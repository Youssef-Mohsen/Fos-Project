
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 f0 17 00 	lgdtl  0x17f018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 f0 17 f0       	mov    $0xf017f000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 78 0b 6c f0 01 	movl   $0x1,0xf06c0b78
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 c4 0a 6c f0 01 	movl   $0x1,0xf06c0ac4
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba b0 b7 b0 f0       	mov    $0xf0b0b7b0,%edx
f010006a:	b8 84 78 69 f0       	mov    $0xf0697884,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 84 78 69 f0       	push   $0xf0697884
f010007e:	e8 33 fd 01 00       	call   f011fdb6 <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 e0 24 12 f0       	push   $0xf01224e0
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 27 25 12 f0       	push   $0xf0122527
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 3b 25 12 f0       	push   $0xf012253b
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 4f 25 12 f0       	push   $0xf012254f
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 3c 70 00 00       	call   f0107116 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 5b 25 12 f0       	push   $0xf012255b
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 63 25 12 f0       	push   $0xf0122563
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 81 79 00 00       	call   f0107a83 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 22 75 00 00       	call   f0107629 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 c2 7c 00 00       	call   f0107dce <initialize_paging>
		sharing_init();
f010010c:	e8 33 89 00 00       	call   f0108a44 <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 1f 91 00 00       	call   f0109247 <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 4f f4 00 00       	call   f010f57f <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 38 f5 00 00       	call   f010f67c <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 13 f5 00 00       	call   f010f664 <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 33 f5 00 00       	call   f010f694 <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 a4 01 02 00       	call   f012030d <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 71 25 12 f0       	push   $0xf0122571
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 b9 ab 00 00       	call   f010ad37 <env_init>
		ts_init();
f010017e:	e8 9d cd 00 00       	call   f010cf20 <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 5b 25 12 f0       	push   $0xf012255b
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 84 25 12 f0       	push   $0xf0122584
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 5a 6c 00 00       	call   f0106e02 <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 ad 25 12 f0       	push   $0xf01225ad
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 32 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 c3 25 12 f0       	push   $0xf01225c3
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 15 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 e0 25 12 f0       	push   $0xf01225e0
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 f8 6d 00 00       	call   f0106ff4 <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 ff 25 12 f0       	push   $0xf01225ff
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 1c 26 12 f0       	push   $0xf012261c
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 d4 49 00 00       	call   f0104bf8 <kclock_init>
		sched_init() ;
f0100224:	e8 04 65 00 00       	call   f010672d <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 40 26 12 f0       	push   $0xf0122640
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 f0 17 f0       	mov    $0xf017f000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 60 26 12 f0       	push   $0xf0122660
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 84 26 12 f0       	push   $0xf0122684
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 bc 0d 6c f0 00 	movl   $0x0,0xf06c0dbc
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 cc 26 12 f0       	push   $0xf01226cc
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 f8 26 12 f0       	push   $0xf01226f8
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 1d 27 12 f0       	push   $0xf012271d
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 24 27 12 f0       	push   $0xf0122724
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 6c 27 12 f0       	push   $0xf012276c
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 b4 27 12 f0       	push   $0xf01227b4
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 6c 27 12 f0       	push   $0xf012276c
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 24 27 12 f0       	push   $0xf0122724
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 f9 27 12 f0       	push   $0xf01227f9
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 47 b6 00 00       	call   f010b98b <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 a0 78 69 f0       	mov    %eax,0xf06978a0

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 00 28 12 f0       	push   $0xf0122800
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 25 28 12 f0       	push   $0xf0122825
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 a3 b5 00 00       	call   f010b949 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 27 28 12 f0       	push   $0xf0122827
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 a0 78 69 f0       	mov    %eax,0xf06978a0

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 31 28 12 f0       	push   $0xf0122831
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 25 28 12 f0       	push   $0xf0122825
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 b2 6d 00 00       	call   f01071cf <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 ea 6c 00 00       	call   f010710c <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 eb 6d 00 00       	call   f0107221 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 94 60 00 00       	call   f01064d5 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 45 b5 00 00       	call   f010b98b <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 ea b4 00 00       	call   f010b949 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 a0 78 69 f0       	mov    %eax,0xf06978a0

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 31 28 12 f0       	push   $0xf0122831
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 25 28 12 f0       	push   $0xf0122825
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 d3 b4 00 00       	call   f010b98b <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 78 b4 00 00       	call   f010b949 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 4a 28 12 f0       	push   $0xf012284a
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 25 28 12 f0       	push   $0xf0122825
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 c4 78 69 f0       	mov    0xf06978c4,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 68 28 12 f0       	push   $0xf0122868
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 c4 78 69 f0       	mov    %eax,0xf06978c4
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 af db 00 00       	call   f010e224 <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 c8 78 69 f0 b4 	movl   $0x3b4,0xf06978c8
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 c8 78 69 f0 d4 	movl   $0x3d4,0xf06978c8
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 c8 78 69 f0       	mov    0xf06978c8,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 c8 78 69 f0       	mov    0xf06978c8,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 c8 78 69 f0       	mov    0xf06978c8,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 c8 78 69 f0       	mov    0xf06978c8,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 cc 78 69 f0       	mov    %eax,0xf06978cc
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 d0 78 69 f0    	mov    %ax,0xf06978d0
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 d0 78 69 f0    	mov    %ax,0xf06978d0
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 cc 78 69 f0    	mov    0xf06978cc,%edx
f010087a:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 d0 78 69 f0    	mov    %ax,0xf06978d0
		text_length = 0;
f01008a6:	c7 05 c0 78 69 f0 00 	movl   $0x0,0xf06978c0
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d d0 78 69 f0 	mov    0xf06978d0,%cx
f01008b7:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 d0 78 69 f0    	mov    %ax,0xf06978d0
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 d0 78 69 f0    	mov    %ax,0xf06978d0
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 d0 78 69 f0    	mov    %ax,0xf06978d0
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d cc 78 69 f0    	mov    0xf06978cc,%ecx
f0100972:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 d0 78 69 f0 	mov    %dx,0xf06978d0
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 c0 78 69 f0    	mov    0xf06978c0,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 c0 78 69 f0       	mov    0xf06978c0,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 c0 78 69 f0       	mov    %eax,0xf06978c0
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 cc 78 69 f0       	mov    0xf06978cc,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 cc 78 69 f0       	mov    0xf06978cc,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 fb f3 01 00       	call   f011fde6 <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 cc 78 69 f0    	mov    0xf06978cc,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 d0 78 69 f0    	mov    %ax,0xf06978d0
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 c8 78 69 f0       	mov    0xf06978c8,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 c8 78 69 f0    	mov    0xf06978c8,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 c8 78 69 f0       	mov    0xf06978c8,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 c8 78 69 f0    	mov    0xf06978c8,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 e8 7a 69 f0       	mov    0xf0697ae8,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 e8 7a 69 f0       	mov    %eax,0xf0697ae8
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 e8 7a 69 f0       	mov    0xf0697ae8,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 f0 17 f0    	mov    -0xfe80fe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 e8 7a 69 f0       	mov    0xf0697ae8,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 e8 7a 69 f0       	mov    %eax,0xf0697ae8
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 e8 7a 69 f0       	mov    0xf0697ae8,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 e8 7a 69 f0       	mov    0xf0697ae8,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 e8 7a 69 f0       	mov    %eax,0xf0697ae8
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 f0 17 f0    	mov    -0xfe80fe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 e8 7a 69 f0       	mov    0xf0697ae8,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 e8 7a 69 f0       	mov    %eax,0xf0697ae8
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 f1 17 f0    	mov    -0xfe80ee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 e8 7a 69 f0       	mov    0xf0697ae8,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 e8 7a 69 f0       	mov    %eax,0xf0697ae8

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 e8 7a 69 f0       	mov    0xf0697ae8,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 f5 17 f0 	mov    -0xfe80ae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 c0 78 69 f0       	mov    0xf06978c0,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 c0 78 69 f0    	mov    0xf06978c0,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 c0 78 69 f0       	mov    0xf06978c0,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 c0 78 69 f0       	mov    %eax,0xf06978c0
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 d0 78 69 f0    	mov    0xf06978d0,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 cc 78 69 f0    	mov    0xf06978cc,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 cc 78 69 f0       	mov    0xf06978cc,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 c0 78 69 f0       	mov    0xf06978c0,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 e8 7a 69 f0       	mov    0xf0697ae8,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 e8 7a 69 f0       	mov    0xf0697ae8,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 e8 7a 69 f0       	mov    0xf0697ae8,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 7b 28 12 f0       	push   $0xf012287b
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 0f d5 00 00       	call   f010e224 <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 e4 7a 69 f0       	mov    0xf0697ae4,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 e4 7a 69 f0    	mov    %edx,0xf0697ae4
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 e0 78 69 f0    	mov    %dl,-0xf968720(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 e4 7a 69 f0       	mov    0xf0697ae4,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 e4 7a 69 f0 00 	movl   $0x0,0xf0697ae4
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 e0 7a 69 f0    	mov    0xf0697ae0,%edx
f0100d7f:	a1 e4 7a 69 f0       	mov    0xf0697ae4,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 e0 7a 69 f0       	mov    0xf0697ae0,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 e0 7a 69 f0    	mov    %edx,0xf0697ae0
f0100d96:	8a 80 e0 78 69 f0    	mov    -0xf968720(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 e0 7a 69 f0       	mov    0xf0697ae0,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 e0 7a 69 f0 00 	movl   $0x0,0xf0697ae0
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 e0 7a 69 f0    	mov    0xf0697ae0,%edx
f0100dd0:	a1 e4 7a 69 f0       	mov    0xf0697ae4,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 e0 7a 69 f0       	mov    0xf0697ae0,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 e0 7a 69 f0    	mov    %edx,0xf0697ae0
f0100de7:	8a 80 e0 78 69 f0    	mov    -0xf968720(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 e0 7a 69 f0       	mov    0xf0697ae0,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 e0 7a 69 f0 00 	movl   $0x0,0xf0697ae0
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 c4 78 69 f0       	mov    0xf06978c4,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 87 28 12 f0       	push   $0xf0122887
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 ff 3d 00 00       	call   f0104cba <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 ca aa 00 00       	call   f010b98b <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 a4 28 12 f0       	push   $0xf01228a4
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 cb 28 12 f0       	push   $0xf01228cb
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 b8 3d 00 00       	call   f0104cba <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 83 aa 00 00       	call   f010b98b <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 e0 28 12 f0       	push   $0xf01228e0
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 cb 28 12 f0       	push   $0xf01228cb
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 83 e5 01 00       	call   f011f506 <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 39 62 00 00       	call   f01071cf <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 6b 62 00 00       	call   f0107221 <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 80 9e 6d f0       	add    $0xf06d9e80,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 d0 eb 01 00       	call   f011fbc8 <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 a0 ee 6d f0       	push   $0xf06deea0
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 d3 ed 01 00       	call   f011fde6 <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 80 9e 6d f0       	add    $0xf06d9e80,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 80 9e 6d f0       	add    $0xf06d9e80,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 0e eb 01 00       	call   f011fbc8 <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 a0 ee 6d f0       	push   $0xf06deea0
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 11 ed 01 00       	call   f011fde6 <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 80 0e 6c f0       	add    $0xf06c0e80,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 4e ec 01 00       	call   f011fdb6 <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 0c 29 12 f0       	push   $0xf012290c
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 0f 29 12 f0       	push   $0xf012290f
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 80 0e 6c f0       	push   $0xf06c0e80
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 f3 e8 01 00       	call   f011fbc8 <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 08 e9 01 00       	call   f011fc17 <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 ab e8 01 00       	call   f011fbc8 <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 1f 29 12 f0       	push   $0xf012291f
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 86 ee 01 00       	call   f01201dd <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 24 29 12 f0       	push   $0xf0122924
f010137e:	50                   	push   %eax
f010137f:	e8 50 e9 01 00       	call   f011fcd4 <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 28 29 12 f0       	push   $0xf0122928
f0101399:	50                   	push   %eax
f010139a:	e8 35 e9 01 00       	call   f011fcd4 <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 2d 29 12 f0       	push   $0xf012292d
f01013b4:	50                   	push   %eax
f01013b5:	e8 1a e9 01 00       	call   f011fcd4 <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 2d 29 12 f0       	push   $0xf012292d
f01013d5:	50                   	push   %eax
f01013d6:	e8 f9 e8 01 00       	call   f011fcd4 <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 a1 e7 01 00       	call   f011fbc8 <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 a3 e7 01 00       	call   f011fc17 <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 82 e7 01 00       	call   f011fc17 <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 ff e6 01 00       	call   f011fbc8 <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 1a e8 01 00       	call   f011fd0c <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 4f e6 01 00       	call   f011fbc8 <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 80 0e 6c f0       	add    $0xf06c0e80,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 1a e8 01 00       	call   f011fdb6 <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 80 0e 6c f0    	add    $0xf06c0e80,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 85 e6 01 00       	call   f011fc45 <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 c5 e5 01 00       	call   f011fbc8 <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d e0 fc 17 f0    	mov    0xf017fce0,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 dd e6 01 00       	call   f011fd0c <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 28 e5 01 00       	call   f011fbc8 <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 c8 e4 01 00       	call   f011fbc8 <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 80 0e 6c f0       	add    $0xf06c0e80,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 93 e6 01 00       	call   f011fdb6 <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 80 0e 6c f0    	add    $0xf06c0e80,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 fe e4 01 00       	call   f011fc45 <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 40 e4 01 00       	call   f011fbc8 <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 5b e5 01 00       	call   f011fd0c <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 a6 e3 01 00       	call   f011fbc8 <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 4c e3 01 00       	call   f011fbc8 <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 80 0e 6c f0       	add    $0xf06c0e80,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 17 e5 01 00       	call   f011fdb6 <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 80 0e 6c f0    	add    $0xf06c0e80,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 82 e3 01 00       	call   f011fc45 <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 b4 fd 17 f0       	mov    0xf017fdb4,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 80 0e 6c f0       	add    $0xf06c0e80,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 80 0e 6c f0       	push   $0xf06c0e80
f0101929:	e8 9a e2 01 00       	call   f011fbc8 <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 41 e2 01 00       	call   f011fbc8 <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 2e e2 01 00       	call   f011fbc8 <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 80 0e 6c f0    	lea    -0xf93f180(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 80 0e 6c f0       	add    $0xf06c0e80,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 d3 e1 01 00       	call   f011fbc8 <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 80 9e 6d f0    	lea    -0xf926180(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 80 9e 6d f0       	add    $0xf06d9e80,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 c8 e1 01 00       	call   f011fde6 <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 80 ea 6d f0       	push   $0xf06dea80
f0101c3a:	e8 a7 e1 01 00       	call   f011fde6 <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 80 9e 6d f0       	add    $0xf06d9e80,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 77 e0 01 00       	call   f011fcd4 <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 f5 17 f0       	mov    %eax,0xf017f530
f0101c6f:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 80 9e 6d f0       	add    $0xf06d9e80,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 59 e1 01 00       	call   f011fde6 <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 bc 0d 6c f0       	mov    0xf06c0dbc,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb 37 29 12 f0       	mov    $0xf0122937,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb 37 2d 12 f0       	mov    $0xf0122d37,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb 37 31 12 f0       	mov    $0xf0123137,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 bc 0d 6c f0 00 	movl   $0x0,0xf06c0dbc
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 38 0d 6c f0 00 	movl   $0x0,0xf06c0d38
f0101d59:	00 00 00 
f0101d5c:	c7 05 3c 0d 6c f0 00 	movl   $0x0,0xf06c0d3c
f0101d63:	00 00 00 
f0101d66:	c7 05 44 0d 6c f0 00 	movl   $0x0,0xf06c0d44
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 30 e0 01 00       	call   f011fdb6 <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 31 29 12 f0       	push   $0xf0122931
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 39 9e 00 00       	call   f010bc18 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 28 53 00 00       	call   f010710c <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 60 0e 6c f0       	mov    %eax,0xf06c0e60
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 80 ee 6d f0       	mov    %eax,0xf06dee80
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 60 0e 6c f0       	mov    0xf06c0e60,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 60 0e 6c f0    	mov    %edx,0xf06c0e60
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 80 ee 6d f0       	mov    0xf06dee80,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 80 ee 6d f0       	mov    %eax,0xf06dee80
f0101e98:	a1 80 ee 6d f0       	mov    0xf06dee80,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 60 0e 6c f0       	mov    %eax,0xf06c0e60
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 80 ee 6d f0       	mov    %eax,0xf06dee80
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 60 0e 6c f0       	mov    0xf06c0e60,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 60 0e 6c f0    	mov    %edx,0xf06c0e60
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 80 ee 6d f0       	mov    0xf06dee80,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 80 ee 6d f0       	mov    %eax,0xf06dee80
f0101ed4:	a1 80 ee 6d f0       	mov    0xf06dee80,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 1f 29 12 f0       	push   $0xf012291f
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 c7 e2 01 00       	call   f01201dd <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 37 35 12 f0       	push   $0xf0123537
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 44 0d 6c f0       	mov    0xf06c0d44,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 50 35 12 f0       	push   $0xf0123550
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 a1 35 12 f0       	push   $0xf01235a1
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 38 0d 6c f0       	mov    0xf06c0d38,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 bc 35 12 f0       	push   $0xf01235bc
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 44 0d 6c f0       	mov    0xf06c0d44,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 ec 35 12 f0       	push   $0xf01235ec
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 a1 35 12 f0       	push   $0xf01235a1
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 38 0d 6c f0       	mov    0xf06c0d38,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 16 36 12 f0       	push   $0xf0123616
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 40 0d 6c f0       	mov    0xf06c0d40,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 40 0d 6c f0       	mov    %eax,0xf06c0d40
f010203b:	a1 40 0d 6c f0       	mov    0xf06c0d40,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 20 36 12 f0       	push   $0xf0123620
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 38 0d 6c f0       	mov    0xf06c0d38,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 83 36 12 f0       	push   $0xf0123683
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 8c 36 12 f0       	push   $0xf012368c
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 40 0d 6c f0       	mov    0xf06c0d40,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 40 0d 6c f0       	mov    %eax,0xf06c0d40
f010218b:	a1 40 0d 6c f0       	mov    0xf06c0d40,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 f5 17 f0       	add    $0xf017f548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 38 0d 6c f0       	mov    0xf06c0d38,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 94 36 12 f0       	push   $0xf0123694
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 a1 35 12 f0       	push   $0xf01235a1
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 3c 0d 6c f0       	mov    %eax,0xf06c0d3c
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 38 0d 6c f0       	mov    %eax,0xf06c0d38
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 44 0d 6c f0       	mov    0xf06c0d44,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 44 0d 6c f0       	mov    %eax,0xf06c0d44

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 40 0d 6c f0       	mov    0xf06c0d40,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 40 0d 6c f0       	mov    %eax,0xf06c0d40
f0102292:	a1 40 0d 6c f0       	mov    0xf06c0d40,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 f6 d9 01 00       	call   f011fcd4 <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c f5 17 f0       	add    $0xf017f54c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c f5 17 f0       	add    $0xf017f54c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 38 0d 6c f0    	mov    0xf06c0d38,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 38 0d 6c f0    	mov    0xf06c0d38,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010238d:	a3 3c 0d 6c f0       	mov    %eax,0xf06c0d3c
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01023a3:	a3 38 0d 6c f0       	mov    %eax,0xf06c0d38
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 f5 17 f0       	add    $0xf017f554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 44 0d 6c f0       	mov    0xf06c0d44,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 44 0d 6c f0       	mov    %eax,0xf06c0d44
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 38 0d 6c f0    	mov    0xf06c0d38,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 38 0d 6c f0    	mov    0xf06c0d38,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010248c:	a3 3c 0d 6c f0       	mov    %eax,0xf06c0d3c
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01024a2:	a3 38 0d 6c f0       	mov    %eax,0xf06c0d38
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 f5 17 f0       	add    $0xf017f554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 44 0d 6c f0       	mov    0xf06c0d44,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 44 0d 6c f0       	mov    %eax,0xf06c0d44
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 78 0b 6c f0 00 	movl   $0x0,0xf06c0b78
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 78 0b 6c f0 01 	movl   $0x1,0xf06c0b78
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 78 0b 6c f0 02 	movl   $0x2,0xf06c0b78
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 78 0b 6c f0 03 	movl   $0x3,0xf06c0b78
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 78 0b 6c f0 04 	movl   $0x4,0xf06c0b78
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 78 0b 6c f0       	mov    0xf06c0b78,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 78 0b 6c f0       	mov    0xf06c0b78,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 78 0b 6c f0       	mov    0xf06c0b78,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 78 0b 6c f0       	mov    0xf06c0b78,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 78 0b 6c f0       	mov    0xf06c0b78,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 c4 0a 6c f0 01 	movl   $0x1,0xf06c0ac4
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 c4 0a 6c f0 02 	movl   $0x2,0xf06c0ac4
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 c4 0a 6c f0 03 	movl   $0x3,0xf06c0ac4
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 c4 0a 6c f0 04 	movl   $0x4,0xf06c0ac4
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 c4 0a 6c f0       	mov    0xf06c0ac4,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 c4 0a 6c f0       	mov    0xf06c0ac4,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 c4 0a 6c f0       	mov    0xf06c0ac4,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 c4 0a 6c f0       	mov    0xf06c0ac4,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 b4 36 12 f0       	push   $0xf01236b4
f0102662:	6a 56                	push   $0x56
f0102664:	68 dc 36 12 f0       	push   $0xf01236dc
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 e0 0a 6c f0    	mov    0xf06c0ae0,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 f5 17 f0       	add    $0xf017f544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 5f 3f 12 f0       	push   $0xf0123f5f
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 68 3f 12 f0       	push   $0xf0123f68
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d e0 fc 17 f0    	mov    0xf017fce0,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 7d 3f 12 f0       	push   $0xf0123f7d
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 99 3f 12 f0       	push   $0xf0123f99
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 b4 3f 12 f0       	push   $0xf0123fb4
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 c5 24 12 00       	mov    $0x1224c5,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 c5 24 12 f0       	push   $0xf01224c5
f010278e:	68 f0 3f 12 f0       	push   $0xf0123ff0
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 84 78 69 00       	mov    $0x697884,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 84 78 69 f0       	push   $0xf0697884
f01027a9:	68 2c 40 12 f0       	push   $0xf012402c
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 b0 b7 b0 00       	mov    $0xb0b7b0,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 b0 b7 b0 f0       	push   $0xf0b0b7b0
f01027c4:	68 74 40 12 f0       	push   $0xf0124074
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 b0 b7 b0 f0       	mov    $0xf0b0b7b0,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 b0 40 12 f0       	push   $0xf01240b0
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 fe d6 01 00       	call   f011ff28 <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 bd d6 01 00       	call   f011ff28 <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 52 91 00 00       	call   f010b9db <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 87 d6 01 00       	call   f011ff28 <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 dc 40 12 f0       	push   $0xf01240dc
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 01 d6 01 00       	call   f011ff28 <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 7e d2 01 00       	call   f011fbc8 <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 83 d5 01 00       	call   f011ff28 <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 06 41 12 f0       	push   $0xf0124106
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 37 d5 01 00       	call   f011ff28 <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 cc 8f 00 00       	call   f010b9db <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 01 d5 01 00       	call   f011ff28 <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 06 41 12 f0       	push   $0xf0124106
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 20 41 12 f0       	push   $0xf0124120
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 70 d4 01 00       	call   f011ff28 <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 4a 41 12 f0       	push   $0xf012414a
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 4d 41 12 f0       	push   $0xf012414d
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 13 d4 01 00       	call   f011ff28 <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 a8 8e 00 00       	call   f010b9db <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 dd d3 01 00       	call   f011ff28 <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 c2 d3 01 00       	call   f011ff28 <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 4f 41 12 f0       	push   $0xf012414f
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 26 d3 01 00       	call   f011ff28 <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 bb 8d 00 00       	call   f010b9db <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 df d2 01 00       	call   f011ff28 <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 af 6b 00 00       	call   f0109834 <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 60 6a 00 00       	call   f01096f1 <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 4b 56 00 00       	call   f0108306 <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 60 41 12 f0       	push   $0xf0124160
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 ea d1 01 00       	call   f011ff28 <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 7f 8c 00 00       	call   f010b9db <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 a3 d1 01 00       	call   f011ff28 <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 1b 54 00 00       	call   f01081b2 <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 8a 41 12 f0       	push   $0xf012418a
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 a7 58 00 00       	call   f010867f <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 a4 41 12 f0       	push   $0xf01241a4
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 18 58 00 00       	call   f010867f <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 dc 5a 00 00       	call   f0108961 <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 e8 41 12 f0       	push   $0xf01241e8
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 90 0c 6c f0       	mov    0xf06c0c90,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 40 42 12 f0       	push   $0xf0124240
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102ef6:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ef9:	83 f8 04             	cmp    $0x4,%eax
f0102efc:	0f 84 94 00 00 00    	je     f0102f96 <CreateEnv+0xc2>
f0102f02:	83 f8 05             	cmp    $0x5,%eax
f0102f05:	74 0e                	je     f0102f15 <CreateEnv+0x41>
f0102f07:	83 f8 03             	cmp    $0x3,%eax
f0102f0a:	0f 84 ec 00 00 00    	je     f0102ffc <CreateEnv+0x128>
f0102f10:	e9 2f 01 00 00       	jmp    f0103044 <CreateEnv+0x170>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f15:	83 ec 0c             	sub    $0xc,%esp
f0102f18:	6a 02                	push   $0x2
f0102f1a:	e8 a8 c6 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f0102f1f:	83 c4 10             	add    $0x10,%esp
f0102f22:	85 c0                	test   %eax,%eax
f0102f24:	75 1a                	jne    f0102f40 <CreateEnv+0x6c>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f26:	83 ec 0c             	sub    $0xc,%esp
f0102f29:	68 7c 42 12 f0       	push   $0xf012427c
f0102f2e:	e8 58 e0 ff ff       	call   f0100f8b <cprintf>
f0102f33:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f36:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f3b:	e9 ff 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f43:	83 c0 10             	add    $0x10,%eax
f0102f46:	8b 00                	mov    (%eax),%eax
f0102f48:	83 ec 04             	sub    $0x4,%esp
f0102f4b:	6a 0a                	push   $0xa
f0102f4d:	6a 00                	push   $0x0
f0102f4f:	50                   	push   %eax
f0102f50:	e8 d3 cf 01 00       	call   f011ff28 <strtol>
f0102f55:	83 c4 10             	add    $0x10,%esp
f0102f58:	89 45 ec             	mov    %eax,-0x14(%ebp)
			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f5e:	83 c0 0c             	add    $0xc,%eax
f0102f61:	8b 00                	mov    (%eax),%eax
f0102f63:	83 ec 04             	sub    $0x4,%esp
f0102f66:	6a 0a                	push   $0xa
f0102f68:	6a 00                	push   $0x0
f0102f6a:	50                   	push   %eax
f0102f6b:	e8 b8 cf 01 00       	call   f011ff28 <strtol>
f0102f70:	83 c4 10             	add    $0x10,%esp
f0102f73:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 08             	add    $0x8,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 9d cf 01 00       	call   f011ff28 <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102f91:	e9 c8 00 00 00       	jmp    f010305e <CreateEnv+0x18a>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f96:	83 ec 0c             	sub    $0xc,%esp
f0102f99:	6a 02                	push   $0x2
f0102f9b:	e8 27 c6 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f0102fa0:	83 c4 10             	add    $0x10,%esp
f0102fa3:	85 c0                	test   %eax,%eax
f0102fa5:	75 1d                	jne    f0102fc4 <CreateEnv+0xf0>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faa:	83 c0 0c             	add    $0xc,%eax
f0102fad:	8b 00                	mov    (%eax),%eax
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	6a 0a                	push   $0xa
f0102fb4:	6a 00                	push   $0x0
f0102fb6:	50                   	push   %eax
f0102fb7:	e8 6c cf 01 00       	call   f011ff28 <strtol>
f0102fbc:	83 c4 10             	add    $0x10,%esp
f0102fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102fc2:	eb 1b                	jmp    f0102fdf <CreateEnv+0x10b>
			}
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fc7:	83 c0 0c             	add    $0xc,%eax
f0102fca:	8b 00                	mov    (%eax),%eax
f0102fcc:	83 ec 04             	sub    $0x4,%esp
f0102fcf:	6a 0a                	push   $0xa
f0102fd1:	6a 00                	push   $0x0
f0102fd3:	50                   	push   %eax
f0102fd4:	e8 4f cf 01 00       	call   f011ff28 <strtol>
f0102fd9:	83 c4 10             	add    $0x10,%esp
f0102fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe2:	83 c0 08             	add    $0x8,%eax
f0102fe5:	8b 00                	mov    (%eax),%eax
f0102fe7:	83 ec 04             	sub    $0x4,%esp
f0102fea:	6a 0a                	push   $0xa
f0102fec:	6a 00                	push   $0x0
f0102fee:	50                   	push   %eax
f0102fef:	e8 34 cf 01 00       	call   f011ff28 <strtol>
f0102ff4:	83 c4 10             	add    $0x10,%esp
f0102ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102ffa:	eb 62                	jmp    f010305e <CreateEnv+0x18a>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102ffc:	83 ec 0c             	sub    $0xc,%esp
f0102fff:	6a 02                	push   $0x2
f0103001:	e8 c1 c5 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f0103006:	83 c4 10             	add    $0x10,%esp
f0103009:	85 c0                	test   %eax,%eax
f010300b:	74 1a                	je     f0103027 <CreateEnv+0x153>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f010300d:	83 ec 0c             	sub    $0xc,%esp
f0103010:	68 28 43 12 f0       	push   $0xf0124328
f0103015:	e8 71 df ff ff       	call   f0100f8b <cprintf>
f010301a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f010301d:	b8 00 00 00 00       	mov    $0x0,%eax
f0103022:	e9 18 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103027:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302a:	83 c0 08             	add    $0x8,%eax
f010302d:	8b 00                	mov    (%eax),%eax
f010302f:	83 ec 04             	sub    $0x4,%esp
f0103032:	6a 0a                	push   $0xa
f0103034:	6a 00                	push   $0x0
f0103036:	50                   	push   %eax
f0103037:	e8 ec ce 01 00       	call   f011ff28 <strtol>
f010303c:	83 c4 10             	add    $0x10,%esp
f010303f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103042:	eb 1a                	jmp    f010305e <CreateEnv+0x18a>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103044:	83 ec 0c             	sub    $0xc,%esp
f0103047:	68 b8 43 12 f0       	push   $0xf01243b8
f010304c:	e8 3a df ff ff       	call   f0100f8b <cprintf>
f0103051:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103054:	b8 00 00 00 00       	mov    $0x0,%eax
f0103059:	e9 e1 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010305e:	83 ec 0c             	sub    $0xc,%esp
f0103061:	6a 02                	push   $0x2
f0103063:	e8 5f c5 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f0103068:	83 c4 10             	add    $0x10,%esp
f010306b:	85 c0                	test   %eax,%eax
f010306d:	74 23                	je     f0103092 <CreateEnv+0x1be>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f010306f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103072:	48                   	dec    %eax
f0103073:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103076:	73 1a                	jae    f0103092 <CreateEnv+0x1be>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103078:	83 ec 0c             	sub    $0xc,%esp
f010307b:	68 50 44 12 f0       	push   $0xf0124450
f0103080:	e8 06 df ff ff       	call   f0100f8b <cprintf>
f0103085:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103088:	b8 00 00 00 00       	mov    $0x0,%eax
f010308d:	e9 ad 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103092:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f0103096:	76 19                	jbe    f01030b1 <CreateEnv+0x1dd>
f0103098:	68 a8 44 12 f0       	push   $0xf01244a8
f010309d:	68 ed 44 12 f0       	push   $0xf01244ed
f01030a2:	68 a4 01 00 00       	push   $0x1a4
f01030a7:	68 02 45 12 f0       	push   $0xf0124502
f01030ac:	e8 88 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030b1:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f01030b5:	76 19                	jbe    f01030d0 <CreateEnv+0x1fc>
f01030b7:	68 a8 44 12 f0       	push   $0xf01244a8
f01030bc:	68 ed 44 12 f0       	push   $0xf01244ed
f01030c1:	68 c0 01 00 00       	push   $0x1c0
f01030c6:	68 02 45 12 f0       	push   $0xf0124502
f01030cb:	e8 69 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f01030d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030d3:	83 c0 04             	add    $0x4,%eax
f01030d6:	8b 00                	mov    (%eax),%eax
f01030d8:	ff 75 e8             	pushl  -0x18(%ebp)
f01030db:	ff 75 f0             	pushl  -0x10(%ebp)
f01030de:	ff 75 f4             	pushl  -0xc(%ebp)
f01030e1:	50                   	push   %eax
f01030e2:	e8 26 7e 00 00       	call   f010af0d <env_create>
f01030e7:	83 c4 10             	add    $0x10,%esp
f01030ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f01030ed:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f01030f1:	74 49                	je     f010313c <CreateEnv+0x268>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f01030f3:	83 ec 08             	sub    $0x8,%esp
f01030f6:	ff 75 ec             	pushl  -0x14(%ebp)
f01030f9:	68 16 45 12 f0       	push   $0xf0124516
f01030fe:	e8 88 de ff ff       	call   f0100f8b <cprintf>
f0103103:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103106:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010310a:	7c 06                	jl     f0103112 <CreateEnv+0x23e>
f010310c:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103110:	7e 19                	jle    f010312b <CreateEnv+0x257>
f0103112:	68 28 45 12 f0       	push   $0xf0124528
f0103117:	68 ed 44 12 f0       	push   $0xf01244ed
f010311c:	68 c5 01 00 00       	push   $0x1c5
f0103121:	68 02 45 12 f0       	push   $0xf0124502
f0103126:	e8 0e d2 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f010312b:	83 ec 08             	sub    $0x8,%esp
f010312e:	ff 75 ec             	pushl  -0x14(%ebp)
f0103131:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103134:	e8 4d 35 00 00       	call   f0106686 <env_set_nice>
f0103139:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f010313c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010313f:	c9                   	leave  
f0103140:	c3                   	ret    

f0103141 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103141:	55                   	push   %ebp
f0103142:	89 e5                	mov    %esp,%ebp
f0103144:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103147:	83 ec 08             	sub    $0x8,%esp
f010314a:	ff 75 0c             	pushl  0xc(%ebp)
f010314d:	ff 75 08             	pushl  0x8(%ebp)
f0103150:	e8 7f fd ff ff       	call   f0102ed4 <CreateEnv>
f0103155:	83 c4 10             	add    $0x10,%esp
f0103158:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f010315b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010315f:	75 07                	jne    f0103168 <command_run_program+0x27>
f0103161:	b8 00 00 00 00       	mov    $0x0,%eax
f0103166:	eb 46                	jmp    f01031ae <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103168:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010316b:	8b 40 10             	mov    0x10(%eax),%eax
f010316e:	83 ec 08             	sub    $0x8,%esp
f0103171:	50                   	push   %eax
f0103172:	68 58 45 12 f0       	push   $0xf0124558
f0103177:	e8 0f de ff ff       	call   f0100f8b <cprintf>
f010317c:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f010317f:	83 ec 0c             	sub    $0xc,%esp
f0103182:	ff 75 f4             	pushl  -0xc(%ebp)
f0103185:	e8 92 25 00 00       	call   f010571c <sched_new_env>
f010318a:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f010318d:	c7 05 90 0c 6c f0 00 	movl   $0x0,0xf06c0c90
f0103194:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103197:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010319a:	8b 40 10             	mov    0x10(%eax),%eax
f010319d:	83 ec 0c             	sub    $0xc,%esp
f01031a0:	50                   	push   %eax
f01031a1:	e8 cc 25 00 00       	call   f0105772 <sched_run_env>
f01031a6:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031ae:	c9                   	leave  
f01031af:	c3                   	ret    

f01031b0 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f01031b0:	55                   	push   %ebp
f01031b1:	89 e5                	mov    %esp,%ebp
f01031b3:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01031b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031b9:	83 c0 04             	add    $0x4,%eax
f01031bc:	8b 00                	mov    (%eax),%eax
f01031be:	83 ec 04             	sub    $0x4,%esp
f01031c1:	6a 0a                	push   $0xa
f01031c3:	6a 00                	push   $0x0
f01031c5:	50                   	push   %eax
f01031c6:	e8 5d cd 01 00       	call   f011ff28 <strtol>
f01031cb:	83 c4 10             	add    $0x10,%esp
f01031ce:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f01031d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031d4:	83 ec 0c             	sub    $0xc,%esp
f01031d7:	50                   	push   %eax
f01031d8:	e8 db 28 00 00       	call   f0105ab8 <sched_kill_env>
f01031dd:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031e5:	c9                   	leave  
f01031e6:	c3                   	ret    

f01031e7 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f01031e7:	55                   	push   %ebp
f01031e8:	89 e5                	mov    %esp,%ebp
f01031ea:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ed:	83 ec 08             	sub    $0x8,%esp
f01031f0:	ff 75 0c             	pushl  0xc(%ebp)
f01031f3:	ff 75 08             	pushl  0x8(%ebp)
f01031f6:	e8 d9 fc ff ff       	call   f0102ed4 <CreateEnv>
f01031fb:	83 c4 10             	add    $0x10,%esp
f01031fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103201:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103205:	75 07                	jne    f010320e <commnad_load_env+0x27>
		return 0 ;
f0103207:	b8 00 00 00 00       	mov    $0x0,%eax
f010320c:	eb 2a                	jmp    f0103238 <commnad_load_env+0x51>

	sched_new_env(env) ;
f010320e:	83 ec 0c             	sub    $0xc,%esp
f0103211:	ff 75 f4             	pushl  -0xc(%ebp)
f0103214:	e8 03 25 00 00       	call   f010571c <sched_new_env>
f0103219:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010321c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321f:	8b 40 10             	mov    0x10(%eax),%eax
f0103222:	83 ec 08             	sub    $0x8,%esp
f0103225:	50                   	push   %eax
f0103226:	68 58 45 12 f0       	push   $0xf0124558
f010322b:	e8 5b dd ff ff       	call   f0100f8b <cprintf>
f0103230:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103233:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103238:	c9                   	leave  
f0103239:	c3                   	ret    

f010323a <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f010323a:	55                   	push   %ebp
f010323b:	89 e5                	mov    %esp,%ebp
f010323d:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103240:	c7 05 90 0c 6c f0 00 	movl   $0x0,0xf06c0c90
f0103247:	00 00 00 
	sched_run_all();
f010324a:	e8 26 2e 00 00       	call   f0106075 <sched_run_all>

	return 0 ;
f010324f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103254:	c9                   	leave  
f0103255:	c3                   	ret    

f0103256 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103256:	55                   	push   %ebp
f0103257:	89 e5                	mov    %esp,%ebp
f0103259:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f010325c:	e8 f3 2b 00 00       	call   f0105e54 <sched_print_all>

	return 0 ;
f0103261:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103266:	c9                   	leave  
f0103267:	c3                   	ret    

f0103268 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103268:	55                   	push   %ebp
f0103269:	89 e5                	mov    %esp,%ebp
f010326b:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f010326e:	e8 97 2e 00 00       	call   f010610a <sched_kill_all>

	return 0 ;
f0103273:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103278:	c9                   	leave  
f0103279:	c3                   	ret    

f010327a <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f010327a:	55                   	push   %ebp
f010327b:	89 e5                	mov    %esp,%ebp
f010327d:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103280:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103284:	7f 1a                	jg     f01032a0 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103286:	83 ec 0c             	sub    $0xc,%esp
f0103289:	68 70 45 12 f0       	push   $0xf0124570
f010328e:	e8 f8 dc ff ff       	call   f0100f8b <cprintf>
f0103293:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103296:	b8 00 00 00 00       	mov    $0x0,%eax
f010329b:	e9 83 00 00 00       	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f01032a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032a3:	83 c0 04             	add    $0x4,%eax
f01032a6:	8b 00                	mov    (%eax),%eax
f01032a8:	83 ec 04             	sub    $0x4,%esp
f01032ab:	6a 0a                	push   $0xa
f01032ad:	6a 00                	push   $0x0
f01032af:	50                   	push   %eax
f01032b0:	e8 73 cc 01 00       	call   f011ff28 <strtol>
f01032b5:	83 c4 10             	add    $0x10,%esp
f01032b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f01032bb:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01032bf:	75 20                	jne    f01032e1 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032c1:	83 ec 0c             	sub    $0xc,%esp
f01032c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01032c7:	e8 70 c2 00 00       	call   f010f53c <setPageReplacmentAlgorithmLRU>
f01032cc:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f01032cf:	83 ec 0c             	sub    $0xc,%esp
f01032d2:	68 d0 45 12 f0       	push   $0xf01245d0
f01032d7:	e8 af dc ff ff       	call   f0100f8b <cprintf>
f01032dc:	83 c4 10             	add    $0x10,%esp
f01032df:	eb 3d                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f01032e1:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01032e5:	75 20                	jne    f0103307 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032e7:	83 ec 0c             	sub    $0xc,%esp
f01032ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01032ed:	e8 4a c2 00 00       	call   f010f53c <setPageReplacmentAlgorithmLRU>
f01032f2:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f01032f5:	83 ec 0c             	sub    $0xc,%esp
f01032f8:	68 14 46 12 f0       	push   $0xf0124614
f01032fd:	e8 89 dc ff ff       	call   f0100f8b <cprintf>
f0103302:	83 c4 10             	add    $0x10,%esp
f0103305:	eb 17                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103307:	83 ec 0c             	sub    $0xc,%esp
f010330a:	68 54 46 12 f0       	push   $0xf0124654
f010330f:	e8 77 dc ff ff       	call   f0100f8b <cprintf>
f0103314:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103317:	b8 00 00 00 00       	mov    $0x0,%eax
f010331c:	eb 05                	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f010331e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103323:	c9                   	leave  
f0103324:	c3                   	ret    

f0103325 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103325:	55                   	push   %ebp
f0103326:	89 e5                	mov    %esp,%ebp
f0103328:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f010332b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010332e:	83 c0 04             	add    $0x4,%eax
f0103331:	8b 00                	mov    (%eax),%eax
f0103333:	83 ec 04             	sub    $0x4,%esp
f0103336:	6a 0a                	push   $0xa
f0103338:	6a 00                	push   $0x0
f010333a:	50                   	push   %eax
f010333b:	e8 e8 cb 01 00       	call   f011ff28 <strtol>
f0103340:	83 c4 10             	add    $0x10,%esp
f0103343:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103346:	83 ec 0c             	sub    $0xc,%esp
f0103349:	ff 75 f4             	pushl  -0xc(%ebp)
f010334c:	e8 5e c2 00 00       	call   f010f5af <setPageReplacmentAlgorithmNchanceCLOCK>
f0103351:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103354:	83 ec 0c             	sub    $0xc,%esp
f0103357:	68 a8 46 12 f0       	push   $0xf01246a8
f010335c:	e8 2a dc ff ff       	call   f0100f8b <cprintf>
f0103361:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103364:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103369:	c9                   	leave  
f010336a:	c3                   	ret    

f010336b <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010336b:	55                   	push   %ebp
f010336c:	89 e5                	mov    %esp,%ebp
f010336e:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103371:	e8 f9 c1 00 00       	call   f010f56f <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103376:	83 ec 0c             	sub    $0xc,%esp
f0103379:	68 dc 46 12 f0       	push   $0xf01246dc
f010337e:	e8 08 dc ff ff       	call   f0100f8b <cprintf>
f0103383:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103386:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010338b:	c9                   	leave  
f010338c:	c3                   	ret    

f010338d <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f010338d:	55                   	push   %ebp
f010338e:	89 e5                	mov    %esp,%ebp
f0103390:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103393:	e8 e7 c1 00 00       	call   f010f57f <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0103398:	83 ec 0c             	sub    $0xc,%esp
f010339b:	68 08 47 12 f0       	push   $0xf0124708
f01033a0:	e8 e6 db ff ff       	call   f0100f8b <cprintf>
f01033a5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033ad:	c9                   	leave  
f01033ae:	c3                   	ret    

f01033af <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01033af:	55                   	push   %ebp
f01033b0:	89 e5                	mov    %esp,%ebp
f01033b2:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01033b5:	e8 d5 c1 00 00       	call   f010f58f <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01033ba:	83 ec 0c             	sub    $0xc,%esp
f01033bd:	68 30 47 12 f0       	push   $0xf0124730
f01033c2:	e8 c4 db ff ff       	call   f0100f8b <cprintf>
f01033c7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033cf:	c9                   	leave  
f01033d0:	c3                   	ret    

f01033d1 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01033d1:	55                   	push   %ebp
f01033d2:	89 e5                	mov    %esp,%ebp
f01033d4:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01033d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033da:	83 c0 04             	add    $0x4,%eax
f01033dd:	8b 00                	mov    (%eax),%eax
f01033df:	83 ec 04             	sub    $0x4,%esp
f01033e2:	6a 0a                	push   $0xa
f01033e4:	6a 00                	push   $0x0
f01033e6:	50                   	push   %eax
f01033e7:	e8 3c cb 01 00       	call   f011ff28 <strtol>
f01033ec:	83 c4 10             	add    $0x10,%esp
f01033ef:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01033f2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033f6:	83 ec 0c             	sub    $0xc,%esp
f01033f9:	50                   	push   %eax
f01033fa:	e8 a8 35 00 00       	call   f01069a7 <sched_init_RR>
f01033ff:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0103402:	a1 a4 09 6c f0       	mov    0xf06c09a4,%eax
f0103407:	8a 00                	mov    (%eax),%al
f0103409:	0f b6 c0             	movzbl %al,%eax
f010340c:	83 ec 08             	sub    $0x8,%esp
f010340f:	50                   	push   %eax
f0103410:	68 64 47 12 f0       	push   $0xf0124764
f0103415:	e8 71 db ff ff       	call   f0100f8b <cprintf>
f010341a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010341d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103422:	c9                   	leave  
f0103423:	c3                   	ret    

f0103424 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103424:	55                   	push   %ebp
f0103425:	89 e5                	mov    %esp,%ebp
f0103427:	53                   	push   %ebx
f0103428:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010342b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010342e:	83 c0 04             	add    $0x4,%eax
f0103431:	8b 00                	mov    (%eax),%eax
f0103433:	83 ec 04             	sub    $0x4,%esp
f0103436:	6a 0a                	push   $0xa
f0103438:	6a 00                	push   $0x0
f010343a:	50                   	push   %eax
f010343b:	e8 e8 ca 01 00       	call   f011ff28 <strtol>
f0103440:	83 c4 10             	add    $0x10,%esp
f0103443:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103446:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f010344d:	eb 2e                	jmp    f010347d <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f010344f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103452:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103458:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010345f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103462:	01 d0                	add    %edx,%eax
f0103464:	8b 00                	mov    (%eax),%eax
f0103466:	83 ec 04             	sub    $0x4,%esp
f0103469:	6a 0a                	push   $0xa
f010346b:	6a 00                	push   $0x0
f010346d:	50                   	push   %eax
f010346e:	e8 b5 ca 01 00       	call   f011ff28 <strtol>
f0103473:	83 c4 10             	add    $0x10,%esp
f0103476:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010347a:	ff 45 f4             	incl   -0xc(%ebp)
f010347d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103480:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103483:	7c ca                	jl     f010344f <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103485:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0103489:	83 ec 08             	sub    $0x8,%esp
f010348c:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f010348f:	52                   	push   %edx
f0103490:	50                   	push   %eax
f0103491:	e8 bf 35 00 00       	call   f0106a55 <sched_init_MLFQ>
f0103496:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f0103499:	83 ec 0c             	sub    $0xc,%esp
f010349c:	68 9c 47 12 f0       	push   $0xf012479c
f01034a1:	e8 e5 da ff ff       	call   f0100f8b <cprintf>
f01034a6:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01034b0:	eb 24                	jmp    f01034d6 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01034b2:	8b 15 a4 09 6c f0    	mov    0xf06c09a4,%edx
f01034b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01034bb:	01 d0                	add    %edx,%eax
f01034bd:	8a 00                	mov    (%eax),%al
f01034bf:	0f b6 c0             	movzbl %al,%eax
f01034c2:	83 ec 08             	sub    $0x8,%esp
f01034c5:	50                   	push   %eax
f01034c6:	68 c9 47 12 f0       	push   $0xf01247c9
f01034cb:	e8 bb da ff ff       	call   f0100f8b <cprintf>
f01034d0:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034d3:	ff 45 f0             	incl   -0x10(%ebp)
f01034d6:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f01034db:	0f b6 c0             	movzbl %al,%eax
f01034de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01034e1:	7f cf                	jg     f01034b2 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01034e3:	83 ec 0c             	sub    $0xc,%esp
f01034e6:	68 4d 41 12 f0       	push   $0xf012414d
f01034eb:	e8 9b da ff ff       	call   f0100f8b <cprintf>
f01034f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01034fb:	c9                   	leave  
f01034fc:	c3                   	ret    

f01034fd <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01034fd:	55                   	push   %ebp
f01034fe:	89 e5                	mov    %esp,%ebp
f0103500:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103503:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103506:	83 c0 04             	add    $0x4,%eax
f0103509:	8b 00                	mov    (%eax),%eax
f010350b:	83 ec 04             	sub    $0x4,%esp
f010350e:	6a 0a                	push   $0xa
f0103510:	6a 00                	push   $0x0
f0103512:	50                   	push   %eax
f0103513:	e8 10 ca 01 00       	call   f011ff28 <strtol>
f0103518:	83 c4 10             	add    $0x10,%esp
f010351b:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f010351e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103521:	83 c0 08             	add    $0x8,%eax
f0103524:	8b 00                	mov    (%eax),%eax
f0103526:	83 ec 04             	sub    $0x4,%esp
f0103529:	6a 0a                	push   $0xa
f010352b:	6a 00                	push   $0x0
f010352d:	50                   	push   %eax
f010352e:	e8 f5 c9 01 00       	call   f011ff28 <strtol>
f0103533:	83 c4 10             	add    $0x10,%esp
f0103536:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0103539:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010353d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103541:	83 ec 08             	sub    $0x8,%esp
f0103544:	52                   	push   %edx
f0103545:	50                   	push   %eax
f0103546:	e8 32 35 00 00       	call   f0106a7d <sched_init_BSD>
f010354b:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f010354e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103552:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103556:	83 ec 04             	sub    $0x4,%esp
f0103559:	52                   	push   %edx
f010355a:	50                   	push   %eax
f010355b:	68 d0 47 12 f0       	push   $0xf01247d0
f0103560:	e8 26 da ff ff       	call   f0100f8b <cprintf>
f0103565:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0103568:	83 ec 0c             	sub    $0xc,%esp
f010356b:	68 4d 41 12 f0       	push   $0xf012414d
f0103570:	e8 16 da ff ff       	call   f0100f8b <cprintf>
f0103575:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103578:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010357d:	c9                   	leave  
f010357e:	c3                   	ret    

f010357f <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f010357f:	55                   	push   %ebp
f0103580:	89 e5                	mov    %esp,%ebp
f0103582:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103585:	e8 6d 31 00 00       	call   f01066f7 <isSchedMethodMLFQ>
f010358a:	85 c0                	test   %eax,%eax
f010358c:	74 5c                	je     f01035ea <command_print_sch_method+0x6b>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f010358e:	83 ec 0c             	sub    $0xc,%esp
f0103591:	68 0c 48 12 f0       	push   $0xf012480c
f0103596:	e8 f0 d9 ff ff       	call   f0100f8b <cprintf>
f010359b:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010359e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01035a5:	eb 24                	jmp    f01035cb <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f01035a7:	8b 15 a4 09 6c f0    	mov    0xf06c09a4,%edx
f01035ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01035b0:	01 d0                	add    %edx,%eax
f01035b2:	8a 00                	mov    (%eax),%al
f01035b4:	0f b6 c0             	movzbl %al,%eax
f01035b7:	83 ec 08             	sub    $0x8,%esp
f01035ba:	50                   	push   %eax
f01035bb:	68 c9 47 12 f0       	push   $0xf01247c9
f01035c0:	e8 c6 d9 ff ff       	call   f0100f8b <cprintf>
f01035c5:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01035c8:	ff 45 f4             	incl   -0xc(%ebp)
f01035cb:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f01035d0:	0f b6 c0             	movzbl %al,%eax
f01035d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01035d6:	7f cf                	jg     f01035a7 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f01035d8:	83 ec 0c             	sub    $0xc,%esp
f01035db:	68 4d 41 12 f0       	push   $0xf012414d
f01035e0:	e8 a6 d9 ff ff       	call   f0100f8b <cprintf>
f01035e5:	83 c4 10             	add    $0x10,%esp
f01035e8:	eb 65                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodRR())
f01035ea:	e8 ee 30 00 00       	call   f01066dd <isSchedMethodRR>
f01035ef:	85 c0                	test   %eax,%eax
f01035f1:	74 1d                	je     f0103610 <command_print_sch_method+0x91>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f01035f3:	a1 a4 09 6c f0       	mov    0xf06c09a4,%eax
f01035f8:	8a 00                	mov    (%eax),%al
f01035fa:	0f b6 c0             	movzbl %al,%eax
f01035fd:	83 ec 08             	sub    $0x8,%esp
f0103600:	50                   	push   %eax
f0103601:	68 40 48 12 f0       	push   $0xf0124840
f0103606:	e8 80 d9 ff ff       	call   f0100f8b <cprintf>
f010360b:	83 c4 10             	add    $0x10,%esp
f010360e:	eb 3f                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodBSD())
f0103610:	e8 fd 30 00 00       	call   f0106712 <isSchedMethodBSD>
f0103615:	85 c0                	test   %eax,%eax
f0103617:	74 26                	je     f010363f <command_print_sch_method+0xc0>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103619:	a1 a4 09 6c f0       	mov    0xf06c09a4,%eax
f010361e:	8a 00                	mov    (%eax),%al
f0103620:	0f b6 d0             	movzbl %al,%edx
f0103623:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f0103628:	0f b6 c0             	movzbl %al,%eax
f010362b:	83 ec 04             	sub    $0x4,%esp
f010362e:	52                   	push   %edx
f010362f:	50                   	push   %eax
f0103630:	68 d0 47 12 f0       	push   $0xf01247d0
f0103635:	e8 51 d9 ff ff       	call   f0100f8b <cprintf>
f010363a:	83 c4 10             	add    $0x10,%esp
f010363d:	eb 10                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f010363f:	83 ec 0c             	sub    $0xc,%esp
f0103642:	68 7c 48 12 f0       	push   $0xf012487c
f0103647:	e8 3f d9 ff ff       	call   f0100f8b <cprintf>
f010364c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010364f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103654:	c9                   	leave  
f0103655:	c3                   	ret    

f0103656 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f0103656:	55                   	push   %ebp
f0103657:	89 e5                	mov    %esp,%ebp
f0103659:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f010365c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010365f:	83 c0 04             	add    $0x4,%eax
f0103662:	8b 00                	mov    (%eax),%eax
f0103664:	83 ec 04             	sub    $0x4,%esp
f0103667:	6a 0a                	push   $0xa
f0103669:	6a 00                	push   $0x0
f010366b:	50                   	push   %eax
f010366c:	e8 b7 c8 01 00       	call   f011ff28 <strtol>
f0103671:	83 c4 10             	add    $0x10,%esp
f0103674:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103677:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010367a:	0f b6 c0             	movzbl %al,%eax
f010367d:	83 ec 0c             	sub    $0xc,%esp
f0103680:	50                   	push   %eax
f0103681:	e8 96 b6 01 00       	call   f011ed1c <chksch>
f0103686:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103689:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010368d:	75 12                	jne    f01036a1 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010368f:	83 ec 0c             	sub    $0xc,%esp
f0103692:	68 a4 48 12 f0       	push   $0xf01248a4
f0103697:	e8 ef d8 ff ff       	call   f0100f8b <cprintf>
f010369c:	83 c4 10             	add    $0x10,%esp
f010369f:	eb 16                	jmp    f01036b7 <command_sch_test+0x61>
	else if (status == 1)
f01036a1:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01036a5:	75 10                	jne    f01036b7 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f01036a7:	83 ec 0c             	sub    $0xc,%esp
f01036aa:	68 cc 48 12 f0       	push   $0xf01248cc
f01036af:	e8 d7 d8 ff ff       	call   f0100f8b <cprintf>
f01036b4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036bc:	c9                   	leave  
f01036bd:	c3                   	ret    

f01036be <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f01036be:	55                   	push   %ebp
f01036bf:	89 e5                	mov    %esp,%ebp
f01036c1:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f01036c4:	e8 14 bf 00 00       	call   f010f5dd <isPageReplacmentAlgorithmCLOCK>
f01036c9:	85 c0                	test   %eax,%eax
f01036cb:	74 15                	je     f01036e2 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f01036cd:	83 ec 0c             	sub    $0xc,%esp
f01036d0:	68 f0 48 12 f0       	push   $0xf01248f0
f01036d5:	e8 b1 d8 ff ff       	call   f0100f8b <cprintf>
f01036da:	83 c4 10             	add    $0x10,%esp
f01036dd:	e9 8c 00 00 00       	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f01036e2:	83 ec 0c             	sub    $0xc,%esp
f01036e5:	6a 01                	push   $0x1
f01036e7:	e8 db be 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f01036ec:	83 c4 10             	add    $0x10,%esp
f01036ef:	85 c0                	test   %eax,%eax
f01036f1:	74 12                	je     f0103705 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f01036f3:	83 ec 0c             	sub    $0xc,%esp
f01036f6:	68 18 49 12 f0       	push   $0xf0124918
f01036fb:	e8 8b d8 ff ff       	call   f0100f8b <cprintf>
f0103700:	83 c4 10             	add    $0x10,%esp
f0103703:	eb 69                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103705:	83 ec 0c             	sub    $0xc,%esp
f0103708:	6a 02                	push   $0x2
f010370a:	e8 b8 be 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f010370f:	83 c4 10             	add    $0x10,%esp
f0103712:	85 c0                	test   %eax,%eax
f0103714:	74 12                	je     f0103728 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103716:	83 ec 0c             	sub    $0xc,%esp
f0103719:	68 58 49 12 f0       	push   $0xf0124958
f010371e:	e8 68 d8 ff ff       	call   f0100f8b <cprintf>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	eb 46                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f0103728:	e8 cb be 00 00       	call   f010f5f8 <isPageReplacmentAlgorithmFIFO>
f010372d:	85 c0                	test   %eax,%eax
f010372f:	74 12                	je     f0103743 <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f0103731:	83 ec 0c             	sub    $0xc,%esp
f0103734:	68 94 49 12 f0       	push   $0xf0124994
f0103739:	e8 4d d8 ff ff       	call   f0100f8b <cprintf>
f010373e:	83 c4 10             	add    $0x10,%esp
f0103741:	eb 2b                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f0103743:	e8 cb be 00 00       	call   f010f613 <isPageReplacmentAlgorithmModifiedCLOCK>
f0103748:	85 c0                	test   %eax,%eax
f010374a:	74 12                	je     f010375e <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f010374c:	83 ec 0c             	sub    $0xc,%esp
f010374f:	68 b8 49 12 f0       	push   $0xf01249b8
f0103754:	e8 32 d8 ff ff       	call   f0100f8b <cprintf>
f0103759:	83 c4 10             	add    $0x10,%esp
f010375c:	eb 10                	jmp    f010376e <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f010375e:	83 ec 0c             	sub    $0xc,%esp
f0103761:	68 e8 49 12 f0       	push   $0xf01249e8
f0103766:	e8 20 d8 ff ff       	call   f0100f8b <cprintf>
f010376b:	83 c4 10             	add    $0x10,%esp

	return 0;
f010376e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103773:	c9                   	leave  
f0103774:	c3                   	ret    

f0103775 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103775:	55                   	push   %ebp
f0103776:	89 e5                	mov    %esp,%ebp
f0103778:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010377b:	e8 2f ee ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103780:	83 ec 0c             	sub    $0xc,%esp
f0103783:	68 14 4a 12 f0       	push   $0xf0124a14
f0103788:	e8 fe d7 ff ff       	call   f0100f8b <cprintf>
f010378d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103790:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103795:	c9                   	leave  
f0103796:	c3                   	ret    

f0103797 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103797:	55                   	push   %ebp
f0103798:	89 e5                	mov    %esp,%ebp
f010379a:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f010379d:	e8 1d ee ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01037a2:	83 ec 0c             	sub    $0xc,%esp
f01037a5:	68 44 4a 12 f0       	push   $0xf0124a44
f01037aa:	e8 dc d7 ff ff       	call   f0100f8b <cprintf>
f01037af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037b7:	c9                   	leave  
f01037b8:	c3                   	ret    

f01037b9 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01037b9:	55                   	push   %ebp
f01037ba:	89 e5                	mov    %esp,%ebp
f01037bc:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01037bf:	e8 0b ee ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01037c4:	83 ec 0c             	sub    $0xc,%esp
f01037c7:	68 74 4a 12 f0       	push   $0xf0124a74
f01037cc:	e8 ba d7 ff ff       	call   f0100f8b <cprintf>
f01037d1:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037d9:	c9                   	leave  
f01037da:	c3                   	ret    

f01037db <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01037db:	55                   	push   %ebp
f01037dc:	89 e5                	mov    %esp,%ebp
f01037de:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01037e1:	e8 f9 ed ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01037e6:	83 ec 0c             	sub    $0xc,%esp
f01037e9:	68 a4 4a 12 f0       	push   $0xf0124aa4
f01037ee:	e8 98 d7 ff ff       	call   f0100f8b <cprintf>
f01037f3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037fb:	c9                   	leave  
f01037fc:	c3                   	ret    

f01037fd <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01037fd:	55                   	push   %ebp
f01037fe:	89 e5                	mov    %esp,%ebp
f0103800:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0103803:	e8 e7 ed ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f0103808:	84 c0                	test   %al,%al
f010380a:	74 12                	je     f010381e <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f010380c:	83 ec 0c             	sub    $0xc,%esp
f010380f:	68 d4 4a 12 f0       	push   $0xf0124ad4
f0103814:	e8 72 d7 ff ff       	call   f0100f8b <cprintf>
f0103819:	83 c4 10             	add    $0x10,%esp
f010381c:	eb 61                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010381e:	e8 e1 ed ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103823:	84 c0                	test   %al,%al
f0103825:	74 12                	je     f0103839 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103827:	83 ec 0c             	sub    $0xc,%esp
f010382a:	68 00 4b 12 f0       	push   $0xf0124b00
f010382f:	e8 57 d7 ff ff       	call   f0100f8b <cprintf>
f0103834:	83 c4 10             	add    $0x10,%esp
f0103837:	eb 46                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103839:	e8 db ed ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f010383e:	84 c0                	test   %al,%al
f0103840:	74 12                	je     f0103854 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103842:	83 ec 0c             	sub    $0xc,%esp
f0103845:	68 2c 4b 12 f0       	push   $0xf0124b2c
f010384a:	e8 3c d7 ff ff       	call   f0100f8b <cprintf>
f010384f:	83 c4 10             	add    $0x10,%esp
f0103852:	eb 2b                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103854:	e8 d5 ed ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103859:	84 c0                	test   %al,%al
f010385b:	74 12                	je     f010386f <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f010385d:	83 ec 0c             	sub    $0xc,%esp
f0103860:	68 58 4b 12 f0       	push   $0xf0124b58
f0103865:	e8 21 d7 ff ff       	call   f0100f8b <cprintf>
f010386a:	83 c4 10             	add    $0x10,%esp
f010386d:	eb 10                	jmp    f010387f <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f010386f:	83 ec 0c             	sub    $0xc,%esp
f0103872:	68 84 4b 12 f0       	push   $0xf0124b84
f0103877:	e8 0f d7 ff ff       	call   f0100f8b <cprintf>
f010387c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010387f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103884:	c9                   	leave  
f0103885:	c3                   	ret    

f0103886 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103886:	55                   	push   %ebp
f0103887:	89 e5                	mov    %esp,%ebp
f0103889:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f010388c:	e8 66 ec ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103891:	83 ec 0c             	sub    $0xc,%esp
f0103894:	68 b0 4b 12 f0       	push   $0xf0124bb0
f0103899:	e8 ed d6 ff ff       	call   f0100f8b <cprintf>
f010389e:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038a6:	c9                   	leave  
f01038a7:	c3                   	ret    

f01038a8 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01038a8:	55                   	push   %ebp
f01038a9:	89 e5                	mov    %esp,%ebp
f01038ab:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f01038ae:	e8 54 ec ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01038b3:	83 ec 0c             	sub    $0xc,%esp
f01038b6:	68 b0 4b 12 f0       	push   $0xf0124bb0
f01038bb:	e8 cb d6 ff ff       	call   f0100f8b <cprintf>
f01038c0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038c8:	c9                   	leave  
f01038c9:	c3                   	ret    

f01038ca <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01038ca:	55                   	push   %ebp
f01038cb:	89 e5                	mov    %esp,%ebp
f01038cd:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f01038d0:	e8 42 ec ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f01038d5:	83 ec 0c             	sub    $0xc,%esp
f01038d8:	68 e4 4b 12 f0       	push   $0xf0124be4
f01038dd:	e8 a9 d6 ff ff       	call   f0100f8b <cprintf>
f01038e2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038ea:	c9                   	leave  
f01038eb:	c3                   	ret    

f01038ec <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01038ec:	55                   	push   %ebp
f01038ed:	89 e5                	mov    %esp,%ebp
f01038ef:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f01038f2:	e8 30 ec ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f01038f7:	83 ec 0c             	sub    $0xc,%esp
f01038fa:	68 14 4c 12 f0       	push   $0xf0124c14
f01038ff:	e8 87 d6 ff ff       	call   f0100f8b <cprintf>
f0103904:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103907:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010390c:	c9                   	leave  
f010390d:	c3                   	ret    

f010390e <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010390e:	55                   	push   %ebp
f010390f:	89 e5                	mov    %esp,%ebp
f0103911:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103914:	e8 1e ec ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103919:	83 ec 0c             	sub    $0xc,%esp
f010391c:	68 44 4c 12 f0       	push   $0xf0124c44
f0103921:	e8 65 d6 ff ff       	call   f0100f8b <cprintf>
f0103926:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103929:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010392e:	c9                   	leave  
f010392f:	c3                   	ret    

f0103930 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103930:	55                   	push   %ebp
f0103931:	89 e5                	mov    %esp,%ebp
f0103933:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103936:	e8 0c ec ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f010393b:	84 c0                	test   %al,%al
f010393d:	74 12                	je     f0103951 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f010393f:	83 ec 0c             	sub    $0xc,%esp
f0103942:	68 78 4c 12 f0       	push   $0xf0124c78
f0103947:	e8 3f d6 ff ff       	call   f0100f8b <cprintf>
f010394c:	83 c4 10             	add    $0x10,%esp
f010394f:	eb 7c                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103951:	e8 05 ec ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103956:	84 c0                	test   %al,%al
f0103958:	74 12                	je     f010396c <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010395a:	83 ec 0c             	sub    $0xc,%esp
f010395d:	68 b4 4c 12 f0       	push   $0xf0124cb4
f0103962:	e8 24 d6 ff ff       	call   f0100f8b <cprintf>
f0103967:	83 c4 10             	add    $0x10,%esp
f010396a:	eb 61                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f010396c:	e8 ff eb ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103971:	84 c0                	test   %al,%al
f0103973:	74 12                	je     f0103987 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103975:	83 ec 0c             	sub    $0xc,%esp
f0103978:	68 e4 4c 12 f0       	push   $0xf0124ce4
f010397d:	e8 09 d6 ff ff       	call   f0100f8b <cprintf>
f0103982:	83 c4 10             	add    $0x10,%esp
f0103985:	eb 46                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103987:	e8 f9 eb ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f010398c:	84 c0                	test   %al,%al
f010398e:	74 12                	je     f01039a2 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103990:	83 ec 0c             	sub    $0xc,%esp
f0103993:	68 10 4d 12 f0       	push   $0xf0124d10
f0103998:	e8 ee d5 ff ff       	call   f0100f8b <cprintf>
f010399d:	83 c4 10             	add    $0x10,%esp
f01039a0:	eb 2b                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f01039a2:	e8 f3 eb ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f01039a7:	84 c0                	test   %al,%al
f01039a9:	74 12                	je     f01039bd <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01039ab:	83 ec 0c             	sub    $0xc,%esp
f01039ae:	68 3c 4d 12 f0       	push   $0xf0124d3c
f01039b3:	e8 d3 d5 ff ff       	call   f0100f8b <cprintf>
f01039b8:	83 c4 10             	add    $0x10,%esp
f01039bb:	eb 10                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f01039bd:	83 ec 0c             	sub    $0xc,%esp
f01039c0:	68 6c 4d 12 f0       	push   $0xf0124d6c
f01039c5:	e8 c1 d5 ff ff       	call   f0100f8b <cprintf>
f01039ca:	83 c4 10             	add    $0x10,%esp

	return 0;
f01039cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039d2:	c9                   	leave  
f01039d3:	c3                   	ret    

f01039d4 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f01039d4:	55                   	push   %ebp
f01039d5:	89 e5                	mov    %esp,%ebp
f01039d7:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01039da:	e8 ab bc 00 00       	call   f010f68a <isBufferingEnabled>
f01039df:	84 c0                	test   %al,%al
f01039e1:	75 12                	jne    f01039f5 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01039e3:	83 ec 0c             	sub    $0xc,%esp
f01039e6:	68 9c 4d 12 f0       	push   $0xf0124d9c
f01039eb:	e8 9b d5 ff ff       	call   f0100f8b <cprintf>
f01039f0:	83 c4 10             	add    $0x10,%esp
f01039f3:	eb 1d                	jmp    f0103a12 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f01039f5:	83 ec 0c             	sub    $0xc,%esp
f01039f8:	6a 00                	push   $0x0
f01039fa:	e8 65 bc 00 00       	call   f010f664 <enableModifiedBuffer>
f01039ff:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103a02:	83 ec 0c             	sub    $0xc,%esp
f0103a05:	68 d8 4d 12 f0       	push   $0xf0124dd8
f0103a0a:	e8 7c d5 ff ff       	call   f0100f8b <cprintf>
f0103a0f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a12:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a17:	c9                   	leave  
f0103a18:	c3                   	ret    

f0103a19 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103a19:	55                   	push   %ebp
f0103a1a:	89 e5                	mov    %esp,%ebp
f0103a1c:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a1f:	e8 66 bc 00 00       	call   f010f68a <isBufferingEnabled>
f0103a24:	84 c0                	test   %al,%al
f0103a26:	75 12                	jne    f0103a3a <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103a28:	83 ec 0c             	sub    $0xc,%esp
f0103a2b:	68 9c 4d 12 f0       	push   $0xf0124d9c
f0103a30:	e8 56 d5 ff ff       	call   f0100f8b <cprintf>
f0103a35:	83 c4 10             	add    $0x10,%esp
f0103a38:	eb 1d                	jmp    f0103a57 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103a3a:	83 ec 0c             	sub    $0xc,%esp
f0103a3d:	6a 01                	push   $0x1
f0103a3f:	e8 20 bc 00 00       	call   f010f664 <enableModifiedBuffer>
f0103a44:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103a47:	83 ec 0c             	sub    $0xc,%esp
f0103a4a:	68 fc 4d 12 f0       	push   $0xf0124dfc
f0103a4f:	e8 37 d5 ff ff       	call   f0100f8b <cprintf>
f0103a54:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a57:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a5c:	c9                   	leave  
f0103a5d:	c3                   	ret    

f0103a5e <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103a5e:	55                   	push   %ebp
f0103a5f:	89 e5                	mov    %esp,%ebp
f0103a61:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103a64:	83 ec 0c             	sub    $0xc,%esp
f0103a67:	6a 00                	push   $0x0
f0103a69:	e8 0e bc 00 00       	call   f010f67c <enableBuffering>
f0103a6e:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103a71:	83 ec 0c             	sub    $0xc,%esp
f0103a74:	6a 00                	push   $0x0
f0103a76:	e8 e9 bb 00 00       	call   f010f664 <enableModifiedBuffer>
f0103a7b:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103a7e:	83 ec 0c             	sub    $0xc,%esp
f0103a81:	68 1c 4e 12 f0       	push   $0xf0124e1c
f0103a86:	e8 00 d5 ff ff       	call   f0100f8b <cprintf>
f0103a8b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a93:	c9                   	leave  
f0103a94:	c3                   	ret    

f0103a95 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103a95:	55                   	push   %ebp
f0103a96:	89 e5                	mov    %esp,%ebp
f0103a98:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103a9b:	83 ec 0c             	sub    $0xc,%esp
f0103a9e:	6a 01                	push   $0x1
f0103aa0:	e8 d7 bb 00 00       	call   f010f67c <enableBuffering>
f0103aa5:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103aa8:	83 ec 0c             	sub    $0xc,%esp
f0103aab:	6a 01                	push   $0x1
f0103aad:	e8 b2 bb 00 00       	call   f010f664 <enableModifiedBuffer>
f0103ab2:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ab5:	e8 e8 bb 00 00       	call   f010f6a2 <getModifiedBufferLength>
f0103aba:	85 c0                	test   %eax,%eax
f0103abc:	75 59                	jne    f0103b17 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103abe:	83 ec 0c             	sub    $0xc,%esp
f0103ac1:	68 38 4e 12 f0       	push   $0xf0124e38
f0103ac6:	e8 c0 d4 ff ff       	call   f0100f8b <cprintf>
f0103acb:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103ace:	83 ec 08             	sub    $0x8,%esp
f0103ad1:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ad4:	50                   	push   %eax
f0103ad5:	68 68 4e 12 f0       	push   $0xf0124e68
f0103ada:	e8 e1 be 01 00       	call   f011f9c0 <readline>
f0103adf:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103ae2:	83 ec 04             	sub    $0x4,%esp
f0103ae5:	6a 0a                	push   $0xa
f0103ae7:	6a 00                	push   $0x0
f0103ae9:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103aec:	50                   	push   %eax
f0103aed:	e8 36 c4 01 00       	call   f011ff28 <strtol>
f0103af2:	83 c4 10             	add    $0x10,%esp
f0103af5:	83 ec 0c             	sub    $0xc,%esp
f0103af8:	50                   	push   %eax
f0103af9:	e8 96 bb 00 00       	call   f010f694 <setModifiedBufferLength>
f0103afe:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b01:	e8 9c bb 00 00       	call   f010f6a2 <getModifiedBufferLength>
f0103b06:	83 ec 08             	sub    $0x8,%esp
f0103b09:	50                   	push   %eax
f0103b0a:	68 94 4e 12 f0       	push   $0xf0124e94
f0103b0f:	e8 77 d4 ff ff       	call   f0100f8b <cprintf>
f0103b14:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103b17:	83 ec 0c             	sub    $0xc,%esp
f0103b1a:	68 b9 4e 12 f0       	push   $0xf0124eb9
f0103b1f:	e8 67 d4 ff ff       	call   f0100f8b <cprintf>
f0103b24:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b2c:	c9                   	leave  
f0103b2d:	c3                   	ret    

f0103b2e <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103b2e:	55                   	push   %ebp
f0103b2f:	89 e5                	mov    %esp,%ebp
f0103b31:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103b34:	e8 51 bb 00 00       	call   f010f68a <isBufferingEnabled>
f0103b39:	84 c0                	test   %al,%al
f0103b3b:	75 12                	jne    f0103b4f <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103b3d:	83 ec 0c             	sub    $0xc,%esp
f0103b40:	68 d4 4e 12 f0       	push   $0xf0124ed4
f0103b45:	e8 41 d4 ff ff       	call   f0100f8b <cprintf>
f0103b4a:	83 c4 10             	add    $0x10,%esp
f0103b4d:	eb 19                	jmp    f0103b68 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103b4f:	e8 1e bb 00 00       	call   f010f672 <isModifiedBufferEnabled>
f0103b54:	84 c0                	test   %al,%al
f0103b56:	75 10                	jne    f0103b68 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103b58:	83 ec 0c             	sub    $0xc,%esp
f0103b5b:	68 24 4f 12 f0       	push   $0xf0124f24
f0103b60:	e8 26 d4 ff ff       	call   f0100f8b <cprintf>
f0103b65:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b6b:	83 c0 04             	add    $0x4,%eax
f0103b6e:	8b 00                	mov    (%eax),%eax
f0103b70:	83 ec 04             	sub    $0x4,%esp
f0103b73:	6a 0a                	push   $0xa
f0103b75:	6a 00                	push   $0x0
f0103b77:	50                   	push   %eax
f0103b78:	e8 ab c3 01 00       	call   f011ff28 <strtol>
f0103b7d:	83 c4 10             	add    $0x10,%esp
f0103b80:	83 ec 0c             	sub    $0xc,%esp
f0103b83:	50                   	push   %eax
f0103b84:	e8 0b bb 00 00       	call   f010f694 <setModifiedBufferLength>
f0103b89:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b8c:	e8 11 bb 00 00       	call   f010f6a2 <getModifiedBufferLength>
f0103b91:	83 ec 08             	sub    $0x8,%esp
f0103b94:	50                   	push   %eax
f0103b95:	68 94 4e 12 f0       	push   $0xf0124e94
f0103b9a:	e8 ec d3 ff ff       	call   f0100f8b <cprintf>
f0103b9f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ba2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ba7:	c9                   	leave  
f0103ba8:	c3                   	ret    

f0103ba9 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103ba9:	55                   	push   %ebp
f0103baa:	89 e5                	mov    %esp,%ebp
f0103bac:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103baf:	e8 d6 ba 00 00       	call   f010f68a <isBufferingEnabled>
f0103bb4:	84 c0                	test   %al,%al
f0103bb6:	75 12                	jne    f0103bca <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103bb8:	83 ec 0c             	sub    $0xc,%esp
f0103bbb:	68 d4 4e 12 f0       	push   $0xf0124ed4
f0103bc0:	e8 c6 d3 ff ff       	call   f0100f8b <cprintf>
f0103bc5:	83 c4 10             	add    $0x10,%esp
f0103bc8:	eb 19                	jmp    f0103be3 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103bca:	e8 a3 ba 00 00       	call   f010f672 <isModifiedBufferEnabled>
f0103bcf:	84 c0                	test   %al,%al
f0103bd1:	75 10                	jne    f0103be3 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103bd3:	83 ec 0c             	sub    $0xc,%esp
f0103bd6:	68 24 4f 12 f0       	push   $0xf0124f24
f0103bdb:	e8 ab d3 ff ff       	call   f0100f8b <cprintf>
f0103be0:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103be3:	e8 ba ba 00 00       	call   f010f6a2 <getModifiedBufferLength>
f0103be8:	83 ec 08             	sub    $0x8,%esp
f0103beb:	50                   	push   %eax
f0103bec:	68 6a 4f 12 f0       	push   $0xf0124f6a
f0103bf1:	e8 95 d3 ff ff       	call   f0100f8b <cprintf>
f0103bf6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bfe:	c9                   	leave  
f0103bff:	c3                   	ret    

f0103c00 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103c00:	55                   	push   %ebp
f0103c01:	89 e5                	mov    %esp,%ebp
f0103c03:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103c06:	83 ec 08             	sub    $0x8,%esp
f0103c09:	ff 75 0c             	pushl  0xc(%ebp)
f0103c0c:	ff 75 08             	pushl  0x8(%ebp)
f0103c0f:	e8 ed c5 00 00       	call   f0110201 <tst_handler>
f0103c14:	83 c4 10             	add    $0x10,%esp
}
f0103c17:	c9                   	leave  
f0103c18:	c3                   	ret    

f0103c19 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103c19:	55                   	push   %ebp
f0103c1a:	89 e5                	mov    %esp,%ebp
f0103c1c:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c22:	05 00 14 00 00       	add    $0x1400,%eax
f0103c27:	c1 e0 03             	shl    $0x3,%eax
f0103c2a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c2d:	83 ec 04             	sub    $0x4,%esp
f0103c30:	6a 08                	push   $0x8
f0103c32:	ff 75 0c             	pushl  0xc(%ebp)
f0103c35:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c38:	e8 73 c7 01 00       	call   f01203b0 <ide_read>
f0103c3d:	83 c4 10             	add    $0x10,%esp
f0103c40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c46:	c9                   	leave  
f0103c47:	c3                   	ret    

f0103c48 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103c48:	55                   	push   %ebp
f0103c49:	89 e5                	mov    %esp,%ebp
f0103c4b:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c51:	05 00 14 00 00       	add    $0x1400,%eax
f0103c56:	c1 e0 03             	shl    $0x3,%eax
f0103c59:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c5c:	83 ec 04             	sub    $0x4,%esp
f0103c5f:	6a 08                	push   $0x8
f0103c61:	ff 75 0c             	pushl  0xc(%ebp)
f0103c64:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c67:	e8 84 c8 01 00       	call   f01204f0 <ide_write>
f0103c6c:	83 c4 10             	add    $0x10,%esp
f0103c6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103c72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103c76:	74 14                	je     f0103c8c <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103c78:	83 ec 04             	sub    $0x4,%esp
f0103c7b:	68 88 4f 12 f0       	push   $0xf0124f88
f0103c80:	6a 2f                	push   $0x2f
f0103c82:	68 9f 4f 12 f0       	push   $0xf0124f9f
f0103c87:	e8 ad c6 ff ff       	call   f0100339 <_panic>
	return success;
f0103c8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c8f:	c9                   	leave  
f0103c90:	c3                   	ret    

f0103c91 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103c91:	55                   	push   %ebp
f0103c92:	89 e5                	mov    %esp,%ebp
f0103c94:	53                   	push   %ebx
f0103c95:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103c98:	c7 05 a0 0c 6c f0 00 	movl   $0x0,0xf06c0ca0
f0103c9f:	00 00 00 
f0103ca2:	c7 05 a4 0c 6c f0 00 	movl   $0x0,0xf06c0ca4
f0103ca9:	00 00 00 
f0103cac:	c7 05 ac 0c 6c f0 00 	movl   $0x0,0xf06c0cac
f0103cb3:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103cb6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103cbd:	e9 e8 00 00 00       	jmp    f0103daa <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103cc2:	8b 0d a0 03 6c f0    	mov    0xf06c03a0,%ecx
f0103cc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ccb:	89 d0                	mov    %edx,%eax
f0103ccd:	01 c0                	add    %eax,%eax
f0103ccf:	01 d0                	add    %edx,%eax
f0103cd1:	c1 e0 03             	shl    $0x3,%eax
f0103cd4:	01 c8                	add    %ecx,%eax
f0103cd6:	83 ec 0c             	sub    $0xc,%esp
f0103cd9:	50                   	push   %eax
f0103cda:	e8 b8 44 00 00       	call   f0108197 <initialize_frame_info>
f0103cdf:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ce2:	8b 0d a0 03 6c f0    	mov    0xf06c03a0,%ecx
f0103ce8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ceb:	89 d0                	mov    %edx,%eax
f0103ced:	01 c0                	add    %eax,%eax
f0103cef:	01 d0                	add    %edx,%eax
f0103cf1:	c1 e0 03             	shl    $0x3,%eax
f0103cf4:	01 c8                	add    %ecx,%eax
f0103cf6:	85 c0                	test   %eax,%eax
f0103cf8:	75 14                	jne    f0103d0e <initialize_disk_page_file+0x7d>
f0103cfa:	83 ec 04             	sub    $0x4,%esp
f0103cfd:	68 bc 4f 12 f0       	push   $0xf0124fbc
f0103d02:	6a 56                	push   $0x56
f0103d04:	68 9f 4f 12 f0       	push   $0xf0124f9f
f0103d09:	e8 2b c6 ff ff       	call   f0100339 <_panic>
f0103d0e:	8b 0d a0 03 6c f0    	mov    0xf06c03a0,%ecx
f0103d14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d17:	89 d0                	mov    %edx,%eax
f0103d19:	01 c0                	add    %eax,%eax
f0103d1b:	01 d0                	add    %edx,%eax
f0103d1d:	c1 e0 03             	shl    $0x3,%eax
f0103d20:	01 c8                	add    %ecx,%eax
f0103d22:	8b 15 a0 0c 6c f0    	mov    0xf06c0ca0,%edx
f0103d28:	89 10                	mov    %edx,(%eax)
f0103d2a:	8b 00                	mov    (%eax),%eax
f0103d2c:	85 c0                	test   %eax,%eax
f0103d2e:	74 1f                	je     f0103d4f <initialize_disk_page_file+0xbe>
f0103d30:	8b 15 a0 0c 6c f0    	mov    0xf06c0ca0,%edx
f0103d36:	8b 1d a0 03 6c f0    	mov    0xf06c03a0,%ebx
f0103d3c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103d3f:	89 c8                	mov    %ecx,%eax
f0103d41:	01 c0                	add    %eax,%eax
f0103d43:	01 c8                	add    %ecx,%eax
f0103d45:	c1 e0 03             	shl    $0x3,%eax
f0103d48:	01 d8                	add    %ebx,%eax
f0103d4a:	89 42 04             	mov    %eax,0x4(%edx)
f0103d4d:	eb 19                	jmp    f0103d68 <initialize_disk_page_file+0xd7>
f0103d4f:	8b 0d a0 03 6c f0    	mov    0xf06c03a0,%ecx
f0103d55:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d58:	89 d0                	mov    %edx,%eax
f0103d5a:	01 c0                	add    %eax,%eax
f0103d5c:	01 d0                	add    %edx,%eax
f0103d5e:	c1 e0 03             	shl    $0x3,%eax
f0103d61:	01 c8                	add    %ecx,%eax
f0103d63:	a3 a4 0c 6c f0       	mov    %eax,0xf06c0ca4
f0103d68:	8b 0d a0 03 6c f0    	mov    0xf06c03a0,%ecx
f0103d6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d71:	89 d0                	mov    %edx,%eax
f0103d73:	01 c0                	add    %eax,%eax
f0103d75:	01 d0                	add    %edx,%eax
f0103d77:	c1 e0 03             	shl    $0x3,%eax
f0103d7a:	01 c8                	add    %ecx,%eax
f0103d7c:	a3 a0 0c 6c f0       	mov    %eax,0xf06c0ca0
f0103d81:	8b 0d a0 03 6c f0    	mov    0xf06c03a0,%ecx
f0103d87:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d8a:	89 d0                	mov    %edx,%eax
f0103d8c:	01 c0                	add    %eax,%eax
f0103d8e:	01 d0                	add    %edx,%eax
f0103d90:	c1 e0 03             	shl    $0x3,%eax
f0103d93:	01 c8                	add    %ecx,%eax
f0103d95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103d9c:	a1 ac 0c 6c f0       	mov    0xf06c0cac,%eax
f0103da1:	40                   	inc    %eax
f0103da2:	a3 ac 0c 6c f0       	mov    %eax,0xf06c0cac
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103da7:	ff 45 f4             	incl   -0xc(%ebp)
f0103daa:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103db1:	0f 8e 0b ff ff ff    	jle    f0103cc2 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103db7:	90                   	nop
f0103db8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103dbb:	c9                   	leave  
f0103dbc:	c3                   	ret    

f0103dbd <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103dbd:	55                   	push   %ebp
f0103dbe:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103dc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dc3:	8b 15 a0 03 6c f0    	mov    0xf06c03a0,%edx
f0103dc9:	29 d0                	sub    %edx,%eax
f0103dcb:	c1 f8 03             	sar    $0x3,%eax
f0103dce:	89 c2                	mov    %eax,%edx
f0103dd0:	89 d0                	mov    %edx,%eax
f0103dd2:	c1 e0 02             	shl    $0x2,%eax
f0103dd5:	01 d0                	add    %edx,%eax
f0103dd7:	c1 e0 02             	shl    $0x2,%eax
f0103dda:	01 d0                	add    %edx,%eax
f0103ddc:	c1 e0 02             	shl    $0x2,%eax
f0103ddf:	01 d0                	add    %edx,%eax
f0103de1:	89 c1                	mov    %eax,%ecx
f0103de3:	c1 e1 08             	shl    $0x8,%ecx
f0103de6:	01 c8                	add    %ecx,%eax
f0103de8:	89 c1                	mov    %eax,%ecx
f0103dea:	c1 e1 10             	shl    $0x10,%ecx
f0103ded:	01 c8                	add    %ecx,%eax
f0103def:	01 c0                	add    %eax,%eax
f0103df1:	01 d0                	add    %edx,%eax
}
f0103df3:	5d                   	pop    %ebp
f0103df4:	c3                   	ret    

f0103df5 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103df5:	55                   	push   %ebp
f0103df6:	89 e5                	mov    %esp,%ebp
f0103df8:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103dfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103e02:	83 ec 0c             	sub    $0xc,%esp
f0103e05:	68 b0 0c 6c f0       	push   $0xf06c0cb0
f0103e0a:	e8 0b be 00 00       	call   f010fc1a <acquire_spinlock>
f0103e0f:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103e12:	a1 a0 0c 6c f0       	mov    0xf06c0ca0,%eax
f0103e17:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103e1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e1e:	75 0c                	jne    f0103e2c <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103e20:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103e27:	e9 a2 00 00 00       	jmp    f0103ece <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e30:	75 14                	jne    f0103e46 <allocate_disk_frame+0x51>
f0103e32:	83 ec 04             	sub    $0x4,%esp
f0103e35:	68 df 4f 12 f0       	push   $0xf0124fdf
f0103e3a:	6a 7b                	push   $0x7b
f0103e3c:	68 9f 4f 12 f0       	push   $0xf0124f9f
f0103e41:	e8 f3 c4 ff ff       	call   f0100339 <_panic>
f0103e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e49:	8b 00                	mov    (%eax),%eax
f0103e4b:	85 c0                	test   %eax,%eax
f0103e4d:	74 10                	je     f0103e5f <allocate_disk_frame+0x6a>
f0103e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e52:	8b 00                	mov    (%eax),%eax
f0103e54:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e57:	8b 52 04             	mov    0x4(%edx),%edx
f0103e5a:	89 50 04             	mov    %edx,0x4(%eax)
f0103e5d:	eb 0b                	jmp    f0103e6a <allocate_disk_frame+0x75>
f0103e5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e62:	8b 40 04             	mov    0x4(%eax),%eax
f0103e65:	a3 a4 0c 6c f0       	mov    %eax,0xf06c0ca4
f0103e6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e6d:	8b 40 04             	mov    0x4(%eax),%eax
f0103e70:	85 c0                	test   %eax,%eax
f0103e72:	74 0f                	je     f0103e83 <allocate_disk_frame+0x8e>
f0103e74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e77:	8b 40 04             	mov    0x4(%eax),%eax
f0103e7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e7d:	8b 12                	mov    (%edx),%edx
f0103e7f:	89 10                	mov    %edx,(%eax)
f0103e81:	eb 0a                	jmp    f0103e8d <allocate_disk_frame+0x98>
f0103e83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e86:	8b 00                	mov    (%eax),%eax
f0103e88:	a3 a0 0c 6c f0       	mov    %eax,0xf06c0ca0
f0103e8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103e96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ea0:	a1 ac 0c 6c f0       	mov    0xf06c0cac,%eax
f0103ea5:	48                   	dec    %eax
f0103ea6:	a3 ac 0c 6c f0       	mov    %eax,0xf06c0cac
			initialize_frame_info(ptr_frame_info);
f0103eab:	83 ec 0c             	sub    $0xc,%esp
f0103eae:	ff 75 f0             	pushl  -0x10(%ebp)
f0103eb1:	e8 e1 42 00 00       	call   f0108197 <initialize_frame_info>
f0103eb6:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103eb9:	83 ec 0c             	sub    $0xc,%esp
f0103ebc:	ff 75 f0             	pushl  -0x10(%ebp)
f0103ebf:	e8 f9 fe ff ff       	call   f0103dbd <to_disk_frame_number>
f0103ec4:	83 c4 10             	add    $0x10,%esp
f0103ec7:	89 c2                	mov    %eax,%edx
f0103ec9:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ecc:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103ece:	83 ec 0c             	sub    $0xc,%esp
f0103ed1:	68 b0 0c 6c f0       	push   $0xf06c0cb0
f0103ed6:	e8 c6 bd 00 00       	call   f010fca1 <release_spinlock>
f0103edb:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103ee1:	c9                   	leave  
f0103ee2:	c3                   	ret    

f0103ee3 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103ee3:	55                   	push   %ebp
f0103ee4:	89 e5                	mov    %esp,%ebp
f0103ee6:	53                   	push   %ebx
f0103ee7:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103eea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103eee:	0f 84 ea 00 00 00    	je     f0103fde <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ef4:	83 ec 0c             	sub    $0xc,%esp
f0103ef7:	68 b0 0c 6c f0       	push   $0xf06c0cb0
f0103efc:	e8 19 bd 00 00       	call   f010fc1a <acquire_spinlock>
f0103f01:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103f04:	8b 0d a0 03 6c f0    	mov    0xf06c03a0,%ecx
f0103f0a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f0d:	89 d0                	mov    %edx,%eax
f0103f0f:	01 c0                	add    %eax,%eax
f0103f11:	01 d0                	add    %edx,%eax
f0103f13:	c1 e0 03             	shl    $0x3,%eax
f0103f16:	01 c8                	add    %ecx,%eax
f0103f18:	85 c0                	test   %eax,%eax
f0103f1a:	75 17                	jne    f0103f33 <free_disk_frame+0x50>
f0103f1c:	83 ec 04             	sub    $0x4,%esp
f0103f1f:	68 bc 4f 12 f0       	push   $0xf0124fbc
f0103f24:	68 8e 00 00 00       	push   $0x8e
f0103f29:	68 9f 4f 12 f0       	push   $0xf0124f9f
f0103f2e:	e8 06 c4 ff ff       	call   f0100339 <_panic>
f0103f33:	8b 0d a0 03 6c f0    	mov    0xf06c03a0,%ecx
f0103f39:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f3c:	89 d0                	mov    %edx,%eax
f0103f3e:	01 c0                	add    %eax,%eax
f0103f40:	01 d0                	add    %edx,%eax
f0103f42:	c1 e0 03             	shl    $0x3,%eax
f0103f45:	01 c8                	add    %ecx,%eax
f0103f47:	8b 15 a0 0c 6c f0    	mov    0xf06c0ca0,%edx
f0103f4d:	89 10                	mov    %edx,(%eax)
f0103f4f:	8b 00                	mov    (%eax),%eax
f0103f51:	85 c0                	test   %eax,%eax
f0103f53:	74 1f                	je     f0103f74 <free_disk_frame+0x91>
f0103f55:	8b 15 a0 0c 6c f0    	mov    0xf06c0ca0,%edx
f0103f5b:	8b 1d a0 03 6c f0    	mov    0xf06c03a0,%ebx
f0103f61:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103f64:	89 c8                	mov    %ecx,%eax
f0103f66:	01 c0                	add    %eax,%eax
f0103f68:	01 c8                	add    %ecx,%eax
f0103f6a:	c1 e0 03             	shl    $0x3,%eax
f0103f6d:	01 d8                	add    %ebx,%eax
f0103f6f:	89 42 04             	mov    %eax,0x4(%edx)
f0103f72:	eb 19                	jmp    f0103f8d <free_disk_frame+0xaa>
f0103f74:	8b 0d a0 03 6c f0    	mov    0xf06c03a0,%ecx
f0103f7a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f7d:	89 d0                	mov    %edx,%eax
f0103f7f:	01 c0                	add    %eax,%eax
f0103f81:	01 d0                	add    %edx,%eax
f0103f83:	c1 e0 03             	shl    $0x3,%eax
f0103f86:	01 c8                	add    %ecx,%eax
f0103f88:	a3 a4 0c 6c f0       	mov    %eax,0xf06c0ca4
f0103f8d:	8b 0d a0 03 6c f0    	mov    0xf06c03a0,%ecx
f0103f93:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f96:	89 d0                	mov    %edx,%eax
f0103f98:	01 c0                	add    %eax,%eax
f0103f9a:	01 d0                	add    %edx,%eax
f0103f9c:	c1 e0 03             	shl    $0x3,%eax
f0103f9f:	01 c8                	add    %ecx,%eax
f0103fa1:	a3 a0 0c 6c f0       	mov    %eax,0xf06c0ca0
f0103fa6:	8b 0d a0 03 6c f0    	mov    0xf06c03a0,%ecx
f0103fac:	8b 55 08             	mov    0x8(%ebp),%edx
f0103faf:	89 d0                	mov    %edx,%eax
f0103fb1:	01 c0                	add    %eax,%eax
f0103fb3:	01 d0                	add    %edx,%eax
f0103fb5:	c1 e0 03             	shl    $0x3,%eax
f0103fb8:	01 c8                	add    %ecx,%eax
f0103fba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103fc1:	a1 ac 0c 6c f0       	mov    0xf06c0cac,%eax
f0103fc6:	40                   	inc    %eax
f0103fc7:	a3 ac 0c 6c f0       	mov    %eax,0xf06c0cac
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103fcc:	83 ec 0c             	sub    $0xc,%esp
f0103fcf:	68 b0 0c 6c f0       	push   $0xf06c0cb0
f0103fd4:	e8 c8 bc 00 00       	call   f010fca1 <release_spinlock>
f0103fd9:	83 c4 10             	add    $0x10,%esp
f0103fdc:	eb 01                	jmp    f0103fdf <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103fde:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103fdf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103fe2:	c9                   	leave  
f0103fe3:	c3                   	ret    

f0103fe4 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103fe4:	55                   	push   %ebp
f0103fe5:	89 e5                	mov    %esp,%ebp
f0103fe7:	53                   	push   %ebx
f0103fe8:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103feb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fee:	c1 e8 16             	shr    $0x16,%eax
f0103ff1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103ff8:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ffb:	01 d0                	add    %edx,%eax
f0103ffd:	8b 00                	mov    (%eax),%eax
f0103fff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0104002:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104009:	77 1d                	ja     f0104028 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f010400b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010400e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104013:	83 ec 0c             	sub    $0xc,%esp
f0104016:	50                   	push   %eax
f0104017:	e8 18 58 00 00       	call   f0109834 <kheap_virtual_address>
f010401c:	83 c4 10             	add    $0x10,%esp
f010401f:	89 c2                	mov    %eax,%edx
f0104021:	8b 45 14             	mov    0x14(%ebp),%eax
f0104024:	89 10                	mov    %edx,(%eax)
f0104026:	eb 44                	jmp    f010406c <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104028:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010402b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104030:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104033:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104036:	c1 e8 0c             	shr    $0xc,%eax
f0104039:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010403c:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f0104041:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104044:	72 17                	jb     f010405d <get_disk_page_table+0x79>
f0104046:	ff 75 f0             	pushl  -0x10(%ebp)
f0104049:	68 00 50 12 f0       	push   $0xf0125000
f010404e:	68 9d 00 00 00       	push   $0x9d
f0104053:	68 9f 4f 12 f0       	push   $0xf0124f9f
f0104058:	e8 dc c2 ff ff       	call   f0100339 <_panic>
f010405d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104060:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104065:	89 c2                	mov    %eax,%edx
f0104067:	8b 45 14             	mov    0x14(%ebp),%eax
f010406a:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010406c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104070:	0f 85 80 00 00 00    	jne    f01040f6 <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0104076:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010407a:	74 6a                	je     f01040e6 <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010407c:	83 ec 0c             	sub    $0xc,%esp
f010407f:	68 00 10 00 00       	push   $0x1000
f0104084:	e8 08 54 00 00       	call   f0109491 <kmalloc>
f0104089:	83 c4 10             	add    $0x10,%esp
f010408c:	89 c2                	mov    %eax,%edx
f010408e:	8b 45 14             	mov    0x14(%ebp),%eax
f0104091:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104093:	8b 45 14             	mov    0x14(%ebp),%eax
f0104096:	8b 00                	mov    (%eax),%eax
f0104098:	85 c0                	test   %eax,%eax
f010409a:	75 07                	jne    f01040a3 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f010409c:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01040a1:	eb 58                	jmp    f01040fb <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01040a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040a6:	c1 e8 16             	shr    $0x16,%eax
f01040a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01040b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01040b3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01040b6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040b9:	8b 00                	mov    (%eax),%eax
f01040bb:	83 ec 0c             	sub    $0xc,%esp
f01040be:	50                   	push   %eax
f01040bf:	e8 13 57 00 00       	call   f01097d7 <kheap_physical_address>
f01040c4:	83 c4 10             	add    $0x10,%esp
f01040c7:	83 c8 01             	or     $0x1,%eax
f01040ca:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01040cc:	8b 45 14             	mov    0x14(%ebp),%eax
f01040cf:	8b 00                	mov    (%eax),%eax
f01040d1:	83 ec 04             	sub    $0x4,%esp
f01040d4:	68 00 10 00 00       	push   $0x1000
f01040d9:	6a 00                	push   $0x0
f01040db:	50                   	push   %eax
f01040dc:	e8 d5 bc 01 00       	call   f011fdb6 <memset>
f01040e1:	83 c4 10             	add    $0x10,%esp
f01040e4:	eb 10                	jmp    f01040f6 <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01040e6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01040ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01040f4:	eb 05                	jmp    f01040fb <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01040f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01040fe:	c9                   	leave  
f01040ff:	c3                   	ret    

f0104100 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0104100:	55                   	push   %ebp
f0104101:	89 e5                	mov    %esp,%ebp
f0104103:	83 ec 28             	sub    $0x28,%esp
f0104106:	8b 45 10             	mov    0x10(%ebp),%eax
f0104109:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f010410c:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104110:	74 72                	je     f0104184 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104112:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010411c:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104121:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104124:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104127:	ba 00 00 00 00       	mov    $0x0,%edx
f010412c:	f7 75 f4             	divl   -0xc(%ebp)
f010412f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104132:	29 d0                	sub    %edx,%eax
f0104134:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104137:	73 2f                	jae    f0104168 <pf_add_empty_env_page+0x68>
f0104139:	8b 45 08             	mov    0x8(%ebp),%eax
f010413c:	8b 50 6c             	mov    0x6c(%eax),%edx
f010413f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104144:	29 d0                	sub    %edx,%eax
f0104146:	c1 e0 0c             	shl    $0xc,%eax
f0104149:	2d 00 20 40 11       	sub    $0x11402000,%eax
f010414e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104151:	76 15                	jbe    f0104168 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104153:	8b 45 08             	mov    0x8(%ebp),%eax
f0104156:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f010415c:	8d 50 01             	lea    0x1(%eax),%edx
f010415f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104162:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104168:	a1 7c 0b 6c f0       	mov    0xf06c0b7c,%eax
f010416d:	83 ec 04             	sub    $0x4,%esp
f0104170:	50                   	push   %eax
f0104171:	ff 75 0c             	pushl  0xc(%ebp)
f0104174:	ff 75 08             	pushl  0x8(%ebp)
f0104177:	e8 b5 00 00 00       	call   f0104231 <pf_add_env_page>
f010417c:	83 c4 10             	add    $0x10,%esp
f010417f:	e9 ab 00 00 00       	jmp    f010422f <pf_add_empty_env_page+0x12f>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104184:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010418b:	76 19                	jbe    f01041a6 <pf_add_empty_env_page+0xa6>
f010418d:	68 30 50 12 f0       	push   $0xf0125030
f0104192:	68 56 50 12 f0       	push   $0xf0125056
f0104197:	68 dc 00 00 00       	push   $0xdc
f010419c:	68 9f 4f 12 f0       	push   $0xf0124f9f
f01041a1:	e8 93 c1 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01041a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01041a9:	83 e8 80             	sub    $0xffffff80,%eax
f01041ac:	83 ec 08             	sub    $0x8,%esp
f01041af:	50                   	push   %eax
f01041b0:	ff 75 08             	pushl  0x8(%ebp)
f01041b3:	e8 c8 05 00 00       	call   f0104780 <get_disk_page_directory>
f01041b8:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01041bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01041be:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01041c4:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01041c7:	52                   	push   %edx
f01041c8:	6a 01                	push   $0x1
f01041ca:	ff 75 0c             	pushl  0xc(%ebp)
f01041cd:	50                   	push   %eax
f01041ce:	e8 11 fe ff ff       	call   f0103fe4 <get_disk_page_table>
f01041d3:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01041d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041d9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041dc:	c1 ea 0c             	shr    $0xc,%edx
f01041df:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041e5:	c1 e2 02             	shl    $0x2,%edx
f01041e8:	01 d0                	add    %edx,%eax
f01041ea:	8b 00                	mov    (%eax),%eax
f01041ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01041ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01041f2:	85 c0                	test   %eax,%eax
f01041f4:	75 34                	jne    f010422a <pf_add_empty_env_page+0x12a>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01041f6:	83 ec 0c             	sub    $0xc,%esp
f01041f9:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01041fc:	50                   	push   %eax
f01041fd:	e8 f3 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f0104202:	83 c4 10             	add    $0x10,%esp
f0104205:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104208:	75 07                	jne    f0104211 <pf_add_empty_env_page+0x111>
f010420a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010420f:	eb 1e                	jmp    f010422f <pf_add_empty_env_page+0x12f>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104211:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104214:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104217:	c1 ea 0c             	shr    $0xc,%edx
f010421a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104220:	c1 e2 02             	shl    $0x2,%edx
f0104223:	01 c2                	add    %eax,%edx
f0104225:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104228:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f010422a:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010422f:	c9                   	leave  
f0104230:	c3                   	ret    

f0104231 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0104231:	55                   	push   %ebp
f0104232:	89 e5                	mov    %esp,%ebp
f0104234:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104237:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010423e:	76 19                	jbe    f0104259 <pf_add_env_page+0x28>
f0104240:	68 30 50 12 f0       	push   $0xf0125030
f0104245:	68 56 50 12 f0       	push   $0xf0125056
f010424a:	68 f1 00 00 00       	push   $0xf1
f010424f:	68 9f 4f 12 f0       	push   $0xf0124f9f
f0104254:	e8 e0 c0 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104259:	8b 45 08             	mov    0x8(%ebp),%eax
f010425c:	83 e8 80             	sub    $0xffffff80,%eax
f010425f:	83 ec 08             	sub    $0x8,%esp
f0104262:	50                   	push   %eax
f0104263:	ff 75 08             	pushl  0x8(%ebp)
f0104266:	e8 15 05 00 00       	call   f0104780 <get_disk_page_directory>
f010426b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010426e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104271:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104277:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010427a:	52                   	push   %edx
f010427b:	6a 01                	push   $0x1
f010427d:	ff 75 0c             	pushl  0xc(%ebp)
f0104280:	50                   	push   %eax
f0104281:	e8 5e fd ff ff       	call   f0103fe4 <get_disk_page_table>
f0104286:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104289:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010428c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010428f:	c1 ea 0c             	shr    $0xc,%edx
f0104292:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104298:	c1 e2 02             	shl    $0x2,%edx
f010429b:	01 d0                	add    %edx,%eax
f010429d:	8b 00                	mov    (%eax),%eax
f010429f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f01042a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042a5:	85 c0                	test   %eax,%eax
f01042a7:	75 34                	jne    f01042dd <pf_add_env_page+0xac>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01042a9:	83 ec 0c             	sub    $0xc,%esp
f01042ac:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01042af:	50                   	push   %eax
f01042b0:	e8 40 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f01042b5:	83 c4 10             	add    $0x10,%esp
f01042b8:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01042bb:	75 07                	jne    f01042c4 <pf_add_env_page+0x93>
f01042bd:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01042c2:	eb 31                	jmp    f01042f5 <pf_add_env_page+0xc4>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01042c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042c7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01042ca:	c1 ea 0c             	shr    $0xc,%edx
f01042cd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01042d3:	c1 e2 02             	shl    $0x2,%edx
f01042d6:	01 c2                	add    %eax,%edx
f01042d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042db:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01042dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042e0:	83 ec 08             	sub    $0x8,%esp
f01042e3:	ff 75 10             	pushl  0x10(%ebp)
f01042e6:	50                   	push   %eax
f01042e7:	e8 5c f9 ff ff       	call   f0103c48 <write_disk_page>
f01042ec:	83 c4 10             	add    $0x10,%esp
f01042ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01042f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01042f5:	c9                   	leave  
f01042f6:	c3                   	ret    

f01042f7 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01042f7:	55                   	push   %ebp
f01042f8:	89 e5                	mov    %esp,%ebp
f01042fa:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01042fd:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104304:	76 19                	jbe    f010431f <pf_update_env_page+0x28>
f0104306:	68 30 50 12 f0       	push   $0xf0125030
f010430b:	68 56 50 12 f0       	push   $0xf0125056
f0104310:	68 13 01 00 00       	push   $0x113
f0104315:	68 9f 4f 12 f0       	push   $0xf0124f9f
f010431a:	e8 1a c0 ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010431f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104322:	83 e8 80             	sub    $0xffffff80,%eax
f0104325:	83 ec 08             	sub    $0x8,%esp
f0104328:	50                   	push   %eax
f0104329:	ff 75 08             	pushl  0x8(%ebp)
f010432c:	e8 4f 04 00 00       	call   f0104780 <get_disk_page_directory>
f0104331:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104334:	8b 45 08             	mov    0x8(%ebp),%eax
f0104337:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010433d:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104340:	52                   	push   %edx
f0104341:	6a 00                	push   $0x0
f0104343:	ff 75 0c             	pushl  0xc(%ebp)
f0104346:	50                   	push   %eax
f0104347:	e8 98 fc ff ff       	call   f0103fe4 <get_disk_page_table>
f010434c:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f010434f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104352:	85 c0                	test   %eax,%eax
f0104354:	74 29                	je     f010437f <pf_update_env_page+0x88>
f0104356:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104359:	85 c0                	test   %eax,%eax
f010435b:	0f 84 c5 00 00 00    	je     f0104426 <pf_update_env_page+0x12f>
f0104361:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104364:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104367:	c1 ea 0c             	shr    $0xc,%edx
f010436a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104370:	c1 e2 02             	shl    $0x2,%edx
f0104373:	01 d0                	add    %edx,%eax
f0104375:	8b 00                	mov    (%eax),%eax
f0104377:	85 c0                	test   %eax,%eax
f0104379:	0f 85 a7 00 00 00    	jne    f0104426 <pf_update_env_page+0x12f>
	{

		uint32 VA = (uint32)virtual_address ;
f010437f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104382:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f0104385:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104388:	85 c0                	test   %eax,%eax
f010438a:	79 09                	jns    f0104395 <pf_update_env_page+0x9e>
f010438c:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f0104393:	76 30                	jbe    f01043c5 <pf_update_env_page+0xce>
f0104395:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010439c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010439f:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01043a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01043a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043aa:	ba 00 00 00 00       	mov    $0x0,%edx
f01043af:	f7 75 f0             	divl   -0x10(%ebp)
f01043b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043b5:	29 d0                	sub    %edx,%eax
f01043b7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01043ba:	77 53                	ja     f010440f <pf_update_env_page+0x118>
f01043bc:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f01043c3:	77 4a                	ja     f010440f <pf_update_env_page+0x118>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f01043c5:	83 ec 04             	sub    $0x4,%esp
f01043c8:	6a 00                	push   $0x0
f01043ca:	ff 75 f4             	pushl  -0xc(%ebp)
f01043cd:	ff 75 08             	pushl  0x8(%ebp)
f01043d0:	e8 2b fd ff ff       	call   f0104100 <pf_add_empty_env_page>
f01043d5:	83 c4 10             	add    $0x10,%esp
f01043d8:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01043db:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f01043df:	75 17                	jne    f01043f8 <pf_update_env_page+0x101>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01043e1:	83 ec 04             	sub    $0x4,%esp
f01043e4:	68 6c 50 12 f0       	push   $0xf012506c
f01043e9:	68 43 01 00 00       	push   $0x143
f01043ee:	68 9f 4f 12 f0       	push   $0xf0124f9f
f01043f3:	e8 41 bf ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01043f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01043fb:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0104401:	8d 50 01             	lea    0x1(%eax),%edx
f0104404:	8b 45 08             	mov    0x8(%ebp),%eax
f0104407:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
f010440d:	eb 17                	jmp    f0104426 <pf_update_env_page+0x12f>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f010440f:	83 ec 04             	sub    $0x4,%esp
f0104412:	68 b8 50 12 f0       	push   $0xf01250b8
f0104417:	68 4c 01 00 00       	push   $0x14c
f010441c:	68 9f 4f 12 f0       	push   $0xf0124f9f
f0104421:	e8 13 bf ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104426:	8b 45 08             	mov    0x8(%ebp),%eax
f0104429:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010442f:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104432:	52                   	push   %edx
f0104433:	6a 00                	push   $0x0
f0104435:	ff 75 0c             	pushl  0xc(%ebp)
f0104438:	50                   	push   %eax
f0104439:	e8 a6 fb ff ff       	call   f0103fe4 <get_disk_page_table>
f010443e:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104441:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104444:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104447:	c1 ea 0c             	shr    $0xc,%edx
f010444a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104450:	c1 e2 02             	shl    $0x2,%edx
f0104453:	01 d0                	add    %edx,%eax
f0104455:	8b 00                	mov    (%eax),%eax
f0104457:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unused VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, USER_LIMIT, 0);
f010445a:	8b 45 08             	mov    0x8(%ebp),%eax
f010445d:	8b 40 64             	mov    0x64(%eax),%eax
f0104460:	6a 00                	push   $0x0
f0104462:	68 00 00 80 ef       	push   $0xef800000
f0104467:	ff 75 10             	pushl  0x10(%ebp)
f010446a:	50                   	push   %eax
f010446b:	e8 0f 42 00 00       	call   f010867f <map_frame>
f0104470:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN(USER_LIMIT, PAGE_SIZE));
f0104473:	c7 45 e0 00 00 80 ef 	movl   $0xef800000,-0x20(%ebp)
f010447a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010447d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104482:	83 ec 08             	sub    $0x8,%esp
f0104485:	50                   	push   %eax
f0104486:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104489:	e8 ba f7 ff ff       	call   f0103c48 <write_disk_page>
f010448e:	83 c4 10             	add    $0x10,%esp
f0104491:	89 45 e8             	mov    %eax,-0x18(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104494:	8b 45 10             	mov    0x10(%ebp),%eax
f0104497:	8b 40 08             	mov    0x8(%eax),%eax
f010449a:	40                   	inc    %eax
f010449b:	8b 55 10             	mov    0x10(%ebp),%edx
f010449e:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, USER_LIMIT);
f01044a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01044a5:	8b 40 64             	mov    0x64(%eax),%eax
f01044a8:	83 ec 08             	sub    $0x8,%esp
f01044ab:	68 00 00 80 ef       	push   $0xef800000
f01044b0:	50                   	push   %eax
f01044b1:	e8 29 43 00 00       	call   f01087df <unmap_frame>
f01044b6:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01044b9:	8b 45 10             	mov    0x10(%ebp),%eax
f01044bc:	8b 40 08             	mov    0x8(%eax),%eax
f01044bf:	48                   	dec    %eax
f01044c0:	8b 55 10             	mov    0x10(%ebp),%edx
f01044c3:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01044c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01044ca:	8b 80 b0 05 00 00    	mov    0x5b0(%eax),%eax
f01044d0:	8d 50 01             	lea    0x1(%eax),%edx
f01044d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01044d6:	89 90 b0 05 00 00    	mov    %edx,0x5b0(%eax)
	//======================

	return ret;
f01044dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01044df:	c9                   	leave  
f01044e0:	c3                   	ret    

f01044e1 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01044e1:	55                   	push   %ebp
f01044e2:	89 e5                	mov    %esp,%ebp
f01044e4:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01044e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01044ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044f5:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01044f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01044fb:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104501:	85 c0                	test   %eax,%eax
f0104503:	75 0a                	jne    f010450f <pf_read_env_page+0x2e>
f0104505:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010450a:	e9 93 00 00 00       	jmp    f01045a2 <pf_read_env_page+0xc1>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f010450f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104512:	8b 45 08             	mov    0x8(%ebp),%eax
f0104515:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010451b:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010451e:	51                   	push   %ecx
f010451f:	6a 00                	push   $0x0
f0104521:	52                   	push   %edx
f0104522:	50                   	push   %eax
f0104523:	e8 bc fa ff ff       	call   f0103fe4 <get_disk_page_table>
f0104528:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010452b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010452e:	85 c0                	test   %eax,%eax
f0104530:	75 07                	jne    f0104539 <pf_read_env_page+0x58>
f0104532:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104537:	eb 69                	jmp    f01045a2 <pf_read_env_page+0xc1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104539:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010453c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010453f:	c1 ea 0c             	shr    $0xc,%edx
f0104542:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104548:	c1 e2 02             	shl    $0x2,%edx
f010454b:	01 d0                	add    %edx,%eax
f010454d:	8b 00                	mov    (%eax),%eax
f010454f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104552:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104556:	75 07                	jne    f010455f <pf_read_env_page+0x7e>
f0104558:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010455d:	eb 43                	jmp    f01045a2 <pf_read_env_page+0xc1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010455f:	83 ec 08             	sub    $0x8,%esp
f0104562:	ff 75 0c             	pushl  0xc(%ebp)
f0104565:	ff 75 f0             	pushl  -0x10(%ebp)
f0104568:	e8 ac f6 ff ff       	call   f0103c19 <read_disk_page>
f010456d:	83 c4 10             	add    $0x10,%esp
f0104570:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104573:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104576:	8b 45 08             	mov    0x8(%ebp),%eax
f0104579:	8b 40 64             	mov    0x64(%eax),%eax
f010457c:	6a 40                	push   $0x40
f010457e:	6a 00                	push   $0x0
f0104580:	52                   	push   %edx
f0104581:	50                   	push   %eax
f0104582:	e8 44 56 00 00       	call   f0109bcb <pt_set_page_permissions>
f0104587:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010458a:	8b 45 08             	mov    0x8(%ebp),%eax
f010458d:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0104593:	8d 50 01             	lea    0x1(%eax),%edx
f0104596:	8b 45 08             	mov    0x8(%ebp),%eax
f0104599:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
	//======================

	return disk_read_error;
f010459f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01045a2:	c9                   	leave  
f01045a3:	c3                   	ret    

f01045a4 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f01045a4:	55                   	push   %ebp
f01045a5:	89 e5                	mov    %esp,%ebp
f01045a7:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01045aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ad:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045b3:	85 c0                	test   %eax,%eax
f01045b5:	74 65                	je     f010461c <pf_remove_env_page+0x78>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01045b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ba:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045c0:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01045c3:	52                   	push   %edx
f01045c4:	6a 00                	push   $0x0
f01045c6:	ff 75 0c             	pushl  0xc(%ebp)
f01045c9:	50                   	push   %eax
f01045ca:	e8 15 fa ff ff       	call   f0103fe4 <get_disk_page_table>
f01045cf:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01045d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045d5:	85 c0                	test   %eax,%eax
f01045d7:	74 46                	je     f010461f <pf_remove_env_page+0x7b>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01045d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045dc:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045df:	c1 ea 0c             	shr    $0xc,%edx
f01045e2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045e8:	c1 e2 02             	shl    $0x2,%edx
f01045eb:	01 d0                	add    %edx,%eax
f01045ed:	8b 00                	mov    (%eax),%eax
f01045ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01045f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045f5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045f8:	c1 ea 0c             	shr    $0xc,%edx
f01045fb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104601:	c1 e2 02             	shl    $0x2,%edx
f0104604:	01 d0                	add    %edx,%eax
f0104606:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f010460c:	83 ec 0c             	sub    $0xc,%esp
f010460f:	ff 75 f4             	pushl  -0xc(%ebp)
f0104612:	e8 cc f8 ff ff       	call   f0103ee3 <free_disk_frame>
f0104617:	83 c4 10             	add    $0x10,%esp
f010461a:	eb 04                	jmp    f0104620 <pf_remove_env_page+0x7c>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010461c:	90                   	nop
f010461d:	eb 01                	jmp    f0104620 <pf_remove_env_page+0x7c>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010461f:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104620:	c9                   	leave  
f0104621:	c3                   	ret    

f0104622 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f0104622:	55                   	push   %ebp
f0104623:	89 e5                	mov    %esp,%ebp
f0104625:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104628:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010462f:	e9 c1 00 00 00       	jmp    f01046f5 <pf_free_env+0xd3>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f0104634:	8b 45 08             	mov    0x8(%ebp),%eax
f0104637:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010463d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104640:	c1 e2 02             	shl    $0x2,%edx
f0104643:	01 d0                	add    %edx,%eax
f0104645:	8b 00                	mov    (%eax),%eax
f0104647:	83 e0 01             	and    $0x1,%eax
f010464a:	85 c0                	test   %eax,%eax
f010464c:	0f 84 9f 00 00 00    	je     f01046f1 <pf_free_env+0xcf>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104652:	8b 45 08             	mov    0x8(%ebp),%eax
f0104655:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010465b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010465e:	c1 e2 02             	shl    $0x2,%edx
f0104661:	01 d0                	add    %edx,%eax
f0104663:	8b 00                	mov    (%eax),%eax
f0104665:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010466a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010466d:	83 ec 0c             	sub    $0xc,%esp
f0104670:	ff 75 ec             	pushl  -0x14(%ebp)
f0104673:	e8 bc 51 00 00       	call   f0109834 <kheap_virtual_address>
f0104678:	83 c4 10             	add    $0x10,%esp
f010467b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010467e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104685:	eb 3a                	jmp    f01046c1 <pf_free_env+0x9f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104687:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010468a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104691:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104694:	01 d0                	add    %edx,%eax
f0104696:	8b 00                	mov    (%eax),%eax
f0104698:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f010469b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010469e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01046a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01046a8:	01 d0                	add    %edx,%eax
f01046aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f01046b0:	83 ec 0c             	sub    $0xc,%esp
f01046b3:	ff 75 e4             	pushl  -0x1c(%ebp)
f01046b6:	e8 28 f8 ff ff       	call   f0103ee3 <free_disk_frame>
f01046bb:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01046be:	ff 45 f0             	incl   -0x10(%ebp)
f01046c1:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01046c8:	76 bd                	jbe    f0104687 <pf_free_env+0x65>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01046ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01046cd:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01046d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01046d6:	c1 e2 02             	shl    $0x2,%edx
f01046d9:	01 d0                	add    %edx,%eax
f01046db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01046e1:	83 ec 0c             	sub    $0xc,%esp
f01046e4:	ff 75 e8             	pushl  -0x18(%ebp)
f01046e7:	e8 05 50 00 00       	call   f01096f1 <kfree>
f01046ec:	83 c4 10             	add    $0x10,%esp
f01046ef:	eb 01                	jmp    f01046f2 <pf_free_env+0xd0>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01046f1:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01046f2:	ff 45 f4             	incl   -0xc(%ebp)
f01046f5:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01046fc:	0f 86 32 ff ff ff    	jbe    f0104634 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f0104702:	8b 45 08             	mov    0x8(%ebp),%eax
f0104705:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010470b:	83 ec 0c             	sub    $0xc,%esp
f010470e:	50                   	push   %eax
f010470f:	e8 dd 4f 00 00       	call   f01096f1 <kfree>
f0104714:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104717:	8b 45 08             	mov    0x8(%ebp),%eax
f010471a:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104721:	00 00 00 
	ptr_env->disk_env_pgdir_PA = 0;
f0104724:	8b 45 08             	mov    0x8(%ebp),%eax
f0104727:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010472e:	00 00 00 


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104731:	8b 45 08             	mov    0x8(%ebp),%eax
f0104734:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010473a:	85 c0                	test   %eax,%eax
f010473c:	74 3f                	je     f010477d <pf_free_env+0x15b>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010473e:	83 ec 0c             	sub    $0xc,%esp
f0104741:	ff 75 08             	pushl  0x8(%ebp)
f0104744:	e8 14 03 00 00       	call   f0104a5d <__pf_remove_env_all_tables>
f0104749:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010474c:	8b 45 08             	mov    0x8(%ebp),%eax
f010474f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104755:	83 ec 0c             	sub    $0xc,%esp
f0104758:	50                   	push   %eax
f0104759:	e8 93 4f 00 00       	call   f01096f1 <kfree>
f010475e:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104761:	8b 45 08             	mov    0x8(%ebp),%eax
f0104764:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010476b:	00 00 00 
	ptr_env->disk_env_tabledir_PA = 0;
f010476e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104771:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f0104778:	00 00 00 
f010477b:	eb 01                	jmp    f010477e <pf_free_env+0x15c>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010477d:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010477e:	c9                   	leave  
f010477f:	c3                   	ret    

f0104780 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0104780:	55                   	push   %ebp
f0104781:	89 e5                	mov    %esp,%ebp
f0104783:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104786:	8b 45 08             	mov    0x8(%ebp),%eax
f0104789:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
f010478f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104792:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104794:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104797:	8b 00                	mov    (%eax),%eax
f0104799:	85 c0                	test   %eax,%eax
f010479b:	75 5b                	jne    f01047f8 <get_disk_page_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010479d:	83 ec 0c             	sub    $0xc,%esp
f01047a0:	68 00 10 00 00       	push   $0x1000
f01047a5:	e8 e7 4c 00 00       	call   f0109491 <kmalloc>
f01047aa:	83 c4 10             	add    $0x10,%esp
f01047ad:	89 c2                	mov    %eax,%edx
f01047af:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b2:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f01047b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b7:	8b 00                	mov    (%eax),%eax
f01047b9:	85 c0                	test   %eax,%eax
f01047bb:	75 07                	jne    f01047c4 <get_disk_page_directory+0x44>
			{
				return E_NO_VM;
f01047bd:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01047c2:	eb 39                	jmp    f01047fd <get_disk_page_directory+0x7d>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f01047c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047c7:	8b 00                	mov    (%eax),%eax
f01047c9:	83 ec 0c             	sub    $0xc,%esp
f01047cc:	50                   	push   %eax
f01047cd:	e8 05 50 00 00       	call   f01097d7 <kheap_physical_address>
f01047d2:	83 c4 10             	add    $0x10,%esp
f01047d5:	89 c2                	mov    %eax,%edx
f01047d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01047da:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01047e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047e3:	8b 00                	mov    (%eax),%eax
f01047e5:	83 ec 04             	sub    $0x4,%esp
f01047e8:	68 00 10 00 00       	push   $0x1000
f01047ed:	6a 00                	push   $0x0
f01047ef:	50                   	push   %eax
f01047f0:	e8 c1 b5 01 00       	call   f011fdb6 <memset>
f01047f5:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01047f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047fd:	c9                   	leave  
f01047fe:	c3                   	ret    

f01047ff <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01047ff:	55                   	push   %ebp
f0104800:	89 e5                	mov    %esp,%ebp
f0104802:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0104805:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010480c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104813:	eb 7e                	jmp    f0104893 <pf_calculate_allocated_pages+0x94>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104815:	8b 45 08             	mov    0x8(%ebp),%eax
f0104818:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010481e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104821:	c1 e2 02             	shl    $0x2,%edx
f0104824:	01 d0                	add    %edx,%eax
f0104826:	8b 00                	mov    (%eax),%eax
f0104828:	83 e0 01             	and    $0x1,%eax
f010482b:	85 c0                	test   %eax,%eax
f010482d:	74 60                	je     f010488f <pf_calculate_allocated_pages+0x90>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f010482f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104832:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104838:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010483b:	c1 e2 02             	shl    $0x2,%edx
f010483e:	01 d0                	add    %edx,%eax
f0104840:	8b 00                	mov    (%eax),%eax
f0104842:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104847:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010484a:	83 ec 0c             	sub    $0xc,%esp
f010484d:	ff 75 e8             	pushl  -0x18(%ebp)
f0104850:	e8 df 4f 00 00       	call   f0109834 <kheap_virtual_address>
f0104855:	83 c4 10             	add    $0x10,%esp
f0104858:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010485b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104862:	eb 20                	jmp    f0104884 <pf_calculate_allocated_pages+0x85>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104864:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104867:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010486e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104871:	01 d0                	add    %edx,%eax
f0104873:	8b 00                	mov    (%eax),%eax
f0104875:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104878:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010487c:	74 03                	je     f0104881 <pf_calculate_allocated_pages+0x82>
				counter ++;
f010487e:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104881:	ff 45 ec             	incl   -0x14(%ebp)
f0104884:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010488b:	76 d7                	jbe    f0104864 <pf_calculate_allocated_pages+0x65>
f010488d:	eb 01                	jmp    f0104890 <pf_calculate_allocated_pages+0x91>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f010488f:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104890:	ff 45 f4             	incl   -0xc(%ebp)
f0104893:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010489a:	0f 86 75 ff ff ff    	jbe    f0104815 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f01048a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f01048a3:	c9                   	leave  
f01048a4:	c3                   	ret    

f01048a5 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f01048a5:	55                   	push   %ebp
f01048a6:	89 e5                	mov    %esp,%ebp
f01048a8:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f01048ab:	83 ec 0c             	sub    $0xc,%esp
f01048ae:	68 b0 0c 6c f0       	push   $0xf06c0cb0
f01048b3:	e8 62 b3 00 00       	call   f010fc1a <acquire_spinlock>
f01048b8:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f01048bb:	a1 ac 0c 6c f0       	mov    0xf06c0cac,%eax
f01048c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01048c3:	83 ec 0c             	sub    $0xc,%esp
f01048c6:	68 b0 0c 6c f0       	push   $0xf06c0cb0
f01048cb:	e8 d1 b3 00 00       	call   f010fca1 <release_spinlock>
f01048d0:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f01048d3:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f01048d6:	c9                   	leave  
f01048d7:	c3                   	ret    

f01048d8 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f01048d8:	55                   	push   %ebp
f01048d9:	89 e5                	mov    %esp,%ebp
f01048db:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f01048de:	8b 45 08             	mov    0x8(%ebp),%eax
f01048e1:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f01048e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ea:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f01048ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ef:	8b 00                	mov    (%eax),%eax
f01048f1:	85 c0                	test   %eax,%eax
f01048f3:	75 5b                	jne    f0104950 <get_disk_table_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f01048f5:	83 ec 0c             	sub    $0xc,%esp
f01048f8:	68 00 10 00 00       	push   $0x1000
f01048fd:	e8 8f 4b 00 00       	call   f0109491 <kmalloc>
f0104902:	83 c4 10             	add    $0x10,%esp
f0104905:	89 c2                	mov    %eax,%edx
f0104907:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490a:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010490c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490f:	8b 00                	mov    (%eax),%eax
f0104911:	85 c0                	test   %eax,%eax
f0104913:	75 07                	jne    f010491c <get_disk_table_directory+0x44>
			{
				return E_NO_VM;
f0104915:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010491a:	eb 39                	jmp    f0104955 <get_disk_table_directory+0x7d>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010491c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010491f:	8b 00                	mov    (%eax),%eax
f0104921:	83 ec 0c             	sub    $0xc,%esp
f0104924:	50                   	push   %eax
f0104925:	e8 ad 4e 00 00       	call   f01097d7 <kheap_physical_address>
f010492a:	83 c4 10             	add    $0x10,%esp
f010492d:	89 c2                	mov    %eax,%edx
f010492f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104932:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104938:	8b 45 0c             	mov    0xc(%ebp),%eax
f010493b:	8b 00                	mov    (%eax),%eax
f010493d:	83 ec 04             	sub    $0x4,%esp
f0104940:	68 00 10 00 00       	push   $0x1000
f0104945:	6a 00                	push   $0x0
f0104947:	50                   	push   %eax
f0104948:	e8 69 b4 01 00       	call   f011fdb6 <memset>
f010494d:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104950:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104955:	c9                   	leave  
f0104956:	c3                   	ret    

f0104957 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104957:	55                   	push   %ebp
f0104958:	89 e5                	mov    %esp,%ebp
f010495a:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010495d:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104964:	76 19                	jbe    f010497f <__pf_write_env_table+0x28>
f0104966:	68 30 50 12 f0       	push   $0xf0125030
f010496b:	68 56 50 12 f0       	push   $0xf0125056
f0104970:	68 91 02 00 00       	push   $0x291
f0104975:	68 9f 4f 12 f0       	push   $0xf0124f9f
f010497a:	e8 ba b9 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010497f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104982:	05 88 00 00 00       	add    $0x88,%eax
f0104987:	83 ec 08             	sub    $0x8,%esp
f010498a:	50                   	push   %eax
f010498b:	ff 75 08             	pushl  0x8(%ebp)
f010498e:	e8 45 ff ff ff       	call   f01048d8 <get_disk_table_directory>
f0104993:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104996:	8b 45 08             	mov    0x8(%ebp),%eax
f0104999:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010499f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049a2:	c1 ea 16             	shr    $0x16,%edx
f01049a5:	c1 e2 02             	shl    $0x2,%edx
f01049a8:	01 d0                	add    %edx,%eax
f01049aa:	8b 00                	mov    (%eax),%eax
f01049ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f01049af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049b2:	85 c0                	test   %eax,%eax
f01049b4:	75 34                	jne    f01049ea <__pf_write_env_table+0x93>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01049b6:	83 ec 0c             	sub    $0xc,%esp
f01049b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01049bc:	50                   	push   %eax
f01049bd:	e8 33 f4 ff ff       	call   f0103df5 <allocate_disk_frame>
f01049c2:	83 c4 10             	add    $0x10,%esp
f01049c5:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01049c8:	75 07                	jne    f01049d1 <__pf_write_env_table+0x7a>
f01049ca:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01049cf:	eb 31                	jmp    f0104a02 <__pf_write_env_table+0xab>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f01049d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01049d4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01049da:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049dd:	c1 ea 16             	shr    $0x16,%edx
f01049e0:	c1 e2 02             	shl    $0x2,%edx
f01049e3:	01 c2                	add    %eax,%edx
f01049e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049e8:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01049ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049ed:	83 ec 08             	sub    $0x8,%esp
f01049f0:	ff 75 10             	pushl  0x10(%ebp)
f01049f3:	50                   	push   %eax
f01049f4:	e8 4f f2 ff ff       	call   f0103c48 <write_disk_page>
f01049f9:	83 c4 10             	add    $0x10,%esp
f01049fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01049ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104a02:	c9                   	leave  
f0104a03:	c3                   	ret    

f0104a04 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104a04:	55                   	push   %ebp
f0104a05:	89 e5                	mov    %esp,%ebp
f0104a07:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a0d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a13:	85 c0                	test   %eax,%eax
f0104a15:	75 07                	jne    f0104a1e <__pf_read_env_table+0x1a>
f0104a17:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a1c:	eb 3d                	jmp    f0104a5b <__pf_read_env_table+0x57>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a21:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a27:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a2a:	c1 ea 16             	shr    $0x16,%edx
f0104a2d:	c1 e2 02             	shl    $0x2,%edx
f0104a30:	01 d0                	add    %edx,%eax
f0104a32:	8b 00                	mov    (%eax),%eax
f0104a34:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a37:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104a3b:	75 07                	jne    f0104a44 <__pf_read_env_table+0x40>
f0104a3d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a42:	eb 17                	jmp    f0104a5b <__pf_read_env_table+0x57>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104a44:	83 ec 08             	sub    $0x8,%esp
f0104a47:	ff 75 10             	pushl  0x10(%ebp)
f0104a4a:	ff 75 f4             	pushl  -0xc(%ebp)
f0104a4d:	e8 c7 f1 ff ff       	call   f0103c19 <read_disk_page>
f0104a52:	83 c4 10             	add    $0x10,%esp
f0104a55:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a5b:	c9                   	leave  
f0104a5c:	c3                   	ret    

f0104a5d <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104a5d:	55                   	push   %ebp
f0104a5e:	89 e5                	mov    %esp,%ebp
f0104a60:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a63:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a66:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a6c:	85 c0                	test   %eax,%eax
f0104a6e:	74 52                	je     f0104ac2 <__pf_remove_env_all_tables+0x65>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a77:	eb 3e                	jmp    f0104ab7 <__pf_remove_env_all_tables+0x5a>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104a79:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a7c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a82:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a85:	c1 e2 02             	shl    $0x2,%edx
f0104a88:	01 d0                	add    %edx,%eax
f0104a8a:	8b 00                	mov    (%eax),%eax
f0104a8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104a8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a92:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a98:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a9b:	c1 e2 02             	shl    $0x2,%edx
f0104a9e:	01 d0                	add    %edx,%eax
f0104aa0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104aa6:	83 ec 0c             	sub    $0xc,%esp
f0104aa9:	ff 75 f0             	pushl  -0x10(%ebp)
f0104aac:	e8 32 f4 ff ff       	call   f0103ee3 <free_disk_frame>
f0104ab1:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104ab4:	ff 45 f4             	incl   -0xc(%ebp)
f0104ab7:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104abe:	76 b9                	jbe    f0104a79 <__pf_remove_env_all_tables+0x1c>
f0104ac0:	eb 01                	jmp    f0104ac3 <__pf_remove_env_all_tables+0x66>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ac2:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104ac3:	c9                   	leave  
f0104ac4:	c3                   	ret    

f0104ac5 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104ac5:	55                   	push   %ebp
f0104ac6:	89 e5                	mov    %esp,%ebp
f0104ac8:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104acb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104acf:	75 10                	jne    f0104ae1 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104ad1:	83 ec 0c             	sub    $0xc,%esp
f0104ad4:	68 34 51 12 f0       	push   $0xf0125134
f0104ad9:	e8 ad c4 ff ff       	call   f0100f8b <cprintf>
f0104ade:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ae1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ae4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104aea:	85 c0                	test   %eax,%eax
f0104aec:	74 43                	je     f0104b31 <__pf_remove_env_table+0x6c>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104aee:	8b 45 08             	mov    0x8(%ebp),%eax
f0104af1:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104af7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104afa:	c1 ea 16             	shr    $0x16,%edx
f0104afd:	c1 e2 02             	shl    $0x2,%edx
f0104b00:	01 d0                	add    %edx,%eax
f0104b02:	8b 00                	mov    (%eax),%eax
f0104b04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104b07:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b0a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104b10:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b13:	c1 ea 16             	shr    $0x16,%edx
f0104b16:	c1 e2 02             	shl    $0x2,%edx
f0104b19:	01 d0                	add    %edx,%eax
f0104b1b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104b21:	83 ec 0c             	sub    $0xc,%esp
f0104b24:	ff 75 f4             	pushl  -0xc(%ebp)
f0104b27:	e8 b7 f3 ff ff       	call   f0103ee3 <free_disk_frame>
f0104b2c:	83 c4 10             	add    $0x10,%esp
f0104b2f:	eb 01                	jmp    f0104b32 <__pf_remove_env_table+0x6d>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104b31:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104b32:	c9                   	leave  
f0104b33:	c3                   	ret    

f0104b34 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104b34:	55                   	push   %ebp
f0104b35:	89 e5                	mov    %esp,%ebp
f0104b37:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104b3a:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104b41:	eb 1f                	jmp    f0104b62 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b46:	83 ec 04             	sub    $0x4,%esp
f0104b49:	6a 08                	push   $0x8
f0104b4b:	ff 75 08             	pushl  0x8(%ebp)
f0104b4e:	50                   	push   %eax
f0104b4f:	e8 9c b9 01 00       	call   f01204f0 <ide_write>
f0104b54:	83 c4 10             	add    $0x10,%esp
f0104b57:	85 c0                	test   %eax,%eax
f0104b59:	75 12                	jne    f0104b6d <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104b5b:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104b62:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104b69:	7e d8                	jle    f0104b43 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6b:	eb 01                	jmp    f0104b6e <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104b6d:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6e:	90                   	nop
f0104b6f:	c9                   	leave  
f0104b70:	c3                   	ret    

f0104b71 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104b71:	55                   	push   %ebp
  pushl %eax
f0104b72:	50                   	push   %eax
  pushl %ebx
f0104b73:	53                   	push   %ebx
  pushl %ecx
f0104b74:	51                   	push   %ecx
  pushl %edx
f0104b75:	52                   	push   %edx
  pushl %esi
f0104b76:	56                   	push   %esi
  pushl %edi
f0104b77:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104b78:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104b7c:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104b80:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104b82:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104b84:	5f                   	pop    %edi
  popl %esi
f0104b85:	5e                   	pop    %esi
  popl %edx
f0104b86:	5a                   	pop    %edx
  popl %ecx
f0104b87:	59                   	pop    %ecx
  popl %ebx
f0104b88:	5b                   	pop    %ebx
  popl %eax
f0104b89:	58                   	pop    %eax
  popl %ebp
f0104b8a:	5d                   	pop    %ebp
  ret
f0104b8b:	c3                   	ret    

f0104b8c <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104b8c:	55                   	push   %ebp
f0104b8d:	89 e5                	mov    %esp,%ebp
f0104b8f:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b95:	0f b6 c0             	movzbl %al,%eax
f0104b98:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b9f:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104ba2:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104ba5:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104ba8:	ee                   	out    %al,(%dx)
f0104ba9:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104bb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104bb3:	89 c2                	mov    %eax,%edx
f0104bb5:	ec                   	in     (%dx),%al
f0104bb6:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104bb9:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104bbc:	0f b6 c0             	movzbl %al,%eax
}
f0104bbf:	c9                   	leave  
f0104bc0:	c3                   	ret    

f0104bc1 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104bc1:	55                   	push   %ebp
f0104bc2:	89 e5                	mov    %esp,%ebp
f0104bc4:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104bc7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bca:	0f b6 c0             	movzbl %al,%eax
f0104bcd:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104bd4:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104bd7:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104bda:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104bdd:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104bde:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104be1:	0f b6 c0             	movzbl %al,%eax
f0104be4:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104beb:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104bee:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104bf1:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104bf4:	ee                   	out    %al,(%dx)
}
f0104bf5:	90                   	nop
f0104bf6:	c9                   	leave  
f0104bf7:	c3                   	ret    

f0104bf8 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104bf8:	55                   	push   %ebp
f0104bf9:	89 e5                	mov    %esp,%ebp
f0104bfb:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104bfe:	c7 05 88 0c 6c f0 00 	movl   $0x0,0xf06c0c88
f0104c05:	00 00 00 
f0104c08:	c7 05 8c 0c 6c f0 00 	movl   $0x0,0xf06c0c8c
f0104c0f:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104c12:	83 ec 08             	sub    $0x8,%esp
f0104c15:	68 bf 6b 10 f0       	push   $0xf0106bbf
f0104c1a:	6a 00                	push   $0x0
f0104c1c:	e8 03 96 00 00       	call   f010e224 <irq_install_handler>
f0104c21:	83 c4 10             	add    $0x10,%esp
}
f0104c24:	90                   	nop
f0104c25:	c9                   	leave  
f0104c26:	c3                   	ret    

f0104c27 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104c27:	55                   	push   %ebp
f0104c28:	89 e5                	mov    %esp,%ebp
f0104c2a:	53                   	push   %ebx
f0104c2b:	83 ec 24             	sub    $0x24,%esp
f0104c2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c31:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104c34:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104c3b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104c3f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104c42:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104c45:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104c46:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104c4a:	77 48                	ja     f0104c94 <kclock_start+0x6d>
f0104c4c:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c53:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104c57:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104c5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c5d:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104c5e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c62:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104c67:	99                   	cltd   
f0104c68:	f7 fb                	idiv   %ebx
f0104c6a:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104c70:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c74:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104c79:	99                   	cltd   
f0104c7a:	f7 fb                	idiv   %ebx
f0104c7c:	89 c3                	mov    %eax,%ebx
f0104c7e:	89 c8                	mov    %ecx,%eax
f0104c80:	99                   	cltd   
f0104c81:	f7 fb                	idiv   %ebx
f0104c83:	0f b7 c0             	movzwl %ax,%eax
f0104c86:	83 ec 0c             	sub    $0xc,%esp
f0104c89:	50                   	push   %eax
f0104c8a:	e8 b3 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104c8f:	83 c4 10             	add    $0x10,%esp
f0104c92:	eb 13                	jmp    f0104ca7 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104c94:	6a 35                	push   $0x35
f0104c96:	68 58 51 12 f0       	push   $0xf0125158
f0104c9b:	6a 41                	push   $0x41
f0104c9d:	68 b4 51 12 f0       	push   $0xf01251b4
f0104ca2:	e8 92 b6 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104ca7:	83 ec 0c             	sub    $0xc,%esp
f0104caa:	6a 00                	push   $0x0
f0104cac:	e8 43 23 00 00       	call   f0106ff4 <irq_clear_mask>
f0104cb1:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104cb4:	90                   	nop
f0104cb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104cb8:	c9                   	leave  
f0104cb9:	c3                   	ret    

f0104cba <kclock_stop>:

void
kclock_stop(void)
{
f0104cba:	55                   	push   %ebp
f0104cbb:	89 e5                	mov    %esp,%ebp
f0104cbd:	83 ec 18             	sub    $0x18,%esp
f0104cc0:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104cc7:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104ccb:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104cce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cd1:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104cd2:	83 ec 0c             	sub    $0xc,%esp
f0104cd5:	6a 00                	push   $0x0
f0104cd7:	e8 a3 22 00 00       	call   f0106f7f <irq_set_mask>
f0104cdc:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104cdf:	90                   	nop
f0104ce0:	c9                   	leave  
f0104ce1:	c3                   	ret    

f0104ce2 <kclock_resume>:

void
kclock_resume(void)
{
f0104ce2:	55                   	push   %ebp
f0104ce3:	89 e5                	mov    %esp,%ebp
f0104ce5:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104ce8:	e8 f5 01 00 00       	call   f0104ee2 <kclock_read_cnt0_latch>
f0104ced:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104cf1:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104cf6:	77 06                	ja     f0104cfe <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104cf8:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104cfe:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d02:	83 e0 01             	and    $0x1,%eax
f0104d05:	66 85 c0             	test   %ax,%ax
f0104d08:	74 09                	je     f0104d13 <kclock_resume+0x31>
		cnt0++;
f0104d0a:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d0e:	40                   	inc    %eax
f0104d0f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104d13:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104d1a:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104d1e:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104d21:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104d24:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d25:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104d29:	83 ec 0c             	sub    $0xc,%esp
f0104d2c:	50                   	push   %eax
f0104d2d:	e8 10 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d32:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d35:	83 ec 0c             	sub    $0xc,%esp
f0104d38:	6a 00                	push   $0x0
f0104d3a:	e8 b5 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d3f:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104d42:	90                   	nop
f0104d43:	c9                   	leave  
f0104d44:	c3                   	ret    

f0104d45 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104d45:	55                   	push   %ebp
f0104d46:	89 e5                	mov    %esp,%ebp
f0104d48:	83 ec 28             	sub    $0x28,%esp
f0104d4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d4e:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104d51:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104d58:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104d5c:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104d5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d62:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d63:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104d67:	83 ec 0c             	sub    $0xc,%esp
f0104d6a:	50                   	push   %eax
f0104d6b:	e8 d2 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d70:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d73:	83 ec 0c             	sub    $0xc,%esp
f0104d76:	6a 00                	push   $0x0
f0104d78:	e8 77 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d7d:	83 c4 10             	add    $0x10,%esp
}
f0104d80:	90                   	nop
f0104d81:	c9                   	leave  
f0104d82:	c3                   	ret    

f0104d83 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104d83:	55                   	push   %ebp
f0104d84:	89 e5                	mov    %esp,%ebp
f0104d86:	56                   	push   %esi
f0104d87:	53                   	push   %ebx
f0104d88:	83 ec 20             	sub    $0x20,%esp
f0104d8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d8e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104d91:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104d95:	0f 87 8a 00 00 00    	ja     f0104e25 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104d9b:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d9f:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104da4:	99                   	cltd   
f0104da5:	f7 fe                	idiv   %esi
f0104da7:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dad:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104db1:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104db6:	99                   	cltd   
f0104db7:	f7 fb                	idiv   %ebx
f0104db9:	89 c6                	mov    %eax,%esi
f0104dbb:	89 c8                	mov    %ecx,%eax
f0104dbd:	99                   	cltd   
f0104dbe:	f7 fe                	idiv   %esi
f0104dc0:	89 c3                	mov    %eax,%ebx
f0104dc2:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104dc6:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104dcb:	99                   	cltd   
f0104dcc:	f7 f9                	idiv   %ecx
f0104dce:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dd4:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104dd8:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104ddd:	99                   	cltd   
f0104dde:	f7 fe                	idiv   %esi
f0104de0:	89 c6                	mov    %eax,%esi
f0104de2:	89 c8                	mov    %ecx,%eax
f0104de4:	99                   	cltd   
f0104de5:	f7 fe                	idiv   %esi
f0104de7:	25 01 00 00 80       	and    $0x80000001,%eax
f0104dec:	85 c0                	test   %eax,%eax
f0104dee:	79 05                	jns    f0104df5 <kclock_set_quantum+0x72>
f0104df0:	48                   	dec    %eax
f0104df1:	83 c8 fe             	or     $0xfffffffe,%eax
f0104df4:	40                   	inc    %eax
f0104df5:	01 d8                	add    %ebx,%eax
f0104df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104dfa:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e01:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e05:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e08:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e0b:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104e0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104e0f:	0f b7 c0             	movzwl %ax,%eax
f0104e12:	83 ec 0c             	sub    $0xc,%esp
f0104e15:	50                   	push   %eax
f0104e16:	e8 27 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104e1b:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104e1e:	e8 97 fe ff ff       	call   f0104cba <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104e23:	eb 16                	jmp    f0104e3b <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104e25:	6a 35                	push   $0x35
f0104e27:	68 58 51 12 f0       	push   $0xf0125158
f0104e2c:	68 ea 00 00 00       	push   $0xea
f0104e31:	68 b4 51 12 f0       	push   $0xf01251b4
f0104e36:	e8 fe b4 ff ff       	call   f0100339 <_panic>
	}
}
f0104e3b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104e3e:	5b                   	pop    %ebx
f0104e3f:	5e                   	pop    %esi
f0104e40:	5d                   	pop    %ebp
f0104e41:	c3                   	ret    

f0104e42 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104e42:	55                   	push   %ebp
f0104e43:	89 e5                	mov    %esp,%ebp
f0104e45:	83 ec 28             	sub    $0x28,%esp
f0104e48:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e4b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104e4f:	e8 7b 23 00 00       	call   f01071cf <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104e54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e57:	0f b6 c0             	movzbl %al,%eax
f0104e5a:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104e61:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104e64:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e6a:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104e6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e6e:	66 c1 e8 08          	shr    $0x8,%ax
f0104e72:	0f b6 c0             	movzbl %al,%eax
f0104e75:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104e7c:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104e7f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e82:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e85:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104e86:	e8 96 23 00 00       	call   f0107221 <popcli>

}
f0104e8b:	90                   	nop
f0104e8c:	c9                   	leave  
f0104e8d:	c3                   	ret    

f0104e8e <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104e8e:	55                   	push   %ebp
f0104e8f:	89 e5                	mov    %esp,%ebp
f0104e91:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104e94:	e8 36 23 00 00       	call   f01071cf <pushcli>
f0104e99:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104ea3:	89 c2                	mov    %eax,%edx
f0104ea5:	ec                   	in     (%dx),%al
f0104ea6:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104ea9:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104eac:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104eaf:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104eb9:	89 c2                	mov    %eax,%edx
f0104ebb:	ec                   	in     (%dx),%al
f0104ebc:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104ebf:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104ec2:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104ec5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104ec9:	c1 e0 08             	shl    $0x8,%eax
f0104ecc:	89 c2                	mov    %eax,%edx
f0104ece:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104ed2:	09 d0                	or     %edx,%eax
f0104ed4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104ed8:	e8 44 23 00 00       	call   f0107221 <popcli>
	return cnt0 ;
f0104edd:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104ee0:	c9                   	leave  
f0104ee1:	c3                   	ret    

f0104ee2 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104ee2:	55                   	push   %ebp
f0104ee3:	89 e5                	mov    %esp,%ebp
f0104ee5:	83 ec 30             	sub    $0x30,%esp
f0104ee8:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eef:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104ef2:	89 c2                	mov    %eax,%edx
f0104ef4:	ec                   	in     (%dx),%al
f0104ef5:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104ef8:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104efb:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104efe:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f05:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f09:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104f0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f0f:	ee                   	out    %al,(%dx)
f0104f10:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104f1a:	89 c2                	mov    %eax,%edx
f0104f1c:	ec                   	in     (%dx),%al
f0104f1d:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104f20:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104f23:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104f26:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104f30:	89 c2                	mov    %eax,%edx
f0104f32:	ec                   	in     (%dx),%al
f0104f33:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104f36:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104f39:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104f3c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104f40:	c1 e0 08             	shl    $0x8,%eax
f0104f43:	89 c2                	mov    %eax,%edx
f0104f45:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104f49:	09 d0                	or     %edx,%eax
f0104f4b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104f4f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104f53:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104f5a:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f5d:	8a 45 df             	mov    -0x21(%ebp),%al
f0104f60:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104f63:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104f64:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104f67:	c9                   	leave  
f0104f68:	c3                   	ret    

f0104f69 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104f69:	55                   	push   %ebp
f0104f6a:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f6c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f70:	74 1d                	je     f0104f8f <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104f72:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f7b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f7e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f85:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f88:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104f8f:	90                   	nop
f0104f90:	5d                   	pop    %ebp
f0104f91:	c3                   	ret    

f0104f92 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104f92:	55                   	push   %ebp
f0104f93:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f95:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f99:	74 08                	je     f0104fa3 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104f9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f9e:	8b 40 0c             	mov    0xc(%eax),%eax
f0104fa1:	eb 05                	jmp    f0104fa8 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104fa3:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104fa8:	5d                   	pop    %ebp
f0104fa9:	c3                   	ret    

f0104faa <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104faa:	55                   	push   %ebp
f0104fab:	89 e5                	mov    %esp,%ebp
f0104fad:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104fb0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fb4:	75 16                	jne    f0104fcc <enqueue+0x22>
f0104fb6:	68 c8 51 12 f0       	push   $0xf01251c8
f0104fbb:	68 d6 51 12 f0       	push   $0xf01251d6
f0104fc0:	6a 34                	push   $0x34
f0104fc2:	68 eb 51 12 f0       	push   $0xf01251eb
f0104fc7:	e8 6d b3 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f0104fcc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd0:	74 66                	je     f0105038 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104fd2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd6:	75 14                	jne    f0104fec <enqueue+0x42>
f0104fd8:	83 ec 04             	sub    $0x4,%esp
f0104fdb:	68 04 52 12 f0       	push   $0xf0125204
f0104fe0:	6a 37                	push   $0x37
f0104fe2:	68 eb 51 12 f0       	push   $0xf01251eb
f0104fe7:	e8 4d b3 ff ff       	call   f0100339 <_panic>
f0104fec:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fef:	8b 10                	mov    (%eax),%edx
f0104ff1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ff4:	89 50 08             	mov    %edx,0x8(%eax)
f0104ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ffa:	8b 40 08             	mov    0x8(%eax),%eax
f0104ffd:	85 c0                	test   %eax,%eax
f0104fff:	74 0d                	je     f010500e <enqueue+0x64>
f0105001:	8b 45 08             	mov    0x8(%ebp),%eax
f0105004:	8b 00                	mov    (%eax),%eax
f0105006:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105009:	89 50 0c             	mov    %edx,0xc(%eax)
f010500c:	eb 09                	jmp    f0105017 <enqueue+0x6d>
f010500e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105011:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105014:	89 50 04             	mov    %edx,0x4(%eax)
f0105017:	8b 45 08             	mov    0x8(%ebp),%eax
f010501a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010501d:	89 10                	mov    %edx,(%eax)
f010501f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105022:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105029:	8b 45 08             	mov    0x8(%ebp),%eax
f010502c:	8b 40 0c             	mov    0xc(%eax),%eax
f010502f:	8d 50 01             	lea    0x1(%eax),%edx
f0105032:	8b 45 08             	mov    0x8(%ebp),%eax
f0105035:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105038:	90                   	nop
f0105039:	c9                   	leave  
f010503a:	c3                   	ret    

f010503b <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f010503b:	55                   	push   %ebp
f010503c:	89 e5                	mov    %esp,%ebp
f010503e:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0105041:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105045:	75 0a                	jne    f0105051 <dequeue+0x16>
f0105047:	b8 00 00 00 00       	mov    $0x0,%eax
f010504c:	e9 a0 00 00 00       	jmp    f01050f1 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0105051:	8b 45 08             	mov    0x8(%ebp),%eax
f0105054:	8b 40 04             	mov    0x4(%eax),%eax
f0105057:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f010505a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010505e:	0f 84 8a 00 00 00    	je     f01050ee <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105064:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105068:	75 14                	jne    f010507e <dequeue+0x43>
f010506a:	83 ec 04             	sub    $0x4,%esp
f010506d:	68 27 52 12 f0       	push   $0xf0125227
f0105072:	6a 44                	push   $0x44
f0105074:	68 eb 51 12 f0       	push   $0xf01251eb
f0105079:	e8 bb b2 ff ff       	call   f0100339 <_panic>
f010507e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105081:	8b 40 08             	mov    0x8(%eax),%eax
f0105084:	85 c0                	test   %eax,%eax
f0105086:	74 11                	je     f0105099 <dequeue+0x5e>
f0105088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010508b:	8b 40 08             	mov    0x8(%eax),%eax
f010508e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105091:	8b 52 0c             	mov    0xc(%edx),%edx
f0105094:	89 50 0c             	mov    %edx,0xc(%eax)
f0105097:	eb 0c                	jmp    f01050a5 <dequeue+0x6a>
f0105099:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010509c:	8b 50 0c             	mov    0xc(%eax),%edx
f010509f:	8b 45 08             	mov    0x8(%ebp),%eax
f01050a2:	89 50 04             	mov    %edx,0x4(%eax)
f01050a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01050ab:	85 c0                	test   %eax,%eax
f01050ad:	74 11                	je     f01050c0 <dequeue+0x85>
f01050af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050b2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050b8:	8b 52 08             	mov    0x8(%edx),%edx
f01050bb:	89 50 08             	mov    %edx,0x8(%eax)
f01050be:	eb 0b                	jmp    f01050cb <dequeue+0x90>
f01050c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050c3:	8b 50 08             	mov    0x8(%eax),%edx
f01050c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01050c9:	89 10                	mov    %edx,(%eax)
f01050cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01050d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01050df:	8b 45 08             	mov    0x8(%ebp),%eax
f01050e2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050e5:	8d 50 ff             	lea    -0x1(%eax),%edx
f01050e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01050eb:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f01050ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01050f1:	c9                   	leave  
f01050f2:	c3                   	ret    

f01050f3 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f01050f3:	55                   	push   %ebp
f01050f4:	89 e5                	mov    %esp,%ebp
f01050f6:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01050f9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01050fd:	75 16                	jne    f0105115 <remove_from_queue+0x22>
f01050ff:	68 c8 51 12 f0       	push   $0xf01251c8
f0105104:	68 d6 51 12 f0       	push   $0xf01251d6
f0105109:	6a 4e                	push   $0x4e
f010510b:	68 eb 51 12 f0       	push   $0xf01251eb
f0105110:	e8 24 b2 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105115:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105119:	0f 84 8a 00 00 00    	je     f01051a9 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f010511f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105123:	75 14                	jne    f0105139 <remove_from_queue+0x46>
f0105125:	83 ec 04             	sub    $0x4,%esp
f0105128:	68 27 52 12 f0       	push   $0xf0125227
f010512d:	6a 52                	push   $0x52
f010512f:	68 eb 51 12 f0       	push   $0xf01251eb
f0105134:	e8 00 b2 ff ff       	call   f0100339 <_panic>
f0105139:	8b 45 0c             	mov    0xc(%ebp),%eax
f010513c:	8b 40 08             	mov    0x8(%eax),%eax
f010513f:	85 c0                	test   %eax,%eax
f0105141:	74 11                	je     f0105154 <remove_from_queue+0x61>
f0105143:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105146:	8b 40 08             	mov    0x8(%eax),%eax
f0105149:	8b 55 0c             	mov    0xc(%ebp),%edx
f010514c:	8b 52 0c             	mov    0xc(%edx),%edx
f010514f:	89 50 0c             	mov    %edx,0xc(%eax)
f0105152:	eb 0c                	jmp    f0105160 <remove_from_queue+0x6d>
f0105154:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105157:	8b 50 0c             	mov    0xc(%eax),%edx
f010515a:	8b 45 08             	mov    0x8(%ebp),%eax
f010515d:	89 50 04             	mov    %edx,0x4(%eax)
f0105160:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105163:	8b 40 0c             	mov    0xc(%eax),%eax
f0105166:	85 c0                	test   %eax,%eax
f0105168:	74 11                	je     f010517b <remove_from_queue+0x88>
f010516a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010516d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105170:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105173:	8b 52 08             	mov    0x8(%edx),%edx
f0105176:	89 50 08             	mov    %edx,0x8(%eax)
f0105179:	eb 0b                	jmp    f0105186 <remove_from_queue+0x93>
f010517b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010517e:	8b 50 08             	mov    0x8(%eax),%edx
f0105181:	8b 45 08             	mov    0x8(%ebp),%eax
f0105184:	89 10                	mov    %edx,(%eax)
f0105186:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105189:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105190:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105193:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010519a:	8b 45 08             	mov    0x8(%ebp),%eax
f010519d:	8b 40 0c             	mov    0xc(%eax),%eax
f01051a0:	8d 50 ff             	lea    -0x1(%eax),%edx
f01051a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01051a6:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f01051a9:	90                   	nop
f01051aa:	c9                   	leave  
f01051ab:	c3                   	ret    

f01051ac <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f01051ac:	55                   	push   %ebp
f01051ad:	89 e5                	mov    %esp,%ebp
f01051af:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01051b2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051b6:	75 07                	jne    f01051bf <find_env_in_queue+0x13>
f01051b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01051bd:	eb 58                	jmp    f0105217 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f01051bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f01051c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01051c9:	8b 00                	mov    (%eax),%eax
f01051cb:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051ce:	eb 19                	jmp    f01051e9 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f01051d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051d3:	8b 40 10             	mov    0x10(%eax),%eax
f01051d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01051d9:	75 05                	jne    f01051e0 <find_env_in_queue+0x34>
		{
			return ptr_env;
f01051db:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051de:	eb 37                	jmp    f0105217 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01051e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01051e3:	8b 40 08             	mov    0x8(%eax),%eax
f01051e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051ed:	74 08                	je     f01051f7 <find_env_in_queue+0x4b>
f01051ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051f2:	8b 40 08             	mov    0x8(%eax),%eax
f01051f5:	eb 05                	jmp    f01051fc <find_env_in_queue+0x50>
f01051f7:	b8 00 00 00 00       	mov    $0x0,%eax
f01051fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01051ff:	89 42 08             	mov    %eax,0x8(%edx)
f0105202:	8b 45 08             	mov    0x8(%ebp),%eax
f0105205:	8b 40 08             	mov    0x8(%eax),%eax
f0105208:	85 c0                	test   %eax,%eax
f010520a:	75 c4                	jne    f01051d0 <find_env_in_queue+0x24>
f010520c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0105210:	75 be                	jne    f01051d0 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105212:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105217:	c9                   	leave  
f0105218:	c3                   	ret    

f0105219 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0105219:	55                   	push   %ebp
f010521a:	89 e5                	mov    %esp,%ebp
f010521c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f010521f:	83 ec 0c             	sub    $0xc,%esp
f0105222:	68 e0 05 6c f0       	push   $0xf06c05e0
f0105227:	e8 ee a9 00 00       	call   f010fc1a <acquire_spinlock>
f010522c:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f010522f:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105234:	85 c0                	test   %eax,%eax
f0105236:	74 11                	je     f0105249 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0105238:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f010523d:	83 ec 0c             	sub    $0xc,%esp
f0105240:	50                   	push   %eax
f0105241:	e8 ab 44 00 00       	call   f01096f1 <kfree>
f0105246:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f0105249:	a1 a4 09 6c f0       	mov    0xf06c09a4,%eax
f010524e:	85 c0                	test   %eax,%eax
f0105250:	74 11                	je     f0105263 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105252:	a1 a4 09 6c f0       	mov    0xf06c09a4,%eax
f0105257:	83 ec 0c             	sub    $0xc,%esp
f010525a:	50                   	push   %eax
f010525b:	e8 91 44 00 00       	call   f01096f1 <kfree>
f0105260:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105263:	83 ec 0c             	sub    $0xc,%esp
f0105266:	68 e0 05 6c f0       	push   $0xf06c05e0
f010526b:	e8 31 aa 00 00       	call   f010fca1 <release_spinlock>
f0105270:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105273:	90                   	nop
f0105274:	c9                   	leave  
f0105275:	c3                   	ret    

f0105276 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105276:	55                   	push   %ebp
f0105277:	89 e5                	mov    %esp,%ebp
f0105279:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010527c:	83 ec 0c             	sub    $0xc,%esp
f010527f:	68 e0 05 6c f0       	push   $0xf06c05e0
f0105284:	e8 aa ab 00 00       	call   f010fe33 <holding_spinlock>
f0105289:	83 c4 10             	add    $0x10,%esp
f010528c:	85 c0                	test   %eax,%eax
f010528e:	75 17                	jne    f01052a7 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105290:	83 ec 04             	sub    $0x4,%esp
f0105293:	68 48 52 12 f0       	push   $0xf0125248
f0105298:	68 85 00 00 00       	push   $0x85
f010529d:	68 eb 51 12 f0       	push   $0xf01251eb
f01052a2:	e8 92 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01052a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052ab:	75 19                	jne    f01052c6 <sched_insert_ready0+0x50>
f01052ad:	68 89 52 12 f0       	push   $0xf0125289
f01052b2:	68 d6 51 12 f0       	push   $0xf01251d6
f01052b7:	68 88 00 00 00       	push   $0x88
f01052bc:	68 eb 51 12 f0       	push   $0xf01251eb
f01052c1:	e8 73 b0 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f01052c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01052c9:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f01052d0:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01052d5:	83 ec 08             	sub    $0x8,%esp
f01052d8:	ff 75 08             	pushl  0x8(%ebp)
f01052db:	50                   	push   %eax
f01052dc:	e8 c9 fc ff ff       	call   f0104faa <enqueue>
f01052e1:	83 c4 10             	add    $0x10,%esp
	}
}
f01052e4:	90                   	nop
f01052e5:	c9                   	leave  
f01052e6:	c3                   	ret    

f01052e7 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f01052e7:	55                   	push   %ebp
f01052e8:	89 e5                	mov    %esp,%ebp
f01052ea:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01052ed:	83 ec 0c             	sub    $0xc,%esp
f01052f0:	68 e0 05 6c f0       	push   $0xf06c05e0
f01052f5:	e8 39 ab 00 00       	call   f010fe33 <holding_spinlock>
f01052fa:	83 c4 10             	add    $0x10,%esp
f01052fd:	85 c0                	test   %eax,%eax
f01052ff:	75 17                	jne    f0105318 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105301:	83 ec 04             	sub    $0x4,%esp
f0105304:	68 48 52 12 f0       	push   $0xf0125248
f0105309:	68 97 00 00 00       	push   $0x97
f010530e:	68 eb 51 12 f0       	push   $0xf01251eb
f0105313:	e8 21 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105318:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010531c:	74 0b                	je     f0105329 <sched_remove_ready+0x42>
f010531e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105321:	8b 40 18             	mov    0x18(%eax),%eax
f0105324:	83 f8 01             	cmp    $0x1,%eax
f0105327:	74 19                	je     f0105342 <sched_remove_ready+0x5b>
f0105329:	68 98 52 12 f0       	push   $0xf0125298
f010532e:	68 d6 51 12 f0       	push   $0xf01251d6
f0105333:	68 9a 00 00 00       	push   $0x9a
f0105338:	68 eb 51 12 f0       	push   $0xf01251eb
f010533d:	e8 f7 af ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105342:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105349:	e9 e4 00 00 00       	jmp    f0105432 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f010534e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105351:	8b 40 10             	mov    0x10(%eax),%eax
f0105354:	89 c2                	mov    %eax,%edx
f0105356:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f010535b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010535e:	c1 e1 04             	shl    $0x4,%ecx
f0105361:	01 c8                	add    %ecx,%eax
f0105363:	83 ec 08             	sub    $0x8,%esp
f0105366:	52                   	push   %edx
f0105367:	50                   	push   %eax
f0105368:	e8 3f fe ff ff       	call   f01051ac <find_env_in_queue>
f010536d:	83 c4 10             	add    $0x10,%esp
f0105370:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0105373:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105377:	0f 84 b2 00 00 00    	je     f010542f <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f010537d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105381:	75 17                	jne    f010539a <sched_remove_ready+0xb3>
f0105383:	83 ec 04             	sub    $0x4,%esp
f0105386:	68 27 52 12 f0       	push   $0xf0125227
f010538b:	68 a1 00 00 00       	push   $0xa1
f0105390:	68 eb 51 12 f0       	push   $0xf01251eb
f0105395:	e8 9f af ff ff       	call   f0100339 <_panic>
f010539a:	8b 45 08             	mov    0x8(%ebp),%eax
f010539d:	8b 40 08             	mov    0x8(%eax),%eax
f01053a0:	85 c0                	test   %eax,%eax
f01053a2:	74 11                	je     f01053b5 <sched_remove_ready+0xce>
f01053a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01053a7:	8b 40 08             	mov    0x8(%eax),%eax
f01053aa:	8b 55 08             	mov    0x8(%ebp),%edx
f01053ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01053b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01053b3:	eb 16                	jmp    f01053cb <sched_remove_ready+0xe4>
f01053b5:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01053ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053bd:	c1 e2 04             	shl    $0x4,%edx
f01053c0:	01 c2                	add    %eax,%edx
f01053c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01053c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01053c8:	89 42 04             	mov    %eax,0x4(%edx)
f01053cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053ce:	8b 40 0c             	mov    0xc(%eax),%eax
f01053d1:	85 c0                	test   %eax,%eax
f01053d3:	74 11                	je     f01053e6 <sched_remove_ready+0xff>
f01053d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01053d8:	8b 40 0c             	mov    0xc(%eax),%eax
f01053db:	8b 55 08             	mov    0x8(%ebp),%edx
f01053de:	8b 52 08             	mov    0x8(%edx),%edx
f01053e1:	89 50 08             	mov    %edx,0x8(%eax)
f01053e4:	eb 15                	jmp    f01053fb <sched_remove_ready+0x114>
f01053e6:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01053eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053ee:	c1 e2 04             	shl    $0x4,%edx
f01053f1:	01 c2                	add    %eax,%edx
f01053f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f6:	8b 40 08             	mov    0x8(%eax),%eax
f01053f9:	89 02                	mov    %eax,(%edx)
f01053fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053fe:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105405:	8b 45 08             	mov    0x8(%ebp),%eax
f0105408:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010540f:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105414:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105417:	c1 e2 04             	shl    $0x4,%edx
f010541a:	01 d0                	add    %edx,%eax
f010541c:	8b 50 0c             	mov    0xc(%eax),%edx
f010541f:	4a                   	dec    %edx
f0105420:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f0105423:	8b 45 08             	mov    0x8(%ebp),%eax
f0105426:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f010542d:	eb 14                	jmp    f0105443 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010542f:	ff 45 f4             	incl   -0xc(%ebp)
f0105432:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f0105437:	0f b6 c0             	movzbl %al,%eax
f010543a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010543d:	0f 8f 0b ff ff ff    	jg     f010534e <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f0105443:	c9                   	leave  
f0105444:	c3                   	ret    

f0105445 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f0105445:	55                   	push   %ebp
f0105446:	89 e5                	mov    %esp,%ebp
f0105448:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010544b:	83 ec 0c             	sub    $0xc,%esp
f010544e:	68 e0 05 6c f0       	push   $0xf06c05e0
f0105453:	e8 db a9 00 00       	call   f010fe33 <holding_spinlock>
f0105458:	83 c4 10             	add    $0x10,%esp
f010545b:	85 c0                	test   %eax,%eax
f010545d:	75 17                	jne    f0105476 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010545f:	83 ec 04             	sub    $0x4,%esp
f0105462:	68 48 52 12 f0       	push   $0xf0125248
f0105467:	68 b0 00 00 00       	push   $0xb0
f010546c:	68 eb 51 12 f0       	push   $0xf01251eb
f0105471:	e8 c3 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105476:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010547a:	75 19                	jne    f0105495 <sched_insert_new+0x50>
f010547c:	68 89 52 12 f0       	push   $0xf0125289
f0105481:	68 d6 51 12 f0       	push   $0xf01251d6
f0105486:	68 b3 00 00 00       	push   $0xb3
f010548b:	68 eb 51 12 f0       	push   $0xf01251eb
f0105490:	e8 a4 ae ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105495:	8b 45 08             	mov    0x8(%ebp),%eax
f0105498:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010549f:	83 ec 08             	sub    $0x8,%esp
f01054a2:	ff 75 08             	pushl  0x8(%ebp)
f01054a5:	68 50 06 6c f0       	push   $0xf06c0650
f01054aa:	e8 fb fa ff ff       	call   f0104faa <enqueue>
f01054af:	83 c4 10             	add    $0x10,%esp
	}
}
f01054b2:	90                   	nop
f01054b3:	c9                   	leave  
f01054b4:	c3                   	ret    

f01054b5 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f01054b5:	55                   	push   %ebp
f01054b6:	89 e5                	mov    %esp,%ebp
f01054b8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01054bb:	83 ec 0c             	sub    $0xc,%esp
f01054be:	68 e0 05 6c f0       	push   $0xf06c05e0
f01054c3:	e8 6b a9 00 00       	call   f010fe33 <holding_spinlock>
f01054c8:	83 c4 10             	add    $0x10,%esp
f01054cb:	85 c0                	test   %eax,%eax
f01054cd:	75 17                	jne    f01054e6 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054cf:	83 ec 04             	sub    $0x4,%esp
f01054d2:	68 48 52 12 f0       	push   $0xf0125248
f01054d7:	68 c1 00 00 00       	push   $0xc1
f01054dc:	68 eb 51 12 f0       	push   $0xf01251eb
f01054e1:	e8 53 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f01054e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01054ea:	74 0b                	je     f01054f7 <sched_remove_new+0x42>
f01054ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01054ef:	8b 40 18             	mov    0x18(%eax),%eax
f01054f2:	83 f8 04             	cmp    $0x4,%eax
f01054f5:	74 19                	je     f0105510 <sched_remove_new+0x5b>
f01054f7:	68 c4 52 12 f0       	push   $0xf01252c4
f01054fc:	68 d6 51 12 f0       	push   $0xf01251d6
f0105501:	68 c4 00 00 00       	push   $0xc4
f0105506:	68 eb 51 12 f0       	push   $0xf01251eb
f010550b:	e8 29 ae ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f0105510:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105514:	75 17                	jne    f010552d <sched_remove_new+0x78>
f0105516:	83 ec 04             	sub    $0x4,%esp
f0105519:	68 27 52 12 f0       	push   $0xf0125227
f010551e:	68 c6 00 00 00       	push   $0xc6
f0105523:	68 eb 51 12 f0       	push   $0xf01251eb
f0105528:	e8 0c ae ff ff       	call   f0100339 <_panic>
f010552d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105530:	8b 40 08             	mov    0x8(%eax),%eax
f0105533:	85 c0                	test   %eax,%eax
f0105535:	74 11                	je     f0105548 <sched_remove_new+0x93>
f0105537:	8b 45 08             	mov    0x8(%ebp),%eax
f010553a:	8b 40 08             	mov    0x8(%eax),%eax
f010553d:	8b 55 08             	mov    0x8(%ebp),%edx
f0105540:	8b 52 0c             	mov    0xc(%edx),%edx
f0105543:	89 50 0c             	mov    %edx,0xc(%eax)
f0105546:	eb 0b                	jmp    f0105553 <sched_remove_new+0x9e>
f0105548:	8b 45 08             	mov    0x8(%ebp),%eax
f010554b:	8b 40 0c             	mov    0xc(%eax),%eax
f010554e:	a3 54 06 6c f0       	mov    %eax,0xf06c0654
f0105553:	8b 45 08             	mov    0x8(%ebp),%eax
f0105556:	8b 40 0c             	mov    0xc(%eax),%eax
f0105559:	85 c0                	test   %eax,%eax
f010555b:	74 11                	je     f010556e <sched_remove_new+0xb9>
f010555d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105560:	8b 40 0c             	mov    0xc(%eax),%eax
f0105563:	8b 55 08             	mov    0x8(%ebp),%edx
f0105566:	8b 52 08             	mov    0x8(%edx),%edx
f0105569:	89 50 08             	mov    %edx,0x8(%eax)
f010556c:	eb 0b                	jmp    f0105579 <sched_remove_new+0xc4>
f010556e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105571:	8b 40 08             	mov    0x8(%eax),%eax
f0105574:	a3 50 06 6c f0       	mov    %eax,0xf06c0650
f0105579:	8b 45 08             	mov    0x8(%ebp),%eax
f010557c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105583:	8b 45 08             	mov    0x8(%ebp),%eax
f0105586:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010558d:	a1 5c 06 6c f0       	mov    0xf06c065c,%eax
f0105592:	48                   	dec    %eax
f0105593:	a3 5c 06 6c f0       	mov    %eax,0xf06c065c
		env->env_status = ENV_UNKNOWN;
f0105598:	8b 45 08             	mov    0x8(%ebp),%eax
f010559b:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01055a2:	90                   	nop
f01055a3:	c9                   	leave  
f01055a4:	c3                   	ret    

f01055a5 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f01055a5:	55                   	push   %ebp
f01055a6:	89 e5                	mov    %esp,%ebp
f01055a8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01055ab:	83 ec 0c             	sub    $0xc,%esp
f01055ae:	68 e0 05 6c f0       	push   $0xf06c05e0
f01055b3:	e8 7b a8 00 00       	call   f010fe33 <holding_spinlock>
f01055b8:	83 c4 10             	add    $0x10,%esp
f01055bb:	85 c0                	test   %eax,%eax
f01055bd:	75 17                	jne    f01055d6 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01055bf:	83 ec 04             	sub    $0x4,%esp
f01055c2:	68 48 52 12 f0       	push   $0xf0125248
f01055c7:	68 d2 00 00 00       	push   $0xd2
f01055cc:	68 eb 51 12 f0       	push   $0xf01251eb
f01055d1:	e8 63 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01055d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055da:	75 19                	jne    f01055f5 <sched_insert_exit+0x50>
f01055dc:	68 89 52 12 f0       	push   $0xf0125289
f01055e1:	68 d6 51 12 f0       	push   $0xf01251d6
f01055e6:	68 d5 00 00 00       	push   $0xd5
f01055eb:	68 eb 51 12 f0       	push   $0xf01251eb
f01055f0:	e8 44 ad ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f01055f5:	e8 90 a0 00 00       	call   f010f68a <isBufferingEnabled>
f01055fa:	84 c0                	test   %al,%al
f01055fc:	74 0e                	je     f010560c <sched_insert_exit+0x67>
f01055fe:	83 ec 0c             	sub    $0xc,%esp
f0105601:	ff 75 08             	pushl  0x8(%ebp)
f0105604:	e8 04 76 00 00       	call   f010cc0d <cleanup_buffers>
f0105609:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f010560c:	8b 45 08             	mov    0x8(%ebp),%eax
f010560f:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105616:	83 ec 08             	sub    $0x8,%esp
f0105619:	ff 75 08             	pushl  0x8(%ebp)
f010561c:	68 60 06 6c f0       	push   $0xf06c0660
f0105621:	e8 84 f9 ff ff       	call   f0104faa <enqueue>
f0105626:	83 c4 10             	add    $0x10,%esp
	}
}
f0105629:	90                   	nop
f010562a:	c9                   	leave  
f010562b:	c3                   	ret    

f010562c <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f010562c:	55                   	push   %ebp
f010562d:	89 e5                	mov    %esp,%ebp
f010562f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105632:	83 ec 0c             	sub    $0xc,%esp
f0105635:	68 e0 05 6c f0       	push   $0xf06c05e0
f010563a:	e8 f4 a7 00 00       	call   f010fe33 <holding_spinlock>
f010563f:	83 c4 10             	add    $0x10,%esp
f0105642:	85 c0                	test   %eax,%eax
f0105644:	75 17                	jne    f010565d <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105646:	83 ec 04             	sub    $0x4,%esp
f0105649:	68 48 52 12 f0       	push   $0xf0125248
f010564e:	68 e3 00 00 00       	push   $0xe3
f0105653:	68 eb 51 12 f0       	push   $0xf01251eb
f0105658:	e8 dc ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f010565d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105661:	74 0b                	je     f010566e <sched_remove_exit+0x42>
f0105663:	8b 45 08             	mov    0x8(%ebp),%eax
f0105666:	8b 40 18             	mov    0x18(%eax),%eax
f0105669:	83 f8 05             	cmp    $0x5,%eax
f010566c:	74 19                	je     f0105687 <sched_remove_exit+0x5b>
f010566e:	68 f0 52 12 f0       	push   $0xf01252f0
f0105673:	68 d6 51 12 f0       	push   $0xf01251d6
f0105678:	68 e6 00 00 00       	push   $0xe6
f010567d:	68 eb 51 12 f0       	push   $0xf01251eb
f0105682:	e8 b2 ac ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105687:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010568b:	75 17                	jne    f01056a4 <sched_remove_exit+0x78>
f010568d:	83 ec 04             	sub    $0x4,%esp
f0105690:	68 27 52 12 f0       	push   $0xf0125227
f0105695:	68 e8 00 00 00       	push   $0xe8
f010569a:	68 eb 51 12 f0       	push   $0xf01251eb
f010569f:	e8 95 ac ff ff       	call   f0100339 <_panic>
f01056a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056a7:	8b 40 08             	mov    0x8(%eax),%eax
f01056aa:	85 c0                	test   %eax,%eax
f01056ac:	74 11                	je     f01056bf <sched_remove_exit+0x93>
f01056ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b1:	8b 40 08             	mov    0x8(%eax),%eax
f01056b4:	8b 55 08             	mov    0x8(%ebp),%edx
f01056b7:	8b 52 0c             	mov    0xc(%edx),%edx
f01056ba:	89 50 0c             	mov    %edx,0xc(%eax)
f01056bd:	eb 0b                	jmp    f01056ca <sched_remove_exit+0x9e>
f01056bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01056c2:	8b 40 0c             	mov    0xc(%eax),%eax
f01056c5:	a3 64 06 6c f0       	mov    %eax,0xf06c0664
f01056ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01056cd:	8b 40 0c             	mov    0xc(%eax),%eax
f01056d0:	85 c0                	test   %eax,%eax
f01056d2:	74 11                	je     f01056e5 <sched_remove_exit+0xb9>
f01056d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056d7:	8b 40 0c             	mov    0xc(%eax),%eax
f01056da:	8b 55 08             	mov    0x8(%ebp),%edx
f01056dd:	8b 52 08             	mov    0x8(%edx),%edx
f01056e0:	89 50 08             	mov    %edx,0x8(%eax)
f01056e3:	eb 0b                	jmp    f01056f0 <sched_remove_exit+0xc4>
f01056e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01056e8:	8b 40 08             	mov    0x8(%eax),%eax
f01056eb:	a3 60 06 6c f0       	mov    %eax,0xf06c0660
f01056f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01056f3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01056fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01056fd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105704:	a1 6c 06 6c f0       	mov    0xf06c066c,%eax
f0105709:	48                   	dec    %eax
f010570a:	a3 6c 06 6c f0       	mov    %eax,0xf06c066c
		env->env_status = ENV_UNKNOWN;
f010570f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105712:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105719:	90                   	nop
f010571a:	c9                   	leave  
f010571b:	c3                   	ret    

f010571c <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f010571c:	55                   	push   %ebp
f010571d:	89 e5                	mov    %esp,%ebp
f010571f:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105722:	83 ec 0c             	sub    $0xc,%esp
f0105725:	68 e0 05 6c f0       	push   $0xf06c05e0
f010572a:	e8 eb a4 00 00       	call   f010fc1a <acquire_spinlock>
f010572f:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f0105732:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105736:	75 19                	jne    f0105751 <sched_new_env+0x35>
f0105738:	68 1b 53 12 f0       	push   $0xf012531b
f010573d:	68 d6 51 12 f0       	push   $0xf01251d6
f0105742:	68 f6 00 00 00       	push   $0xf6
f0105747:	68 eb 51 12 f0       	push   $0xf01251eb
f010574c:	e8 e8 ab ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f0105751:	83 ec 0c             	sub    $0xc,%esp
f0105754:	ff 75 08             	pushl  0x8(%ebp)
f0105757:	e8 e9 fc ff ff       	call   f0105445 <sched_insert_new>
f010575c:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010575f:	83 ec 0c             	sub    $0xc,%esp
f0105762:	68 e0 05 6c f0       	push   $0xf06c05e0
f0105767:	e8 35 a5 00 00       	call   f010fca1 <release_spinlock>
f010576c:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f010576f:	90                   	nop
f0105770:	c9                   	leave  
f0105771:	c3                   	ret    

f0105772 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f0105772:	55                   	push   %ebp
f0105773:	89 e5                	mov    %esp,%ebp
f0105775:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105778:	83 ec 0c             	sub    $0xc,%esp
f010577b:	68 e0 05 6c f0       	push   $0xf06c05e0
f0105780:	e8 95 a4 00 00       	call   f010fc1a <acquire_spinlock>
f0105785:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105788:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010578f:	a1 50 06 6c f0       	mov    0xf06c0650,%eax
f0105794:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105797:	eb 53                	jmp    f01057ec <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105799:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010579c:	8b 40 10             	mov    0x10(%eax),%eax
f010579f:	3b 45 08             	cmp    0x8(%ebp),%eax
f01057a2:	75 40                	jne    f01057e4 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f01057a4:	83 ec 0c             	sub    $0xc,%esp
f01057a7:	ff 75 f4             	pushl  -0xc(%ebp)
f01057aa:	e8 06 fd ff ff       	call   f01054b5 <sched_remove_new>
f01057af:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f01057b2:	83 ec 0c             	sub    $0xc,%esp
f01057b5:	ff 75 f4             	pushl  -0xc(%ebp)
f01057b8:	e8 b9 fa ff ff       	call   f0105276 <sched_insert_ready0>
f01057bd:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f01057c0:	e8 47 19 00 00       	call   f010710c <mycpu>
f01057c5:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01057cb:	85 c0                	test   %eax,%eax
f01057cd:	75 46                	jne    f0105815 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01057cf:	83 ec 0c             	sub    $0xc,%esp
f01057d2:	68 e0 05 6c f0       	push   $0xf06c05e0
f01057d7:	e8 c5 a4 00 00       	call   f010fca1 <release_spinlock>
f01057dc:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f01057df:	e8 ad 0f 00 00       	call   f0106791 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057e4:	a1 58 06 6c f0       	mov    0xf06c0658,%eax
f01057e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01057f0:	74 08                	je     f01057fa <sched_run_env+0x88>
f01057f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057f5:	8b 40 08             	mov    0x8(%eax),%eax
f01057f8:	eb 05                	jmp    f01057ff <sched_run_env+0x8d>
f01057fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01057ff:	a3 58 06 6c f0       	mov    %eax,0xf06c0658
f0105804:	a1 58 06 6c f0       	mov    0xf06c0658,%eax
f0105809:	85 c0                	test   %eax,%eax
f010580b:	75 8c                	jne    f0105799 <sched_run_env+0x27>
f010580d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105811:	75 86                	jne    f0105799 <sched_run_env+0x27>
f0105813:	eb 01                	jmp    f0105816 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105815:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105816:	83 ec 0c             	sub    $0xc,%esp
f0105819:	68 e0 05 6c f0       	push   $0xf06c05e0
f010581e:	e8 7e a4 00 00       	call   f010fca1 <release_spinlock>
f0105823:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105826:	90                   	nop
f0105827:	c9                   	leave  
f0105828:	c3                   	ret    

f0105829 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105829:	55                   	push   %ebp
f010582a:	89 e5                	mov    %esp,%ebp
f010582c:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f010582f:	83 ec 0c             	sub    $0xc,%esp
f0105832:	68 e0 05 6c f0       	push   $0xf06c05e0
f0105837:	e8 f7 a5 00 00       	call   f010fe33 <holding_spinlock>
f010583c:	83 c4 10             	add    $0x10,%esp
f010583f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105842:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105846:	75 10                	jne    f0105858 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105848:	83 ec 0c             	sub    $0xc,%esp
f010584b:	68 e0 05 6c f0       	push   $0xf06c05e0
f0105850:	e8 c5 a3 00 00       	call   f010fc1a <acquire_spinlock>
f0105855:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105858:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f010585f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105866:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010586a:	75 59                	jne    f01058c5 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010586c:	a1 50 06 6c f0       	mov    0xf06c0650,%eax
f0105871:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105874:	eb 28                	jmp    f010589e <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105876:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105879:	8b 40 10             	mov    0x10(%eax),%eax
f010587c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010587f:	75 15                	jne    f0105896 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105881:	83 ec 0c             	sub    $0xc,%esp
f0105884:	ff 75 f4             	pushl  -0xc(%ebp)
f0105887:	e8 29 fc ff ff       	call   f01054b5 <sched_remove_new>
f010588c:	83 c4 10             	add    $0x10,%esp
				found = 1;
f010588f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105896:	a1 58 06 6c f0       	mov    0xf06c0658,%eax
f010589b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010589e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058a2:	74 08                	je     f01058ac <sched_exit_env+0x83>
f01058a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058a7:	8b 40 08             	mov    0x8(%eax),%eax
f01058aa:	eb 05                	jmp    f01058b1 <sched_exit_env+0x88>
f01058ac:	b8 00 00 00 00       	mov    $0x0,%eax
f01058b1:	a3 58 06 6c f0       	mov    %eax,0xf06c0658
f01058b6:	a1 58 06 6c f0       	mov    0xf06c0658,%eax
f01058bb:	85 c0                	test   %eax,%eax
f01058bd:	75 b7                	jne    f0105876 <sched_exit_env+0x4d>
f01058bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058c3:	75 b1                	jne    f0105876 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f01058c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01058c9:	0f 85 67 01 00 00    	jne    f0105a36 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01058cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01058d6:	e9 47 01 00 00       	jmp    f0105a22 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01058db:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01058e0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058e3:	c1 e2 04             	shl    $0x4,%edx
f01058e6:	01 d0                	add    %edx,%eax
f01058e8:	8b 00                	mov    (%eax),%eax
f01058ea:	85 c0                	test   %eax,%eax
f01058ec:	0f 84 27 01 00 00    	je     f0105a19 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f01058f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01058f9:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01058fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105901:	c1 e2 04             	shl    $0x4,%edx
f0105904:	01 d0                	add    %edx,%eax
f0105906:	8b 00                	mov    (%eax),%eax
f0105908:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010590b:	e9 d1 00 00 00       	jmp    f01059e1 <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105910:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105913:	8b 40 10             	mov    0x10(%eax),%eax
f0105916:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105919:	0f 85 af 00 00 00    	jne    f01059ce <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010591f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105923:	75 17                	jne    f010593c <sched_exit_env+0x113>
f0105925:	83 ec 04             	sub    $0x4,%esp
f0105928:	68 27 52 12 f0       	push   $0xf0125227
f010592d:	68 44 01 00 00       	push   $0x144
f0105932:	68 eb 51 12 f0       	push   $0xf01251eb
f0105937:	e8 fd a9 ff ff       	call   f0100339 <_panic>
f010593c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010593f:	8b 40 08             	mov    0x8(%eax),%eax
f0105942:	85 c0                	test   %eax,%eax
f0105944:	74 11                	je     f0105957 <sched_exit_env+0x12e>
f0105946:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105949:	8b 40 08             	mov    0x8(%eax),%eax
f010594c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010594f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105952:	89 50 0c             	mov    %edx,0xc(%eax)
f0105955:	eb 16                	jmp    f010596d <sched_exit_env+0x144>
f0105957:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f010595c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010595f:	c1 e2 04             	shl    $0x4,%edx
f0105962:	01 c2                	add    %eax,%edx
f0105964:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105967:	8b 40 0c             	mov    0xc(%eax),%eax
f010596a:	89 42 04             	mov    %eax,0x4(%edx)
f010596d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105970:	8b 40 0c             	mov    0xc(%eax),%eax
f0105973:	85 c0                	test   %eax,%eax
f0105975:	74 11                	je     f0105988 <sched_exit_env+0x15f>
f0105977:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010597a:	8b 40 0c             	mov    0xc(%eax),%eax
f010597d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105980:	8b 52 08             	mov    0x8(%edx),%edx
f0105983:	89 50 08             	mov    %edx,0x8(%eax)
f0105986:	eb 15                	jmp    f010599d <sched_exit_env+0x174>
f0105988:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f010598d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105990:	c1 e2 04             	shl    $0x4,%edx
f0105993:	01 c2                	add    %eax,%edx
f0105995:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105998:	8b 40 08             	mov    0x8(%eax),%eax
f010599b:	89 02                	mov    %eax,(%edx)
f010599d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059a0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01059a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059aa:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01059b1:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01059b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059b9:	c1 e2 04             	shl    $0x4,%edx
f01059bc:	01 d0                	add    %edx,%eax
f01059be:	8b 50 0c             	mov    0xc(%eax),%edx
f01059c1:	4a                   	dec    %edx
f01059c2:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f01059c5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f01059cc:	eb 4b                	jmp    f0105a19 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01059ce:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01059d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059d6:	c1 e2 04             	shl    $0x4,%edx
f01059d9:	01 d0                	add    %edx,%eax
f01059db:	8b 40 08             	mov    0x8(%eax),%eax
f01059de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01059e1:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01059e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059e9:	c1 e2 04             	shl    $0x4,%edx
f01059ec:	01 d0                	add    %edx,%eax
f01059ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059f2:	74 08                	je     f01059fc <sched_exit_env+0x1d3>
f01059f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01059f7:	8b 52 08             	mov    0x8(%edx),%edx
f01059fa:	eb 05                	jmp    f0105a01 <sched_exit_env+0x1d8>
f01059fc:	ba 00 00 00 00       	mov    $0x0,%edx
f0105a01:	89 50 08             	mov    %edx,0x8(%eax)
f0105a04:	8b 40 08             	mov    0x8(%eax),%eax
f0105a07:	85 c0                	test   %eax,%eax
f0105a09:	0f 85 01 ff ff ff    	jne    f0105910 <sched_exit_env+0xe7>
f0105a0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a13:	0f 85 f7 fe ff ff    	jne    f0105910 <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a1d:	75 16                	jne    f0105a35 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105a1f:	ff 45 ec             	incl   -0x14(%ebp)
f0105a22:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f0105a27:	0f b6 c0             	movzbl %al,%eax
f0105a2a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105a2d:	0f 8f a8 fe ff ff    	jg     f01058db <sched_exit_env+0xb2>
f0105a33:	eb 01                	jmp    f0105a36 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a35:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105a36:	e8 50 5f 00 00       	call   f010b98b <get_cpu_proc>
f0105a3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105a3e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105a42:	75 19                	jne    f0105a5d <sched_exit_env+0x234>
f0105a44:	68 23 53 12 f0       	push   $0xf0125323
f0105a49:	68 d6 51 12 f0       	push   $0xf01251d6
f0105a4e:	68 4e 01 00 00       	push   $0x14e
f0105a53:	68 eb 51 12 f0       	push   $0xf01251eb
f0105a58:	e8 dc a8 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105a5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a61:	75 18                	jne    f0105a7b <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105a63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a66:	8b 40 10             	mov    0x10(%eax),%eax
f0105a69:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a6c:	75 0d                	jne    f0105a7b <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105a6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a71:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105a74:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105a7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a7f:	74 1e                	je     f0105a9f <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105a81:	83 ec 0c             	sub    $0xc,%esp
f0105a84:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a87:	e8 19 fb ff ff       	call   f01055a5 <sched_insert_exit>
f0105a8c:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105a8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a92:	8b 40 10             	mov    0x10(%eax),%eax
f0105a95:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a98:	75 05                	jne    f0105a9f <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105a9a:	e8 6d 60 00 00       	call   f010bb0c <sched>
		}
	}
	if (!lock_already_held)
f0105a9f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105aa3:	75 10                	jne    f0105ab5 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105aa5:	83 ec 0c             	sub    $0xc,%esp
f0105aa8:	68 e0 05 6c f0       	push   $0xf06c05e0
f0105aad:	e8 ef a1 00 00       	call   f010fca1 <release_spinlock>
f0105ab2:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105ab5:	90                   	nop
f0105ab6:	c9                   	leave  
f0105ab7:	c3                   	ret    

f0105ab8 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105ab8:	55                   	push   %ebp
f0105ab9:	89 e5                	mov    %esp,%ebp
f0105abb:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105abe:	83 ec 0c             	sub    $0xc,%esp
f0105ac1:	68 e0 05 6c f0       	push   $0xf06c05e0
f0105ac6:	e8 4f a1 00 00       	call   f010fc1a <acquire_spinlock>
f0105acb:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105ace:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105ad5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105adc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ae0:	75 79                	jne    f0105b5b <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ae2:	a1 50 06 6c f0       	mov    0xf06c0650,%eax
f0105ae7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105aea:	eb 48                	jmp    f0105b34 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105aef:	8b 40 10             	mov    0x10(%eax),%eax
f0105af2:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105af5:	75 35                	jne    f0105b2c <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105af7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105afa:	8d 50 20             	lea    0x20(%eax),%edx
f0105afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b00:	8b 40 10             	mov    0x10(%eax),%eax
f0105b03:	83 ec 04             	sub    $0x4,%esp
f0105b06:	52                   	push   %edx
f0105b07:	50                   	push   %eax
f0105b08:	68 34 53 12 f0       	push   $0xf0125334
f0105b0d:	e8 79 b4 ff ff       	call   f0100f8b <cprintf>
f0105b12:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105b15:	83 ec 0c             	sub    $0xc,%esp
f0105b18:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b1b:	e8 95 f9 ff ff       	call   f01054b5 <sched_remove_new>
f0105b20:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105b23:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105b2a:	eb 2f                	jmp    f0105b5b <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b2c:	a1 58 06 6c f0       	mov    0xf06c0658,%eax
f0105b31:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b38:	74 08                	je     f0105b42 <sched_kill_env+0x8a>
f0105b3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b3d:	8b 40 08             	mov    0x8(%eax),%eax
f0105b40:	eb 05                	jmp    f0105b47 <sched_kill_env+0x8f>
f0105b42:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b47:	a3 58 06 6c f0       	mov    %eax,0xf06c0658
f0105b4c:	a1 58 06 6c f0       	mov    0xf06c0658,%eax
f0105b51:	85 c0                	test   %eax,%eax
f0105b53:	75 97                	jne    f0105aec <sched_kill_env+0x34>
f0105b55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b59:	75 91                	jne    f0105aec <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105b5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b5f:	0f 85 85 01 00 00    	jne    f0105cea <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b6c:	e9 65 01 00 00       	jmp    f0105cd6 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b71:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105b76:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b79:	c1 e2 04             	shl    $0x4,%edx
f0105b7c:	01 d0                	add    %edx,%eax
f0105b7e:	8b 00                	mov    (%eax),%eax
f0105b80:	85 c0                	test   %eax,%eax
f0105b82:	0f 84 45 01 00 00    	je     f0105ccd <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105b88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b8f:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105b94:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b97:	c1 e2 04             	shl    $0x4,%edx
f0105b9a:	01 d0                	add    %edx,%eax
f0105b9c:	8b 00                	mov    (%eax),%eax
f0105b9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ba1:	e9 ef 00 00 00       	jmp    f0105c95 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba9:	8b 40 10             	mov    0x10(%eax),%eax
f0105bac:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105baf:	0f 85 cd 00 00 00    	jne    f0105c82 <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105bb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb8:	8d 50 20             	lea    0x20(%eax),%edx
f0105bbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bbe:	8b 40 10             	mov    0x10(%eax),%eax
f0105bc1:	ff 75 ec             	pushl  -0x14(%ebp)
f0105bc4:	52                   	push   %edx
f0105bc5:	50                   	push   %eax
f0105bc6:	68 5c 53 12 f0       	push   $0xf012535c
f0105bcb:	e8 bb b3 ff ff       	call   f0100f8b <cprintf>
f0105bd0:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105bd3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105bd7:	75 17                	jne    f0105bf0 <sched_kill_env+0x138>
f0105bd9:	83 ec 04             	sub    $0x4,%esp
f0105bdc:	68 27 52 12 f0       	push   $0xf0125227
f0105be1:	68 91 01 00 00       	push   $0x191
f0105be6:	68 eb 51 12 f0       	push   $0xf01251eb
f0105beb:	e8 49 a7 ff ff       	call   f0100339 <_panic>
f0105bf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bf3:	8b 40 08             	mov    0x8(%eax),%eax
f0105bf6:	85 c0                	test   %eax,%eax
f0105bf8:	74 11                	je     f0105c0b <sched_kill_env+0x153>
f0105bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bfd:	8b 40 08             	mov    0x8(%eax),%eax
f0105c00:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c03:	8b 52 0c             	mov    0xc(%edx),%edx
f0105c06:	89 50 0c             	mov    %edx,0xc(%eax)
f0105c09:	eb 16                	jmp    f0105c21 <sched_kill_env+0x169>
f0105c0b:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105c10:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c13:	c1 e2 04             	shl    $0x4,%edx
f0105c16:	01 c2                	add    %eax,%edx
f0105c18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c1b:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c1e:	89 42 04             	mov    %eax,0x4(%edx)
f0105c21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c24:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c27:	85 c0                	test   %eax,%eax
f0105c29:	74 11                	je     f0105c3c <sched_kill_env+0x184>
f0105c2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c2e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c34:	8b 52 08             	mov    0x8(%edx),%edx
f0105c37:	89 50 08             	mov    %edx,0x8(%eax)
f0105c3a:	eb 15                	jmp    f0105c51 <sched_kill_env+0x199>
f0105c3c:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105c41:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c44:	c1 e2 04             	shl    $0x4,%edx
f0105c47:	01 c2                	add    %eax,%edx
f0105c49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c4c:	8b 40 08             	mov    0x8(%eax),%eax
f0105c4f:	89 02                	mov    %eax,(%edx)
f0105c51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c54:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c5e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c65:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105c6a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c6d:	c1 e2 04             	shl    $0x4,%edx
f0105c70:	01 d0                	add    %edx,%eax
f0105c72:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c75:	4a                   	dec    %edx
f0105c76:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c79:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c80:	eb 4b                	jmp    f0105ccd <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c82:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105c87:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c8a:	c1 e2 04             	shl    $0x4,%edx
f0105c8d:	01 d0                	add    %edx,%eax
f0105c8f:	8b 40 08             	mov    0x8(%eax),%eax
f0105c92:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c95:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105c9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c9d:	c1 e2 04             	shl    $0x4,%edx
f0105ca0:	01 d0                	add    %edx,%eax
f0105ca2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ca6:	74 08                	je     f0105cb0 <sched_kill_env+0x1f8>
f0105ca8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cab:	8b 52 08             	mov    0x8(%edx),%edx
f0105cae:	eb 05                	jmp    f0105cb5 <sched_kill_env+0x1fd>
f0105cb0:	ba 00 00 00 00       	mov    $0x0,%edx
f0105cb5:	89 50 08             	mov    %edx,0x8(%eax)
f0105cb8:	8b 40 08             	mov    0x8(%eax),%eax
f0105cbb:	85 c0                	test   %eax,%eax
f0105cbd:	0f 85 e3 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
f0105cc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105cc7:	0f 85 d9 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105ccd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cd1:	75 16                	jne    f0105ce9 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105cd3:	ff 45 ec             	incl   -0x14(%ebp)
f0105cd6:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f0105cdb:	0f b6 c0             	movzbl %al,%eax
f0105cde:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105ce1:	0f 8f 8a fe ff ff    	jg     f0105b71 <sched_kill_env+0xb9>
f0105ce7:	eb 01                	jmp    f0105cea <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105ce9:	90                   	nop
		}
	}
	if (!found)
f0105cea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cee:	0f 85 80 00 00 00    	jne    f0105d74 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105cf4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105cfb:	a1 60 06 6c f0       	mov    0xf06c0660,%eax
f0105d00:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d03:	eb 48                	jmp    f0105d4d <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105d05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d08:	8b 40 10             	mov    0x10(%eax),%eax
f0105d0b:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d0e:	75 35                	jne    f0105d45 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d13:	8d 50 20             	lea    0x20(%eax),%edx
f0105d16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d19:	8b 40 10             	mov    0x10(%eax),%eax
f0105d1c:	83 ec 04             	sub    $0x4,%esp
f0105d1f:	52                   	push   %edx
f0105d20:	50                   	push   %eax
f0105d21:	68 88 53 12 f0       	push   $0xf0125388
f0105d26:	e8 60 b2 ff ff       	call   f0100f8b <cprintf>
f0105d2b:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105d2e:	83 ec 0c             	sub    $0xc,%esp
f0105d31:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d34:	e8 f3 f8 ff ff       	call   f010562c <sched_remove_exit>
f0105d39:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d3c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d43:	eb 2f                	jmp    f0105d74 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105d45:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f0105d4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d4d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d51:	74 08                	je     f0105d5b <sched_kill_env+0x2a3>
f0105d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d56:	8b 40 08             	mov    0x8(%eax),%eax
f0105d59:	eb 05                	jmp    f0105d60 <sched_kill_env+0x2a8>
f0105d5b:	b8 00 00 00 00       	mov    $0x0,%eax
f0105d60:	a3 68 06 6c f0       	mov    %eax,0xf06c0668
f0105d65:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f0105d6a:	85 c0                	test   %eax,%eax
f0105d6c:	75 97                	jne    f0105d05 <sched_kill_env+0x24d>
f0105d6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d72:	75 91                	jne    f0105d05 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d74:	83 ec 0c             	sub    $0xc,%esp
f0105d77:	68 e0 05 6c f0       	push   $0xf06c05e0
f0105d7c:	e8 20 9f 00 00       	call   f010fca1 <release_spinlock>
f0105d81:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105d84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d88:	74 23                	je     f0105dad <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105d8a:	83 ec 0c             	sub    $0xc,%esp
f0105d8d:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d90:	e8 ae 5b 00 00       	call   f010b943 <env_free>
f0105d95:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105d98:	83 ec 0c             	sub    $0xc,%esp
f0105d9b:	68 ae 53 12 f0       	push   $0xf01253ae
f0105da0:	e8 e6 b1 ff ff       	call   f0100f8b <cprintf>
f0105da5:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105da8:	e9 a4 00 00 00       	jmp    f0105e51 <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105dad:	e8 d9 5b 00 00       	call   f010b98b <get_cpu_proc>
f0105db2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105db5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105db9:	75 19                	jne    f0105dd4 <sched_kill_env+0x31c>
f0105dbb:	68 23 53 12 f0       	push   $0xf0125323
f0105dc0:	68 d6 51 12 f0       	push   $0xf01251d6
f0105dc5:	68 b3 01 00 00       	push   $0x1b3
f0105dca:	68 eb 51 12 f0       	push   $0xf01251eb
f0105dcf:	e8 65 a5 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f0105dd4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105dd7:	8b 40 10             	mov    0x10(%eax),%eax
f0105dda:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105ddd:	75 72                	jne    f0105e51 <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f0105ddf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105de2:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105de8:	8b 40 18             	mov    0x18(%eax),%eax
f0105deb:	83 f8 02             	cmp    $0x2,%eax
f0105dee:	74 19                	je     f0105e09 <sched_kill_env+0x351>
f0105df0:	68 b4 53 12 f0       	push   $0xf01253b4
f0105df5:	68 d6 51 12 f0       	push   $0xf01251d6
f0105dfa:	68 b8 01 00 00       	push   $0x1b8
f0105dff:	68 eb 51 12 f0       	push   $0xf01251eb
f0105e04:	e8 30 a5 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105e09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e0c:	8d 50 20             	lea    0x20(%eax),%edx
f0105e0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e12:	8b 40 10             	mov    0x10(%eax),%eax
f0105e15:	83 ec 04             	sub    $0x4,%esp
f0105e18:	52                   	push   %edx
f0105e19:	50                   	push   %eax
f0105e1a:	68 d8 53 12 f0       	push   $0xf01253d8
f0105e1f:	e8 67 b1 ff ff       	call   f0100f8b <cprintf>
f0105e24:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105e27:	83 ec 0c             	sub    $0xc,%esp
f0105e2a:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e2d:	e8 11 5b 00 00       	call   f010b943 <env_free>
f0105e32:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105e35:	83 ec 0c             	sub    $0xc,%esp
f0105e38:	68 ae 53 12 f0       	push   $0xf01253ae
f0105e3d:	e8 49 b1 ff ff       	call   f0100f8b <cprintf>
f0105e42:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105e45:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105e4c:	e8 bb 5c 00 00       	call   f010bb0c <sched>
		}
	}

}
f0105e51:	90                   	nop
f0105e52:	c9                   	leave  
f0105e53:	c3                   	ret    

f0105e54 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105e54:	55                   	push   %ebp
f0105e55:	89 e5                	mov    %esp,%ebp
f0105e57:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105e5a:	83 ec 0c             	sub    $0xc,%esp
f0105e5d:	68 e0 05 6c f0       	push   $0xf06c05e0
f0105e62:	e8 b3 9d 00 00       	call   f010fc1a <acquire_spinlock>
f0105e67:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e6a:	a1 50 06 6c f0       	mov    0xf06c0650,%eax
f0105e6f:	85 c0                	test   %eax,%eax
f0105e71:	74 69                	je     f0105edc <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105e73:	83 ec 0c             	sub    $0xc,%esp
f0105e76:	68 04 54 12 f0       	push   $0xf0125404
f0105e7b:	e8 0b b1 ff ff       	call   f0100f8b <cprintf>
f0105e80:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e83:	a1 50 06 6c f0       	mov    0xf06c0650,%eax
f0105e88:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e8b:	eb 26                	jmp    f0105eb3 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e90:	8d 50 20             	lea    0x20(%eax),%edx
f0105e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e96:	8b 40 10             	mov    0x10(%eax),%eax
f0105e99:	83 ec 04             	sub    $0x4,%esp
f0105e9c:	52                   	push   %edx
f0105e9d:	50                   	push   %eax
f0105e9e:	68 26 54 12 f0       	push   $0xf0125426
f0105ea3:	e8 e3 b0 ff ff       	call   f0100f8b <cprintf>
f0105ea8:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105eab:	a1 58 06 6c f0       	mov    0xf06c0658,%eax
f0105eb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105eb3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105eb7:	74 08                	je     f0105ec1 <sched_print_all+0x6d>
f0105eb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ebc:	8b 40 08             	mov    0x8(%eax),%eax
f0105ebf:	eb 05                	jmp    f0105ec6 <sched_print_all+0x72>
f0105ec1:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ec6:	a3 58 06 6c f0       	mov    %eax,0xf06c0658
f0105ecb:	a1 58 06 6c f0       	mov    0xf06c0658,%eax
f0105ed0:	85 c0                	test   %eax,%eax
f0105ed2:	75 b9                	jne    f0105e8d <sched_print_all+0x39>
f0105ed4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ed8:	75 b3                	jne    f0105e8d <sched_print_all+0x39>
f0105eda:	eb 10                	jmp    f0105eec <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105edc:	83 ec 0c             	sub    $0xc,%esp
f0105edf:	68 30 54 12 f0       	push   $0xf0125430
f0105ee4:	e8 a2 b0 ff ff       	call   f0100f8b <cprintf>
f0105ee9:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105eec:	83 ec 0c             	sub    $0xc,%esp
f0105eef:	68 4c 54 12 f0       	push   $0xf012544c
f0105ef4:	e8 92 b0 ff ff       	call   f0100f8b <cprintf>
f0105ef9:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105efc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105f03:	e9 c7 00 00 00       	jmp    f0105fcf <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105f08:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105f0d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f10:	c1 e2 04             	shl    $0x4,%edx
f0105f13:	01 d0                	add    %edx,%eax
f0105f15:	8b 00                	mov    (%eax),%eax
f0105f17:	85 c0                	test   %eax,%eax
f0105f19:	0f 84 8a 00 00 00    	je     f0105fa9 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105f1f:	83 ec 08             	sub    $0x8,%esp
f0105f22:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f25:	68 80 54 12 f0       	push   $0xf0125480
f0105f2a:	e8 5c b0 ff ff       	call   f0100f8b <cprintf>
f0105f2f:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f32:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105f37:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f3a:	c1 e2 04             	shl    $0x4,%edx
f0105f3d:	01 d0                	add    %edx,%eax
f0105f3f:	8b 00                	mov    (%eax),%eax
f0105f41:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f44:	eb 31                	jmp    f0105f77 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105f46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f49:	8d 50 20             	lea    0x20(%eax),%edx
f0105f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f4f:	8b 40 10             	mov    0x10(%eax),%eax
f0105f52:	83 ec 04             	sub    $0x4,%esp
f0105f55:	52                   	push   %edx
f0105f56:	50                   	push   %eax
f0105f57:	68 26 54 12 f0       	push   $0xf0125426
f0105f5c:	e8 2a b0 ff ff       	call   f0100f8b <cprintf>
f0105f61:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f64:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105f69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f6c:	c1 e2 04             	shl    $0x4,%edx
f0105f6f:	01 d0                	add    %edx,%eax
f0105f71:	8b 40 08             	mov    0x8(%eax),%eax
f0105f74:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f77:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0105f7c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f7f:	c1 e2 04             	shl    $0x4,%edx
f0105f82:	01 d0                	add    %edx,%eax
f0105f84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f88:	74 08                	je     f0105f92 <sched_print_all+0x13e>
f0105f8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f8d:	8b 52 08             	mov    0x8(%edx),%edx
f0105f90:	eb 05                	jmp    f0105f97 <sched_print_all+0x143>
f0105f92:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f97:	89 50 08             	mov    %edx,0x8(%eax)
f0105f9a:	8b 40 08             	mov    0x8(%eax),%eax
f0105f9d:	85 c0                	test   %eax,%eax
f0105f9f:	75 a5                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fa5:	75 9f                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa7:	eb 13                	jmp    f0105fbc <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105fa9:	83 ec 08             	sub    $0x8,%esp
f0105fac:	ff 75 f0             	pushl  -0x10(%ebp)
f0105faf:	68 a8 54 12 f0       	push   $0xf01254a8
f0105fb4:	e8 d2 af ff ff       	call   f0100f8b <cprintf>
f0105fb9:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105fbc:	83 ec 0c             	sub    $0xc,%esp
f0105fbf:	68 4c 54 12 f0       	push   $0xf012544c
f0105fc4:	e8 c2 af ff ff       	call   f0100f8b <cprintf>
f0105fc9:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105fcc:	ff 45 f0             	incl   -0x10(%ebp)
f0105fcf:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f0105fd4:	0f b6 c0             	movzbl %al,%eax
f0105fd7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105fda:	0f 8f 28 ff ff ff    	jg     f0105f08 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105fe0:	a1 60 06 6c f0       	mov    0xf06c0660,%eax
f0105fe5:	85 c0                	test   %eax,%eax
f0105fe7:	74 69                	je     f0106052 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105fe9:	83 ec 0c             	sub    $0xc,%esp
f0105fec:	68 cc 54 12 f0       	push   $0xf01254cc
f0105ff1:	e8 95 af ff ff       	call   f0100f8b <cprintf>
f0105ff6:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105ff9:	a1 60 06 6c f0       	mov    0xf06c0660,%eax
f0105ffe:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106001:	eb 26                	jmp    f0106029 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106003:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106006:	8d 50 20             	lea    0x20(%eax),%edx
f0106009:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010600c:	8b 40 10             	mov    0x10(%eax),%eax
f010600f:	83 ec 04             	sub    $0x4,%esp
f0106012:	52                   	push   %edx
f0106013:	50                   	push   %eax
f0106014:	68 26 54 12 f0       	push   $0xf0125426
f0106019:	e8 6d af ff ff       	call   f0100f8b <cprintf>
f010601e:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106021:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f0106026:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106029:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010602d:	74 08                	je     f0106037 <sched_print_all+0x1e3>
f010602f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106032:	8b 40 08             	mov    0x8(%eax),%eax
f0106035:	eb 05                	jmp    f010603c <sched_print_all+0x1e8>
f0106037:	b8 00 00 00 00       	mov    $0x0,%eax
f010603c:	a3 68 06 6c f0       	mov    %eax,0xf06c0668
f0106041:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f0106046:	85 c0                	test   %eax,%eax
f0106048:	75 b9                	jne    f0106003 <sched_print_all+0x1af>
f010604a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010604e:	75 b3                	jne    f0106003 <sched_print_all+0x1af>
f0106050:	eb 10                	jmp    f0106062 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106052:	83 ec 0c             	sub    $0xc,%esp
f0106055:	68 ee 54 12 f0       	push   $0xf01254ee
f010605a:	e8 2c af ff ff       	call   f0100f8b <cprintf>
f010605f:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106062:	83 ec 0c             	sub    $0xc,%esp
f0106065:	68 e0 05 6c f0       	push   $0xf06c05e0
f010606a:	e8 32 9c 00 00       	call   f010fca1 <release_spinlock>
f010606f:	83 c4 10             	add    $0x10,%esp
}
f0106072:	90                   	nop
f0106073:	c9                   	leave  
f0106074:	c3                   	ret    

f0106075 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106075:	55                   	push   %ebp
f0106076:	89 e5                	mov    %esp,%ebp
f0106078:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010607b:	83 ec 0c             	sub    $0xc,%esp
f010607e:	68 e0 05 6c f0       	push   $0xf06c05e0
f0106083:	e8 92 9b 00 00       	call   f010fc1a <acquire_spinlock>
f0106088:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010608b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0106092:	a1 5c 06 6c f0       	mov    0xf06c065c,%eax
f0106097:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010609a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01060a1:	eb 24                	jmp    f01060c7 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f01060a3:	83 ec 0c             	sub    $0xc,%esp
f01060a6:	68 50 06 6c f0       	push   $0xf06c0650
f01060ab:	e8 8b ef ff ff       	call   f010503b <dequeue>
f01060b0:	83 c4 10             	add    $0x10,%esp
f01060b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f01060b6:	83 ec 0c             	sub    $0xc,%esp
f01060b9:	ff 75 f0             	pushl  -0x10(%ebp)
f01060bc:	e8 b5 f1 ff ff       	call   f0105276 <sched_insert_ready0>
f01060c1:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f01060c4:	ff 45 f4             	incl   -0xc(%ebp)
f01060c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060ca:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01060cd:	7c d4                	jl     f01060a3 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060cf:	83 ec 0c             	sub    $0xc,%esp
f01060d2:	68 e0 05 6c f0       	push   $0xf06c05e0
f01060d7:	e8 c5 9b 00 00       	call   f010fca1 <release_spinlock>
f01060dc:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f01060df:	e8 28 10 00 00       	call   f010710c <mycpu>
f01060e4:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01060ea:	85 c0                	test   %eax,%eax
f01060ec:	75 05                	jne    f01060f3 <sched_run_all+0x7e>
		fos_scheduler();
f01060ee:	e8 9e 06 00 00       	call   f0106791 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f01060f3:	83 ec 04             	sub    $0x4,%esp
f01060f6:	68 0c 55 12 f0       	push   $0xf012550c
f01060fb:	68 15 02 00 00       	push   $0x215
f0106100:	68 eb 51 12 f0       	push   $0xf01251eb
f0106105:	e8 2f a2 ff ff       	call   f0100339 <_panic>

f010610a <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010610a:	55                   	push   %ebp
f010610b:	89 e5                	mov    %esp,%ebp
f010610d:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106110:	83 ec 0c             	sub    $0xc,%esp
f0106113:	68 e0 05 6c f0       	push   $0xf06c05e0
f0106118:	e8 fd 9a 00 00       	call   f010fc1a <acquire_spinlock>
f010611d:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106120:	a1 50 06 6c f0       	mov    0xf06c0650,%eax
f0106125:	85 c0                	test   %eax,%eax
f0106127:	0f 84 95 00 00 00    	je     f01061c2 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f010612d:	83 ec 0c             	sub    $0xc,%esp
f0106130:	68 48 55 12 f0       	push   $0xf0125548
f0106135:	e8 51 ae ff ff       	call   f0100f8b <cprintf>
f010613a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010613d:	a1 50 06 6c f0       	mov    0xf06c0650,%eax
f0106142:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106145:	eb 52                	jmp    f0106199 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106147:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010614a:	8d 50 20             	lea    0x20(%eax),%edx
f010614d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106150:	8b 40 10             	mov    0x10(%eax),%eax
f0106153:	83 ec 04             	sub    $0x4,%esp
f0106156:	52                   	push   %edx
f0106157:	50                   	push   %eax
f0106158:	68 74 55 12 f0       	push   $0xf0125574
f010615d:	e8 29 ae ff ff       	call   f0100f8b <cprintf>
f0106162:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0106165:	83 ec 0c             	sub    $0xc,%esp
f0106168:	ff 75 f4             	pushl  -0xc(%ebp)
f010616b:	e8 45 f3 ff ff       	call   f01054b5 <sched_remove_new>
f0106170:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106173:	83 ec 0c             	sub    $0xc,%esp
f0106176:	ff 75 f4             	pushl  -0xc(%ebp)
f0106179:	e8 c5 57 00 00       	call   f010b943 <env_free>
f010617e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106181:	83 ec 0c             	sub    $0xc,%esp
f0106184:	68 ae 53 12 f0       	push   $0xf01253ae
f0106189:	e8 fd ad ff ff       	call   f0100f8b <cprintf>
f010618e:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106191:	a1 58 06 6c f0       	mov    0xf06c0658,%eax
f0106196:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106199:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010619d:	74 08                	je     f01061a7 <sched_kill_all+0x9d>
f010619f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061a2:	8b 40 08             	mov    0x8(%eax),%eax
f01061a5:	eb 05                	jmp    f01061ac <sched_kill_all+0xa2>
f01061a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01061ac:	a3 58 06 6c f0       	mov    %eax,0xf06c0658
f01061b1:	a1 58 06 6c f0       	mov    0xf06c0658,%eax
f01061b6:	85 c0                	test   %eax,%eax
f01061b8:	75 8d                	jne    f0106147 <sched_kill_all+0x3d>
f01061ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061be:	75 87                	jne    f0106147 <sched_kill_all+0x3d>
f01061c0:	eb 10                	jmp    f01061d2 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f01061c2:	83 ec 0c             	sub    $0xc,%esp
f01061c5:	68 87 55 12 f0       	push   $0xf0125587
f01061ca:	e8 bc ad ff ff       	call   f0100f8b <cprintf>
f01061cf:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f01061d2:	83 ec 0c             	sub    $0xc,%esp
f01061d5:	68 4c 54 12 f0       	push   $0xf012544c
f01061da:	e8 ac ad ff ff       	call   f0100f8b <cprintf>
f01061df:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01061e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01061e9:	e9 96 01 00 00       	jmp    f0106384 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01061ee:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01061f3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061f6:	c1 e2 04             	shl    $0x4,%edx
f01061f9:	01 d0                	add    %edx,%eax
f01061fb:	8b 00                	mov    (%eax),%eax
f01061fd:	85 c0                	test   %eax,%eax
f01061ff:	0f 84 59 01 00 00    	je     f010635e <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106205:	83 ec 08             	sub    $0x8,%esp
f0106208:	ff 75 f0             	pushl  -0x10(%ebp)
f010620b:	68 a4 55 12 f0       	push   $0xf01255a4
f0106210:	e8 76 ad ff ff       	call   f0100f8b <cprintf>
f0106215:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106218:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f010621d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106220:	c1 e2 04             	shl    $0x4,%edx
f0106223:	01 d0                	add    %edx,%eax
f0106225:	8b 00                	mov    (%eax),%eax
f0106227:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010622a:	e9 f5 00 00 00       	jmp    f0106324 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010622f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106232:	8d 50 20             	lea    0x20(%eax),%edx
f0106235:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106238:	8b 40 10             	mov    0x10(%eax),%eax
f010623b:	83 ec 04             	sub    $0x4,%esp
f010623e:	52                   	push   %edx
f010623f:	50                   	push   %eax
f0106240:	68 74 55 12 f0       	push   $0xf0125574
f0106245:	e8 41 ad ff ff       	call   f0100f8b <cprintf>
f010624a:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010624d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106251:	75 17                	jne    f010626a <sched_kill_all+0x160>
f0106253:	83 ec 04             	sub    $0x4,%esp
f0106256:	68 27 52 12 f0       	push   $0xf0125227
f010625b:	68 37 02 00 00       	push   $0x237
f0106260:	68 eb 51 12 f0       	push   $0xf01251eb
f0106265:	e8 cf a0 ff ff       	call   f0100339 <_panic>
f010626a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010626d:	8b 40 08             	mov    0x8(%eax),%eax
f0106270:	85 c0                	test   %eax,%eax
f0106272:	74 11                	je     f0106285 <sched_kill_all+0x17b>
f0106274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106277:	8b 40 08             	mov    0x8(%eax),%eax
f010627a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010627d:	8b 52 0c             	mov    0xc(%edx),%edx
f0106280:	89 50 0c             	mov    %edx,0xc(%eax)
f0106283:	eb 16                	jmp    f010629b <sched_kill_all+0x191>
f0106285:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f010628a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010628d:	c1 e2 04             	shl    $0x4,%edx
f0106290:	01 c2                	add    %eax,%edx
f0106292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106295:	8b 40 0c             	mov    0xc(%eax),%eax
f0106298:	89 42 04             	mov    %eax,0x4(%edx)
f010629b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010629e:	8b 40 0c             	mov    0xc(%eax),%eax
f01062a1:	85 c0                	test   %eax,%eax
f01062a3:	74 11                	je     f01062b6 <sched_kill_all+0x1ac>
f01062a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01062ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062ae:	8b 52 08             	mov    0x8(%edx),%edx
f01062b1:	89 50 08             	mov    %edx,0x8(%eax)
f01062b4:	eb 15                	jmp    f01062cb <sched_kill_all+0x1c1>
f01062b6:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01062bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062be:	c1 e2 04             	shl    $0x4,%edx
f01062c1:	01 c2                	add    %eax,%edx
f01062c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062c6:	8b 40 08             	mov    0x8(%eax),%eax
f01062c9:	89 02                	mov    %eax,(%edx)
f01062cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01062d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01062df:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01062e4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062e7:	c1 e2 04             	shl    $0x4,%edx
f01062ea:	01 d0                	add    %edx,%eax
f01062ec:	8b 50 0c             	mov    0xc(%eax),%edx
f01062ef:	4a                   	dec    %edx
f01062f0:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f01062f3:	83 ec 0c             	sub    $0xc,%esp
f01062f6:	ff 75 f4             	pushl  -0xc(%ebp)
f01062f9:	e8 45 56 00 00       	call   f010b943 <env_free>
f01062fe:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0106301:	83 ec 0c             	sub    $0xc,%esp
f0106304:	68 ae 53 12 f0       	push   $0xf01253ae
f0106309:	e8 7d ac ff ff       	call   f0100f8b <cprintf>
f010630e:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106311:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0106316:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106319:	c1 e2 04             	shl    $0x4,%edx
f010631c:	01 d0                	add    %edx,%eax
f010631e:	8b 40 08             	mov    0x8(%eax),%eax
f0106321:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106324:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0106329:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010632c:	c1 e2 04             	shl    $0x4,%edx
f010632f:	01 d0                	add    %edx,%eax
f0106331:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106335:	74 08                	je     f010633f <sched_kill_all+0x235>
f0106337:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010633a:	8b 52 08             	mov    0x8(%edx),%edx
f010633d:	eb 05                	jmp    f0106344 <sched_kill_all+0x23a>
f010633f:	ba 00 00 00 00       	mov    $0x0,%edx
f0106344:	89 50 08             	mov    %edx,0x8(%eax)
f0106347:	8b 40 08             	mov    0x8(%eax),%eax
f010634a:	85 c0                	test   %eax,%eax
f010634c:	0f 85 dd fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f0106352:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106356:	0f 85 d3 fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f010635c:	eb 13                	jmp    f0106371 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f010635e:	83 ec 08             	sub    $0x8,%esp
f0106361:	ff 75 f0             	pushl  -0x10(%ebp)
f0106364:	68 a8 54 12 f0       	push   $0xf01254a8
f0106369:	e8 1d ac ff ff       	call   f0100f8b <cprintf>
f010636e:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106371:	83 ec 0c             	sub    $0xc,%esp
f0106374:	68 4c 54 12 f0       	push   $0xf012544c
f0106379:	e8 0d ac ff ff       	call   f0100f8b <cprintf>
f010637e:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106381:	ff 45 f0             	incl   -0x10(%ebp)
f0106384:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f0106389:	0f b6 c0             	movzbl %al,%eax
f010638c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010638f:	0f 8f 59 fe ff ff    	jg     f01061ee <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106395:	a1 60 06 6c f0       	mov    0xf06c0660,%eax
f010639a:	85 c0                	test   %eax,%eax
f010639c:	0f 84 95 00 00 00    	je     f0106437 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f01063a2:	83 ec 0c             	sub    $0xc,%esp
f01063a5:	68 d8 55 12 f0       	push   $0xf01255d8
f01063aa:	e8 dc ab ff ff       	call   f0100f8b <cprintf>
f01063af:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063b2:	a1 60 06 6c f0       	mov    0xf06c0660,%eax
f01063b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063ba:	eb 52                	jmp    f010640e <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063bf:	8d 50 20             	lea    0x20(%eax),%edx
f01063c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063c5:	8b 40 10             	mov    0x10(%eax),%eax
f01063c8:	83 ec 04             	sub    $0x4,%esp
f01063cb:	52                   	push   %edx
f01063cc:	50                   	push   %eax
f01063cd:	68 74 55 12 f0       	push   $0xf0125574
f01063d2:	e8 b4 ab ff ff       	call   f0100f8b <cprintf>
f01063d7:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f01063da:	83 ec 0c             	sub    $0xc,%esp
f01063dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01063e0:	e8 47 f2 ff ff       	call   f010562c <sched_remove_exit>
f01063e5:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063e8:	83 ec 0c             	sub    $0xc,%esp
f01063eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01063ee:	e8 50 55 00 00       	call   f010b943 <env_free>
f01063f3:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063f6:	83 ec 0c             	sub    $0xc,%esp
f01063f9:	68 ae 53 12 f0       	push   $0xf01253ae
f01063fe:	e8 88 ab ff ff       	call   f0100f8b <cprintf>
f0106403:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106406:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f010640b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010640e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106412:	74 08                	je     f010641c <sched_kill_all+0x312>
f0106414:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106417:	8b 40 08             	mov    0x8(%eax),%eax
f010641a:	eb 05                	jmp    f0106421 <sched_kill_all+0x317>
f010641c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106421:	a3 68 06 6c f0       	mov    %eax,0xf06c0668
f0106426:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f010642b:	85 c0                	test   %eax,%eax
f010642d:	75 8d                	jne    f01063bc <sched_kill_all+0x2b2>
f010642f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106433:	75 87                	jne    f01063bc <sched_kill_all+0x2b2>
f0106435:	eb 10                	jmp    f0106447 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106437:	83 ec 0c             	sub    $0xc,%esp
f010643a:	68 ee 54 12 f0       	push   $0xf01254ee
f010643f:	e8 47 ab ff ff       	call   f0100f8b <cprintf>
f0106444:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f0106447:	e8 3f 55 00 00       	call   f010b98b <get_cpu_proc>
f010644c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f010644f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106453:	74 6b                	je     f01064c0 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f0106455:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106458:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f010645b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010645e:	8b 40 18             	mov    0x18(%eax),%eax
f0106461:	83 f8 02             	cmp    $0x2,%eax
f0106464:	74 19                	je     f010647f <sched_kill_all+0x375>
f0106466:	68 b4 53 12 f0       	push   $0xf01253b4
f010646b:	68 d6 51 12 f0       	push   $0xf01251d6
f0106470:	68 57 02 00 00       	push   $0x257
f0106475:	68 eb 51 12 f0       	push   $0xf01251eb
f010647a:	e8 ba 9e ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010647f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106482:	8d 50 20             	lea    0x20(%eax),%edx
f0106485:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106488:	8b 40 10             	mov    0x10(%eax),%eax
f010648b:	83 ec 04             	sub    $0x4,%esp
f010648e:	52                   	push   %edx
f010648f:	50                   	push   %eax
f0106490:	68 d8 53 12 f0       	push   $0xf01253d8
f0106495:	e8 f1 aa ff ff       	call   f0100f8b <cprintf>
f010649a:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010649d:	83 ec 0c             	sub    $0xc,%esp
f01064a0:	ff 75 f4             	pushl  -0xc(%ebp)
f01064a3:	e8 9b 54 00 00       	call   f010b943 <env_free>
f01064a8:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f01064ab:	83 ec 0c             	sub    $0xc,%esp
f01064ae:	68 ae 53 12 f0       	push   $0xf01253ae
f01064b3:	e8 d3 aa ff ff       	call   f0100f8b <cprintf>
f01064b8:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f01064bb:	e8 4c 56 00 00       	call   f010bb0c <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064c0:	83 ec 0c             	sub    $0xc,%esp
f01064c3:	68 e0 05 6c f0       	push   $0xf06c05e0
f01064c8:	e8 d4 97 00 00       	call   f010fca1 <release_spinlock>
f01064cd:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f01064d0:	e8 ed b8 ff ff       	call   f0101dc2 <get_into_prompt>

f01064d5 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f01064d5:	55                   	push   %ebp
f01064d6:	89 e5                	mov    %esp,%ebp
f01064d8:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064db:	83 ec 0c             	sub    $0xc,%esp
f01064de:	68 e0 05 6c f0       	push   $0xf06c05e0
f01064e3:	e8 32 97 00 00       	call   f010fc1a <acquire_spinlock>
f01064e8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01064eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01064f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01064f9:	e9 37 01 00 00       	jmp    f0106635 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01064fe:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0106503:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106506:	c1 e2 04             	shl    $0x4,%edx
f0106509:	01 d0                	add    %edx,%eax
f010650b:	8b 00                	mov    (%eax),%eax
f010650d:	85 c0                	test   %eax,%eax
f010650f:	0f 84 1d 01 00 00    	je     f0106632 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0106515:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010651c:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0106521:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106524:	c1 e2 04             	shl    $0x4,%edx
f0106527:	01 d0                	add    %edx,%eax
f0106529:	8b 00                	mov    (%eax),%eax
f010652b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010652e:	e9 c7 00 00 00       	jmp    f01065fa <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106533:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106537:	75 17                	jne    f0106550 <sched_exit_all_ready_envs+0x7b>
f0106539:	83 ec 04             	sub    $0x4,%esp
f010653c:	68 27 52 12 f0       	push   $0xf0125227
f0106541:	68 79 02 00 00       	push   $0x279
f0106546:	68 eb 51 12 f0       	push   $0xf01251eb
f010654b:	e8 e9 9d ff ff       	call   f0100339 <_panic>
f0106550:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106553:	8b 40 08             	mov    0x8(%eax),%eax
f0106556:	85 c0                	test   %eax,%eax
f0106558:	74 11                	je     f010656b <sched_exit_all_ready_envs+0x96>
f010655a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655d:	8b 40 08             	mov    0x8(%eax),%eax
f0106560:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106563:	8b 52 0c             	mov    0xc(%edx),%edx
f0106566:	89 50 0c             	mov    %edx,0xc(%eax)
f0106569:	eb 16                	jmp    f0106581 <sched_exit_all_ready_envs+0xac>
f010656b:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0106570:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106573:	c1 e2 04             	shl    $0x4,%edx
f0106576:	01 c2                	add    %eax,%edx
f0106578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010657b:	8b 40 0c             	mov    0xc(%eax),%eax
f010657e:	89 42 04             	mov    %eax,0x4(%edx)
f0106581:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106584:	8b 40 0c             	mov    0xc(%eax),%eax
f0106587:	85 c0                	test   %eax,%eax
f0106589:	74 11                	je     f010659c <sched_exit_all_ready_envs+0xc7>
f010658b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010658e:	8b 40 0c             	mov    0xc(%eax),%eax
f0106591:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106594:	8b 52 08             	mov    0x8(%edx),%edx
f0106597:	89 50 08             	mov    %edx,0x8(%eax)
f010659a:	eb 15                	jmp    f01065b1 <sched_exit_all_ready_envs+0xdc>
f010659c:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01065a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065a4:	c1 e2 04             	shl    $0x4,%edx
f01065a7:	01 c2                	add    %eax,%edx
f01065a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065ac:	8b 40 08             	mov    0x8(%eax),%eax
f01065af:	89 02                	mov    %eax,(%edx)
f01065b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065b4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01065bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065be:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01065c5:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01065ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065cd:	c1 e2 04             	shl    $0x4,%edx
f01065d0:	01 d0                	add    %edx,%eax
f01065d2:	8b 50 0c             	mov    0xc(%eax),%edx
f01065d5:	4a                   	dec    %edx
f01065d6:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f01065d9:	83 ec 0c             	sub    $0xc,%esp
f01065dc:	ff 75 f4             	pushl  -0xc(%ebp)
f01065df:	e8 c1 ef ff ff       	call   f01055a5 <sched_insert_exit>
f01065e4:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01065e7:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01065ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065ef:	c1 e2 04             	shl    $0x4,%edx
f01065f2:	01 d0                	add    %edx,%eax
f01065f4:	8b 40 08             	mov    0x8(%eax),%eax
f01065f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01065fa:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f01065ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106602:	c1 e2 04             	shl    $0x4,%edx
f0106605:	01 d0                	add    %edx,%eax
f0106607:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010660b:	74 08                	je     f0106615 <sched_exit_all_ready_envs+0x140>
f010660d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106610:	8b 52 08             	mov    0x8(%edx),%edx
f0106613:	eb 05                	jmp    f010661a <sched_exit_all_ready_envs+0x145>
f0106615:	ba 00 00 00 00       	mov    $0x0,%edx
f010661a:	89 50 08             	mov    %edx,0x8(%eax)
f010661d:	8b 40 08             	mov    0x8(%eax),%eax
f0106620:	85 c0                	test   %eax,%eax
f0106622:	0f 85 0b ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
f0106628:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010662c:	0f 85 01 ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106632:	ff 45 f0             	incl   -0x10(%ebp)
f0106635:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f010663a:	0f b6 c0             	movzbl %al,%eax
f010663d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106640:	0f 8f b8 fe ff ff    	jg     f01064fe <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106646:	83 ec 0c             	sub    $0xc,%esp
f0106649:	68 e0 05 6c f0       	push   $0xf06c05e0
f010664e:	e8 4e 96 00 00       	call   f010fca1 <release_spinlock>
f0106653:	83 c4 10             	add    $0x10,%esp
}
f0106656:	90                   	nop
f0106657:	c9                   	leave  
f0106658:	c3                   	ret    

f0106659 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f0106659:	55                   	push   %ebp
f010665a:	89 e5                	mov    %esp,%ebp
	return ticks;
f010665c:	a1 88 0c 6c f0       	mov    0xf06c0c88,%eax
f0106661:	8b 15 8c 0c 6c f0    	mov    0xf06c0c8c,%edx
}
f0106667:	5d                   	pop    %ebp
f0106668:	c3                   	ret    

f0106669 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f0106669:	55                   	push   %ebp
f010666a:	89 e5                	mov    %esp,%ebp
f010666c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010666f:	83 ec 04             	sub    $0x4,%esp
f0106672:	68 04 56 12 f0       	push   $0xf0125604
f0106677:	68 8c 02 00 00       	push   $0x28c
f010667c:	68 eb 51 12 f0       	push   $0xf01251eb
f0106681:	e8 b3 9c ff ff       	call   f0100339 <_panic>

f0106686 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0106686:	55                   	push   %ebp
f0106687:	89 e5                	mov    %esp,%ebp
f0106689:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010668c:	83 ec 04             	sub    $0x4,%esp
f010668f:	68 04 56 12 f0       	push   $0xf0125604
f0106694:	68 94 02 00 00       	push   $0x294
f0106699:	68 eb 51 12 f0       	push   $0xf01251eb
f010669e:	e8 96 9c ff ff       	call   f0100339 <_panic>

f01066a3 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f01066a3:	55                   	push   %ebp
f01066a4:	89 e5                	mov    %esp,%ebp
f01066a6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066a9:	83 ec 04             	sub    $0x4,%esp
f01066ac:	68 04 56 12 f0       	push   $0xf0125604
f01066b1:	68 9c 02 00 00       	push   $0x29c
f01066b6:	68 eb 51 12 f0       	push   $0xf01251eb
f01066bb:	e8 79 9c ff ff       	call   f0100339 <_panic>

f01066c0 <get_load_average>:
}
int get_load_average()
{
f01066c0:	55                   	push   %ebp
f01066c1:	89 e5                	mov    %esp,%ebp
f01066c3:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066c6:	83 ec 04             	sub    $0x4,%esp
f01066c9:	68 04 56 12 f0       	push   $0xf0125604
f01066ce:	68 a4 02 00 00       	push   $0x2a4
f01066d3:	68 eb 51 12 f0       	push   $0xf01251eb
f01066d8:	e8 5c 9c ff ff       	call   f0100339 <_panic>

f01066dd <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f01066dd:	55                   	push   %ebp
f01066de:	89 e5                	mov    %esp,%ebp
f01066e0:	a1 d4 0a 6c f0       	mov    0xf06c0ad4,%eax
f01066e5:	85 c0                	test   %eax,%eax
f01066e7:	75 07                	jne    f01066f0 <isSchedMethodRR+0x13>
f01066e9:	b8 01 00 00 00       	mov    $0x1,%eax
f01066ee:	eb 05                	jmp    f01066f5 <isSchedMethodRR+0x18>
f01066f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01066f5:	5d                   	pop    %ebp
f01066f6:	c3                   	ret    

f01066f7 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f01066f7:	55                   	push   %ebp
f01066f8:	89 e5                	mov    %esp,%ebp
f01066fa:	a1 d4 0a 6c f0       	mov    0xf06c0ad4,%eax
f01066ff:	83 f8 01             	cmp    $0x1,%eax
f0106702:	75 07                	jne    f010670b <isSchedMethodMLFQ+0x14>
f0106704:	b8 01 00 00 00       	mov    $0x1,%eax
f0106709:	eb 05                	jmp    f0106710 <isSchedMethodMLFQ+0x19>
f010670b:	b8 00 00 00 00       	mov    $0x0,%eax
f0106710:	5d                   	pop    %ebp
f0106711:	c3                   	ret    

f0106712 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106712:	55                   	push   %ebp
f0106713:	89 e5                	mov    %esp,%ebp
f0106715:	a1 d4 0a 6c f0       	mov    0xf06c0ad4,%eax
f010671a:	83 f8 02             	cmp    $0x2,%eax
f010671d:	75 07                	jne    f0106726 <isSchedMethodBSD+0x14>
f010671f:	b8 01 00 00 00       	mov    $0x1,%eax
f0106724:	eb 05                	jmp    f010672b <isSchedMethodBSD+0x19>
f0106726:	b8 00 00 00 00       	mov    $0x0,%eax
f010672b:	5d                   	pop    %ebp
f010672c:	c3                   	ret    

f010672d <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010672d:	55                   	push   %ebp
f010672e:	89 e5                	mov    %esp,%ebp
f0106730:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106733:	c7 05 b8 07 6c f0 00 	movl   $0x0,0xf06c07b8
f010673a:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f010673d:	83 ec 0c             	sub    $0xc,%esp
f0106740:	6a 0a                	push   $0xa
f0106742:	e8 60 02 00 00       	call   f01069a7 <sched_init_RR>
f0106747:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f010674a:	83 ec 0c             	sub    $0xc,%esp
f010674d:	68 50 06 6c f0       	push   $0xf06c0650
f0106752:	e8 12 e8 ff ff       	call   f0104f69 <init_queue>
f0106757:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f010675a:	83 ec 0c             	sub    $0xc,%esp
f010675d:	68 60 06 6c f0       	push   $0xf06c0660
f0106762:	e8 02 e8 ff ff       	call   f0104f69 <init_queue>
f0106767:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f010676a:	e8 9d 09 00 00       	call   f010710c <mycpu>
f010676f:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106776:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106779:	83 ec 08             	sub    $0x8,%esp
f010677c:	68 18 56 12 f0       	push   $0xf0125618
f0106781:	68 e0 05 6c f0       	push   $0xf06c05e0
f0106786:	e8 5e 94 00 00       	call   f010fbe9 <init_spinlock>
f010678b:	83 c4 10             	add    $0x10,%esp
}
f010678e:	90                   	nop
f010678f:	c9                   	leave  
f0106790:	c3                   	ret    

f0106791 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106791:	55                   	push   %ebp
f0106792:	89 e5                	mov    %esp,%ebp
f0106794:	53                   	push   %ebx
f0106795:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106798:	9c                   	pushf  
f0106799:	58                   	pop    %eax
f010679a:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f010679d:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f01067a0:	25 00 02 00 00       	and    $0x200,%eax
f01067a5:	85 c0                	test   %eax,%eax
f01067a7:	74 14                	je     f01067bd <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f01067a9:	83 ec 04             	sub    $0x4,%esp
f01067ac:	68 2c 56 12 f0       	push   $0xf012562c
f01067b1:	6a 37                	push   $0x37
f01067b3:	68 62 56 12 f0       	push   $0xf0125662
f01067b8:	e8 7c 9b ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01067bd:	e8 4a 09 00 00       	call   f010710c <mycpu>
f01067c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f01067c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067c8:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01067cf:	00 00 00 

	chk1();
f01067d2:	e8 ad 85 01 00       	call   f011ed84 <chk1>
	c->scheduler_status = SCH_STARTED;
f01067d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067da:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f01067e1:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f01067e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f01067eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01067f2:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f01067f3:	83 ec 0c             	sub    $0xc,%esp
f01067f6:	68 e0 05 6c f0       	push   $0xf06c05e0
f01067fb:	e8 1a 94 00 00       	call   f010fc1a <acquire_spinlock>
f0106800:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106803:	a1 d4 0a 6c f0       	mov    0xf06c0ad4,%eax
f0106808:	8b 04 85 4c f9 17 f0 	mov    -0xfe806b4(,%eax,4),%eax
f010680f:	ff d0                	call   *%eax
f0106811:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106814:	e8 72 51 00 00       	call   f010b98b <get_cpu_proc>
f0106819:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f010681c:	83 ec 0c             	sub    $0xc,%esp
f010681f:	ff 75 e8             	pushl  -0x18(%ebp)
f0106822:	e8 8d 51 00 00       	call   f010b9b4 <set_cpu_proc>
f0106827:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f010682a:	83 ec 0c             	sub    $0xc,%esp
f010682d:	ff 75 e8             	pushl  -0x18(%ebp)
f0106830:	e8 55 85 01 00       	call   f011ed8a <chk2>
f0106835:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106838:	83 ec 0c             	sub    $0xc,%esp
f010683b:	ff 75 e0             	pushl  -0x20(%ebp)
f010683e:	e8 71 51 00 00       	call   f010b9b4 <set_cpu_proc>
f0106843:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106846:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010684a:	0f 84 d6 00 00 00    	je     f0106926 <fos_scheduler+0x195>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106850:	83 ec 0c             	sub    $0xc,%esp
f0106853:	ff 75 e8             	pushl  -0x18(%ebp)
f0106856:	e8 59 51 00 00       	call   f010b9b4 <set_cpu_proc>
f010685b:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f010685e:	83 ec 0c             	sub    $0xc,%esp
f0106861:	ff 75 e8             	pushl  -0x18(%ebp)
f0106864:	e8 c6 53 00 00       	call   f010bc2f <switchuvm>
f0106869:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f010686c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010686f:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106876:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106879:	8b 40 04             	mov    0x4(%eax),%eax
f010687c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010687f:	83 c2 04             	add    $0x4,%edx
f0106882:	83 ec 08             	sub    $0x8,%esp
f0106885:	50                   	push   %eax
f0106886:	52                   	push   %edx
f0106887:	e8 e5 e2 ff ff       	call   f0104b71 <context_switch>
f010688c:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010688f:	9c                   	pushf  
f0106890:	58                   	pop    %eax
f0106891:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106894:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106897:	25 00 02 00 00       	and    $0x200,%eax
f010689c:	85 c0                	test   %eax,%eax
f010689e:	74 14                	je     f01068b4 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f01068a0:	83 ec 04             	sub    $0x4,%esp
f01068a3:	68 74 56 12 f0       	push   $0xf0125674
f01068a8:	6a 74                	push   $0x74
f01068aa:	68 62 56 12 f0       	push   $0xf0125662
f01068af:	e8 85 9a ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01068b4:	e8 01 e4 ff ff       	call   f0104cba <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01068b9:	e8 cd 50 00 00       	call   f010b98b <get_cpu_proc>
f01068be:	89 c2                	mov    %eax,%edx
f01068c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068c3:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068c9:	39 c2                	cmp    %eax,%edx
f01068cb:	74 16                	je     f01068e3 <fos_scheduler+0x152>
f01068cd:	68 ab 56 12 f0       	push   $0xf01256ab
f01068d2:	68 c5 56 12 f0       	push   $0xf01256c5
f01068d7:	6a 7d                	push   $0x7d
f01068d9:	68 62 56 12 f0       	push   $0xf0125662
f01068de:	e8 56 9a ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f01068e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068e6:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068ec:	8b 40 18             	mov    0x18(%eax),%eax
f01068ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f01068f2:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f01068f6:	75 16                	jne    f010690e <fos_scheduler+0x17d>
f01068f8:	68 da 56 12 f0       	push   $0xf01256da
f01068fd:	68 c5 56 12 f0       	push   $0xf01256c5
f0106902:	6a 7f                	push   $0x7f
f0106904:	68 62 56 12 f0       	push   $0xf0125662
f0106909:	e8 2b 9a ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f010690e:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106912:	74 12                	je     f0106926 <fos_scheduler+0x195>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106914:	e8 ff 52 00 00       	call   f010bc18 <switchkvm>
					set_cpu_proc(NULL);
f0106919:	83 ec 0c             	sub    $0xc,%esp
f010691c:	6a 00                	push   $0x0
f010691e:	e8 91 50 00 00       	call   f010b9b4 <set_cpu_proc>
f0106923:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106926:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010692a:	0f 85 d3 fe ff ff    	jne    f0106803 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106930:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106937:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010693e:	eb 3e                	jmp    f010697e <fos_scheduler+0x1ed>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106940:	8b 0d f0 7a 69 f0    	mov    0xf0697af0,%ecx
f0106946:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106949:	89 d0                	mov    %edx,%eax
f010694b:	c1 e0 03             	shl    $0x3,%eax
f010694e:	01 d0                	add    %edx,%eax
f0106950:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106957:	01 d8                	add    %ebx,%eax
f0106959:	01 c0                	add    %eax,%eax
f010695b:	01 d0                	add    %edx,%eax
f010695d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106964:	01 d8                	add    %ebx,%eax
f0106966:	01 d0                	add    %edx,%eax
f0106968:	01 c8                	add    %ecx,%eax
f010696a:	8b 40 18             	mov    0x18(%eax),%eax
f010696d:	83 f8 03             	cmp    $0x3,%eax
f0106970:	75 09                	jne    f010697b <fos_scheduler+0x1ea>
			{
				is_any_blocked = 1;
f0106972:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0106979:	eb 0d                	jmp    f0106988 <fos_scheduler+0x1f7>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f010697b:	ff 45 f0             	incl   -0x10(%ebp)
f010697e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106981:	3d c9 02 00 00       	cmp    $0x2c9,%eax
f0106986:	76 b8                	jbe    f0106940 <fos_scheduler+0x1af>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0106988:	83 ec 0c             	sub    $0xc,%esp
f010698b:	68 e0 05 6c f0       	push   $0xf06c05e0
f0106990:	e8 0c 93 00 00       	call   f010fca1 <release_spinlock>
f0106995:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f0106998:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010699c:	0f 8f 50 fe ff ff    	jg     f01067f2 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01069a2:	e8 1b b4 ff ff       	call   f0101dc2 <get_into_prompt>

f01069a7 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01069a7:	55                   	push   %ebp
f01069a8:	89 e5                	mov    %esp,%ebp
f01069aa:	83 ec 28             	sub    $0x28,%esp
f01069ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01069b0:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01069b3:	c6 05 24 0d 6c f0 01 	movb   $0x1,0xf06c0d24
#if USE_KHEAP
	sched_delete_ready_queues();
f01069ba:	e8 5a e8 ff ff       	call   f0105219 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f01069bf:	83 ec 0c             	sub    $0xc,%esp
f01069c2:	6a 10                	push   $0x10
f01069c4:	e8 c8 2a 00 00       	call   f0109491 <kmalloc>
f01069c9:	83 c4 10             	add    $0x10,%esp
f01069cc:	a3 70 06 6c f0       	mov    %eax,0xf06c0670
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f01069d1:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f01069d6:	0f b6 c0             	movzbl %al,%eax
f01069d9:	83 ec 0c             	sub    $0xc,%esp
f01069dc:	50                   	push   %eax
f01069dd:	e8 af 2a 00 00       	call   f0109491 <kmalloc>
f01069e2:	83 c4 10             	add    $0x10,%esp
f01069e5:	a3 a4 09 6c f0       	mov    %eax,0xf06c09a4
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f01069ea:	a1 a4 09 6c f0       	mov    0xf06c09a4,%eax
f01069ef:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f01069f2:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f01069f4:	a1 a4 09 6c f0       	mov    0xf06c09a4,%eax
f01069f9:	8a 00                	mov    (%eax),%al
f01069fb:	0f b6 c0             	movzbl %al,%eax
f01069fe:	83 ec 0c             	sub    $0xc,%esp
f0106a01:	50                   	push   %eax
f0106a02:	e8 7c e3 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106a07:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106a0a:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0106a0f:	83 ec 0c             	sub    $0xc,%esp
f0106a12:	50                   	push   %eax
f0106a13:	e8 51 e5 ff ff       	call   f0104f69 <init_queue>
f0106a18:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106a1b:	e8 c2 e4 ff ff       	call   f0104ee2 <kclock_read_cnt0_latch>
f0106a20:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106a24:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106a28:	83 ec 08             	sub    $0x8,%esp
f0106a2b:	50                   	push   %eax
f0106a2c:	68 f0 56 12 f0       	push   $0xf01256f0
f0106a31:	e8 55 a5 ff ff       	call   f0100f8b <cprintf>
f0106a36:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106a39:	e8 ce 06 00 00       	call   f010710c <mycpu>
f0106a3e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a45:	00 00 00 
	scheduler_method = SCH_RR;
f0106a48:	c7 05 d4 0a 6c f0 00 	movl   $0x0,0xf06c0ad4
f0106a4f:	00 00 00 
	//=========================================
	//=========================================
}
f0106a52:	90                   	nop
f0106a53:	c9                   	leave  
f0106a54:	c3                   	ret    

f0106a55 <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106a55:	55                   	push   %ebp
f0106a56:	89 e5                	mov    %esp,%ebp
f0106a58:	83 ec 18             	sub    $0x18,%esp
f0106a5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0106a5e:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106a61:	e8 b3 e7 ff ff       	call   f0105219 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a66:	83 ec 04             	sub    $0x4,%esp
f0106a69:	68 18 57 12 f0       	push   $0xf0125718
f0106a6e:	68 ce 00 00 00       	push   $0xce
f0106a73:	68 62 56 12 f0       	push   $0xf0125662
f0106a78:	e8 bc 98 ff ff       	call   f0100339 <_panic>

f0106a7d <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106a7d:	55                   	push   %ebp
f0106a7e:	89 e5                	mov    %esp,%ebp
f0106a80:	83 ec 18             	sub    $0x18,%esp
f0106a83:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a89:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106a8c:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a8f:	83 ec 04             	sub    $0x4,%esp
f0106a92:	68 18 57 12 f0       	push   $0xf0125718
f0106a97:	68 e4 00 00 00       	push   $0xe4
f0106a9c:	68 62 56 12 f0       	push   $0xf0125662
f0106aa1:	e8 93 98 ff ff       	call   f0100339 <_panic>

f0106aa6 <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106aa6:	55                   	push   %ebp
f0106aa7:	89 e5                	mov    %esp,%ebp
f0106aa9:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106aac:	83 ec 0c             	sub    $0xc,%esp
f0106aaf:	68 e0 05 6c f0       	push   $0xf06c05e0
f0106ab4:	e8 7a 93 00 00       	call   f010fe33 <holding_spinlock>
f0106ab9:	83 c4 10             	add    $0x10,%esp
f0106abc:	85 c0                	test   %eax,%eax
f0106abe:	75 17                	jne    f0106ad7 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106ac0:	83 ec 04             	sub    $0x4,%esp
f0106ac3:	68 2c 57 12 f0       	push   $0xf012572c
f0106ac8:	68 fe 00 00 00       	push   $0xfe
f0106acd:	68 62 56 12 f0       	push   $0xf0125662
f0106ad2:	e8 62 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106ad7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106ade:	e8 a8 4e 00 00       	call   f010b98b <get_cpu_proc>
f0106ae3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106ae6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106aea:	74 14                	je     f0106b00 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106aec:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0106af1:	83 ec 08             	sub    $0x8,%esp
f0106af4:	ff 75 f0             	pushl  -0x10(%ebp)
f0106af7:	50                   	push   %eax
f0106af8:	e8 ad e4 ff ff       	call   f0104faa <enqueue>
f0106afd:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106b00:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f0106b05:	83 ec 0c             	sub    $0xc,%esp
f0106b08:	50                   	push   %eax
f0106b09:	e8 2d e5 ff ff       	call   f010503b <dequeue>
f0106b0e:	83 c4 10             	add    $0x10,%esp
f0106b11:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106b14:	a1 a4 09 6c f0       	mov    0xf06c09a4,%eax
f0106b19:	8a 00                	mov    (%eax),%al
f0106b1b:	0f b6 c0             	movzbl %al,%eax
f0106b1e:	83 ec 0c             	sub    $0xc,%esp
f0106b21:	50                   	push   %eax
f0106b22:	e8 5c e2 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106b27:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106b2d:	c9                   	leave  
f0106b2e:	c3                   	ret    

f0106b2f <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106b2f:	55                   	push   %ebp
f0106b30:	89 e5                	mov    %esp,%ebp
f0106b32:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b35:	83 ec 0c             	sub    $0xc,%esp
f0106b38:	68 e0 05 6c f0       	push   $0xf06c05e0
f0106b3d:	e8 f1 92 00 00       	call   f010fe33 <holding_spinlock>
f0106b42:	83 c4 10             	add    $0x10,%esp
f0106b45:	85 c0                	test   %eax,%eax
f0106b47:	75 17                	jne    f0106b60 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106b49:	83 ec 04             	sub    $0x4,%esp
f0106b4c:	68 78 57 12 f0       	push   $0xf0125778
f0106b51:	68 1d 01 00 00       	push   $0x11d
f0106b56:	68 62 56 12 f0       	push   $0xf0125662
f0106b5b:	e8 d9 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b60:	83 ec 04             	sub    $0x4,%esp
f0106b63:	68 18 57 12 f0       	push   $0xf0125718
f0106b68:	68 23 01 00 00       	push   $0x123
f0106b6d:	68 62 56 12 f0       	push   $0xf0125662
f0106b72:	e8 c2 97 ff ff       	call   f0100339 <_panic>

f0106b77 <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106b77:	55                   	push   %ebp
f0106b78:	89 e5                	mov    %esp,%ebp
f0106b7a:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b7d:	83 ec 0c             	sub    $0xc,%esp
f0106b80:	68 e0 05 6c f0       	push   $0xf06c05e0
f0106b85:	e8 a9 92 00 00       	call   f010fe33 <holding_spinlock>
f0106b8a:	83 c4 10             	add    $0x10,%esp
f0106b8d:	85 c0                	test   %eax,%eax
f0106b8f:	75 17                	jne    f0106ba8 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106b91:	83 ec 04             	sub    $0x4,%esp
f0106b94:	68 c8 57 12 f0       	push   $0xf01257c8
f0106b99:	68 2e 01 00 00       	push   $0x12e
f0106b9e:	68 62 56 12 f0       	push   $0xf0125662
f0106ba3:	e8 91 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106ba8:	83 ec 04             	sub    $0x4,%esp
f0106bab:	68 18 57 12 f0       	push   $0xf0125718
f0106bb0:	68 34 01 00 00       	push   $0x134
f0106bb5:	68 62 56 12 f0       	push   $0xf0125662
f0106bba:	e8 7a 97 ff ff       	call   f0100339 <_panic>

f0106bbf <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106bbf:	55                   	push   %ebp
f0106bc0:	89 e5                	mov    %esp,%ebp
f0106bc2:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106bc5:	e8 48 fb ff ff       	call   f0106712 <isSchedMethodBSD>
f0106bca:	85 c0                	test   %eax,%eax
f0106bcc:	74 17                	je     f0106be5 <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106bce:	83 ec 04             	sub    $0x4,%esp
f0106bd1:	68 18 57 12 f0       	push   $0xf0125718
f0106bd6:	68 43 01 00 00       	push   $0x143
f0106bdb:	68 62 56 12 f0       	push   $0xf0125662
f0106be0:	e8 54 97 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106be5:	a1 88 0c 6c f0       	mov    0xf06c0c88,%eax
f0106bea:	8b 15 8c 0c 6c f0    	mov    0xf06c0c8c,%edx
f0106bf0:	83 c0 01             	add    $0x1,%eax
f0106bf3:	83 d2 00             	adc    $0x0,%edx
f0106bf6:	a3 88 0c 6c f0       	mov    %eax,0xf06c0c88
f0106bfb:	89 15 8c 0c 6c f0    	mov    %edx,0xf06c0c8c
	struct Env* p = get_cpu_proc();
f0106c01:	e8 85 4d 00 00       	call   f010b98b <get_cpu_proc>
f0106c06:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106c09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c0d:	74 30                	je     f0106c3f <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c12:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0106c18:	8d 50 01             	lea    0x1(%eax),%edx
f0106c1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c1e:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106c24:	83 ec 0c             	sub    $0xc,%esp
f0106c27:	6a 01                	push   $0x1
f0106c29:	e8 99 89 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f0106c2e:	83 c4 10             	add    $0x10,%esp
f0106c31:	85 c0                	test   %eax,%eax
f0106c33:	74 05                	je     f0106c3a <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106c35:	e8 08 00 00 00       	call   f0106c42 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106c3a:	e8 6e 4e 00 00       	call   f010baad <yield>
	}
	/*****************************************/
}
f0106c3f:	90                   	nop
f0106c40:	c9                   	leave  
f0106c41:	c3                   	ret    

f0106c42 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106c42:	55                   	push   %ebp
f0106c43:	89 e5                	mov    %esp,%ebp
f0106c45:	53                   	push   %ebx
f0106c46:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106c49:	e8 3d 4d 00 00       	call   f010b98b <get_cpu_proc>
f0106c4e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106c51:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106c55:	0f 84 a1 01 00 00    	je     f0106dfc <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106c5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c5e:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0106c64:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c67:	eb 78                	jmp    f0106ce1 <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106c69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c6c:	8b 00                	mov    (%eax),%eax
f0106c6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106c71:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c74:	8b 40 64             	mov    0x64(%eax),%eax
f0106c77:	83 ec 08             	sub    $0x8,%esp
f0106c7a:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c7d:	50                   	push   %eax
f0106c7e:	e8 0c 30 00 00       	call   f0109c8f <pt_get_page_permissions>
f0106c83:	83 c4 10             	add    $0x10,%esp
f0106c86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106c89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c8c:	8b 40 08             	mov    0x8(%eax),%eax
f0106c8f:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106c92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106c95:	83 e0 20             	and    $0x20,%eax
f0106c98:	85 c0                	test   %eax,%eax
f0106c9a:	74 2b                	je     f0106cc7 <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106c9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c9f:	c1 e8 02             	shr    $0x2,%eax
f0106ca2:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106ca7:	89 c2                	mov    %eax,%edx
f0106ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cac:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106caf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cb2:	8b 40 64             	mov    0x64(%eax),%eax
f0106cb5:	6a 20                	push   $0x20
f0106cb7:	6a 00                	push   $0x0
f0106cb9:	ff 75 e8             	pushl  -0x18(%ebp)
f0106cbc:	50                   	push   %eax
f0106cbd:	e8 09 2f 00 00       	call   f0109bcb <pt_set_page_permissions>
f0106cc2:	83 c4 10             	add    $0x10,%esp
f0106cc5:	eb 0e                	jmp    f0106cd5 <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106cc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106cca:	c1 e8 02             	shr    $0x2,%eax
f0106ccd:	89 c2                	mov    %eax,%edx
f0106ccf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cd2:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106cd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cd8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106cde:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ce1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ce5:	74 08                	je     f0106cef <update_WS_time_stamps+0xad>
f0106ce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cea:	8b 40 10             	mov    0x10(%eax),%eax
f0106ced:	eb 05                	jmp    f0106cf4 <update_WS_time_stamps+0xb2>
f0106cef:	b8 00 00 00 00       	mov    $0x0,%eax
f0106cf4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106cf7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0106cfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d00:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106d06:	85 c0                	test   %eax,%eax
f0106d08:	0f 85 5b ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
f0106d0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d12:	0f 85 51 ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106d18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106d1f:	e9 ce 00 00 00       	jmp    f0106df2 <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106d24:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d27:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d2a:	89 d0                	mov    %edx,%eax
f0106d2c:	01 c0                	add    %eax,%eax
f0106d2e:	01 d0                	add    %edx,%eax
f0106d30:	c1 e0 03             	shl    $0x3,%eax
f0106d33:	01 c8                	add    %ecx,%eax
f0106d35:	05 b0 00 00 00       	add    $0xb0,%eax
f0106d3a:	8a 00                	mov    (%eax),%al
f0106d3c:	3c 01                	cmp    $0x1,%al
f0106d3e:	0f 84 ab 00 00 00    	je     f0106def <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106d44:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d47:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d4a:	89 d0                	mov    %edx,%eax
f0106d4c:	01 c0                	add    %eax,%eax
f0106d4e:	01 d0                	add    %edx,%eax
f0106d50:	c1 e0 03             	shl    $0x3,%eax
f0106d53:	01 c8                	add    %ecx,%eax
f0106d55:	05 ac 00 00 00       	add    $0xac,%eax
f0106d5a:	8b 00                	mov    (%eax),%eax
f0106d5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106d5f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d62:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d65:	89 d0                	mov    %edx,%eax
f0106d67:	01 c0                	add    %eax,%eax
f0106d69:	01 d0                	add    %edx,%eax
f0106d6b:	c1 e0 03             	shl    $0x3,%eax
f0106d6e:	01 c8                	add    %ecx,%eax
f0106d70:	05 b4 00 00 00       	add    $0xb4,%eax
f0106d75:	8b 00                	mov    (%eax),%eax
f0106d77:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106d7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d7d:	8b 40 64             	mov    0x64(%eax),%eax
f0106d80:	83 ec 08             	sub    $0x8,%esp
f0106d83:	ff 75 dc             	pushl  -0x24(%ebp)
f0106d86:	50                   	push   %eax
f0106d87:	e8 df 2f 00 00       	call   f0109d6b <pd_is_table_used>
f0106d8c:	83 c4 10             	add    $0x10,%esp
f0106d8f:	85 c0                	test   %eax,%eax
f0106d91:	74 3c                	je     f0106dcf <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106d93:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106d96:	c1 e8 02             	shr    $0x2,%eax
f0106d99:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106d9e:	89 c1                	mov    %eax,%ecx
f0106da0:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106da3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106da6:	89 d0                	mov    %edx,%eax
f0106da8:	01 c0                	add    %eax,%eax
f0106daa:	01 d0                	add    %edx,%eax
f0106dac:	c1 e0 03             	shl    $0x3,%eax
f0106daf:	01 d8                	add    %ebx,%eax
f0106db1:	05 b4 00 00 00       	add    $0xb4,%eax
f0106db6:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106dbb:	8b 40 64             	mov    0x64(%eax),%eax
f0106dbe:	83 ec 08             	sub    $0x8,%esp
f0106dc1:	ff 75 dc             	pushl  -0x24(%ebp)
f0106dc4:	50                   	push   %eax
f0106dc5:	e8 c5 2f 00 00       	call   f0109d8f <pd_set_table_unused>
f0106dca:	83 c4 10             	add    $0x10,%esp
f0106dcd:	eb 20                	jmp    f0106def <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106dcf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106dd2:	c1 e8 02             	shr    $0x2,%eax
f0106dd5:	89 c1                	mov    %eax,%ecx
f0106dd7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106dda:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ddd:	89 d0                	mov    %edx,%eax
f0106ddf:	01 c0                	add    %eax,%eax
f0106de1:	01 d0                	add    %edx,%eax
f0106de3:	c1 e0 03             	shl    $0x3,%eax
f0106de6:	01 d8                	add    %ebx,%eax
f0106de8:	05 b4 00 00 00       	add    $0xb4,%eax
f0106ded:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106def:	ff 45 f0             	incl   -0x10(%ebp)
f0106df2:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106df6:	0f 8e 28 ff ff ff    	jle    f0106d24 <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0106dfc:	90                   	nop
f0106dfd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106e00:	c9                   	leave  
f0106e01:	c3                   	ret    

f0106e02 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106e02:	55                   	push   %ebp
f0106e03:	89 e5                	mov    %esp,%ebp
f0106e05:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106e08:	c7 05 ec 7a 69 f0 01 	movl   $0x1,0xf0697aec
f0106e0f:	00 00 00 
f0106e12:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106e19:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106e1d:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106e20:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106e23:	ee                   	out    %al,(%dx)
f0106e24:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106e2b:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106e2f:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106e32:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e35:	ee                   	out    %al,(%dx)
f0106e36:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106e3d:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106e41:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106e44:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106e47:	ee                   	out    %al,(%dx)
f0106e48:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106e4f:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106e53:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106e56:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106e59:	ee                   	out    %al,(%dx)
f0106e5a:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106e61:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106e65:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106e68:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106e6b:	ee                   	out    %al,(%dx)
f0106e6c:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106e73:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106e77:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106e7a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106e7d:	ee                   	out    %al,(%dx)
f0106e7e:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106e85:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106e89:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106e8c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106e8f:	ee                   	out    %al,(%dx)
f0106e90:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106e97:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106e9b:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106e9e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106ea1:	ee                   	out    %al,(%dx)
f0106ea2:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106ea9:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106ead:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106eb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106eb3:	ee                   	out    %al,(%dx)
f0106eb4:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106ebb:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106ebf:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106ec2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106ec5:	ee                   	out    %al,(%dx)
f0106ec6:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106ecd:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106ed1:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106ed4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106ed7:	ee                   	out    %al,(%dx)
f0106ed8:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106edf:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106ee3:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106ee6:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106ee9:	ee                   	out    %al,(%dx)
f0106eea:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106ef1:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106ef5:	8a 45 be             	mov    -0x42(%ebp),%al
f0106ef8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106efb:	ee                   	out    %al,(%dx)
f0106efc:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106f03:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106f07:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106f0a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106f0d:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106f0e:	66 a1 58 f9 17 f0    	mov    0xf017f958,%ax
f0106f14:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106f18:	74 15                	je     f0106f2f <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106f1a:	66 a1 58 f9 17 f0    	mov    0xf017f958,%ax
f0106f20:	0f b7 c0             	movzwl %ax,%eax
f0106f23:	83 ec 0c             	sub    $0xc,%esp
f0106f26:	50                   	push   %eax
f0106f27:	e8 06 00 00 00       	call   f0106f32 <irq_setmask_8259A>
f0106f2c:	83 c4 10             	add    $0x10,%esp
}
f0106f2f:	90                   	nop
f0106f30:	c9                   	leave  
f0106f31:	c3                   	ret    

f0106f32 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106f32:	55                   	push   %ebp
f0106f33:	89 e5                	mov    %esp,%ebp
f0106f35:	83 ec 14             	sub    $0x14,%esp
f0106f38:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f3b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106f3f:	a1 ec 7a 69 f0       	mov    0xf0697aec,%eax
f0106f44:	85 c0                	test   %eax,%eax
f0106f46:	74 34                	je     f0106f7c <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106f48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f4b:	0f b6 c0             	movzbl %al,%eax
f0106f4e:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106f55:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106f58:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106f5b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106f5e:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106f5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f62:	66 c1 e8 08          	shr    $0x8,%ax
f0106f66:	0f b6 c0             	movzbl %al,%eax
f0106f69:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106f70:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106f73:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106f76:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106f79:	ee                   	out    %al,(%dx)
f0106f7a:	eb 01                	jmp    f0106f7d <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106f7c:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106f7d:	c9                   	leave  
f0106f7e:	c3                   	ret    

f0106f7f <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106f7f:	55                   	push   %ebp
f0106f80:	89 e5                	mov    %esp,%ebp
f0106f82:	53                   	push   %ebx
f0106f83:	83 ec 14             	sub    $0x14,%esp
f0106f86:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f89:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f8c:	a1 ec 7a 69 f0       	mov    0xf0697aec,%eax
f0106f91:	85 c0                	test   %eax,%eax
f0106f93:	74 58                	je     f0106fed <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f95:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106f99:	77 08                	ja     f0106fa3 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106f9b:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106fa1:	eb 0a                	jmp    f0106fad <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106fa3:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106fa9:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106fad:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fb1:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb7:	89 c2                	mov    %eax,%edx
f0106fb9:	ec                   	in     (%dx),%al
f0106fba:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106fbd:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106fc0:	88 c2                	mov    %al,%dl
f0106fc2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106fc6:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106fcb:	88 c1                	mov    %al,%cl
f0106fcd:	d3 e3                	shl    %cl,%ebx
f0106fcf:	89 d8                	mov    %ebx,%eax
f0106fd1:	09 d0                	or     %edx,%eax
f0106fd3:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106fd6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106fda:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106fde:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106fe1:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106fe4:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106fe7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fea:	ee                   	out    %al,(%dx)
f0106feb:	eb 01                	jmp    f0106fee <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106fed:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106fee:	83 c4 14             	add    $0x14,%esp
f0106ff1:	5b                   	pop    %ebx
f0106ff2:	5d                   	pop    %ebp
f0106ff3:	c3                   	ret    

f0106ff4 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106ff4:	55                   	push   %ebp
f0106ff5:	89 e5                	mov    %esp,%ebp
f0106ff7:	53                   	push   %ebx
f0106ff8:	83 ec 14             	sub    $0x14,%esp
f0106ffb:	8b 45 08             	mov    0x8(%ebp),%eax
f0106ffe:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107001:	a1 ec 7a 69 f0       	mov    0xf0697aec,%eax
f0107006:	85 c0                	test   %eax,%eax
f0107008:	74 5a                	je     f0107064 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f010700a:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010700e:	77 08                	ja     f0107018 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107010:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107016:	eb 0a                	jmp    f0107022 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107018:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010701e:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0107022:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107026:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107029:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010702c:	89 c2                	mov    %eax,%edx
f010702e:	ec                   	in     (%dx),%al
f010702f:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107032:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107035:	88 c2                	mov    %al,%dl
f0107037:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010703b:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107040:	88 c1                	mov    %al,%cl
f0107042:	d3 e3                	shl    %cl,%ebx
f0107044:	89 d8                	mov    %ebx,%eax
f0107046:	f7 d0                	not    %eax
f0107048:	21 d0                	and    %edx,%eax
f010704a:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f010704d:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107051:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107055:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107058:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010705b:	8a 45 ef             	mov    -0x11(%ebp),%al
f010705e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107061:	ee                   	out    %al,(%dx)
f0107062:	eb 01                	jmp    f0107065 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107064:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107065:	83 c4 14             	add    $0x14,%esp
f0107068:	5b                   	pop    %ebx
f0107069:	5d                   	pop    %ebp
f010706a:	c3                   	ret    

f010706b <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f010706b:	55                   	push   %ebp
f010706c:	89 e5                	mov    %esp,%ebp
f010706e:	53                   	push   %ebx
f010706f:	83 ec 14             	sub    $0x14,%esp
f0107072:	8b 45 08             	mov    0x8(%ebp),%eax
f0107075:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107078:	a1 ec 7a 69 f0       	mov    0xf0697aec,%eax
f010707d:	85 c0                	test   %eax,%eax
f010707f:	75 07                	jne    f0107088 <irq_get_mask+0x1d>
		return -1;
f0107081:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107086:	eb 45                	jmp    f01070cd <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107088:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010708c:	77 08                	ja     f0107096 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f010708e:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107094:	eb 0a                	jmp    f01070a0 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107096:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010709c:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f01070a0:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01070a4:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01070a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070aa:	89 c2                	mov    %eax,%edx
f01070ac:	ec                   	in     (%dx),%al
f01070ad:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01070b0:	8a 45 f3             	mov    -0xd(%ebp),%al
f01070b3:	88 c2                	mov    %al,%dl
f01070b5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01070b9:	bb 01 00 00 00       	mov    $0x1,%ebx
f01070be:	88 c1                	mov    %al,%cl
f01070c0:	d3 e3                	shl    %cl,%ebx
f01070c2:	89 d8                	mov    %ebx,%eax
f01070c4:	21 d0                	and    %edx,%eax
f01070c6:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01070c9:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01070cd:	83 c4 14             	add    $0x14,%esp
f01070d0:	5b                   	pop    %ebx
f01070d1:	5d                   	pop    %ebp
f01070d2:	c3                   	ret    

f01070d3 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01070d3:	55                   	push   %ebp
f01070d4:	89 e5                	mov    %esp,%ebp
f01070d6:	83 ec 14             	sub    $0x14,%esp
f01070d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01070dc:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f01070df:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f01070e3:	76 12                	jbe    f01070f7 <pic_sendEOI+0x24>
f01070e5:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f01070ec:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01070f0:	8a 45 f7             	mov    -0x9(%ebp),%al
f01070f3:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01070f6:	ee                   	out    %al,(%dx)
f01070f7:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f01070fe:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0107102:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107105:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107108:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107109:	90                   	nop
f010710a:	c9                   	leave  
f010710b:	c3                   	ret    

f010710c <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f010710c:	55                   	push   %ebp
f010710d:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f010710f:	b8 c0 07 6c f0       	mov    $0xf06c07c0,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0107114:	5d                   	pop    %ebp
f0107115:	c3                   	ret    

f0107116 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107116:	55                   	push   %ebp
f0107117:	89 e5                	mov    %esp,%ebp
f0107119:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f010711c:	e8 eb ff ff ff       	call   f010710c <mycpu>
f0107121:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0107124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107127:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010712e:	00 00 00 
  c->ncli = 0;
f0107131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107134:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010713b:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010713e:	9c                   	pushf  
f010713f:	58                   	pop    %eax
f0107140:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107143:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107146:	25 00 02 00 00       	and    $0x200,%eax
f010714b:	85 c0                	test   %eax,%eax
f010714d:	0f 95 c0             	setne  %al
f0107150:	0f b6 d0             	movzbl %al,%edx
f0107153:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107156:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f010715c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107166:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107169:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107170:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107173:	8b 45 08             	mov    0x8(%ebp),%eax
f0107176:	40                   	inc    %eax
f0107177:	c1 e0 0f             	shl    $0xf,%eax
f010717a:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f010717f:	29 c2                	sub    %eax,%edx
f0107181:	89 d0                	mov    %edx,%eax
f0107183:	89 c2                	mov    %eax,%edx
f0107185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107188:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f010718b:	e8 18 01 00 00       	call   f01072a8 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107190:	e8 c6 5e 00 00       	call   f010d05b <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0107195:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107198:	83 c0 0c             	add    $0xc,%eax
f010719b:	83 ec 04             	sub    $0x4,%esp
f010719e:	6a 68                	push   $0x68
f01071a0:	6a 00                	push   $0x0
f01071a2:	50                   	push   %eax
f01071a3:	e8 0e 8c 01 00       	call   f011fdb6 <memset>
f01071a8:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f01071ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ae:	05 a4 00 00 00       	add    $0xa4,%eax
f01071b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01071b6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01071bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01071c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01071c3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01071c6:	f0 87 02             	lock xchg %eax,(%edx)
f01071c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01071cc:	90                   	nop
f01071cd:	c9                   	leave  
f01071ce:	c3                   	ret    

f01071cf <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01071cf:	55                   	push   %ebp
f01071d0:	89 e5                	mov    %esp,%ebp
f01071d2:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01071d5:	9c                   	pushf  
f01071d6:	58                   	pop    %eax
f01071d7:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f01071da:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f01071dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01071e0:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f01071e1:	e8 26 ff ff ff       	call   f010710c <mycpu>
f01071e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f01071e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ec:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071f2:	85 c0                	test   %eax,%eax
f01071f4:	75 13                	jne    f0107209 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f01071f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01071f9:	25 00 02 00 00       	and    $0x200,%eax
f01071fe:	89 c2                	mov    %eax,%edx
f0107200:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107203:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0107209:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010720c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107212:	8d 50 01             	lea    0x1(%eax),%edx
f0107215:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107218:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f010721e:	90                   	nop
f010721f:	c9                   	leave  
f0107220:	c3                   	ret    

f0107221 <popcli>:

void popcli(void)
{
f0107221:	55                   	push   %ebp
f0107222:	89 e5                	mov    %esp,%ebp
f0107224:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107227:	9c                   	pushf  
f0107228:	58                   	pop    %eax
f0107229:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010722c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f010722f:	25 00 02 00 00       	and    $0x200,%eax
f0107234:	85 c0                	test   %eax,%eax
f0107236:	74 14                	je     f010724c <popcli+0x2b>
    panic("popcli - interruptible");
f0107238:	83 ec 04             	sub    $0x4,%esp
f010723b:	68 15 58 12 f0       	push   $0xf0125815
f0107240:	6a 5e                	push   $0x5e
f0107242:	68 2c 58 12 f0       	push   $0xf012582c
f0107247:	e8 ed 90 ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f010724c:	e8 bb fe ff ff       	call   f010710c <mycpu>
f0107251:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f0107254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107257:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010725d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107260:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107263:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0107269:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010726c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107272:	85 c0                	test   %eax,%eax
f0107274:	79 14                	jns    f010728a <popcli+0x69>
    panic("popcli");
f0107276:	83 ec 04             	sub    $0x4,%esp
f0107279:	68 3b 58 12 f0       	push   $0xf012583b
f010727e:	6a 61                	push   $0x61
f0107280:	68 2c 58 12 f0       	push   $0xf012582c
f0107285:	e8 af 90 ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f010728a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010728d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107293:	85 c0                	test   %eax,%eax
f0107295:	75 0e                	jne    f01072a5 <popcli+0x84>
f0107297:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010729a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01072a0:	85 c0                	test   %eax,%eax
f01072a2:	74 01                	je     f01072a5 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01072a4:	fb                   	sti    
    sti();
}
f01072a5:	90                   	nop
f01072a6:	c9                   	leave  
f01072a7:	c3                   	ret    

f01072a8 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f01072a8:	55                   	push   %ebp
f01072a9:	89 e5                	mov    %esp,%ebp
f01072ab:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01072ae:	e8 1c ff ff ff       	call   f01071cf <pushcli>

	c = mycpu();
f01072b3:	e8 54 fe ff ff       	call   f010710c <mycpu>
f01072b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01072bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072be:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01072c5:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01072cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072cf:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f01072d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072d8:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f01072de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072e1:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f01072e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072eb:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072f1:	83 e2 f0             	and    $0xfffffff0,%edx
f01072f4:	83 ca 0a             	or     $0xa,%edx
f01072f7:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107300:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107306:	83 ca 10             	or     $0x10,%edx
f0107309:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010730f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107312:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107318:	83 e2 9f             	and    $0xffffff9f,%edx
f010731b:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107321:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107324:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010732a:	83 ca 80             	or     $0xffffff80,%edx
f010732d:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107333:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107336:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010733c:	83 ca 0f             	or     $0xf,%edx
f010733f:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107345:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107348:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010734e:	83 e2 ef             	and    $0xffffffef,%edx
f0107351:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107357:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010735a:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107360:	83 e2 df             	and    $0xffffffdf,%edx
f0107363:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107369:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010736c:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107372:	83 ca 40             	or     $0x40,%edx
f0107375:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010737b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010737e:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107384:	83 ca 80             	or     $0xffffff80,%edx
f0107387:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010738d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107390:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f0107397:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010739a:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01073a1:	ff ff 
f01073a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073a6:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01073ad:	00 00 
f01073af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073b2:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01073b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073bc:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073c2:	83 e2 f0             	and    $0xfffffff0,%edx
f01073c5:	83 ca 02             	or     $0x2,%edx
f01073c8:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d1:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073d7:	83 ca 10             	or     $0x10,%edx
f01073da:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073e3:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073e9:	83 e2 9f             	and    $0xffffff9f,%edx
f01073ec:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f5:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073fb:	83 ca 80             	or     $0xffffff80,%edx
f01073fe:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107404:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107407:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010740d:	83 ca 0f             	or     $0xf,%edx
f0107410:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107416:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107419:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010741f:	83 e2 ef             	and    $0xffffffef,%edx
f0107422:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107428:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010742b:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107431:	83 e2 df             	and    $0xffffffdf,%edx
f0107434:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010743a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010743d:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107443:	83 ca 40             	or     $0x40,%edx
f0107446:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010744c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010744f:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107455:	83 ca 80             	or     $0xffffff80,%edx
f0107458:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010745e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107461:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107468:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010746b:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107472:	ff ff 
f0107474:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107477:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f010747e:	00 00 
f0107480:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107483:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010748a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010748d:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107493:	83 e2 f0             	and    $0xfffffff0,%edx
f0107496:	83 ca 0a             	or     $0xa,%edx
f0107499:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f010749f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a2:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074a8:	83 ca 10             	or     $0x10,%edx
f01074ab:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b4:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074ba:	83 ca 60             	or     $0x60,%edx
f01074bd:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c6:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074cc:	83 ca 80             	or     $0xffffff80,%edx
f01074cf:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d8:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074de:	83 ca 0f             	or     $0xf,%edx
f01074e1:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074ea:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074f0:	83 e2 ef             	and    $0xffffffef,%edx
f01074f3:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074fc:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107502:	83 e2 df             	and    $0xffffffdf,%edx
f0107505:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010750b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010750e:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107514:	83 ca 40             	or     $0x40,%edx
f0107517:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010751d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107520:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107526:	83 ca 80             	or     $0xffffff80,%edx
f0107529:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010752f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107532:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107539:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010753c:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107543:	ff ff 
f0107545:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107548:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f010754f:	00 00 
f0107551:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107554:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f010755b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010755e:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107564:	83 e2 f0             	and    $0xfffffff0,%edx
f0107567:	83 ca 02             	or     $0x2,%edx
f010756a:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107570:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107573:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107579:	83 ca 10             	or     $0x10,%edx
f010757c:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107582:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107585:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010758b:	83 ca 60             	or     $0x60,%edx
f010758e:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107594:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107597:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010759d:	83 ca 80             	or     $0xffffff80,%edx
f01075a0:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01075a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075a9:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075af:	83 ca 0f             	or     $0xf,%edx
f01075b2:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075bb:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075c1:	83 e2 ef             	and    $0xffffffef,%edx
f01075c4:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075cd:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075d3:	83 e2 df             	and    $0xffffffdf,%edx
f01075d6:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075df:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075e5:	83 ca 40             	or     $0x40,%edx
f01075e8:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075f1:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075f7:	83 ca 80             	or     $0xffffff80,%edx
f01075fa:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107600:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107603:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010760a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760d:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0107614:	00 00 00 
f0107617:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010761e:	00 00 00 

	popcli();	//enable interrupt
f0107621:	e8 fb fb ff ff       	call   f0107221 <popcli>


}
f0107626:	90                   	nop
f0107627:	c9                   	leave  
f0107628:	c3                   	ret    

f0107629 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107629:	55                   	push   %ebp
f010762a:	89 e5                	mov    %esp,%ebp
f010762c:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f010762f:	83 ec 08             	sub    $0x8,%esp
f0107632:	68 00 10 00 00       	push   $0x1000
f0107637:	68 00 10 00 00       	push   $0x1000
f010763c:	e8 42 02 00 00       	call   f0107883 <boot_allocate_space>
f0107641:	83 c4 10             	add    $0x10,%esp
f0107644:	a3 9c 0c 6c f0       	mov    %eax,0xf06c0c9c
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107649:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f010764e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107651:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107658:	77 14                	ja     f010766e <initialize_kernel_VM+0x45>
f010765a:	ff 75 e0             	pushl  -0x20(%ebp)
f010765d:	68 44 58 12 f0       	push   $0xf0125844
f0107662:	6a 57                	push   $0x57
f0107664:	68 78 58 12 f0       	push   $0xf0125878
f0107669:	e8 cb 8c ff ff       	call   f0100339 <_panic>
f010766e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107671:	05 00 00 00 10       	add    $0x10000000,%eax
f0107676:	a3 c4 0d 6c f0       	mov    %eax,0xf06c0dc4
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f010767b:	c7 45 dc 00 70 17 f0 	movl   $0xf0177000,-0x24(%ebp)
f0107682:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107689:	77 14                	ja     f010769f <initialize_kernel_VM+0x76>
f010768b:	ff 75 dc             	pushl  -0x24(%ebp)
f010768e:	68 44 58 12 f0       	push   $0xf0125844
f0107693:	6a 63                	push   $0x63
f0107695:	68 78 58 12 f0       	push   $0xf0125878
f010769a:	e8 9a 8c ff ff       	call   f0100339 <_panic>
f010769f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01076a2:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01076a8:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01076ad:	83 ec 0c             	sub    $0xc,%esp
f01076b0:	6a 02                	push   $0x2
f01076b2:	52                   	push   %edx
f01076b3:	68 00 80 00 00       	push   $0x8000
f01076b8:	68 00 80 bf ef       	push   $0xefbf8000
f01076bd:	50                   	push   %eax
f01076be:	e8 34 02 00 00       	call   f01078f7 <boot_map_range>
f01076c3:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01076cd:	eb 24                	jmp    f01076f3 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01076cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076d2:	40                   	inc    %eax
f01076d3:	c1 e0 0f             	shl    $0xf,%eax
f01076d6:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01076db:	29 c2                	sub    %eax,%edx
f01076dd:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01076e2:	6a 01                	push   $0x1
f01076e4:	6a 00                	push   $0x0
f01076e6:	52                   	push   %edx
f01076e7:	50                   	push   %eax
f01076e8:	e8 de 24 00 00       	call   f0109bcb <pt_set_page_permissions>
f01076ed:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076f0:	ff 45 f4             	incl   -0xc(%ebp)
f01076f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01076f7:	7e d6                	jle    f01076cf <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f01076f9:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107700:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107707:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010770e:	eb 25                	jmp    f0107735 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107710:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107713:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107716:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f010771b:	83 ec 04             	sub    $0x4,%esp
f010771e:	6a 01                	push   $0x1
f0107720:	52                   	push   %edx
f0107721:	50                   	push   %eax
f0107722:	e8 44 02 00 00       	call   f010796b <boot_get_page_table>
f0107727:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010772a:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107731:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107735:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107739:	72 d5                	jb     f0107710 <initialize_kernel_VM+0xe7>
f010773b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010773f:	77 06                	ja     f0107747 <initialize_kernel_VM+0x11e>
f0107741:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107745:	76 c9                	jbe    f0107710 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107747:	8b 15 78 08 6c f0    	mov    0xf06c0878,%edx
f010774d:	89 d0                	mov    %edx,%eax
f010774f:	01 c0                	add    %eax,%eax
f0107751:	01 d0                	add    %edx,%eax
f0107753:	c1 e0 03             	shl    $0x3,%eax
f0107756:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107759:	83 ec 08             	sub    $0x8,%esp
f010775c:	68 00 10 00 00       	push   $0x1000
f0107761:	ff 75 d8             	pushl  -0x28(%ebp)
f0107764:	e8 1a 01 00 00       	call   f0107883 <boot_allocate_space>
f0107769:	83 c4 10             	add    $0x10,%esp
f010776c:	a3 e0 0a 6c f0       	mov    %eax,0xf06c0ae0
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107771:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107778:	83 ec 08             	sub    $0x8,%esp
f010777b:	68 00 10 00 00       	push   $0x1000
f0107780:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107783:	e8 fb 00 00 00       	call   f0107883 <boot_allocate_space>
f0107788:	83 c4 10             	add    $0x10,%esp
f010778b:	a3 a0 03 6c f0       	mov    %eax,0xf06c03a0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107790:	e8 05 05 00 00       	call   f0107c9a <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107795:	83 ec 0c             	sub    $0xc,%esp
f0107798:	68 ca 02 00 00       	push   $0x2ca
f010779d:	e8 84 69 01 00       	call   f011e126 <nearest_pow2_ceil>
f01077a2:	83 c4 10             	add    $0x10,%esp
f01077a5:	83 ec 04             	sub    $0x4,%esp
f01077a8:	50                   	push   %eax
f01077a9:	68 ca 02 00 00       	push   $0x2ca
f01077ae:	68 98 58 12 f0       	push   $0xf0125898
f01077b3:	e8 d3 97 ff ff       	call   f0100f8b <cprintf>
f01077b8:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f01077bb:	c7 45 d0 58 fe 0f 00 	movl   $0xffe58,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f01077c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01077c5:	83 ec 08             	sub    $0x8,%esp
f01077c8:	68 00 10 00 00       	push   $0x1000
f01077cd:	50                   	push   %eax
f01077ce:	e8 b0 00 00 00       	call   f0107883 <boot_allocate_space>
f01077d3:	83 c4 10             	add    $0x10,%esp
f01077d6:	a3 f0 7a 69 f0       	mov    %eax,0xf0697af0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f01077db:	a1 f0 7a 69 f0       	mov    0xf0697af0,%eax
f01077e0:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01077e3:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f01077ea:	77 17                	ja     f0107803 <initialize_kernel_VM+0x1da>
f01077ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01077ef:	68 44 58 12 f0       	push   $0xf0125844
f01077f4:	68 b1 00 00 00       	push   $0xb1
f01077f9:	68 78 58 12 f0       	push   $0xf0125878
f01077fe:	e8 36 8b ff ff       	call   f0100339 <_panic>
f0107803:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107806:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f010780c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010780f:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0107814:	83 ec 0c             	sub    $0xc,%esp
f0107817:	6a 04                	push   $0x4
f0107819:	51                   	push   %ecx
f010781a:	52                   	push   %edx
f010781b:	68 00 00 c0 ee       	push   $0xeec00000
f0107820:	50                   	push   %eax
f0107821:	e8 d1 00 00 00       	call   f01078f7 <boot_map_range>
f0107826:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107829:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f010782e:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107833:	8b 15 9c 0c 6c f0    	mov    0xf06c0c9c,%edx
f0107839:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f010783f:	8b 12                	mov    (%edx),%edx
f0107841:	83 ca 05             	or     $0x5,%edx
f0107844:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107846:	a1 98 0c 6c f0       	mov    0xf06c0c98,%eax
f010784b:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107851:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0107856:	83 ec 0c             	sub    $0xc,%esp
f0107859:	6a 02                	push   $0x2
f010785b:	6a 00                	push   $0x0
f010785d:	52                   	push   %edx
f010785e:	68 00 00 00 f0       	push   $0xf0000000
f0107863:	50                   	push   %eax
f0107864:	e8 8e 00 00 00       	call   f01078f7 <boot_map_range>
f0107869:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f010786c:	e8 88 78 01 00       	call   f011f0f9 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107871:	c7 05 b0 07 6c f0 19 	movl   $0x19,0xf06c07b0
f0107878:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f010787b:	e8 e6 02 00 00       	call   f0107b66 <turn_on_paging>
}
f0107880:	90                   	nop
f0107881:	c9                   	leave  
f0107882:	c3                   	ret    

f0107883 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107883:	55                   	push   %ebp
f0107884:	89 e5                	mov    %esp,%ebp
f0107886:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107889:	a1 98 0c 6c f0       	mov    0xf06c0c98,%eax
f010788e:	85 c0                	test   %eax,%eax
f0107890:	75 0a                	jne    f010789c <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107892:	c7 05 98 0c 6c f0 b0 	movl   $0xf0b0b7b0,0xf06c0c98
f0107899:	b7 b0 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f010789c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010789f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01078a2:	a1 98 0c 6c f0       	mov    0xf06c0c98,%eax
f01078a7:	89 c2                	mov    %eax,%edx
f01078a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078ac:	01 d0                	add    %edx,%eax
f01078ae:	48                   	dec    %eax
f01078af:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01078b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078b5:	ba 00 00 00 00       	mov    $0x0,%edx
f01078ba:	f7 75 f4             	divl   -0xc(%ebp)
f01078bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078c0:	29 d0                	sub    %edx,%eax
f01078c2:	a3 98 0c 6c f0       	mov    %eax,0xf06c0c98

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f01078c7:	a1 98 0c 6c f0       	mov    0xf06c0c98,%eax
f01078cc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f01078cf:	8b 15 98 0c 6c f0    	mov    0xf06c0c98,%edx
f01078d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01078d8:	01 d0                	add    %edx,%eax
f01078da:	a3 98 0c 6c f0       	mov    %eax,0xf06c0c98

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f01078df:	83 ec 04             	sub    $0x4,%esp
f01078e2:	ff 75 08             	pushl  0x8(%ebp)
f01078e5:	6a 00                	push   $0x0
f01078e7:	ff 75 ec             	pushl  -0x14(%ebp)
f01078ea:	e8 c7 84 01 00       	call   f011fdb6 <memset>
f01078ef:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01078f2:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f01078f5:	c9                   	leave  
f01078f6:	c3                   	ret    

f01078f7 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01078f7:	55                   	push   %ebp
f01078f8:	89 e5                	mov    %esp,%ebp
f01078fa:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01078fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107904:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010790b:	eb 53                	jmp    f0107960 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f010790d:	83 ec 04             	sub    $0x4,%esp
f0107910:	6a 01                	push   $0x1
f0107912:	ff 75 0c             	pushl  0xc(%ebp)
f0107915:	ff 75 08             	pushl  0x8(%ebp)
f0107918:	e8 4e 00 00 00       	call   f010796b <boot_get_page_table>
f010791d:	83 c4 10             	add    $0x10,%esp
f0107920:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107923:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107926:	c1 e8 0c             	shr    $0xc,%eax
f0107929:	25 ff 03 00 00       	and    $0x3ff,%eax
f010792e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107931:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107934:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010793b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010793e:	01 c2                	add    %eax,%edx
f0107940:	8b 45 18             	mov    0x18(%ebp),%eax
f0107943:	0b 45 14             	or     0x14(%ebp),%eax
f0107946:	83 c8 01             	or     $0x1,%eax
f0107949:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f010794b:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107952:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107959:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107960:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107963:	3b 45 10             	cmp    0x10(%ebp),%eax
f0107966:	72 a5                	jb     f010790d <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0107968:	90                   	nop
f0107969:	c9                   	leave  
f010796a:	c3                   	ret    

f010796b <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f010796b:	55                   	push   %ebp
f010796c:	89 e5                	mov    %esp,%ebp
f010796e:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107971:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107974:	c1 e8 16             	shr    $0x16,%eax
f0107977:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010797a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010797d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107984:	8b 45 08             	mov    0x8(%ebp),%eax
f0107987:	01 d0                	add    %edx,%eax
f0107989:	8b 00                	mov    (%eax),%eax
f010798b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f010798e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107991:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107996:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0107999:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010799c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010799f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079a2:	c1 e8 0c             	shr    $0xc,%eax
f01079a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01079a8:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f01079ad:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01079b0:	72 17                	jb     f01079c9 <boot_get_page_table+0x5e>
f01079b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01079b5:	68 c0 58 12 f0       	push   $0xf01258c0
f01079ba:	68 33 01 00 00       	push   $0x133
f01079bf:	68 78 58 12 f0       	push   $0xf0125878
f01079c4:	e8 70 89 ff ff       	call   f0100339 <_panic>
f01079c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079cc:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01079d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01079d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01079d8:	75 72                	jne    f0107a4c <boot_get_page_table+0xe1>
	{
		if (create)
f01079da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01079de:	74 65                	je     f0107a45 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01079e0:	83 ec 08             	sub    $0x8,%esp
f01079e3:	68 00 10 00 00       	push   $0x1000
f01079e8:	68 00 10 00 00       	push   $0x1000
f01079ed:	e8 91 fe ff ff       	call   f0107883 <boot_allocate_space>
f01079f2:	83 c4 10             	add    $0x10,%esp
f01079f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01079f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01079fe:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107a05:	77 17                	ja     f0107a1e <boot_get_page_table+0xb3>
f0107a07:	ff 75 dc             	pushl  -0x24(%ebp)
f0107a0a:	68 44 58 12 f0       	push   $0xf0125844
f0107a0f:	68 39 01 00 00       	push   $0x139
f0107a14:	68 78 58 12 f0       	push   $0xf0125878
f0107a19:	e8 1b 89 ff ff       	call   f0100339 <_panic>
f0107a1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107a21:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a26:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a2c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107a33:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a36:	01 d0                	add    %edx,%eax
f0107a38:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107a3b:	83 ca 03             	or     $0x3,%edx
f0107a3e:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107a40:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a43:	eb 0a                	jmp    f0107a4f <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107a45:	b8 00 00 00 00       	mov    $0x0,%eax
f0107a4a:	eb 03                	jmp    f0107a4f <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107a4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107a4f:	c9                   	leave  
f0107a50:	c3                   	ret    

f0107a51 <nvram_read>:


int nvram_read(int r)
{
f0107a51:	55                   	push   %ebp
f0107a52:	89 e5                	mov    %esp,%ebp
f0107a54:	53                   	push   %ebx
f0107a55:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107a58:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a5b:	83 ec 0c             	sub    $0xc,%esp
f0107a5e:	50                   	push   %eax
f0107a5f:	e8 28 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a64:	83 c4 10             	add    $0x10,%esp
f0107a67:	89 c3                	mov    %eax,%ebx
f0107a69:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a6c:	40                   	inc    %eax
f0107a6d:	83 ec 0c             	sub    $0xc,%esp
f0107a70:	50                   	push   %eax
f0107a71:	e8 16 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a76:	83 c4 10             	add    $0x10,%esp
f0107a79:	c1 e0 08             	shl    $0x8,%eax
f0107a7c:	09 d8                	or     %ebx,%eax
}
f0107a7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107a81:	c9                   	leave  
f0107a82:	c3                   	ret    

f0107a83 <detect_memory>:

void detect_memory()
{
f0107a83:	55                   	push   %ebp
f0107a84:	89 e5                	mov    %esp,%ebp
f0107a86:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107a89:	83 ec 0c             	sub    $0xc,%esp
f0107a8c:	6a 15                	push   $0x15
f0107a8e:	e8 be ff ff ff       	call   f0107a51 <nvram_read>
f0107a93:	83 c4 10             	add    $0x10,%esp
f0107a96:	c1 e0 0a             	shl    $0xa,%eax
f0107a99:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107aa4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107aa7:	83 ec 0c             	sub    $0xc,%esp
f0107aaa:	6a 17                	push   $0x17
f0107aac:	e8 a0 ff ff ff       	call   f0107a51 <nvram_read>
f0107ab1:	83 c4 10             	add    $0x10,%esp
f0107ab4:	c1 e0 0a             	shl    $0xa,%eax
f0107ab7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107aba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107abd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ac2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107ac5:	83 ec 0c             	sub    $0xc,%esp
f0107ac8:	6a 34                	push   $0x34
f0107aca:	e8 82 ff ff ff       	call   f0107a51 <nvram_read>
f0107acf:	83 c4 10             	add    $0x10,%esp
f0107ad2:	c1 e0 10             	shl    $0x10,%eax
f0107ad5:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107ad8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107adb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ae0:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107ae3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107ae7:	74 18                	je     f0107b01 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107ae9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107aec:	05 00 00 00 01       	add    $0x1000000,%eax
f0107af1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107af7:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107afc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107aff:	eb 19                	jmp    f0107b1a <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107b01:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107b05:	74 0d                	je     f0107b14 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107b07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b0a:	05 00 00 10 00       	add    $0x100000,%eax
f0107b0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107b12:	eb 06                	jmp    f0107b1a <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107b1a:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b24:	c1 e8 0c             	shr    $0xc,%eax
f0107b27:	a3 78 08 6c f0       	mov    %eax,0xf06c0878

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b2f:	c1 e8 0a             	shr    $0xa,%eax
f0107b32:	83 ec 08             	sub    $0x8,%esp
f0107b35:	50                   	push   %eax
f0107b36:	68 f0 58 12 f0       	push   $0xf01258f0
f0107b3b:	e8 4b 94 ff ff       	call   f0100f8b <cprintf>
f0107b40:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107b43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b46:	c1 e8 0a             	shr    $0xa,%eax
f0107b49:	89 c2                	mov    %eax,%edx
f0107b4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107b4e:	c1 e8 0a             	shr    $0xa,%eax
f0107b51:	83 ec 04             	sub    $0x4,%esp
f0107b54:	52                   	push   %edx
f0107b55:	50                   	push   %eax
f0107b56:	68 13 59 12 f0       	push   $0xf0125913
f0107b5b:	e8 2b 94 ff ff       	call   f0100f8b <cprintf>
f0107b60:	83 c4 10             	add    $0x10,%esp
}
f0107b63:	90                   	nop
f0107b64:	c9                   	leave  
f0107b65:	c3                   	ret    

f0107b66 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107b66:	55                   	push   %ebp
f0107b67:	89 e5                	mov    %esp,%ebp
f0107b69:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107b6c:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107b73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b7a:	eb 24                	jmp    f0107ba0 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107b7c:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0107b81:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107b84:	c1 e2 02             	shl    $0x2,%edx
f0107b87:	01 c2                	add    %eax,%edx
f0107b89:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0107b8e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107b91:	c1 e1 02             	shl    $0x2,%ecx
f0107b94:	01 c8                	add    %ecx,%eax
f0107b96:	8b 00                	mov    (%eax),%eax
f0107b98:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b9a:	ff 45 f4             	incl   -0xc(%ebp)
f0107b9d:	ff 45 f0             	incl   -0x10(%ebp)
f0107ba0:	a1 98 0c 6c f0       	mov    0xf06c0c98,%eax
f0107ba5:	c1 e8 16             	shr    $0x16,%eax
f0107ba8:	89 c2                	mov    %eax,%edx
f0107baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bad:	39 c2                	cmp    %eax,%edx
f0107baf:	77 cb                	ja     f0107b7c <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107bb1:	a1 c4 0d 6c f0       	mov    0xf06c0dc4,%eax
f0107bb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107bb9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107bbc:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107bbf:	0f 20 c0             	mov    %cr0,%eax
f0107bc2:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107bc5:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107bc8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107bcb:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107bd2:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107bd6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107bd9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107bdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107bdf:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107be2:	e8 e8 f5 ff ff       	call   f01071cf <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107be7:	e8 20 f5 ff ff       	call   f010710c <mycpu>
f0107bec:	83 c0 74             	add    $0x74,%eax
f0107bef:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107bf2:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107bf9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107bfc:	48                   	dec    %eax
f0107bfd:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107c01:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c04:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107c08:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c0b:	c1 e8 10             	shr    $0x10,%eax
f0107c0e:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107c12:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107c15:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107c18:	e8 04 f6 ff ff       	call   f0107221 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107c1d:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c22:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107c24:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c29:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107c2b:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c30:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107c32:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c37:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107c39:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c3e:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107c40:	ea 47 7c 10 f0 08 00 	ljmp   $0x8,$0xf0107c47
	asm volatile("lldt %%ax" :: "a" (0));
f0107c47:	b8 00 00 00 00       	mov    $0x0,%eax
f0107c4c:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107c4f:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107c56:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c5d:	eb 19                	jmp    f0107c78 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107c5f:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0107c64:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107c67:	c1 e2 02             	shl    $0x2,%edx
f0107c6a:	01 d0                	add    %edx,%eax
f0107c6c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c72:	ff 45 ec             	incl   -0x14(%ebp)
f0107c75:	ff 45 e8             	incl   -0x18(%ebp)
f0107c78:	a1 98 0c 6c f0       	mov    0xf06c0c98,%eax
f0107c7d:	c1 e8 16             	shr    $0x16,%eax
f0107c80:	89 c2                	mov    %eax,%edx
f0107c82:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c85:	39 c2                	cmp    %eax,%edx
f0107c87:	77 d6                	ja     f0107c5f <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107c89:	a1 c4 0d 6c f0       	mov    0xf06c0dc4,%eax
f0107c8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107c91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107c94:	0f 22 d8             	mov    %eax,%cr3

}
f0107c97:	90                   	nop
f0107c98:	c9                   	leave  
f0107c99:	c3                   	ret    

f0107c9a <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107c9a:	55                   	push   %ebp
f0107c9b:	89 e5                	mov    %esp,%ebp
f0107c9d:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107ca0:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0107ca5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107ca8:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107caf:	77 17                	ja     f0107cc8 <setup_listing_to_all_page_tables_entries+0x2e>
f0107cb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0107cb4:	68 44 58 12 f0       	push   $0xf0125844
f0107cb9:	68 cf 01 00 00       	push   $0x1cf
f0107cbe:	68 78 58 12 f0       	push   $0xf0125878
f0107cc3:	e8 71 86 ff ff       	call   f0100339 <_panic>
f0107cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ccb:	05 00 00 00 10       	add    $0x10000000,%eax
f0107cd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107cd3:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0107cd8:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107cdd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107ce0:	83 ca 03             	or     $0x3,%edx
f0107ce3:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107ce5:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0107cea:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107cf0:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0107cf5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107cf8:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107cff:	77 17                	ja     f0107d18 <setup_listing_to_all_page_tables_entries+0x7e>
f0107d01:	ff 75 ec             	pushl  -0x14(%ebp)
f0107d04:	68 44 58 12 f0       	push   $0xf0125844
f0107d09:	68 d4 01 00 00       	push   $0x1d4
f0107d0e:	68 78 58 12 f0       	push   $0xf0125878
f0107d13:	e8 21 86 ff ff       	call   f0100339 <_panic>
f0107d18:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107d1b:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d20:	83 c8 05             	or     $0x5,%eax
f0107d23:	89 02                	mov    %eax,(%edx)

}
f0107d25:	90                   	nop
f0107d26:	c9                   	leave  
f0107d27:	c3                   	ret    

f0107d28 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107d28:	55                   	push   %ebp
f0107d29:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107d2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d2e:	8b 15 e0 0a 6c f0    	mov    0xf06c0ae0,%edx
f0107d34:	29 d0                	sub    %edx,%eax
f0107d36:	c1 f8 03             	sar    $0x3,%eax
f0107d39:	89 c2                	mov    %eax,%edx
f0107d3b:	89 d0                	mov    %edx,%eax
f0107d3d:	c1 e0 02             	shl    $0x2,%eax
f0107d40:	01 d0                	add    %edx,%eax
f0107d42:	c1 e0 02             	shl    $0x2,%eax
f0107d45:	01 d0                	add    %edx,%eax
f0107d47:	c1 e0 02             	shl    $0x2,%eax
f0107d4a:	01 d0                	add    %edx,%eax
f0107d4c:	89 c1                	mov    %eax,%ecx
f0107d4e:	c1 e1 08             	shl    $0x8,%ecx
f0107d51:	01 c8                	add    %ecx,%eax
f0107d53:	89 c1                	mov    %eax,%ecx
f0107d55:	c1 e1 10             	shl    $0x10,%ecx
f0107d58:	01 c8                	add    %ecx,%eax
f0107d5a:	01 c0                	add    %eax,%eax
f0107d5c:	01 d0                	add    %edx,%eax
}
f0107d5e:	5d                   	pop    %ebp
f0107d5f:	c3                   	ret    

f0107d60 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107d60:	55                   	push   %ebp
f0107d61:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107d63:	ff 75 08             	pushl  0x8(%ebp)
f0107d66:	e8 bd ff ff ff       	call   f0107d28 <to_frame_number>
f0107d6b:	83 c4 04             	add    $0x4,%esp
f0107d6e:	c1 e0 0c             	shl    $0xc,%eax
}
f0107d71:	c9                   	leave  
f0107d72:	c3                   	ret    

f0107d73 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107d73:	55                   	push   %ebp
f0107d74:	89 e5                	mov    %esp,%ebp
f0107d76:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107d79:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d7c:	c1 e8 0c             	shr    $0xc,%eax
f0107d7f:	89 c2                	mov    %eax,%edx
f0107d81:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f0107d86:	39 c2                	cmp    %eax,%edx
f0107d88:	72 14                	jb     f0107d9e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107d8a:	83 ec 04             	sub    $0x4,%esp
f0107d8d:	68 30 59 12 f0       	push   $0xf0125930
f0107d92:	6a 56                	push   $0x56
f0107d94:	68 55 59 12 f0       	push   $0xf0125955
f0107d99:	e8 9b 85 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0107d9e:	8b 15 e0 0a 6c f0    	mov    0xf06c0ae0,%edx
f0107da4:	8b 45 08             	mov    0x8(%ebp),%eax
f0107da7:	c1 e8 0c             	shr    $0xc,%eax
f0107daa:	89 c1                	mov    %eax,%ecx
f0107dac:	89 c8                	mov    %ecx,%eax
f0107dae:	01 c0                	add    %eax,%eax
f0107db0:	01 c8                	add    %ecx,%eax
f0107db2:	c1 e0 03             	shl    $0x3,%eax
f0107db5:	01 d0                	add    %edx,%eax
}
f0107db7:	c9                   	leave  
f0107db8:	c3                   	ret    

f0107db9 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107db9:	55                   	push   %ebp
f0107dba:	89 e5                	mov    %esp,%ebp
f0107dbc:	83 ec 10             	sub    $0x10,%esp
f0107dbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107dc2:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107dc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107dc8:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107dcb:	90                   	nop
f0107dcc:	c9                   	leave  
f0107dcd:	c3                   	ret    

f0107dce <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107dce:	55                   	push   %ebp
f0107dcf:	89 e5                	mov    %esp,%ebp
f0107dd1:	53                   	push   %ebx
f0107dd2:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107dd5:	c7 05 80 06 6c f0 00 	movl   $0x0,0xf06c0680
f0107ddc:	00 00 00 
f0107ddf:	c7 05 84 06 6c f0 00 	movl   $0x0,0xf06c0684
f0107de6:	00 00 00 
f0107de9:	c7 05 8c 06 6c f0 00 	movl   $0x0,0xf06c068c
f0107df0:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107df3:	c7 05 90 06 6c f0 00 	movl   $0x0,0xf06c0690
f0107dfa:	00 00 00 
f0107dfd:	c7 05 94 06 6c f0 00 	movl   $0x0,0xf06c0694
f0107e04:	00 00 00 
f0107e07:	c7 05 9c 06 6c f0 00 	movl   $0x0,0xf06c069c
f0107e0e:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107e11:	83 ec 08             	sub    $0x8,%esp
f0107e14:	68 6f 59 12 f0       	push   $0xf012596f
f0107e19:	68 a0 06 6c f0       	push   $0xf06c06a0
f0107e1e:	e8 c6 7d 00 00       	call   f010fbe9 <init_spinlock>
f0107e23:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107e26:	a1 e0 0a 6c f0       	mov    0xf06c0ae0,%eax
f0107e2b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107e31:	a1 e0 0a 6c f0       	mov    0xf06c0ae0,%eax
f0107e36:	83 c0 18             	add    $0x18,%eax
f0107e39:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107e3f:	a1 e0 0a 6c f0       	mov    0xf06c0ae0,%eax
f0107e44:	83 c0 30             	add    $0x30,%eax
f0107e47:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107e4d:	c7 05 7c 0b 6c f0 00 	movl   $0xf0001000,0xf06c0b7c
f0107e54:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107e57:	c7 05 2c 0d 6c f0 00 	movl   $0xf0002000,0xf06c0d2c
f0107e5e:	20 00 f0 
	i =0;
f0107e61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107e68:	eb 1f                	jmp    f0107e89 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107e6a:	8b 15 7c 0b 6c f0    	mov    0xf06c0b7c,%edx
f0107e70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e73:	01 d0                	add    %edx,%eax
f0107e75:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107e78:	8b 15 2c 0d 6c f0    	mov    0xf06c0d2c,%edx
f0107e7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e81:	01 d0                	add    %edx,%eax
f0107e83:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107e86:	ff 45 f4             	incl   -0xc(%ebp)
f0107e89:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107e90:	7e d8                	jle    f0107e6a <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107e92:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107e99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e9c:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107ea1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107ea4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ea7:	ba 00 00 00 00       	mov    $0x0,%edx
f0107eac:	f7 75 f0             	divl   -0x10(%ebp)
f0107eaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107eb2:	29 d0                	sub    %edx,%eax
f0107eb4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107eb7:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107ebe:	e9 e8 00 00 00       	jmp    f0107fab <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107ec3:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f0107ec9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ecc:	89 d0                	mov    %edx,%eax
f0107ece:	01 c0                	add    %eax,%eax
f0107ed0:	01 d0                	add    %edx,%eax
f0107ed2:	c1 e0 03             	shl    $0x3,%eax
f0107ed5:	01 c8                	add    %ecx,%eax
f0107ed7:	83 ec 0c             	sub    $0xc,%esp
f0107eda:	50                   	push   %eax
f0107edb:	e8 b7 02 00 00       	call   f0108197 <initialize_frame_info>
f0107ee0:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107ee3:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f0107ee9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107eec:	89 d0                	mov    %edx,%eax
f0107eee:	01 c0                	add    %eax,%eax
f0107ef0:	01 d0                	add    %edx,%eax
f0107ef2:	c1 e0 03             	shl    $0x3,%eax
f0107ef5:	01 c8                	add    %ecx,%eax
f0107ef7:	85 c0                	test   %eax,%eax
f0107ef9:	75 14                	jne    f0107f0f <initialize_paging+0x141>
f0107efb:	83 ec 04             	sub    $0x4,%esp
f0107efe:	68 80 59 12 f0       	push   $0xf0125980
f0107f03:	6a 60                	push   $0x60
f0107f05:	68 a3 59 12 f0       	push   $0xf01259a3
f0107f0a:	e8 2a 84 ff ff       	call   f0100339 <_panic>
f0107f0f:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f0107f15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f18:	89 d0                	mov    %edx,%eax
f0107f1a:	01 c0                	add    %eax,%eax
f0107f1c:	01 d0                	add    %edx,%eax
f0107f1e:	c1 e0 03             	shl    $0x3,%eax
f0107f21:	01 c8                	add    %ecx,%eax
f0107f23:	8b 15 80 06 6c f0    	mov    0xf06c0680,%edx
f0107f29:	89 10                	mov    %edx,(%eax)
f0107f2b:	8b 00                	mov    (%eax),%eax
f0107f2d:	85 c0                	test   %eax,%eax
f0107f2f:	74 1f                	je     f0107f50 <initialize_paging+0x182>
f0107f31:	8b 15 80 06 6c f0    	mov    0xf06c0680,%edx
f0107f37:	8b 1d e0 0a 6c f0    	mov    0xf06c0ae0,%ebx
f0107f3d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107f40:	89 c8                	mov    %ecx,%eax
f0107f42:	01 c0                	add    %eax,%eax
f0107f44:	01 c8                	add    %ecx,%eax
f0107f46:	c1 e0 03             	shl    $0x3,%eax
f0107f49:	01 d8                	add    %ebx,%eax
f0107f4b:	89 42 04             	mov    %eax,0x4(%edx)
f0107f4e:	eb 19                	jmp    f0107f69 <initialize_paging+0x19b>
f0107f50:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f0107f56:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f59:	89 d0                	mov    %edx,%eax
f0107f5b:	01 c0                	add    %eax,%eax
f0107f5d:	01 d0                	add    %edx,%eax
f0107f5f:	c1 e0 03             	shl    $0x3,%eax
f0107f62:	01 c8                	add    %ecx,%eax
f0107f64:	a3 84 06 6c f0       	mov    %eax,0xf06c0684
f0107f69:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f0107f6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f72:	89 d0                	mov    %edx,%eax
f0107f74:	01 c0                	add    %eax,%eax
f0107f76:	01 d0                	add    %edx,%eax
f0107f78:	c1 e0 03             	shl    $0x3,%eax
f0107f7b:	01 c8                	add    %ecx,%eax
f0107f7d:	a3 80 06 6c f0       	mov    %eax,0xf06c0680
f0107f82:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f0107f88:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f8b:	89 d0                	mov    %edx,%eax
f0107f8d:	01 c0                	add    %eax,%eax
f0107f8f:	01 d0                	add    %edx,%eax
f0107f91:	c1 e0 03             	shl    $0x3,%eax
f0107f94:	01 c8                	add    %ecx,%eax
f0107f96:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107f9d:	a1 8c 06 6c f0       	mov    0xf06c068c,%eax
f0107fa2:	40                   	inc    %eax
f0107fa3:	a3 8c 06 6c f0       	mov    %eax,0xf06c068c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107fa8:	ff 45 f4             	incl   -0xc(%ebp)
f0107fab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107fae:	85 c0                	test   %eax,%eax
f0107fb0:	79 05                	jns    f0107fb7 <initialize_paging+0x1e9>
f0107fb2:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107fb7:	c1 f8 0c             	sar    $0xc,%eax
f0107fba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107fbd:	0f 8f 00 ff ff ff    	jg     f0107ec3 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fc3:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107fca:	eb 1d                	jmp    f0107fe9 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107fcc:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f0107fd2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fd5:	89 d0                	mov    %edx,%eax
f0107fd7:	01 c0                	add    %eax,%eax
f0107fd9:	01 d0                	add    %edx,%eax
f0107fdb:	c1 e0 03             	shl    $0x3,%eax
f0107fde:	01 c8                	add    %ecx,%eax
f0107fe0:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fe6:	ff 45 f4             	incl   -0xc(%ebp)
f0107fe9:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107ff0:	7e da                	jle    f0107fcc <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107ff2:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107ff9:	a1 98 0c 6c f0       	mov    0xf06c0c98,%eax
f0107ffe:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108001:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108008:	77 14                	ja     f010801e <initialize_paging+0x250>
f010800a:	ff 75 e0             	pushl  -0x20(%ebp)
f010800d:	68 c0 59 12 f0       	push   $0xf01259c0
f0108012:	6a 68                	push   $0x68
f0108014:	68 a3 59 12 f0       	push   $0xf01259a3
f0108019:	e8 1b 83 ff ff       	call   f0100339 <_panic>
f010801e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108021:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108027:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010802a:	01 d0                	add    %edx,%eax
f010802c:	48                   	dec    %eax
f010802d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108030:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108033:	ba 00 00 00 00       	mov    $0x0,%edx
f0108038:	f7 75 e4             	divl   -0x1c(%ebp)
f010803b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010803e:	29 d0                	sub    %edx,%eax
f0108040:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108043:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f010804a:	eb 1d                	jmp    f0108069 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f010804c:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f0108052:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108055:	89 d0                	mov    %edx,%eax
f0108057:	01 c0                	add    %eax,%eax
f0108059:	01 d0                	add    %edx,%eax
f010805b:	c1 e0 03             	shl    $0x3,%eax
f010805e:	01 c8                	add    %ecx,%eax
f0108060:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108066:	ff 45 f4             	incl   -0xc(%ebp)
f0108069:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010806c:	85 c0                	test   %eax,%eax
f010806e:	79 05                	jns    f0108075 <initialize_paging+0x2a7>
f0108070:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108075:	c1 f8 0c             	sar    $0xc,%eax
f0108078:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010807b:	7f cf                	jg     f010804c <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010807d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108080:	85 c0                	test   %eax,%eax
f0108082:	79 05                	jns    f0108089 <initialize_paging+0x2bb>
f0108084:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108089:	c1 f8 0c             	sar    $0xc,%eax
f010808c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010808f:	e9 e8 00 00 00       	jmp    f010817c <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0108094:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f010809a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010809d:	89 d0                	mov    %edx,%eax
f010809f:	01 c0                	add    %eax,%eax
f01080a1:	01 d0                	add    %edx,%eax
f01080a3:	c1 e0 03             	shl    $0x3,%eax
f01080a6:	01 c8                	add    %ecx,%eax
f01080a8:	83 ec 0c             	sub    $0xc,%esp
f01080ab:	50                   	push   %eax
f01080ac:	e8 e6 00 00 00       	call   f0108197 <initialize_frame_info>
f01080b1:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01080b4:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f01080ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080bd:	89 d0                	mov    %edx,%eax
f01080bf:	01 c0                	add    %eax,%eax
f01080c1:	01 d0                	add    %edx,%eax
f01080c3:	c1 e0 03             	shl    $0x3,%eax
f01080c6:	01 c8                	add    %ecx,%eax
f01080c8:	85 c0                	test   %eax,%eax
f01080ca:	75 14                	jne    f01080e0 <initialize_paging+0x312>
f01080cc:	83 ec 04             	sub    $0x4,%esp
f01080cf:	68 80 59 12 f0       	push   $0xf0125980
f01080d4:	6a 74                	push   $0x74
f01080d6:	68 a3 59 12 f0       	push   $0xf01259a3
f01080db:	e8 59 82 ff ff       	call   f0100339 <_panic>
f01080e0:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f01080e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080e9:	89 d0                	mov    %edx,%eax
f01080eb:	01 c0                	add    %eax,%eax
f01080ed:	01 d0                	add    %edx,%eax
f01080ef:	c1 e0 03             	shl    $0x3,%eax
f01080f2:	01 c8                	add    %ecx,%eax
f01080f4:	8b 15 80 06 6c f0    	mov    0xf06c0680,%edx
f01080fa:	89 10                	mov    %edx,(%eax)
f01080fc:	8b 00                	mov    (%eax),%eax
f01080fe:	85 c0                	test   %eax,%eax
f0108100:	74 1f                	je     f0108121 <initialize_paging+0x353>
f0108102:	8b 15 80 06 6c f0    	mov    0xf06c0680,%edx
f0108108:	8b 1d e0 0a 6c f0    	mov    0xf06c0ae0,%ebx
f010810e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108111:	89 c8                	mov    %ecx,%eax
f0108113:	01 c0                	add    %eax,%eax
f0108115:	01 c8                	add    %ecx,%eax
f0108117:	c1 e0 03             	shl    $0x3,%eax
f010811a:	01 d8                	add    %ebx,%eax
f010811c:	89 42 04             	mov    %eax,0x4(%edx)
f010811f:	eb 19                	jmp    f010813a <initialize_paging+0x36c>
f0108121:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f0108127:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010812a:	89 d0                	mov    %edx,%eax
f010812c:	01 c0                	add    %eax,%eax
f010812e:	01 d0                	add    %edx,%eax
f0108130:	c1 e0 03             	shl    $0x3,%eax
f0108133:	01 c8                	add    %ecx,%eax
f0108135:	a3 84 06 6c f0       	mov    %eax,0xf06c0684
f010813a:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f0108140:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108143:	89 d0                	mov    %edx,%eax
f0108145:	01 c0                	add    %eax,%eax
f0108147:	01 d0                	add    %edx,%eax
f0108149:	c1 e0 03             	shl    $0x3,%eax
f010814c:	01 c8                	add    %ecx,%eax
f010814e:	a3 80 06 6c f0       	mov    %eax,0xf06c0680
f0108153:	8b 0d e0 0a 6c f0    	mov    0xf06c0ae0,%ecx
f0108159:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010815c:	89 d0                	mov    %edx,%eax
f010815e:	01 c0                	add    %eax,%eax
f0108160:	01 d0                	add    %edx,%eax
f0108162:	c1 e0 03             	shl    $0x3,%eax
f0108165:	01 c8                	add    %ecx,%eax
f0108167:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010816e:	a1 8c 06 6c f0       	mov    0xf06c068c,%eax
f0108173:	40                   	inc    %eax
f0108174:	a3 8c 06 6c f0       	mov    %eax,0xf06c068c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108179:	ff 45 f4             	incl   -0xc(%ebp)
f010817c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010817f:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f0108184:	39 c2                	cmp    %eax,%edx
f0108186:	0f 82 08 ff ff ff    	jb     f0108094 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010818c:	e8 00 bb ff ff       	call   f0103c91 <initialize_disk_page_file>
}
f0108191:	90                   	nop
f0108192:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108195:	c9                   	leave  
f0108196:	c3                   	ret    

f0108197 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0108197:	55                   	push   %ebp
f0108198:	89 e5                	mov    %esp,%ebp
f010819a:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f010819d:	83 ec 04             	sub    $0x4,%esp
f01081a0:	6a 18                	push   $0x18
f01081a2:	6a 00                	push   $0x0
f01081a4:	ff 75 08             	pushl  0x8(%ebp)
f01081a7:	e8 0a 7c 01 00       	call   f011fdb6 <memset>
f01081ac:	83 c4 10             	add    $0x10,%esp
}
f01081af:	90                   	nop
f01081b0:	c9                   	leave  
f01081b1:	c3                   	ret    

f01081b2 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01081b2:	55                   	push   %ebp
f01081b3:	89 e5                	mov    %esp,%ebp
f01081b5:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01081b8:	83 ec 0c             	sub    $0xc,%esp
f01081bb:	68 a0 06 6c f0       	push   $0xf06c06a0
f01081c0:	e8 6e 7c 00 00       	call   f010fe33 <holding_spinlock>
f01081c5:	83 c4 10             	add    $0x10,%esp
f01081c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01081cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01081cf:	75 10                	jne    f01081e1 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01081d1:	83 ec 0c             	sub    $0xc,%esp
f01081d4:	68 a0 06 6c f0       	push   $0xf06c06a0
f01081d9:	e8 3c 7a 00 00       	call   f010fc1a <acquire_spinlock>
f01081de:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f01081e1:	8b 15 80 06 6c f0    	mov    0xf06c0680,%edx
f01081e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01081ea:	89 10                	mov    %edx,(%eax)
	int c = 0;
f01081ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f01081f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01081f6:	8b 00                	mov    (%eax),%eax
f01081f8:	85 c0                	test   %eax,%eax
f01081fa:	75 17                	jne    f0108213 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f01081fc:	83 ec 04             	sub    $0x4,%esp
f01081ff:	68 f4 59 12 f0       	push   $0xf01259f4
f0108204:	68 a2 00 00 00       	push   $0xa2
f0108209:	68 a3 59 12 f0       	push   $0xf01259a3
f010820e:	e8 26 81 ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0108213:	8b 45 08             	mov    0x8(%ebp),%eax
f0108216:	8b 00                	mov    (%eax),%eax
f0108218:	85 c0                	test   %eax,%eax
f010821a:	75 17                	jne    f0108233 <allocate_frame+0x81>
f010821c:	83 ec 04             	sub    $0x4,%esp
f010821f:	68 41 5a 12 f0       	push   $0xf0125a41
f0108224:	68 a8 00 00 00       	push   $0xa8
f0108229:	68 a3 59 12 f0       	push   $0xf01259a3
f010822e:	e8 06 81 ff ff       	call   f0100339 <_panic>
f0108233:	8b 45 08             	mov    0x8(%ebp),%eax
f0108236:	8b 00                	mov    (%eax),%eax
f0108238:	8b 00                	mov    (%eax),%eax
f010823a:	85 c0                	test   %eax,%eax
f010823c:	74 14                	je     f0108252 <allocate_frame+0xa0>
f010823e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108241:	8b 00                	mov    (%eax),%eax
f0108243:	8b 00                	mov    (%eax),%eax
f0108245:	8b 55 08             	mov    0x8(%ebp),%edx
f0108248:	8b 12                	mov    (%edx),%edx
f010824a:	8b 52 04             	mov    0x4(%edx),%edx
f010824d:	89 50 04             	mov    %edx,0x4(%eax)
f0108250:	eb 0d                	jmp    f010825f <allocate_frame+0xad>
f0108252:	8b 45 08             	mov    0x8(%ebp),%eax
f0108255:	8b 00                	mov    (%eax),%eax
f0108257:	8b 40 04             	mov    0x4(%eax),%eax
f010825a:	a3 84 06 6c f0       	mov    %eax,0xf06c0684
f010825f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108262:	8b 00                	mov    (%eax),%eax
f0108264:	8b 40 04             	mov    0x4(%eax),%eax
f0108267:	85 c0                	test   %eax,%eax
f0108269:	74 13                	je     f010827e <allocate_frame+0xcc>
f010826b:	8b 45 08             	mov    0x8(%ebp),%eax
f010826e:	8b 00                	mov    (%eax),%eax
f0108270:	8b 40 04             	mov    0x4(%eax),%eax
f0108273:	8b 55 08             	mov    0x8(%ebp),%edx
f0108276:	8b 12                	mov    (%edx),%edx
f0108278:	8b 12                	mov    (%edx),%edx
f010827a:	89 10                	mov    %edx,(%eax)
f010827c:	eb 0c                	jmp    f010828a <allocate_frame+0xd8>
f010827e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108281:	8b 00                	mov    (%eax),%eax
f0108283:	8b 00                	mov    (%eax),%eax
f0108285:	a3 80 06 6c f0       	mov    %eax,0xf06c0680
f010828a:	8b 45 08             	mov    0x8(%ebp),%eax
f010828d:	8b 00                	mov    (%eax),%eax
f010828f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108295:	8b 45 08             	mov    0x8(%ebp),%eax
f0108298:	8b 00                	mov    (%eax),%eax
f010829a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01082a1:	a1 8c 06 6c f0       	mov    0xf06c068c,%eax
f01082a6:	48                   	dec    %eax
f01082a7:	a3 8c 06 6c f0       	mov    %eax,0xf06c068c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f01082ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01082af:	8b 00                	mov    (%eax),%eax
f01082b1:	8a 40 14             	mov    0x14(%eax),%al
f01082b4:	84 c0                	test   %al,%al
f01082b6:	74 20                	je     f01082d8 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01082b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082bb:	8b 00                	mov    (%eax),%eax
f01082bd:	8b 50 10             	mov    0x10(%eax),%edx
f01082c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01082c3:	8b 00                	mov    (%eax),%eax
f01082c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01082c8:	8b 40 64             	mov    0x64(%eax),%eax
f01082cb:	83 ec 08             	sub    $0x8,%esp
f01082ce:	52                   	push   %edx
f01082cf:	50                   	push   %eax
f01082d0:	e8 03 1a 00 00       	call   f0109cd8 <pt_clear_page_table_entry>
f01082d5:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f01082d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082db:	8b 00                	mov    (%eax),%eax
f01082dd:	83 ec 0c             	sub    $0xc,%esp
f01082e0:	50                   	push   %eax
f01082e1:	e8 b1 fe ff ff       	call   f0108197 <initialize_frame_info>
f01082e6:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f01082e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01082ed:	75 10                	jne    f01082ff <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01082ef:	83 ec 0c             	sub    $0xc,%esp
f01082f2:	68 a0 06 6c f0       	push   $0xf06c06a0
f01082f7:	e8 a5 79 00 00       	call   f010fca1 <release_spinlock>
f01082fc:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f01082ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108304:	c9                   	leave  
f0108305:	c3                   	ret    

f0108306 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108306:	55                   	push   %ebp
f0108307:	89 e5                	mov    %esp,%ebp
f0108309:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f010830c:	83 ec 0c             	sub    $0xc,%esp
f010830f:	68 a0 06 6c f0       	push   $0xf06c06a0
f0108314:	e8 1a 7b 00 00       	call   f010fe33 <holding_spinlock>
f0108319:	83 c4 10             	add    $0x10,%esp
f010831c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010831f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108323:	75 10                	jne    f0108335 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108325:	83 ec 0c             	sub    $0xc,%esp
f0108328:	68 a0 06 6c f0       	push   $0xf06c06a0
f010832d:	e8 e8 78 00 00       	call   f010fc1a <acquire_spinlock>
f0108332:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108335:	83 ec 0c             	sub    $0xc,%esp
f0108338:	ff 75 08             	pushl  0x8(%ebp)
f010833b:	e8 57 fe ff ff       	call   f0108197 <initialize_frame_info>
f0108340:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108343:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108347:	75 17                	jne    f0108360 <free_frame+0x5a>
f0108349:	83 ec 04             	sub    $0x4,%esp
f010834c:	68 80 59 12 f0       	push   $0xf0125980
f0108351:	68 cf 00 00 00       	push   $0xcf
f0108356:	68 a3 59 12 f0       	push   $0xf01259a3
f010835b:	e8 d9 7f ff ff       	call   f0100339 <_panic>
f0108360:	8b 15 80 06 6c f0    	mov    0xf06c0680,%edx
f0108366:	8b 45 08             	mov    0x8(%ebp),%eax
f0108369:	89 10                	mov    %edx,(%eax)
f010836b:	8b 45 08             	mov    0x8(%ebp),%eax
f010836e:	8b 00                	mov    (%eax),%eax
f0108370:	85 c0                	test   %eax,%eax
f0108372:	74 0d                	je     f0108381 <free_frame+0x7b>
f0108374:	a1 80 06 6c f0       	mov    0xf06c0680,%eax
f0108379:	8b 55 08             	mov    0x8(%ebp),%edx
f010837c:	89 50 04             	mov    %edx,0x4(%eax)
f010837f:	eb 08                	jmp    f0108389 <free_frame+0x83>
f0108381:	8b 45 08             	mov    0x8(%ebp),%eax
f0108384:	a3 84 06 6c f0       	mov    %eax,0xf06c0684
f0108389:	8b 45 08             	mov    0x8(%ebp),%eax
f010838c:	a3 80 06 6c f0       	mov    %eax,0xf06c0680
f0108391:	8b 45 08             	mov    0x8(%ebp),%eax
f0108394:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010839b:	a1 8c 06 6c f0       	mov    0xf06c068c,%eax
f01083a0:	40                   	inc    %eax
f01083a1:	a3 8c 06 6c f0       	mov    %eax,0xf06c068c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01083a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01083aa:	75 10                	jne    f01083bc <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01083ac:	83 ec 0c             	sub    $0xc,%esp
f01083af:	68 a0 06 6c f0       	push   $0xf06c06a0
f01083b4:	e8 e8 78 00 00       	call   f010fca1 <release_spinlock>
f01083b9:	83 c4 10             	add    $0x10,%esp
	}
}
f01083bc:	90                   	nop
f01083bd:	c9                   	leave  
f01083be:	c3                   	ret    

f01083bf <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01083bf:	55                   	push   %ebp
f01083c0:	89 e5                	mov    %esp,%ebp
f01083c2:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01083c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01083c8:	8b 40 08             	mov    0x8(%eax),%eax
f01083cb:	48                   	dec    %eax
f01083cc:	8b 55 08             	mov    0x8(%ebp),%edx
f01083cf:	66 89 42 08          	mov    %ax,0x8(%edx)
f01083d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01083d6:	8b 40 08             	mov    0x8(%eax),%eax
f01083d9:	66 85 c0             	test   %ax,%ax
f01083dc:	75 0e                	jne    f01083ec <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f01083de:	83 ec 0c             	sub    $0xc,%esp
f01083e1:	ff 75 08             	pushl  0x8(%ebp)
f01083e4:	e8 1d ff ff ff       	call   f0108306 <free_frame>
f01083e9:	83 c4 10             	add    $0x10,%esp
}
f01083ec:	90                   	nop
f01083ed:	c9                   	leave  
f01083ee:	c3                   	ret    

f01083ef <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01083ef:	55                   	push   %ebp
f01083f0:	89 e5                	mov    %esp,%ebp
f01083f2:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01083f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01083f8:	c1 e8 16             	shr    $0x16,%eax
f01083fb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108402:	8b 45 08             	mov    0x8(%ebp),%eax
f0108405:	01 d0                	add    %edx,%eax
f0108407:	8b 00                	mov    (%eax),%eax
f0108409:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f010840c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010840f:	83 e0 01             	and    $0x1,%eax
f0108412:	85 c0                	test   %eax,%eax
f0108414:	74 74                	je     f010848a <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108416:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010841d:	77 1d                	ja     f010843c <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010841f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108422:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108427:	83 ec 0c             	sub    $0xc,%esp
f010842a:	50                   	push   %eax
f010842b:	e8 04 14 00 00       	call   f0109834 <kheap_virtual_address>
f0108430:	83 c4 10             	add    $0x10,%esp
f0108433:	89 c2                	mov    %eax,%edx
f0108435:	8b 45 10             	mov    0x10(%ebp),%eax
f0108438:	89 10                	mov    %edx,(%eax)
f010843a:	eb 44                	jmp    f0108480 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010843c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010843f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108444:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108447:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010844a:	c1 e8 0c             	shr    $0xc,%eax
f010844d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108450:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f0108455:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108458:	72 17                	jb     f0108471 <get_page_table+0x82>
f010845a:	ff 75 f0             	pushl  -0x10(%ebp)
f010845d:	68 60 5a 12 f0       	push   $0xf0125a60
f0108462:	68 fb 00 00 00       	push   $0xfb
f0108467:	68 a3 59 12 f0       	push   $0xf01259a3
f010846c:	e8 c8 7e ff ff       	call   f0100339 <_panic>
f0108471:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108474:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108479:	89 c2                	mov    %eax,%edx
f010847b:	8b 45 10             	mov    0x10(%ebp),%eax
f010847e:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108480:	b8 00 00 00 00       	mov    $0x0,%eax
f0108485:	e9 b9 00 00 00       	jmp    f0108543 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f010848a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010848e:	0f 84 a1 00 00 00    	je     f0108535 <get_page_table+0x146>
f0108494:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108497:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010849a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010849d:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f01084a0:	83 ec 0c             	sub    $0xc,%esp
f01084a3:	6a 00                	push   $0x0
f01084a5:	e8 02 72 00 00       	call   f010f6ac <fault_handler>
f01084aa:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01084ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084b0:	c1 e8 16             	shr    $0x16,%eax
f01084b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01084ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01084bd:	01 d0                	add    %edx,%eax
f01084bf:	8b 00                	mov    (%eax),%eax
f01084c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01084c4:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01084cb:	77 1d                	ja     f01084ea <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084d0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084d5:	83 ec 0c             	sub    $0xc,%esp
f01084d8:	50                   	push   %eax
f01084d9:	e8 56 13 00 00       	call   f0109834 <kheap_virtual_address>
f01084de:	83 c4 10             	add    $0x10,%esp
f01084e1:	89 c2                	mov    %eax,%edx
f01084e3:	8b 45 10             	mov    0x10(%ebp),%eax
f01084e6:	89 10                	mov    %edx,(%eax)
f01084e8:	eb 44                	jmp    f010852e <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084ed:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01084f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084f8:	c1 e8 0c             	shr    $0xc,%eax
f01084fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01084fe:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f0108503:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108506:	72 17                	jb     f010851f <get_page_table+0x130>
f0108508:	ff 75 e8             	pushl  -0x18(%ebp)
f010850b:	68 60 5a 12 f0       	push   $0xf0125a60
f0108510:	68 13 01 00 00       	push   $0x113
f0108515:	68 a3 59 12 f0       	push   $0xf01259a3
f010851a:	e8 1a 7e ff ff       	call   f0100339 <_panic>
f010851f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108522:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108527:	89 c2                	mov    %eax,%edx
f0108529:	8b 45 10             	mov    0x10(%ebp),%eax
f010852c:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f010852e:	b8 00 00 00 00       	mov    $0x0,%eax
f0108533:	eb 0e                	jmp    f0108543 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108535:	8b 45 10             	mov    0x10(%ebp),%eax
f0108538:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f010853e:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0108543:	c9                   	leave  
f0108544:	c3                   	ret    

f0108545 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108545:	55                   	push   %ebp
f0108546:	89 e5                	mov    %esp,%ebp
f0108548:	53                   	push   %ebx
f0108549:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f010854c:	83 ec 0c             	sub    $0xc,%esp
f010854f:	68 00 10 00 00       	push   $0x1000
f0108554:	e8 38 0f 00 00       	call   f0109491 <kmalloc>
f0108559:	83 c4 10             	add    $0x10,%esp
f010855c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f010855f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108563:	75 17                	jne    f010857c <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108565:	83 ec 04             	sub    $0x4,%esp
f0108568:	68 8f 5a 12 f0       	push   $0xf0125a8f
f010856d:	68 33 01 00 00       	push   $0x133
f0108572:	68 a3 59 12 f0       	push   $0xf01259a3
f0108577:	e8 bd 7d ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010857c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010857f:	c1 e8 16             	shr    $0x16,%eax
f0108582:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108589:	8b 45 08             	mov    0x8(%ebp),%eax
f010858c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010858f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108592:	83 ec 0c             	sub    $0xc,%esp
f0108595:	50                   	push   %eax
f0108596:	e8 3c 12 00 00       	call   f01097d7 <kheap_physical_address>
f010859b:	83 c4 10             	add    $0x10,%esp
f010859e:	83 c8 07             	or     $0x7,%eax
f01085a1:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f01085a3:	83 ec 04             	sub    $0x4,%esp
f01085a6:	68 00 10 00 00       	push   $0x1000
f01085ab:	6a 00                	push   $0x0
f01085ad:	ff 75 f4             	pushl  -0xc(%ebp)
f01085b0:	e8 01 78 01 00       	call   f011fdb6 <memset>
f01085b5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01085b8:	0f 20 d8             	mov    %cr3,%eax
f01085bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01085be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085c1:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f01085c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01085c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01085ca:	c9                   	leave  
f01085cb:	c3                   	ret    

f01085cc <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01085cc:	55                   	push   %ebp
f01085cd:	89 e5                	mov    %esp,%ebp
f01085cf:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f01085d2:	83 ec 0c             	sub    $0xc,%esp
f01085d5:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01085d8:	50                   	push   %eax
f01085d9:	e8 d4 fb ff ff       	call   f01081b2 <allocate_frame>
f01085de:	83 c4 10             	add    $0x10,%esp
f01085e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f01085e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01085e7:	83 ec 0c             	sub    $0xc,%esp
f01085ea:	50                   	push   %eax
f01085eb:	e8 70 f7 ff ff       	call   f0107d60 <to_physical_address>
f01085f0:	83 c4 10             	add    $0x10,%esp
f01085f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f01085f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01085fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01085ff:	c1 e8 0c             	shr    $0xc,%eax
f0108602:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108605:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f010860a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f010860d:	72 17                	jb     f0108626 <__static_cpt+0x5a>
f010860f:	ff 75 ec             	pushl  -0x14(%ebp)
f0108612:	68 60 5a 12 f0       	push   $0xf0125a60
f0108617:	68 4e 01 00 00       	push   $0x14e
f010861c:	68 a3 59 12 f0       	push   $0xf01259a3
f0108621:	e8 13 7d ff ff       	call   f0100339 <_panic>
f0108626:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108629:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010862e:	89 c2                	mov    %eax,%edx
f0108630:	8b 45 10             	mov    0x10(%ebp),%eax
f0108633:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108635:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108638:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f010863e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108641:	c1 e8 16             	shr    $0x16,%eax
f0108644:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010864b:	8b 45 08             	mov    0x8(%ebp),%eax
f010864e:	01 d0                	add    %edx,%eax
f0108650:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108653:	83 ca 07             	or     $0x7,%edx
f0108656:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108658:	8b 45 10             	mov    0x10(%ebp),%eax
f010865b:	8b 00                	mov    (%eax),%eax
f010865d:	83 ec 04             	sub    $0x4,%esp
f0108660:	68 00 10 00 00       	push   $0x1000
f0108665:	6a 00                	push   $0x0
f0108667:	50                   	push   %eax
f0108668:	e8 49 77 01 00       	call   f011fdb6 <memset>
f010866d:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108670:	0f 20 d8             	mov    %cr3,%eax
f0108673:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108676:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108679:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010867c:	90                   	nop
f010867d:	c9                   	leave  
f010867e:	c3                   	ret    

f010867f <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f010867f:	55                   	push   %ebp
f0108680:	89 e5                	mov    %esp,%ebp
f0108682:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108685:	ff 75 0c             	pushl  0xc(%ebp)
f0108688:	e8 d3 f6 ff ff       	call   f0107d60 <to_physical_address>
f010868d:	83 c4 04             	add    $0x4,%esp
f0108690:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108693:	83 ec 04             	sub    $0x4,%esp
f0108696:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108699:	50                   	push   %eax
f010869a:	ff 75 10             	pushl  0x10(%ebp)
f010869d:	ff 75 08             	pushl  0x8(%ebp)
f01086a0:	e8 4a fd ff ff       	call   f01083ef <get_page_table>
f01086a5:	83 c4 10             	add    $0x10,%esp
f01086a8:	83 f8 01             	cmp    $0x1,%eax
f01086ab:	75 1b                	jne    f01086c8 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f01086ad:	83 ec 08             	sub    $0x8,%esp
f01086b0:	ff 75 10             	pushl  0x10(%ebp)
f01086b3:	ff 75 08             	pushl  0x8(%ebp)
f01086b6:	e8 8a fe ff ff       	call   f0108545 <create_page_table>
f01086bb:	83 c4 10             	add    $0x10,%esp
f01086be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f01086c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f01086c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01086cb:	8b 55 10             	mov    0x10(%ebp),%edx
f01086ce:	c1 ea 0c             	shr    $0xc,%edx
f01086d1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086d7:	c1 e2 02             	shl    $0x2,%edx
f01086da:	01 d0                	add    %edx,%eax
f01086dc:	8b 00                	mov    (%eax),%eax
f01086de:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f01086e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086e4:	83 e0 01             	and    $0x1,%eax
f01086e7:	85 c0                	test   %eax,%eax
f01086e9:	74 25                	je     f0108710 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f01086eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086ee:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01086f3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01086f6:	75 07                	jne    f01086ff <map_frame+0x80>
			return 0;
f01086f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01086fd:	eb 68                	jmp    f0108767 <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f01086ff:	83 ec 08             	sub    $0x8,%esp
f0108702:	ff 75 10             	pushl  0x10(%ebp)
f0108705:	ff 75 08             	pushl  0x8(%ebp)
f0108708:	e8 d2 00 00 00       	call   f01087df <unmap_frame>
f010870d:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108710:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108713:	8b 40 08             	mov    0x8(%eax),%eax
f0108716:	40                   	inc    %eax
f0108717:	8b 55 0c             	mov    0xc(%ebp),%edx
f010871a:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f010871e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108721:	8b 55 10             	mov    0x10(%ebp),%edx
f0108724:	c1 ea 0c             	shr    $0xc,%edx
f0108727:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010872d:	c1 e2 02             	shl    $0x2,%edx
f0108730:	01 d0                	add    %edx,%eax
f0108732:	8b 00                	mov    (%eax),%eax
f0108734:	25 00 0e 00 00       	and    $0xe00,%eax
f0108739:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f010873c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010873f:	8b 55 10             	mov    0x10(%ebp),%edx
f0108742:	c1 ea 0c             	shr    $0xc,%edx
f0108745:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010874b:	c1 e2 02             	shl    $0x2,%edx
f010874e:	01 c2                	add    %eax,%edx
f0108750:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108753:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108756:	89 c1                	mov    %eax,%ecx
f0108758:	8b 45 14             	mov    0x14(%ebp),%eax
f010875b:	09 c8                	or     %ecx,%eax
f010875d:	83 c8 01             	or     $0x1,%eax
f0108760:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108762:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108767:	c9                   	leave  
f0108768:	c3                   	ret    

f0108769 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108769:	55                   	push   %ebp
f010876a:	89 e5                	mov    %esp,%ebp
f010876c:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f010876f:	83 ec 04             	sub    $0x4,%esp
f0108772:	ff 75 10             	pushl  0x10(%ebp)
f0108775:	ff 75 0c             	pushl  0xc(%ebp)
f0108778:	ff 75 08             	pushl  0x8(%ebp)
f010877b:	e8 6f fc ff ff       	call   f01083ef <get_page_table>
f0108780:	83 c4 10             	add    $0x10,%esp
f0108783:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108786:	8b 45 10             	mov    0x10(%ebp),%eax
f0108789:	8b 00                	mov    (%eax),%eax
f010878b:	85 c0                	test   %eax,%eax
f010878d:	74 49                	je     f01087d8 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f010878f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108792:	c1 e8 0c             	shr    $0xc,%eax
f0108795:	25 ff 03 00 00       	and    $0x3ff,%eax
f010879a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f010879d:	8b 45 10             	mov    0x10(%ebp),%eax
f01087a0:	8b 00                	mov    (%eax),%eax
f01087a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01087a5:	c1 e2 02             	shl    $0x2,%edx
f01087a8:	01 d0                	add    %edx,%eax
f01087aa:	8b 00                	mov    (%eax),%eax
f01087ac:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f01087af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087b2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087b7:	85 c0                	test   %eax,%eax
f01087b9:	74 16                	je     f01087d1 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f01087bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087c3:	83 ec 0c             	sub    $0xc,%esp
f01087c6:	50                   	push   %eax
f01087c7:	e8 a7 f5 ff ff       	call   f0107d73 <to_frame_info>
f01087cc:	83 c4 10             	add    $0x10,%esp
f01087cf:	eb 0c                	jmp    f01087dd <get_frame_info+0x74>
		}
		return 0;
f01087d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01087d6:	eb 05                	jmp    f01087dd <get_frame_info+0x74>
	}
	return 0;
f01087d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01087dd:	c9                   	leave  
f01087de:	c3                   	ret    

f01087df <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f01087df:	55                   	push   %ebp
f01087e0:	89 e5                	mov    %esp,%ebp
f01087e2:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f01087e5:	83 ec 04             	sub    $0x4,%esp
f01087e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01087eb:	50                   	push   %eax
f01087ec:	ff 75 0c             	pushl  0xc(%ebp)
f01087ef:	ff 75 08             	pushl  0x8(%ebp)
f01087f2:	e8 72 ff ff ff       	call   f0108769 <get_frame_info>
f01087f7:	83 c4 10             	add    $0x10,%esp
f01087fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f01087fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108801:	74 7d                	je     f0108880 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108803:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108806:	8a 40 14             	mov    0x14(%eax),%al
f0108809:	84 c0                	test   %al,%al
f010880b:	74 1c                	je     f0108829 <unmap_frame+0x4a>
f010880d:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108814:	77 13                	ja     f0108829 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108816:	83 ec 08             	sub    $0x8,%esp
f0108819:	ff 75 0c             	pushl  0xc(%ebp)
f010881c:	68 ac 5a 12 f0       	push   $0xf0125aac
f0108821:	e8 65 87 ff ff       	call   f0100f8b <cprintf>
f0108826:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0108829:	83 ec 0c             	sub    $0xc,%esp
f010882c:	ff 75 f4             	pushl  -0xc(%ebp)
f010882f:	e8 8b fb ff ff       	call   f01083bf <decrement_references>
f0108834:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108837:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010883a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010883d:	c1 ea 0c             	shr    $0xc,%edx
f0108840:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108846:	c1 e2 02             	shl    $0x2,%edx
f0108849:	01 d0                	add    %edx,%eax
f010884b:	8b 00                	mov    (%eax),%eax
f010884d:	25 00 0e 00 00       	and    $0xe00,%eax
f0108852:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108855:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108858:	8b 55 0c             	mov    0xc(%ebp),%edx
f010885b:	c1 ea 0c             	shr    $0xc,%edx
f010885e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108864:	c1 e2 02             	shl    $0x2,%edx
f0108867:	01 c2                	add    %eax,%edx
f0108869:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010886c:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f010886e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108871:	83 ec 08             	sub    $0x8,%esp
f0108874:	50                   	push   %eax
f0108875:	ff 75 08             	pushl  0x8(%ebp)
f0108878:	e8 3c f5 ff ff       	call   f0107db9 <tlb_invalidate>
f010887d:	83 c4 10             	add    $0x10,%esp
	}
}
f0108880:	90                   	nop
f0108881:	c9                   	leave  
f0108882:	c3                   	ret    

f0108883 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108883:	55                   	push   %ebp
f0108884:	89 e5                	mov    %esp,%ebp
f0108886:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108889:	ff 75 0c             	pushl  0xc(%ebp)
f010888c:	e8 cf f4 ff ff       	call   f0107d60 <to_physical_address>
f0108891:	83 c4 04             	add    $0x4,%esp
f0108894:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108897:	8b 45 10             	mov    0x10(%ebp),%eax
f010889a:	c1 e8 16             	shr    $0x16,%eax
f010889d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01088a7:	01 d0                	add    %edx,%eax
f01088a9:	8b 00                	mov    (%eax),%eax
f01088ab:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01088ae:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01088b5:	77 19                	ja     f01088d0 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088bf:	83 ec 0c             	sub    $0xc,%esp
f01088c2:	50                   	push   %eax
f01088c3:	e8 6c 0f 00 00       	call   f0109834 <kheap_virtual_address>
f01088c8:	83 c4 10             	add    $0x10,%esp
f01088cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01088ce:	eb 40                	jmp    f0108910 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088d3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01088db:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01088de:	c1 e8 0c             	shr    $0xc,%eax
f01088e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01088e4:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f01088e9:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01088ec:	72 17                	jb     f0108905 <loadtime_map_frame+0x82>
f01088ee:	ff 75 e8             	pushl  -0x18(%ebp)
f01088f1:	68 60 5a 12 f0       	push   $0xf0125a60
f01088f6:	68 fa 01 00 00       	push   $0x1fa
f01088fb:	68 a3 59 12 f0       	push   $0xf01259a3
f0108900:	e8 34 7a ff ff       	call   f0100339 <_panic>
f0108905:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108908:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010890d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108910:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108914:	75 14                	jne    f010892a <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0108916:	83 ec 08             	sub    $0x8,%esp
f0108919:	ff 75 10             	pushl  0x10(%ebp)
f010891c:	ff 75 08             	pushl  0x8(%ebp)
f010891f:	e8 21 fc ff ff       	call   f0108545 <create_page_table>
f0108924:	83 c4 10             	add    $0x10,%esp
f0108927:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f010892a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010892d:	8b 40 08             	mov    0x8(%eax),%eax
f0108930:	40                   	inc    %eax
f0108931:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108934:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108938:	8b 45 10             	mov    0x10(%ebp),%eax
f010893b:	c1 e8 0c             	shr    $0xc,%eax
f010893e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108943:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010894a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010894d:	01 c2                	add    %eax,%edx
f010894f:	8b 45 14             	mov    0x14(%ebp),%eax
f0108952:	0b 45 f0             	or     -0x10(%ebp),%eax
f0108955:	83 c8 01             	or     $0x1,%eax
f0108958:	89 02                	mov    %eax,(%edx)

	return 0;
f010895a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010895f:	c9                   	leave  
f0108960:	c3                   	ret    

f0108961 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108961:	55                   	push   %ebp
f0108962:	89 e5                	mov    %esp,%ebp
f0108964:	57                   	push   %edi
f0108965:	56                   	push   %esi
f0108966:	53                   	push   %ebx
f0108967:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f010896a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108971:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0108978:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f010897f:	83 ec 0c             	sub    $0xc,%esp
f0108982:	68 a0 06 6c f0       	push   $0xf06c06a0
f0108987:	e8 a7 74 00 00       	call   f010fe33 <holding_spinlock>
f010898c:	83 c4 10             	add    $0x10,%esp
f010898f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108992:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108996:	75 10                	jne    f01089a8 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108998:	83 ec 0c             	sub    $0xc,%esp
f010899b:	68 a0 06 6c f0       	push   $0xf06c06a0
f01089a0:	e8 75 72 00 00       	call   f010fc1a <acquire_spinlock>
f01089a5:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089a8:	a1 80 06 6c f0       	mov    0xf06c0680,%eax
f01089ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089b0:	eb 1a                	jmp    f01089cc <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f01089b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089b5:	8a 40 14             	mov    0x14(%eax),%al
f01089b8:	84 c0                	test   %al,%al
f01089ba:	74 05                	je     f01089c1 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f01089bc:	ff 45 dc             	incl   -0x24(%ebp)
f01089bf:	eb 03                	jmp    f01089c4 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f01089c1:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089c4:	a1 88 06 6c f0       	mov    0xf06c0688,%eax
f01089c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089d0:	74 07                	je     f01089d9 <calculate_available_frames+0x78>
f01089d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089d5:	8b 00                	mov    (%eax),%eax
f01089d7:	eb 05                	jmp    f01089de <calculate_available_frames+0x7d>
f01089d9:	b8 00 00 00 00       	mov    $0x0,%eax
f01089de:	a3 88 06 6c f0       	mov    %eax,0xf06c0688
f01089e3:	a1 88 06 6c f0       	mov    0xf06c0688,%eax
f01089e8:	85 c0                	test   %eax,%eax
f01089ea:	75 c6                	jne    f01089b2 <calculate_available_frames+0x51>
f01089ec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089f0:	75 c0                	jne    f01089b2 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f01089f2:	a1 9c 06 6c f0       	mov    0xf06c069c,%eax
f01089f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f01089fa:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01089fe:	75 10                	jne    f0108a10 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108a00:	83 ec 0c             	sub    $0xc,%esp
f0108a03:	68 a0 06 6c f0       	push   $0xf06c06a0
f0108a08:	e8 94 72 00 00       	call   f010fca1 <release_spinlock>
f0108a0d:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108a10:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108a13:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108a16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108a19:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108a1c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108a1f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108a22:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a25:	89 c3                	mov    %eax,%ebx
f0108a27:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108a2a:	ba 03 00 00 00       	mov    $0x3,%edx
f0108a2f:	89 df                	mov    %ebx,%edi
f0108a31:	89 c6                	mov    %eax,%esi
f0108a33:	89 d1                	mov    %edx,%ecx
f0108a35:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108a37:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108a3d:	5b                   	pop    %ebx
f0108a3e:	5e                   	pop    %esi
f0108a3f:	5f                   	pop    %edi
f0108a40:	5d                   	pop    %ebp
f0108a41:	c2 04 00             	ret    $0x4

f0108a44 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0108a44:	55                   	push   %ebp
f0108a45:	89 e5                	mov    %esp,%ebp
f0108a47:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0108a4a:	c7 05 40 05 6c f0 00 	movl   $0x0,0xf06c0540
f0108a51:	00 00 00 
f0108a54:	c7 05 44 05 6c f0 00 	movl   $0x0,0xf06c0544
f0108a5b:	00 00 00 
f0108a5e:	c7 05 4c 05 6c f0 00 	movl   $0x0,0xf06c054c
f0108a65:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f0108a68:	83 ec 08             	sub    $0x8,%esp
f0108a6b:	68 dc 5a 12 f0       	push   $0xf0125adc
f0108a70:	68 50 05 6c f0       	push   $0xf06c0550
f0108a75:	e8 6f 71 00 00       	call   f010fbe9 <init_spinlock>
f0108a7a:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108a7d:	90                   	nop
f0108a7e:	c9                   	leave  
f0108a7f:	c3                   	ret    

f0108a80 <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108a80:	55                   	push   %ebp
f0108a81:	89 e5                	mov    %esp,%ebp
f0108a83:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108a86:	83 ec 08             	sub    $0x8,%esp
f0108a89:	ff 75 0c             	pushl  0xc(%ebp)
f0108a8c:	ff 75 08             	pushl  0x8(%ebp)
f0108a8f:	e8 4b 01 00 00       	call   f0108bdf <get_share>
f0108a94:	83 c4 10             	add    $0x10,%esp
f0108a97:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108a9a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a9e:	75 07                	jne    f0108aa7 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108aa0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108aa5:	eb 06                	jmp    f0108aad <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108aaa:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108aad:	c9                   	leave  
f0108aae:	c3                   	ret    

f0108aaf <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108aaf:	55                   	push   %ebp
f0108ab0:	89 e5                	mov    %esp,%ebp
f0108ab2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_frames_storage is not implemented yet");
	//Your Code is Here...
	if (LIST_SIZE(&MemFrameLists.free_frame_list) < numOfFrames)
f0108ab5:	8b 15 8c 06 6c f0    	mov    0xf06c068c,%edx
f0108abb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108abe:	39 c2                	cmp    %eax,%edx
f0108ac0:	73 07                	jae    f0108ac9 <create_frames_storage+0x1a>
	{
		return NULL;
f0108ac2:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ac7:	eb 3c                	jmp    f0108b05 <create_frames_storage+0x56>
	}
	struct FrameInfo** frames_storage = (struct FrameInfo**) kmalloc(numOfFrames * sizeof(struct FrameInfo * ));
f0108ac9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108acc:	c1 e0 02             	shl    $0x2,%eax
f0108acf:	83 ec 0c             	sub    $0xc,%esp
f0108ad2:	50                   	push   %eax
f0108ad3:	e8 b9 09 00 00       	call   f0109491 <kmalloc>
f0108ad8:	83 c4 10             	add    $0x10,%esp
f0108adb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (frames_storage==NULL) return NULL;
f0108ade:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108ae2:	75 07                	jne    f0108aeb <create_frames_storage+0x3c>
f0108ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ae9:	eb 1a                	jmp    f0108b05 <create_frames_storage+0x56>
	 // Initialize the FrameInfo struct to zero
	 memset(frames_storage, 0, numOfFrames * sizeof(struct FrameInfo *));
f0108aeb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108aee:	c1 e0 02             	shl    $0x2,%eax
f0108af1:	83 ec 04             	sub    $0x4,%esp
f0108af4:	50                   	push   %eax
f0108af5:	6a 00                	push   $0x0
f0108af7:	ff 75 f4             	pushl  -0xc(%ebp)
f0108afa:	e8 b7 72 01 00       	call   f011fdb6 <memset>
f0108aff:	83 c4 10             	add    $0x10,%esp
	return frames_storage;
f0108b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108b05:	c9                   	leave  
f0108b06:	c3                   	ret    

f0108b07 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108b07:	55                   	push   %ebp
f0108b08:	89 e5                	mov    %esp,%ebp
f0108b0a:	83 ec 28             	sub    $0x28,%esp
f0108b0d:	8b 45 14             	mov    0x14(%ebp),%eax
f0108b10:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_share is not implemented yet");
	//Your Code is Here...
	uint32 numOfFrames = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108b13:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0108b1a:	8b 55 10             	mov    0x10(%ebp),%edx
f0108b1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b20:	01 d0                	add    %edx,%eax
f0108b22:	48                   	dec    %eax
f0108b23:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108b26:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b29:	ba 00 00 00 00       	mov    $0x0,%edx
f0108b2e:	f7 75 f4             	divl   -0xc(%ebp)
f0108b31:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b34:	29 d0                	sub    %edx,%eax
f0108b36:	c1 e8 0c             	shr    $0xc,%eax
f0108b39:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Share* created_share = kmalloc(sizeof(struct Share));
f0108b3c:	83 ec 0c             	sub    $0xc,%esp
f0108b3f:	6a 60                	push   $0x60
f0108b41:	e8 4b 09 00 00       	call   f0109491 <kmalloc>
f0108b46:	83 c4 10             	add    $0x10,%esp
f0108b49:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share==NULL) return NULL;
f0108b4c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108b50:	75 0a                	jne    f0108b5c <create_share+0x55>
f0108b52:	b8 00 00 00 00       	mov    $0x0,%eax
f0108b57:	e9 81 00 00 00       	jmp    f0108bdd <create_share+0xd6>
	created_share->references=1;
f0108b5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b5f:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	created_share->ID=(int32)(((int)created_share << 1)>>1); //mask
f0108b66:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b69:	01 c0                	add    %eax,%eax
f0108b6b:	d1 f8                	sar    %eax
f0108b6d:	89 c2                	mov    %eax,%edx
f0108b6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b72:	89 10                	mov    %edx,(%eax)
	created_share->framesStorage = create_frames_storage(numOfFrames);
f0108b74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b77:	83 ec 0c             	sub    $0xc,%esp
f0108b7a:	50                   	push   %eax
f0108b7b:	e8 2f ff ff ff       	call   f0108aaf <create_frames_storage>
f0108b80:	83 c4 10             	add    $0x10,%esp
f0108b83:	89 c2                	mov    %eax,%edx
f0108b85:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b88:	89 50 54             	mov    %edx,0x54(%eax)
	if(created_share->framesStorage==NULL)
f0108b8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b8e:	8b 40 54             	mov    0x54(%eax),%eax
f0108b91:	85 c0                	test   %eax,%eax
f0108b93:	75 15                	jne    f0108baa <create_share+0xa3>
	{
			kfree((void*)created_share);
f0108b95:	83 ec 0c             	sub    $0xc,%esp
f0108b98:	ff 75 e8             	pushl  -0x18(%ebp)
f0108b9b:	e8 51 0b 00 00       	call   f01096f1 <kfree>
f0108ba0:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0108ba3:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ba8:	eb 33                	jmp    f0108bdd <create_share+0xd6>
	}
	created_share->ownerID=ownerID;
f0108baa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bad:	8b 55 08             	mov    0x8(%ebp),%edx
f0108bb0:	89 50 04             	mov    %edx,0x4(%eax)
	strcpy(created_share->name, shareName);
f0108bb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bb6:	83 c0 08             	add    $0x8,%eax
f0108bb9:	83 ec 08             	sub    $0x8,%esp
f0108bbc:	ff 75 0c             	pushl  0xc(%ebp)
f0108bbf:	50                   	push   %eax
f0108bc0:	e8 52 70 01 00       	call   f011fc17 <strcpy>
f0108bc5:	83 c4 10             	add    $0x10,%esp
	created_share->size=size;
f0108bc8:	8b 55 10             	mov    0x10(%ebp),%edx
f0108bcb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bce:	89 50 48             	mov    %edx,0x48(%eax)
	created_share->isWritable=isWritable;
f0108bd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bd4:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0108bd7:	88 50 50             	mov    %dl,0x50(%eax)
	return created_share;
f0108bda:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0108bdd:	c9                   	leave  
f0108bde:	c3                   	ret    

f0108bdf <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108bdf:	55                   	push   %ebp
f0108be0:	89 e5                	mov    %esp,%ebp
f0108be2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
f0108be5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&AllShares.shareslock);
f0108bec:	83 ec 0c             	sub    $0xc,%esp
f0108bef:	68 50 05 6c f0       	push   $0xf06c0550
f0108bf4:	e8 21 70 00 00       	call   f010fc1a <acquire_spinlock>
f0108bf9:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108bfc:	a1 40 05 6c f0       	mov    0xf06c0540,%eax
f0108c01:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c04:	eb 41                	jmp    f0108c47 <get_share+0x68>
		if(founded->ownerID == ownerID && strcmp(founded->name, name) == 0)
f0108c06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c09:	8b 40 04             	mov    0x4(%eax),%eax
f0108c0c:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108c0f:	75 2e                	jne    f0108c3f <get_share+0x60>
f0108c11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c14:	83 c0 08             	add    $0x8,%eax
f0108c17:	83 ec 08             	sub    $0x8,%esp
f0108c1a:	ff 75 0c             	pushl  0xc(%ebp)
f0108c1d:	50                   	push   %eax
f0108c1e:	e8 b1 70 01 00       	call   f011fcd4 <strcmp>
f0108c23:	83 c4 10             	add    $0x10,%esp
f0108c26:	85 c0                	test   %eax,%eax
f0108c28:	75 15                	jne    f0108c3f <get_share+0x60>
		{
			release_spinlock(&AllShares.shareslock);
f0108c2a:	83 ec 0c             	sub    $0xc,%esp
f0108c2d:	68 50 05 6c f0       	push   $0xf06c0550
f0108c32:	e8 6a 70 00 00       	call   f010fca1 <release_spinlock>
f0108c37:	83 c4 10             	add    $0x10,%esp
			return founded;
f0108c3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c3d:	eb 44                	jmp    f0108c83 <get_share+0xa4>
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
	acquire_spinlock(&AllShares.shareslock);
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108c3f:	a1 48 05 6c f0       	mov    0xf06c0548,%eax
f0108c44:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c4b:	74 08                	je     f0108c55 <get_share+0x76>
f0108c4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c50:	8b 40 58             	mov    0x58(%eax),%eax
f0108c53:	eb 05                	jmp    f0108c5a <get_share+0x7b>
f0108c55:	b8 00 00 00 00       	mov    $0x0,%eax
f0108c5a:	a3 48 05 6c f0       	mov    %eax,0xf06c0548
f0108c5f:	a1 48 05 6c f0       	mov    0xf06c0548,%eax
f0108c64:	85 c0                	test   %eax,%eax
f0108c66:	75 9e                	jne    f0108c06 <get_share+0x27>
f0108c68:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c6c:	75 98                	jne    f0108c06 <get_share+0x27>
		{
			release_spinlock(&AllShares.shareslock);
			return founded;
		}
	}
	release_spinlock(&AllShares.shareslock);
f0108c6e:	83 ec 0c             	sub    $0xc,%esp
f0108c71:	68 50 05 6c f0       	push   $0xf06c0550
f0108c76:	e8 26 70 00 00       	call   f010fca1 <release_spinlock>
f0108c7b:	83 c4 10             	add    $0x10,%esp
	return NULL;
f0108c7e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108c83:	c9                   	leave  
f0108c84:	c3                   	ret    

f0108c85 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108c85:	55                   	push   %ebp
f0108c86:	89 e5                	mov    %esp,%ebp
f0108c88:	83 ec 48             	sub    $0x48,%esp
f0108c8b:	8b 45 14             	mov    0x14(%ebp),%eax
f0108c8e:	88 45 c4             	mov    %al,-0x3c(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("createSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108c91:	e8 f5 2c 00 00       	call   f010b98b <get_cpu_proc>
f0108c96:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share* existed = get_share(ownerID,shareName);
f0108c99:	83 ec 08             	sub    $0x8,%esp
f0108c9c:	ff 75 0c             	pushl  0xc(%ebp)
f0108c9f:	ff 75 08             	pushl  0x8(%ebp)
f0108ca2:	e8 38 ff ff ff       	call   f0108bdf <get_share>
f0108ca7:	83 c4 10             	add    $0x10,%esp
f0108caa:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
f0108cad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108cb1:	74 0a                	je     f0108cbd <createSharedObject+0x38>
f0108cb3:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f0108cb8:	e9 59 01 00 00       	jmp    f0108e16 <createSharedObject+0x191>
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
f0108cbd:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f0108cc1:	50                   	push   %eax
f0108cc2:	ff 75 10             	pushl  0x10(%ebp)
f0108cc5:	ff 75 0c             	pushl  0xc(%ebp)
f0108cc8:	ff 75 08             	pushl  0x8(%ebp)
f0108ccb:	e8 37 fe ff ff       	call   f0108b07 <create_share>
f0108cd0:	83 c4 10             	add    $0x10,%esp
f0108cd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share == NULL) return E_NO_SHARE;
f0108cd6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108cda:	75 0a                	jne    f0108ce6 <createSharedObject+0x61>
f0108cdc:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f0108ce1:	e9 30 01 00 00       	jmp    f0108e16 <createSharedObject+0x191>
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108ce6:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108ced:	8b 55 10             	mov    0x10(%ebp),%edx
f0108cf0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108cf3:	01 d0                	add    %edx,%eax
f0108cf5:	48                   	dec    %eax
f0108cf6:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108cf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108cfc:	ba 00 00 00 00       	mov    $0x0,%edx
f0108d01:	f7 75 e4             	divl   -0x1c(%ebp)
f0108d04:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108d07:	29 d0                	sub    %edx,%eax
f0108d09:	c1 e8 0c             	shr    $0xc,%eax
f0108d0c:	89 45 dc             	mov    %eax,-0x24(%ebp)

	for (int k = 0; k < num_pages; k++)
f0108d0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108d16:	eb 6c                	jmp    f0108d84 <createSharedObject+0xff>
	{
		struct FrameInfo *ptr_frame_info;
		int ret = allocate_frame(&ptr_frame_info);
f0108d18:	83 ec 0c             	sub    $0xc,%esp
f0108d1b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0108d1e:	50                   	push   %eax
f0108d1f:	e8 8e f4 ff ff       	call   f01081b2 <allocate_frame>
f0108d24:	83 c4 10             	add    $0x10,%esp
f0108d27:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (ret == 0)
f0108d2a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0108d2e:	75 3d                	jne    f0108d6d <createSharedObject+0xe8>
		{
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
f0108d30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d33:	c1 e0 0c             	shl    $0xc,%eax
f0108d36:	89 c2                	mov    %eax,%edx
f0108d38:	8b 45 18             	mov    0x18(%ebp),%eax
f0108d3b:	01 d0                	add    %edx,%eax
f0108d3d:	89 c1                	mov    %eax,%ecx
f0108d3f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0108d42:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d45:	8b 40 64             	mov    0x64(%eax),%eax
f0108d48:	6a 06                	push   $0x6
f0108d4a:	51                   	push   %ecx
f0108d4b:	52                   	push   %edx
f0108d4c:	50                   	push   %eax
f0108d4d:	e8 2d f9 ff ff       	call   f010867f <map_frame>
f0108d52:	83 c4 10             	add    $0x10,%esp
			created_share->framesStorage[k] = ptr_frame_info;
f0108d55:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108d58:	8b 40 54             	mov    0x54(%eax),%eax
f0108d5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d5e:	c1 e2 02             	shl    $0x2,%edx
f0108d61:	01 c2                	add    %eax,%edx
f0108d63:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0108d66:	89 02                	mov    %eax,(%edx)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;

	for (int k = 0; k < num_pages; k++)
f0108d68:	ff 45 f4             	incl   -0xc(%ebp)
f0108d6b:	eb 17                	jmp    f0108d84 <createSharedObject+0xff>
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
			created_share->framesStorage[k] = ptr_frame_info;
		}
		else
		{
			panic("No Memory");
f0108d6d:	83 ec 04             	sub    $0x4,%esp
f0108d70:	68 e8 5a 12 f0       	push   $0xf0125ae8
f0108d75:	68 a6 00 00 00       	push   $0xa6
f0108d7a:	68 f4 5a 12 f0       	push   $0xf0125af4
f0108d7f:	e8 b5 75 ff ff       	call   f0100339 <_panic>
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;

	for (int k = 0; k < num_pages; k++)
f0108d84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d87:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0108d8a:	72 8c                	jb     f0108d18 <createSharedObject+0x93>
		{
			panic("No Memory");
			return E_NO_SHARE;
		}
	}
	acquire_spinlock(&AllShares.shareslock);
f0108d8c:	83 ec 0c             	sub    $0xc,%esp
f0108d8f:	68 50 05 6c f0       	push   $0xf06c0550
f0108d94:	e8 81 6e 00 00       	call   f010fc1a <acquire_spinlock>
f0108d99:	83 c4 10             	add    $0x10,%esp
	LIST_INSERT_TAIL(&AllShares.shares_list,created_share);
f0108d9c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108da0:	75 17                	jne    f0108db9 <createSharedObject+0x134>
f0108da2:	83 ec 04             	sub    $0x4,%esp
f0108da5:	68 18 5b 12 f0       	push   $0xf0125b18
f0108daa:	68 ab 00 00 00       	push   $0xab
f0108daf:	68 f4 5a 12 f0       	push   $0xf0125af4
f0108db4:	e8 80 75 ff ff       	call   f0100339 <_panic>
f0108db9:	8b 15 44 05 6c f0    	mov    0xf06c0544,%edx
f0108dbf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108dc2:	89 50 5c             	mov    %edx,0x5c(%eax)
f0108dc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108dc8:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108dcb:	85 c0                	test   %eax,%eax
f0108dcd:	74 0d                	je     f0108ddc <createSharedObject+0x157>
f0108dcf:	a1 44 05 6c f0       	mov    0xf06c0544,%eax
f0108dd4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108dd7:	89 50 58             	mov    %edx,0x58(%eax)
f0108dda:	eb 08                	jmp    f0108de4 <createSharedObject+0x15f>
f0108ddc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ddf:	a3 40 05 6c f0       	mov    %eax,0xf06c0540
f0108de4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108de7:	a3 44 05 6c f0       	mov    %eax,0xf06c0544
f0108dec:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108def:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0108df6:	a1 4c 05 6c f0       	mov    0xf06c054c,%eax
f0108dfb:	40                   	inc    %eax
f0108dfc:	a3 4c 05 6c f0       	mov    %eax,0xf06c054c
	release_spinlock(&AllShares.shareslock);
f0108e01:	83 ec 0c             	sub    $0xc,%esp
f0108e04:	68 50 05 6c f0       	push   $0xf06c0550
f0108e09:	e8 93 6e 00 00       	call   f010fca1 <release_spinlock>
f0108e0e:	83 c4 10             	add    $0x10,%esp
	return created_share->ID;
f0108e11:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e14:	8b 00                	mov    (%eax),%eax
}
f0108e16:	c9                   	leave  
f0108e17:	c3                   	ret    

f0108e18 <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108e18:	55                   	push   %ebp
f0108e19:	89 e5                	mov    %esp,%ebp
f0108e1b:	53                   	push   %ebx
f0108e1c:	83 ec 24             	sub    $0x24,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("getSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108e1f:	e8 67 2b 00 00       	call   f010b98b <get_cpu_proc>
f0108e24:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share * shared_obj = get_share(ownerID,shareName);
f0108e27:	83 ec 08             	sub    $0x8,%esp
f0108e2a:	ff 75 0c             	pushl  0xc(%ebp)
f0108e2d:	ff 75 08             	pushl  0x8(%ebp)
f0108e30:	e8 aa fd ff ff       	call   f0108bdf <get_share>
f0108e35:	83 c4 10             	add    $0x10,%esp
f0108e38:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
f0108e3b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108e3f:	75 0a                	jne    f0108e4b <getSharedObject+0x33>
f0108e41:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108e46:	e9 a0 00 00 00       	jmp    f0108eeb <getSharedObject+0xd3>
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
f0108e4b:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f0108e52:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e55:	8b 40 48             	mov    0x48(%eax),%eax
f0108e58:	89 c2                	mov    %eax,%edx
f0108e5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e5d:	01 d0                	add    %edx,%eax
f0108e5f:	48                   	dec    %eax
f0108e60:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108e63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e66:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e6b:	f7 75 e8             	divl   -0x18(%ebp)
f0108e6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e71:	29 d0                	sub    %edx,%eax
f0108e73:	85 c0                	test   %eax,%eax
f0108e75:	79 05                	jns    f0108e7c <getSharedObject+0x64>
f0108e77:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108e7c:	c1 f8 0c             	sar    $0xc,%eax
f0108e7f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for(int i = 0 ;i< numOfFrames ;i++)
f0108e82:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108e89:	eb 44                	jmp    f0108ecf <getSharedObject+0xb7>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
f0108e8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e8e:	8a 40 50             	mov    0x50(%eax),%al
f0108e91:	0f b6 c0             	movzbl %al,%eax
f0108e94:	01 c0                	add    %eax,%eax
f0108e96:	83 c8 04             	or     $0x4,%eax
f0108e99:	89 c3                	mov    %eax,%ebx
f0108e9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e9e:	c1 e0 0c             	shl    $0xc,%eax
f0108ea1:	89 c2                	mov    %eax,%edx
f0108ea3:	8b 45 10             	mov    0x10(%ebp),%eax
f0108ea6:	01 d0                	add    %edx,%eax
f0108ea8:	89 c1                	mov    %eax,%ecx
f0108eaa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ead:	8b 40 54             	mov    0x54(%eax),%eax
f0108eb0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108eb3:	c1 e2 02             	shl    $0x2,%edx
f0108eb6:	01 d0                	add    %edx,%eax
f0108eb8:	8b 10                	mov    (%eax),%edx
f0108eba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ebd:	8b 40 64             	mov    0x64(%eax),%eax
f0108ec0:	53                   	push   %ebx
f0108ec1:	51                   	push   %ecx
f0108ec2:	52                   	push   %edx
f0108ec3:	50                   	push   %eax
f0108ec4:	e8 b6 f7 ff ff       	call   f010867f <map_frame>
f0108ec9:	83 c4 10             	add    $0x10,%esp

	struct Env* myenv = get_cpu_proc(); //The calling environment
	struct Share * shared_obj = get_share(ownerID,shareName);
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0 ;i< numOfFrames ;i++)
f0108ecc:	ff 45 f4             	incl   -0xc(%ebp)
f0108ecf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ed2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0108ed5:	72 b4                	jb     f0108e8b <getSharedObject+0x73>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
	}
	shared_obj->references++;
f0108ed7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108eda:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108edd:	8d 50 01             	lea    0x1(%eax),%edx
f0108ee0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ee3:	89 50 4c             	mov    %edx,0x4c(%eax)
	return shared_obj->ID;
f0108ee6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ee9:	8b 00                	mov    (%eax),%eax
}
f0108eeb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108eee:	c9                   	leave  
f0108eef:	c3                   	ret    

f0108ef0 <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0108ef0:	55                   	push   %ebp
f0108ef1:	89 e5                	mov    %esp,%ebp
f0108ef3:	83 ec 08             	sub    $0x8,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f0108ef6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108efa:	0f 84 ca 00 00 00    	je     f0108fca <free_share+0xda>
    acquire_spinlock(&AllShares.shareslock);
f0108f00:	83 ec 0c             	sub    $0xc,%esp
f0108f03:	68 50 05 6c f0       	push   $0xf06c0550
f0108f08:	e8 0d 6d 00 00       	call   f010fc1a <acquire_spinlock>
f0108f0d:	83 c4 10             	add    $0x10,%esp
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
f0108f10:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108f14:	75 17                	jne    f0108f2d <free_share+0x3d>
f0108f16:	83 ec 04             	sub    $0x4,%esp
f0108f19:	68 3b 5b 12 f0       	push   $0xf0125b3b
f0108f1e:	68 d8 00 00 00       	push   $0xd8
f0108f23:	68 f4 5a 12 f0       	push   $0xf0125af4
f0108f28:	e8 0c 74 ff ff       	call   f0100339 <_panic>
f0108f2d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f30:	8b 40 58             	mov    0x58(%eax),%eax
f0108f33:	85 c0                	test   %eax,%eax
f0108f35:	74 11                	je     f0108f48 <free_share+0x58>
f0108f37:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f3a:	8b 40 58             	mov    0x58(%eax),%eax
f0108f3d:	8b 55 08             	mov    0x8(%ebp),%edx
f0108f40:	8b 52 5c             	mov    0x5c(%edx),%edx
f0108f43:	89 50 5c             	mov    %edx,0x5c(%eax)
f0108f46:	eb 0b                	jmp    f0108f53 <free_share+0x63>
f0108f48:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f4b:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108f4e:	a3 44 05 6c f0       	mov    %eax,0xf06c0544
f0108f53:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f56:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108f59:	85 c0                	test   %eax,%eax
f0108f5b:	74 11                	je     f0108f6e <free_share+0x7e>
f0108f5d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f60:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108f63:	8b 55 08             	mov    0x8(%ebp),%edx
f0108f66:	8b 52 58             	mov    0x58(%edx),%edx
f0108f69:	89 50 58             	mov    %edx,0x58(%eax)
f0108f6c:	eb 0b                	jmp    f0108f79 <free_share+0x89>
f0108f6e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f71:	8b 40 58             	mov    0x58(%eax),%eax
f0108f74:	a3 40 05 6c f0       	mov    %eax,0xf06c0540
f0108f79:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f7c:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0108f83:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f86:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
f0108f8d:	a1 4c 05 6c f0       	mov    0xf06c054c,%eax
f0108f92:	48                   	dec    %eax
f0108f93:	a3 4c 05 6c f0       	mov    %eax,0xf06c054c
    release_spinlock(&AllShares.shareslock);
f0108f98:	83 ec 0c             	sub    $0xc,%esp
f0108f9b:	68 50 05 6c f0       	push   $0xf06c0550
f0108fa0:	e8 fc 6c 00 00       	call   f010fca1 <release_spinlock>
f0108fa5:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare->framesStorage);
f0108fa8:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fab:	8b 40 54             	mov    0x54(%eax),%eax
f0108fae:	83 ec 0c             	sub    $0xc,%esp
f0108fb1:	50                   	push   %eax
f0108fb2:	e8 3a 07 00 00       	call   f01096f1 <kfree>
f0108fb7:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare);
f0108fba:	83 ec 0c             	sub    $0xc,%esp
f0108fbd:	ff 75 08             	pushl  0x8(%ebp)
f0108fc0:	e8 2c 07 00 00       	call   f01096f1 <kfree>
f0108fc5:	83 c4 10             	add    $0x10,%esp
f0108fc8:	eb 01                	jmp    f0108fcb <free_share+0xdb>
{
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f0108fca:	90                   	nop
    acquire_spinlock(&AllShares.shareslock);
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
    release_spinlock(&AllShares.shareslock);
    kfree((void*)ptrShare->framesStorage);
    kfree((void*)ptrShare);
}
f0108fcb:	c9                   	leave  
f0108fcc:	c3                   	ret    

f0108fcd <get_Share_id>:
//========================
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
f0108fcd:	55                   	push   %ebp
f0108fce:	89 e5                	mov    %esp,%ebp
f0108fd0:	83 ec 18             	sub    $0x18,%esp
	 uint32 id = ((uint32)va << 1) >> 1;
f0108fd3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108fd6:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
f0108fdb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	 cprintf("VA : %x \n",id);
f0108fde:	83 ec 08             	sub    $0x8,%esp
f0108fe1:	ff 75 f0             	pushl  -0x10(%ebp)
f0108fe4:	68 59 5b 12 f0       	push   $0xf0125b59
f0108fe9:	e8 9d 7f ff ff       	call   f0100f8b <cprintf>
f0108fee:	83 c4 10             	add    $0x10,%esp
    struct Share* founded = NULL;
f0108ff1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        acquire_spinlock(&AllShares.shareslock);
f0108ff8:	83 ec 0c             	sub    $0xc,%esp
f0108ffb:	68 50 05 6c f0       	push   $0xf06c0550
f0109000:	e8 15 6c 00 00       	call   f010fc1a <acquire_spinlock>
f0109005:	83 c4 10             	add    $0x10,%esp
        LIST_FOREACH(founded, &AllShares.shares_list) {
f0109008:	a1 40 05 6c f0       	mov    0xf06c0540,%eax
f010900d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109010:	eb 40                	jmp    f0109052 <get_Share_id+0x85>
        	cprintf("Found ID : %x - Id : %x \n",founded->ID,sharedObjectID);
f0109012:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109015:	8b 00                	mov    (%eax),%eax
f0109017:	83 ec 04             	sub    $0x4,%esp
f010901a:	ff 75 08             	pushl  0x8(%ebp)
f010901d:	50                   	push   %eax
f010901e:	68 63 5b 12 f0       	push   $0xf0125b63
f0109023:	e8 63 7f ff ff       	call   f0100f8b <cprintf>
f0109028:	83 c4 10             	add    $0x10,%esp
            if(founded->ID == sharedObjectID)
f010902b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010902e:	8b 00                	mov    (%eax),%eax
f0109030:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109033:	75 15                	jne    f010904a <get_Share_id+0x7d>
            {
                release_spinlock(&AllShares.shareslock);
f0109035:	83 ec 0c             	sub    $0xc,%esp
f0109038:	68 50 05 6c f0       	push   $0xf06c0550
f010903d:	e8 5f 6c 00 00       	call   f010fca1 <release_spinlock>
f0109042:	83 c4 10             	add    $0x10,%esp
                return founded;
f0109045:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109048:	eb 44                	jmp    f010908e <get_Share_id+0xc1>
struct Share* get_Share_id(int32 sharedObjectID,void * va){
	 uint32 id = ((uint32)va << 1) >> 1;
	 cprintf("VA : %x \n",id);
    struct Share* founded = NULL;
        acquire_spinlock(&AllShares.shareslock);
        LIST_FOREACH(founded, &AllShares.shares_list) {
f010904a:	a1 48 05 6c f0       	mov    0xf06c0548,%eax
f010904f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109052:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109056:	74 08                	je     f0109060 <get_Share_id+0x93>
f0109058:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010905b:	8b 40 58             	mov    0x58(%eax),%eax
f010905e:	eb 05                	jmp    f0109065 <get_Share_id+0x98>
f0109060:	b8 00 00 00 00       	mov    $0x0,%eax
f0109065:	a3 48 05 6c f0       	mov    %eax,0xf06c0548
f010906a:	a1 48 05 6c f0       	mov    0xf06c0548,%eax
f010906f:	85 c0                	test   %eax,%eax
f0109071:	75 9f                	jne    f0109012 <get_Share_id+0x45>
f0109073:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109077:	75 99                	jne    f0109012 <get_Share_id+0x45>
            {
                release_spinlock(&AllShares.shareslock);
                return founded;
            }
        }
        release_spinlock(&AllShares.shareslock);
f0109079:	83 ec 0c             	sub    $0xc,%esp
f010907c:	68 50 05 6c f0       	push   $0xf06c0550
f0109081:	e8 1b 6c 00 00       	call   f010fca1 <release_spinlock>
f0109086:	83 c4 10             	add    $0x10,%esp
        return NULL;
f0109089:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010908e:	c9                   	leave  
f010908f:	c3                   	ret    

f0109090 <freeSharedObject>:
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0109090:	55                   	push   %ebp
f0109091:	89 e5                	mov    %esp,%ebp
f0109093:	83 ec 28             	sub    $0x28,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("freeSharedObject is not implemented yet");
    //Your Code is Here...
	struct Env* myenv = get_cpu_proc();
f0109096:	e8 f0 28 00 00       	call   f010b98b <get_cpu_proc>
f010909b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
f010909e:	83 ec 08             	sub    $0x8,%esp
f01090a1:	ff 75 0c             	pushl  0xc(%ebp)
f01090a4:	ff 75 08             	pushl  0x8(%ebp)
f01090a7:	e8 21 ff ff ff       	call   f0108fcd <get_Share_id>
f01090ac:	83 c4 10             	add    $0x10,%esp
f01090af:	89 45 ec             	mov    %eax,-0x14(%ebp)
        cprintf("245\n");
f01090b2:	83 ec 0c             	sub    $0xc,%esp
f01090b5:	68 7d 5b 12 f0       	push   $0xf0125b7d
f01090ba:	e8 cc 7e ff ff       	call   f0100f8b <cprintf>
f01090bf:	83 c4 10             	add    $0x10,%esp
        cprintf("Share : %x \n",ptr_share);
f01090c2:	83 ec 08             	sub    $0x8,%esp
f01090c5:	ff 75 ec             	pushl  -0x14(%ebp)
f01090c8:	68 82 5b 12 f0       	push   $0xf0125b82
f01090cd:	e8 b9 7e ff ff       	call   f0100f8b <cprintf>
f01090d2:	83 c4 10             	add    $0x10,%esp
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
f01090d5:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f01090dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01090df:	8b 40 48             	mov    0x48(%eax),%eax
f01090e2:	89 c2                	mov    %eax,%edx
f01090e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01090e7:	01 d0                	add    %edx,%eax
f01090e9:	48                   	dec    %eax
f01090ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01090ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01090f0:	ba 00 00 00 00       	mov    $0x0,%edx
f01090f5:	f7 75 e8             	divl   -0x18(%ebp)
f01090f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01090fb:	29 d0                	sub    %edx,%eax
f01090fd:	85 c0                	test   %eax,%eax
f01090ff:	79 05                	jns    f0109106 <freeSharedObject+0x76>
f0109101:	05 ff 0f 00 00       	add    $0xfff,%eax
f0109106:	c1 f8 0c             	sar    $0xc,%eax
f0109109:	89 45 e0             	mov    %eax,-0x20(%ebp)
        cprintf("Size : %d \n",ptr_share->size);
f010910c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010910f:	8b 40 48             	mov    0x48(%eax),%eax
f0109112:	83 ec 08             	sub    $0x8,%esp
f0109115:	50                   	push   %eax
f0109116:	68 8f 5b 12 f0       	push   $0xf0125b8f
f010911b:	e8 6b 7e ff ff       	call   f0100f8b <cprintf>
f0109120:	83 c4 10             	add    $0x10,%esp
        for(int k = 0;k<no_of_pages;k++)
f0109123:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010912a:	eb 33                	jmp    f010915f <freeSharedObject+0xcf>
		{
        	cprintf("250\n");
f010912c:	83 ec 0c             	sub    $0xc,%esp
f010912f:	68 9b 5b 12 f0       	push   $0xf0125b9b
f0109134:	e8 52 7e ff ff       	call   f0100f8b <cprintf>
f0109139:	83 c4 10             	add    $0x10,%esp
			unmap_frame(myenv->env_page_directory, (uint32)startVA + k*PAGE_SIZE);
f010913c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010913f:	c1 e0 0c             	shl    $0xc,%eax
f0109142:	89 c2                	mov    %eax,%edx
f0109144:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109147:	01 c2                	add    %eax,%edx
f0109149:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010914c:	8b 40 64             	mov    0x64(%eax),%eax
f010914f:	83 ec 08             	sub    $0x8,%esp
f0109152:	52                   	push   %edx
f0109153:	50                   	push   %eax
f0109154:	e8 86 f6 ff ff       	call   f01087df <unmap_frame>
f0109159:	83 c4 10             	add    $0x10,%esp
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
        cprintf("245\n");
        cprintf("Share : %x \n",ptr_share);
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
        cprintf("Size : %d \n",ptr_share->size);
        for(int k = 0;k<no_of_pages;k++)
f010915c:	ff 45 f4             	incl   -0xc(%ebp)
f010915f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109162:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0109165:	72 c5                	jb     f010912c <freeSharedObject+0x9c>
		{
        	cprintf("250\n");
			unmap_frame(myenv->env_page_directory, (uint32)startVA + k*PAGE_SIZE);
        	//free_frame(ptr_share->framesStorage[k]);
		}
        cprintf("251\n");
f0109167:	83 ec 0c             	sub    $0xc,%esp
f010916a:	68 a0 5b 12 f0       	push   $0xf0125ba0
f010916f:	e8 17 7e ff ff       	call   f0100f8b <cprintf>
f0109174:	83 c4 10             	add    $0x10,%esp
      /*  if((ptr_page_directory[PDX(startVA)])&PERM_USED){
        	cprintf("253\n");
            kfree((void *)ptr_page_directory[PDX(startVA)]);
        }*/
        cprintf("256\n");
f0109177:	83 ec 0c             	sub    $0xc,%esp
f010917a:	68 a5 5b 12 f0       	push   $0xf0125ba5
f010917f:	e8 07 7e ff ff       	call   f0100f8b <cprintf>
f0109184:	83 c4 10             	add    $0x10,%esp
        ptr_share->references--;
f0109187:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010918a:	8b 40 4c             	mov    0x4c(%eax),%eax
f010918d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109190:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109193:	89 50 4c             	mov    %edx,0x4c(%eax)
        if(ptr_share->references <= 1){
f0109196:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109199:	8b 40 4c             	mov    0x4c(%eax),%eax
f010919c:	83 f8 01             	cmp    $0x1,%eax
f010919f:	77 0e                	ja     f01091af <freeSharedObject+0x11f>
            free_share(ptr_share);
f01091a1:	83 ec 0c             	sub    $0xc,%esp
f01091a4:	ff 75 ec             	pushl  -0x14(%ebp)
f01091a7:	e8 44 fd ff ff       	call   f0108ef0 <free_share>
f01091ac:	83 c4 10             	add    $0x10,%esp
        }
        cprintf("261\n");
f01091af:	83 ec 0c             	sub    $0xc,%esp
f01091b2:	68 aa 5b 12 f0       	push   $0xf0125baa
f01091b7:	e8 cf 7d ff ff       	call   f0100f8b <cprintf>
f01091bc:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01091bf:	0f 20 d8             	mov    %cr3,%eax
f01091c2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01091c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01091c8:	0f 22 d8             	mov    %eax,%cr3
        tlbflush();
        return 0;
f01091cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01091d0:	c9                   	leave  
f01091d1:	c3                   	ret    

f01091d2 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f01091d2:	55                   	push   %ebp
f01091d3:	89 e5                	mov    %esp,%ebp
f01091d5:	a1 78 0b 6c f0       	mov    0xf06c0b78,%eax
f01091da:	83 f8 01             	cmp    $0x1,%eax
f01091dd:	75 04                	jne    f01091e3 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f01091df:	b0 01                	mov    $0x1,%al
f01091e1:	eb 02                	jmp    f01091e5 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f01091e3:	b0 00                	mov    $0x0,%al
f01091e5:	5d                   	pop    %ebp
f01091e6:	c3                   	ret    

f01091e7 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f01091e7:	55                   	push   %ebp
f01091e8:	89 e5                	mov    %esp,%ebp
f01091ea:	a1 78 0b 6c f0       	mov    0xf06c0b78,%eax
f01091ef:	83 f8 02             	cmp    $0x2,%eax
f01091f2:	75 04                	jne    f01091f8 <isKHeapPlacementStrategyBESTFIT+0x11>
f01091f4:	b0 01                	mov    $0x1,%al
f01091f6:	eb 02                	jmp    f01091fa <isKHeapPlacementStrategyBESTFIT+0x13>
f01091f8:	b0 00                	mov    $0x0,%al
f01091fa:	5d                   	pop    %ebp
f01091fb:	c3                   	ret    

f01091fc <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f01091fc:	55                   	push   %ebp
f01091fd:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f01091ff:	8b 45 08             	mov    0x8(%ebp),%eax
f0109202:	8b 15 e0 0a 6c f0    	mov    0xf06c0ae0,%edx
f0109208:	29 d0                	sub    %edx,%eax
f010920a:	c1 f8 03             	sar    $0x3,%eax
f010920d:	89 c2                	mov    %eax,%edx
f010920f:	89 d0                	mov    %edx,%eax
f0109211:	c1 e0 02             	shl    $0x2,%eax
f0109214:	01 d0                	add    %edx,%eax
f0109216:	c1 e0 02             	shl    $0x2,%eax
f0109219:	01 d0                	add    %edx,%eax
f010921b:	c1 e0 02             	shl    $0x2,%eax
f010921e:	01 d0                	add    %edx,%eax
f0109220:	89 c1                	mov    %eax,%ecx
f0109222:	c1 e1 08             	shl    $0x8,%ecx
f0109225:	01 c8                	add    %ecx,%eax
f0109227:	89 c1                	mov    %eax,%ecx
f0109229:	c1 e1 10             	shl    $0x10,%ecx
f010922c:	01 c8                	add    %ecx,%eax
f010922e:	01 c0                	add    %eax,%eax
f0109230:	01 d0                	add    %edx,%eax
}
f0109232:	5d                   	pop    %ebp
f0109233:	c3                   	ret    

f0109234 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0109234:	55                   	push   %ebp
f0109235:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0109237:	ff 75 08             	pushl  0x8(%ebp)
f010923a:	e8 bd ff ff ff       	call   f01091fc <to_frame_number>
f010923f:	83 c4 04             	add    $0x4,%esp
f0109242:	c1 e0 0c             	shl    $0xc,%eax
}
f0109245:	c9                   	leave  
f0109246:	c3                   	ret    

f0109247 <initialize_kheap_dynamic_allocator>:
//	Otherwise (if no memory OR initial size exceed the given limit): PANIC

uint32 no_pages_alloc[NUM_OF_KHEAP_PAGES];
uint32 to_virtual[1048576];
int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0109247:	55                   	push   %ebp
f0109248:	89 e5                	mov    %esp,%ebp
f010924a:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
	start = daStart;
f010924d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109250:	a3 28 0d 6c f0       	mov    %eax,0xf06c0d28
	hard_limit = daLimit;
f0109255:	8b 45 10             	mov    0x10(%ebp),%eax
f0109258:	a3 74 0b 6c f0       	mov    %eax,0xf06c0b74
	brk = daStart + initSizeToAllocate;
f010925d:	8b 55 08             	mov    0x8(%ebp),%edx
f0109260:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109263:	01 d0                	add    %edx,%eax
f0109265:	a3 20 0d 6c f0       	mov    %eax,0xf06c0d20

	if(brk > daLimit) panic("exceeds Limit");
f010926a:	a1 20 0d 6c f0       	mov    0xf06c0d20,%eax
f010926f:	3b 45 10             	cmp    0x10(%ebp),%eax
f0109272:	76 14                	jbe    f0109288 <initialize_kheap_dynamic_allocator+0x41>
f0109274:	83 ec 04             	sub    $0x4,%esp
f0109277:	68 b0 5b 12 f0       	push   $0xf0125bb0
f010927c:	6a 1a                	push   $0x1a
f010927e:	68 be 5b 12 f0       	push   $0xf0125bbe
f0109283:	e8 b1 70 ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f0109288:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f010928f:	8b 45 10             	mov    0x10(%ebp),%eax
f0109292:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 uint32 page_area_size = initSizeToAllocate;
f0109295:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109298:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f010929b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010929e:	c1 e8 0c             	shr    $0xc,%eax
f01092a1:	89 45 e4             	mov    %eax,-0x1c(%ebp)


	 for(int i=0;i<no_pages;i++)
f01092a4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01092ab:	e9 8a 00 00 00       	jmp    f010933a <initialize_kheap_dynamic_allocator+0xf3>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f01092b0:	83 ec 0c             	sub    $0xc,%esp
f01092b3:	8d 45 d8             	lea    -0x28(%ebp),%eax
f01092b6:	50                   	push   %eax
f01092b7:	e8 f6 ee ff ff       	call   f01081b2 <allocate_frame>
f01092bc:	83 c4 10             	add    $0x10,%esp
f01092bf:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(ret != E_NO_MEM)
f01092c2:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f01092c6:	74 5e                	je     f0109326 <initialize_kheap_dynamic_allocator+0xdf>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_WRITEABLE);
f01092c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01092cb:	c1 e0 0c             	shl    $0xc,%eax
f01092ce:	89 c2                	mov    %eax,%edx
f01092d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092d3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01092d6:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01092d9:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01092de:	6a 02                	push   $0x2
f01092e0:	51                   	push   %ecx
f01092e1:	52                   	push   %edx
f01092e2:	50                   	push   %eax
f01092e3:	e8 97 f3 ff ff       	call   f010867f <map_frame>
f01092e8:	83 c4 10             	add    $0x10,%esp
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
f01092eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01092ee:	c1 e0 0c             	shl    $0xc,%eax
f01092f1:	89 c2                	mov    %eax,%edx
f01092f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092f6:	01 d0                	add    %edx,%eax
f01092f8:	83 ec 0c             	sub    $0xc,%esp
f01092fb:	50                   	push   %eax
f01092fc:	e8 d6 04 00 00       	call   f01097d7 <kheap_physical_address>
f0109301:	83 c4 10             	add    $0x10,%esp
f0109304:	89 45 dc             	mov    %eax,-0x24(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
f0109307:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010930a:	c1 e8 0c             	shr    $0xc,%eax
f010930d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109310:	c1 e2 0c             	shl    $0xc,%edx
f0109313:	89 d1                	mov    %edx,%ecx
f0109315:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109318:	01 ca                	add    %ecx,%edx
f010931a:	89 14 85 c0 72 70 f0 	mov    %edx,-0xf8f8d40(,%eax,4)

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0109321:	ff 45 f4             	incl   -0xc(%ebp)
f0109324:	eb 14                	jmp    f010933a <initialize_kheap_dynamic_allocator+0xf3>
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
		}
		else
		{
			panic("No Memory");
f0109326:	83 ec 04             	sub    $0x4,%esp
f0109329:	68 cf 5b 12 f0       	push   $0xf0125bcf
f010932e:	6a 2f                	push   $0x2f
f0109330:	68 be 5b 12 f0       	push   $0xf0125bbe
f0109335:	e8 ff 6f ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f010933a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010933d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0109340:	0f 82 6a ff ff ff    	jb     f01092b0 <initialize_kheap_dynamic_allocator+0x69>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f0109346:	83 ec 08             	sub    $0x8,%esp
f0109349:	ff 75 0c             	pushl  0xc(%ebp)
f010934c:	ff 75 08             	pushl  0x8(%ebp)
f010934f:	e8 43 74 01 00       	call   f0120797 <initialize_dynamic_allocator>
f0109354:	83 c4 10             	add    $0x10,%esp

	return 0;
f0109357:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010935c:	c9                   	leave  
f010935d:	c3                   	ret    

f010935e <sbrk>:

void* sbrk(int numOfPages)
{
f010935e:	55                   	push   %ebp
f010935f:	89 e5                	mov    %esp,%ebp
f0109361:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f0109364:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109368:	0f 8e d6 00 00 00    	jle    f0109444 <sbrk+0xe6>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010936e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109371:	c1 e0 0c             	shl    $0xc,%eax
f0109374:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk=brk;
f0109377:	a1 20 0d 6c f0       	mov    0xf06c0d20,%eax
f010937c:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(brk+size > hard_limit) return (void *)-1;
f010937f:	8b 15 20 0d 6c f0    	mov    0xf06c0d20,%edx
f0109385:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109388:	01 c2                	add    %eax,%edx
f010938a:	a1 74 0b 6c f0       	mov    0xf06c0b74,%eax
f010938f:	39 c2                	cmp    %eax,%edx
f0109391:	76 0a                	jbe    f010939d <sbrk+0x3f>
f0109393:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109398:	e9 b9 00 00 00       	jmp    f0109456 <sbrk+0xf8>

		for(int i=0;i<numOfPages;i++)
f010939d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01093a4:	eb 7d                	jmp    f0109423 <sbrk+0xc5>
		{
			struct FrameInfo * ptr_frame;
			int ret = allocate_frame(&ptr_frame);
f01093a6:	83 ec 0c             	sub    $0xc,%esp
f01093a9:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01093ac:	50                   	push   %eax
f01093ad:	e8 00 ee ff ff       	call   f01081b2 <allocate_frame>
f01093b2:	83 c4 10             	add    $0x10,%esp
f01093b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(ret != E_NO_MEM)
f01093b8:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f01093bc:	74 5e                	je     f010941c <sbrk+0xbe>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_WRITEABLE);
f01093be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093c1:	c1 e0 0c             	shl    $0xc,%eax
f01093c4:	89 c2                	mov    %eax,%edx
f01093c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01093c9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01093cc:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01093cf:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01093d4:	6a 02                	push   $0x2
f01093d6:	51                   	push   %ecx
f01093d7:	52                   	push   %edx
f01093d8:	50                   	push   %eax
f01093d9:	e8 a1 f2 ff ff       	call   f010867f <map_frame>
f01093de:	83 c4 10             	add    $0x10,%esp
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
f01093e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093e4:	c1 e0 0c             	shl    $0xc,%eax
f01093e7:	89 c2                	mov    %eax,%edx
f01093e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01093ec:	01 d0                	add    %edx,%eax
f01093ee:	83 ec 0c             	sub    $0xc,%esp
f01093f1:	50                   	push   %eax
f01093f2:	e8 e0 03 00 00       	call   f01097d7 <kheap_physical_address>
f01093f7:	83 c4 10             	add    $0x10,%esp
f01093fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
f01093fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109400:	c1 e8 0c             	shr    $0xc,%eax
f0109403:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109406:	c1 e2 0c             	shl    $0xc,%edx
f0109409:	89 d1                	mov    %edx,%ecx
f010940b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010940e:	01 ca                	add    %ecx,%edx
f0109410:	89 14 85 c0 72 70 f0 	mov    %edx,-0xf8f8d40(,%eax,4)
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109417:	ff 45 f4             	incl   -0xc(%ebp)
f010941a:	eb 07                	jmp    f0109423 <sbrk+0xc5>
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
			}
			else
			{
				return (void *)-1;
f010941c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109421:	eb 33                	jmp    f0109456 <sbrk+0xf8>
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109423:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109426:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109429:	0f 8c 77 ff ff ff    	jl     f01093a6 <sbrk+0x48>
			else
			{
				return (void *)-1;
			}
		}
		brk += size;
f010942f:	8b 15 20 0d 6c f0    	mov    0xf06c0d20,%edx
f0109435:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109438:	01 d0                	add    %edx,%eax
f010943a:	a3 20 0d 6c f0       	mov    %eax,0xf06c0d20
		return (void *)prev_brk;
f010943f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109442:	eb 12                	jmp    f0109456 <sbrk+0xf8>

	}
	else if(numOfPages == 0)
f0109444:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109448:	75 07                	jne    f0109451 <sbrk+0xf3>
	{
		return (void *) brk;
f010944a:	a1 20 0d 6c f0       	mov    0xf06c0d20,%eax
f010944f:	eb 05                	jmp    f0109456 <sbrk+0xf8>
	}

	return (void *)-1;
f0109451:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0109456:	c9                   	leave  
f0109457:	c3                   	ret    

f0109458 <isPageAllocated>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator
bool isPageAllocated(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f0109458:	55                   	push   %ebp
f0109459:	89 e5                	mov    %esp,%ebp
f010945b:	83 ec 18             	sub    $0x18,%esp
	uint32* ptr_pageTable = NULL;
f010945e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_pageTable);
f0109465:	83 ec 04             	sub    $0x4,%esp
f0109468:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010946b:	50                   	push   %eax
f010946c:	ff 75 0c             	pushl  0xc(%ebp)
f010946f:	ff 75 08             	pushl  0x8(%ebp)
f0109472:	e8 f2 f2 ff ff       	call   f0108769 <get_frame_info>
f0109477:	83 c4 10             	add    $0x10,%esp
f010947a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_frame_info == NULL) return 0;
f010947d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109481:	75 07                	jne    f010948a <isPageAllocated+0x32>
f0109483:	b8 00 00 00 00       	mov    $0x0,%eax
f0109488:	eb 05                	jmp    f010948f <isPageAllocated+0x37>
	return 1;
f010948a:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010948f:	c9                   	leave  
f0109490:	c3                   	ret    

f0109491 <kmalloc>:

void *kmalloc(unsigned int size)
{
f0109491:	55                   	push   %ebp
f0109492:	89 e5                	mov    %esp,%ebp
f0109494:	83 ec 48             	sub    $0x48,%esp
	// TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	//  Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0109497:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f010949e:	8b 55 08             	mov    0x8(%ebp),%edx
f01094a1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01094a4:	01 d0                	add    %edx,%eax
f01094a6:	48                   	dec    %eax
f01094a7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01094aa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01094ad:	ba 00 00 00 00       	mov    $0x0,%edx
f01094b2:	f7 75 d8             	divl   -0x28(%ebp)
f01094b5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01094b8:	29 d0                	sub    %edx,%eax
f01094ba:	c1 e8 0c             	shr    $0xc,%eax
f01094bd:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 max_no_of_pages = ROUNDUP((uint32)KERNEL_HEAP_MAX - hard_limit + (uint32)PAGE_SIZE ,PAGE_SIZE) / PAGE_SIZE;
f01094c0:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f01094c7:	a1 74 0b 6c f0       	mov    0xf06c0b74,%eax
f01094cc:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01094cf:	29 c2                	sub    %eax,%edx
f01094d1:	89 d0                	mov    %edx,%eax
f01094d3:	48                   	dec    %eax
f01094d4:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01094d7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01094da:	ba 00 00 00 00       	mov    $0x0,%edx
f01094df:	f7 75 cc             	divl   -0x34(%ebp)
f01094e2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01094e5:	29 d0                	sub    %edx,%eax
f01094e7:	c1 e8 0c             	shr    $0xc,%eax
f01094ea:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	void *ptr = NULL;
f01094ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f01094f4:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f01094fb:	77 42                	ja     f010953f <kmalloc+0xae>
	{
		if (isKHeapPlacementStrategyFIRSTFIT())
f01094fd:	e8 d0 fc ff ff       	call   f01091d2 <isKHeapPlacementStrategyFIRSTFIT>
f0109502:	84 c0                	test   %al,%al
f0109504:	74 16                	je     f010951c <kmalloc+0x8b>
			ptr = alloc_block_FF(size);
f0109506:	83 ec 0c             	sub    $0xc,%esp
f0109509:	ff 75 08             	pushl  0x8(%ebp)
f010950c:	e8 a2 74 01 00       	call   f01209b3 <alloc_block_FF>
f0109511:	83 c4 10             	add    $0x10,%esp
f0109514:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109517:	e9 d0 01 00 00       	jmp    f01096ec <kmalloc+0x25b>
		else if (isKHeapPlacementStrategyBESTFIT())
f010951c:	e8 c6 fc ff ff       	call   f01091e7 <isKHeapPlacementStrategyBESTFIT>
f0109521:	84 c0                	test   %al,%al
f0109523:	0f 84 c3 01 00 00    	je     f01096ec <kmalloc+0x25b>
			ptr = alloc_block_BF(size);
f0109529:	83 ec 0c             	sub    $0xc,%esp
f010952c:	ff 75 08             	pushl  0x8(%ebp)
f010952f:	e8 3b 79 01 00       	call   f0120e6f <alloc_block_BF>
f0109534:	83 c4 10             	add    $0x10,%esp
f0109537:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010953a:	e9 ad 01 00 00       	jmp    f01096ec <kmalloc+0x25b>
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
f010953f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109542:	48                   	dec    %eax
f0109543:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0109546:	0f 86 99 01 00 00    	jbe    f01096e5 <kmalloc+0x254>
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
f010954c:	a1 74 0b 6c f0       	mov    0xf06c0b74,%eax
f0109551:	05 00 10 00 00       	add    $0x1000,%eax
f0109556:	89 45 f0             	mov    %eax,-0x10(%ebp)
		bool ok = 0;
f0109559:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		while (i < (uint32)KERNEL_HEAP_MAX)
f0109560:	e9 86 00 00 00       	jmp    f01095eb <kmalloc+0x15a>
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
f0109565:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f010956a:	83 ec 08             	sub    $0x8,%esp
f010956d:	ff 75 f0             	pushl  -0x10(%ebp)
f0109570:	50                   	push   %eax
f0109571:	e8 e2 fe ff ff       	call   f0109458 <isPageAllocated>
f0109576:	83 c4 10             	add    $0x10,%esp
f0109579:	85 c0                	test   %eax,%eax
f010957b:	75 61                	jne    f01095de <kmalloc+0x14d>
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
f010957d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109580:	05 00 10 00 00       	add    $0x1000,%eax
f0109585:	89 45 e8             	mov    %eax,-0x18(%ebp)
				uint32 cnt = 0;
f0109588:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < num_pages - 1)
f010958f:	eb 3d                	jmp    f01095ce <kmalloc+0x13d>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX) return NULL;
f0109591:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f0109598:	76 0a                	jbe    f01095a4 <kmalloc+0x113>
f010959a:	b8 00 00 00 00       	mov    $0x0,%eax
f010959f:	e9 4b 01 00 00       	jmp    f01096ef <kmalloc+0x25e>
					if (isPageAllocated(ptr_page_directory, j))
f01095a4:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01095a9:	83 ec 08             	sub    $0x8,%esp
f01095ac:	ff 75 e8             	pushl  -0x18(%ebp)
f01095af:	50                   	push   %eax
f01095b0:	e8 a3 fe ff ff       	call   f0109458 <isPageAllocated>
f01095b5:	83 c4 10             	add    $0x10,%esp
f01095b8:	85 c0                	test   %eax,%eax
f01095ba:	74 08                	je     f01095c4 <kmalloc+0x133>
					{

						i = j;
f01095bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01095bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
						goto sayed;
f01095c2:	eb 1a                	jmp    f01095de <kmalloc+0x14d>
					}

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++
f01095c4:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)

					cnt++;
f01095cb:	ff 45 e4             	incl   -0x1c(%ebp)
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
				uint32 cnt = 0;
				while(cnt < num_pages - 1)
f01095ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01095d1:	48                   	dec    %eax
f01095d2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01095d5:	77 ba                	ja     f0109591 <kmalloc+0x100>

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++

					cnt++;
				}
				ok = 1;
f01095d7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			}
			sayed:
			if(ok)
f01095de:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01095e2:	75 16                	jne    f01095fa <kmalloc+0x169>
			{
				break;
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
f01095e4:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
		bool ok = 0;
		while (i < (uint32)KERNEL_HEAP_MAX)
f01095eb:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f01095f2:	0f 86 6d ff ff ff    	jbe    f0109565 <kmalloc+0xd4>
f01095f8:	eb 01                	jmp    f01095fb <kmalloc+0x16a>
				ok = 1;
			}
			sayed:
			if(ok)
			{
				break;
f01095fa:	90                   	nop
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
f01095fb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01095ff:	75 0a                	jne    f010960b <kmalloc+0x17a>
f0109601:	b8 00 00 00 00       	mov    $0x0,%eax
f0109606:	e9 e4 00 00 00       	jmp    f01096ef <kmalloc+0x25e>
		for (int k = 0; k < num_pages; k++)
f010960b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109612:	eb 57                	jmp    f010966b <kmalloc+0x1da>
		{
			struct FrameInfo *ptr_frame_info;
			int ret = allocate_frame(&ptr_frame_info);
f0109614:	83 ec 0c             	sub    $0xc,%esp
f0109617:	8d 45 b8             	lea    -0x48(%ebp),%eax
f010961a:	50                   	push   %eax
f010961b:	e8 92 eb ff ff       	call   f01081b2 <allocate_frame>
f0109620:	83 c4 10             	add    $0x10,%esp
f0109623:	89 45 c0             	mov    %eax,-0x40(%ebp)
			if (ret != E_NO_MEM)
f0109626:	83 7d c0 fc          	cmpl   $0xfffffffc,-0x40(%ebp)
f010962a:	74 28                	je     f0109654 <kmalloc+0x1c3>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE); // a3raf el page mnen
f010962c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010962f:	c1 e0 0c             	shl    $0xc,%eax
f0109632:	89 c2                	mov    %eax,%edx
f0109634:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109637:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010963a:	8b 55 b8             	mov    -0x48(%ebp),%edx
f010963d:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0109642:	6a 02                	push   $0x2
f0109644:	51                   	push   %ecx
f0109645:	52                   	push   %edx
f0109646:	50                   	push   %eax
f0109647:	e8 33 f0 ff ff       	call   f010867f <map_frame>
f010964c:	83 c4 10             	add    $0x10,%esp
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f010964f:	ff 45 e0             	incl   -0x20(%ebp)
f0109652:	eb 17                	jmp    f010966b <kmalloc+0x1da>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE); // a3raf el page mnen
			}
			else
			{
				panic("No Memory");
f0109654:	83 ec 04             	sub    $0x4,%esp
f0109657:	68 cf 5b 12 f0       	push   $0xf0125bcf
f010965c:	68 b5 00 00 00       	push   $0xb5
f0109661:	68 be 5b 12 f0       	push   $0xf0125bbe
f0109666:	e8 ce 6c ff ff       	call   f0100339 <_panic>
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f010966b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010966e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0109671:	72 a1                	jb     f0109614 <kmalloc+0x183>
			else
			{
				panic("No Memory");
			}
		}
		ptr = (void*)i;
f0109673:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109676:	89 45 f4             	mov    %eax,-0xc(%ebp)

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;
f0109679:	a1 74 0b 6c f0       	mov    0xf06c0b74,%eax
f010967e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109681:	29 c2                	sub    %eax,%edx
f0109683:	89 d0                	mov    %edx,%eax
f0109685:	2d 00 10 00 00       	sub    $0x1000,%eax
f010968a:	c1 e8 0c             	shr    $0xc,%eax
f010968d:	89 c2                	mov    %eax,%edx
f010968f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109692:	89 04 95 c0 f2 6d f0 	mov    %eax,-0xf920d40(,%edx,4)

		for(int i = 0; i < num_pages; i++){
f0109699:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01096a0:	eb 39                	jmp    f01096db <kmalloc+0x24a>
			uint32 pa = kheap_physical_address((uint32)ptr + i * PAGE_SIZE);
f01096a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01096a5:	c1 e0 0c             	shl    $0xc,%eax
f01096a8:	89 c2                	mov    %eax,%edx
f01096aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01096ad:	01 d0                	add    %edx,%eax
f01096af:	83 ec 0c             	sub    $0xc,%esp
f01096b2:	50                   	push   %eax
f01096b3:	e8 1f 01 00 00       	call   f01097d7 <kheap_physical_address>
f01096b8:	83 c4 10             	add    $0x10,%esp
f01096bb:	89 45 bc             	mov    %eax,-0x44(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
f01096be:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01096c1:	c1 e8 0c             	shr    $0xc,%eax
f01096c4:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01096c7:	c1 e2 0c             	shl    $0xc,%edx
f01096ca:	89 d1                	mov    %edx,%ecx
f01096cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01096cf:	01 ca                	add    %ecx,%edx
f01096d1:	89 14 85 c0 72 70 f0 	mov    %edx,-0xf8f8d40(,%eax,4)
		}
		ptr = (void*)i;

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;

		for(int i = 0; i < num_pages; i++){
f01096d8:	ff 45 dc             	incl   -0x24(%ebp)
f01096db:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01096de:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01096e1:	72 bf                	jb     f01096a2 <kmalloc+0x211>
f01096e3:	eb 07                	jmp    f01096ec <kmalloc+0x25b>
		}
	}
	else
	{

		return NULL;
f01096e5:	b8 00 00 00 00       	mov    $0x0,%eax
f01096ea:	eb 03                	jmp    f01096ef <kmalloc+0x25e>
	}
	return ptr;
f01096ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01096ef:	c9                   	leave  
f01096f0:	c3                   	ret    

f01096f1 <kfree>:

void kfree(void *va)
{
f01096f1:	55                   	push   %ebp
f01096f2:	89 e5                	mov    %esp,%ebp
f01096f4:	83 ec 18             	sub    $0x18,%esp
    //  Write your code here, remove the panic and write your code
//    panic("kfree() is not implemented yet...!!");

    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
f01096f7:	a1 74 0b 6c f0       	mov    0xf06c0b74,%eax
f01096fc:	05 00 10 00 00       	add    $0x1000,%eax
f0109701:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if((uint32)va < hard_limit){
f0109704:	8b 55 08             	mov    0x8(%ebp),%edx
f0109707:	a1 74 0b 6c f0       	mov    0xf06c0b74,%eax
f010970c:	39 c2                	cmp    %eax,%edx
f010970e:	73 13                	jae    f0109723 <kfree+0x32>
        free_block(va);
f0109710:	83 ec 0c             	sub    $0xc,%esp
f0109713:	ff 75 08             	pushl  0x8(%ebp)
f0109716:	e8 5c 81 01 00       	call   f0121877 <free_block>
f010971b:	83 c4 10             	add    $0x10,%esp
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
		}
    } else{
        panic("kfree: The virtual Address is invalid");
    }
}
f010971e:	e9 b1 00 00 00       	jmp    f01097d4 <kfree+0xe3>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109723:	8b 45 08             	mov    0x8(%ebp),%eax
f0109726:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0109729:	0f 82 8e 00 00 00    	jb     f01097bd <kfree+0xcc>
f010972f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109732:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f0109737:	0f 87 80 00 00 00    	ja     f01097bd <kfree+0xcc>
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
f010973d:	8b 55 08             	mov    0x8(%ebp),%edx
f0109740:	a1 74 0b 6c f0       	mov    0xf06c0b74,%eax
f0109745:	29 c2                	sub    %eax,%edx
f0109747:	89 d0                	mov    %edx,%eax
f0109749:	2d 00 10 00 00       	sub    $0x1000,%eax
f010974e:	c1 e8 0c             	shr    $0xc,%eax
f0109751:	8b 04 85 c0 f2 6d f0 	mov    -0xf920d40(,%eax,4),%eax
f0109758:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f010975b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109762:	eb 4f                	jmp    f01097b3 <kfree+0xc2>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
f0109764:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109767:	c1 e0 0c             	shl    $0xc,%eax
f010976a:	89 c2                	mov    %eax,%edx
f010976c:	8b 45 08             	mov    0x8(%ebp),%eax
f010976f:	01 d0                	add    %edx,%eax
f0109771:	83 ec 0c             	sub    $0xc,%esp
f0109774:	50                   	push   %eax
f0109775:	e8 5d 00 00 00       	call   f01097d7 <kheap_physical_address>
f010977a:	83 c4 10             	add    $0x10,%esp
f010977d:	89 45 e8             	mov    %eax,-0x18(%ebp)
			to_virtual[pa / PAGE_SIZE] = 0;
f0109780:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109783:	c1 e8 0c             	shr    $0xc,%eax
f0109786:	c7 04 85 c0 72 70 f0 	movl   $0x0,-0xf8f8d40(,%eax,4)
f010978d:	00 00 00 00 
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
f0109791:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109794:	c1 e0 0c             	shl    $0xc,%eax
f0109797:	89 c2                	mov    %eax,%edx
f0109799:	8b 45 08             	mov    0x8(%ebp),%eax
f010979c:	01 c2                	add    %eax,%edx
f010979e:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01097a3:	83 ec 08             	sub    $0x8,%esp
f01097a6:	52                   	push   %edx
f01097a7:	50                   	push   %eax
f01097a8:	e8 32 f0 ff ff       	call   f01087df <unmap_frame>
f01097ad:	83 c4 10             	add    $0x10,%esp
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
		for(int i = 0; i < no_of_pages; i++){
f01097b0:	ff 45 f4             	incl   -0xc(%ebp)
f01097b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01097b6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01097b9:	72 a9                	jb     f0109764 <kfree+0x73>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f01097bb:	eb 17                	jmp    f01097d4 <kfree+0xe3>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = 0;
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
		}
    } else{
        panic("kfree: The virtual Address is invalid");
f01097bd:	83 ec 04             	sub    $0x4,%esp
f01097c0:	68 dc 5b 12 f0       	push   $0xf0125bdc
f01097c5:	68 dc 00 00 00       	push   $0xdc
f01097ca:	68 be 5b 12 f0       	push   $0xf0125bbe
f01097cf:	e8 65 6b ff ff       	call   f0100339 <_panic>
    }
}
f01097d4:	90                   	nop
f01097d5:	c9                   	leave  
f01097d6:	c3                   	ret    

f01097d7 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int va)
{
f01097d7:	55                   	push   %ebp
f01097d8:	89 e5                	mov    %esp,%ebp
f01097da:	83 ec 18             	sub    $0x18,%esp
	// return the physical address corresponding to given virtual_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	uint32* ptr_page_table = NULL;
f01097dd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, va, &ptr_page_table);
f01097e4:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01097e9:	83 ec 04             	sub    $0x4,%esp
f01097ec:	8d 55 e8             	lea    -0x18(%ebp),%edx
f01097ef:	52                   	push   %edx
f01097f0:	ff 75 08             	pushl  0x8(%ebp)
f01097f3:	50                   	push   %eax
f01097f4:	e8 70 ef ff ff       	call   f0108769 <get_frame_info>
f01097f9:	83 c4 10             	add    $0x10,%esp
f01097fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_frame_info == NULL){
f01097ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109803:	75 07                	jne    f010980c <kheap_physical_address+0x35>
		return 0;
f0109805:	b8 00 00 00 00       	mov    $0x0,%eax
f010980a:	eb 26                	jmp    f0109832 <kheap_physical_address+0x5b>
	}

	uint32 offset = PGOFF(va);
f010980c:	8b 45 08             	mov    0x8(%ebp),%eax
f010980f:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109814:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 pa = to_physical_address(ptr_frame_info) + offset;
f0109817:	83 ec 0c             	sub    $0xc,%esp
f010981a:	ff 75 f4             	pushl  -0xc(%ebp)
f010981d:	e8 12 fa ff ff       	call   f0109234 <to_physical_address>
f0109822:	83 c4 10             	add    $0x10,%esp
f0109825:	89 c2                	mov    %eax,%edx
f0109827:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010982a:	01 d0                	add    %edx,%eax
f010982c:	89 45 ec             	mov    %eax,-0x14(%ebp)


	return pa;
f010982f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0109832:	c9                   	leave  
f0109833:	c3                   	ret    

f0109834 <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0109834:	55                   	push   %ebp
f0109835:	89 e5                	mov    %esp,%ebp
f0109837:	83 ec 10             	sub    $0x10,%esp
	// return the virtual address corresponding to given physical_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	////////////get it in block Allocator//////////////////
	uint32 offset = PGOFF(physical_address);
f010983a:	8b 45 08             	mov    0x8(%ebp),%eax
f010983d:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109842:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32 va = to_virtual[physical_address / PAGE_SIZE];
f0109845:	8b 45 08             	mov    0x8(%ebp),%eax
f0109848:	c1 e8 0c             	shr    $0xc,%eax
f010984b:	8b 04 85 c0 72 70 f0 	mov    -0xf8f8d40(,%eax,4),%eax
f0109852:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(va) va += offset;
f0109855:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0109859:	74 06                	je     f0109861 <kheap_virtual_address+0x2d>
f010985b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010985e:	01 45 fc             	add    %eax,-0x4(%ebp)
	return va;
f0109861:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0109864:	c9                   	leave  
f0109865:	c3                   	ret    

f0109866 <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *va, uint32 new_size)
{
f0109866:	55                   	push   %ebp
f0109867:	89 e5                	mov    %esp,%ebp
f0109869:	83 ec 58             	sub    $0x58,%esp
	// TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	//  Write your code here, remove the panic and write your code
	//return NULL;
//	panic("krealloc() is not implemented yet...!!");
	void *ptr = NULL;
f010986c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if(va == NULL){
f0109873:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109877:	75 16                	jne    f010988f <krealloc+0x29>
		ptr = kmalloc(new_size);
f0109879:	83 ec 0c             	sub    $0xc,%esp
f010987c:	ff 75 0c             	pushl  0xc(%ebp)
f010987f:	e8 0d fc ff ff       	call   f0109491 <kmalloc>
f0109884:	83 c4 10             	add    $0x10,%esp
f0109887:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010988a:	e9 37 03 00 00       	jmp    f0109bc6 <krealloc+0x360>
	} else if(new_size == 0){
f010988f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0109893:	75 13                	jne    f01098a8 <krealloc+0x42>
		kfree(va);
f0109895:	83 ec 0c             	sub    $0xc,%esp
f0109898:	ff 75 08             	pushl  0x8(%ebp)
f010989b:	e8 51 fe ff ff       	call   f01096f1 <kfree>
f01098a0:	83 c4 10             	add    $0x10,%esp
f01098a3:	e9 1e 03 00 00       	jmp    f0109bc6 <krealloc+0x360>
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
f01098a8:	a1 74 0b 6c f0       	mov    0xf06c0b74,%eax
f01098ad:	05 00 10 00 00       	add    $0x1000,%eax
f01098b2:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)va < hard_limit){
f01098b5:	8b 55 08             	mov    0x8(%ebp),%edx
f01098b8:	a1 74 0b 6c f0       	mov    0xf06c0b74,%eax
f01098bd:	39 c2                	cmp    %eax,%edx
f01098bf:	73 19                	jae    f01098da <krealloc+0x74>
			ptr = realloc_block_FF(va, new_size);
f01098c1:	83 ec 08             	sub    $0x8,%esp
f01098c4:	ff 75 0c             	pushl  0xc(%ebp)
f01098c7:	ff 75 08             	pushl  0x8(%ebp)
f01098ca:	e8 a8 80 01 00       	call   f0121977 <realloc_block_FF>
f01098cf:	83 c4 10             	add    $0x10,%esp
f01098d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01098d5:	e9 ec 02 00 00       	jmp    f0109bc6 <krealloc+0x360>
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f01098da:	8b 45 08             	mov    0x8(%ebp),%eax
f01098dd:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01098e0:	0f 82 c8 02 00 00    	jb     f0109bae <krealloc+0x348>
f01098e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01098e9:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f01098ee:	0f 87 ba 02 00 00    	ja     f0109bae <krealloc+0x348>
			uint32 num_pages = ROUNDUP(new_size ,PAGE_SIZE) / PAGE_SIZE;
f01098f4:	c7 45 d4 00 10 00 00 	movl   $0x1000,-0x2c(%ebp)
f01098fb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01098fe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109901:	01 d0                	add    %edx,%eax
f0109903:	48                   	dec    %eax
f0109904:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0109907:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010990a:	ba 00 00 00 00       	mov    $0x0,%edx
f010990f:	f7 75 d4             	divl   -0x2c(%ebp)
f0109912:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109915:	29 d0                	sub    %edx,%eax
f0109917:	c1 e8 0c             	shr    $0xc,%eax
f010991a:	89 45 cc             	mov    %eax,-0x34(%ebp)
			uint32 num_old_pages = no_pages_alloc[(uint32)va / PAGE_SIZE];
f010991d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109920:	c1 e8 0c             	shr    $0xc,%eax
f0109923:	8b 04 85 c0 f2 6d f0 	mov    -0xf920d40(,%eax,4),%eax
f010992a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if(num_pages <= num_old_pages){
f010992d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109930:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0109933:	0f 87 ee 00 00 00    	ja     f0109a27 <krealloc+0x1c1>
				if (new_size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f0109939:	81 7d 0c 00 08 00 00 	cmpl   $0x800,0xc(%ebp)
f0109940:	77 63                	ja     f01099a5 <krealloc+0x13f>
				{
					if (isKHeapPlacementStrategyFIRSTFIT())
f0109942:	e8 8b f8 ff ff       	call   f01091d2 <isKHeapPlacementStrategyFIRSTFIT>
f0109947:	84 c0                	test   %al,%al
f0109949:	74 13                	je     f010995e <krealloc+0xf8>
						ptr = alloc_block_FF(new_size);
f010994b:	83 ec 0c             	sub    $0xc,%esp
f010994e:	ff 75 0c             	pushl  0xc(%ebp)
f0109951:	e8 5d 70 01 00       	call   f01209b3 <alloc_block_FF>
f0109956:	83 c4 10             	add    $0x10,%esp
f0109959:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010995c:	eb 1a                	jmp    f0109978 <krealloc+0x112>
					else if (isKHeapPlacementStrategyBESTFIT())
f010995e:	e8 84 f8 ff ff       	call   f01091e7 <isKHeapPlacementStrategyBESTFIT>
f0109963:	84 c0                	test   %al,%al
f0109965:	74 11                	je     f0109978 <krealloc+0x112>
						ptr = alloc_block_BF(new_size);
f0109967:	83 ec 0c             	sub    $0xc,%esp
f010996a:	ff 75 0c             	pushl  0xc(%ebp)
f010996d:	e8 fd 74 01 00       	call   f0120e6f <alloc_block_BF>
f0109972:	83 c4 10             	add    $0x10,%esp
f0109975:	89 45 f4             	mov    %eax,-0xc(%ebp)
					if(ptr != NULL) memcpy(ptr, va, new_size);
f0109978:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010997c:	74 14                	je     f0109992 <krealloc+0x12c>
f010997e:	83 ec 04             	sub    $0x4,%esp
f0109981:	ff 75 0c             	pushl  0xc(%ebp)
f0109984:	ff 75 08             	pushl  0x8(%ebp)
f0109987:	ff 75 f4             	pushl  -0xc(%ebp)
f010998a:	e8 57 64 01 00       	call   f011fde6 <memcpy>
f010998f:	83 c4 10             	add    $0x10,%esp
					kfree(va);
f0109992:	83 ec 0c             	sub    $0xc,%esp
f0109995:	ff 75 08             	pushl  0x8(%ebp)
f0109998:	e8 54 fd ff ff       	call   f01096f1 <kfree>
f010999d:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f01099a0:	e9 20 02 00 00       	jmp    f0109bc5 <krealloc+0x35f>
					else if (isKHeapPlacementStrategyBESTFIT())
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
f01099a5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01099a8:	c1 e0 0c             	shl    $0xc,%eax
f01099ab:	89 c2                	mov    %eax,%edx
f01099ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01099b0:	01 d0                	add    %edx,%eax
f01099b2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f01099b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01099bc:	eb 4f                	jmp    f0109a0d <krealloc+0x1a7>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
f01099be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01099c1:	c1 e0 0c             	shl    $0xc,%eax
f01099c4:	89 c2                	mov    %eax,%edx
f01099c6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01099c9:	01 d0                	add    %edx,%eax
f01099cb:	83 ec 0c             	sub    $0xc,%esp
f01099ce:	50                   	push   %eax
f01099cf:	e8 03 fe ff ff       	call   f01097d7 <kheap_physical_address>
f01099d4:	83 c4 10             	add    $0x10,%esp
f01099d7:	89 45 c0             	mov    %eax,-0x40(%ebp)
						to_virtual[pa / PAGE_SIZE] = 0;
f01099da:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01099dd:	c1 e8 0c             	shr    $0xc,%eax
f01099e0:	c7 04 85 c0 72 70 f0 	movl   $0x0,-0xf8f8d40(,%eax,4)
f01099e7:	00 00 00 00 
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
f01099eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01099ee:	c1 e0 0c             	shl    $0xc,%eax
f01099f1:	89 c2                	mov    %eax,%edx
f01099f3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01099f6:	01 c2                	add    %eax,%edx
f01099f8:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01099fd:	83 ec 08             	sub    $0x8,%esp
f0109a00:	52                   	push   %edx
f0109a01:	50                   	push   %eax
f0109a02:	e8 d8 ed ff ff       	call   f01087df <unmap_frame>
f0109a07:	83 c4 10             	add    $0x10,%esp
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109a0a:	ff 45 f0             	incl   -0x10(%ebp)
f0109a0d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109a10:	2b 45 cc             	sub    -0x34(%ebp),%eax
f0109a13:	89 c2                	mov    %eax,%edx
f0109a15:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a18:	39 c2                	cmp    %eax,%edx
f0109a1a:	77 a2                	ja     f01099be <krealloc+0x158>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
						to_virtual[pa / PAGE_SIZE] = 0;
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
f0109a1c:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109a22:	e9 9e 01 00 00       	jmp    f0109bc5 <krealloc+0x35f>
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
f0109a27:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109a2a:	c1 e0 0c             	shl    $0xc,%eax
f0109a2d:	89 c2                	mov    %eax,%edx
f0109a2f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a32:	01 d0                	add    %edx,%eax
f0109a34:	89 45 ec             	mov    %eax,-0x14(%ebp)
				uint32 cnt = 0;
f0109a37:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				bool found_free_pages = 0;
f0109a3e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < (num_pages - num_old_pages))
f0109a45:	eb 33                	jmp    f0109a7a <krealloc+0x214>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
f0109a47:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f0109a4e:	0f 87 19 01 00 00    	ja     f0109b6d <krealloc+0x307>
f0109a54:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0109a59:	83 ec 08             	sub    $0x8,%esp
f0109a5c:	ff 75 ec             	pushl  -0x14(%ebp)
f0109a5f:	50                   	push   %eax
f0109a60:	e8 f3 f9 ff ff       	call   f0109458 <isPageAllocated>
f0109a65:	83 c4 10             	add    $0x10,%esp
f0109a68:	85 c0                	test   %eax,%eax
f0109a6a:	0f 85 fd 00 00 00    	jne    f0109b6d <krealloc+0x307>
					j += (uint32)PAGE_SIZE;
f0109a70:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
					cnt++;
f0109a77:	ff 45 e8             	incl   -0x18(%ebp)
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
				uint32 cnt = 0;
				bool found_free_pages = 0;
				while(cnt < (num_pages - num_old_pages))
f0109a7a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109a7d:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109a80:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109a83:	77 c2                	ja     f0109a47 <krealloc+0x1e1>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
f0109a85:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109a8c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109a93:	eb 5c                	jmp    f0109af1 <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
f0109a95:	83 ec 0c             	sub    $0xc,%esp
f0109a98:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0109a9b:	50                   	push   %eax
f0109a9c:	e8 11 e7 ff ff       	call   f01081b2 <allocate_frame>
f0109aa1:	83 c4 10             	add    $0x10,%esp
f0109aa4:	89 45 bc             	mov    %eax,-0x44(%ebp)
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
f0109aa7:	83 7d bc fc          	cmpl   $0xfffffffc,-0x44(%ebp)
f0109aab:	74 2d                	je     f0109ada <krealloc+0x274>
f0109aad:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109ab0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109ab3:	01 d0                	add    %edx,%eax
f0109ab5:	c1 e0 0c             	shl    $0xc,%eax
f0109ab8:	89 c2                	mov    %eax,%edx
f0109aba:	8b 45 08             	mov    0x8(%ebp),%eax
f0109abd:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109ac0:	8b 55 b4             	mov    -0x4c(%ebp),%edx
f0109ac3:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0109ac8:	6a 02                	push   $0x2
f0109aca:	51                   	push   %ecx
f0109acb:	52                   	push   %edx
f0109acc:	50                   	push   %eax
f0109acd:	e8 ad eb ff ff       	call   f010867f <map_frame>
f0109ad2:	83 c4 10             	add    $0x10,%esp
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109ad5:	ff 45 e0             	incl   -0x20(%ebp)
f0109ad8:	eb 17                	jmp    f0109af1 <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
f0109ada:	83 ec 04             	sub    $0x4,%esp
f0109add:	68 cf 5b 12 f0       	push   $0xf0125bcf
f0109ae2:	68 49 01 00 00       	push   $0x149
f0109ae7:	68 be 5b 12 f0       	push   $0xf0125bbe
f0109aec:	e8 48 68 ff ff       	call   f0100339 <_panic>
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109af1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109af4:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109af7:	89 c2                	mov    %eax,%edx
f0109af9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109afc:	39 c2                	cmp    %eax,%edx
f0109afe:	77 95                	ja     f0109a95 <krealloc+0x22f>
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
f0109b00:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b03:	c1 e8 0c             	shr    $0xc,%eax
f0109b06:	89 c2                	mov    %eax,%edx
f0109b08:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109b0b:	89 04 95 c0 f2 6d f0 	mov    %eax,-0xf920d40(,%edx,4)
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109b12:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0109b19:	eb 43                	jmp    f0109b5e <krealloc+0x2f8>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
f0109b1b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109b1e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109b21:	01 d0                	add    %edx,%eax
f0109b23:	c1 e0 0c             	shl    $0xc,%eax
f0109b26:	89 c2                	mov    %eax,%edx
f0109b28:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b2b:	01 d0                	add    %edx,%eax
f0109b2d:	83 ec 0c             	sub    $0xc,%esp
f0109b30:	50                   	push   %eax
f0109b31:	e8 a1 fc ff ff       	call   f01097d7 <kheap_physical_address>
f0109b36:	83 c4 10             	add    $0x10,%esp
f0109b39:	89 45 b8             	mov    %eax,-0x48(%ebp)
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
f0109b3c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0109b3f:	c1 e8 0c             	shr    $0xc,%eax
f0109b42:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0109b45:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0109b48:	01 ca                	add    %ecx,%edx
f0109b4a:	89 d1                	mov    %edx,%ecx
f0109b4c:	c1 e1 0c             	shl    $0xc,%ecx
f0109b4f:	8b 55 08             	mov    0x8(%ebp),%edx
f0109b52:	01 ca                	add    %ecx,%edx
f0109b54:	89 14 85 c0 72 70 f0 	mov    %edx,-0xf8f8d40(,%eax,4)
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109b5b:	ff 45 dc             	incl   -0x24(%ebp)
f0109b5e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109b61:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109b64:	89 c2                	mov    %eax,%edx
f0109b66:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109b69:	39 c2                	cmp    %eax,%edx
f0109b6b:	77 ae                	ja     f0109b1b <krealloc+0x2b5>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
				}
				sayed:
					if(!found_free_pages){
f0109b6d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109b71:	75 52                	jne    f0109bc5 <krealloc+0x35f>
						ptr = kmalloc(new_size);
f0109b73:	83 ec 0c             	sub    $0xc,%esp
f0109b76:	ff 75 0c             	pushl  0xc(%ebp)
f0109b79:	e8 13 f9 ff ff       	call   f0109491 <kmalloc>
f0109b7e:	83 c4 10             	add    $0x10,%esp
f0109b81:	89 45 f4             	mov    %eax,-0xc(%ebp)
						if(ptr != NULL) memcpy(ptr, va, new_size);
f0109b84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109b88:	74 14                	je     f0109b9e <krealloc+0x338>
f0109b8a:	83 ec 04             	sub    $0x4,%esp
f0109b8d:	ff 75 0c             	pushl  0xc(%ebp)
f0109b90:	ff 75 08             	pushl  0x8(%ebp)
f0109b93:	ff 75 f4             	pushl  -0xc(%ebp)
f0109b96:	e8 4b 62 01 00       	call   f011fde6 <memcpy>
f0109b9b:	83 c4 10             	add    $0x10,%esp
						kfree(va);
f0109b9e:	83 ec 0c             	sub    $0xc,%esp
f0109ba1:	ff 75 08             	pushl  0x8(%ebp)
f0109ba4:	e8 48 fb ff ff       	call   f01096f1 <kfree>
f0109ba9:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109bac:	eb 17                	jmp    f0109bc5 <krealloc+0x35f>
						if(ptr != NULL) memcpy(ptr, va, new_size);
						kfree(va);
					}
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
f0109bae:	83 ec 04             	sub    $0x4,%esp
f0109bb1:	68 04 5c 12 f0       	push   $0xf0125c04
f0109bb6:	68 58 01 00 00       	push   $0x158
f0109bbb:	68 be 5b 12 f0       	push   $0xf0125bbe
f0109bc0:	e8 74 67 ff ff       	call   f0100339 <_panic>
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109bc5:	90                   	nop
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
		}
	}
	return ptr;
f0109bc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109bc9:	c9                   	leave  
f0109bca:	c3                   	ret    

f0109bcb <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0109bcb:	55                   	push   %ebp
f0109bcc:	89 e5                	mov    %esp,%ebp
f0109bce:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109bd1:	83 ec 04             	sub    $0x4,%esp
f0109bd4:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109bd7:	50                   	push   %eax
f0109bd8:	ff 75 0c             	pushl  0xc(%ebp)
f0109bdb:	ff 75 08             	pushl  0x8(%ebp)
f0109bde:	e8 0c e8 ff ff       	call   f01083ef <get_page_table>
f0109be3:	83 c4 10             	add    $0x10,%esp
f0109be6:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109be9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109bec:	85 c0                	test   %eax,%eax
f0109bee:	74 64                	je     f0109c54 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109bf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109bf3:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109bf6:	c1 ea 0c             	shr    $0xc,%edx
f0109bf9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109bff:	c1 e2 02             	shl    $0x2,%edx
f0109c02:	01 c2                	add    %eax,%edx
f0109c04:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c07:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109c0a:	c1 e9 0c             	shr    $0xc,%ecx
f0109c0d:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109c13:	c1 e1 02             	shl    $0x2,%ecx
f0109c16:	01 c8                	add    %ecx,%eax
f0109c18:	8b 00                	mov    (%eax),%eax
f0109c1a:	0b 45 10             	or     0x10(%ebp),%eax
f0109c1d:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109c1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c22:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109c25:	c1 ea 0c             	shr    $0xc,%edx
f0109c28:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109c2e:	c1 e2 02             	shl    $0x2,%edx
f0109c31:	01 d0                	add    %edx,%eax
f0109c33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109c36:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109c39:	c1 e9 0c             	shr    $0xc,%ecx
f0109c3c:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109c42:	c1 e1 02             	shl    $0x2,%ecx
f0109c45:	01 ca                	add    %ecx,%edx
f0109c47:	8b 12                	mov    (%edx),%edx
f0109c49:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109c4c:	f7 d1                	not    %ecx
f0109c4e:	21 ca                	and    %ecx,%edx
f0109c50:	89 10                	mov    %edx,(%eax)
f0109c52:	eb 27                	jmp    f0109c7b <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109c54:	83 ec 08             	sub    $0x8,%esp
f0109c57:	ff 75 0c             	pushl  0xc(%ebp)
f0109c5a:	68 30 5c 12 f0       	push   $0xf0125c30
f0109c5f:	e8 27 73 ff ff       	call   f0100f8b <cprintf>
f0109c64:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109c67:	83 ec 04             	sub    $0x4,%esp
f0109c6a:	68 58 5c 12 f0       	push   $0xf0125c58
f0109c6f:	6a 1c                	push   $0x1c
f0109c71:	68 cc 5c 12 f0       	push   $0xf0125ccc
f0109c76:	e8 be 66 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109c7b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109c7e:	83 ec 08             	sub    $0x8,%esp
f0109c81:	50                   	push   %eax
f0109c82:	6a 00                	push   $0x0
f0109c84:	e8 30 e1 ff ff       	call   f0107db9 <tlb_invalidate>
f0109c89:	83 c4 10             	add    $0x10,%esp
}
f0109c8c:	90                   	nop
f0109c8d:	c9                   	leave  
f0109c8e:	c3                   	ret    

f0109c8f <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f0109c8f:	55                   	push   %ebp
f0109c90:	89 e5                	mov    %esp,%ebp
f0109c92:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109c95:	83 ec 04             	sub    $0x4,%esp
f0109c98:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109c9b:	50                   	push   %eax
f0109c9c:	ff 75 0c             	pushl  0xc(%ebp)
f0109c9f:	ff 75 08             	pushl  0x8(%ebp)
f0109ca2:	e8 48 e7 ff ff       	call   f01083ef <get_page_table>
f0109ca7:	83 c4 10             	add    $0x10,%esp
f0109caa:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f0109cad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109cb0:	85 c0                	test   %eax,%eax
f0109cb2:	74 1d                	je     f0109cd1 <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f0109cb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109cb7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109cba:	c1 ea 0c             	shr    $0xc,%edx
f0109cbd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109cc3:	c1 e2 02             	shl    $0x2,%edx
f0109cc6:	01 d0                	add    %edx,%eax
f0109cc8:	8b 00                	mov    (%eax),%eax
f0109cca:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109ccf:	eb 05                	jmp    f0109cd6 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f0109cd1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f0109cd6:	c9                   	leave  
f0109cd7:	c3                   	ret    

f0109cd8 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f0109cd8:	55                   	push   %ebp
f0109cd9:	89 e5                	mov    %esp,%ebp
f0109cdb:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109cde:	83 ec 04             	sub    $0x4,%esp
f0109ce1:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109ce4:	50                   	push   %eax
f0109ce5:	ff 75 0c             	pushl  0xc(%ebp)
f0109ce8:	ff 75 08             	pushl  0x8(%ebp)
f0109ceb:	e8 ff e6 ff ff       	call   f01083ef <get_page_table>
f0109cf0:	83 c4 10             	add    $0x10,%esp
f0109cf3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109cf6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109cf9:	85 c0                	test   %eax,%eax
f0109cfb:	74 46                	je     f0109d43 <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f0109cfd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d00:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d03:	c1 ea 0c             	shr    $0xc,%edx
f0109d06:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109d0c:	c1 e2 02             	shl    $0x2,%edx
f0109d0f:	01 d0                	add    %edx,%eax
f0109d11:	8b 00                	mov    (%eax),%eax
f0109d13:	83 ec 04             	sub    $0x4,%esp
f0109d16:	50                   	push   %eax
f0109d17:	ff 75 0c             	pushl  0xc(%ebp)
f0109d1a:	68 e8 5c 12 f0       	push   $0xf0125ce8
f0109d1f:	e8 67 72 ff ff       	call   f0100f8b <cprintf>
f0109d24:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f0109d27:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d2a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d2d:	c1 ea 0c             	shr    $0xc,%edx
f0109d30:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109d36:	c1 e2 02             	shl    $0x2,%edx
f0109d39:	01 d0                	add    %edx,%eax
f0109d3b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109d41:	eb 14                	jmp    f0109d57 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109d43:	83 ec 04             	sub    $0x4,%esp
f0109d46:	68 10 5d 12 f0       	push   $0xf0125d10
f0109d4b:	6a 47                	push   $0x47
f0109d4d:	68 cc 5c 12 f0       	push   $0xf0125ccc
f0109d52:	e8 e2 65 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109d57:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109d5a:	83 ec 08             	sub    $0x8,%esp
f0109d5d:	50                   	push   %eax
f0109d5e:	6a 00                	push   $0x0
f0109d60:	e8 54 e0 ff ff       	call   f0107db9 <tlb_invalidate>
f0109d65:	83 c4 10             	add    $0x10,%esp
}
f0109d68:	90                   	nop
f0109d69:	c9                   	leave  
f0109d6a:	c3                   	ret    

f0109d6b <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f0109d6b:	55                   	push   %ebp
f0109d6c:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0109d6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109d71:	c1 e8 16             	shr    $0x16,%eax
f0109d74:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109d7b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d7e:	01 d0                	add    %edx,%eax
f0109d80:	8b 00                	mov    (%eax),%eax
f0109d82:	83 e0 20             	and    $0x20,%eax
f0109d85:	85 c0                	test   %eax,%eax
f0109d87:	0f 95 c0             	setne  %al
f0109d8a:	0f b6 c0             	movzbl %al,%eax
}
f0109d8d:	5d                   	pop    %ebp
f0109d8e:	c3                   	ret    

f0109d8f <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f0109d8f:	55                   	push   %ebp
f0109d90:	89 e5                	mov    %esp,%ebp
f0109d92:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f0109d95:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109d98:	c1 e8 16             	shr    $0x16,%eax
f0109d9b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109da2:	8b 45 08             	mov    0x8(%ebp),%eax
f0109da5:	01 d0                	add    %edx,%eax
f0109da7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109daa:	c1 ea 16             	shr    $0x16,%edx
f0109dad:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0109db4:	8b 55 08             	mov    0x8(%ebp),%edx
f0109db7:	01 ca                	add    %ecx,%edx
f0109db9:	8b 12                	mov    (%edx),%edx
f0109dbb:	83 e2 df             	and    $0xffffffdf,%edx
f0109dbe:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109dc0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109dc3:	83 ec 08             	sub    $0x8,%esp
f0109dc6:	50                   	push   %eax
f0109dc7:	6a 00                	push   $0x0
f0109dc9:	e8 eb df ff ff       	call   f0107db9 <tlb_invalidate>
f0109dce:	83 c4 10             	add    $0x10,%esp
}
f0109dd1:	90                   	nop
f0109dd2:	c9                   	leave  
f0109dd3:	c3                   	ret    

f0109dd4 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f0109dd4:	55                   	push   %ebp
f0109dd5:	89 e5                	mov    %esp,%ebp
f0109dd7:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f0109dda:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ddd:	c1 e8 16             	shr    $0x16,%eax
f0109de0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109de7:	8b 45 08             	mov    0x8(%ebp),%eax
f0109dea:	01 d0                	add    %edx,%eax
f0109dec:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109df2:	0f 20 d8             	mov    %cr3,%eax
f0109df5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109df8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0109dfb:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0109dfe:	90                   	nop
f0109dff:	c9                   	leave  
f0109e00:	c3                   	ret    

f0109e01 <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f0109e01:	55                   	push   %ebp
f0109e02:	89 e5                	mov    %esp,%ebp
f0109e04:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("env_page_ws_list_create_element is not implemented yet");
	//Your Code is Here...
	void* retK = kmalloc(sizeof(struct WorkingSetElement));
f0109e07:	83 ec 0c             	sub    $0xc,%esp
f0109e0a:	6a 18                	push   $0x18
f0109e0c:	e8 80 f6 ff ff       	call   f0109491 <kmalloc>
f0109e11:	83 c4 10             	add    $0x10,%esp
f0109e14:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (retK==NULL) panic("env_page_ws_list_create_element failed no mem");
f0109e17:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109e1b:	75 14                	jne    f0109e31 <env_page_ws_list_create_element+0x30>
f0109e1d:	83 ec 04             	sub    $0x4,%esp
f0109e20:	68 88 5d 12 f0       	push   $0xf0125d88
f0109e25:	6a 19                	push   $0x19
f0109e27:	68 b8 5d 12 f0       	push   $0xf0125db8
f0109e2c:	e8 08 65 ff ff       	call   f0100339 <_panic>
	struct WorkingSetElement* element =(struct WorkingSetElement*)retK;
f0109e31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109e34:	89 45 f0             	mov    %eax,-0x10(%ebp)
	element->virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
f0109e37:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e3a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109e3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109e40:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109e45:	89 c2                	mov    %eax,%edx
f0109e47:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e4a:	89 10                	mov    %edx,(%eax)
	element->empty=0;
f0109e4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e4f:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	element->time_stamp=0;
f0109e53:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e56:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	element->sweeps_counter=0;
f0109e5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e60:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return element;
f0109e67:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
f0109e6a:	c9                   	leave  
f0109e6b:	c3                   	ret    

f0109e6c <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109e6c:	55                   	push   %ebp
f0109e6d:	89 e5                	mov    %esp,%ebp
f0109e6f:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109e72:	83 ec 0c             	sub    $0xc,%esp
f0109e75:	6a 02                	push   $0x2
f0109e77:	e8 4b 57 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f0109e7c:	83 c4 10             	add    $0x10,%esp
f0109e7f:	85 c0                	test   %eax,%eax
f0109e81:	0f 84 e5 03 00 00    	je     f010a26c <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f0109e87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f0109e8e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109e95:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e98:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0109e9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109ea1:	e9 3b 02 00 00       	jmp    f010a0e1 <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109ea6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ea9:	8b 00                	mov    (%eax),%eax
f0109eab:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109eae:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109eb1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109eb6:	89 c2                	mov    %eax,%edx
f0109eb8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ebb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109ebe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109ec1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109ec6:	39 c2                	cmp    %eax,%edx
f0109ec8:	0f 85 07 02 00 00    	jne    f010a0d5 <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f0109ece:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ed1:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109ed7:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f0109eda:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109edd:	8b 10                	mov    (%eax),%edx
f0109edf:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ee2:	8b 40 64             	mov    0x64(%eax),%eax
f0109ee5:	83 ec 08             	sub    $0x8,%esp
f0109ee8:	52                   	push   %edx
f0109ee9:	50                   	push   %eax
f0109eea:	e8 f0 e8 ff ff       	call   f01087df <unmap_frame>
f0109eef:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f0109ef2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109ef6:	75 14                	jne    f0109f0c <env_page_ws_invalidate+0xa0>
f0109ef8:	83 ec 04             	sub    $0x4,%esp
f0109efb:	68 d7 5d 12 f0       	push   $0xf0125dd7
f0109f00:	6a 2f                	push   $0x2f
f0109f02:	68 b8 5d 12 f0       	push   $0xf0125db8
f0109f07:	e8 2d 64 ff ff       	call   f0100339 <_panic>
f0109f0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f0f:	8b 40 10             	mov    0x10(%eax),%eax
f0109f12:	85 c0                	test   %eax,%eax
f0109f14:	74 11                	je     f0109f27 <env_page_ws_invalidate+0xbb>
f0109f16:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f19:	8b 40 10             	mov    0x10(%eax),%eax
f0109f1c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109f1f:	8b 52 14             	mov    0x14(%edx),%edx
f0109f22:	89 50 14             	mov    %edx,0x14(%eax)
f0109f25:	eb 0f                	jmp    f0109f36 <env_page_ws_invalidate+0xca>
f0109f27:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f2a:	8b 50 14             	mov    0x14(%eax),%edx
f0109f2d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f30:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f0109f36:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f39:	8b 40 14             	mov    0x14(%eax),%eax
f0109f3c:	85 c0                	test   %eax,%eax
f0109f3e:	74 11                	je     f0109f51 <env_page_ws_invalidate+0xe5>
f0109f40:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f43:	8b 40 14             	mov    0x14(%eax),%eax
f0109f46:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109f49:	8b 52 10             	mov    0x10(%edx),%edx
f0109f4c:	89 50 10             	mov    %edx,0x10(%eax)
f0109f4f:	eb 0f                	jmp    f0109f60 <env_page_ws_invalidate+0xf4>
f0109f51:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f54:	8b 50 10             	mov    0x10(%eax),%edx
f0109f57:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f5a:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f0109f60:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f63:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109f6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f6d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109f74:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f77:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0109f7d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109f80:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f83:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f0109f89:	83 ec 0c             	sub    $0xc,%esp
f0109f8c:	ff 75 f0             	pushl  -0x10(%ebp)
f0109f8f:	e8 5d f7 ff ff       	call   f01096f1 <kfree>
f0109f94:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f0109f97:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0109f9b:	0f 84 2b 01 00 00    	je     f010a0cc <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f0109fa1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0109fa5:	75 14                	jne    f0109fbb <env_page_ws_invalidate+0x14f>
f0109fa7:	83 ec 04             	sub    $0x4,%esp
f0109faa:	68 d7 5d 12 f0       	push   $0xf0125dd7
f0109faf:	6a 35                	push   $0x35
f0109fb1:	68 b8 5d 12 f0       	push   $0xf0125db8
f0109fb6:	e8 7e 63 ff ff       	call   f0100339 <_panic>
f0109fbb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109fbe:	8b 40 10             	mov    0x10(%eax),%eax
f0109fc1:	85 c0                	test   %eax,%eax
f0109fc3:	74 11                	je     f0109fd6 <env_page_ws_invalidate+0x16a>
f0109fc5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109fc8:	8b 40 10             	mov    0x10(%eax),%eax
f0109fcb:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109fce:	8b 52 14             	mov    0x14(%edx),%edx
f0109fd1:	89 50 14             	mov    %edx,0x14(%eax)
f0109fd4:	eb 0f                	jmp    f0109fe5 <env_page_ws_invalidate+0x179>
f0109fd6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109fd9:	8b 50 14             	mov    0x14(%eax),%edx
f0109fdc:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fdf:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f0109fe5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109fe8:	8b 40 14             	mov    0x14(%eax),%eax
f0109feb:	85 c0                	test   %eax,%eax
f0109fed:	74 11                	je     f010a000 <env_page_ws_invalidate+0x194>
f0109fef:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109ff2:	8b 40 14             	mov    0x14(%eax),%eax
f0109ff5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109ff8:	8b 52 10             	mov    0x10(%edx),%edx
f0109ffb:	89 50 10             	mov    %edx,0x10(%eax)
f0109ffe:	eb 0f                	jmp    f010a00f <env_page_ws_invalidate+0x1a3>
f010a000:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a003:	8b 50 10             	mov    0x10(%eax),%edx
f010a006:	8b 45 08             	mov    0x8(%ebp),%eax
f010a009:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a00f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a012:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a019:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a01c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a023:	8b 45 08             	mov    0x8(%ebp),%eax
f010a026:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a02c:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a02f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a032:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010a038:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a03c:	75 14                	jne    f010a052 <env_page_ws_invalidate+0x1e6>
f010a03e:	83 ec 04             	sub    $0x4,%esp
f010a041:	68 f8 5d 12 f0       	push   $0xf0125df8
f010a046:	6a 36                	push   $0x36
f010a048:	68 b8 5d 12 f0       	push   $0xf0125db8
f010a04d:	e8 e7 62 ff ff       	call   f0100339 <_panic>
f010a052:	8b 45 08             	mov    0x8(%ebp),%eax
f010a055:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010a05b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a05e:	89 50 14             	mov    %edx,0x14(%eax)
f010a061:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a064:	8b 40 14             	mov    0x14(%eax),%eax
f010a067:	85 c0                	test   %eax,%eax
f010a069:	74 11                	je     f010a07c <env_page_ws_invalidate+0x210>
f010a06b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a06e:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a074:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a077:	89 50 10             	mov    %edx,0x10(%eax)
f010a07a:	eb 0c                	jmp    f010a088 <env_page_ws_invalidate+0x21c>
f010a07c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a07f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a082:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a088:	8b 45 08             	mov    0x8(%ebp),%eax
f010a08b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a08e:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a094:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a097:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a09e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0a1:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a0a7:	8d 50 01             	lea    0x1(%eax),%edx
f010a0aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0ad:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010a0b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0b6:	8b 10                	mov    (%eax),%edx
f010a0b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0bb:	8b 40 64             	mov    0x64(%eax),%eax
f010a0be:	6a 00                	push   $0x0
f010a0c0:	6a 01                	push   $0x1
f010a0c2:	52                   	push   %edx
f010a0c3:	50                   	push   %eax
f010a0c4:	e8 02 fb ff ff       	call   f0109bcb <pt_set_page_permissions>
f010a0c9:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010a0cc:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010a0d3:	eb 43                	jmp    f010a118 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a0d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0d8:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a0de:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a0e1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a0e5:	74 08                	je     f010a0ef <env_page_ws_invalidate+0x283>
f010a0e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a0ea:	8b 40 10             	mov    0x10(%eax),%eax
f010a0ed:	eb 05                	jmp    f010a0f4 <env_page_ws_invalidate+0x288>
f010a0ef:	b8 00 00 00 00       	mov    $0x0,%eax
f010a0f4:	8b 55 08             	mov    0x8(%ebp),%edx
f010a0f7:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a0fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a100:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a106:	85 c0                	test   %eax,%eax
f010a108:	0f 85 98 fd ff ff    	jne    f0109ea6 <env_page_ws_invalidate+0x3a>
f010a10e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a112:	0f 85 8e fd ff ff    	jne    f0109ea6 <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010a118:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a11c:	0f 85 a4 02 00 00    	jne    f010a3c6 <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010a122:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a129:	8b 45 08             	mov    0x8(%ebp),%eax
f010a12c:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a132:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a135:	e9 f6 00 00 00       	jmp    f010a230 <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a13a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a13d:	8b 00                	mov    (%eax),%eax
f010a13f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a142:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a145:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a14a:	89 c2                	mov    %eax,%edx
f010a14c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a14f:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a152:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a155:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a15a:	39 c2                	cmp    %eax,%edx
f010a15c:	0f 85 c2 00 00 00    	jne    f010a224 <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a162:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a165:	8b 10                	mov    (%eax),%edx
f010a167:	8b 45 08             	mov    0x8(%ebp),%eax
f010a16a:	8b 40 64             	mov    0x64(%eax),%eax
f010a16d:	83 ec 08             	sub    $0x8,%esp
f010a170:	52                   	push   %edx
f010a171:	50                   	push   %eax
f010a172:	e8 68 e6 ff ff       	call   f01087df <unmap_frame>
f010a177:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010a17a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a17e:	75 14                	jne    f010a194 <env_page_ws_invalidate+0x328>
f010a180:	83 ec 04             	sub    $0x4,%esp
f010a183:	68 d7 5d 12 f0       	push   $0xf0125dd7
f010a188:	6a 46                	push   $0x46
f010a18a:	68 b8 5d 12 f0       	push   $0xf0125db8
f010a18f:	e8 a5 61 ff ff       	call   f0100339 <_panic>
f010a194:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a197:	8b 40 10             	mov    0x10(%eax),%eax
f010a19a:	85 c0                	test   %eax,%eax
f010a19c:	74 11                	je     f010a1af <env_page_ws_invalidate+0x343>
f010a19e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1a1:	8b 40 10             	mov    0x10(%eax),%eax
f010a1a4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a1a7:	8b 52 14             	mov    0x14(%edx),%edx
f010a1aa:	89 50 14             	mov    %edx,0x14(%eax)
f010a1ad:	eb 0f                	jmp    f010a1be <env_page_ws_invalidate+0x352>
f010a1af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1b2:	8b 50 14             	mov    0x14(%eax),%edx
f010a1b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1b8:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a1be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1c1:	8b 40 14             	mov    0x14(%eax),%eax
f010a1c4:	85 c0                	test   %eax,%eax
f010a1c6:	74 11                	je     f010a1d9 <env_page_ws_invalidate+0x36d>
f010a1c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1cb:	8b 40 14             	mov    0x14(%eax),%eax
f010a1ce:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a1d1:	8b 52 10             	mov    0x10(%edx),%edx
f010a1d4:	89 50 10             	mov    %edx,0x10(%eax)
f010a1d7:	eb 0f                	jmp    f010a1e8 <env_page_ws_invalidate+0x37c>
f010a1d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1dc:	8b 50 10             	mov    0x10(%eax),%edx
f010a1df:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1e2:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a1e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1eb:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a1f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1f5:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a1fc:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1ff:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a205:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a208:	8b 45 08             	mov    0x8(%ebp),%eax
f010a20b:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

					kfree(ptr_WS_element);
f010a211:	83 ec 0c             	sub    $0xc,%esp
f010a214:	ff 75 f0             	pushl  -0x10(%ebp)
f010a217:	e8 d5 f4 ff ff       	call   f01096f1 <kfree>
f010a21c:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010a21f:	e9 a2 01 00 00       	jmp    f010a3c6 <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a224:	8b 45 08             	mov    0x8(%ebp),%eax
f010a227:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a22d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a230:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a234:	74 08                	je     f010a23e <env_page_ws_invalidate+0x3d2>
f010a236:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a239:	8b 40 10             	mov    0x10(%eax),%eax
f010a23c:	eb 05                	jmp    f010a243 <env_page_ws_invalidate+0x3d7>
f010a23e:	b8 00 00 00 00       	mov    $0x0,%eax
f010a243:	8b 55 08             	mov    0x8(%ebp),%edx
f010a246:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a24c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a24f:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a255:	85 c0                	test   %eax,%eax
f010a257:	0f 85 dd fe ff ff    	jne    f010a13a <env_page_ws_invalidate+0x2ce>
f010a25d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a261:	0f 85 d3 fe ff ff    	jne    f010a13a <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010a267:	e9 5a 01 00 00       	jmp    f010a3c6 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a26c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a26f:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a275:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a278:	e9 10 01 00 00       	jmp    f010a38d <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a27d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a280:	8b 00                	mov    (%eax),%eax
f010a282:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a285:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a288:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a28d:	89 c2                	mov    %eax,%edx
f010a28f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a292:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a295:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a298:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a29d:	39 c2                	cmp    %eax,%edx
f010a29f:	0f 85 dc 00 00 00    	jne    f010a381 <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010a2a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a2a8:	8b 10                	mov    (%eax),%edx
f010a2aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2ad:	8b 40 64             	mov    0x64(%eax),%eax
f010a2b0:	83 ec 08             	sub    $0x8,%esp
f010a2b3:	52                   	push   %edx
f010a2b4:	50                   	push   %eax
f010a2b5:	e8 25 e5 ff ff       	call   f01087df <unmap_frame>
f010a2ba:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010a2bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2c0:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a2c6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a2c9:	75 0f                	jne    f010a2da <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010a2cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a2ce:	8b 50 10             	mov    0x10(%eax),%edx
f010a2d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2d4:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010a2da:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a2de:	75 14                	jne    f010a2f4 <env_page_ws_invalidate+0x488>
f010a2e0:	83 ec 04             	sub    $0x4,%esp
f010a2e3:	68 d7 5d 12 f0       	push   $0xf0125dd7
f010a2e8:	6a 5c                	push   $0x5c
f010a2ea:	68 b8 5d 12 f0       	push   $0xf0125db8
f010a2ef:	e8 45 60 ff ff       	call   f0100339 <_panic>
f010a2f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a2f7:	8b 40 10             	mov    0x10(%eax),%eax
f010a2fa:	85 c0                	test   %eax,%eax
f010a2fc:	74 11                	je     f010a30f <env_page_ws_invalidate+0x4a3>
f010a2fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a301:	8b 40 10             	mov    0x10(%eax),%eax
f010a304:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a307:	8b 52 14             	mov    0x14(%edx),%edx
f010a30a:	89 50 14             	mov    %edx,0x14(%eax)
f010a30d:	eb 0f                	jmp    f010a31e <env_page_ws_invalidate+0x4b2>
f010a30f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a312:	8b 50 14             	mov    0x14(%eax),%edx
f010a315:	8b 45 08             	mov    0x8(%ebp),%eax
f010a318:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010a31e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a321:	8b 40 14             	mov    0x14(%eax),%eax
f010a324:	85 c0                	test   %eax,%eax
f010a326:	74 11                	je     f010a339 <env_page_ws_invalidate+0x4cd>
f010a328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a32b:	8b 40 14             	mov    0x14(%eax),%eax
f010a32e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a331:	8b 52 10             	mov    0x10(%edx),%edx
f010a334:	89 50 10             	mov    %edx,0x10(%eax)
f010a337:	eb 0f                	jmp    f010a348 <env_page_ws_invalidate+0x4dc>
f010a339:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a33c:	8b 50 10             	mov    0x10(%eax),%edx
f010a33f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a342:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010a348:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a34b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a352:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a355:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a35c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a35f:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010a365:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a368:	8b 45 08             	mov    0x8(%ebp),%eax
f010a36b:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)

				kfree(wse);
f010a371:	83 ec 0c             	sub    $0xc,%esp
f010a374:	ff 75 ec             	pushl  -0x14(%ebp)
f010a377:	e8 75 f3 ff ff       	call   f01096f1 <kfree>
f010a37c:	83 c4 10             	add    $0x10,%esp

				break;
f010a37f:	eb 45                	jmp    f010a3c6 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a381:	8b 45 08             	mov    0x8(%ebp),%eax
f010a384:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a38a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a38d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a391:	74 08                	je     f010a39b <env_page_ws_invalidate+0x52f>
f010a393:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a396:	8b 40 10             	mov    0x10(%eax),%eax
f010a399:	eb 05                	jmp    f010a3a0 <env_page_ws_invalidate+0x534>
f010a39b:	b8 00 00 00 00       	mov    $0x0,%eax
f010a3a0:	8b 55 08             	mov    0x8(%ebp),%edx
f010a3a3:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a3a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3ac:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a3b2:	85 c0                	test   %eax,%eax
f010a3b4:	0f 85 c3 fe ff ff    	jne    f010a27d <env_page_ws_invalidate+0x411>
f010a3ba:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a3be:	0f 85 b9 fe ff ff    	jne    f010a27d <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010a3c4:	eb 00                	jmp    f010a3c6 <env_page_ws_invalidate+0x55a>
f010a3c6:	90                   	nop
f010a3c7:	c9                   	leave  
f010a3c8:	c3                   	ret    

f010a3c9 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010a3c9:	55                   	push   %ebp
f010a3ca:	89 e5                	mov    %esp,%ebp
f010a3cc:	53                   	push   %ebx
f010a3cd:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a3d0:	83 ec 0c             	sub    $0xc,%esp
f010a3d3:	6a 02                	push   $0x2
f010a3d5:	e8 ed 51 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f010a3da:	83 c4 10             	add    $0x10,%esp
f010a3dd:	85 c0                	test   %eax,%eax
f010a3df:	0f 84 fe 00 00 00    	je     f010a4e3 <env_page_ws_print+0x11a>
	{
		int i = 0;
f010a3e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010a3ec:	83 ec 0c             	sub    $0xc,%esp
f010a3ef:	68 1b 5e 12 f0       	push   $0xf0125e1b
f010a3f4:	e8 92 6b ff ff       	call   f0100f8b <cprintf>
f010a3f9:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a3fc:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3ff:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010a405:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a408:	eb 2c                	jmp    f010a436 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a40a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a40d:	8b 10                	mov    (%eax),%edx
f010a40f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a412:	8d 48 01             	lea    0x1(%eax),%ecx
f010a415:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a418:	83 ec 04             	sub    $0x4,%esp
f010a41b:	52                   	push   %edx
f010a41c:	50                   	push   %eax
f010a41d:	68 35 5e 12 f0       	push   $0xf0125e35
f010a422:	e8 64 6b ff ff       	call   f0100f8b <cprintf>
f010a427:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a42a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a42d:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a433:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a436:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a43a:	74 08                	je     f010a444 <env_page_ws_print+0x7b>
f010a43c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a43f:	8b 40 10             	mov    0x10(%eax),%eax
f010a442:	eb 05                	jmp    f010a449 <env_page_ws_print+0x80>
f010a444:	b8 00 00 00 00       	mov    $0x0,%eax
f010a449:	8b 55 08             	mov    0x8(%ebp),%edx
f010a44c:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a452:	8b 45 08             	mov    0x8(%ebp),%eax
f010a455:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a45b:	85 c0                	test   %eax,%eax
f010a45d:	75 ab                	jne    f010a40a <env_page_ws_print+0x41>
f010a45f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a463:	75 a5                	jne    f010a40a <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010a465:	83 ec 0c             	sub    $0xc,%esp
f010a468:	68 3d 5e 12 f0       	push   $0xf0125e3d
f010a46d:	e8 19 6b ff ff       	call   f0100f8b <cprintf>
f010a472:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a475:	8b 45 08             	mov    0x8(%ebp),%eax
f010a478:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a47e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a481:	eb 2c                	jmp    f010a4af <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a483:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a486:	8b 10                	mov    (%eax),%edx
f010a488:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a48b:	8d 48 01             	lea    0x1(%eax),%ecx
f010a48e:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a491:	83 ec 04             	sub    $0x4,%esp
f010a494:	52                   	push   %edx
f010a495:	50                   	push   %eax
f010a496:	68 35 5e 12 f0       	push   $0xf0125e35
f010a49b:	e8 eb 6a ff ff       	call   f0100f8b <cprintf>
f010a4a0:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a4a3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4a6:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a4ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a4af:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a4b3:	74 08                	je     f010a4bd <env_page_ws_print+0xf4>
f010a4b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4b8:	8b 40 10             	mov    0x10(%eax),%eax
f010a4bb:	eb 05                	jmp    f010a4c2 <env_page_ws_print+0xf9>
f010a4bd:	b8 00 00 00 00       	mov    $0x0,%eax
f010a4c2:	8b 55 08             	mov    0x8(%ebp),%edx
f010a4c5:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a4cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4ce:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a4d4:	85 c0                	test   %eax,%eax
f010a4d6:	75 ab                	jne    f010a483 <env_page_ws_print+0xba>
f010a4d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a4dc:	75 a5                	jne    f010a483 <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a4de:	e9 5a 01 00 00       	jmp    f010a63d <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010a4e3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010a4ea:	83 ec 0c             	sub    $0xc,%esp
f010a4ed:	68 58 5e 12 f0       	push   $0xf0125e58
f010a4f2:	e8 94 6a ff ff       	call   f0100f8b <cprintf>
f010a4f7:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010a4fa:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a501:	8b 45 08             	mov    0x8(%ebp),%eax
f010a504:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a50a:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a50d:	e9 d1 00 00 00       	jmp    f010a5e3 <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010a512:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a515:	8b 00                	mov    (%eax),%eax
f010a517:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010a51a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a51d:	8b 40 08             	mov    0x8(%eax),%eax
f010a520:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010a523:	8b 45 08             	mov    0x8(%ebp),%eax
f010a526:	8b 40 64             	mov    0x64(%eax),%eax
f010a529:	83 ec 08             	sub    $0x8,%esp
f010a52c:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a52f:	50                   	push   %eax
f010a530:	e8 5a f7 ff ff       	call   f0109c8f <pt_get_page_permissions>
f010a535:	83 c4 10             	add    $0x10,%esp
f010a538:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010a53b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a53e:	83 e0 40             	and    $0x40,%eax
f010a541:	85 c0                	test   %eax,%eax
f010a543:	0f 95 c0             	setne  %al
f010a546:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010a549:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a54c:	83 e0 20             	and    $0x20,%eax
f010a54f:	85 c0                	test   %eax,%eax
f010a551:	0f 95 c0             	setne  %al
f010a554:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010a557:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a55a:	25 00 02 00 00       	and    $0x200,%eax
f010a55f:	85 c0                	test   %eax,%eax
f010a561:	0f 95 c0             	setne  %al
f010a564:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010a567:	83 ec 04             	sub    $0x4,%esp
f010a56a:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a56d:	ff 75 ec             	pushl  -0x14(%ebp)
f010a570:	68 62 5e 12 f0       	push   $0xf0125e62
f010a575:	e8 11 6a ff ff       	call   f0100f8b <cprintf>
f010a57a:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f010a57d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a580:	8b 58 0c             	mov    0xc(%eax),%ebx
f010a583:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010a587:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010a58b:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010a58f:	83 ec 08             	sub    $0x8,%esp
f010a592:	53                   	push   %ebx
f010a593:	ff 75 e0             	pushl  -0x20(%ebp)
f010a596:	51                   	push   %ecx
f010a597:	52                   	push   %edx
f010a598:	50                   	push   %eax
f010a599:	68 6c 5e 12 f0       	push   $0xf0125e6c
f010a59e:	e8 e8 69 ff ff       	call   f0100f8b <cprintf>
f010a5a3:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f010a5a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5a9:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a5af:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a5b2:	75 10                	jne    f010a5c4 <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010a5b4:	83 ec 0c             	sub    $0xc,%esp
f010a5b7:	68 b3 5e 12 f0       	push   $0xf0125eb3
f010a5bc:	e8 ca 69 ff ff       	call   f0100f8b <cprintf>
f010a5c1:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a5c4:	83 ec 0c             	sub    $0xc,%esp
f010a5c7:	68 b8 5e 12 f0       	push   $0xf0125eb8
f010a5cc:	e8 ba 69 ff ff       	call   f0100f8b <cprintf>
f010a5d1:	83 c4 10             	add    $0x10,%esp
			i++;
f010a5d4:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a5d7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5da:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a5e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a5e3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a5e7:	74 08                	je     f010a5f1 <env_page_ws_print+0x228>
f010a5e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a5ec:	8b 40 10             	mov    0x10(%eax),%eax
f010a5ef:	eb 05                	jmp    f010a5f6 <env_page_ws_print+0x22d>
f010a5f1:	b8 00 00 00 00       	mov    $0x0,%eax
f010a5f6:	8b 55 08             	mov    0x8(%ebp),%edx
f010a5f9:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a5ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010a602:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a608:	85 c0                	test   %eax,%eax
f010a60a:	0f 85 02 ff ff ff    	jne    f010a512 <env_page_ws_print+0x149>
f010a610:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a614:	0f 85 f8 fe ff ff    	jne    f010a512 <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a61a:	eb 13                	jmp    f010a62f <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a61c:	83 ec 0c             	sub    $0xc,%esp
f010a61f:	68 ba 5e 12 f0       	push   $0xf0125eba
f010a624:	e8 62 69 ff ff       	call   f0100f8b <cprintf>
f010a629:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a62c:	ff 45 ec             	incl   -0x14(%ebp)
f010a62f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a632:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a638:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a63b:	77 df                	ja     f010a61c <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a63d:	90                   	nop
f010a63e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a641:	c9                   	leave  
f010a642:	c3                   	ret    

f010a643 <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010a643:	55                   	push   %ebp
f010a644:	89 e5                	mov    %esp,%ebp
f010a646:	53                   	push   %ebx
f010a647:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010a64a:	83 ec 0c             	sub    $0xc,%esp
f010a64d:	68 cc 5e 12 f0       	push   $0xf0125ecc
f010a652:	e8 34 69 ff ff       	call   f0100f8b <cprintf>
f010a657:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010a65a:	83 ec 0c             	sub    $0xc,%esp
f010a65d:	68 01 5f 12 f0       	push   $0xf0125f01
f010a662:	e8 24 69 ff ff       	call   f0100f8b <cprintf>
f010a667:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a66a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a671:	e9 16 01 00 00       	jmp    f010a78c <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010a676:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a679:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a67c:	89 d0                	mov    %edx,%eax
f010a67e:	01 c0                	add    %eax,%eax
f010a680:	01 d0                	add    %edx,%eax
f010a682:	c1 e0 03             	shl    $0x3,%eax
f010a685:	01 c8                	add    %ecx,%eax
f010a687:	05 b0 00 00 00       	add    $0xb0,%eax
f010a68c:	8a 00                	mov    (%eax),%al
f010a68e:	84 c0                	test   %al,%al
f010a690:	74 43                	je     f010a6d5 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010a692:	83 ec 0c             	sub    $0xc,%esp
f010a695:	68 0c 5f 12 f0       	push   $0xf0125f0c
f010a69a:	e8 ec 68 ff ff       	call   f0100f8b <cprintf>
f010a69f:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010a6a2:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6a5:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a6ab:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a6ae:	75 10                	jne    f010a6c0 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010a6b0:	83 ec 0c             	sub    $0xc,%esp
f010a6b3:	68 1b 5f 12 f0       	push   $0xf0125f1b
f010a6b8:	e8 ce 68 ff ff       	call   f0100f8b <cprintf>
f010a6bd:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a6c0:	83 ec 0c             	sub    $0xc,%esp
f010a6c3:	68 b8 5e 12 f0       	push   $0xf0125eb8
f010a6c8:	e8 be 68 ff ff       	call   f0100f8b <cprintf>
f010a6cd:	83 c4 10             	add    $0x10,%esp
			continue;
f010a6d0:	e9 b4 00 00 00       	jmp    f010a789 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010a6d5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a6d8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a6db:	89 d0                	mov    %edx,%eax
f010a6dd:	01 c0                	add    %eax,%eax
f010a6df:	01 d0                	add    %edx,%eax
f010a6e1:	c1 e0 03             	shl    $0x3,%eax
f010a6e4:	01 c8                	add    %ecx,%eax
f010a6e6:	05 ac 00 00 00       	add    $0xac,%eax
f010a6eb:	8b 00                	mov    (%eax),%eax
f010a6ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010a6f0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a6f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a6f6:	89 d0                	mov    %edx,%eax
f010a6f8:	01 c0                	add    %eax,%eax
f010a6fa:	01 d0                	add    %edx,%eax
f010a6fc:	c1 e0 03             	shl    $0x3,%eax
f010a6ff:	01 c8                	add    %ecx,%eax
f010a701:	05 ac 00 00 00       	add    $0xac,%eax
f010a706:	8b 00                	mov    (%eax),%eax
f010a708:	83 ec 04             	sub    $0x4,%esp
f010a70b:	50                   	push   %eax
f010a70c:	ff 75 f4             	pushl  -0xc(%ebp)
f010a70f:	68 21 5f 12 f0       	push   $0xf0125f21
f010a714:	e8 72 68 ff ff       	call   f0100f8b <cprintf>
f010a719:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010a71c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a71f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a722:	89 d0                	mov    %edx,%eax
f010a724:	01 c0                	add    %eax,%eax
f010a726:	01 d0                	add    %edx,%eax
f010a728:	c1 e0 03             	shl    $0x3,%eax
f010a72b:	01 c8                	add    %ecx,%eax
f010a72d:	05 b4 00 00 00       	add    $0xb4,%eax
f010a732:	8b 18                	mov    (%eax),%ebx
f010a734:	8b 45 08             	mov    0x8(%ebp),%eax
f010a737:	8b 40 64             	mov    0x64(%eax),%eax
f010a73a:	83 ec 08             	sub    $0x8,%esp
f010a73d:	ff 75 f0             	pushl  -0x10(%ebp)
f010a740:	50                   	push   %eax
f010a741:	e8 25 f6 ff ff       	call   f0109d6b <pd_is_table_used>
f010a746:	83 c4 10             	add    $0x10,%esp
f010a749:	83 ec 04             	sub    $0x4,%esp
f010a74c:	53                   	push   %ebx
f010a74d:	50                   	push   %eax
f010a74e:	68 38 5f 12 f0       	push   $0xf0125f38
f010a753:	e8 33 68 ff ff       	call   f0100f8b <cprintf>
f010a758:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010a75b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a75e:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a764:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a767:	75 10                	jne    f010a779 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010a769:	83 ec 0c             	sub    $0xc,%esp
f010a76c:	68 b3 5e 12 f0       	push   $0xf0125eb3
f010a771:	e8 15 68 ff ff       	call   f0100f8b <cprintf>
f010a776:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010a779:	83 ec 0c             	sub    $0xc,%esp
f010a77c:	68 b8 5e 12 f0       	push   $0xf0125eb8
f010a781:	e8 05 68 ff ff       	call   f0100f8b <cprintf>
f010a786:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a789:	ff 45 f4             	incl   -0xc(%ebp)
f010a78c:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a790:	0f 86 e0 fe ff ff    	jbe    f010a676 <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010a796:	90                   	nop
f010a797:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a79a:	c9                   	leave  
f010a79b:	c3                   	ret    

f010a79c <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010a79c:	55                   	push   %ebp
f010a79d:	89 e5                	mov    %esp,%ebp
f010a79f:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010a7a2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010a7a9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010a7b0:	eb 22                	jmp    f010a7d4 <env_table_ws_get_size+0x38>
f010a7b2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a7b5:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a7b8:	89 d0                	mov    %edx,%eax
f010a7ba:	01 c0                	add    %eax,%eax
f010a7bc:	01 d0                	add    %edx,%eax
f010a7be:	c1 e0 03             	shl    $0x3,%eax
f010a7c1:	01 c8                	add    %ecx,%eax
f010a7c3:	05 b0 00 00 00       	add    $0xb0,%eax
f010a7c8:	8a 00                	mov    (%eax),%al
f010a7ca:	84 c0                	test   %al,%al
f010a7cc:	75 03                	jne    f010a7d1 <env_table_ws_get_size+0x35>
f010a7ce:	ff 45 f8             	incl   -0x8(%ebp)
f010a7d1:	ff 45 fc             	incl   -0x4(%ebp)
f010a7d4:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010a7d8:	7e d8                	jle    f010a7b2 <env_table_ws_get_size+0x16>
	return counter;
f010a7da:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010a7dd:	c9                   	leave  
f010a7de:	c3                   	ret    

f010a7df <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a7df:	55                   	push   %ebp
f010a7e0:	89 e5                	mov    %esp,%ebp
f010a7e2:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010a7e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010a7ec:	eb 4e                	jmp    f010a83c <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010a7ee:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a7f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7f4:	89 d0                	mov    %edx,%eax
f010a7f6:	01 c0                	add    %eax,%eax
f010a7f8:	01 d0                	add    %edx,%eax
f010a7fa:	c1 e0 03             	shl    $0x3,%eax
f010a7fd:	01 c8                	add    %ecx,%eax
f010a7ff:	05 ac 00 00 00       	add    $0xac,%eax
f010a804:	8b 00                	mov    (%eax),%eax
f010a806:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a809:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a80c:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a811:	89 c2                	mov    %eax,%edx
f010a813:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a816:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a819:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a81c:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a821:	39 c2                	cmp    %eax,%edx
f010a823:	75 14                	jne    f010a839 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010a825:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a828:	83 ec 08             	sub    $0x8,%esp
f010a82b:	50                   	push   %eax
f010a82c:	ff 75 08             	pushl  0x8(%ebp)
f010a82f:	e8 bc 00 00 00       	call   f010a8f0 <env_table_ws_clear_entry>
f010a834:	83 c4 10             	add    $0x10,%esp
			break;
f010a837:	eb 09                	jmp    f010a842 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010a839:	ff 45 f4             	incl   -0xc(%ebp)
f010a83c:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a840:	7e ac                	jle    f010a7ee <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010a842:	90                   	nop
f010a843:	c9                   	leave  
f010a844:	c3                   	ret    

f010a845 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010a845:	55                   	push   %ebp
f010a846:	89 e5                	mov    %esp,%ebp
f010a848:	53                   	push   %ebx
f010a849:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a84c:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a850:	76 19                	jbe    f010a86b <env_table_ws_set_entry+0x26>
f010a852:	68 5c 5f 12 f0       	push   $0xf0125f5c
f010a857:	68 8d 5f 12 f0       	push   $0xf0125f8d
f010a85c:	68 3f 01 00 00       	push   $0x13f
f010a861:	68 b8 5d 12 f0       	push   $0xf0125db8
f010a866:	e8 ce 5a ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010a86b:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010a872:	76 19                	jbe    f010a88d <env_table_ws_set_entry+0x48>
f010a874:	68 a4 5f 12 f0       	push   $0xf0125fa4
f010a879:	68 8d 5f 12 f0       	push   $0xf0125f8d
f010a87e:	68 40 01 00 00       	push   $0x140
f010a883:	68 b8 5d 12 f0       	push   $0xf0125db8
f010a888:	e8 ac 5a ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010a88d:	8b 45 10             	mov    0x10(%ebp),%eax
f010a890:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a893:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a896:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a89b:	89 c1                	mov    %eax,%ecx
f010a89d:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010a8a0:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a8a3:	89 d0                	mov    %edx,%eax
f010a8a5:	01 c0                	add    %eax,%eax
f010a8a7:	01 d0                	add    %edx,%eax
f010a8a9:	c1 e0 03             	shl    $0x3,%eax
f010a8ac:	01 d8                	add    %ebx,%eax
f010a8ae:	05 ac 00 00 00       	add    $0xac,%eax
f010a8b3:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010a8b5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a8b8:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a8bb:	89 d0                	mov    %edx,%eax
f010a8bd:	01 c0                	add    %eax,%eax
f010a8bf:	01 d0                	add    %edx,%eax
f010a8c1:	c1 e0 03             	shl    $0x3,%eax
f010a8c4:	01 c8                	add    %ecx,%eax
f010a8c6:	05 b0 00 00 00       	add    $0xb0,%eax
f010a8cb:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f010a8ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a8d1:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a8d4:	89 d0                	mov    %edx,%eax
f010a8d6:	01 c0                	add    %eax,%eax
f010a8d8:	01 d0                	add    %edx,%eax
f010a8da:	c1 e0 03             	shl    $0x3,%eax
f010a8dd:	01 c8                	add    %ecx,%eax
f010a8df:	05 b4 00 00 00       	add    $0xb4,%eax
f010a8e4:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010a8ea:	90                   	nop
}
f010a8eb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a8ee:	c9                   	leave  
f010a8ef:	c3                   	ret    

f010a8f0 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010a8f0:	55                   	push   %ebp
f010a8f1:	89 e5                	mov    %esp,%ebp
f010a8f3:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a8f6:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a8fa:	76 19                	jbe    f010a915 <env_table_ws_clear_entry+0x25>
f010a8fc:	68 5c 5f 12 f0       	push   $0xf0125f5c
f010a901:	68 8d 5f 12 f0       	push   $0xf0125f8d
f010a906:	68 4b 01 00 00       	push   $0x14b
f010a90b:	68 b8 5d 12 f0       	push   $0xf0125db8
f010a910:	e8 24 5a ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010a915:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a918:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a91b:	89 d0                	mov    %edx,%eax
f010a91d:	01 c0                	add    %eax,%eax
f010a91f:	01 d0                	add    %edx,%eax
f010a921:	c1 e0 03             	shl    $0x3,%eax
f010a924:	01 c8                	add    %ecx,%eax
f010a926:	05 ac 00 00 00       	add    $0xac,%eax
f010a92b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010a931:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a934:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a937:	89 d0                	mov    %edx,%eax
f010a939:	01 c0                	add    %eax,%eax
f010a93b:	01 d0                	add    %edx,%eax
f010a93d:	c1 e0 03             	shl    $0x3,%eax
f010a940:	01 c8                	add    %ecx,%eax
f010a942:	05 b0 00 00 00       	add    $0xb0,%eax
f010a947:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010a94a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a94d:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a950:	89 d0                	mov    %edx,%eax
f010a952:	01 c0                	add    %eax,%eax
f010a954:	01 d0                	add    %edx,%eax
f010a956:	c1 e0 03             	shl    $0x3,%eax
f010a959:	01 c8                	add    %ecx,%eax
f010a95b:	05 b4 00 00 00       	add    $0xb4,%eax
f010a960:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010a966:	90                   	nop
f010a967:	c9                   	leave  
f010a968:	c3                   	ret    

f010a969 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010a969:	55                   	push   %ebp
f010a96a:	89 e5                	mov    %esp,%ebp
f010a96c:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a96f:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a973:	76 19                	jbe    f010a98e <env_table_ws_get_virtual_address+0x25>
f010a975:	68 5c 5f 12 f0       	push   $0xf0125f5c
f010a97a:	68 8d 5f 12 f0       	push   $0xf0125f8d
f010a97f:	68 53 01 00 00       	push   $0x153
f010a984:	68 b8 5d 12 f0       	push   $0xf0125db8
f010a989:	e8 ab 59 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010a98e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a991:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a994:	89 d0                	mov    %edx,%eax
f010a996:	01 c0                	add    %eax,%eax
f010a998:	01 d0                	add    %edx,%eax
f010a99a:	c1 e0 03             	shl    $0x3,%eax
f010a99d:	01 c8                	add    %ecx,%eax
f010a99f:	05 ac 00 00 00       	add    $0xac,%eax
f010a9a4:	8b 00                	mov    (%eax),%eax
f010a9a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a9a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a9ac:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010a9b1:	c9                   	leave  
f010a9b2:	c3                   	ret    

f010a9b3 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010a9b3:	55                   	push   %ebp
f010a9b4:	89 e5                	mov    %esp,%ebp
f010a9b6:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a9b9:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a9bd:	76 19                	jbe    f010a9d8 <env_table_ws_get_time_stamp+0x25>
f010a9bf:	68 5c 5f 12 f0       	push   $0xf0125f5c
f010a9c4:	68 8d 5f 12 f0       	push   $0xf0125f8d
f010a9c9:	68 5a 01 00 00       	push   $0x15a
f010a9ce:	68 b8 5d 12 f0       	push   $0xf0125db8
f010a9d3:	e8 61 59 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010a9d8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9db:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9de:	89 d0                	mov    %edx,%eax
f010a9e0:	01 c0                	add    %eax,%eax
f010a9e2:	01 d0                	add    %edx,%eax
f010a9e4:	c1 e0 03             	shl    $0x3,%eax
f010a9e7:	01 c8                	add    %ecx,%eax
f010a9e9:	05 b4 00 00 00       	add    $0xb4,%eax
f010a9ee:	8b 00                	mov    (%eax),%eax
}
f010a9f0:	c9                   	leave  
f010a9f1:	c3                   	ret    

f010a9f2 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010a9f2:	55                   	push   %ebp
f010a9f3:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010a9f5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9f8:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9fb:	89 d0                	mov    %edx,%eax
f010a9fd:	01 c0                	add    %eax,%eax
f010a9ff:	01 d0                	add    %edx,%eax
f010aa01:	c1 e0 03             	shl    $0x3,%eax
f010aa04:	01 c8                	add    %ecx,%eax
f010aa06:	05 b0 00 00 00       	add    $0xb0,%eax
f010aa0b:	8a 00                	mov    (%eax),%al
f010aa0d:	0f b6 c0             	movzbl %al,%eax
}
f010aa10:	5d                   	pop    %ebp
f010aa11:	c3                   	ret    

f010aa12 <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010aa12:	55                   	push   %ebp
f010aa13:	89 e5                	mov    %esp,%ebp
f010aa15:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010aa18:	83 ec 04             	sub    $0x4,%esp
f010aa1b:	68 d7 5f 12 f0       	push   $0xf0125fd7
f010aa20:	68 6a 01 00 00       	push   $0x16a
f010aa25:	68 b8 5d 12 f0       	push   $0xf0125db8
f010aa2a:	e8 0a 59 ff ff       	call   f0100339 <_panic>

f010aa2f <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010aa2f:	55                   	push   %ebp
f010aa30:	89 e5                	mov    %esp,%ebp
f010aa32:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010aa35:	83 ec 04             	sub    $0x4,%esp
f010aa38:	68 d7 5f 12 f0       	push   $0xf0125fd7
f010aa3d:	68 6f 01 00 00       	push   $0x16f
f010aa42:	68 b8 5d 12 f0       	push   $0xf0125db8
f010aa47:	e8 ed 58 ff ff       	call   f0100339 <_panic>

f010aa4c <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010aa4c:	55                   	push   %ebp
f010aa4d:	89 e5                	mov    %esp,%ebp
f010aa4f:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f010aa52:	83 ec 04             	sub    $0x4,%esp
f010aa55:	68 e8 5f 12 f0       	push   $0xf0125fe8
f010aa5a:	6a 22                	push   $0x22
f010aa5c:	68 16 60 12 f0       	push   $0xf0126016
f010aa61:	e8 d3 58 ff ff       	call   f0100339 <_panic>

f010aa66 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010aa66:	55                   	push   %ebp
f010aa67:	89 e5                	mov    %esp,%ebp
f010aa69:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010aa6c:	83 ec 04             	sub    $0x4,%esp
f010aa6f:	68 34 60 12 f0       	push   $0xf0126034
f010aa74:	6a 35                	push   $0x35
f010aa76:	68 16 60 12 f0       	push   $0xf0126016
f010aa7b:	e8 b9 58 ff ff       	call   f0100339 <_panic>

f010aa80 <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010aa80:	55                   	push   %ebp
f010aa81:	89 e5                	mov    %esp,%ebp
f010aa83:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010aa86:	83 ec 04             	sub    $0x4,%esp
f010aa89:	68 64 60 12 f0       	push   $0xf0126064
f010aa8e:	6a 45                	push   $0x45
f010aa90:	68 16 60 12 f0       	push   $0xf0126016
f010aa95:	e8 9f 58 ff ff       	call   f0100339 <_panic>

f010aa9a <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010aa9a:	55                   	push   %ebp
f010aa9b:	89 e5                	mov    %esp,%ebp
f010aa9d:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f010aaa0:	83 ec 04             	sub    $0x4,%esp
f010aaa3:	68 90 60 12 f0       	push   $0xf0126090
f010aaa8:	6a 53                	push   $0x53
f010aaaa:	68 16 60 12 f0       	push   $0xf0126016
f010aaaf:	e8 85 58 ff ff       	call   f0100339 <_panic>

f010aab4 <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010aab4:	55                   	push   %ebp
f010aab5:	89 e5                	mov    %esp,%ebp
f010aab7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010aaba:	83 ec 04             	sub    $0x4,%esp
f010aabd:	68 c0 60 12 f0       	push   $0xf01260c0
f010aac2:	6a 5d                	push   $0x5d
f010aac4:	68 16 60 12 f0       	push   $0xf0126016
f010aac9:	e8 6b 58 ff ff       	call   f0100339 <_panic>

f010aace <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010aace:	55                   	push   %ebp
f010aacf:	89 e5                	mov    %esp,%ebp
f010aad1:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010aad4:	83 ec 04             	sub    $0x4,%esp
f010aad7:	68 f8 60 12 f0       	push   $0xf01260f8
f010aadc:	6a 6a                	push   $0x6a
f010aade:	68 16 60 12 f0       	push   $0xf0126016
f010aae3:	e8 51 58 ff ff       	call   f0100339 <_panic>

f010aae8 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010aae8:	55                   	push   %ebp
f010aae9:	89 e5                	mov    %esp,%ebp
f010aaeb:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
//	return (void*)-1 ;
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f010aaee:	e8 98 0e 00 00       	call   f010b98b <get_cpu_proc>
f010aaf3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(numOfPages > 0)
f010aaf6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010aafa:	7e 61                	jle    f010ab5d <sys_sbrk+0x75>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010aafc:	8b 45 08             	mov    0x8(%ebp),%eax
f010aaff:	c1 e0 0c             	shl    $0xc,%eax
f010ab02:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk = env->heap_brk;
f010ab05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab08:	8b 40 7c             	mov    0x7c(%eax),%eax
f010ab0b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(env->heap_brk + size > env->heap_hard_limit || LIST_SIZE(&MemFrameLists.free_frame_list) < 1) return (void *)-1;
f010ab0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab11:	8b 50 7c             	mov    0x7c(%eax),%edx
f010ab14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ab17:	01 c2                	add    %eax,%edx
f010ab19:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab1c:	8b 40 78             	mov    0x78(%eax),%eax
f010ab1f:	39 c2                	cmp    %eax,%edx
f010ab21:	77 09                	ja     f010ab2c <sys_sbrk+0x44>
f010ab23:	a1 8c 06 6c f0       	mov    0xf06c068c,%eax
f010ab28:	85 c0                	test   %eax,%eax
f010ab2a:	75 07                	jne    f010ab33 <sys_sbrk+0x4b>
f010ab2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010ab31:	eb 3d                	jmp    f010ab70 <sys_sbrk+0x88>
		allocate_user_mem(env, prev_brk, size);
f010ab33:	83 ec 04             	sub    $0x4,%esp
f010ab36:	ff 75 f0             	pushl  -0x10(%ebp)
f010ab39:	ff 75 ec             	pushl  -0x14(%ebp)
f010ab3c:	ff 75 f4             	pushl  -0xc(%ebp)
f010ab3f:	e8 2e 00 00 00       	call   f010ab72 <allocate_user_mem>
f010ab44:	83 c4 10             	add    $0x10,%esp
		env->heap_brk += size;
f010ab47:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab4a:	8b 50 7c             	mov    0x7c(%eax),%edx
f010ab4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ab50:	01 c2                	add    %eax,%edx
f010ab52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab55:	89 50 7c             	mov    %edx,0x7c(%eax)
		return (void *)prev_brk;
f010ab58:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ab5b:	eb 13                	jmp    f010ab70 <sys_sbrk+0x88>

	}
	else if(numOfPages == 0)
f010ab5d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ab61:	75 08                	jne    f010ab6b <sys_sbrk+0x83>
	{
		return (void *) env->heap_brk;
f010ab63:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab66:	8b 40 7c             	mov    0x7c(%eax),%eax
f010ab69:	eb 05                	jmp    f010ab70 <sys_sbrk+0x88>
	}

	return (void *)-1;
f010ab6b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f010ab70:	c9                   	leave  
f010ab71:	c3                   	ret    

f010ab72 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ab72:	55                   	push   %ebp
f010ab73:	89 e5                	mov    %esp,%ebp
f010ab75:	83 ec 28             	sub    $0x28,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010ab78:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010ab7f:	8b 55 10             	mov    0x10(%ebp),%edx
f010ab82:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ab85:	01 d0                	add    %edx,%eax
f010ab87:	48                   	dec    %eax
f010ab88:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ab8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ab8e:	ba 00 00 00 00       	mov    $0x0,%edx
f010ab93:	f7 75 f0             	divl   -0x10(%ebp)
f010ab96:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ab99:	29 d0                	sub    %edx,%eax
f010ab9b:	c1 e8 0c             	shr    $0xc,%eax
f010ab9e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for(int i = 0; i < no_of_pages; i++){
f010aba1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010aba8:	eb 78                	jmp    f010ac22 <allocate_user_mem+0xb0>
		uint32* ptr_table;
		int ret = get_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,&ptr_table);
f010abaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abad:	c1 e0 0c             	shl    $0xc,%eax
f010abb0:	89 c2                	mov    %eax,%edx
f010abb2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010abb5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010abb8:	8b 45 08             	mov    0x8(%ebp),%eax
f010abbb:	8b 40 64             	mov    0x64(%eax),%eax
f010abbe:	83 ec 04             	sub    $0x4,%esp
f010abc1:	8d 55 e0             	lea    -0x20(%ebp),%edx
f010abc4:	52                   	push   %edx
f010abc5:	51                   	push   %ecx
f010abc6:	50                   	push   %eax
f010abc7:	e8 23 d8 ff ff       	call   f01083ef <get_page_table>
f010abcc:	83 c4 10             	add    $0x10,%esp
f010abcf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(ret == TABLE_NOT_EXIST)
f010abd2:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f010abd6:	75 23                	jne    f010abfb <allocate_user_mem+0x89>
		{
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
f010abd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abdb:	c1 e0 0c             	shl    $0xc,%eax
f010abde:	89 c2                	mov    %eax,%edx
f010abe0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010abe3:	01 c2                	add    %eax,%edx
f010abe5:	8b 45 08             	mov    0x8(%ebp),%eax
f010abe8:	8b 40 64             	mov    0x64(%eax),%eax
f010abeb:	83 ec 08             	sub    $0x8,%esp
f010abee:	52                   	push   %edx
f010abef:	50                   	push   %eax
f010abf0:	e8 50 d9 ff ff       	call   f0108545 <create_page_table>
f010abf5:	83 c4 10             	add    $0x10,%esp
f010abf8:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
f010abfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abfe:	c1 e0 0c             	shl    $0xc,%eax
f010ac01:	89 c2                	mov    %eax,%edx
f010ac03:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ac06:	01 c2                	add    %eax,%edx
f010ac08:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac0b:	8b 40 64             	mov    0x64(%eax),%eax
f010ac0e:	6a 00                	push   $0x0
f010ac10:	68 00 02 00 00       	push   $0x200
f010ac15:	52                   	push   %edx
f010ac16:	50                   	push   %eax
f010ac17:	e8 af ef ff ff       	call   f0109bcb <pt_set_page_permissions>
f010ac1c:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0; i < no_of_pages; i++){
f010ac1f:	ff 45 f4             	incl   -0xc(%ebp)
f010ac22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac25:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010ac28:	72 80                	jb     f010abaa <allocate_user_mem+0x38>
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
	}

}
f010ac2a:	90                   	nop
f010ac2b:	c9                   	leave  
f010ac2c:	c3                   	ret    

f010ac2d <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ac2d:	55                   	push   %ebp
f010ac2e:	89 e5                	mov    %esp,%ebp
f010ac30:	83 ec 28             	sub    $0x28,%esp

	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010ac33:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010ac3a:	8b 55 10             	mov    0x10(%ebp),%edx
f010ac3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ac40:	01 d0                	add    %edx,%eax
f010ac42:	48                   	dec    %eax
f010ac43:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ac46:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ac49:	ba 00 00 00 00       	mov    $0x0,%edx
f010ac4e:	f7 75 f0             	divl   -0x10(%ebp)
f010ac51:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ac54:	29 d0                	sub    %edx,%eax
f010ac56:	c1 e8 0c             	shr    $0xc,%eax
f010ac59:	89 45 e8             	mov    %eax,-0x18(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f010ac5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ac63:	e9 86 00 00 00       	jmp    f010acee <free_user_mem+0xc1>
			pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
f010ac68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac6b:	c1 e0 0c             	shl    $0xc,%eax
f010ac6e:	89 c2                	mov    %eax,%edx
f010ac70:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ac73:	01 c2                	add    %eax,%edx
f010ac75:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac78:	8b 40 64             	mov    0x64(%eax),%eax
f010ac7b:	68 00 02 00 00       	push   $0x200
f010ac80:	6a 00                	push   $0x0
f010ac82:	52                   	push   %edx
f010ac83:	50                   	push   %eax
f010ac84:	e8 42 ef ff ff       	call   f0109bcb <pt_set_page_permissions>
f010ac89:	83 c4 10             	add    $0x10,%esp
			int ret = pf_read_env_page(e,(void*)((i*PAGE_SIZE)+virtual_address));
f010ac8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac8f:	c1 e0 0c             	shl    $0xc,%eax
f010ac92:	89 c2                	mov    %eax,%edx
f010ac94:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ac97:	01 d0                	add    %edx,%eax
f010ac99:	83 ec 08             	sub    $0x8,%esp
f010ac9c:	50                   	push   %eax
f010ac9d:	ff 75 08             	pushl  0x8(%ebp)
f010aca0:	e8 3c 98 ff ff       	call   f01044e1 <pf_read_env_page>
f010aca5:	83 c4 10             	add    $0x10,%esp
f010aca8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
f010acab:	83 7d e4 f7          	cmpl   $0xfffffff7,-0x1c(%ebp)
f010acaf:	75 1e                	jne    f010accf <free_user_mem+0xa2>
f010acb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acb4:	c1 e0 0c             	shl    $0xc,%eax
f010acb7:	89 c2                	mov    %eax,%edx
f010acb9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010acbc:	01 d0                	add    %edx,%eax
f010acbe:	83 ec 08             	sub    $0x8,%esp
f010acc1:	50                   	push   %eax
f010acc2:	ff 75 08             	pushl  0x8(%ebp)
f010acc5:	e8 a2 f1 ff ff       	call   f0109e6c <env_page_ws_invalidate>
f010acca:	83 c4 10             	add    $0x10,%esp
f010accd:	eb 1c                	jmp    f010aceb <free_user_mem+0xbe>
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);
f010accf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acd2:	c1 e0 0c             	shl    $0xc,%eax
f010acd5:	89 c2                	mov    %eax,%edx
f010acd7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010acda:	01 d0                	add    %edx,%eax
f010acdc:	83 ec 08             	sub    $0x8,%esp
f010acdf:	50                   	push   %eax
f010ace0:	ff 75 08             	pushl  0x8(%ebp)
f010ace3:	e8 bc 98 ff ff       	call   f01045a4 <pf_remove_env_page>
f010ace8:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
		for(int i = 0; i < no_of_pages; i++){
f010aceb:	ff 45 f4             	incl   -0xc(%ebp)
f010acee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acf1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010acf4:	0f 82 6e ff ff ff    	jb     f010ac68 <free_user_mem+0x3b>
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);


		}
}
f010acfa:	90                   	nop
f010acfb:	c9                   	leave  
f010acfc:	c3                   	ret    

f010acfd <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010acfd:	55                   	push   %ebp
f010acfe:	89 e5                	mov    %esp,%ebp
f010ad00:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010ad03:	83 ec 04             	sub    $0x4,%esp
f010ad06:	68 30 61 12 f0       	push   $0xf0126130
f010ad0b:	68 e0 00 00 00       	push   $0xe0
f010ad10:	68 16 60 12 f0       	push   $0xf0126016
f010ad15:	e8 1f 56 ff ff       	call   f0100339 <_panic>

f010ad1a <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010ad1a:	55                   	push   %ebp
f010ad1b:	89 e5                	mov    %esp,%ebp
f010ad1d:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010ad20:	83 ec 04             	sub    $0x4,%esp
f010ad23:	68 70 61 12 f0       	push   $0xf0126170
f010ad28:	68 ea 00 00 00       	push   $0xea
f010ad2d:	68 16 60 12 f0       	push   $0xf0126016
f010ad32:	e8 02 56 ff ff       	call   f0100339 <_panic>

f010ad37 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010ad37:	55                   	push   %ebp
f010ad38:	89 e5                	mov    %esp,%ebp
f010ad3a:	56                   	push   %esi
f010ad3b:	53                   	push   %ebx
f010ad3c:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010ad3f:	c7 45 f4 c9 02 00 00 	movl   $0x2c9,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010ad46:	e9 b0 01 00 00       	jmp    f010aefb <env_init+0x1c4>
	{
		envs[iEnv].env_status = ENV_FREE;
f010ad4b:	8b 0d f0 7a 69 f0    	mov    0xf0697af0,%ecx
f010ad51:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ad54:	89 d0                	mov    %edx,%eax
f010ad56:	c1 e0 03             	shl    $0x3,%eax
f010ad59:	01 d0                	add    %edx,%eax
f010ad5b:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ad62:	01 d8                	add    %ebx,%eax
f010ad64:	01 c0                	add    %eax,%eax
f010ad66:	01 d0                	add    %edx,%eax
f010ad68:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ad6f:	01 d8                	add    %ebx,%eax
f010ad71:	01 d0                	add    %edx,%eax
f010ad73:	01 c8                	add    %ecx,%eax
f010ad75:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010ad7c:	8b 0d f0 7a 69 f0    	mov    0xf0697af0,%ecx
f010ad82:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ad85:	89 d0                	mov    %edx,%eax
f010ad87:	c1 e0 03             	shl    $0x3,%eax
f010ad8a:	01 d0                	add    %edx,%eax
f010ad8c:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ad93:	01 d8                	add    %ebx,%eax
f010ad95:	01 c0                	add    %eax,%eax
f010ad97:	01 d0                	add    %edx,%eax
f010ad99:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ada0:	01 d8                	add    %ebx,%eax
f010ada2:	01 d0                	add    %edx,%eax
f010ada4:	01 c8                	add    %ecx,%eax
f010ada6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010adad:	8b 0d f0 7a 69 f0    	mov    0xf0697af0,%ecx
f010adb3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010adb6:	89 d0                	mov    %edx,%eax
f010adb8:	c1 e0 03             	shl    $0x3,%eax
f010adbb:	01 d0                	add    %edx,%eax
f010adbd:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010adc4:	01 d8                	add    %ebx,%eax
f010adc6:	01 c0                	add    %eax,%eax
f010adc8:	01 d0                	add    %edx,%eax
f010adca:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010add1:	01 d8                	add    %ebx,%eax
f010add3:	01 d0                	add    %edx,%eax
f010add5:	01 c8                	add    %ecx,%eax
f010add7:	85 c0                	test   %eax,%eax
f010add9:	75 14                	jne    f010adef <env_init+0xb8>
f010addb:	83 ec 04             	sub    $0x4,%esp
f010adde:	68 9c 61 12 f0       	push   $0xf012619c
f010ade3:	6a 65                	push   $0x65
f010ade5:	68 bf 61 12 f0       	push   $0xf01261bf
f010adea:	e8 4a 55 ff ff       	call   f0100339 <_panic>
f010adef:	8b 0d f0 7a 69 f0    	mov    0xf0697af0,%ecx
f010adf5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010adf8:	89 d0                	mov    %edx,%eax
f010adfa:	c1 e0 03             	shl    $0x3,%eax
f010adfd:	01 d0                	add    %edx,%eax
f010adff:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae06:	01 d8                	add    %ebx,%eax
f010ae08:	01 c0                	add    %eax,%eax
f010ae0a:	01 d0                	add    %edx,%eax
f010ae0c:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae13:	01 d8                	add    %ebx,%eax
f010ae15:	01 d0                	add    %edx,%eax
f010ae17:	01 c8                	add    %ecx,%eax
f010ae19:	8b 15 f4 7a 69 f0    	mov    0xf0697af4,%edx
f010ae1f:	89 50 08             	mov    %edx,0x8(%eax)
f010ae22:	8b 40 08             	mov    0x8(%eax),%eax
f010ae25:	85 c0                	test   %eax,%eax
f010ae27:	74 35                	je     f010ae5e <env_init+0x127>
f010ae29:	8b 0d f4 7a 69 f0    	mov    0xf0697af4,%ecx
f010ae2f:	8b 1d f0 7a 69 f0    	mov    0xf0697af0,%ebx
f010ae35:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae38:	89 d0                	mov    %edx,%eax
f010ae3a:	c1 e0 03             	shl    $0x3,%eax
f010ae3d:	01 d0                	add    %edx,%eax
f010ae3f:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010ae46:	01 f0                	add    %esi,%eax
f010ae48:	01 c0                	add    %eax,%eax
f010ae4a:	01 d0                	add    %edx,%eax
f010ae4c:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010ae53:	01 f0                	add    %esi,%eax
f010ae55:	01 d0                	add    %edx,%eax
f010ae57:	01 d8                	add    %ebx,%eax
f010ae59:	89 41 0c             	mov    %eax,0xc(%ecx)
f010ae5c:	eb 2f                	jmp    f010ae8d <env_init+0x156>
f010ae5e:	8b 0d f0 7a 69 f0    	mov    0xf0697af0,%ecx
f010ae64:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae67:	89 d0                	mov    %edx,%eax
f010ae69:	c1 e0 03             	shl    $0x3,%eax
f010ae6c:	01 d0                	add    %edx,%eax
f010ae6e:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae75:	01 d8                	add    %ebx,%eax
f010ae77:	01 c0                	add    %eax,%eax
f010ae79:	01 d0                	add    %edx,%eax
f010ae7b:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae82:	01 d8                	add    %ebx,%eax
f010ae84:	01 d0                	add    %edx,%eax
f010ae86:	01 c8                	add    %ecx,%eax
f010ae88:	a3 f8 7a 69 f0       	mov    %eax,0xf0697af8
f010ae8d:	8b 0d f0 7a 69 f0    	mov    0xf0697af0,%ecx
f010ae93:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae96:	89 d0                	mov    %edx,%eax
f010ae98:	c1 e0 03             	shl    $0x3,%eax
f010ae9b:	01 d0                	add    %edx,%eax
f010ae9d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aea4:	01 d8                	add    %ebx,%eax
f010aea6:	01 c0                	add    %eax,%eax
f010aea8:	01 d0                	add    %edx,%eax
f010aeaa:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aeb1:	01 d8                	add    %ebx,%eax
f010aeb3:	01 d0                	add    %edx,%eax
f010aeb5:	01 c8                	add    %ecx,%eax
f010aeb7:	a3 f4 7a 69 f0       	mov    %eax,0xf0697af4
f010aebc:	8b 0d f0 7a 69 f0    	mov    0xf0697af0,%ecx
f010aec2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aec5:	89 d0                	mov    %edx,%eax
f010aec7:	c1 e0 03             	shl    $0x3,%eax
f010aeca:	01 d0                	add    %edx,%eax
f010aecc:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aed3:	01 d8                	add    %ebx,%eax
f010aed5:	01 c0                	add    %eax,%eax
f010aed7:	01 d0                	add    %edx,%eax
f010aed9:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aee0:	01 d8                	add    %ebx,%eax
f010aee2:	01 d0                	add    %edx,%eax
f010aee4:	01 c8                	add    %ecx,%eax
f010aee6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010aeed:	a1 00 7b 69 f0       	mov    0xf0697b00,%eax
f010aef2:	40                   	inc    %eax
f010aef3:	a3 00 7b 69 f0       	mov    %eax,0xf0697b00
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010aef8:	ff 4d f4             	decl   -0xc(%ebp)
f010aefb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010aeff:	0f 89 46 fe ff ff    	jns    f010ad4b <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010af05:	90                   	nop
f010af06:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010af09:	5b                   	pop    %ebx
f010af0a:	5e                   	pop    %esi
f010af0b:	5d                   	pop    %ebp
f010af0c:	c3                   	ret    

f010af0d <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010af0d:	55                   	push   %ebp
f010af0e:	89 e5                	mov    %esp,%ebp
f010af10:	57                   	push   %edi
f010af11:	56                   	push   %esi
f010af12:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010af18:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010af1f:	83 ec 0c             	sub    $0xc,%esp
f010af22:	ff 75 08             	pushl  0x8(%ebp)
f010af25:	e8 b8 1e 00 00       	call   f010cde2 <get_user_program_info>
f010af2a:	83 c4 10             	add    $0x10,%esp
f010af2d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010af30:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010af34:	75 0a                	jne    f010af40 <env_create+0x33>
	{
		return NULL;
f010af36:	b8 00 00 00 00       	mov    $0x0,%eax
f010af3b:	e9 aa 09 00 00       	jmp    f010b8ea <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010af40:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010af43:	8b 40 08             	mov    0x8(%eax),%eax
f010af46:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010af49:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010af50:	00 00 00 
	if(allocate_environment(&e) < 0)
f010af53:	83 ec 0c             	sub    $0xc,%esp
f010af56:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010af5c:	50                   	push   %eax
f010af5d:	e8 96 0e 00 00       	call   f010bdf8 <allocate_environment>
f010af62:	83 c4 10             	add    $0x10,%esp
f010af65:	85 c0                	test   %eax,%eax
f010af67:	79 0a                	jns    f010af73 <env_create+0x66>
	{
		return NULL;
f010af69:	b8 00 00 00 00       	mov    $0x0,%eax
f010af6e:	e9 77 09 00 00       	jmp    f010b8ea <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010af73:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010af76:	8b 00                	mov    (%eax),%eax
f010af78:	83 ec 0c             	sub    $0xc,%esp
f010af7b:	50                   	push   %eax
f010af7c:	e8 47 4c 01 00       	call   f011fbc8 <strlen>
f010af81:	83 c4 10             	add    $0x10,%esp
f010af84:	83 f8 3f             	cmp    $0x3f,%eax
f010af87:	7f 1d                	jg     f010afa6 <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010af89:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010af8c:	8b 00                	mov    (%eax),%eax
f010af8e:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010af94:	83 c2 20             	add    $0x20,%edx
f010af97:	83 ec 08             	sub    $0x8,%esp
f010af9a:	50                   	push   %eax
f010af9b:	52                   	push   %edx
f010af9c:	e8 76 4c 01 00       	call   f011fc17 <strcpy>
f010afa1:	83 c4 10             	add    $0x10,%esp
f010afa4:	eb 1d                	jmp    f010afc3 <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010afa6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010afa9:	8b 00                	mov    (%eax),%eax
f010afab:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010afb1:	83 c2 20             	add    $0x20,%edx
f010afb4:	83 ec 04             	sub    $0x4,%esp
f010afb7:	6a 3f                	push   $0x3f
f010afb9:	50                   	push   %eax
f010afba:	52                   	push   %edx
f010afbb:	e8 85 4c 01 00       	call   f011fc45 <strncpy>
f010afc0:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010afc3:	e8 fc 13 00 00       	call   f010c3c4 <create_user_directory>
f010afc8:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010afcb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010afce:	83 ec 0c             	sub    $0xc,%esp
f010afd1:	50                   	push   %eax
f010afd2:	e8 00 e8 ff ff       	call   f01097d7 <kheap_physical_address>
f010afd7:	83 c4 10             	add    $0x10,%esp
f010afda:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010afdd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afe3:	8b 55 0c             	mov    0xc(%ebp),%edx
f010afe6:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010afec:	83 ec 0c             	sub    $0xc,%esp
f010afef:	6a 02                	push   $0x2
f010aff1:	e8 d1 45 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f010aff6:	83 c4 10             	add    $0x10,%esp
f010aff9:	85 c0                	test   %eax,%eax
f010affb:	74 21                	je     f010b01e <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010affd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b003:	8b 55 10             	mov    0x10(%ebp),%edx
f010b006:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010b00c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b012:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b015:	2b 55 10             	sub    0x10(%ebp),%edx
f010b018:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010b01e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010b022:	75 12                	jne    f010b036 <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010b024:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b02a:	c7 80 8c 05 00 00 0a 	movl   $0xa,0x58c(%eax)
f010b031:	00 00 00 
f010b034:	eb 0f                	jmp    f010b045 <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010b036:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b03c:	8b 55 14             	mov    0x14(%ebp),%edx
f010b03f:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010b045:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b04b:	83 ec 04             	sub    $0x4,%esp
f010b04e:	ff 75 bc             	pushl  -0x44(%ebp)
f010b051:	ff 75 c0             	pushl  -0x40(%ebp)
f010b054:	50                   	push   %eax
f010b055:	e8 c8 14 00 00       	call   f010c522 <initialize_environment>
f010b05a:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010b05d:	e8 6d c1 ff ff       	call   f01071cf <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010b062:	0f 20 d8             	mov    %cr3,%eax
f010b065:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010b068:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010b06b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010b06e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b074:	8b 40 68             	mov    0x68(%eax),%eax
f010b077:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b07d:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010b083:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010b086:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010b08d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010b094:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b09a:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b0a0:	48                   	dec    %eax
f010b0a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010b0a4:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010b0ab:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b0ae:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010b0b4:	83 ec 08             	sub    $0x8,%esp
f010b0b7:	ff 75 c8             	pushl  -0x38(%ebp)
f010b0ba:	50                   	push   %eax
f010b0bb:	e8 34 1a 00 00       	call   f010caf4 <PROGRAM_SEGMENT_FIRST>
f010b0c0:	83 c4 0c             	add    $0xc,%esp
f010b0c3:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b0c9:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010b0cf:	b9 05 00 00 00       	mov    $0x5,%ecx
f010b0d4:	89 c7                	mov    %eax,%edi
f010b0d6:	89 d6                	mov    %edx,%esi
f010b0d8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010b0da:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b0e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010b0e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b0e6:	8b 40 10             	mov    0x10(%eax),%eax
f010b0e9:	83 f8 ff             	cmp    $0xffffffff,%eax
f010b0ec:	75 07                	jne    f010b0f5 <env_create+0x1e8>
f010b0ee:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010b0f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b0f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b0fb:	e9 fa 02 00 00       	jmp    f010b3fa <env_create+0x4ed>
		{
			segment_counter++;
f010b100:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010b103:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010b10a:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010b10d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b113:	83 ec 0c             	sub    $0xc,%esp
f010b116:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010b11c:	52                   	push   %edx
f010b11d:	ff 75 ec             	pushl  -0x14(%ebp)
f010b120:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010b126:	52                   	push   %edx
f010b127:	ff 75 f4             	pushl  -0xc(%ebp)
f010b12a:	50                   	push   %eax
f010b12b:	e8 86 0d 00 00       	call   f010beb6 <program_segment_alloc_map_copy_workingset>
f010b130:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010b133:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010b139:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010b13c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b13f:	8b 00                	mov    (%eax),%eax
f010b141:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010b144:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b147:	8b 40 0c             	mov    0xc(%eax),%eax
f010b14a:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010b14d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b150:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010b153:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010b156:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b15b:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010b15e:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010b165:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010b168:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010b16b:	01 d0                	add    %edx,%eax
f010b16d:	48                   	dec    %eax
f010b16e:	89 45 98             	mov    %eax,-0x68(%ebp)
f010b171:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b174:	ba 00 00 00 00       	mov    $0x0,%edx
f010b179:	f7 75 9c             	divl   -0x64(%ebp)
f010b17c:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b17f:	29 d0                	sub    %edx,%eax
f010b181:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010b184:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b187:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010b18a:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010b18d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b190:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010b193:	8b 15 2c 0d 6c f0    	mov    0xf06c0d2c,%edx
f010b199:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b19c:	01 d0                	add    %edx,%eax
f010b19e:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010b1a1:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010b1a5:	74 73                	je     f010b21a <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010b1a7:	a1 2c 0d 6c f0       	mov    0xf06c0d2c,%eax
f010b1ac:	83 ec 04             	sub    $0x4,%esp
f010b1af:	68 00 10 00 00       	push   $0x1000
f010b1b4:	6a 00                	push   $0x0
f010b1b6:	50                   	push   %eax
f010b1b7:	e8 fa 4b 01 00       	call   f011fdb6 <memset>
f010b1bc:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b1bf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b1c2:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b1c5:	eb 13                	jmp    f010b1da <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010b1c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b1ca:	8a 10                	mov    (%eax),%dl
f010b1cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b1cf:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b1d1:	ff 45 dc             	incl   -0x24(%ebp)
f010b1d4:	ff 45 e4             	incl   -0x1c(%ebp)
f010b1d7:	ff 45 e0             	incl   -0x20(%ebp)
f010b1da:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b1dd:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010b1e0:	72 e5                	jb     f010b1c7 <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b1e2:	8b 15 2c 0d 6c f0    	mov    0xf06c0d2c,%edx
f010b1e8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b1ee:	83 ec 04             	sub    $0x4,%esp
f010b1f1:	52                   	push   %edx
f010b1f2:	ff 75 a0             	pushl  -0x60(%ebp)
f010b1f5:	50                   	push   %eax
f010b1f6:	e8 36 90 ff ff       	call   f0104231 <pf_add_env_page>
f010b1fb:	83 c4 10             	add    $0x10,%esp
f010b1fe:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b201:	75 17                	jne    f010b21a <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b203:	83 ec 04             	sub    $0x4,%esp
f010b206:	68 dc 61 12 f0       	push   $0xf01261dc
f010b20b:	68 f5 00 00 00       	push   $0xf5
f010b210:	68 bf 61 12 f0       	push   $0xf01261bf
f010b215:	e8 1f 51 ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010b21a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b21d:	8b 50 04             	mov    0x4(%eax),%edx
f010b220:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b223:	01 d0                	add    %edx,%eax
f010b225:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010b228:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010b22b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b230:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010b233:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b236:	8b 50 04             	mov    0x4(%eax),%edx
f010b239:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b23c:	01 d0                	add    %edx,%eax
f010b23e:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b241:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010b244:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b247:	eb 43                	jmp    f010b28c <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010b249:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010b24c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b252:	83 ec 04             	sub    $0x4,%esp
f010b255:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b258:	52                   	push   %edx
f010b259:	50                   	push   %eax
f010b25a:	e8 d2 8f ff ff       	call   f0104231 <pf_add_env_page>
f010b25f:	83 c4 10             	add    $0x10,%esp
f010b262:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b265:	75 17                	jne    f010b27e <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b267:	83 ec 04             	sub    $0x4,%esp
f010b26a:	68 dc 61 12 f0       	push   $0xf01261dc
f010b26f:	68 02 01 00 00       	push   $0x102
f010b274:	68 bf 61 12 f0       	push   $0xf01261bf
f010b279:	e8 bb 50 ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b27e:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b285:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010b28c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b28f:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010b292:	72 b5                	jb     f010b249 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010b294:	a1 2c 0d 6c f0       	mov    0xf06c0d2c,%eax
f010b299:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010b29c:	83 ec 04             	sub    $0x4,%esp
f010b29f:	68 00 10 00 00       	push   $0x1000
f010b2a4:	6a 00                	push   $0x0
f010b2a6:	ff 75 e0             	pushl  -0x20(%ebp)
f010b2a9:	e8 08 4b 01 00       	call   f011fdb6 <memset>
f010b2ae:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b2b1:	8b 45 88             	mov    -0x78(%ebp),%eax
f010b2b4:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b2b7:	eb 13                	jmp    f010b2cc <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010b2b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b2bc:	8a 10                	mov    (%eax),%dl
f010b2be:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b2c1:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b2c3:	ff 45 dc             	incl   -0x24(%ebp)
f010b2c6:	ff 45 e4             	incl   -0x1c(%ebp)
f010b2c9:	ff 45 e0             	incl   -0x20(%ebp)
f010b2cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b2cf:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010b2d2:	72 e5                	jb     f010b2b9 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b2d4:	8b 15 2c 0d 6c f0    	mov    0xf06c0d2c,%edx
f010b2da:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b2e0:	83 ec 04             	sub    $0x4,%esp
f010b2e3:	52                   	push   %edx
f010b2e4:	ff 75 88             	pushl  -0x78(%ebp)
f010b2e7:	50                   	push   %eax
f010b2e8:	e8 44 8f ff ff       	call   f0104231 <pf_add_env_page>
f010b2ed:	83 c4 10             	add    $0x10,%esp
f010b2f0:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b2f3:	75 17                	jne    f010b30c <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b2f5:	83 ec 04             	sub    $0x4,%esp
f010b2f8:	68 dc 61 12 f0       	push   $0xf01261dc
f010b2fd:	68 11 01 00 00       	push   $0x111
f010b302:	68 bf 61 12 f0       	push   $0xf01261bf
f010b307:	e8 2d 50 ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010b30c:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010b313:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b316:	8b 50 04             	mov    0x4(%eax),%edx
f010b319:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b31c:	01 c2                	add    %eax,%edx
f010b31e:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b321:	01 d0                	add    %edx,%eax
f010b323:	48                   	dec    %eax
f010b324:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010b32a:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b330:	ba 00 00 00 00       	mov    $0x0,%edx
f010b335:	f7 75 80             	divl   -0x80(%ebp)
f010b338:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b33e:	29 d0                	sub    %edx,%eax
f010b340:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010b343:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b346:	8b 50 08             	mov    0x8(%eax),%edx
f010b349:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b34c:	01 d0                	add    %edx,%eax
f010b34e:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010b351:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b357:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010b35e:	eb 41                	jmp    f010b3a1 <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010b360:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b366:	83 ec 04             	sub    $0x4,%esp
f010b369:	6a 01                	push   $0x1
f010b36b:	ff 75 d8             	pushl  -0x28(%ebp)
f010b36e:	50                   	push   %eax
f010b36f:	e8 8c 8d ff ff       	call   f0104100 <pf_add_empty_env_page>
f010b374:	83 c4 10             	add    $0x10,%esp
f010b377:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b37a:	75 17                	jne    f010b393 <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b37c:	83 ec 04             	sub    $0x4,%esp
f010b37f:	68 dc 61 12 f0       	push   $0xf01261dc
f010b384:	68 1e 01 00 00       	push   $0x11e
f010b389:	68 bf 61 12 f0       	push   $0xf01261bf
f010b38e:	e8 a6 4f ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b393:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b39a:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010b3a1:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010b3a8:	10 00 00 
f010b3ab:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010b3b1:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010b3b7:	01 d0                	add    %edx,%eax
f010b3b9:	48                   	dec    %eax
f010b3ba:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010b3c0:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b3c6:	ba 00 00 00 00       	mov    $0x0,%edx
f010b3cb:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010b3d1:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b3d7:	29 d0                	sub    %edx,%eax
f010b3d9:	89 c2                	mov    %eax,%edx
f010b3db:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b3de:	39 c2                	cmp    %eax,%edx
f010b3e0:	0f 87 7a ff ff ff    	ja     f010b360 <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b3e6:	83 ec 08             	sub    $0x8,%esp
f010b3e9:	ff 75 c8             	pushl  -0x38(%ebp)
f010b3ec:	ff 75 f4             	pushl  -0xc(%ebp)
f010b3ef:	e8 f5 15 00 00       	call   f010c9e9 <PROGRAM_SEGMENT_NEXT>
f010b3f4:	83 c4 10             	add    $0x10,%esp
f010b3f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b3fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b3fe:	0f 85 fc fc ff ff    	jne    f010b100 <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b404:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b40a:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b410:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b413:	eb 77                	jmp    f010b48c <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010b415:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b418:	8b 00                	mov    (%eax),%eax
f010b41a:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010b420:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b426:	8b 40 64             	mov    0x64(%eax),%eax
f010b429:	83 ec 04             	sub    $0x4,%esp
f010b42c:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010b432:	52                   	push   %edx
f010b433:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010b439:	50                   	push   %eax
f010b43a:	e8 b0 cf ff ff       	call   f01083ef <get_page_table>
f010b43f:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010b442:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010b448:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010b44e:	c1 ea 0c             	shr    $0xc,%edx
f010b451:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b457:	c1 e2 02             	shl    $0x2,%edx
f010b45a:	01 d0                	add    %edx,%eax
f010b45c:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010b462:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010b468:	c1 e9 0c             	shr    $0xc,%ecx
f010b46b:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b471:	c1 e1 02             	shl    $0x2,%ecx
f010b474:	01 ca                	add    %ecx,%edx
f010b476:	8b 12                	mov    (%edx),%edx
f010b478:	83 e2 bf             	and    $0xffffffbf,%edx
f010b47b:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b47d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b483:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b489:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b48c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b492:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b496:	74 08                	je     f010b4a0 <env_create+0x593>
f010b498:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b49b:	8b 52 10             	mov    0x10(%edx),%edx
f010b49e:	eb 05                	jmp    f010b4a5 <env_create+0x598>
f010b4a0:	ba 00 00 00 00       	mov    $0x0,%edx
f010b4a5:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f010b4ab:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b4b1:	85 c0                	test   %eax,%eax
f010b4b3:	0f 85 5c ff ff ff    	jne    f010b415 <env_create+0x508>
f010b4b9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b4bd:	0f 85 52 ff ff ff    	jne    f010b415 <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010b4c3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b4c6:	8b 50 08             	mov    0x8(%eax),%edx
f010b4c9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b4cf:	83 ec 08             	sub    $0x8,%esp
f010b4d2:	52                   	push   %edx
f010b4d3:	50                   	push   %eax
f010b4d4:	e8 d0 14 00 00       	call   f010c9a9 <set_environment_entry_point>
f010b4d9:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010b4dc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b4e2:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010b4e9:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010b4f0:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010b4f3:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b4fa:	e9 42 03 00 00       	jmp    f010b841 <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010b4ff:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010b506:	00 00 00 
			allocate_frame(&pp);
f010b509:	83 ec 0c             	sub    $0xc,%esp
f010b50c:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010b512:	50                   	push   %eax
f010b513:	e8 9a cc ff ff       	call   f01081b2 <allocate_frame>
f010b518:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010b51b:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010b521:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b527:	8b 40 64             	mov    0x64(%eax),%eax
f010b52a:	6a 06                	push   $0x6
f010b52c:	ff 75 d0             	pushl  -0x30(%ebp)
f010b52f:	52                   	push   %edx
f010b530:	50                   	push   %eax
f010b531:	e8 4d d3 ff ff       	call   f0108883 <loadtime_map_frame>
f010b536:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010b539:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b53c:	83 ec 04             	sub    $0x4,%esp
f010b53f:	68 00 10 00 00       	push   $0x1000
f010b544:	6a 00                	push   $0x0
f010b546:	50                   	push   %eax
f010b547:	e8 6a 48 01 00       	call   f011fdb6 <memset>
f010b54c:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010b54f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b555:	83 ec 08             	sub    $0x8,%esp
f010b558:	ff 75 d0             	pushl  -0x30(%ebp)
f010b55b:	50                   	push   %eax
f010b55c:	e8 a0 e8 ff ff       	call   f0109e01 <env_page_ws_list_create_element>
f010b561:	83 c4 10             	add    $0x10,%esp
f010b564:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b567:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b56b:	75 17                	jne    f010b584 <env_create+0x677>
f010b56d:	83 ec 04             	sub    $0x4,%esp
f010b570:	68 24 62 12 f0       	push   $0xf0126224
f010b575:	68 5d 01 00 00       	push   $0x15d
f010b57a:	68 bf 61 12 f0       	push   $0xf01261bf
f010b57f:	e8 b5 4d ff ff       	call   f0100339 <_panic>
f010b584:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b58a:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010b590:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b593:	89 50 14             	mov    %edx,0x14(%eax)
f010b596:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b599:	8b 40 14             	mov    0x14(%eax),%eax
f010b59c:	85 c0                	test   %eax,%eax
f010b59e:	74 14                	je     f010b5b4 <env_create+0x6a7>
f010b5a0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5a6:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010b5ac:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b5af:	89 50 10             	mov    %edx,0x10(%eax)
f010b5b2:	eb 0f                	jmp    f010b5c3 <env_create+0x6b6>
f010b5b4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5ba:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b5bd:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b5c3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5c9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b5cc:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b5d2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b5d5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b5dc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5e2:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b5e8:	42                   	inc    %edx
f010b5e9:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b5ef:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5f5:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b5fb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b601:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b607:	39 c2                	cmp    %eax,%edx
f010b609:	75 1a                	jne    f010b625 <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b60b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b611:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b617:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b61d:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010b623:	eb 10                	jmp    f010b635 <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b625:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b62b:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010b632:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b635:	83 ec 0c             	sub    $0xc,%esp
f010b638:	6a 02                	push   $0x2
f010b63a:	e8 88 3f 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f010b63f:	83 c4 10             	add    $0x10,%esp
f010b642:	85 c0                	test   %eax,%eax
f010b644:	0f 84 d3 01 00 00    	je     f010b81d <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b64a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b64e:	75 17                	jne    f010b667 <env_create+0x75a>
f010b650:	83 ec 04             	sub    $0x4,%esp
f010b653:	68 47 62 12 f0       	push   $0xf0126247
f010b658:	68 6a 01 00 00       	push   $0x16a
f010b65d:	68 bf 61 12 f0       	push   $0xf01261bf
f010b662:	e8 d2 4c ff ff       	call   f0100339 <_panic>
f010b667:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b66a:	8b 40 10             	mov    0x10(%eax),%eax
f010b66d:	85 c0                	test   %eax,%eax
f010b66f:	74 11                	je     f010b682 <env_create+0x775>
f010b671:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b674:	8b 40 10             	mov    0x10(%eax),%eax
f010b677:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b67a:	8b 52 14             	mov    0x14(%edx),%edx
f010b67d:	89 50 14             	mov    %edx,0x14(%eax)
f010b680:	eb 12                	jmp    f010b694 <env_create+0x787>
f010b682:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b688:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b68b:	8b 52 14             	mov    0x14(%edx),%edx
f010b68e:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b694:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b697:	8b 40 14             	mov    0x14(%eax),%eax
f010b69a:	85 c0                	test   %eax,%eax
f010b69c:	74 11                	je     f010b6af <env_create+0x7a2>
f010b69e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b6a1:	8b 40 14             	mov    0x14(%eax),%eax
f010b6a4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b6a7:	8b 52 10             	mov    0x10(%edx),%edx
f010b6aa:	89 50 10             	mov    %edx,0x10(%eax)
f010b6ad:	eb 12                	jmp    f010b6c1 <env_create+0x7b4>
f010b6af:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6b5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b6b8:	8b 52 10             	mov    0x10(%edx),%edx
f010b6bb:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b6c1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b6c4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b6cb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b6ce:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b6d5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6db:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b6e1:	4a                   	dec    %edx
f010b6e2:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010b6e8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6ee:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b6f4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6fa:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b700:	39 c2                	cmp    %eax,%edx
f010b702:	0f 83 8d 00 00 00    	jae    f010b795 <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b708:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b70c:	75 17                	jne    f010b725 <env_create+0x818>
f010b70e:	83 ec 04             	sub    $0x4,%esp
f010b711:	68 9c 61 12 f0       	push   $0xf012619c
f010b716:	68 6f 01 00 00       	push   $0x16f
f010b71b:	68 bf 61 12 f0       	push   $0xf01261bf
f010b720:	e8 14 4c ff ff       	call   f0100339 <_panic>
f010b725:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b72b:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010b731:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b734:	89 50 10             	mov    %edx,0x10(%eax)
f010b737:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b73a:	8b 40 10             	mov    0x10(%eax),%eax
f010b73d:	85 c0                	test   %eax,%eax
f010b73f:	74 14                	je     f010b755 <env_create+0x848>
f010b741:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b747:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010b74d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b750:	89 50 14             	mov    %edx,0x14(%eax)
f010b753:	eb 0f                	jmp    f010b764 <env_create+0x857>
f010b755:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b75b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b75e:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010b764:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b76a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b76d:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010b773:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b776:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b77d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b783:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b789:	42                   	inc    %edx
f010b78a:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010b790:	e9 88 00 00 00       	jmp    f010b81d <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b795:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b799:	75 17                	jne    f010b7b2 <env_create+0x8a5>
f010b79b:	83 ec 04             	sub    $0x4,%esp
f010b79e:	68 9c 61 12 f0       	push   $0xf012619c
f010b7a3:	68 73 01 00 00       	push   $0x173
f010b7a8:	68 bf 61 12 f0       	push   $0xf01261bf
f010b7ad:	e8 87 4b ff ff       	call   f0100339 <_panic>
f010b7b2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7b8:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010b7be:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b7c1:	89 50 10             	mov    %edx,0x10(%eax)
f010b7c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b7c7:	8b 40 10             	mov    0x10(%eax),%eax
f010b7ca:	85 c0                	test   %eax,%eax
f010b7cc:	74 14                	je     f010b7e2 <env_create+0x8d5>
f010b7ce:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7d4:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b7da:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b7dd:	89 50 14             	mov    %edx,0x14(%eax)
f010b7e0:	eb 0f                	jmp    f010b7f1 <env_create+0x8e4>
f010b7e2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7e8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b7eb:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010b7f1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7f7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b7fa:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010b800:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b803:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b80a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b810:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f010b816:	42                   	inc    %edx
f010b817:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010b81d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b823:	83 ec 04             	sub    $0x4,%esp
f010b826:	6a 01                	push   $0x1
f010b828:	ff 75 d0             	pushl  -0x30(%ebp)
f010b82b:	50                   	push   %eax
f010b82c:	e8 cf 88 ff ff       	call   f0104100 <pf_add_empty_env_page>
f010b831:	83 c4 10             	add    $0x10,%esp
f010b834:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b83a:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010b841:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b844:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010b84a:	0f 83 af fc ff ff    	jae    f010b4ff <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b850:	83 ec 0c             	sub    $0xc,%esp
f010b853:	6a 02                	push   $0x2
f010b855:	e8 6d 3d 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f010b85a:	83 c4 10             	add    $0x10,%esp
f010b85d:	85 c0                	test   %eax,%eax
f010b85f:	74 72                	je     f010b8d3 <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010b861:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010b868:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b86e:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b874:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b877:	eb 2b                	jmp    f010b8a4 <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010b879:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b87c:	8b 10                	mov    (%eax),%edx
f010b87e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b884:	8b 40 64             	mov    0x64(%eax),%eax
f010b887:	6a 01                	push   $0x1
f010b889:	6a 00                	push   $0x0
f010b88b:	52                   	push   %edx
f010b88c:	50                   	push   %eax
f010b88d:	e8 39 e3 ff ff       	call   f0109bcb <pt_set_page_permissions>
f010b892:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010b895:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b89b:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b8a1:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b8a4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8aa:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b8ae:	74 08                	je     f010b8b8 <env_create+0x9ab>
f010b8b0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b8b3:	8b 52 10             	mov    0x10(%edx),%edx
f010b8b6:	eb 05                	jmp    f010b8bd <env_create+0x9b0>
f010b8b8:	ba 00 00 00 00       	mov    $0x0,%edx
f010b8bd:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010b8c3:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b8c9:	85 c0                	test   %eax,%eax
f010b8cb:	75 ac                	jne    f010b879 <env_create+0x96c>
f010b8cd:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b8d1:	75 a6                	jne    f010b879 <env_create+0x96c>
f010b8d3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b8d6:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b8d9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b8dc:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010b8df:	e8 3d b9 ff ff       	call   f0107221 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010b8e4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010b8ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010b8ed:	5e                   	pop    %esi
f010b8ee:	5f                   	pop    %edi
f010b8ef:	5d                   	pop    %ebp
f010b8f0:	c3                   	ret    

f010b8f1 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010b8f1:	55                   	push   %ebp
f010b8f2:	89 e5                	mov    %esp,%ebp
f010b8f4:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010b8f7:	83 ec 0c             	sub    $0xc,%esp
f010b8fa:	68 e0 05 6c f0       	push   $0xf06c05e0
f010b8ff:	e8 9d 43 00 00       	call   f010fca1 <release_spinlock>
f010b904:	83 c4 10             	add    $0x10,%esp

	if (first)
f010b907:	a1 60 f9 17 f0       	mov    0xf017f960,%eax
f010b90c:	85 c0                	test   %eax,%eax
f010b90e:	74 30                	je     f010b940 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010b910:	e8 76 00 00 00       	call   f010b98b <get_cpu_proc>
f010b915:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010b918:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b91b:	8b 40 10             	mov    0x10(%eax),%eax
f010b91e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b921:	83 c2 20             	add    $0x20,%edx
f010b924:	83 ec 04             	sub    $0x4,%esp
f010b927:	50                   	push   %eax
f010b928:	52                   	push   %edx
f010b929:	68 65 62 12 f0       	push   $0xf0126265
f010b92e:	e8 58 56 ff ff       	call   f0100f8b <cprintf>
f010b933:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010b936:	c7 05 60 f9 17 f0 00 	movl   $0x0,0xf017f960
f010b93d:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010b940:	90                   	nop
f010b941:	c9                   	leave  
f010b942:	c3                   	ret    

f010b943 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010b943:	55                   	push   %ebp
f010b944:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010b946:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010b947:	5d                   	pop    %ebp
f010b948:	c3                   	ret    

f010b949 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010b949:	55                   	push   %ebp
f010b94a:	89 e5                	mov    %esp,%ebp
f010b94c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010b94f:	e8 37 00 00 00       	call   f010b98b <get_cpu_proc>
f010b954:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010b957:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b95b:	75 19                	jne    f010b976 <env_exit+0x2d>
f010b95d:	68 7b 62 12 f0       	push   $0xf012627b
f010b962:	68 8b 62 12 f0       	push   $0xf012628b
f010b967:	68 ed 01 00 00       	push   $0x1ed
f010b96c:	68 bf 61 12 f0       	push   $0xf01261bf
f010b971:	e8 c3 49 ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010b976:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b979:	8b 40 10             	mov    0x10(%eax),%eax
f010b97c:	83 ec 0c             	sub    $0xc,%esp
f010b97f:	50                   	push   %eax
f010b980:	e8 a4 9e ff ff       	call   f0105829 <sched_exit_env>
f010b985:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010b988:	90                   	nop
f010b989:	c9                   	leave  
f010b98a:	c3                   	ret    

f010b98b <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010b98b:	55                   	push   %ebp
f010b98c:	89 e5                	mov    %esp,%ebp
f010b98e:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010b991:	e8 39 b8 ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010b996:	e8 71 b7 ff ff       	call   f010710c <mycpu>
f010b99b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010b99e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b9a1:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b9a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010b9aa:	e8 72 b8 ff ff       	call   f0107221 <popcli>
	return p;
f010b9af:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010b9b2:	c9                   	leave  
f010b9b3:	c3                   	ret    

f010b9b4 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010b9b4:	55                   	push   %ebp
f010b9b5:	89 e5                	mov    %esp,%ebp
f010b9b7:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010b9ba:	e8 10 b8 ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010b9bf:	e8 48 b7 ff ff       	call   f010710c <mycpu>
f010b9c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010b9c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b9ca:	8b 55 08             	mov    0x8(%ebp),%edx
f010b9cd:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010b9d3:	e8 49 b8 ff ff       	call   f0107221 <popcli>
}
f010b9d8:	90                   	nop
f010b9d9:	c9                   	leave  
f010b9da:	c3                   	ret    

f010b9db <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010b9db:	55                   	push   %ebp
f010b9dc:	89 e5                	mov    %esp,%ebp
f010b9de:	53                   	push   %ebx
f010b9df:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010b9e2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b9e6:	75 16                	jne    f010b9fe <envid2env+0x23>
		*env_store = get_cpu_proc();
f010b9e8:	e8 9e ff ff ff       	call   f010b98b <get_cpu_proc>
f010b9ed:	89 c2                	mov    %eax,%edx
f010b9ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b9f2:	89 10                	mov    %edx,(%eax)
		return 0;
f010b9f4:	b8 00 00 00 00       	mov    $0x0,%eax
f010b9f9:	e9 aa 00 00 00       	jmp    f010baa8 <envid2env+0xcd>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010b9fe:	8b 1d f0 7a 69 f0    	mov    0xf0697af0,%ebx
f010ba04:	83 ec 0c             	sub    $0xc,%esp
f010ba07:	68 ca 02 00 00       	push   $0x2ca
f010ba0c:	e8 15 27 01 00       	call   f011e126 <nearest_pow2_ceil>
f010ba11:	83 c4 10             	add    $0x10,%esp
f010ba14:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ba17:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba1a:	21 c2                	and    %eax,%edx
f010ba1c:	89 d0                	mov    %edx,%eax
f010ba1e:	c1 e0 03             	shl    $0x3,%eax
f010ba21:	01 d0                	add    %edx,%eax
f010ba23:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010ba2a:	01 c8                	add    %ecx,%eax
f010ba2c:	01 c0                	add    %eax,%eax
f010ba2e:	01 d0                	add    %edx,%eax
f010ba30:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010ba37:	01 c8                	add    %ecx,%eax
f010ba39:	01 d0                	add    %edx,%eax
f010ba3b:	01 d8                	add    %ebx,%eax
f010ba3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010ba40:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba43:	8b 40 18             	mov    0x18(%eax),%eax
f010ba46:	85 c0                	test   %eax,%eax
f010ba48:	74 0b                	je     f010ba55 <envid2env+0x7a>
f010ba4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba4d:	8b 40 10             	mov    0x10(%eax),%eax
f010ba50:	3b 45 08             	cmp    0x8(%ebp),%eax
f010ba53:	74 10                	je     f010ba65 <envid2env+0x8a>
		*env_store = 0;
f010ba55:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ba58:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010ba5e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010ba63:	eb 43                	jmp    f010baa8 <envid2env+0xcd>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010ba65:	e8 21 ff ff ff       	call   f010b98b <get_cpu_proc>
f010ba6a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010ba6d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010ba71:	74 28                	je     f010ba9b <envid2env+0xc0>
f010ba73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba76:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ba79:	74 20                	je     f010ba9b <envid2env+0xc0>
f010ba7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba7e:	8b 50 14             	mov    0x14(%eax),%edx
f010ba81:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ba84:	8b 40 10             	mov    0x10(%eax),%eax
f010ba87:	39 c2                	cmp    %eax,%edx
f010ba89:	74 10                	je     f010ba9b <envid2env+0xc0>
		*env_store = 0;
f010ba8b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ba8e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010ba94:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010ba99:	eb 0d                	jmp    f010baa8 <envid2env+0xcd>
	}

	*env_store = e;
f010ba9b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ba9e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010baa1:	89 10                	mov    %edx,(%eax)
	return 0;
f010baa3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010baa8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010baab:	c9                   	leave  
f010baac:	c3                   	ret    

f010baad <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010baad:	55                   	push   %ebp
f010baae:	89 e5                	mov    %esp,%ebp
f010bab0:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010bab3:	83 ec 0c             	sub    $0xc,%esp
f010bab6:	68 e0 05 6c f0       	push   $0xf06c05e0
f010babb:	e8 5a 41 00 00       	call   f010fc1a <acquire_spinlock>
f010bac0:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010bac3:	e8 c3 fe ff ff       	call   f010b98b <get_cpu_proc>
f010bac8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010bacb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bacf:	75 19                	jne    f010baea <yield+0x3d>
f010bad1:	68 a0 62 12 f0       	push   $0xf01262a0
f010bad6:	68 8b 62 12 f0       	push   $0xf012628b
f010badb:	68 4c 02 00 00       	push   $0x24c
f010bae0:	68 bf 61 12 f0       	push   $0xf01261bf
f010bae5:	e8 4f 48 ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010baea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010baed:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010baf4:	e8 13 00 00 00       	call   f010bb0c <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010baf9:	83 ec 0c             	sub    $0xc,%esp
f010bafc:	68 e0 05 6c f0       	push   $0xf06c05e0
f010bb01:	e8 9b 41 00 00       	call   f010fca1 <release_spinlock>
f010bb06:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010bb09:	90                   	nop
f010bb0a:	c9                   	leave  
f010bb0b:	c3                   	ret    

f010bb0c <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010bb0c:	55                   	push   %ebp
f010bb0d:	89 e5                	mov    %esp,%ebp
f010bb0f:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010bb12:	e8 74 fe ff ff       	call   f010b98b <get_cpu_proc>
f010bb17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010bb1a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bb1e:	75 19                	jne    f010bb39 <sched+0x2d>
f010bb20:	68 a0 62 12 f0       	push   $0xf01262a0
f010bb25:	68 8b 62 12 f0       	push   $0xf012628b
f010bb2a:	68 60 02 00 00       	push   $0x260
f010bb2f:	68 bf 61 12 f0       	push   $0xf01261bf
f010bb34:	e8 00 48 ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010bb39:	83 ec 0c             	sub    $0xc,%esp
f010bb3c:	68 e0 05 6c f0       	push   $0xf06c05e0
f010bb41:	e8 ed 42 00 00       	call   f010fe33 <holding_spinlock>
f010bb46:	83 c4 10             	add    $0x10,%esp
f010bb49:	85 c0                	test   %eax,%eax
f010bb4b:	75 17                	jne    f010bb64 <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010bb4d:	83 ec 04             	sub    $0x4,%esp
f010bb50:	68 ac 62 12 f0       	push   $0xf01262ac
f010bb55:	68 64 02 00 00       	push   $0x264
f010bb5a:	68 bf 61 12 f0       	push   $0xf01261bf
f010bb5f:	e8 d5 47 ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010bb64:	e8 a3 b5 ff ff       	call   f010710c <mycpu>
f010bb69:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bb6f:	83 f8 01             	cmp    $0x1,%eax
f010bb72:	74 20                	je     f010bb94 <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010bb74:	e8 93 b5 ff ff       	call   f010710c <mycpu>
f010bb79:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bb7f:	50                   	push   %eax
f010bb80:	68 ee 62 12 f0       	push   $0xf01262ee
f010bb85:	68 67 02 00 00       	push   $0x267
f010bb8a:	68 bf 61 12 f0       	push   $0xf01261bf
f010bb8f:	e8 a5 47 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010bb94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb97:	8b 40 18             	mov    0x18(%eax),%eax
f010bb9a:	83 f8 02             	cmp    $0x2,%eax
f010bb9d:	75 17                	jne    f010bbb6 <sched+0xaa>
		panic("sched a running process");
f010bb9f:	83 ec 04             	sub    $0x4,%esp
f010bba2:	68 05 63 12 f0       	push   $0xf0126305
f010bba7:	68 6a 02 00 00       	push   $0x26a
f010bbac:	68 bf 61 12 f0       	push   $0xf01261bf
f010bbb1:	e8 83 47 ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010bbb6:	9c                   	pushf  
f010bbb7:	58                   	pop    %eax
f010bbb8:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010bbbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010bbbe:	25 00 02 00 00       	and    $0x200,%eax
f010bbc3:	85 c0                	test   %eax,%eax
f010bbc5:	74 17                	je     f010bbde <sched+0xd2>
		panic("sched is interruptible!");
f010bbc7:	83 ec 04             	sub    $0x4,%esp
f010bbca:	68 1d 63 12 f0       	push   $0xf012631d
f010bbcf:	68 6c 02 00 00       	push   $0x26c
f010bbd4:	68 bf 61 12 f0       	push   $0xf01261bf
f010bbd9:	e8 5b 47 ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010bbde:	e8 29 b5 ff ff       	call   f010710c <mycpu>
f010bbe3:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010bbe9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010bbec:	e8 1b b5 ff ff       	call   f010710c <mycpu>
f010bbf1:	8b 40 04             	mov    0x4(%eax),%eax
f010bbf4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bbf7:	83 c2 04             	add    $0x4,%edx
f010bbfa:	83 ec 08             	sub    $0x8,%esp
f010bbfd:	50                   	push   %eax
f010bbfe:	52                   	push   %edx
f010bbff:	e8 6d 8f ff ff       	call   f0104b71 <context_switch>
f010bc04:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010bc07:	e8 00 b5 ff ff       	call   f010710c <mycpu>
f010bc0c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bc0f:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010bc15:	90                   	nop
f010bc16:	c9                   	leave  
f010bc17:	c3                   	ret    

f010bc18 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010bc18:	55                   	push   %ebp
f010bc19:	89 e5                	mov    %esp,%ebp
f010bc1b:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010bc1e:	a1 c4 0d 6c f0       	mov    0xf06c0dc4,%eax
f010bc23:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bc26:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010bc29:	0f 22 d8             	mov    %eax,%cr3
}
f010bc2c:	90                   	nop
f010bc2d:	c9                   	leave  
f010bc2e:	c3                   	ret    

f010bc2f <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010bc2f:	55                   	push   %ebp
f010bc30:	89 e5                	mov    %esp,%ebp
f010bc32:	53                   	push   %ebx
f010bc33:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010bc36:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bc3a:	75 17                	jne    f010bc53 <switchuvm+0x24>
		panic("switchuvm: no process");
f010bc3c:	83 ec 04             	sub    $0x4,%esp
f010bc3f:	68 35 63 12 f0       	push   $0xf0126335
f010bc44:	68 81 02 00 00       	push   $0x281
f010bc49:	68 bf 61 12 f0       	push   $0xf01261bf
f010bc4e:	e8 e6 46 ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010bc53:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc56:	8b 40 70             	mov    0x70(%eax),%eax
f010bc59:	85 c0                	test   %eax,%eax
f010bc5b:	75 17                	jne    f010bc74 <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010bc5d:	83 ec 04             	sub    $0x4,%esp
f010bc60:	68 4b 63 12 f0       	push   $0xf012634b
f010bc65:	68 83 02 00 00       	push   $0x283
f010bc6a:	68 bf 61 12 f0       	push   $0xf01261bf
f010bc6f:	e8 c5 46 ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010bc74:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc77:	8b 40 64             	mov    0x64(%eax),%eax
f010bc7a:	85 c0                	test   %eax,%eax
f010bc7c:	75 17                	jne    f010bc95 <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010bc7e:	83 ec 04             	sub    $0x4,%esp
f010bc81:	68 60 63 12 f0       	push   $0xf0126360
f010bc86:	68 85 02 00 00       	push   $0x285
f010bc8b:	68 bf 61 12 f0       	push   $0xf01261bf
f010bc90:	e8 a4 46 ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010bc95:	e8 35 b5 ff ff       	call   f01071cf <pushcli>
	struct cpu* c = mycpu();
f010bc9a:	e8 6d b4 ff ff       	call   f010710c <mycpu>
f010bc9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010bca2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bca5:	8b 55 08             	mov    0x8(%ebp),%edx
f010bca8:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010bcae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bcb1:	83 c0 0c             	add    $0xc,%eax
f010bcb4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bcb7:	83 c2 0c             	add    $0xc,%edx
f010bcba:	c1 ea 10             	shr    $0x10,%edx
f010bcbd:	88 d3                	mov    %dl,%bl
f010bcbf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bcc2:	83 c2 0c             	add    $0xc,%edx
f010bcc5:	c1 ea 18             	shr    $0x18,%edx
f010bcc8:	88 d1                	mov    %dl,%cl
f010bcca:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bccd:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010bcd4:	68 00 
f010bcd6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bcd9:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010bce0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bce3:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010bce9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bcec:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bcf2:	83 e2 f0             	and    $0xfffffff0,%edx
f010bcf5:	83 ca 09             	or     $0x9,%edx
f010bcf8:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bcfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd01:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd07:	83 ca 10             	or     $0x10,%edx
f010bd0a:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bd10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd13:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd19:	83 e2 9f             	and    $0xffffff9f,%edx
f010bd1c:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bd22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd25:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd2b:	83 ca 80             	or     $0xffffff80,%edx
f010bd2e:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bd34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd37:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bd3d:	83 e2 f0             	and    $0xfffffff0,%edx
f010bd40:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bd46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd49:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bd4f:	83 e2 ef             	and    $0xffffffef,%edx
f010bd52:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bd58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd5b:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bd61:	83 e2 df             	and    $0xffffffdf,%edx
f010bd64:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bd6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd6d:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bd73:	83 ca 40             	or     $0x40,%edx
f010bd76:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bd7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd7f:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bd85:	83 e2 7f             	and    $0x7f,%edx
f010bd88:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bd8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd91:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010bd97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd9a:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bda0:	83 e2 ef             	and    $0xffffffef,%edx
f010bda3:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010bda9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdac:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010bdb2:	8b 40 70             	mov    0x70(%eax),%eax
f010bdb5:	05 00 80 00 00       	add    $0x8000,%eax
f010bdba:	89 c2                	mov    %eax,%edx
f010bdbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdbf:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010bdc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdc5:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010bdcb:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010bdd1:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010bdd5:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010bdd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bddb:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010bde1:	8b 40 68             	mov    0x68(%eax),%eax
f010bde4:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bde7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bdea:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010bded:	e8 2f b4 ff ff       	call   f0107221 <popcli>
}
f010bdf2:	90                   	nop
f010bdf3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bdf6:	c9                   	leave  
f010bdf7:	c3                   	ret    

f010bdf8 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010bdf8:	55                   	push   %ebp
f010bdf9:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010bdfb:	8b 15 f4 7a 69 f0    	mov    0xf0697af4,%edx
f010be01:	8b 45 08             	mov    0x8(%ebp),%eax
f010be04:	89 10                	mov    %edx,(%eax)
f010be06:	8b 45 08             	mov    0x8(%ebp),%eax
f010be09:	8b 00                	mov    (%eax),%eax
f010be0b:	85 c0                	test   %eax,%eax
f010be0d:	75 07                	jne    f010be16 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010be0f:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010be14:	eb 11                	jmp    f010be27 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010be16:	8b 45 08             	mov    0x8(%ebp),%eax
f010be19:	8b 00                	mov    (%eax),%eax
f010be1b:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010be22:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010be27:	5d                   	pop    %ebp
f010be28:	c3                   	ret    

f010be29 <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010be29:	55                   	push   %ebp
f010be2a:	89 e5                	mov    %esp,%ebp
f010be2c:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010be2f:	83 ec 04             	sub    $0x4,%esp
f010be32:	68 bc 05 00 00       	push   $0x5bc
f010be37:	6a 00                	push   $0x0
f010be39:	ff 75 08             	pushl  0x8(%ebp)
f010be3c:	e8 75 3f 01 00       	call   f011fdb6 <memset>
f010be41:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010be44:	8b 45 08             	mov    0x8(%ebp),%eax
f010be47:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010be4e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010be52:	75 17                	jne    f010be6b <free_environment+0x42>
f010be54:	83 ec 04             	sub    $0x4,%esp
f010be57:	68 9c 61 12 f0       	push   $0xf012619c
f010be5c:	68 c0 02 00 00       	push   $0x2c0
f010be61:	68 bf 61 12 f0       	push   $0xf01261bf
f010be66:	e8 ce 44 ff ff       	call   f0100339 <_panic>
f010be6b:	8b 15 f4 7a 69 f0    	mov    0xf0697af4,%edx
f010be71:	8b 45 08             	mov    0x8(%ebp),%eax
f010be74:	89 50 08             	mov    %edx,0x8(%eax)
f010be77:	8b 45 08             	mov    0x8(%ebp),%eax
f010be7a:	8b 40 08             	mov    0x8(%eax),%eax
f010be7d:	85 c0                	test   %eax,%eax
f010be7f:	74 0d                	je     f010be8e <free_environment+0x65>
f010be81:	a1 f4 7a 69 f0       	mov    0xf0697af4,%eax
f010be86:	8b 55 08             	mov    0x8(%ebp),%edx
f010be89:	89 50 0c             	mov    %edx,0xc(%eax)
f010be8c:	eb 08                	jmp    f010be96 <free_environment+0x6d>
f010be8e:	8b 45 08             	mov    0x8(%ebp),%eax
f010be91:	a3 f8 7a 69 f0       	mov    %eax,0xf0697af8
f010be96:	8b 45 08             	mov    0x8(%ebp),%eax
f010be99:	a3 f4 7a 69 f0       	mov    %eax,0xf0697af4
f010be9e:	8b 45 08             	mov    0x8(%ebp),%eax
f010bea1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010bea8:	a1 00 7b 69 f0       	mov    0xf0697b00,%eax
f010bead:	40                   	inc    %eax
f010beae:	a3 00 7b 69 f0       	mov    %eax,0xf0697b00
}
f010beb3:	90                   	nop
f010beb4:	c9                   	leave  
f010beb5:	c3                   	ret    

f010beb6 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010beb6:	55                   	push   %ebp
f010beb7:	89 e5                	mov    %esp,%ebp
f010beb9:	53                   	push   %ebx
f010beba:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010bebd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bec0:	8b 40 0c             	mov    0xc(%eax),%eax
f010bec3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010bec6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bec9:	8b 40 08             	mov    0x8(%eax),%eax
f010becc:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010becf:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010bed6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010bed9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bedc:	01 c2                	add    %eax,%edx
f010bede:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bee1:	01 d0                	add    %edx,%eax
f010bee3:	48                   	dec    %eax
f010bee4:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010bee7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010beea:	ba 00 00 00 00       	mov    $0x0,%edx
f010beef:	f7 75 dc             	divl   -0x24(%ebp)
f010bef2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bef5:	29 d0                	sub    %edx,%eax
f010bef7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010befa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010befd:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010bf00:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010bf03:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bf08:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010bf0b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010bf12:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010bf19:	8b 45 10             	mov    0x10(%ebp),%eax
f010bf1c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010bf22:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010bf29:	0f 85 f5 03 00 00    	jne    f010c324 <program_segment_alloc_map_copy_workingset+0x46e>
f010bf2f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf32:	83 c0 20             	add    $0x20,%eax
f010bf35:	83 ec 08             	sub    $0x8,%esp
f010bf38:	68 74 63 12 f0       	push   $0xf0126374
f010bf3d:	50                   	push   %eax
f010bf3e:	e8 91 3d 01 00       	call   f011fcd4 <strcmp>
f010bf43:	83 c4 10             	add    $0x10,%esp
f010bf46:	85 c0                	test   %eax,%eax
f010bf48:	0f 84 d6 03 00 00    	je     f010c324 <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010bf4e:	8b 45 14             	mov    0x14(%ebp),%eax
f010bf51:	83 f8 06             	cmp    $0x6,%eax
f010bf54:	76 05                	jbe    f010bf5b <program_segment_alloc_map_copy_workingset+0xa5>
f010bf56:	b8 06 00 00 00       	mov    $0x6,%eax
f010bf5b:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010bf5e:	e9 c1 03 00 00       	jmp    f010c324 <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010bf63:	83 ec 0c             	sub    $0xc,%esp
f010bf66:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010bf69:	50                   	push   %eax
f010bf6a:	e8 43 c2 ff ff       	call   f01081b2 <allocate_frame>
f010bf6f:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010bf72:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010bf75:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf78:	8b 40 64             	mov    0x64(%eax),%eax
f010bf7b:	6a 06                	push   $0x6
f010bf7d:	ff 75 f4             	pushl  -0xc(%ebp)
f010bf80:	52                   	push   %edx
f010bf81:	50                   	push   %eax
f010bf82:	e8 fc c8 ff ff       	call   f0108883 <loadtime_map_frame>
f010bf87:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010bf8a:	83 ec 08             	sub    $0x8,%esp
f010bf8d:	ff 75 f4             	pushl  -0xc(%ebp)
f010bf90:	ff 75 08             	pushl  0x8(%ebp)
f010bf93:	e8 69 de ff ff       	call   f0109e01 <env_page_ws_list_create_element>
f010bf98:	83 c4 10             	add    $0x10,%esp
f010bf9b:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010bf9e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bfa1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010bfa8:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010bfac:	75 17                	jne    f010bfc5 <program_segment_alloc_map_copy_workingset+0x10f>
f010bfae:	83 ec 04             	sub    $0x4,%esp
f010bfb1:	68 24 62 12 f0       	push   $0xf0126224
f010bfb6:	68 ea 02 00 00       	push   $0x2ea
f010bfbb:	68 bf 61 12 f0       	push   $0xf01261bf
f010bfc0:	e8 74 43 ff ff       	call   f0100339 <_panic>
f010bfc5:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfc8:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010bfce:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bfd1:	89 50 14             	mov    %edx,0x14(%eax)
f010bfd4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bfd7:	8b 40 14             	mov    0x14(%eax),%eax
f010bfda:	85 c0                	test   %eax,%eax
f010bfdc:	74 11                	je     f010bfef <program_segment_alloc_map_copy_workingset+0x139>
f010bfde:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfe1:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010bfe7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bfea:	89 50 10             	mov    %edx,0x10(%eax)
f010bfed:	eb 0c                	jmp    f010bffb <program_segment_alloc_map_copy_workingset+0x145>
f010bfef:	8b 45 08             	mov    0x8(%ebp),%eax
f010bff2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bff5:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010bffb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bffe:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c001:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c007:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c00a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c011:	8b 45 08             	mov    0x8(%ebp),%eax
f010c014:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c01a:	8d 50 01             	lea    0x1(%eax),%edx
f010c01d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c020:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c026:	83 ec 0c             	sub    $0xc,%esp
f010c029:	6a 02                	push   $0x2
f010c02b:	e8 97 35 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f010c030:	83 c4 10             	add    $0x10,%esp
f010c033:	85 c0                	test   %eax,%eax
f010c035:	0f 84 b3 01 00 00    	je     f010c1ee <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010c03b:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c03f:	75 17                	jne    f010c058 <program_segment_alloc_map_copy_workingset+0x1a2>
f010c041:	83 ec 04             	sub    $0x4,%esp
f010c044:	68 47 62 12 f0       	push   $0xf0126247
f010c049:	68 f6 02 00 00       	push   $0x2f6
f010c04e:	68 bf 61 12 f0       	push   $0xf01261bf
f010c053:	e8 e1 42 ff ff       	call   f0100339 <_panic>
f010c058:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c05b:	8b 40 10             	mov    0x10(%eax),%eax
f010c05e:	85 c0                	test   %eax,%eax
f010c060:	74 11                	je     f010c073 <program_segment_alloc_map_copy_workingset+0x1bd>
f010c062:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c065:	8b 40 10             	mov    0x10(%eax),%eax
f010c068:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c06b:	8b 52 14             	mov    0x14(%edx),%edx
f010c06e:	89 50 14             	mov    %edx,0x14(%eax)
f010c071:	eb 0f                	jmp    f010c082 <program_segment_alloc_map_copy_workingset+0x1cc>
f010c073:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c076:	8b 50 14             	mov    0x14(%eax),%edx
f010c079:	8b 45 08             	mov    0x8(%ebp),%eax
f010c07c:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c082:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c085:	8b 40 14             	mov    0x14(%eax),%eax
f010c088:	85 c0                	test   %eax,%eax
f010c08a:	74 11                	je     f010c09d <program_segment_alloc_map_copy_workingset+0x1e7>
f010c08c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c08f:	8b 40 14             	mov    0x14(%eax),%eax
f010c092:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c095:	8b 52 10             	mov    0x10(%edx),%edx
f010c098:	89 50 10             	mov    %edx,0x10(%eax)
f010c09b:	eb 0f                	jmp    f010c0ac <program_segment_alloc_map_copy_workingset+0x1f6>
f010c09d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0a0:	8b 50 10             	mov    0x10(%eax),%edx
f010c0a3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0a6:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c0ac:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0af:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c0b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0b9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c0c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0c3:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c0c9:	8d 50 ff             	lea    -0x1(%eax),%edx
f010c0cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0cf:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010c0d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0d8:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010c0de:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0e1:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010c0e7:	48                   	dec    %eax
f010c0e8:	39 c2                	cmp    %eax,%edx
f010c0ea:	0f 83 80 00 00 00    	jae    f010c170 <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010c0f0:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c0f4:	75 17                	jne    f010c10d <program_segment_alloc_map_copy_workingset+0x257>
f010c0f6:	83 ec 04             	sub    $0x4,%esp
f010c0f9:	68 9c 61 12 f0       	push   $0xf012619c
f010c0fe:	68 fa 02 00 00       	push   $0x2fa
f010c103:	68 bf 61 12 f0       	push   $0xf01261bf
f010c108:	e8 2c 42 ff ff       	call   f0100339 <_panic>
f010c10d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c110:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010c116:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c119:	89 50 10             	mov    %edx,0x10(%eax)
f010c11c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c11f:	8b 40 10             	mov    0x10(%eax),%eax
f010c122:	85 c0                	test   %eax,%eax
f010c124:	74 11                	je     f010c137 <program_segment_alloc_map_copy_workingset+0x281>
f010c126:	8b 45 08             	mov    0x8(%ebp),%eax
f010c129:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010c12f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c132:	89 50 14             	mov    %edx,0x14(%eax)
f010c135:	eb 0c                	jmp    f010c143 <program_segment_alloc_map_copy_workingset+0x28d>
f010c137:	8b 45 08             	mov    0x8(%ebp),%eax
f010c13a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c13d:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010c143:	8b 45 08             	mov    0x8(%ebp),%eax
f010c146:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c149:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010c14f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c152:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c159:	8b 45 08             	mov    0x8(%ebp),%eax
f010c15c:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010c162:	8d 50 01             	lea    0x1(%eax),%edx
f010c165:	8b 45 08             	mov    0x8(%ebp),%eax
f010c168:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010c16e:	eb 7e                	jmp    f010c1ee <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010c170:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c174:	75 17                	jne    f010c18d <program_segment_alloc_map_copy_workingset+0x2d7>
f010c176:	83 ec 04             	sub    $0x4,%esp
f010c179:	68 9c 61 12 f0       	push   $0xf012619c
f010c17e:	68 ff 02 00 00       	push   $0x2ff
f010c183:	68 bf 61 12 f0       	push   $0xf01261bf
f010c188:	e8 ac 41 ff ff       	call   f0100339 <_panic>
f010c18d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c190:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010c196:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c199:	89 50 10             	mov    %edx,0x10(%eax)
f010c19c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c19f:	8b 40 10             	mov    0x10(%eax),%eax
f010c1a2:	85 c0                	test   %eax,%eax
f010c1a4:	74 11                	je     f010c1b7 <program_segment_alloc_map_copy_workingset+0x301>
f010c1a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1a9:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010c1af:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1b2:	89 50 14             	mov    %edx,0x14(%eax)
f010c1b5:	eb 0c                	jmp    f010c1c3 <program_segment_alloc_map_copy_workingset+0x30d>
f010c1b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1ba:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1bd:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010c1c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1c6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1c9:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010c1cf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1d2:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c1d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1dc:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010c1e2:	8d 50 01             	lea    0x1(%eax),%edx
f010c1e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1e8:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010c1ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1f1:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010c1f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1fa:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c200:	39 c2                	cmp    %eax,%edx
f010c202:	75 14                	jne    f010c218 <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010c204:	8b 45 08             	mov    0x8(%ebp),%eax
f010c207:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010c20d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c210:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010c216:	eb 0d                	jmp    f010c225 <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010c218:	8b 45 08             	mov    0x8(%ebp),%eax
f010c21b:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010c222:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010c225:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c228:	c1 e8 16             	shr    $0x16,%eax
f010c22b:	89 c2                	mov    %eax,%edx
f010c22d:	8b 45 18             	mov    0x18(%ebp),%eax
f010c230:	8b 00                	mov    (%eax),%eax
f010c232:	39 c2                	cmp    %eax,%edx
f010c234:	0f 84 d3 00 00 00    	je     f010c30d <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010c23a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c23d:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c243:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c246:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010c249:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c24c:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c251:	89 c1                	mov    %eax,%ecx
f010c253:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c256:	89 d0                	mov    %edx,%eax
f010c258:	01 c0                	add    %eax,%eax
f010c25a:	01 d0                	add    %edx,%eax
f010c25c:	c1 e0 03             	shl    $0x3,%eax
f010c25f:	01 d8                	add    %ebx,%eax
f010c261:	05 ac 00 00 00       	add    $0xac,%eax
f010c266:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010c268:	8b 45 08             	mov    0x8(%ebp),%eax
f010c26b:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c271:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c274:	89 d0                	mov    %edx,%eax
f010c276:	01 c0                	add    %eax,%eax
f010c278:	01 d0                	add    %edx,%eax
f010c27a:	c1 e0 03             	shl    $0x3,%eax
f010c27d:	01 c8                	add    %ecx,%eax
f010c27f:	05 b0 00 00 00       	add    $0xb0,%eax
f010c284:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010c287:	8b 45 08             	mov    0x8(%ebp),%eax
f010c28a:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c290:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c293:	89 d0                	mov    %edx,%eax
f010c295:	01 c0                	add    %eax,%eax
f010c297:	01 d0                	add    %edx,%eax
f010c299:	c1 e0 03             	shl    $0x3,%eax
f010c29c:	01 c8                	add    %ecx,%eax
f010c29e:	05 b4 00 00 00       	add    $0xb4,%eax
f010c2a3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010c2a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2ac:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c2b2:	8d 50 01             	lea    0x1(%eax),%edx
f010c2b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2b8:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010c2be:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2c1:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c2c7:	b9 32 00 00 00       	mov    $0x32,%ecx
f010c2cc:	ba 00 00 00 00       	mov    $0x0,%edx
f010c2d1:	f7 f1                	div    %ecx
f010c2d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2d6:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			if (e->table_last_WS_index == 0)
f010c2dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2df:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c2e5:	85 c0                	test   %eax,%eax
f010c2e7:	75 17                	jne    f010c300 <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010c2e9:	83 ec 04             	sub    $0x4,%esp
f010c2ec:	68 78 63 12 f0       	push   $0xf0126378
f010c2f1:	68 27 03 00 00       	push   $0x327
f010c2f6:	68 bf 61 12 f0       	push   $0xf01261bf
f010c2fb:	e8 39 40 ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010c300:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c303:	c1 e8 16             	shr    $0x16,%eax
f010c306:	89 c2                	mov    %eax,%edx
f010c308:	8b 45 18             	mov    0x18(%ebp),%eax
f010c30b:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010c30d:	8b 45 10             	mov    0x10(%ebp),%eax
f010c310:	8b 00                	mov    (%eax),%eax
f010c312:	8d 50 01             	lea    0x1(%eax),%edx
f010c315:	8b 45 10             	mov    0x10(%ebp),%eax
f010c318:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c31a:	ff 45 f0             	incl   -0x10(%ebp)
f010c31d:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c324:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c327:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010c32a:	73 0c                	jae    f010c338 <program_segment_alloc_map_copy_workingset+0x482>
f010c32c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c32f:	3b 45 14             	cmp    0x14(%ebp),%eax
f010c332:	0f 82 2b fc ff ff    	jb     f010bf63 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010c338:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c33b:	8b 00                	mov    (%eax),%eax
f010c33d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010c340:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c343:	8b 40 0c             	mov    0xc(%eax),%eax
f010c346:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c349:	eb 10                	jmp    f010c35b <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010c34b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c34e:	8a 10                	mov    (%eax),%dl
f010c350:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c353:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010c355:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010c358:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c35b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c35e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010c361:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c364:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c369:	89 c2                	mov    %eax,%edx
f010c36b:	8b 45 10             	mov    0x10(%ebp),%eax
f010c36e:	8b 00                	mov    (%eax),%eax
f010c370:	c1 e0 0c             	shl    $0xc,%eax
f010c373:	01 c2                	add    %eax,%edx
f010c375:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c378:	39 c2                	cmp    %eax,%edx
f010c37a:	76 1d                	jbe    f010c399 <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010c37c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c37f:	8b 50 04             	mov    0x4(%eax),%edx
f010c382:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c385:	01 c2                	add    %eax,%edx
f010c387:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c38a:	39 c2                	cmp    %eax,%edx
f010c38c:	77 bd                	ja     f010c34b <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c38e:	eb 09                	jmp    f010c399 <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010c390:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c393:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010c396:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c399:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c39c:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010c39f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010c3a2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c3a7:	89 c2                	mov    %eax,%edx
f010c3a9:	8b 45 10             	mov    0x10(%ebp),%eax
f010c3ac:	8b 00                	mov    (%eax),%eax
f010c3ae:	c1 e0 0c             	shl    $0xc,%eax
f010c3b1:	01 c2                	add    %eax,%edx
f010c3b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c3b6:	39 c2                	cmp    %eax,%edx
f010c3b8:	77 d6                	ja     f010c390 <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010c3ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c3bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c3c2:	c9                   	leave  
f010c3c3:	c3                   	ret    

f010c3c4 <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010c3c4:	55                   	push   %ebp
f010c3c5:	89 e5                	mov    %esp,%ebp
f010c3c7:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010c3ca:	83 ec 0c             	sub    $0xc,%esp
f010c3cd:	68 00 10 00 00       	push   $0x1000
f010c3d2:	e8 ba d0 ff ff       	call   f0109491 <kmalloc>
f010c3d7:	83 c4 10             	add    $0x10,%esp
f010c3da:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010c3dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c3e1:	75 17                	jne    f010c3fa <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010c3e3:	83 ec 04             	sub    $0x4,%esp
f010c3e6:	68 1b 64 12 f0       	push   $0xf012641b
f010c3eb:	68 57 03 00 00       	push   $0x357
f010c3f0:	68 bf 61 12 f0       	push   $0xf01261bf
f010c3f5:	e8 3f 3f ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010c3fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010c3fd:	c9                   	leave  
f010c3fe:	c3                   	ret    

f010c3ff <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010c3ff:	55                   	push   %ebp
f010c400:	89 e5                	mov    %esp,%ebp
f010c402:	83 ec 28             	sub    $0x28,%esp
//allocate space for the user kernel stack.
//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
f010c405:	83 ec 0c             	sub    $0xc,%esp
f010c408:	68 00 80 00 00       	push   $0x8000
f010c40d:	e8 7f d0 ff ff       	call   f0109491 <kmalloc>
f010c412:	83 c4 10             	add    $0x10,%esp
f010c415:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
f010c418:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f010c41f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c422:	05 ff 7f 00 00       	add    $0x7fff,%eax
f010c427:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010c42a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c42d:	ba 00 00 00 00       	mov    $0x0,%edx
f010c432:	f7 75 ec             	divl   -0x14(%ebp)
f010c435:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c438:	29 d0                	sub    %edx,%eax
f010c43a:	85 c0                	test   %eax,%eax
f010c43c:	79 05                	jns    f010c443 <create_user_kern_stack+0x44>
f010c43e:	05 ff 0f 00 00       	add    $0xfff,%eax
f010c443:	c1 f8 0c             	sar    $0xc,%eax
f010c446:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i=1; i<num_pages; i++)
f010c449:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f010c450:	eb 72                	jmp    f010c4c4 <create_user_kern_stack+0xc5>
	{
		uint32* ptr_page_table = NULL;
f010c452:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		struct FrameInfo * ptr_FrameInfo = get_frame_info(ptr_page_directory, (uint32)va + i*PAGE_SIZE, &ptr_page_table);
f010c459:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c45c:	c1 e0 0c             	shl    $0xc,%eax
f010c45f:	89 c2                	mov    %eax,%edx
f010c461:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c464:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010c467:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f010c46c:	83 ec 04             	sub    $0x4,%esp
f010c46f:	8d 55 dc             	lea    -0x24(%ebp),%edx
f010c472:	52                   	push   %edx
f010c473:	51                   	push   %ecx
f010c474:	50                   	push   %eax
f010c475:	e8 ef c2 ff ff       	call   f0108769 <get_frame_info>
f010c47a:	83 c4 10             	add    $0x10,%esp
f010c47d:	89 45 e0             	mov    %eax,-0x20(%ebp)
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
f010c480:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c483:	c1 e0 0c             	shl    $0xc,%eax
f010c486:	89 c2                	mov    %eax,%edx
f010c488:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c48b:	01 d0                	add    %edx,%eax
f010c48d:	6a 01                	push   $0x1
f010c48f:	50                   	push   %eax
f010c490:	ff 75 e0             	pushl  -0x20(%ebp)
f010c493:	ff 75 08             	pushl  0x8(%ebp)
f010c496:	e8 e4 c1 ff ff       	call   f010867f <map_frame>
f010c49b:	83 c4 10             	add    $0x10,%esp
		if(i == 0){
f010c49e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c4a2:	75 1d                	jne    f010c4c1 <create_user_kern_stack+0xc2>
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
f010c4a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4a7:	c1 e0 0c             	shl    $0xc,%eax
f010c4aa:	89 c2                	mov    %eax,%edx
f010c4ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c4af:	01 d0                	add    %edx,%eax
f010c4b1:	6a 01                	push   $0x1
f010c4b3:	6a 00                	push   $0x0
f010c4b5:	50                   	push   %eax
f010c4b6:	ff 75 08             	pushl  0x8(%ebp)
f010c4b9:	e8 0d d7 ff ff       	call   f0109bcb <pt_set_page_permissions>
f010c4be:	83 c4 10             	add    $0x10,%esp
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
	for (int i=1; i<num_pages; i++)
f010c4c1:	ff 45 f4             	incl   -0xc(%ebp)
f010c4c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4c7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010c4ca:	72 86                	jb     f010c452 <create_user_kern_stack+0x53>
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
		if(i == 0){
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
		}
	}
	    return va;
f010c4cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
void* kstack = (void*) __cur_k_stk;
__cur_k_stk += KERNEL_STACK_SIZE;
return kstack ;
//panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010c4cf:	c9                   	leave  
f010c4d0:	c3                   	ret    

f010c4d1 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010c4d1:	55                   	push   %ebp
f010c4d2:	89 e5                	mov    %esp,%ebp
f010c4d4:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010c4d7:	83 ec 04             	sub    $0x4,%esp
f010c4da:	68 38 64 12 f0       	push   $0xf0126438
f010c4df:	68 8e 03 00 00       	push   $0x38e
f010c4e4:	68 bf 61 12 f0       	push   $0xf01261bf
f010c4e9:	e8 4b 3e ff ff       	call   f0100339 <_panic>

f010c4ee <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010c4ee:	55                   	push   %ebp
f010c4ef:	89 e5                	mov    %esp,%ebp
f010c4f1:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
	e->heap_start = daStart;
f010c4f4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4f7:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c4fa:	89 50 74             	mov    %edx,0x74(%eax)
	e->heap_hard_limit = daLimit;
f010c4fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c500:	8b 55 10             	mov    0x10(%ebp),%edx
f010c503:	89 50 78             	mov    %edx,0x78(%eax)
	e->heap_brk = daStart;
f010c506:	8b 45 08             	mov    0x8(%ebp),%eax
f010c509:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c50c:	89 50 7c             	mov    %edx,0x7c(%eax)

	initialize_dynamic_allocator(daStart,0);
f010c50f:	83 ec 08             	sub    $0x8,%esp
f010c512:	6a 00                	push   $0x0
f010c514:	ff 75 0c             	pushl  0xc(%ebp)
f010c517:	e8 7b 42 01 00       	call   f0120797 <initialize_dynamic_allocator>
f010c51c:	83 c4 10             	add    $0x10,%esp
}
f010c51f:	90                   	nop
f010c520:	c9                   	leave  
f010c521:	c3                   	ret    

f010c522 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010c522:	55                   	push   %ebp
f010c523:	89 e5                	mov    %esp,%ebp
f010c525:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010c528:	8b 45 08             	mov    0x8(%ebp),%eax
f010c52b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c52e:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010c531:	8b 45 08             	mov    0x8(%ebp),%eax
f010c534:	8b 55 10             	mov    0x10(%ebp),%edx
f010c537:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c53a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c541:	eb 17                	jmp    f010c55a <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010c543:	8b 45 08             	mov    0x8(%ebp),%eax
f010c546:	8b 40 64             	mov    0x64(%eax),%eax
f010c549:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c54c:	c1 e2 02             	shl    $0x2,%edx
f010c54f:	01 d0                	add    %edx,%eax
f010c551:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c557:	ff 45 f4             	incl   -0xc(%ebp)
f010c55a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c55d:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010c562:	76 df                	jbe    f010c543 <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c564:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010c56b:	eb 22                	jmp    f010c58f <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010c56d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c570:	8b 40 64             	mov    0x64(%eax),%eax
f010c573:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c576:	c1 e2 02             	shl    $0x2,%edx
f010c579:	01 c2                	add    %eax,%edx
f010c57b:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f010c580:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c583:	c1 e1 02             	shl    $0x2,%ecx
f010c586:	01 c8                	add    %ecx,%eax
f010c588:	8b 00                	mov    (%eax),%eax
f010c58a:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c58c:	ff 45 f4             	incl   -0xc(%ebp)
f010c58f:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010c596:	7e d5                	jle    f010c56d <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010c598:	8b 45 08             	mov    0x8(%ebp),%eax
f010c59b:	8b 40 64             	mov    0x64(%eax),%eax
f010c59e:	83 ec 0c             	sub    $0xc,%esp
f010c5a1:	50                   	push   %eax
f010c5a2:	e8 58 fe ff ff       	call   f010c3ff <create_user_kern_stack>
f010c5a7:	83 c4 10             	add    $0x10,%esp
f010c5aa:	89 c2                	mov    %eax,%edx
f010c5ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5af:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010c5b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5b5:	8b 40 70             	mov    0x70(%eax),%eax
f010c5b8:	05 00 80 00 00       	add    $0x8000,%eax
f010c5bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010c5c0:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010c5c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c5ca:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010c5cc:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010c5d0:	ba 10 e6 10 f0       	mov    $0xf010e610,%edx
f010c5d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c5d8:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010c5da:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010c5de:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5e1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c5e4:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010c5e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5ea:	8b 40 04             	mov    0x4(%eax),%eax
f010c5ed:	83 ec 04             	sub    $0x4,%esp
f010c5f0:	6a 20                	push   $0x20
f010c5f2:	6a 00                	push   $0x0
f010c5f4:	50                   	push   %eax
f010c5f5:	e8 bc 37 01 00       	call   f011fdb6 <memset>
f010c5fa:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010c5fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c600:	8b 40 04             	mov    0x4(%eax),%eax
f010c603:	ba f1 b8 10 f0       	mov    $0xf010b8f1,%edx
f010c608:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c60b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c60e:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c615:	00 00 00 
f010c618:	8b 45 08             	mov    0x8(%ebp),%eax
f010c61b:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c622:	00 00 00 
f010c625:	8b 45 08             	mov    0x8(%ebp),%eax
f010c628:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c62f:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c632:	83 ec 0c             	sub    $0xc,%esp
f010c635:	6a 02                	push   $0x2
f010c637:	e8 8b 2f 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f010c63c:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c63f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c646:	eb 54                	jmp    f010c69c <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c648:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c64b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c64e:	89 d0                	mov    %edx,%eax
f010c650:	01 c0                	add    %eax,%eax
f010c652:	01 d0                	add    %edx,%eax
f010c654:	c1 e0 03             	shl    $0x3,%eax
f010c657:	01 c8                	add    %ecx,%eax
f010c659:	05 ac 00 00 00       	add    $0xac,%eax
f010c65e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c664:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c667:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c66a:	89 d0                	mov    %edx,%eax
f010c66c:	01 c0                	add    %eax,%eax
f010c66e:	01 d0                	add    %edx,%eax
f010c670:	c1 e0 03             	shl    $0x3,%eax
f010c673:	01 c8                	add    %ecx,%eax
f010c675:	05 b0 00 00 00       	add    $0xb0,%eax
f010c67a:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010c67d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c680:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c683:	89 d0                	mov    %edx,%eax
f010c685:	01 c0                	add    %eax,%eax
f010c687:	01 d0                	add    %edx,%eax
f010c689:	c1 e0 03             	shl    $0x3,%eax
f010c68c:	01 c8                	add    %ecx,%eax
f010c68e:	05 b4 00 00 00       	add    $0xb4,%eax
f010c693:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c699:	ff 45 f4             	incl   -0xc(%ebp)
f010c69c:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c6a0:	7e a6                	jle    f010c648 <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010c6a2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6a5:	c7 80 5c 05 00 00 00 	movl   $0x0,0x55c(%eax)
f010c6ac:	00 00 00 

	e->pageFaultsCounter=0;
f010c6af:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6b2:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010c6b9:	00 00 00 
	e->tableFaultsCounter=0;
f010c6bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6bf:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010c6c6:	00 00 00 

	e->freeingFullWSCounter = 0;
f010c6c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6cc:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010c6d3:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010c6d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6d9:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010c6e0:	00 00 00 

	e->nModifiedPages=0;
f010c6e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6e6:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010c6ed:	00 00 00 
	e->nNotModifiedPages=0;
f010c6f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6f3:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010c6fa:	00 00 00 
	e->nClocks = 0;
f010c6fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c700:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010c707:	00 00 00 

	//2020
	e->nPageIn = 0;
f010c70a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c70d:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010c714:	00 00 00 
	e->nPageOut = 0;
f010c717:	8b 45 08             	mov    0x8(%ebp),%eax
f010c71a:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010c721:	00 00 00 
	e->nNewPageAdded = 0;
f010c724:	8b 45 08             	mov    0x8(%ebp),%eax
f010c727:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010c72e:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010c731:	83 ec 04             	sub    $0x4,%esp
f010c734:	68 00 00 00 82       	push   $0x82000000
f010c739:	68 00 00 00 80       	push   $0x80000000
f010c73e:	ff 75 08             	pushl  0x8(%ebp)
f010c741:	e8 a8 fd ff ff       	call   f010c4ee <initialize_uheap_dynamic_allocator>
f010c746:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010c749:	83 ec 0c             	sub    $0xc,%esp
f010c74c:	ff 75 08             	pushl  0x8(%ebp)
f010c74f:	e8 06 00 00 00       	call   f010c75a <complete_environment_initialization>
f010c754:	83 c4 10             	add    $0x10,%esp
}
f010c757:	90                   	nop
f010c758:	c9                   	leave  
f010c759:	c3                   	ret    

f010c75a <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010c75a:	55                   	push   %ebp
f010c75b:	89 e5                	mov    %esp,%ebp
f010c75d:	53                   	push   %ebx
f010c75e:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010c761:	8b 45 08             	mov    0x8(%ebp),%eax
f010c764:	8b 40 64             	mov    0x64(%eax),%eax
f010c767:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010c76d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c770:	8b 40 68             	mov    0x68(%eax),%eax
f010c773:	83 c8 03             	or     $0x3,%eax
f010c776:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010c778:	8b 45 08             	mov    0x8(%ebp),%eax
f010c77b:	8b 40 64             	mov    0x64(%eax),%eax
f010c77e:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010c784:	8b 45 08             	mov    0x8(%ebp),%eax
f010c787:	8b 40 68             	mov    0x68(%eax),%eax
f010c78a:	83 c8 05             	or     $0x5,%eax
f010c78d:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010c78f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c792:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010c799:	00 00 00 
	e->disk_env_pgdir_PA= 0;
f010c79c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c79f:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010c7a6:	00 00 00 
	e->disk_env_tabledir = 0;
f010c7a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7ac:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010c7b3:	00 00 00 
	e->disk_env_tabledir_PA = 0;
f010c7b6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7b9:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010c7c0:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010c7c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7c6:	8b 58 10             	mov    0x10(%eax),%ebx
f010c7c9:	83 ec 0c             	sub    $0xc,%esp
f010c7cc:	68 ca 02 00 00       	push   $0x2ca
f010c7d1:	e8 85 19 01 00       	call   f011e15b <log2_ceil>
f010c7d6:	83 c4 10             	add    $0x10,%esp
f010c7d9:	ba 01 00 00 00       	mov    $0x1,%edx
f010c7de:	88 c1                	mov    %al,%cl
f010c7e0:	d3 e2                	shl    %cl,%edx
f010c7e2:	89 d0                	mov    %edx,%eax
f010c7e4:	01 d8                	add    %ebx,%eax
f010c7e6:	89 c3                	mov    %eax,%ebx
f010c7e8:	83 ec 0c             	sub    $0xc,%esp
f010c7eb:	68 ca 02 00 00       	push   $0x2ca
f010c7f0:	e8 31 19 01 00       	call   f011e126 <nearest_pow2_ceil>
f010c7f5:	83 c4 10             	add    $0x10,%esp
f010c7f8:	f7 d8                	neg    %eax
f010c7fa:	21 d8                	and    %ebx,%eax
f010c7fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010c7ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c803:	7f 1e                	jg     f010c823 <complete_environment_initialization+0xc9>
		generation = 1 << ENVGENSHIFT;
f010c805:	83 ec 0c             	sub    $0xc,%esp
f010c808:	68 ca 02 00 00       	push   $0x2ca
f010c80d:	e8 49 19 01 00       	call   f011e15b <log2_ceil>
f010c812:	83 c4 10             	add    $0x10,%esp
f010c815:	ba 01 00 00 00       	mov    $0x1,%edx
f010c81a:	88 c1                	mov    %al,%cl
f010c81c:	d3 e2                	shl    %cl,%edx
f010c81e:	89 d0                	mov    %edx,%eax
f010c820:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010c823:	8b 45 08             	mov    0x8(%ebp),%eax
f010c826:	8b 15 f0 7a 69 f0    	mov    0xf0697af0,%edx
f010c82c:	29 d0                	sub    %edx,%eax
f010c82e:	c1 f8 02             	sar    $0x2,%eax
f010c831:	89 c2                	mov    %eax,%edx
f010c833:	89 d0                	mov    %edx,%eax
f010c835:	c1 e0 03             	shl    $0x3,%eax
f010c838:	01 d0                	add    %edx,%eax
f010c83a:	c1 e0 03             	shl    $0x3,%eax
f010c83d:	01 d0                	add    %edx,%eax
f010c83f:	c1 e0 02             	shl    $0x2,%eax
f010c842:	01 d0                	add    %edx,%eax
f010c844:	01 c0                	add    %eax,%eax
f010c846:	01 d0                	add    %edx,%eax
f010c848:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010c84f:	01 c8                	add    %ecx,%eax
f010c851:	c1 e0 02             	shl    $0x2,%eax
f010c854:	01 d0                	add    %edx,%eax
f010c856:	c1 e0 03             	shl    $0x3,%eax
f010c859:	01 d0                	add    %edx,%eax
f010c85b:	c1 e0 05             	shl    $0x5,%eax
f010c85e:	29 d0                	sub    %edx,%eax
f010c860:	c1 e0 02             	shl    $0x2,%eax
f010c863:	01 d0                	add    %edx,%eax
f010c865:	01 c0                	add    %eax,%eax
f010c867:	01 d0                	add    %edx,%eax
f010c869:	c1 e0 03             	shl    $0x3,%eax
f010c86c:	01 d0                	add    %edx,%eax
f010c86e:	c1 e0 04             	shl    $0x4,%eax
f010c871:	29 d0                	sub    %edx,%eax
f010c873:	0b 45 f4             	or     -0xc(%ebp),%eax
f010c876:	89 c2                	mov    %eax,%edx
f010c878:	8b 45 08             	mov    0x8(%ebp),%eax
f010c87b:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010c87e:	e8 08 f1 ff ff       	call   f010b98b <get_cpu_proc>
f010c883:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010c886:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010c88a:	75 0c                	jne    f010c898 <complete_environment_initialization+0x13e>
		e->env_parent_id = 0;//no parent;
f010c88c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c88f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c896:	eb 0c                	jmp    f010c8a4 <complete_environment_initialization+0x14a>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010c898:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c89b:	8b 50 10             	mov    0x10(%eax),%edx
f010c89e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8a1:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010c8a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8a7:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010c8ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8b1:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010c8b8:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010c8bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8be:	8b 00                	mov    (%eax),%eax
f010c8c0:	83 ec 04             	sub    $0x4,%esp
f010c8c3:	6a 44                	push   $0x44
f010c8c5:	6a 00                	push   $0x0
f010c8c7:	50                   	push   %eax
f010c8c8:	e8 e9 34 01 00       	call   f011fdb6 <memset>
f010c8cd:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010c8d0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8d3:	8b 00                	mov    (%eax),%eax
f010c8d5:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010c8db:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8de:	8b 00                	mov    (%eax),%eax
f010c8e0:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010c8e6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8e9:	8b 00                	mov    (%eax),%eax
f010c8eb:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010c8f1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8f4:	8b 00                	mov    (%eax),%eax
f010c8f6:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010c8fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c900:	8b 00                	mov    (%eax),%eax
f010c902:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010c908:	8b 45 08             	mov    0x8(%ebp),%eax
f010c90b:	8b 00                	mov    (%eax),%eax
f010c90d:	8b 55 08             	mov    0x8(%ebp),%edx
f010c910:	8b 12                	mov    (%edx),%edx
f010c912:	8b 52 38             	mov    0x38(%edx),%edx
f010c915:	80 ce 02             	or     $0x2,%dh
f010c918:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010c91b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c91f:	75 17                	jne    f010c938 <complete_environment_initialization+0x1de>
f010c921:	83 ec 04             	sub    $0x4,%esp
f010c924:	68 47 62 12 f0       	push   $0xf0126247
f010c929:	68 67 04 00 00       	push   $0x467
f010c92e:	68 bf 61 12 f0       	push   $0xf01261bf
f010c933:	e8 01 3a ff ff       	call   f0100339 <_panic>
f010c938:	8b 45 08             	mov    0x8(%ebp),%eax
f010c93b:	8b 40 08             	mov    0x8(%eax),%eax
f010c93e:	85 c0                	test   %eax,%eax
f010c940:	74 11                	je     f010c953 <complete_environment_initialization+0x1f9>
f010c942:	8b 45 08             	mov    0x8(%ebp),%eax
f010c945:	8b 40 08             	mov    0x8(%eax),%eax
f010c948:	8b 55 08             	mov    0x8(%ebp),%edx
f010c94b:	8b 52 0c             	mov    0xc(%edx),%edx
f010c94e:	89 50 0c             	mov    %edx,0xc(%eax)
f010c951:	eb 0b                	jmp    f010c95e <complete_environment_initialization+0x204>
f010c953:	8b 45 08             	mov    0x8(%ebp),%eax
f010c956:	8b 40 0c             	mov    0xc(%eax),%eax
f010c959:	a3 f8 7a 69 f0       	mov    %eax,0xf0697af8
f010c95e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c961:	8b 40 0c             	mov    0xc(%eax),%eax
f010c964:	85 c0                	test   %eax,%eax
f010c966:	74 11                	je     f010c979 <complete_environment_initialization+0x21f>
f010c968:	8b 45 08             	mov    0x8(%ebp),%eax
f010c96b:	8b 40 0c             	mov    0xc(%eax),%eax
f010c96e:	8b 55 08             	mov    0x8(%ebp),%edx
f010c971:	8b 52 08             	mov    0x8(%edx),%edx
f010c974:	89 50 08             	mov    %edx,0x8(%eax)
f010c977:	eb 0b                	jmp    f010c984 <complete_environment_initialization+0x22a>
f010c979:	8b 45 08             	mov    0x8(%ebp),%eax
f010c97c:	8b 40 08             	mov    0x8(%eax),%eax
f010c97f:	a3 f4 7a 69 f0       	mov    %eax,0xf0697af4
f010c984:	8b 45 08             	mov    0x8(%ebp),%eax
f010c987:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010c98e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c991:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c998:	a1 00 7b 69 f0       	mov    0xf0697b00,%eax
f010c99d:	48                   	dec    %eax
f010c99e:	a3 00 7b 69 f0       	mov    %eax,0xf0697b00
	return ;
f010c9a3:	90                   	nop
}
f010c9a4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c9a7:	c9                   	leave  
f010c9a8:	c3                   	ret    

f010c9a9 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010c9a9:	55                   	push   %ebp
f010c9aa:	89 e5                	mov    %esp,%ebp
f010c9ac:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c9af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c9b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c9b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9b8:	8b 00                	mov    (%eax),%eax
f010c9ba:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c9bf:	74 17                	je     f010c9d8 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010c9c1:	83 ec 04             	sub    $0x4,%esp
f010c9c4:	68 6d 64 12 f0       	push   $0xf012646d
f010c9c9:	68 73 04 00 00       	push   $0x473
f010c9ce:	68 bf 61 12 f0       	push   $0xf01261bf
f010c9d3:	e8 61 39 ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010c9d8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9db:	8b 00                	mov    (%eax),%eax
f010c9dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c9e0:	8b 52 18             	mov    0x18(%edx),%edx
f010c9e3:	89 50 30             	mov    %edx,0x30(%eax)
}
f010c9e6:	90                   	nop
f010c9e7:	c9                   	leave  
f010c9e8:	c3                   	ret    

f010c9e9 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010c9e9:	55                   	push   %ebp
f010c9ea:	89 e5                	mov    %esp,%ebp
f010c9ec:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010c9ef:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9f2:	8b 40 10             	mov    0x10(%eax),%eax
f010c9f5:	8d 48 01             	lea    0x1(%eax),%ecx
f010c9f8:	8b 55 08             	mov    0x8(%ebp),%edx
f010c9fb:	89 4a 10             	mov    %ecx,0x10(%edx)
f010c9fe:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010ca01:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ca04:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010ca07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ca0a:	8b 00                	mov    (%eax),%eax
f010ca0c:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010ca11:	74 17                	je     f010ca2a <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010ca13:	83 ec 04             	sub    $0x4,%esp
f010ca16:	68 6d 64 12 f0       	push   $0xf012646d
f010ca1b:	68 81 04 00 00       	push   $0x481
f010ca20:	68 bf 61 12 f0       	push   $0xf01261bf
f010ca25:	e8 0f 39 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010ca2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ca2d:	8b 50 1c             	mov    0x1c(%eax),%edx
f010ca30:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ca33:	01 d0                	add    %edx,%eax
f010ca35:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010ca38:	eb 0f                	jmp    f010ca49 <PROGRAM_SEGMENT_NEXT+0x60>
f010ca3a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca3d:	8b 40 10             	mov    0x10(%eax),%eax
f010ca40:	8d 50 01             	lea    0x1(%eax),%edx
f010ca43:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca46:	89 50 10             	mov    %edx,0x10(%eax)
f010ca49:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca4c:	8b 40 10             	mov    0x10(%eax),%eax
f010ca4f:	c1 e0 05             	shl    $0x5,%eax
f010ca52:	89 c2                	mov    %eax,%edx
f010ca54:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ca57:	01 d0                	add    %edx,%eax
f010ca59:	8b 00                	mov    (%eax),%eax
f010ca5b:	83 f8 01             	cmp    $0x1,%eax
f010ca5e:	74 13                	je     f010ca73 <PROGRAM_SEGMENT_NEXT+0x8a>
f010ca60:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca63:	8b 50 10             	mov    0x10(%eax),%edx
f010ca66:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ca69:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ca6c:	0f b7 c0             	movzwl %ax,%eax
f010ca6f:	39 c2                	cmp    %eax,%edx
f010ca71:	72 c7                	jb     f010ca3a <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010ca73:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca76:	8b 40 10             	mov    0x10(%eax),%eax
f010ca79:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010ca7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ca7f:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ca82:	0f b7 c0             	movzwl %ax,%eax
f010ca85:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ca88:	7e 63                	jle    f010caed <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010ca8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca8d:	c1 e0 05             	shl    $0x5,%eax
f010ca90:	89 c2                	mov    %eax,%edx
f010ca92:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ca95:	01 d0                	add    %edx,%eax
f010ca97:	8b 50 04             	mov    0x4(%eax),%edx
f010ca9a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ca9d:	01 c2                	add    %eax,%edx
f010ca9f:	8b 45 08             	mov    0x8(%ebp),%eax
f010caa2:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010caa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010caa7:	c1 e0 05             	shl    $0x5,%eax
f010caaa:	89 c2                	mov    %eax,%edx
f010caac:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010caaf:	01 d0                	add    %edx,%eax
f010cab1:	8b 50 14             	mov    0x14(%eax),%edx
f010cab4:	8b 45 08             	mov    0x8(%ebp),%eax
f010cab7:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010caba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cabd:	c1 e0 05             	shl    $0x5,%eax
f010cac0:	89 c2                	mov    %eax,%edx
f010cac2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cac5:	01 d0                	add    %edx,%eax
f010cac7:	8b 50 10             	mov    0x10(%eax),%edx
f010caca:	8b 45 08             	mov    0x8(%ebp),%eax
f010cacd:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010cad0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cad3:	c1 e0 05             	shl    $0x5,%eax
f010cad6:	89 c2                	mov    %eax,%edx
f010cad8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cadb:	01 d0                	add    %edx,%eax
f010cadd:	8b 40 08             	mov    0x8(%eax),%eax
f010cae0:	89 c2                	mov    %eax,%edx
f010cae2:	8b 45 08             	mov    0x8(%ebp),%eax
f010cae5:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010cae8:	8b 45 08             	mov    0x8(%ebp),%eax
f010caeb:	eb 05                	jmp    f010caf2 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010caed:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010caf2:	c9                   	leave  
f010caf3:	c3                   	ret    

f010caf4 <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010caf4:	55                   	push   %ebp
f010caf5:	89 e5                	mov    %esp,%ebp
f010caf7:	57                   	push   %edi
f010caf8:	56                   	push   %esi
f010caf9:	53                   	push   %ebx
f010cafa:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010cafd:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cb04:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cb07:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cb0a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cb0d:	8b 00                	mov    (%eax),%eax
f010cb0f:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cb14:	74 17                	je     f010cb2d <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010cb16:	83 ec 04             	sub    $0x4,%esp
f010cb19:	68 6d 64 12 f0       	push   $0xf012646d
f010cb1e:	68 9d 04 00 00       	push   $0x49d
f010cb23:	68 bf 61 12 f0       	push   $0xf01261bf
f010cb28:	e8 0c 38 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cb2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cb30:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cb33:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cb36:	01 d0                	add    %edx,%eax
f010cb38:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010cb3b:	eb 07                	jmp    f010cb44 <PROGRAM_SEGMENT_FIRST+0x50>
f010cb3d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cb40:	40                   	inc    %eax
f010cb41:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010cb44:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cb47:	c1 e0 05             	shl    $0x5,%eax
f010cb4a:	89 c2                	mov    %eax,%edx
f010cb4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cb4f:	01 d0                	add    %edx,%eax
f010cb51:	8b 00                	mov    (%eax),%eax
f010cb53:	83 f8 01             	cmp    $0x1,%eax
f010cb56:	74 10                	je     f010cb68 <PROGRAM_SEGMENT_FIRST+0x74>
f010cb58:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010cb5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cb5e:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cb61:	0f b7 c0             	movzwl %ax,%eax
f010cb64:	39 c2                	cmp    %eax,%edx
f010cb66:	72 d5                	jb     f010cb3d <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010cb68:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cb6b:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010cb6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cb71:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cb74:	0f b7 c0             	movzwl %ax,%eax
f010cb77:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010cb7a:	7e 68                	jle    f010cbe4 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cb7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cb7f:	c1 e0 05             	shl    $0x5,%eax
f010cb82:	89 c2                	mov    %eax,%edx
f010cb84:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cb87:	01 d0                	add    %edx,%eax
f010cb89:	8b 50 04             	mov    0x4(%eax),%edx
f010cb8c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cb8f:	01 d0                	add    %edx,%eax
f010cb91:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010cb94:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cb97:	c1 e0 05             	shl    $0x5,%eax
f010cb9a:	89 c2                	mov    %eax,%edx
f010cb9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cb9f:	01 d0                	add    %edx,%eax
f010cba1:	8b 40 14             	mov    0x14(%eax),%eax
f010cba4:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010cba7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cbaa:	c1 e0 05             	shl    $0x5,%eax
f010cbad:	89 c2                	mov    %eax,%edx
f010cbaf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cbb2:	01 d0                	add    %edx,%eax
f010cbb4:	8b 40 10             	mov    0x10(%eax),%eax
f010cbb7:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010cbba:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cbbd:	c1 e0 05             	shl    $0x5,%eax
f010cbc0:	89 c2                	mov    %eax,%edx
f010cbc2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cbc5:	01 d0                	add    %edx,%eax
f010cbc7:	8b 40 08             	mov    0x8(%eax),%eax
f010cbca:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010cbcd:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbd0:	89 c3                	mov    %eax,%ebx
f010cbd2:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cbd5:	ba 05 00 00 00       	mov    $0x5,%edx
f010cbda:	89 df                	mov    %ebx,%edi
f010cbdc:	89 c6                	mov    %eax,%esi
f010cbde:	89 d1                	mov    %edx,%ecx
f010cbe0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010cbe2:	eb 1c                	jmp    f010cc00 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010cbe4:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010cbeb:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbee:	89 c3                	mov    %eax,%ebx
f010cbf0:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cbf3:	ba 05 00 00 00       	mov    $0x5,%edx
f010cbf8:	89 df                	mov    %ebx,%edi
f010cbfa:	89 c6                	mov    %eax,%esi
f010cbfc:	89 d1                	mov    %edx,%ecx
f010cbfe:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010cc00:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc03:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010cc06:	5b                   	pop    %ebx
f010cc07:	5e                   	pop    %esi
f010cc08:	5f                   	pop    %edi
f010cc09:	5d                   	pop    %ebp
f010cc0a:	c2 04 00             	ret    $0x4

f010cc0d <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010cc0d:	55                   	push   %ebp
f010cc0e:	89 e5                	mov    %esp,%ebp
f010cc10:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010cc13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010cc1a:	83 ec 0c             	sub    $0xc,%esp
f010cc1d:	68 a0 06 6c f0       	push   $0xf06c06a0
f010cc22:	e8 f3 2f 00 00       	call   f010fc1a <acquire_spinlock>
f010cc27:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cc2a:	a1 90 06 6c f0       	mov    0xf06c0690,%eax
f010cc2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cc32:	e9 c3 00 00 00       	jmp    f010ccfa <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010cc37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc3a:	8b 40 0c             	mov    0xc(%eax),%eax
f010cc3d:	3b 45 08             	cmp    0x8(%ebp),%eax
f010cc40:	0f 85 ac 00 00 00    	jne    f010ccf2 <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010cc46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc49:	8b 50 10             	mov    0x10(%eax),%edx
f010cc4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc4f:	8b 40 0c             	mov    0xc(%eax),%eax
f010cc52:	8b 40 64             	mov    0x64(%eax),%eax
f010cc55:	83 ec 08             	sub    $0x8,%esp
f010cc58:	52                   	push   %edx
f010cc59:	50                   	push   %eax
f010cc5a:	e8 79 d0 ff ff       	call   f0109cd8 <pt_clear_page_table_entry>
f010cc5f:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010cc62:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cc66:	75 17                	jne    f010cc7f <cleanup_buffers+0x72>
f010cc68:	83 ec 04             	sub    $0x4,%esp
f010cc6b:	68 47 62 12 f0       	push   $0xf0126247
f010cc70:	68 c6 04 00 00       	push   $0x4c6
f010cc75:	68 bf 61 12 f0       	push   $0xf01261bf
f010cc7a:	e8 ba 36 ff ff       	call   f0100339 <_panic>
f010cc7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc82:	8b 00                	mov    (%eax),%eax
f010cc84:	85 c0                	test   %eax,%eax
f010cc86:	74 10                	je     f010cc98 <cleanup_buffers+0x8b>
f010cc88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc8b:	8b 00                	mov    (%eax),%eax
f010cc8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cc90:	8b 52 04             	mov    0x4(%edx),%edx
f010cc93:	89 50 04             	mov    %edx,0x4(%eax)
f010cc96:	eb 0b                	jmp    f010cca3 <cleanup_buffers+0x96>
f010cc98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc9b:	8b 40 04             	mov    0x4(%eax),%eax
f010cc9e:	a3 94 06 6c f0       	mov    %eax,0xf06c0694
f010cca3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cca6:	8b 40 04             	mov    0x4(%eax),%eax
f010cca9:	85 c0                	test   %eax,%eax
f010ccab:	74 0f                	je     f010ccbc <cleanup_buffers+0xaf>
f010ccad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ccb0:	8b 40 04             	mov    0x4(%eax),%eax
f010ccb3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ccb6:	8b 12                	mov    (%edx),%edx
f010ccb8:	89 10                	mov    %edx,(%eax)
f010ccba:	eb 0a                	jmp    f010ccc6 <cleanup_buffers+0xb9>
f010ccbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ccbf:	8b 00                	mov    (%eax),%eax
f010ccc1:	a3 90 06 6c f0       	mov    %eax,0xf06c0690
f010ccc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ccc9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010cccf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ccd2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010ccd9:	a1 9c 06 6c f0       	mov    0xf06c069c,%eax
f010ccde:	48                   	dec    %eax
f010ccdf:	a3 9c 06 6c f0       	mov    %eax,0xf06c069c

				free_frame(ptr_fi);
f010cce4:	83 ec 0c             	sub    $0xc,%esp
f010cce7:	ff 75 f4             	pushl  -0xc(%ebp)
f010ccea:	e8 17 b6 ff ff       	call   f0108306 <free_frame>
f010ccef:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010ccf2:	a1 98 06 6c f0       	mov    0xf06c0698,%eax
f010ccf7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ccfa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ccfe:	74 07                	je     f010cd07 <cleanup_buffers+0xfa>
f010cd00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd03:	8b 00                	mov    (%eax),%eax
f010cd05:	eb 05                	jmp    f010cd0c <cleanup_buffers+0xff>
f010cd07:	b8 00 00 00 00       	mov    $0x0,%eax
f010cd0c:	a3 98 06 6c f0       	mov    %eax,0xf06c0698
f010cd11:	a1 98 06 6c f0       	mov    0xf06c0698,%eax
f010cd16:	85 c0                	test   %eax,%eax
f010cd18:	0f 85 19 ff ff ff    	jne    f010cc37 <cleanup_buffers+0x2a>
f010cd1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cd22:	0f 85 0f ff ff ff    	jne    f010cc37 <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010cd28:	83 ec 0c             	sub    $0xc,%esp
f010cd2b:	68 a0 06 6c f0       	push   $0xf06c06a0
f010cd30:	e8 6c 2f 00 00       	call   f010fca1 <release_spinlock>
f010cd35:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010cd38:	90                   	nop
f010cd39:	c9                   	leave  
f010cd3a:	c3                   	ret    

f010cd3b <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010cd3b:	55                   	push   %ebp
f010cd3c:	89 e5                	mov    %esp,%ebp
f010cd3e:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010cd41:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010cd45:	7e 06                	jle    f010cd4d <set_program_priority+0x12>
f010cd47:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010cd4b:	7e 14                	jle    f010cd61 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010cd4d:	83 ec 04             	sub    $0x4,%esp
f010cd50:	68 84 64 12 f0       	push   $0xf0126484
f010cd55:	6a 10                	push   $0x10
f010cd57:	68 a8 64 12 f0       	push   $0xf01264a8
f010cd5c:	e8 d8 35 ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010cd61:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010cd65:	74 78                	je     f010cddf <set_program_priority+0xa4>
		return;
	switch(priority)
f010cd67:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010cd6b:	77 56                	ja     f010cdc3 <set_program_priority+0x88>
f010cd6d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cd70:	c1 e0 02             	shl    $0x2,%eax
f010cd73:	05 e4 64 12 f0       	add    $0xf01264e4,%eax
f010cd78:	8b 00                	mov    (%eax),%eax
f010cd7a:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010cd7c:	83 ec 08             	sub    $0x8,%esp
f010cd7f:	6a 01                	push   $0x1
f010cd81:	ff 75 08             	pushl  0x8(%ebp)
f010cd84:	e8 a6 dc ff ff       	call   f010aa2f <half_WS_Size>
f010cd89:	83 c4 10             	add    $0x10,%esp
			break;
f010cd8c:	eb 35                	jmp    f010cdc3 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010cd8e:	83 ec 08             	sub    $0x8,%esp
f010cd91:	6a 00                	push   $0x0
f010cd93:	ff 75 08             	pushl  0x8(%ebp)
f010cd96:	e8 94 dc ff ff       	call   f010aa2f <half_WS_Size>
f010cd9b:	83 c4 10             	add    $0x10,%esp
			break;
f010cd9e:	eb 23                	jmp    f010cdc3 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010cda0:	83 ec 08             	sub    $0x8,%esp
f010cda3:	6a 01                	push   $0x1
f010cda5:	ff 75 08             	pushl  0x8(%ebp)
f010cda8:	e8 65 dc ff ff       	call   f010aa12 <double_WS_Size>
f010cdad:	83 c4 10             	add    $0x10,%esp
			break;
f010cdb0:	eb 11                	jmp    f010cdc3 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010cdb2:	83 ec 08             	sub    $0x8,%esp
f010cdb5:	6a 00                	push   $0x0
f010cdb7:	ff 75 08             	pushl  0x8(%ebp)
f010cdba:	e8 53 dc ff ff       	call   f010aa12 <double_WS_Size>
f010cdbf:	83 c4 10             	add    $0x10,%esp
			break;
f010cdc2:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010cdc3:	8b 45 08             	mov    0x8(%ebp),%eax
f010cdc6:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010cdcc:	83 ec 08             	sub    $0x8,%esp
f010cdcf:	50                   	push   %eax
f010cdd0:	68 c5 64 12 f0       	push   $0xf01264c5
f010cdd5:	e8 b1 41 ff ff       	call   f0100f8b <cprintf>
f010cdda:	83 c4 10             	add    $0x10,%esp
f010cddd:	eb 01                	jmp    f010cde0 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010cddf:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010cde0:	c9                   	leave  
f010cde1:	c3                   	ret    

f010cde2 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010cde2:	55                   	push   %ebp
f010cde3:	89 e5                	mov    %esp,%ebp
f010cde5:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cde8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010cdef:	eb 29                	jmp    f010ce1a <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010cdf1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cdf4:	89 d0                	mov    %edx,%eax
f010cdf6:	01 c0                	add    %eax,%eax
f010cdf8:	01 d0                	add    %edx,%eax
f010cdfa:	c1 e0 02             	shl    $0x2,%eax
f010cdfd:	05 80 f9 17 f0       	add    $0xf017f980,%eax
f010ce02:	8b 00                	mov    (%eax),%eax
f010ce04:	83 ec 08             	sub    $0x8,%esp
f010ce07:	50                   	push   %eax
f010ce08:	ff 75 08             	pushl  0x8(%ebp)
f010ce0b:	e8 c4 2e 01 00       	call   f011fcd4 <strcmp>
f010ce10:	83 c4 10             	add    $0x10,%esp
f010ce13:	85 c0                	test   %eax,%eax
f010ce15:	74 0f                	je     f010ce26 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ce17:	ff 45 f4             	incl   -0xc(%ebp)
f010ce1a:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010ce1f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ce22:	7c cd                	jl     f010cdf1 <get_user_program_info+0xf>
f010ce24:	eb 01                	jmp    f010ce27 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010ce26:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010ce27:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010ce2c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ce2f:	75 1a                	jne    f010ce4b <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010ce31:	83 ec 08             	sub    $0x8,%esp
f010ce34:	ff 75 08             	pushl  0x8(%ebp)
f010ce37:	68 49 72 12 f0       	push   $0xf0127249
f010ce3c:	e8 4a 41 ff ff       	call   f0100f8b <cprintf>
f010ce41:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ce44:	b8 00 00 00 00       	mov    $0x0,%eax
f010ce49:	eb 11                	jmp    f010ce5c <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010ce4b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ce4e:	89 d0                	mov    %edx,%eax
f010ce50:	01 c0                	add    %eax,%eax
f010ce52:	01 d0                	add    %edx,%eax
f010ce54:	c1 e0 02             	shl    $0x2,%eax
f010ce57:	05 80 f9 17 f0       	add    $0xf017f980,%eax
}
f010ce5c:	c9                   	leave  
f010ce5d:	c3                   	ret    

f010ce5e <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010ce5e:	55                   	push   %ebp
f010ce5f:	89 e5                	mov    %esp,%ebp
f010ce61:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ce64:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ce6b:	eb 2d                	jmp    f010ce9a <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010ce6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ce70:	89 d0                	mov    %edx,%eax
f010ce72:	01 c0                	add    %eax,%eax
f010ce74:	01 d0                	add    %edx,%eax
f010ce76:	c1 e0 02             	shl    $0x2,%eax
f010ce79:	05 80 f9 17 f0       	add    $0xf017f980,%eax
f010ce7e:	8b 00                	mov    (%eax),%eax
f010ce80:	8b 55 08             	mov    0x8(%ebp),%edx
f010ce83:	83 c2 20             	add    $0x20,%edx
f010ce86:	83 ec 08             	sub    $0x8,%esp
f010ce89:	50                   	push   %eax
f010ce8a:	52                   	push   %edx
f010ce8b:	e8 44 2e 01 00       	call   f011fcd4 <strcmp>
f010ce90:	83 c4 10             	add    $0x10,%esp
f010ce93:	85 c0                	test   %eax,%eax
f010ce95:	74 0f                	je     f010cea6 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ce97:	ff 45 f4             	incl   -0xc(%ebp)
f010ce9a:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010ce9f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cea2:	7c c9                	jl     f010ce6d <get_user_program_info_by_env+0xf>
f010cea4:	eb 01                	jmp    f010cea7 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010cea6:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010cea7:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010ceac:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ceaf:	75 17                	jne    f010cec8 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010ceb1:	83 ec 0c             	sub    $0xc,%esp
f010ceb4:	68 64 72 12 f0       	push   $0xf0127264
f010ceb9:	e8 cd 40 ff ff       	call   f0100f8b <cprintf>
f010cebe:	83 c4 10             	add    $0x10,%esp
		return 0;
f010cec1:	b8 00 00 00 00       	mov    $0x0,%eax
f010cec6:	eb 11                	jmp    f010ced9 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010cec8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cecb:	89 d0                	mov    %edx,%eax
f010cecd:	01 c0                	add    %eax,%eax
f010cecf:	01 d0                	add    %edx,%eax
f010ced1:	c1 e0 02             	shl    $0x2,%eax
f010ced4:	05 80 f9 17 f0       	add    $0xf017f980,%eax
}
f010ced9:	c9                   	leave  
f010ceda:	c3                   	ret    

f010cedb <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010cedb:	55                   	push   %ebp
f010cedc:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010cede:	8b 45 08             	mov    0x8(%ebp),%eax
f010cee1:	83 f8 13             	cmp    $0x13,%eax
f010cee4:	77 0c                	ja     f010cef2 <trapname+0x17>
		return excnames[trapno];
f010cee6:	8b 45 08             	mov    0x8(%ebp),%eax
f010cee9:	8b 04 85 40 76 12 f0 	mov    -0xfed89c0(,%eax,4),%eax
f010cef0:	eb 2c                	jmp    f010cf1e <trapname+0x43>
	if (trapno == T_SYSCALL)
f010cef2:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010cef6:	75 07                	jne    f010ceff <trapname+0x24>
		return "System call";
f010cef8:	b8 80 72 12 f0       	mov    $0xf0127280,%eax
f010cefd:	eb 1f                	jmp    f010cf1e <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010ceff:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010cf03:	75 07                	jne    f010cf0c <trapname+0x31>
		return "Clock Interrupt";
f010cf05:	b8 8c 72 12 f0       	mov    $0xf012728c,%eax
f010cf0a:	eb 12                	jmp    f010cf1e <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010cf0c:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010cf10:	75 07                	jne    f010cf19 <trapname+0x3e>
		return "Keyboard Interrupt";
f010cf12:	b8 9c 72 12 f0       	mov    $0xf012729c,%eax
f010cf17:	eb 05                	jmp    f010cf1e <trapname+0x43>
	return "(unknown trap)";
f010cf19:	b8 af 72 12 f0       	mov    $0xf01272af,%eax
}
f010cf1e:	5d                   	pop    %ebp
f010cf1f:	c3                   	ret    

f010cf20 <ts_init>:


void ts_init(void)
{
f010cf20:	55                   	push   %ebp
f010cf21:	89 e5                	mov    %esp,%ebp
f010cf23:	53                   	push   %ebx
f010cf24:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010cf27:	e8 a3 a2 ff ff       	call   f01071cf <pushcli>

	struct cpu* c = mycpu();
f010cf2c:	e8 db a1 ff ff       	call   f010710c <mycpu>
f010cf31:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010cf34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf37:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010cf3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf41:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010cf47:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf4a:	83 c0 0c             	add    $0xc,%eax
f010cf4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf50:	83 c2 0c             	add    $0xc,%edx
f010cf53:	c1 ea 10             	shr    $0x10,%edx
f010cf56:	88 d3                	mov    %dl,%bl
f010cf58:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf5b:	83 c2 0c             	add    $0xc,%edx
f010cf5e:	c1 ea 18             	shr    $0x18,%edx
f010cf61:	88 d1                	mov    %dl,%cl
f010cf63:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf66:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010cf6d:	68 00 
f010cf6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf72:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010cf79:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf7c:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010cf82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf85:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cf8b:	83 e2 f0             	and    $0xfffffff0,%edx
f010cf8e:	83 ca 09             	or     $0x9,%edx
f010cf91:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cf97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf9a:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cfa0:	83 ca 10             	or     $0x10,%edx
f010cfa3:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cfa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfac:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cfb2:	83 e2 9f             	and    $0xffffff9f,%edx
f010cfb5:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cfbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfbe:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cfc4:	83 ca 80             	or     $0xffffff80,%edx
f010cfc7:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cfcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfd0:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cfd6:	83 e2 f0             	and    $0xfffffff0,%edx
f010cfd9:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cfdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfe2:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cfe8:	83 e2 ef             	and    $0xffffffef,%edx
f010cfeb:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cff1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cff4:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cffa:	83 e2 df             	and    $0xffffffdf,%edx
f010cffd:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d003:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d006:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d00c:	83 ca 40             	or     $0x40,%edx
f010d00f:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d015:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d018:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d01e:	83 e2 7f             	and    $0x7f,%edx
f010d021:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d027:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d02a:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010d030:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d033:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d039:	83 e2 ef             	and    $0xffffffef,%edx
f010d03c:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010d042:	e8 da a1 ff ff       	call   f0107221 <popcli>
f010d047:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010d04d:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010d051:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010d054:	90                   	nop
f010d055:	83 c4 14             	add    $0x14,%esp
f010d058:	5b                   	pop    %ebx
f010d059:	5d                   	pop    %ebp
f010d05a:	c3                   	ret    

f010d05b <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010d05b:	55                   	push   %ebp
f010d05c:	89 e5                	mov    %esp,%ebp
f010d05e:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010d061:	b8 0a e5 10 f0       	mov    $0xf010e50a,%eax
f010d066:	66 a3 60 7b 69 f0    	mov    %ax,0xf0697b60
f010d06c:	66 c7 05 62 7b 69 f0 	movw   $0x8,0xf0697b62
f010d073:	08 00 
f010d075:	a0 64 7b 69 f0       	mov    0xf0697b64,%al
f010d07a:	83 e0 e0             	and    $0xffffffe0,%eax
f010d07d:	a2 64 7b 69 f0       	mov    %al,0xf0697b64
f010d082:	a0 64 7b 69 f0       	mov    0xf0697b64,%al
f010d087:	83 e0 1f             	and    $0x1f,%eax
f010d08a:	a2 64 7b 69 f0       	mov    %al,0xf0697b64
f010d08f:	a0 65 7b 69 f0       	mov    0xf0697b65,%al
f010d094:	83 e0 f0             	and    $0xfffffff0,%eax
f010d097:	83 c8 0e             	or     $0xe,%eax
f010d09a:	a2 65 7b 69 f0       	mov    %al,0xf0697b65
f010d09f:	a0 65 7b 69 f0       	mov    0xf0697b65,%al
f010d0a4:	83 e0 ef             	and    $0xffffffef,%eax
f010d0a7:	a2 65 7b 69 f0       	mov    %al,0xf0697b65
f010d0ac:	a0 65 7b 69 f0       	mov    0xf0697b65,%al
f010d0b1:	83 e0 9f             	and    $0xffffff9f,%eax
f010d0b4:	a2 65 7b 69 f0       	mov    %al,0xf0697b65
f010d0b9:	a0 65 7b 69 f0       	mov    0xf0697b65,%al
f010d0be:	83 c8 80             	or     $0xffffff80,%eax
f010d0c1:	a2 65 7b 69 f0       	mov    %al,0xf0697b65
f010d0c6:	b8 0a e5 10 f0       	mov    $0xf010e50a,%eax
f010d0cb:	c1 e8 10             	shr    $0x10,%eax
f010d0ce:	66 a3 66 7b 69 f0    	mov    %ax,0xf0697b66
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010d0d4:	b8 12 e5 10 f0       	mov    $0xf010e512,%eax
f010d0d9:	66 a3 90 7b 69 f0    	mov    %ax,0xf0697b90
f010d0df:	66 c7 05 92 7b 69 f0 	movw   $0x8,0xf0697b92
f010d0e6:	08 00 
f010d0e8:	a0 94 7b 69 f0       	mov    0xf0697b94,%al
f010d0ed:	83 e0 e0             	and    $0xffffffe0,%eax
f010d0f0:	a2 94 7b 69 f0       	mov    %al,0xf0697b94
f010d0f5:	a0 94 7b 69 f0       	mov    0xf0697b94,%al
f010d0fa:	83 e0 1f             	and    $0x1f,%eax
f010d0fd:	a2 94 7b 69 f0       	mov    %al,0xf0697b94
f010d102:	a0 95 7b 69 f0       	mov    0xf0697b95,%al
f010d107:	83 e0 f0             	and    $0xfffffff0,%eax
f010d10a:	83 c8 0e             	or     $0xe,%eax
f010d10d:	a2 95 7b 69 f0       	mov    %al,0xf0697b95
f010d112:	a0 95 7b 69 f0       	mov    0xf0697b95,%al
f010d117:	83 e0 ef             	and    $0xffffffef,%eax
f010d11a:	a2 95 7b 69 f0       	mov    %al,0xf0697b95
f010d11f:	a0 95 7b 69 f0       	mov    0xf0697b95,%al
f010d124:	83 e0 9f             	and    $0xffffff9f,%eax
f010d127:	a2 95 7b 69 f0       	mov    %al,0xf0697b95
f010d12c:	a0 95 7b 69 f0       	mov    0xf0697b95,%al
f010d131:	83 c8 80             	or     $0xffffff80,%eax
f010d134:	a2 95 7b 69 f0       	mov    %al,0xf0697b95
f010d139:	b8 12 e5 10 f0       	mov    $0xf010e512,%eax
f010d13e:	c1 e8 10             	shr    $0x10,%eax
f010d141:	66 a3 96 7b 69 f0    	mov    %ax,0xf0697b96
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010d147:	b8 1a e5 10 f0       	mov    $0xf010e51a,%eax
f010d14c:	66 a3 20 7c 69 f0    	mov    %ax,0xf0697c20
f010d152:	66 c7 05 22 7c 69 f0 	movw   $0x8,0xf0697c22
f010d159:	08 00 
f010d15b:	a0 24 7c 69 f0       	mov    0xf0697c24,%al
f010d160:	83 e0 e0             	and    $0xffffffe0,%eax
f010d163:	a2 24 7c 69 f0       	mov    %al,0xf0697c24
f010d168:	a0 24 7c 69 f0       	mov    0xf0697c24,%al
f010d16d:	83 e0 1f             	and    $0x1f,%eax
f010d170:	a2 24 7c 69 f0       	mov    %al,0xf0697c24
f010d175:	a0 25 7c 69 f0       	mov    0xf0697c25,%al
f010d17a:	83 e0 f0             	and    $0xfffffff0,%eax
f010d17d:	83 c8 0e             	or     $0xe,%eax
f010d180:	a2 25 7c 69 f0       	mov    %al,0xf0697c25
f010d185:	a0 25 7c 69 f0       	mov    0xf0697c25,%al
f010d18a:	83 e0 ef             	and    $0xffffffef,%eax
f010d18d:	a2 25 7c 69 f0       	mov    %al,0xf0697c25
f010d192:	a0 25 7c 69 f0       	mov    0xf0697c25,%al
f010d197:	83 c8 60             	or     $0x60,%eax
f010d19a:	a2 25 7c 69 f0       	mov    %al,0xf0697c25
f010d19f:	a0 25 7c 69 f0       	mov    0xf0697c25,%al
f010d1a4:	83 c8 80             	or     $0xffffff80,%eax
f010d1a7:	a2 25 7c 69 f0       	mov    %al,0xf0697c25
f010d1ac:	b8 1a e5 10 f0       	mov    $0xf010e51a,%eax
f010d1b1:	c1 e8 10             	shr    $0x10,%eax
f010d1b4:	66 a3 26 7c 69 f0    	mov    %ax,0xf0697c26
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010d1ba:	b8 24 e5 10 f0       	mov    $0xf010e524,%eax
f010d1bf:	66 a3 28 7c 69 f0    	mov    %ax,0xf0697c28
f010d1c5:	66 c7 05 2a 7c 69 f0 	movw   $0x8,0xf0697c2a
f010d1cc:	08 00 
f010d1ce:	a0 2c 7c 69 f0       	mov    0xf0697c2c,%al
f010d1d3:	83 e0 e0             	and    $0xffffffe0,%eax
f010d1d6:	a2 2c 7c 69 f0       	mov    %al,0xf0697c2c
f010d1db:	a0 2c 7c 69 f0       	mov    0xf0697c2c,%al
f010d1e0:	83 e0 1f             	and    $0x1f,%eax
f010d1e3:	a2 2c 7c 69 f0       	mov    %al,0xf0697c2c
f010d1e8:	a0 2d 7c 69 f0       	mov    0xf0697c2d,%al
f010d1ed:	83 e0 f0             	and    $0xfffffff0,%eax
f010d1f0:	83 c8 0e             	or     $0xe,%eax
f010d1f3:	a2 2d 7c 69 f0       	mov    %al,0xf0697c2d
f010d1f8:	a0 2d 7c 69 f0       	mov    0xf0697c2d,%al
f010d1fd:	83 e0 ef             	and    $0xffffffef,%eax
f010d200:	a2 2d 7c 69 f0       	mov    %al,0xf0697c2d
f010d205:	a0 2d 7c 69 f0       	mov    0xf0697c2d,%al
f010d20a:	83 c8 60             	or     $0x60,%eax
f010d20d:	a2 2d 7c 69 f0       	mov    %al,0xf0697c2d
f010d212:	a0 2d 7c 69 f0       	mov    0xf0697c2d,%al
f010d217:	83 c8 80             	or     $0xffffff80,%eax
f010d21a:	a2 2d 7c 69 f0       	mov    %al,0xf0697c2d
f010d21f:	b8 24 e5 10 f0       	mov    $0xf010e524,%eax
f010d224:	c1 e8 10             	shr    $0x10,%eax
f010d227:	66 a3 2e 7c 69 f0    	mov    %ax,0xf0697c2e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010d22d:	b8 2e e5 10 f0       	mov    $0xf010e52e,%eax
f010d232:	66 a3 a0 7c 69 f0    	mov    %ax,0xf0697ca0
f010d238:	66 c7 05 a2 7c 69 f0 	movw   $0x8,0xf0697ca2
f010d23f:	08 00 
f010d241:	a0 a4 7c 69 f0       	mov    0xf0697ca4,%al
f010d246:	83 e0 e0             	and    $0xffffffe0,%eax
f010d249:	a2 a4 7c 69 f0       	mov    %al,0xf0697ca4
f010d24e:	a0 a4 7c 69 f0       	mov    0xf0697ca4,%al
f010d253:	83 e0 1f             	and    $0x1f,%eax
f010d256:	a2 a4 7c 69 f0       	mov    %al,0xf0697ca4
f010d25b:	a0 a5 7c 69 f0       	mov    0xf0697ca5,%al
f010d260:	83 e0 f0             	and    $0xfffffff0,%eax
f010d263:	83 c8 0e             	or     $0xe,%eax
f010d266:	a2 a5 7c 69 f0       	mov    %al,0xf0697ca5
f010d26b:	a0 a5 7c 69 f0       	mov    0xf0697ca5,%al
f010d270:	83 e0 ef             	and    $0xffffffef,%eax
f010d273:	a2 a5 7c 69 f0       	mov    %al,0xf0697ca5
f010d278:	a0 a5 7c 69 f0       	mov    0xf0697ca5,%al
f010d27d:	83 c8 60             	or     $0x60,%eax
f010d280:	a2 a5 7c 69 f0       	mov    %al,0xf0697ca5
f010d285:	a0 a5 7c 69 f0       	mov    0xf0697ca5,%al
f010d28a:	83 c8 80             	or     $0xffffff80,%eax
f010d28d:	a2 a5 7c 69 f0       	mov    %al,0xf0697ca5
f010d292:	b8 2e e5 10 f0       	mov    $0xf010e52e,%eax
f010d297:	c1 e8 10             	shr    $0x10,%eax
f010d29a:	66 a3 a6 7c 69 f0    	mov    %ax,0xf0697ca6

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010d2a0:	b8 38 e5 10 f0       	mov    $0xf010e538,%eax
f010d2a5:	66 a3 20 7b 69 f0    	mov    %ax,0xf0697b20
f010d2ab:	66 c7 05 22 7b 69 f0 	movw   $0x8,0xf0697b22
f010d2b2:	08 00 
f010d2b4:	a0 24 7b 69 f0       	mov    0xf0697b24,%al
f010d2b9:	83 e0 e0             	and    $0xffffffe0,%eax
f010d2bc:	a2 24 7b 69 f0       	mov    %al,0xf0697b24
f010d2c1:	a0 24 7b 69 f0       	mov    0xf0697b24,%al
f010d2c6:	83 e0 1f             	and    $0x1f,%eax
f010d2c9:	a2 24 7b 69 f0       	mov    %al,0xf0697b24
f010d2ce:	a0 25 7b 69 f0       	mov    0xf0697b25,%al
f010d2d3:	83 e0 f0             	and    $0xfffffff0,%eax
f010d2d6:	83 c8 0e             	or     $0xe,%eax
f010d2d9:	a2 25 7b 69 f0       	mov    %al,0xf0697b25
f010d2de:	a0 25 7b 69 f0       	mov    0xf0697b25,%al
f010d2e3:	83 e0 ef             	and    $0xffffffef,%eax
f010d2e6:	a2 25 7b 69 f0       	mov    %al,0xf0697b25
f010d2eb:	a0 25 7b 69 f0       	mov    0xf0697b25,%al
f010d2f0:	83 c8 60             	or     $0x60,%eax
f010d2f3:	a2 25 7b 69 f0       	mov    %al,0xf0697b25
f010d2f8:	a0 25 7b 69 f0       	mov    0xf0697b25,%al
f010d2fd:	83 c8 80             	or     $0xffffff80,%eax
f010d300:	a2 25 7b 69 f0       	mov    %al,0xf0697b25
f010d305:	b8 38 e5 10 f0       	mov    $0xf010e538,%eax
f010d30a:	c1 e8 10             	shr    $0x10,%eax
f010d30d:	66 a3 26 7b 69 f0    	mov    %ax,0xf0697b26
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010d313:	b8 42 e5 10 f0       	mov    $0xf010e542,%eax
f010d318:	66 a3 28 7b 69 f0    	mov    %ax,0xf0697b28
f010d31e:	66 c7 05 2a 7b 69 f0 	movw   $0x8,0xf0697b2a
f010d325:	08 00 
f010d327:	a0 2c 7b 69 f0       	mov    0xf0697b2c,%al
f010d32c:	83 e0 e0             	and    $0xffffffe0,%eax
f010d32f:	a2 2c 7b 69 f0       	mov    %al,0xf0697b2c
f010d334:	a0 2c 7b 69 f0       	mov    0xf0697b2c,%al
f010d339:	83 e0 1f             	and    $0x1f,%eax
f010d33c:	a2 2c 7b 69 f0       	mov    %al,0xf0697b2c
f010d341:	a0 2d 7b 69 f0       	mov    0xf0697b2d,%al
f010d346:	83 c8 0f             	or     $0xf,%eax
f010d349:	a2 2d 7b 69 f0       	mov    %al,0xf0697b2d
f010d34e:	a0 2d 7b 69 f0       	mov    0xf0697b2d,%al
f010d353:	83 e0 ef             	and    $0xffffffef,%eax
f010d356:	a2 2d 7b 69 f0       	mov    %al,0xf0697b2d
f010d35b:	a0 2d 7b 69 f0       	mov    0xf0697b2d,%al
f010d360:	83 c8 60             	or     $0x60,%eax
f010d363:	a2 2d 7b 69 f0       	mov    %al,0xf0697b2d
f010d368:	a0 2d 7b 69 f0       	mov    0xf0697b2d,%al
f010d36d:	83 c8 80             	or     $0xffffff80,%eax
f010d370:	a2 2d 7b 69 f0       	mov    %al,0xf0697b2d
f010d375:	b8 42 e5 10 f0       	mov    $0xf010e542,%eax
f010d37a:	c1 e8 10             	shr    $0x10,%eax
f010d37d:	66 a3 2e 7b 69 f0    	mov    %ax,0xf0697b2e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010d383:	b8 4c e5 10 f0       	mov    $0xf010e54c,%eax
f010d388:	66 a3 30 7b 69 f0    	mov    %ax,0xf0697b30
f010d38e:	66 c7 05 32 7b 69 f0 	movw   $0x8,0xf0697b32
f010d395:	08 00 
f010d397:	a0 34 7b 69 f0       	mov    0xf0697b34,%al
f010d39c:	83 e0 e0             	and    $0xffffffe0,%eax
f010d39f:	a2 34 7b 69 f0       	mov    %al,0xf0697b34
f010d3a4:	a0 34 7b 69 f0       	mov    0xf0697b34,%al
f010d3a9:	83 e0 1f             	and    $0x1f,%eax
f010d3ac:	a2 34 7b 69 f0       	mov    %al,0xf0697b34
f010d3b1:	a0 35 7b 69 f0       	mov    0xf0697b35,%al
f010d3b6:	83 e0 f0             	and    $0xfffffff0,%eax
f010d3b9:	83 c8 0e             	or     $0xe,%eax
f010d3bc:	a2 35 7b 69 f0       	mov    %al,0xf0697b35
f010d3c1:	a0 35 7b 69 f0       	mov    0xf0697b35,%al
f010d3c6:	83 e0 ef             	and    $0xffffffef,%eax
f010d3c9:	a2 35 7b 69 f0       	mov    %al,0xf0697b35
f010d3ce:	a0 35 7b 69 f0       	mov    0xf0697b35,%al
f010d3d3:	83 c8 60             	or     $0x60,%eax
f010d3d6:	a2 35 7b 69 f0       	mov    %al,0xf0697b35
f010d3db:	a0 35 7b 69 f0       	mov    0xf0697b35,%al
f010d3e0:	83 c8 80             	or     $0xffffff80,%eax
f010d3e3:	a2 35 7b 69 f0       	mov    %al,0xf0697b35
f010d3e8:	b8 4c e5 10 f0       	mov    $0xf010e54c,%eax
f010d3ed:	c1 e8 10             	shr    $0x10,%eax
f010d3f0:	66 a3 36 7b 69 f0    	mov    %ax,0xf0697b36
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010d3f6:	b8 56 e5 10 f0       	mov    $0xf010e556,%eax
f010d3fb:	66 a3 38 7b 69 f0    	mov    %ax,0xf0697b38
f010d401:	66 c7 05 3a 7b 69 f0 	movw   $0x8,0xf0697b3a
f010d408:	08 00 
f010d40a:	a0 3c 7b 69 f0       	mov    0xf0697b3c,%al
f010d40f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d412:	a2 3c 7b 69 f0       	mov    %al,0xf0697b3c
f010d417:	a0 3c 7b 69 f0       	mov    0xf0697b3c,%al
f010d41c:	83 e0 1f             	and    $0x1f,%eax
f010d41f:	a2 3c 7b 69 f0       	mov    %al,0xf0697b3c
f010d424:	a0 3d 7b 69 f0       	mov    0xf0697b3d,%al
f010d429:	83 c8 0f             	or     $0xf,%eax
f010d42c:	a2 3d 7b 69 f0       	mov    %al,0xf0697b3d
f010d431:	a0 3d 7b 69 f0       	mov    0xf0697b3d,%al
f010d436:	83 e0 ef             	and    $0xffffffef,%eax
f010d439:	a2 3d 7b 69 f0       	mov    %al,0xf0697b3d
f010d43e:	a0 3d 7b 69 f0       	mov    0xf0697b3d,%al
f010d443:	83 c8 60             	or     $0x60,%eax
f010d446:	a2 3d 7b 69 f0       	mov    %al,0xf0697b3d
f010d44b:	a0 3d 7b 69 f0       	mov    0xf0697b3d,%al
f010d450:	83 c8 80             	or     $0xffffff80,%eax
f010d453:	a2 3d 7b 69 f0       	mov    %al,0xf0697b3d
f010d458:	b8 56 e5 10 f0       	mov    $0xf010e556,%eax
f010d45d:	c1 e8 10             	shr    $0x10,%eax
f010d460:	66 a3 3e 7b 69 f0    	mov    %ax,0xf0697b3e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010d466:	b8 60 e5 10 f0       	mov    $0xf010e560,%eax
f010d46b:	66 a3 40 7b 69 f0    	mov    %ax,0xf0697b40
f010d471:	66 c7 05 42 7b 69 f0 	movw   $0x8,0xf0697b42
f010d478:	08 00 
f010d47a:	a0 44 7b 69 f0       	mov    0xf0697b44,%al
f010d47f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d482:	a2 44 7b 69 f0       	mov    %al,0xf0697b44
f010d487:	a0 44 7b 69 f0       	mov    0xf0697b44,%al
f010d48c:	83 e0 1f             	and    $0x1f,%eax
f010d48f:	a2 44 7b 69 f0       	mov    %al,0xf0697b44
f010d494:	a0 45 7b 69 f0       	mov    0xf0697b45,%al
f010d499:	83 c8 0f             	or     $0xf,%eax
f010d49c:	a2 45 7b 69 f0       	mov    %al,0xf0697b45
f010d4a1:	a0 45 7b 69 f0       	mov    0xf0697b45,%al
f010d4a6:	83 e0 ef             	and    $0xffffffef,%eax
f010d4a9:	a2 45 7b 69 f0       	mov    %al,0xf0697b45
f010d4ae:	a0 45 7b 69 f0       	mov    0xf0697b45,%al
f010d4b3:	83 c8 60             	or     $0x60,%eax
f010d4b6:	a2 45 7b 69 f0       	mov    %al,0xf0697b45
f010d4bb:	a0 45 7b 69 f0       	mov    0xf0697b45,%al
f010d4c0:	83 c8 80             	or     $0xffffff80,%eax
f010d4c3:	a2 45 7b 69 f0       	mov    %al,0xf0697b45
f010d4c8:	b8 60 e5 10 f0       	mov    $0xf010e560,%eax
f010d4cd:	c1 e8 10             	shr    $0x10,%eax
f010d4d0:	66 a3 46 7b 69 f0    	mov    %ax,0xf0697b46
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010d4d6:	b8 6a e5 10 f0       	mov    $0xf010e56a,%eax
f010d4db:	66 a3 48 7b 69 f0    	mov    %ax,0xf0697b48
f010d4e1:	66 c7 05 4a 7b 69 f0 	movw   $0x8,0xf0697b4a
f010d4e8:	08 00 
f010d4ea:	a0 4c 7b 69 f0       	mov    0xf0697b4c,%al
f010d4ef:	83 e0 e0             	and    $0xffffffe0,%eax
f010d4f2:	a2 4c 7b 69 f0       	mov    %al,0xf0697b4c
f010d4f7:	a0 4c 7b 69 f0       	mov    0xf0697b4c,%al
f010d4fc:	83 e0 1f             	and    $0x1f,%eax
f010d4ff:	a2 4c 7b 69 f0       	mov    %al,0xf0697b4c
f010d504:	a0 4d 7b 69 f0       	mov    0xf0697b4d,%al
f010d509:	83 e0 f0             	and    $0xfffffff0,%eax
f010d50c:	83 c8 0e             	or     $0xe,%eax
f010d50f:	a2 4d 7b 69 f0       	mov    %al,0xf0697b4d
f010d514:	a0 4d 7b 69 f0       	mov    0xf0697b4d,%al
f010d519:	83 e0 ef             	and    $0xffffffef,%eax
f010d51c:	a2 4d 7b 69 f0       	mov    %al,0xf0697b4d
f010d521:	a0 4d 7b 69 f0       	mov    0xf0697b4d,%al
f010d526:	83 c8 60             	or     $0x60,%eax
f010d529:	a2 4d 7b 69 f0       	mov    %al,0xf0697b4d
f010d52e:	a0 4d 7b 69 f0       	mov    0xf0697b4d,%al
f010d533:	83 c8 80             	or     $0xffffff80,%eax
f010d536:	a2 4d 7b 69 f0       	mov    %al,0xf0697b4d
f010d53b:	b8 6a e5 10 f0       	mov    $0xf010e56a,%eax
f010d540:	c1 e8 10             	shr    $0x10,%eax
f010d543:	66 a3 4e 7b 69 f0    	mov    %ax,0xf0697b4e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010d549:	b8 74 e5 10 f0       	mov    $0xf010e574,%eax
f010d54e:	66 a3 50 7b 69 f0    	mov    %ax,0xf0697b50
f010d554:	66 c7 05 52 7b 69 f0 	movw   $0x8,0xf0697b52
f010d55b:	08 00 
f010d55d:	a0 54 7b 69 f0       	mov    0xf0697b54,%al
f010d562:	83 e0 e0             	and    $0xffffffe0,%eax
f010d565:	a2 54 7b 69 f0       	mov    %al,0xf0697b54
f010d56a:	a0 54 7b 69 f0       	mov    0xf0697b54,%al
f010d56f:	83 e0 1f             	and    $0x1f,%eax
f010d572:	a2 54 7b 69 f0       	mov    %al,0xf0697b54
f010d577:	a0 55 7b 69 f0       	mov    0xf0697b55,%al
f010d57c:	83 e0 f0             	and    $0xfffffff0,%eax
f010d57f:	83 c8 0e             	or     $0xe,%eax
f010d582:	a2 55 7b 69 f0       	mov    %al,0xf0697b55
f010d587:	a0 55 7b 69 f0       	mov    0xf0697b55,%al
f010d58c:	83 e0 ef             	and    $0xffffffef,%eax
f010d58f:	a2 55 7b 69 f0       	mov    %al,0xf0697b55
f010d594:	a0 55 7b 69 f0       	mov    0xf0697b55,%al
f010d599:	83 c8 60             	or     $0x60,%eax
f010d59c:	a2 55 7b 69 f0       	mov    %al,0xf0697b55
f010d5a1:	a0 55 7b 69 f0       	mov    0xf0697b55,%al
f010d5a6:	83 c8 80             	or     $0xffffff80,%eax
f010d5a9:	a2 55 7b 69 f0       	mov    %al,0xf0697b55
f010d5ae:	b8 74 e5 10 f0       	mov    $0xf010e574,%eax
f010d5b3:	c1 e8 10             	shr    $0x10,%eax
f010d5b6:	66 a3 56 7b 69 f0    	mov    %ax,0xf0697b56
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010d5bc:	b8 7e e5 10 f0       	mov    $0xf010e57e,%eax
f010d5c1:	66 a3 58 7b 69 f0    	mov    %ax,0xf0697b58
f010d5c7:	66 c7 05 5a 7b 69 f0 	movw   $0x8,0xf0697b5a
f010d5ce:	08 00 
f010d5d0:	a0 5c 7b 69 f0       	mov    0xf0697b5c,%al
f010d5d5:	83 e0 e0             	and    $0xffffffe0,%eax
f010d5d8:	a2 5c 7b 69 f0       	mov    %al,0xf0697b5c
f010d5dd:	a0 5c 7b 69 f0       	mov    0xf0697b5c,%al
f010d5e2:	83 e0 1f             	and    $0x1f,%eax
f010d5e5:	a2 5c 7b 69 f0       	mov    %al,0xf0697b5c
f010d5ea:	a0 5d 7b 69 f0       	mov    0xf0697b5d,%al
f010d5ef:	83 e0 f0             	and    $0xfffffff0,%eax
f010d5f2:	83 c8 0e             	or     $0xe,%eax
f010d5f5:	a2 5d 7b 69 f0       	mov    %al,0xf0697b5d
f010d5fa:	a0 5d 7b 69 f0       	mov    0xf0697b5d,%al
f010d5ff:	83 e0 ef             	and    $0xffffffef,%eax
f010d602:	a2 5d 7b 69 f0       	mov    %al,0xf0697b5d
f010d607:	a0 5d 7b 69 f0       	mov    0xf0697b5d,%al
f010d60c:	83 c8 60             	or     $0x60,%eax
f010d60f:	a2 5d 7b 69 f0       	mov    %al,0xf0697b5d
f010d614:	a0 5d 7b 69 f0       	mov    0xf0697b5d,%al
f010d619:	83 c8 80             	or     $0xffffff80,%eax
f010d61c:	a2 5d 7b 69 f0       	mov    %al,0xf0697b5d
f010d621:	b8 7e e5 10 f0       	mov    $0xf010e57e,%eax
f010d626:	c1 e8 10             	shr    $0x10,%eax
f010d629:	66 a3 5e 7b 69 f0    	mov    %ax,0xf0697b5e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d62f:	b8 84 e5 10 f0       	mov    $0xf010e584,%eax
f010d634:	66 a3 70 7b 69 f0    	mov    %ax,0xf0697b70
f010d63a:	66 c7 05 72 7b 69 f0 	movw   $0x8,0xf0697b72
f010d641:	08 00 
f010d643:	a0 74 7b 69 f0       	mov    0xf0697b74,%al
f010d648:	83 e0 e0             	and    $0xffffffe0,%eax
f010d64b:	a2 74 7b 69 f0       	mov    %al,0xf0697b74
f010d650:	a0 74 7b 69 f0       	mov    0xf0697b74,%al
f010d655:	83 e0 1f             	and    $0x1f,%eax
f010d658:	a2 74 7b 69 f0       	mov    %al,0xf0697b74
f010d65d:	a0 75 7b 69 f0       	mov    0xf0697b75,%al
f010d662:	83 e0 f0             	and    $0xfffffff0,%eax
f010d665:	83 c8 0e             	or     $0xe,%eax
f010d668:	a2 75 7b 69 f0       	mov    %al,0xf0697b75
f010d66d:	a0 75 7b 69 f0       	mov    0xf0697b75,%al
f010d672:	83 e0 ef             	and    $0xffffffef,%eax
f010d675:	a2 75 7b 69 f0       	mov    %al,0xf0697b75
f010d67a:	a0 75 7b 69 f0       	mov    0xf0697b75,%al
f010d67f:	83 c8 60             	or     $0x60,%eax
f010d682:	a2 75 7b 69 f0       	mov    %al,0xf0697b75
f010d687:	a0 75 7b 69 f0       	mov    0xf0697b75,%al
f010d68c:	83 c8 80             	or     $0xffffff80,%eax
f010d68f:	a2 75 7b 69 f0       	mov    %al,0xf0697b75
f010d694:	b8 84 e5 10 f0       	mov    $0xf010e584,%eax
f010d699:	c1 e8 10             	shr    $0x10,%eax
f010d69c:	66 a3 76 7b 69 f0    	mov    %ax,0xf0697b76
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010d6a2:	b8 88 e5 10 f0       	mov    $0xf010e588,%eax
f010d6a7:	66 a3 78 7b 69 f0    	mov    %ax,0xf0697b78
f010d6ad:	66 c7 05 7a 7b 69 f0 	movw   $0x8,0xf0697b7a
f010d6b4:	08 00 
f010d6b6:	a0 7c 7b 69 f0       	mov    0xf0697b7c,%al
f010d6bb:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6be:	a2 7c 7b 69 f0       	mov    %al,0xf0697b7c
f010d6c3:	a0 7c 7b 69 f0       	mov    0xf0697b7c,%al
f010d6c8:	83 e0 1f             	and    $0x1f,%eax
f010d6cb:	a2 7c 7b 69 f0       	mov    %al,0xf0697b7c
f010d6d0:	a0 7d 7b 69 f0       	mov    0xf0697b7d,%al
f010d6d5:	83 e0 f0             	and    $0xfffffff0,%eax
f010d6d8:	83 c8 0e             	or     $0xe,%eax
f010d6db:	a2 7d 7b 69 f0       	mov    %al,0xf0697b7d
f010d6e0:	a0 7d 7b 69 f0       	mov    0xf0697b7d,%al
f010d6e5:	83 e0 ef             	and    $0xffffffef,%eax
f010d6e8:	a2 7d 7b 69 f0       	mov    %al,0xf0697b7d
f010d6ed:	a0 7d 7b 69 f0       	mov    0xf0697b7d,%al
f010d6f2:	83 c8 60             	or     $0x60,%eax
f010d6f5:	a2 7d 7b 69 f0       	mov    %al,0xf0697b7d
f010d6fa:	a0 7d 7b 69 f0       	mov    0xf0697b7d,%al
f010d6ff:	83 c8 80             	or     $0xffffff80,%eax
f010d702:	a2 7d 7b 69 f0       	mov    %al,0xf0697b7d
f010d707:	b8 88 e5 10 f0       	mov    $0xf010e588,%eax
f010d70c:	c1 e8 10             	shr    $0x10,%eax
f010d70f:	66 a3 7e 7b 69 f0    	mov    %ax,0xf0697b7e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010d715:	b8 8c e5 10 f0       	mov    $0xf010e58c,%eax
f010d71a:	66 a3 80 7b 69 f0    	mov    %ax,0xf0697b80
f010d720:	66 c7 05 82 7b 69 f0 	movw   $0x8,0xf0697b82
f010d727:	08 00 
f010d729:	a0 84 7b 69 f0       	mov    0xf0697b84,%al
f010d72e:	83 e0 e0             	and    $0xffffffe0,%eax
f010d731:	a2 84 7b 69 f0       	mov    %al,0xf0697b84
f010d736:	a0 84 7b 69 f0       	mov    0xf0697b84,%al
f010d73b:	83 e0 1f             	and    $0x1f,%eax
f010d73e:	a2 84 7b 69 f0       	mov    %al,0xf0697b84
f010d743:	a0 85 7b 69 f0       	mov    0xf0697b85,%al
f010d748:	83 e0 f0             	and    $0xfffffff0,%eax
f010d74b:	83 c8 0e             	or     $0xe,%eax
f010d74e:	a2 85 7b 69 f0       	mov    %al,0xf0697b85
f010d753:	a0 85 7b 69 f0       	mov    0xf0697b85,%al
f010d758:	83 e0 ef             	and    $0xffffffef,%eax
f010d75b:	a2 85 7b 69 f0       	mov    %al,0xf0697b85
f010d760:	a0 85 7b 69 f0       	mov    0xf0697b85,%al
f010d765:	83 c8 60             	or     $0x60,%eax
f010d768:	a2 85 7b 69 f0       	mov    %al,0xf0697b85
f010d76d:	a0 85 7b 69 f0       	mov    0xf0697b85,%al
f010d772:	83 c8 80             	or     $0xffffff80,%eax
f010d775:	a2 85 7b 69 f0       	mov    %al,0xf0697b85
f010d77a:	b8 8c e5 10 f0       	mov    $0xf010e58c,%eax
f010d77f:	c1 e8 10             	shr    $0x10,%eax
f010d782:	66 a3 86 7b 69 f0    	mov    %ax,0xf0697b86
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010d788:	b8 90 e5 10 f0       	mov    $0xf010e590,%eax
f010d78d:	66 a3 88 7b 69 f0    	mov    %ax,0xf0697b88
f010d793:	66 c7 05 8a 7b 69 f0 	movw   $0x8,0xf0697b8a
f010d79a:	08 00 
f010d79c:	a0 8c 7b 69 f0       	mov    0xf0697b8c,%al
f010d7a1:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7a4:	a2 8c 7b 69 f0       	mov    %al,0xf0697b8c
f010d7a9:	a0 8c 7b 69 f0       	mov    0xf0697b8c,%al
f010d7ae:	83 e0 1f             	and    $0x1f,%eax
f010d7b1:	a2 8c 7b 69 f0       	mov    %al,0xf0697b8c
f010d7b6:	a0 8d 7b 69 f0       	mov    0xf0697b8d,%al
f010d7bb:	83 e0 f0             	and    $0xfffffff0,%eax
f010d7be:	83 c8 0e             	or     $0xe,%eax
f010d7c1:	a2 8d 7b 69 f0       	mov    %al,0xf0697b8d
f010d7c6:	a0 8d 7b 69 f0       	mov    0xf0697b8d,%al
f010d7cb:	83 e0 ef             	and    $0xffffffef,%eax
f010d7ce:	a2 8d 7b 69 f0       	mov    %al,0xf0697b8d
f010d7d3:	a0 8d 7b 69 f0       	mov    0xf0697b8d,%al
f010d7d8:	83 c8 60             	or     $0x60,%eax
f010d7db:	a2 8d 7b 69 f0       	mov    %al,0xf0697b8d
f010d7e0:	a0 8d 7b 69 f0       	mov    0xf0697b8d,%al
f010d7e5:	83 c8 80             	or     $0xffffff80,%eax
f010d7e8:	a2 8d 7b 69 f0       	mov    %al,0xf0697b8d
f010d7ed:	b8 90 e5 10 f0       	mov    $0xf010e590,%eax
f010d7f2:	c1 e8 10             	shr    $0x10,%eax
f010d7f5:	66 a3 8e 7b 69 f0    	mov    %ax,0xf0697b8e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010d7fb:	b8 94 e5 10 f0       	mov    $0xf010e594,%eax
f010d800:	66 a3 a0 7b 69 f0    	mov    %ax,0xf0697ba0
f010d806:	66 c7 05 a2 7b 69 f0 	movw   $0x8,0xf0697ba2
f010d80d:	08 00 
f010d80f:	a0 a4 7b 69 f0       	mov    0xf0697ba4,%al
f010d814:	83 e0 e0             	and    $0xffffffe0,%eax
f010d817:	a2 a4 7b 69 f0       	mov    %al,0xf0697ba4
f010d81c:	a0 a4 7b 69 f0       	mov    0xf0697ba4,%al
f010d821:	83 e0 1f             	and    $0x1f,%eax
f010d824:	a2 a4 7b 69 f0       	mov    %al,0xf0697ba4
f010d829:	a0 a5 7b 69 f0       	mov    0xf0697ba5,%al
f010d82e:	83 e0 f0             	and    $0xfffffff0,%eax
f010d831:	83 c8 0e             	or     $0xe,%eax
f010d834:	a2 a5 7b 69 f0       	mov    %al,0xf0697ba5
f010d839:	a0 a5 7b 69 f0       	mov    0xf0697ba5,%al
f010d83e:	83 e0 ef             	and    $0xffffffef,%eax
f010d841:	a2 a5 7b 69 f0       	mov    %al,0xf0697ba5
f010d846:	a0 a5 7b 69 f0       	mov    0xf0697ba5,%al
f010d84b:	83 c8 60             	or     $0x60,%eax
f010d84e:	a2 a5 7b 69 f0       	mov    %al,0xf0697ba5
f010d853:	a0 a5 7b 69 f0       	mov    0xf0697ba5,%al
f010d858:	83 c8 80             	or     $0xffffff80,%eax
f010d85b:	a2 a5 7b 69 f0       	mov    %al,0xf0697ba5
f010d860:	b8 94 e5 10 f0       	mov    $0xf010e594,%eax
f010d865:	c1 e8 10             	shr    $0x10,%eax
f010d868:	66 a3 a6 7b 69 f0    	mov    %ax,0xf0697ba6
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010d86e:	b8 9a e5 10 f0       	mov    $0xf010e59a,%eax
f010d873:	66 a3 a8 7b 69 f0    	mov    %ax,0xf0697ba8
f010d879:	66 c7 05 aa 7b 69 f0 	movw   $0x8,0xf0697baa
f010d880:	08 00 
f010d882:	a0 ac 7b 69 f0       	mov    0xf0697bac,%al
f010d887:	83 e0 e0             	and    $0xffffffe0,%eax
f010d88a:	a2 ac 7b 69 f0       	mov    %al,0xf0697bac
f010d88f:	a0 ac 7b 69 f0       	mov    0xf0697bac,%al
f010d894:	83 e0 1f             	and    $0x1f,%eax
f010d897:	a2 ac 7b 69 f0       	mov    %al,0xf0697bac
f010d89c:	a0 ad 7b 69 f0       	mov    0xf0697bad,%al
f010d8a1:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8a4:	83 c8 0e             	or     $0xe,%eax
f010d8a7:	a2 ad 7b 69 f0       	mov    %al,0xf0697bad
f010d8ac:	a0 ad 7b 69 f0       	mov    0xf0697bad,%al
f010d8b1:	83 e0 ef             	and    $0xffffffef,%eax
f010d8b4:	a2 ad 7b 69 f0       	mov    %al,0xf0697bad
f010d8b9:	a0 ad 7b 69 f0       	mov    0xf0697bad,%al
f010d8be:	83 c8 60             	or     $0x60,%eax
f010d8c1:	a2 ad 7b 69 f0       	mov    %al,0xf0697bad
f010d8c6:	a0 ad 7b 69 f0       	mov    0xf0697bad,%al
f010d8cb:	83 c8 80             	or     $0xffffff80,%eax
f010d8ce:	a2 ad 7b 69 f0       	mov    %al,0xf0697bad
f010d8d3:	b8 9a e5 10 f0       	mov    $0xf010e59a,%eax
f010d8d8:	c1 e8 10             	shr    $0x10,%eax
f010d8db:	66 a3 ae 7b 69 f0    	mov    %ax,0xf0697bae
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010d8e1:	b8 9e e5 10 f0       	mov    $0xf010e59e,%eax
f010d8e6:	66 a3 b0 7b 69 f0    	mov    %ax,0xf0697bb0
f010d8ec:	66 c7 05 b2 7b 69 f0 	movw   $0x8,0xf0697bb2
f010d8f3:	08 00 
f010d8f5:	a0 b4 7b 69 f0       	mov    0xf0697bb4,%al
f010d8fa:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8fd:	a2 b4 7b 69 f0       	mov    %al,0xf0697bb4
f010d902:	a0 b4 7b 69 f0       	mov    0xf0697bb4,%al
f010d907:	83 e0 1f             	and    $0x1f,%eax
f010d90a:	a2 b4 7b 69 f0       	mov    %al,0xf0697bb4
f010d90f:	a0 b5 7b 69 f0       	mov    0xf0697bb5,%al
f010d914:	83 e0 f0             	and    $0xfffffff0,%eax
f010d917:	83 c8 0e             	or     $0xe,%eax
f010d91a:	a2 b5 7b 69 f0       	mov    %al,0xf0697bb5
f010d91f:	a0 b5 7b 69 f0       	mov    0xf0697bb5,%al
f010d924:	83 e0 ef             	and    $0xffffffef,%eax
f010d927:	a2 b5 7b 69 f0       	mov    %al,0xf0697bb5
f010d92c:	a0 b5 7b 69 f0       	mov    0xf0697bb5,%al
f010d931:	83 c8 60             	or     $0x60,%eax
f010d934:	a2 b5 7b 69 f0       	mov    %al,0xf0697bb5
f010d939:	a0 b5 7b 69 f0       	mov    0xf0697bb5,%al
f010d93e:	83 c8 80             	or     $0xffffff80,%eax
f010d941:	a2 b5 7b 69 f0       	mov    %al,0xf0697bb5
f010d946:	b8 9e e5 10 f0       	mov    $0xf010e59e,%eax
f010d94b:	c1 e8 10             	shr    $0x10,%eax
f010d94e:	66 a3 b6 7b 69 f0    	mov    %ax,0xf0697bb6
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010d954:	b8 a4 e5 10 f0       	mov    $0xf010e5a4,%eax
f010d959:	66 a3 b8 7b 69 f0    	mov    %ax,0xf0697bb8
f010d95f:	66 c7 05 ba 7b 69 f0 	movw   $0x8,0xf0697bba
f010d966:	08 00 
f010d968:	a0 bc 7b 69 f0       	mov    0xf0697bbc,%al
f010d96d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d970:	a2 bc 7b 69 f0       	mov    %al,0xf0697bbc
f010d975:	a0 bc 7b 69 f0       	mov    0xf0697bbc,%al
f010d97a:	83 e0 1f             	and    $0x1f,%eax
f010d97d:	a2 bc 7b 69 f0       	mov    %al,0xf0697bbc
f010d982:	a0 bd 7b 69 f0       	mov    0xf0697bbd,%al
f010d987:	83 e0 f0             	and    $0xfffffff0,%eax
f010d98a:	83 c8 0e             	or     $0xe,%eax
f010d98d:	a2 bd 7b 69 f0       	mov    %al,0xf0697bbd
f010d992:	a0 bd 7b 69 f0       	mov    0xf0697bbd,%al
f010d997:	83 e0 ef             	and    $0xffffffef,%eax
f010d99a:	a2 bd 7b 69 f0       	mov    %al,0xf0697bbd
f010d99f:	a0 bd 7b 69 f0       	mov    0xf0697bbd,%al
f010d9a4:	83 c8 60             	or     $0x60,%eax
f010d9a7:	a2 bd 7b 69 f0       	mov    %al,0xf0697bbd
f010d9ac:	a0 bd 7b 69 f0       	mov    0xf0697bbd,%al
f010d9b1:	83 c8 80             	or     $0xffffff80,%eax
f010d9b4:	a2 bd 7b 69 f0       	mov    %al,0xf0697bbd
f010d9b9:	b8 a4 e5 10 f0       	mov    $0xf010e5a4,%eax
f010d9be:	c1 e8 10             	shr    $0x10,%eax
f010d9c1:	66 a3 be 7b 69 f0    	mov    %ax,0xf0697bbe

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010d9c7:	b8 aa e5 10 f0       	mov    $0xf010e5aa,%eax
f010d9cc:	66 a3 30 7c 69 f0    	mov    %ax,0xf0697c30
f010d9d2:	66 c7 05 32 7c 69 f0 	movw   $0x8,0xf0697c32
f010d9d9:	08 00 
f010d9db:	a0 34 7c 69 f0       	mov    0xf0697c34,%al
f010d9e0:	83 e0 e0             	and    $0xffffffe0,%eax
f010d9e3:	a2 34 7c 69 f0       	mov    %al,0xf0697c34
f010d9e8:	a0 34 7c 69 f0       	mov    0xf0697c34,%al
f010d9ed:	83 e0 1f             	and    $0x1f,%eax
f010d9f0:	a2 34 7c 69 f0       	mov    %al,0xf0697c34
f010d9f5:	a0 35 7c 69 f0       	mov    0xf0697c35,%al
f010d9fa:	83 e0 f0             	and    $0xfffffff0,%eax
f010d9fd:	83 c8 0e             	or     $0xe,%eax
f010da00:	a2 35 7c 69 f0       	mov    %al,0xf0697c35
f010da05:	a0 35 7c 69 f0       	mov    0xf0697c35,%al
f010da0a:	83 e0 ef             	and    $0xffffffef,%eax
f010da0d:	a2 35 7c 69 f0       	mov    %al,0xf0697c35
f010da12:	a0 35 7c 69 f0       	mov    0xf0697c35,%al
f010da17:	83 c8 60             	or     $0x60,%eax
f010da1a:	a2 35 7c 69 f0       	mov    %al,0xf0697c35
f010da1f:	a0 35 7c 69 f0       	mov    0xf0697c35,%al
f010da24:	83 c8 80             	or     $0xffffff80,%eax
f010da27:	a2 35 7c 69 f0       	mov    %al,0xf0697c35
f010da2c:	b8 aa e5 10 f0       	mov    $0xf010e5aa,%eax
f010da31:	c1 e8 10             	shr    $0x10,%eax
f010da34:	66 a3 36 7c 69 f0    	mov    %ax,0xf0697c36
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010da3a:	b8 b0 e5 10 f0       	mov    $0xf010e5b0,%eax
f010da3f:	66 a3 38 7c 69 f0    	mov    %ax,0xf0697c38
f010da45:	66 c7 05 3a 7c 69 f0 	movw   $0x8,0xf0697c3a
f010da4c:	08 00 
f010da4e:	a0 3c 7c 69 f0       	mov    0xf0697c3c,%al
f010da53:	83 e0 e0             	and    $0xffffffe0,%eax
f010da56:	a2 3c 7c 69 f0       	mov    %al,0xf0697c3c
f010da5b:	a0 3c 7c 69 f0       	mov    0xf0697c3c,%al
f010da60:	83 e0 1f             	and    $0x1f,%eax
f010da63:	a2 3c 7c 69 f0       	mov    %al,0xf0697c3c
f010da68:	a0 3d 7c 69 f0       	mov    0xf0697c3d,%al
f010da6d:	83 e0 f0             	and    $0xfffffff0,%eax
f010da70:	83 c8 0e             	or     $0xe,%eax
f010da73:	a2 3d 7c 69 f0       	mov    %al,0xf0697c3d
f010da78:	a0 3d 7c 69 f0       	mov    0xf0697c3d,%al
f010da7d:	83 e0 ef             	and    $0xffffffef,%eax
f010da80:	a2 3d 7c 69 f0       	mov    %al,0xf0697c3d
f010da85:	a0 3d 7c 69 f0       	mov    0xf0697c3d,%al
f010da8a:	83 c8 60             	or     $0x60,%eax
f010da8d:	a2 3d 7c 69 f0       	mov    %al,0xf0697c3d
f010da92:	a0 3d 7c 69 f0       	mov    0xf0697c3d,%al
f010da97:	83 c8 80             	or     $0xffffff80,%eax
f010da9a:	a2 3d 7c 69 f0       	mov    %al,0xf0697c3d
f010da9f:	b8 b0 e5 10 f0       	mov    $0xf010e5b0,%eax
f010daa4:	c1 e8 10             	shr    $0x10,%eax
f010daa7:	66 a3 3e 7c 69 f0    	mov    %ax,0xf0697c3e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010daad:	b8 b6 e5 10 f0       	mov    $0xf010e5b6,%eax
f010dab2:	66 a3 40 7c 69 f0    	mov    %ax,0xf0697c40
f010dab8:	66 c7 05 42 7c 69 f0 	movw   $0x8,0xf0697c42
f010dabf:	08 00 
f010dac1:	a0 44 7c 69 f0       	mov    0xf0697c44,%al
f010dac6:	83 e0 e0             	and    $0xffffffe0,%eax
f010dac9:	a2 44 7c 69 f0       	mov    %al,0xf0697c44
f010dace:	a0 44 7c 69 f0       	mov    0xf0697c44,%al
f010dad3:	83 e0 1f             	and    $0x1f,%eax
f010dad6:	a2 44 7c 69 f0       	mov    %al,0xf0697c44
f010dadb:	a0 45 7c 69 f0       	mov    0xf0697c45,%al
f010dae0:	83 e0 f0             	and    $0xfffffff0,%eax
f010dae3:	83 c8 0e             	or     $0xe,%eax
f010dae6:	a2 45 7c 69 f0       	mov    %al,0xf0697c45
f010daeb:	a0 45 7c 69 f0       	mov    0xf0697c45,%al
f010daf0:	83 e0 ef             	and    $0xffffffef,%eax
f010daf3:	a2 45 7c 69 f0       	mov    %al,0xf0697c45
f010daf8:	a0 45 7c 69 f0       	mov    0xf0697c45,%al
f010dafd:	83 c8 60             	or     $0x60,%eax
f010db00:	a2 45 7c 69 f0       	mov    %al,0xf0697c45
f010db05:	a0 45 7c 69 f0       	mov    0xf0697c45,%al
f010db0a:	83 c8 80             	or     $0xffffff80,%eax
f010db0d:	a2 45 7c 69 f0       	mov    %al,0xf0697c45
f010db12:	b8 b6 e5 10 f0       	mov    $0xf010e5b6,%eax
f010db17:	c1 e8 10             	shr    $0x10,%eax
f010db1a:	66 a3 46 7c 69 f0    	mov    %ax,0xf0697c46
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010db20:	b8 bc e5 10 f0       	mov    $0xf010e5bc,%eax
f010db25:	66 a3 48 7c 69 f0    	mov    %ax,0xf0697c48
f010db2b:	66 c7 05 4a 7c 69 f0 	movw   $0x8,0xf0697c4a
f010db32:	08 00 
f010db34:	a0 4c 7c 69 f0       	mov    0xf0697c4c,%al
f010db39:	83 e0 e0             	and    $0xffffffe0,%eax
f010db3c:	a2 4c 7c 69 f0       	mov    %al,0xf0697c4c
f010db41:	a0 4c 7c 69 f0       	mov    0xf0697c4c,%al
f010db46:	83 e0 1f             	and    $0x1f,%eax
f010db49:	a2 4c 7c 69 f0       	mov    %al,0xf0697c4c
f010db4e:	a0 4d 7c 69 f0       	mov    0xf0697c4d,%al
f010db53:	83 e0 f0             	and    $0xfffffff0,%eax
f010db56:	83 c8 0e             	or     $0xe,%eax
f010db59:	a2 4d 7c 69 f0       	mov    %al,0xf0697c4d
f010db5e:	a0 4d 7c 69 f0       	mov    0xf0697c4d,%al
f010db63:	83 e0 ef             	and    $0xffffffef,%eax
f010db66:	a2 4d 7c 69 f0       	mov    %al,0xf0697c4d
f010db6b:	a0 4d 7c 69 f0       	mov    0xf0697c4d,%al
f010db70:	83 c8 60             	or     $0x60,%eax
f010db73:	a2 4d 7c 69 f0       	mov    %al,0xf0697c4d
f010db78:	a0 4d 7c 69 f0       	mov    0xf0697c4d,%al
f010db7d:	83 c8 80             	or     $0xffffff80,%eax
f010db80:	a2 4d 7c 69 f0       	mov    %al,0xf0697c4d
f010db85:	b8 bc e5 10 f0       	mov    $0xf010e5bc,%eax
f010db8a:	c1 e8 10             	shr    $0x10,%eax
f010db8d:	66 a3 4e 7c 69 f0    	mov    %ax,0xf0697c4e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010db93:	b8 c2 e5 10 f0       	mov    $0xf010e5c2,%eax
f010db98:	66 a3 50 7c 69 f0    	mov    %ax,0xf0697c50
f010db9e:	66 c7 05 52 7c 69 f0 	movw   $0x8,0xf0697c52
f010dba5:	08 00 
f010dba7:	a0 54 7c 69 f0       	mov    0xf0697c54,%al
f010dbac:	83 e0 e0             	and    $0xffffffe0,%eax
f010dbaf:	a2 54 7c 69 f0       	mov    %al,0xf0697c54
f010dbb4:	a0 54 7c 69 f0       	mov    0xf0697c54,%al
f010dbb9:	83 e0 1f             	and    $0x1f,%eax
f010dbbc:	a2 54 7c 69 f0       	mov    %al,0xf0697c54
f010dbc1:	a0 55 7c 69 f0       	mov    0xf0697c55,%al
f010dbc6:	83 e0 f0             	and    $0xfffffff0,%eax
f010dbc9:	83 c8 0e             	or     $0xe,%eax
f010dbcc:	a2 55 7c 69 f0       	mov    %al,0xf0697c55
f010dbd1:	a0 55 7c 69 f0       	mov    0xf0697c55,%al
f010dbd6:	83 e0 ef             	and    $0xffffffef,%eax
f010dbd9:	a2 55 7c 69 f0       	mov    %al,0xf0697c55
f010dbde:	a0 55 7c 69 f0       	mov    0xf0697c55,%al
f010dbe3:	83 c8 60             	or     $0x60,%eax
f010dbe6:	a2 55 7c 69 f0       	mov    %al,0xf0697c55
f010dbeb:	a0 55 7c 69 f0       	mov    0xf0697c55,%al
f010dbf0:	83 c8 80             	or     $0xffffff80,%eax
f010dbf3:	a2 55 7c 69 f0       	mov    %al,0xf0697c55
f010dbf8:	b8 c2 e5 10 f0       	mov    $0xf010e5c2,%eax
f010dbfd:	c1 e8 10             	shr    $0x10,%eax
f010dc00:	66 a3 56 7c 69 f0    	mov    %ax,0xf0697c56
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010dc06:	b8 c8 e5 10 f0       	mov    $0xf010e5c8,%eax
f010dc0b:	66 a3 58 7c 69 f0    	mov    %ax,0xf0697c58
f010dc11:	66 c7 05 5a 7c 69 f0 	movw   $0x8,0xf0697c5a
f010dc18:	08 00 
f010dc1a:	a0 5c 7c 69 f0       	mov    0xf0697c5c,%al
f010dc1f:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc22:	a2 5c 7c 69 f0       	mov    %al,0xf0697c5c
f010dc27:	a0 5c 7c 69 f0       	mov    0xf0697c5c,%al
f010dc2c:	83 e0 1f             	and    $0x1f,%eax
f010dc2f:	a2 5c 7c 69 f0       	mov    %al,0xf0697c5c
f010dc34:	a0 5d 7c 69 f0       	mov    0xf0697c5d,%al
f010dc39:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc3c:	83 c8 0e             	or     $0xe,%eax
f010dc3f:	a2 5d 7c 69 f0       	mov    %al,0xf0697c5d
f010dc44:	a0 5d 7c 69 f0       	mov    0xf0697c5d,%al
f010dc49:	83 e0 ef             	and    $0xffffffef,%eax
f010dc4c:	a2 5d 7c 69 f0       	mov    %al,0xf0697c5d
f010dc51:	a0 5d 7c 69 f0       	mov    0xf0697c5d,%al
f010dc56:	83 c8 60             	or     $0x60,%eax
f010dc59:	a2 5d 7c 69 f0       	mov    %al,0xf0697c5d
f010dc5e:	a0 5d 7c 69 f0       	mov    0xf0697c5d,%al
f010dc63:	83 c8 80             	or     $0xffffff80,%eax
f010dc66:	a2 5d 7c 69 f0       	mov    %al,0xf0697c5d
f010dc6b:	b8 c8 e5 10 f0       	mov    $0xf010e5c8,%eax
f010dc70:	c1 e8 10             	shr    $0x10,%eax
f010dc73:	66 a3 5e 7c 69 f0    	mov    %ax,0xf0697c5e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010dc79:	b8 ce e5 10 f0       	mov    $0xf010e5ce,%eax
f010dc7e:	66 a3 60 7c 69 f0    	mov    %ax,0xf0697c60
f010dc84:	66 c7 05 62 7c 69 f0 	movw   $0x8,0xf0697c62
f010dc8b:	08 00 
f010dc8d:	a0 64 7c 69 f0       	mov    0xf0697c64,%al
f010dc92:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc95:	a2 64 7c 69 f0       	mov    %al,0xf0697c64
f010dc9a:	a0 64 7c 69 f0       	mov    0xf0697c64,%al
f010dc9f:	83 e0 1f             	and    $0x1f,%eax
f010dca2:	a2 64 7c 69 f0       	mov    %al,0xf0697c64
f010dca7:	a0 65 7c 69 f0       	mov    0xf0697c65,%al
f010dcac:	83 e0 f0             	and    $0xfffffff0,%eax
f010dcaf:	83 c8 0e             	or     $0xe,%eax
f010dcb2:	a2 65 7c 69 f0       	mov    %al,0xf0697c65
f010dcb7:	a0 65 7c 69 f0       	mov    0xf0697c65,%al
f010dcbc:	83 e0 ef             	and    $0xffffffef,%eax
f010dcbf:	a2 65 7c 69 f0       	mov    %al,0xf0697c65
f010dcc4:	a0 65 7c 69 f0       	mov    0xf0697c65,%al
f010dcc9:	83 c8 60             	or     $0x60,%eax
f010dccc:	a2 65 7c 69 f0       	mov    %al,0xf0697c65
f010dcd1:	a0 65 7c 69 f0       	mov    0xf0697c65,%al
f010dcd6:	83 c8 80             	or     $0xffffff80,%eax
f010dcd9:	a2 65 7c 69 f0       	mov    %al,0xf0697c65
f010dcde:	b8 ce e5 10 f0       	mov    $0xf010e5ce,%eax
f010dce3:	c1 e8 10             	shr    $0x10,%eax
f010dce6:	66 a3 66 7c 69 f0    	mov    %ax,0xf0697c66
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010dcec:	b8 d4 e5 10 f0       	mov    $0xf010e5d4,%eax
f010dcf1:	66 a3 68 7c 69 f0    	mov    %ax,0xf0697c68
f010dcf7:	66 c7 05 6a 7c 69 f0 	movw   $0x8,0xf0697c6a
f010dcfe:	08 00 
f010dd00:	a0 6c 7c 69 f0       	mov    0xf0697c6c,%al
f010dd05:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd08:	a2 6c 7c 69 f0       	mov    %al,0xf0697c6c
f010dd0d:	a0 6c 7c 69 f0       	mov    0xf0697c6c,%al
f010dd12:	83 e0 1f             	and    $0x1f,%eax
f010dd15:	a2 6c 7c 69 f0       	mov    %al,0xf0697c6c
f010dd1a:	a0 6d 7c 69 f0       	mov    0xf0697c6d,%al
f010dd1f:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd22:	83 c8 0e             	or     $0xe,%eax
f010dd25:	a2 6d 7c 69 f0       	mov    %al,0xf0697c6d
f010dd2a:	a0 6d 7c 69 f0       	mov    0xf0697c6d,%al
f010dd2f:	83 e0 ef             	and    $0xffffffef,%eax
f010dd32:	a2 6d 7c 69 f0       	mov    %al,0xf0697c6d
f010dd37:	a0 6d 7c 69 f0       	mov    0xf0697c6d,%al
f010dd3c:	83 c8 60             	or     $0x60,%eax
f010dd3f:	a2 6d 7c 69 f0       	mov    %al,0xf0697c6d
f010dd44:	a0 6d 7c 69 f0       	mov    0xf0697c6d,%al
f010dd49:	83 c8 80             	or     $0xffffff80,%eax
f010dd4c:	a2 6d 7c 69 f0       	mov    %al,0xf0697c6d
f010dd51:	b8 d4 e5 10 f0       	mov    $0xf010e5d4,%eax
f010dd56:	c1 e8 10             	shr    $0x10,%eax
f010dd59:	66 a3 6e 7c 69 f0    	mov    %ax,0xf0697c6e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010dd5f:	b8 da e5 10 f0       	mov    $0xf010e5da,%eax
f010dd64:	66 a3 70 7c 69 f0    	mov    %ax,0xf0697c70
f010dd6a:	66 c7 05 72 7c 69 f0 	movw   $0x8,0xf0697c72
f010dd71:	08 00 
f010dd73:	a0 74 7c 69 f0       	mov    0xf0697c74,%al
f010dd78:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd7b:	a2 74 7c 69 f0       	mov    %al,0xf0697c74
f010dd80:	a0 74 7c 69 f0       	mov    0xf0697c74,%al
f010dd85:	83 e0 1f             	and    $0x1f,%eax
f010dd88:	a2 74 7c 69 f0       	mov    %al,0xf0697c74
f010dd8d:	a0 75 7c 69 f0       	mov    0xf0697c75,%al
f010dd92:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd95:	83 c8 0e             	or     $0xe,%eax
f010dd98:	a2 75 7c 69 f0       	mov    %al,0xf0697c75
f010dd9d:	a0 75 7c 69 f0       	mov    0xf0697c75,%al
f010dda2:	83 e0 ef             	and    $0xffffffef,%eax
f010dda5:	a2 75 7c 69 f0       	mov    %al,0xf0697c75
f010ddaa:	a0 75 7c 69 f0       	mov    0xf0697c75,%al
f010ddaf:	83 c8 60             	or     $0x60,%eax
f010ddb2:	a2 75 7c 69 f0       	mov    %al,0xf0697c75
f010ddb7:	a0 75 7c 69 f0       	mov    0xf0697c75,%al
f010ddbc:	83 c8 80             	or     $0xffffff80,%eax
f010ddbf:	a2 75 7c 69 f0       	mov    %al,0xf0697c75
f010ddc4:	b8 da e5 10 f0       	mov    $0xf010e5da,%eax
f010ddc9:	c1 e8 10             	shr    $0x10,%eax
f010ddcc:	66 a3 76 7c 69 f0    	mov    %ax,0xf0697c76
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010ddd2:	b8 e0 e5 10 f0       	mov    $0xf010e5e0,%eax
f010ddd7:	66 a3 78 7c 69 f0    	mov    %ax,0xf0697c78
f010dddd:	66 c7 05 7a 7c 69 f0 	movw   $0x8,0xf0697c7a
f010dde4:	08 00 
f010dde6:	a0 7c 7c 69 f0       	mov    0xf0697c7c,%al
f010ddeb:	83 e0 e0             	and    $0xffffffe0,%eax
f010ddee:	a2 7c 7c 69 f0       	mov    %al,0xf0697c7c
f010ddf3:	a0 7c 7c 69 f0       	mov    0xf0697c7c,%al
f010ddf8:	83 e0 1f             	and    $0x1f,%eax
f010ddfb:	a2 7c 7c 69 f0       	mov    %al,0xf0697c7c
f010de00:	a0 7d 7c 69 f0       	mov    0xf0697c7d,%al
f010de05:	83 e0 f0             	and    $0xfffffff0,%eax
f010de08:	83 c8 0e             	or     $0xe,%eax
f010de0b:	a2 7d 7c 69 f0       	mov    %al,0xf0697c7d
f010de10:	a0 7d 7c 69 f0       	mov    0xf0697c7d,%al
f010de15:	83 e0 ef             	and    $0xffffffef,%eax
f010de18:	a2 7d 7c 69 f0       	mov    %al,0xf0697c7d
f010de1d:	a0 7d 7c 69 f0       	mov    0xf0697c7d,%al
f010de22:	83 c8 60             	or     $0x60,%eax
f010de25:	a2 7d 7c 69 f0       	mov    %al,0xf0697c7d
f010de2a:	a0 7d 7c 69 f0       	mov    0xf0697c7d,%al
f010de2f:	83 c8 80             	or     $0xffffff80,%eax
f010de32:	a2 7d 7c 69 f0       	mov    %al,0xf0697c7d
f010de37:	b8 e0 e5 10 f0       	mov    $0xf010e5e0,%eax
f010de3c:	c1 e8 10             	shr    $0x10,%eax
f010de3f:	66 a3 7e 7c 69 f0    	mov    %ax,0xf0697c7e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010de45:	b8 e6 e5 10 f0       	mov    $0xf010e5e6,%eax
f010de4a:	66 a3 80 7c 69 f0    	mov    %ax,0xf0697c80
f010de50:	66 c7 05 82 7c 69 f0 	movw   $0x8,0xf0697c82
f010de57:	08 00 
f010de59:	a0 84 7c 69 f0       	mov    0xf0697c84,%al
f010de5e:	83 e0 e0             	and    $0xffffffe0,%eax
f010de61:	a2 84 7c 69 f0       	mov    %al,0xf0697c84
f010de66:	a0 84 7c 69 f0       	mov    0xf0697c84,%al
f010de6b:	83 e0 1f             	and    $0x1f,%eax
f010de6e:	a2 84 7c 69 f0       	mov    %al,0xf0697c84
f010de73:	a0 85 7c 69 f0       	mov    0xf0697c85,%al
f010de78:	83 e0 f0             	and    $0xfffffff0,%eax
f010de7b:	83 c8 0e             	or     $0xe,%eax
f010de7e:	a2 85 7c 69 f0       	mov    %al,0xf0697c85
f010de83:	a0 85 7c 69 f0       	mov    0xf0697c85,%al
f010de88:	83 e0 ef             	and    $0xffffffef,%eax
f010de8b:	a2 85 7c 69 f0       	mov    %al,0xf0697c85
f010de90:	a0 85 7c 69 f0       	mov    0xf0697c85,%al
f010de95:	83 c8 60             	or     $0x60,%eax
f010de98:	a2 85 7c 69 f0       	mov    %al,0xf0697c85
f010de9d:	a0 85 7c 69 f0       	mov    0xf0697c85,%al
f010dea2:	83 c8 80             	or     $0xffffff80,%eax
f010dea5:	a2 85 7c 69 f0       	mov    %al,0xf0697c85
f010deaa:	b8 e6 e5 10 f0       	mov    $0xf010e5e6,%eax
f010deaf:	c1 e8 10             	shr    $0x10,%eax
f010deb2:	66 a3 86 7c 69 f0    	mov    %ax,0xf0697c86
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010deb8:	b8 ec e5 10 f0       	mov    $0xf010e5ec,%eax
f010debd:	66 a3 88 7c 69 f0    	mov    %ax,0xf0697c88
f010dec3:	66 c7 05 8a 7c 69 f0 	movw   $0x8,0xf0697c8a
f010deca:	08 00 
f010decc:	a0 8c 7c 69 f0       	mov    0xf0697c8c,%al
f010ded1:	83 e0 e0             	and    $0xffffffe0,%eax
f010ded4:	a2 8c 7c 69 f0       	mov    %al,0xf0697c8c
f010ded9:	a0 8c 7c 69 f0       	mov    0xf0697c8c,%al
f010dede:	83 e0 1f             	and    $0x1f,%eax
f010dee1:	a2 8c 7c 69 f0       	mov    %al,0xf0697c8c
f010dee6:	a0 8d 7c 69 f0       	mov    0xf0697c8d,%al
f010deeb:	83 e0 f0             	and    $0xfffffff0,%eax
f010deee:	83 c8 0e             	or     $0xe,%eax
f010def1:	a2 8d 7c 69 f0       	mov    %al,0xf0697c8d
f010def6:	a0 8d 7c 69 f0       	mov    0xf0697c8d,%al
f010defb:	83 e0 ef             	and    $0xffffffef,%eax
f010defe:	a2 8d 7c 69 f0       	mov    %al,0xf0697c8d
f010df03:	a0 8d 7c 69 f0       	mov    0xf0697c8d,%al
f010df08:	83 c8 60             	or     $0x60,%eax
f010df0b:	a2 8d 7c 69 f0       	mov    %al,0xf0697c8d
f010df10:	a0 8d 7c 69 f0       	mov    0xf0697c8d,%al
f010df15:	83 c8 80             	or     $0xffffff80,%eax
f010df18:	a2 8d 7c 69 f0       	mov    %al,0xf0697c8d
f010df1d:	b8 ec e5 10 f0       	mov    $0xf010e5ec,%eax
f010df22:	c1 e8 10             	shr    $0x10,%eax
f010df25:	66 a3 8e 7c 69 f0    	mov    %ax,0xf0697c8e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010df2b:	b8 f2 e5 10 f0       	mov    $0xf010e5f2,%eax
f010df30:	66 a3 90 7c 69 f0    	mov    %ax,0xf0697c90
f010df36:	66 c7 05 92 7c 69 f0 	movw   $0x8,0xf0697c92
f010df3d:	08 00 
f010df3f:	a0 94 7c 69 f0       	mov    0xf0697c94,%al
f010df44:	83 e0 e0             	and    $0xffffffe0,%eax
f010df47:	a2 94 7c 69 f0       	mov    %al,0xf0697c94
f010df4c:	a0 94 7c 69 f0       	mov    0xf0697c94,%al
f010df51:	83 e0 1f             	and    $0x1f,%eax
f010df54:	a2 94 7c 69 f0       	mov    %al,0xf0697c94
f010df59:	a0 95 7c 69 f0       	mov    0xf0697c95,%al
f010df5e:	83 e0 f0             	and    $0xfffffff0,%eax
f010df61:	83 c8 0e             	or     $0xe,%eax
f010df64:	a2 95 7c 69 f0       	mov    %al,0xf0697c95
f010df69:	a0 95 7c 69 f0       	mov    0xf0697c95,%al
f010df6e:	83 e0 ef             	and    $0xffffffef,%eax
f010df71:	a2 95 7c 69 f0       	mov    %al,0xf0697c95
f010df76:	a0 95 7c 69 f0       	mov    0xf0697c95,%al
f010df7b:	83 c8 60             	or     $0x60,%eax
f010df7e:	a2 95 7c 69 f0       	mov    %al,0xf0697c95
f010df83:	a0 95 7c 69 f0       	mov    0xf0697c95,%al
f010df88:	83 c8 80             	or     $0xffffff80,%eax
f010df8b:	a2 95 7c 69 f0       	mov    %al,0xf0697c95
f010df90:	b8 f2 e5 10 f0       	mov    $0xf010e5f2,%eax
f010df95:	c1 e8 10             	shr    $0x10,%eax
f010df98:	66 a3 96 7c 69 f0    	mov    %ax,0xf0697c96
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010df9e:	b8 f8 e5 10 f0       	mov    $0xf010e5f8,%eax
f010dfa3:	66 a3 98 7c 69 f0    	mov    %ax,0xf0697c98
f010dfa9:	66 c7 05 9a 7c 69 f0 	movw   $0x8,0xf0697c9a
f010dfb0:	08 00 
f010dfb2:	a0 9c 7c 69 f0       	mov    0xf0697c9c,%al
f010dfb7:	83 e0 e0             	and    $0xffffffe0,%eax
f010dfba:	a2 9c 7c 69 f0       	mov    %al,0xf0697c9c
f010dfbf:	a0 9c 7c 69 f0       	mov    0xf0697c9c,%al
f010dfc4:	83 e0 1f             	and    $0x1f,%eax
f010dfc7:	a2 9c 7c 69 f0       	mov    %al,0xf0697c9c
f010dfcc:	a0 9d 7c 69 f0       	mov    0xf0697c9d,%al
f010dfd1:	83 e0 f0             	and    $0xfffffff0,%eax
f010dfd4:	83 c8 0e             	or     $0xe,%eax
f010dfd7:	a2 9d 7c 69 f0       	mov    %al,0xf0697c9d
f010dfdc:	a0 9d 7c 69 f0       	mov    0xf0697c9d,%al
f010dfe1:	83 e0 ef             	and    $0xffffffef,%eax
f010dfe4:	a2 9d 7c 69 f0       	mov    %al,0xf0697c9d
f010dfe9:	a0 9d 7c 69 f0       	mov    0xf0697c9d,%al
f010dfee:	83 c8 60             	or     $0x60,%eax
f010dff1:	a2 9d 7c 69 f0       	mov    %al,0xf0697c9d
f010dff6:	a0 9d 7c 69 f0       	mov    0xf0697c9d,%al
f010dffb:	83 c8 80             	or     $0xffffff80,%eax
f010dffe:	a2 9d 7c 69 f0       	mov    %al,0xf0697c9d
f010e003:	b8 f8 e5 10 f0       	mov    $0xf010e5f8,%eax
f010e008:	c1 e8 10             	shr    $0x10,%eax
f010e00b:	66 a3 9e 7c 69 f0    	mov    %ax,0xf0697c9e
f010e011:	c7 45 fc 20 7b 69 f0 	movl   $0xf0697b20,-0x4(%ebp)
f010e018:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010e01f:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e022:	48                   	dec    %eax
f010e023:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010e027:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e02a:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010e02e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e031:	c1 e8 10             	shr    $0x10,%eax
f010e034:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010e038:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010e03b:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010e03e:	90                   	nop
f010e03f:	c9                   	leave  
f010e040:	c3                   	ret    

f010e041 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010e041:	55                   	push   %ebp
f010e042:	89 e5                	mov    %esp,%ebp
f010e044:	53                   	push   %ebx
f010e045:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010e048:	83 ec 08             	sub    $0x8,%esp
f010e04b:	ff 75 08             	pushl  0x8(%ebp)
f010e04e:	68 be 72 12 f0       	push   $0xf01272be
f010e053:	e8 33 2f ff ff       	call   f0100f8b <cprintf>
f010e058:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010e05b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e05e:	83 ec 0c             	sub    $0xc,%esp
f010e061:	50                   	push   %eax
f010e062:	e8 fd 00 00 00       	call   f010e164 <print_regs>
f010e067:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010e06a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e06d:	8b 40 20             	mov    0x20(%eax),%eax
f010e070:	0f b7 c0             	movzwl %ax,%eax
f010e073:	83 ec 08             	sub    $0x8,%esp
f010e076:	50                   	push   %eax
f010e077:	68 d0 72 12 f0       	push   $0xf01272d0
f010e07c:	e8 0a 2f ff ff       	call   f0100f8b <cprintf>
f010e081:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010e084:	8b 45 08             	mov    0x8(%ebp),%eax
f010e087:	8b 40 24             	mov    0x24(%eax),%eax
f010e08a:	0f b7 c0             	movzwl %ax,%eax
f010e08d:	83 ec 08             	sub    $0x8,%esp
f010e090:	50                   	push   %eax
f010e091:	68 e3 72 12 f0       	push   $0xf01272e3
f010e096:	e8 f0 2e ff ff       	call   f0100f8b <cprintf>
f010e09b:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010e09e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0a1:	8b 58 28             	mov    0x28(%eax),%ebx
f010e0a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0a7:	8b 40 28             	mov    0x28(%eax),%eax
f010e0aa:	83 ec 0c             	sub    $0xc,%esp
f010e0ad:	50                   	push   %eax
f010e0ae:	e8 28 ee ff ff       	call   f010cedb <trapname>
f010e0b3:	83 c4 10             	add    $0x10,%esp
f010e0b6:	89 c2                	mov    %eax,%edx
f010e0b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0bb:	8b 40 28             	mov    0x28(%eax),%eax
f010e0be:	53                   	push   %ebx
f010e0bf:	52                   	push   %edx
f010e0c0:	50                   	push   %eax
f010e0c1:	68 f6 72 12 f0       	push   $0xf01272f6
f010e0c6:	e8 c0 2e ff ff       	call   f0100f8b <cprintf>
f010e0cb:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010e0ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0d1:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e0d4:	83 ec 08             	sub    $0x8,%esp
f010e0d7:	50                   	push   %eax
f010e0d8:	68 0d 73 12 f0       	push   $0xf012730d
f010e0dd:	e8 a9 2e ff ff       	call   f0100f8b <cprintf>
f010e0e2:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010e0e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0e8:	8b 40 30             	mov    0x30(%eax),%eax
f010e0eb:	83 ec 08             	sub    $0x8,%esp
f010e0ee:	50                   	push   %eax
f010e0ef:	68 1c 73 12 f0       	push   $0xf012731c
f010e0f4:	e8 92 2e ff ff       	call   f0100f8b <cprintf>
f010e0f9:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010e0fc:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0ff:	8b 40 34             	mov    0x34(%eax),%eax
f010e102:	0f b7 c0             	movzwl %ax,%eax
f010e105:	83 ec 08             	sub    $0x8,%esp
f010e108:	50                   	push   %eax
f010e109:	68 2b 73 12 f0       	push   $0xf012732b
f010e10e:	e8 78 2e ff ff       	call   f0100f8b <cprintf>
f010e113:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010e116:	8b 45 08             	mov    0x8(%ebp),%eax
f010e119:	8b 40 38             	mov    0x38(%eax),%eax
f010e11c:	83 ec 08             	sub    $0x8,%esp
f010e11f:	50                   	push   %eax
f010e120:	68 3e 73 12 f0       	push   $0xf012733e
f010e125:	e8 61 2e ff ff       	call   f0100f8b <cprintf>
f010e12a:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010e12d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e130:	8b 40 3c             	mov    0x3c(%eax),%eax
f010e133:	83 ec 08             	sub    $0x8,%esp
f010e136:	50                   	push   %eax
f010e137:	68 4d 73 12 f0       	push   $0xf012734d
f010e13c:	e8 4a 2e ff ff       	call   f0100f8b <cprintf>
f010e141:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010e144:	8b 45 08             	mov    0x8(%ebp),%eax
f010e147:	8b 40 40             	mov    0x40(%eax),%eax
f010e14a:	0f b7 c0             	movzwl %ax,%eax
f010e14d:	83 ec 08             	sub    $0x8,%esp
f010e150:	50                   	push   %eax
f010e151:	68 5c 73 12 f0       	push   $0xf012735c
f010e156:	e8 30 2e ff ff       	call   f0100f8b <cprintf>
f010e15b:	83 c4 10             	add    $0x10,%esp
}
f010e15e:	90                   	nop
f010e15f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e162:	c9                   	leave  
f010e163:	c3                   	ret    

f010e164 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010e164:	55                   	push   %ebp
f010e165:	89 e5                	mov    %esp,%ebp
f010e167:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010e16a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e16d:	8b 00                	mov    (%eax),%eax
f010e16f:	83 ec 08             	sub    $0x8,%esp
f010e172:	50                   	push   %eax
f010e173:	68 6f 73 12 f0       	push   $0xf012736f
f010e178:	e8 0e 2e ff ff       	call   f0100f8b <cprintf>
f010e17d:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010e180:	8b 45 08             	mov    0x8(%ebp),%eax
f010e183:	8b 40 04             	mov    0x4(%eax),%eax
f010e186:	83 ec 08             	sub    $0x8,%esp
f010e189:	50                   	push   %eax
f010e18a:	68 7e 73 12 f0       	push   $0xf012737e
f010e18f:	e8 f7 2d ff ff       	call   f0100f8b <cprintf>
f010e194:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010e197:	8b 45 08             	mov    0x8(%ebp),%eax
f010e19a:	8b 40 08             	mov    0x8(%eax),%eax
f010e19d:	83 ec 08             	sub    $0x8,%esp
f010e1a0:	50                   	push   %eax
f010e1a1:	68 8d 73 12 f0       	push   $0xf012738d
f010e1a6:	e8 e0 2d ff ff       	call   f0100f8b <cprintf>
f010e1ab:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010e1ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1b1:	8b 40 0c             	mov    0xc(%eax),%eax
f010e1b4:	83 ec 08             	sub    $0x8,%esp
f010e1b7:	50                   	push   %eax
f010e1b8:	68 9c 73 12 f0       	push   $0xf012739c
f010e1bd:	e8 c9 2d ff ff       	call   f0100f8b <cprintf>
f010e1c2:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010e1c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1c8:	8b 40 10             	mov    0x10(%eax),%eax
f010e1cb:	83 ec 08             	sub    $0x8,%esp
f010e1ce:	50                   	push   %eax
f010e1cf:	68 ab 73 12 f0       	push   $0xf01273ab
f010e1d4:	e8 b2 2d ff ff       	call   f0100f8b <cprintf>
f010e1d9:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010e1dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1df:	8b 40 14             	mov    0x14(%eax),%eax
f010e1e2:	83 ec 08             	sub    $0x8,%esp
f010e1e5:	50                   	push   %eax
f010e1e6:	68 ba 73 12 f0       	push   $0xf01273ba
f010e1eb:	e8 9b 2d ff ff       	call   f0100f8b <cprintf>
f010e1f0:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010e1f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1f6:	8b 40 18             	mov    0x18(%eax),%eax
f010e1f9:	83 ec 08             	sub    $0x8,%esp
f010e1fc:	50                   	push   %eax
f010e1fd:	68 c9 73 12 f0       	push   $0xf01273c9
f010e202:	e8 84 2d ff ff       	call   f0100f8b <cprintf>
f010e207:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010e20a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e20d:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e210:	83 ec 08             	sub    $0x8,%esp
f010e213:	50                   	push   %eax
f010e214:	68 d8 73 12 f0       	push   $0xf01273d8
f010e219:	e8 6d 2d ff ff       	call   f0100f8b <cprintf>
f010e21e:	83 c4 10             	add    $0x10,%esp
}
f010e221:	90                   	nop
f010e222:	c9                   	leave  
f010e223:	c3                   	ret    

f010e224 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010e224:	55                   	push   %ebp
f010e225:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010e227:	8b 45 08             	mov    0x8(%ebp),%eax
f010e22a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e22d:	89 14 85 20 83 69 f0 	mov    %edx,-0xf967ce0(,%eax,4)
}
f010e234:	90                   	nop
f010e235:	5d                   	pop    %ebp
f010e236:	c3                   	ret    

f010e237 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010e237:	55                   	push   %ebp
f010e238:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010e23a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e23d:	c7 04 85 20 83 69 f0 	movl   $0x0,-0xf967ce0(,%eax,4)
f010e244:	00 00 00 00 
}
f010e248:	90                   	nop
f010e249:	5d                   	pop    %ebp
f010e24a:	c3                   	ret    

f010e24b <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010e24b:	55                   	push   %ebp
f010e24c:	89 e5                	mov    %esp,%ebp
f010e24e:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010e251:	8b 45 08             	mov    0x8(%ebp),%eax
f010e254:	8b 40 28             	mov    0x28(%eax),%eax
f010e257:	83 e8 20             	sub    $0x20,%eax
f010e25a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010e25d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e260:	8b 04 85 20 83 69 f0 	mov    -0xf967ce0(,%eax,4),%eax
f010e267:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010e26a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e26e:	74 0e                	je     f010e27e <irq_dispatch+0x33>
	{
		handler(tf);
f010e270:	83 ec 0c             	sub    $0xc,%esp
f010e273:	ff 75 08             	pushl  0x8(%ebp)
f010e276:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e279:	ff d0                	call   *%eax
f010e27b:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010e27e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e281:	0f b6 c0             	movzbl %al,%eax
f010e284:	83 ec 0c             	sub    $0xc,%esp
f010e287:	50                   	push   %eax
f010e288:	e8 46 8e ff ff       	call   f01070d3 <pic_sendEOI>
f010e28d:	83 c4 10             	add    $0x10,%esp
}
f010e290:	90                   	nop
f010e291:	c9                   	leave  
f010e292:	c3                   	ret    

f010e293 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010e293:	55                   	push   %ebp
f010e294:	89 e5                	mov    %esp,%ebp
f010e296:	57                   	push   %edi
f010e297:	56                   	push   %esi
f010e298:	53                   	push   %ebx
f010e299:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010e29c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e29f:	8b 40 28             	mov    0x28(%eax),%eax
f010e2a2:	83 f8 0e             	cmp    $0xe,%eax
f010e2a5:	75 51                	jne    f010e2f8 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010e2a7:	a0 60 83 69 f0       	mov    0xf0698360,%al
f010e2ac:	84 c0                	test   %al,%al
f010e2ae:	74 1f                	je     f010e2cf <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010e2b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2b3:	8b 40 30             	mov    0x30(%eax),%eax
f010e2b6:	89 c2                	mov    %eax,%edx
f010e2b8:	a0 60 83 69 f0       	mov    0xf0698360,%al
f010e2bd:	0f b6 c0             	movzbl %al,%eax
f010e2c0:	01 d0                	add    %edx,%eax
f010e2c2:	89 c2                	mov    %eax,%edx
f010e2c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2c7:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010e2ca:	e9 0c 01 00 00       	jmp    f010e3db <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010e2cf:	83 ec 0c             	sub    $0xc,%esp
f010e2d2:	6a 01                	push   $0x1
f010e2d4:	e8 ee 12 00 00       	call   f010f5c7 <isPageReplacmentAlgorithmLRU>
f010e2d9:	83 c4 10             	add    $0x10,%esp
f010e2dc:	85 c0                	test   %eax,%eax
f010e2de:	74 05                	je     f010e2e5 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010e2e0:	e8 5d 89 ff ff       	call   f0106c42 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010e2e5:	83 ec 0c             	sub    $0xc,%esp
f010e2e8:	ff 75 08             	pushl  0x8(%ebp)
f010e2eb:	e8 bc 13 00 00       	call   f010f6ac <fault_handler>
f010e2f0:	83 c4 10             	add    $0x10,%esp
f010e2f3:	e9 e3 00 00 00       	jmp    f010e3db <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010e2f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2fb:	8b 40 28             	mov    0x28(%eax),%eax
f010e2fe:	83 f8 30             	cmp    $0x30,%eax
f010e301:	75 6e                	jne    f010e371 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010e303:	8b 45 08             	mov    0x8(%ebp),%eax
f010e306:	8b 40 38             	mov    0x38(%eax),%eax
f010e309:	25 00 02 00 00       	and    $0x200,%eax
f010e30e:	85 c0                	test   %eax,%eax
f010e310:	74 06                	je     f010e318 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010e312:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010e313:	e8 ca 69 ff ff       	call   f0104ce2 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010e318:	8b 45 08             	mov    0x8(%ebp),%eax
f010e31b:	8b 78 04             	mov    0x4(%eax),%edi
f010e31e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e321:	8b 30                	mov    (%eax),%esi
f010e323:	8b 45 08             	mov    0x8(%ebp),%eax
f010e326:	8b 58 10             	mov    0x10(%eax),%ebx
f010e329:	8b 45 08             	mov    0x8(%ebp),%eax
f010e32c:	8b 48 18             	mov    0x18(%eax),%ecx
f010e32f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e332:	8b 50 14             	mov    0x14(%eax),%edx
f010e335:	8b 45 08             	mov    0x8(%ebp),%eax
f010e338:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e33b:	83 ec 08             	sub    $0x8,%esp
f010e33e:	57                   	push   %edi
f010e33f:	56                   	push   %esi
f010e340:	53                   	push   %ebx
f010e341:	51                   	push   %ecx
f010e342:	52                   	push   %edx
f010e343:	50                   	push   %eax
f010e344:	e8 a5 09 00 00       	call   f010ecee <syscall>
f010e349:	83 c4 20             	add    $0x20,%esp
f010e34c:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010e34f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e352:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e355:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e358:	9c                   	pushf  
f010e359:	58                   	pop    %eax
f010e35a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010e35d:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010e360:	25 00 02 00 00       	and    $0x200,%eax
f010e365:	85 c0                	test   %eax,%eax
f010e367:	74 72                	je     f010e3db <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010e369:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010e36a:	e8 4b 69 ff ff       	call   f0104cba <kclock_stop>
f010e36f:	eb 6a                	jmp    f010e3db <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010e371:	8b 45 08             	mov    0x8(%ebp),%eax
f010e374:	8b 40 28             	mov    0x28(%eax),%eax
f010e377:	83 f8 08             	cmp    $0x8,%eax
f010e37a:	75 17                	jne    f010e393 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010e37c:	83 ec 04             	sub    $0x4,%esp
f010e37f:	68 e7 73 12 f0       	push   $0xf01273e7
f010e384:	68 22 01 00 00       	push   $0x122
f010e389:	68 f6 73 12 f0       	push   $0xf01273f6
f010e38e:	e8 a6 1f ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010e393:	83 ec 0c             	sub    $0xc,%esp
f010e396:	ff 75 08             	pushl  0x8(%ebp)
f010e399:	e8 a3 fc ff ff       	call   f010e041 <print_trapframe>
f010e39e:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010e3a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3a4:	8b 40 34             	mov    0x34(%eax),%eax
f010e3a7:	66 83 f8 08          	cmp    $0x8,%ax
f010e3ab:	75 17                	jne    f010e3c4 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010e3ad:	83 ec 04             	sub    $0x4,%esp
f010e3b0:	68 07 74 12 f0       	push   $0xf0127407
f010e3b5:	68 2a 01 00 00       	push   $0x12a
f010e3ba:	68 f6 73 12 f0       	push   $0xf01273f6
f010e3bf:	e8 75 1f ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010e3c4:	83 ec 04             	sub    $0x4,%esp
f010e3c7:	68 20 74 12 f0       	push   $0xf0127420
f010e3cc:	68 2f 01 00 00       	push   $0x12f
f010e3d1:	68 f6 73 12 f0       	push   $0xf01273f6
f010e3d6:	e8 5e 1f ff ff       	call   f0100339 <_panic>
		}
	}
}
f010e3db:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e3de:	5b                   	pop    %ebx
f010e3df:	5e                   	pop    %esi
f010e3e0:	5f                   	pop    %edi
f010e3e1:	5d                   	pop    %ebp
f010e3e2:	c3                   	ret    

f010e3e3 <trap>:

void trap(struct Trapframe *tf)
{
f010e3e3:	55                   	push   %ebp
f010e3e4:	89 e5                	mov    %esp,%ebp
f010e3e6:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010e3e9:	e8 cc 68 ff ff       	call   f0104cba <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e3ee:	9c                   	pushf  
f010e3ef:	58                   	pop    %eax
f010e3f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010e3f3:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010e3f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010e3f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e3fc:	25 00 02 00 00       	and    $0x200,%eax
f010e401:	85 c0                	test   %eax,%eax
f010e403:	74 25                	je     f010e42a <trap+0x47>
	{
		print_trapframe(tf);
f010e405:	83 ec 0c             	sub    $0xc,%esp
f010e408:	ff 75 08             	pushl  0x8(%ebp)
f010e40b:	e8 31 fc ff ff       	call   f010e041 <print_trapframe>
f010e410:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010e413:	83 ec 04             	sub    $0x4,%esp
f010e416:	68 40 74 12 f0       	push   $0xf0127440
f010e41b:	68 45 01 00 00       	push   $0x145
f010e420:	68 f6 73 12 f0       	push   $0xf01273f6
f010e425:	e8 0f 1f ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010e42a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010e431:	e8 55 d5 ff ff       	call   f010b98b <get_cpu_proc>
f010e436:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010e439:	8b 45 08             	mov    0x8(%ebp),%eax
f010e43c:	8b 40 34             	mov    0x34(%eax),%eax
f010e43f:	0f b7 c0             	movzwl %ax,%eax
f010e442:	83 e0 03             	and    $0x3,%eax
f010e445:	83 f8 03             	cmp    $0x3,%eax
f010e448:	75 54                	jne    f010e49e <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010e44a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e44e:	74 0b                	je     f010e45b <trap+0x78>
f010e450:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e453:	8b 40 18             	mov    0x18(%eax),%eax
f010e456:	83 f8 02             	cmp    $0x2,%eax
f010e459:	74 19                	je     f010e474 <trap+0x91>
f010e45b:	68 84 74 12 f0       	push   $0xf0127484
f010e460:	68 b2 74 12 f0       	push   $0xf01274b2
f010e465:	68 4d 01 00 00       	push   $0x14d
f010e46a:	68 f6 73 12 f0       	push   $0xf01273f6
f010e46f:	e8 c5 1e ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010e474:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e477:	8b 00                	mov    (%eax),%eax
f010e479:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e47c:	74 19                	je     f010e497 <trap+0xb4>
f010e47e:	68 c7 74 12 f0       	push   $0xf01274c7
f010e483:	68 b2 74 12 f0       	push   $0xf01274b2
f010e488:	68 4f 01 00 00       	push   $0x14f
f010e48d:	68 f6 73 12 f0       	push   $0xf01273f6
f010e492:	e8 a2 1e ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010e497:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010e49e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4a1:	8b 40 28             	mov    0x28(%eax),%eax
f010e4a4:	83 f8 1f             	cmp    $0x1f,%eax
f010e4a7:	76 1b                	jbe    f010e4c4 <trap+0xe1>
f010e4a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4ac:	8b 40 28             	mov    0x28(%eax),%eax
f010e4af:	83 f8 2f             	cmp    $0x2f,%eax
f010e4b2:	77 10                	ja     f010e4c4 <trap+0xe1>
	{
		irq_dispatch(tf);
f010e4b4:	83 ec 0c             	sub    $0xc,%esp
f010e4b7:	ff 75 08             	pushl  0x8(%ebp)
f010e4ba:	e8 8c fd ff ff       	call   f010e24b <irq_dispatch>
f010e4bf:	83 c4 10             	add    $0x10,%esp
f010e4c2:	eb 0e                	jmp    f010e4d2 <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010e4c4:	83 ec 0c             	sub    $0xc,%esp
f010e4c7:	ff 75 08             	pushl  0x8(%ebp)
f010e4ca:	e8 c4 fd ff ff       	call   f010e293 <trap_dispatch>
f010e4cf:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e4d2:	9c                   	pushf  
f010e4d3:	58                   	pop    %eax
f010e4d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010e4d7:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010e4da:	25 00 02 00 00       	and    $0x200,%eax
f010e4df:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010e4e2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e4e6:	74 19                	je     f010e501 <trap+0x11e>
f010e4e8:	68 dd 74 12 f0       	push   $0xf01274dd
f010e4ed:	68 b2 74 12 f0       	push   $0xf01274b2
f010e4f2:	68 66 01 00 00       	push   $0x166
f010e4f7:	68 f6 73 12 f0       	push   $0xf01273f6
f010e4fc:	e8 38 1e ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010e501:	e8 dc 67 ff ff       	call   f0104ce2 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010e506:	90                   	nop
f010e507:	c9                   	leave  
f010e508:	c3                   	ret    
f010e509:	90                   	nop

f010e50a <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010e50a:	6a 08                	push   $0x8
f010e50c:	e9 ed 00 00 00       	jmp    f010e5fe <_alltraps>
f010e511:	90                   	nop

f010e512 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010e512:	6a 0e                	push   $0xe
f010e514:	e9 e5 00 00 00       	jmp    f010e5fe <_alltraps>
f010e519:	90                   	nop

f010e51a <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010e51a:	6a 00                	push   $0x0
f010e51c:	6a 20                	push   $0x20
f010e51e:	e9 db 00 00 00       	jmp    f010e5fe <_alltraps>
f010e523:	90                   	nop

f010e524 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010e524:	6a 00                	push   $0x0
f010e526:	6a 21                	push   $0x21
f010e528:	e9 d1 00 00 00       	jmp    f010e5fe <_alltraps>
f010e52d:	90                   	nop

f010e52e <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010e52e:	6a 00                	push   $0x0
f010e530:	6a 30                	push   $0x30
f010e532:	e9 c7 00 00 00       	jmp    f010e5fe <_alltraps>
f010e537:	90                   	nop

f010e538 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010e538:	6a 00                	push   $0x0
f010e53a:	6a 00                	push   $0x0
f010e53c:	e9 bd 00 00 00       	jmp    f010e5fe <_alltraps>
f010e541:	90                   	nop

f010e542 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010e542:	6a 00                	push   $0x0
f010e544:	6a 01                	push   $0x1
f010e546:	e9 b3 00 00 00       	jmp    f010e5fe <_alltraps>
f010e54b:	90                   	nop

f010e54c <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010e54c:	6a 00                	push   $0x0
f010e54e:	6a 02                	push   $0x2
f010e550:	e9 a9 00 00 00       	jmp    f010e5fe <_alltraps>
f010e555:	90                   	nop

f010e556 <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010e556:	6a 00                	push   $0x0
f010e558:	6a 03                	push   $0x3
f010e55a:	e9 9f 00 00 00       	jmp    f010e5fe <_alltraps>
f010e55f:	90                   	nop

f010e560 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010e560:	6a 00                	push   $0x0
f010e562:	6a 04                	push   $0x4
f010e564:	e9 95 00 00 00       	jmp    f010e5fe <_alltraps>
f010e569:	90                   	nop

f010e56a <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010e56a:	6a 00                	push   $0x0
f010e56c:	6a 05                	push   $0x5
f010e56e:	e9 8b 00 00 00       	jmp    f010e5fe <_alltraps>
f010e573:	90                   	nop

f010e574 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010e574:	6a 00                	push   $0x0
f010e576:	6a 06                	push   $0x6
f010e578:	e9 81 00 00 00       	jmp    f010e5fe <_alltraps>
f010e57d:	90                   	nop

f010e57e <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010e57e:	6a 00                	push   $0x0
f010e580:	6a 07                	push   $0x7
f010e582:	eb 7a                	jmp    f010e5fe <_alltraps>

f010e584 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010e584:	6a 0a                	push   $0xa
f010e586:	eb 76                	jmp    f010e5fe <_alltraps>

f010e588 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010e588:	6a 0b                	push   $0xb
f010e58a:	eb 72                	jmp    f010e5fe <_alltraps>

f010e58c <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010e58c:	6a 0c                	push   $0xc
f010e58e:	eb 6e                	jmp    f010e5fe <_alltraps>

f010e590 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010e590:	6a 0d                	push   $0xd
f010e592:	eb 6a                	jmp    f010e5fe <_alltraps>

f010e594 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010e594:	6a 00                	push   $0x0
f010e596:	6a 10                	push   $0x10
f010e598:	eb 64                	jmp    f010e5fe <_alltraps>

f010e59a <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010e59a:	6a 11                	push   $0x11
f010e59c:	eb 60                	jmp    f010e5fe <_alltraps>

f010e59e <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010e59e:	6a 00                	push   $0x0
f010e5a0:	6a 12                	push   $0x12
f010e5a2:	eb 5a                	jmp    f010e5fe <_alltraps>

f010e5a4 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010e5a4:	6a 00                	push   $0x0
f010e5a6:	6a 13                	push   $0x13
f010e5a8:	eb 54                	jmp    f010e5fe <_alltraps>

f010e5aa <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010e5aa:	6a 00                	push   $0x0
f010e5ac:	6a 22                	push   $0x22
f010e5ae:	eb 4e                	jmp    f010e5fe <_alltraps>

f010e5b0 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010e5b0:	6a 00                	push   $0x0
f010e5b2:	6a 23                	push   $0x23
f010e5b4:	eb 48                	jmp    f010e5fe <_alltraps>

f010e5b6 <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010e5b6:	6a 00                	push   $0x0
f010e5b8:	6a 24                	push   $0x24
f010e5ba:	eb 42                	jmp    f010e5fe <_alltraps>

f010e5bc <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010e5bc:	6a 00                	push   $0x0
f010e5be:	6a 25                	push   $0x25
f010e5c0:	eb 3c                	jmp    f010e5fe <_alltraps>

f010e5c2 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010e5c2:	6a 00                	push   $0x0
f010e5c4:	6a 26                	push   $0x26
f010e5c6:	eb 36                	jmp    f010e5fe <_alltraps>

f010e5c8 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010e5c8:	6a 00                	push   $0x0
f010e5ca:	6a 27                	push   $0x27
f010e5cc:	eb 30                	jmp    f010e5fe <_alltraps>

f010e5ce <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010e5ce:	6a 00                	push   $0x0
f010e5d0:	6a 28                	push   $0x28
f010e5d2:	eb 2a                	jmp    f010e5fe <_alltraps>

f010e5d4 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010e5d4:	6a 00                	push   $0x0
f010e5d6:	6a 29                	push   $0x29
f010e5d8:	eb 24                	jmp    f010e5fe <_alltraps>

f010e5da <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010e5da:	6a 00                	push   $0x0
f010e5dc:	6a 2a                	push   $0x2a
f010e5de:	eb 1e                	jmp    f010e5fe <_alltraps>

f010e5e0 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010e5e0:	6a 00                	push   $0x0
f010e5e2:	6a 2b                	push   $0x2b
f010e5e4:	eb 18                	jmp    f010e5fe <_alltraps>

f010e5e6 <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010e5e6:	6a 00                	push   $0x0
f010e5e8:	6a 2c                	push   $0x2c
f010e5ea:	eb 12                	jmp    f010e5fe <_alltraps>

f010e5ec <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010e5ec:	6a 00                	push   $0x0
f010e5ee:	6a 2d                	push   $0x2d
f010e5f0:	eb 0c                	jmp    f010e5fe <_alltraps>

f010e5f2 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010e5f2:	6a 00                	push   $0x0
f010e5f4:	6a 2e                	push   $0x2e
f010e5f6:	eb 06                	jmp    f010e5fe <_alltraps>

f010e5f8 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010e5f8:	6a 00                	push   $0x0
f010e5fa:	6a 2f                	push   $0x2f
f010e5fc:	eb 00                	jmp    f010e5fe <_alltraps>

f010e5fe <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010e5fe:	1e                   	push   %ds
push 	%es
f010e5ff:	06                   	push   %es
pushal
f010e600:	60                   	pusha  

mov 	$(GD_KD), %ax
f010e601:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e605:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e607:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e609:	54                   	push   %esp
call 	trap
f010e60a:	e8 d4 fd ff ff       	call   f010e3e3 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e60f:	59                   	pop    %ecx

f010e610 <trapret>:
.globl trapret
trapret:
popal
f010e610:	61                   	popa   
pop 	%es
f010e611:	07                   	pop    %es
pop 	%ds
f010e612:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e613:	83 c4 08             	add    $0x8,%esp
iret
f010e616:	cf                   	iret   

f010e617 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010e617:	55                   	push   %ebp
f010e618:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010e61a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e61d:	8b 15 e0 0a 6c f0    	mov    0xf06c0ae0,%edx
f010e623:	29 d0                	sub    %edx,%eax
f010e625:	c1 f8 03             	sar    $0x3,%eax
f010e628:	89 c2                	mov    %eax,%edx
f010e62a:	89 d0                	mov    %edx,%eax
f010e62c:	c1 e0 02             	shl    $0x2,%eax
f010e62f:	01 d0                	add    %edx,%eax
f010e631:	c1 e0 02             	shl    $0x2,%eax
f010e634:	01 d0                	add    %edx,%eax
f010e636:	c1 e0 02             	shl    $0x2,%eax
f010e639:	01 d0                	add    %edx,%eax
f010e63b:	89 c1                	mov    %eax,%ecx
f010e63d:	c1 e1 08             	shl    $0x8,%ecx
f010e640:	01 c8                	add    %ecx,%eax
f010e642:	89 c1                	mov    %eax,%ecx
f010e644:	c1 e1 10             	shl    $0x10,%ecx
f010e647:	01 c8                	add    %ecx,%eax
f010e649:	01 c0                	add    %eax,%eax
f010e64b:	01 d0                	add    %edx,%eax
}
f010e64d:	5d                   	pop    %ebp
f010e64e:	c3                   	ret    

f010e64f <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010e64f:	55                   	push   %ebp
f010e650:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010e652:	ff 75 08             	pushl  0x8(%ebp)
f010e655:	e8 bd ff ff ff       	call   f010e617 <to_frame_number>
f010e65a:	83 c4 04             	add    $0x4,%esp
f010e65d:	c1 e0 0c             	shl    $0xc,%eax
}
f010e660:	c9                   	leave  
f010e661:	c3                   	ret    

f010e662 <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010e662:	55                   	push   %ebp
f010e663:	89 e5                	mov    %esp,%ebp
f010e665:	83 ec 18             	sub    $0x18,%esp
f010e668:	8b 45 10             	mov    0x10(%ebp),%eax
f010e66b:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010e66e:	e8 5c 8b ff ff       	call   f01071cf <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010e673:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010e677:	74 23                	je     f010e69c <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010e679:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010e67e:	8b 40 10             	mov    0x10(%eax),%eax
f010e681:	8b 15 c0 72 b0 f0    	mov    0xf0b072c0,%edx
f010e687:	83 c2 20             	add    $0x20,%edx
f010e68a:	83 ec 04             	sub    $0x4,%esp
f010e68d:	50                   	push   %eax
f010e68e:	52                   	push   %edx
f010e68f:	68 90 76 12 f0       	push   $0xf0127690
f010e694:	e8 f2 28 ff ff       	call   f0100f8b <cprintf>
f010e699:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010e69c:	83 ec 04             	sub    $0x4,%esp
f010e69f:	ff 75 08             	pushl  0x8(%ebp)
f010e6a2:	ff 75 0c             	pushl  0xc(%ebp)
f010e6a5:	68 99 76 12 f0       	push   $0xf0127699
f010e6aa:	e8 dc 28 ff ff       	call   f0100f8b <cprintf>
f010e6af:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010e6b2:	e8 6a 8b ff ff       	call   f0107221 <popcli>
}
f010e6b7:	90                   	nop
f010e6b8:	c9                   	leave  
f010e6b9:	c3                   	ret    

f010e6ba <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010e6ba:	55                   	push   %ebp
f010e6bb:	89 e5                	mov    %esp,%ebp
f010e6bd:	83 ec 18             	sub    $0x18,%esp
f010e6c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6c3:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010e6c6:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010e6ca:	83 ec 08             	sub    $0x8,%esp
f010e6cd:	50                   	push   %eax
f010e6ce:	68 9e 76 12 f0       	push   $0xf012769e
f010e6d3:	e8 b3 28 ff ff       	call   f0100f8b <cprintf>
f010e6d8:	83 c4 10             	add    $0x10,%esp
}
f010e6db:	90                   	nop
f010e6dc:	c9                   	leave  
f010e6dd:	c3                   	ret    

f010e6de <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010e6de:	55                   	push   %ebp
f010e6df:	89 e5                	mov    %esp,%ebp
f010e6e1:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e6e4:	9c                   	pushf  
f010e6e5:	58                   	pop    %eax
f010e6e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010e6e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010e6ec:	25 00 02 00 00       	and    $0x200,%eax
f010e6f1:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010e6f4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e6f8:	74 10                	je     f010e70a <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010e6fa:	e8 c5 26 ff ff       	call   f0100dc4 <cons_getc2>
f010e6ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e702:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e706:	74 f2                	je     f010e6fa <sys_cgetc+0x1c>
f010e708:	eb 0e                	jmp    f010e718 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010e70a:	e8 5a 26 ff ff       	call   f0100d69 <cons_getc>
f010e70f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e712:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e716:	74 f2                	je     f010e70a <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010e718:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e71b:	c9                   	leave  
f010e71c:	c3                   	ret    

f010e71d <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010e71d:	55                   	push   %ebp
f010e71e:	89 e5                	mov    %esp,%ebp
f010e720:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010e723:	e8 88 27 ff ff       	call   f0100eb0 <cons_lock>
}
f010e728:	90                   	nop
f010e729:	c9                   	leave  
f010e72a:	c3                   	ret    

f010e72b <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010e72b:	55                   	push   %ebp
f010e72c:	89 e5                	mov    %esp,%ebp
f010e72e:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010e731:	e8 c1 27 ff ff       	call   f0100ef7 <cons_unlock>
}
f010e736:	90                   	nop
f010e737:	c9                   	leave  
f010e738:	c3                   	ret    

f010e739 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010e739:	55                   	push   %ebp
f010e73a:	89 e5                	mov    %esp,%ebp
f010e73c:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010e73f:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010e744:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010e747:	83 ec 0c             	sub    $0xc,%esp
f010e74a:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e74d:	50                   	push   %eax
f010e74e:	e8 5f 9a ff ff       	call   f01081b2 <allocate_frame>
f010e753:	83 c4 10             	add    $0x10,%esp
f010e756:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e759:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e75d:	75 08                	jne    f010e767 <__sys_allocate_page+0x2e>
		return r ;
f010e75f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e762:	e9 e9 00 00 00       	jmp    f010e850 <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010e767:	8b 45 08             	mov    0x8(%ebp),%eax
f010e76a:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010e76f:	77 0c                	ja     f010e77d <__sys_allocate_page+0x44>
f010e771:	8b 45 08             	mov    0x8(%ebp),%eax
f010e774:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e779:	85 c0                	test   %eax,%eax
f010e77b:	74 0a                	je     f010e787 <__sys_allocate_page+0x4e>
		return E_INVAL;
f010e77d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e782:	e9 c9 00 00 00       	jmp    f010e850 <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010e787:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e78a:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010e78f:	83 f8 04             	cmp    $0x4,%eax
f010e792:	74 0a                	je     f010e79e <__sys_allocate_page+0x65>
		return E_INVAL;
f010e794:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e799:	e9 b2 00 00 00       	jmp    f010e850 <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010e79e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e7a1:	83 ec 0c             	sub    $0xc,%esp
f010e7a4:	50                   	push   %eax
f010e7a5:	e8 a5 fe ff ff       	call   f010e64f <to_physical_address>
f010e7aa:	83 c4 10             	add    $0x10,%esp
f010e7ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010e7b0:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e7b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e7b6:	8b 40 64             	mov    0x64(%eax),%eax
f010e7b9:	6a 02                	push   $0x2
f010e7bb:	68 00 00 80 ef       	push   $0xef800000
f010e7c0:	52                   	push   %edx
f010e7c1:	50                   	push   %eax
f010e7c2:	e8 b8 9e ff ff       	call   f010867f <map_frame>
f010e7c7:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010e7ca:	83 ec 04             	sub    $0x4,%esp
f010e7cd:	68 00 10 00 00       	push   $0x1000
f010e7d2:	6a 00                	push   $0x0
f010e7d4:	68 00 00 80 ef       	push   $0xef800000
f010e7d9:	e8 d8 15 01 00       	call   f011fdb6 <memset>
f010e7de:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010e7e1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e7e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e7e7:	8b 40 08             	mov    0x8(%eax),%eax
f010e7ea:	40                   	inc    %eax
f010e7eb:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010e7ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e7f2:	8b 40 64             	mov    0x64(%eax),%eax
f010e7f5:	83 ec 08             	sub    $0x8,%esp
f010e7f8:	68 00 00 80 ef       	push   $0xef800000
f010e7fd:	50                   	push   %eax
f010e7fe:	e8 dc 9f ff ff       	call   f01087df <unmap_frame>
f010e803:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010e806:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e809:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e80c:	8b 40 08             	mov    0x8(%eax),%eax
f010e80f:	48                   	dec    %eax
f010e810:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010e814:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e817:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e81a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e81d:	8b 40 64             	mov    0x64(%eax),%eax
f010e820:	ff 75 0c             	pushl  0xc(%ebp)
f010e823:	51                   	push   %ecx
f010e824:	52                   	push   %edx
f010e825:	50                   	push   %eax
f010e826:	e8 54 9e ff ff       	call   f010867f <map_frame>
f010e82b:	83 c4 10             	add    $0x10,%esp
f010e82e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e831:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e835:	75 14                	jne    f010e84b <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010e837:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e83a:	83 ec 0c             	sub    $0xc,%esp
f010e83d:	50                   	push   %eax
f010e83e:	e8 7c 9b ff ff       	call   f01083bf <decrement_references>
f010e843:	83 c4 10             	add    $0x10,%esp
		return r;
f010e846:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e849:	eb 05                	jmp    f010e850 <__sys_allocate_page+0x117>
	}
	return 0 ;
f010e84b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e850:	c9                   	leave  
f010e851:	c3                   	ret    

f010e852 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010e852:	55                   	push   %ebp
f010e853:	89 e5                	mov    %esp,%ebp
f010e855:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010e858:	83 ec 04             	sub    $0x4,%esp
f010e85b:	68 a1 76 12 f0       	push   $0xf01276a1
f010e860:	68 dc 00 00 00       	push   $0xdc
f010e865:	68 bf 76 12 f0       	push   $0xf01276bf
f010e86a:	e8 ca 1a ff ff       	call   f0100339 <_panic>

f010e86f <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010e86f:	55                   	push   %ebp
f010e870:	89 e5                	mov    %esp,%ebp
f010e872:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010e875:	83 ec 04             	sub    $0x4,%esp
f010e878:	68 d4 76 12 f0       	push   $0xf01276d4
f010e87d:	68 ed 00 00 00       	push   $0xed
f010e882:	68 bf 76 12 f0       	push   $0xf01276bf
f010e887:	e8 ad 1a ff ff       	call   f0100339 <_panic>

f010e88c <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010e88c:	55                   	push   %ebp
f010e88d:	89 e5                	mov    %esp,%ebp
f010e88f:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010e892:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010e897:	8b 40 64             	mov    0x64(%eax),%eax
f010e89a:	83 ec 04             	sub    $0x4,%esp
f010e89d:	ff 75 0c             	pushl  0xc(%ebp)
f010e8a0:	ff 75 08             	pushl  0x8(%ebp)
f010e8a3:	50                   	push   %eax
f010e8a4:	e8 25 c2 ff ff       	call   f010aace <calculate_required_frames>
f010e8a9:	83 c4 10             	add    $0x10,%esp
}
f010e8ac:	c9                   	leave  
f010e8ad:	c3                   	ret    

f010e8ae <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010e8ae:	55                   	push   %ebp
f010e8af:	89 e5                	mov    %esp,%ebp
f010e8b1:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e8b4:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e8b7:	83 ec 0c             	sub    $0xc,%esp
f010e8ba:	50                   	push   %eax
f010e8bb:	e8 a1 a0 ff ff       	call   f0108961 <calculate_available_frames>
f010e8c0:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010e8c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e8c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e8c9:	01 d0                	add    %edx,%eax
}
f010e8cb:	c9                   	leave  
f010e8cc:	c3                   	ret    

f010e8cd <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010e8cd:	55                   	push   %ebp
f010e8ce:	89 e5                	mov    %esp,%ebp
f010e8d0:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e8d3:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e8d6:	83 ec 0c             	sub    $0xc,%esp
f010e8d9:	50                   	push   %eax
f010e8da:	e8 82 a0 ff ff       	call   f0108961 <calculate_available_frames>
f010e8df:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010e8e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e8e5:	c9                   	leave  
f010e8e6:	c3                   	ret    

f010e8e7 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010e8e7:	55                   	push   %ebp
f010e8e8:	89 e5                	mov    %esp,%ebp
f010e8ea:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e8ed:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e8f0:	83 ec 0c             	sub    $0xc,%esp
f010e8f3:	50                   	push   %eax
f010e8f4:	e8 68 a0 ff ff       	call   f0108961 <calculate_available_frames>
f010e8f9:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010e8fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010e8ff:	c9                   	leave  
f010e900:	c3                   	ret    

f010e901 <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010e901:	55                   	push   %ebp
f010e902:	89 e5                	mov    %esp,%ebp
f010e904:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010e907:	83 ec 0c             	sub    $0xc,%esp
f010e90a:	ff 75 08             	pushl  0x8(%ebp)
f010e90d:	e8 4d 00 01 00       	call   f011e95f <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010e912:	83 c4 10             	add    $0x10,%esp
}
f010e915:	c9                   	leave  
f010e916:	c3                   	ret    

f010e917 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010e917:	55                   	push   %ebp
f010e918:	89 e5                	mov    %esp,%ebp
f010e91a:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010e91d:	e8 68 ff 00 00       	call   f011e88a <scarce_memory>
}
f010e922:	90                   	nop
f010e923:	c9                   	leave  
f010e924:	c3                   	ret    

f010e925 <sys_clearFFL>:

void sys_clearFFL()
{
f010e925:	55                   	push   %ebp
f010e926:	89 e5                	mov    %esp,%ebp
f010e928:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010e92b:	83 ec 0c             	sub    $0xc,%esp
f010e92e:	68 a0 06 6c f0       	push   $0xf06c06a0
f010e933:	e8 e2 12 00 00       	call   f010fc1a <acquire_spinlock>
f010e938:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010e93b:	a1 8c 06 6c f0       	mov    0xf06c068c,%eax
f010e940:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e943:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e94a:	eb 12                	jmp    f010e95e <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010e94c:	83 ec 0c             	sub    $0xc,%esp
f010e94f:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e952:	50                   	push   %eax
f010e953:	e8 5a 98 ff ff       	call   f01081b2 <allocate_frame>
f010e958:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e95b:	ff 45 f4             	incl   -0xc(%ebp)
f010e95e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e961:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010e964:	7c e6                	jl     f010e94c <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010e966:	83 ec 0c             	sub    $0xc,%esp
f010e969:	68 a0 06 6c f0       	push   $0xf06c06a0
f010e96e:	e8 2e 13 00 00       	call   f010fca1 <release_spinlock>
f010e973:	83 c4 10             	add    $0x10,%esp
}
f010e976:	90                   	nop
f010e977:	c9                   	leave  
f010e978:	c3                   	ret    

f010e979 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010e979:	55                   	push   %ebp
f010e97a:	89 e5                	mov    %esp,%ebp
f010e97c:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010e97f:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010e984:	83 ec 0c             	sub    $0xc,%esp
f010e987:	50                   	push   %eax
f010e988:	e8 72 5e ff ff       	call   f01047ff <pf_calculate_allocated_pages>
f010e98d:	83 c4 10             	add    $0x10,%esp
}
f010e990:	c9                   	leave  
f010e991:	c3                   	ret    

f010e992 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010e992:	55                   	push   %ebp
f010e993:	89 e5                	mov    %esp,%ebp
f010e995:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010e998:	e8 ed 0c 00 00       	call   f010f68a <isBufferingEnabled>
f010e99d:	84 c0                	test   %al,%al
f010e99f:	74 19                	je     f010e9ba <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010e9a1:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010e9a6:	83 ec 04             	sub    $0x4,%esp
f010e9a9:	ff 75 0c             	pushl  0xc(%ebp)
f010e9ac:	ff 75 08             	pushl  0x8(%ebp)
f010e9af:	50                   	push   %eax
f010e9b0:	e8 48 c3 ff ff       	call   f010acfd <__free_user_mem_with_buffering>
f010e9b5:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010e9b8:	eb 18                	jmp    f010e9d2 <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010e9ba:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010e9bf:	83 ec 04             	sub    $0x4,%esp
f010e9c2:	ff 75 0c             	pushl  0xc(%ebp)
f010e9c5:	ff 75 08             	pushl  0x8(%ebp)
f010e9c8:	50                   	push   %eax
f010e9c9:	e8 5f c2 ff ff       	call   f010ac2d <free_user_mem>
f010e9ce:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010e9d1:	90                   	nop
}
f010e9d2:	c9                   	leave  
f010e9d3:	c3                   	ret    

f010e9d4 <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010e9d4:	55                   	push   %ebp
f010e9d5:	89 e5                	mov    %esp,%ebp
f010e9d7:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010e9da:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e9de:	75 07                	jne    f010e9e7 <check_Param+0x13>
	{
		env_exit();
f010e9e0:	e8 64 cf ff ff       	call   f010b949 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010e9e5:	eb 25                	jmp    f010ea0c <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010e9e7:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010e9ee:	77 07                	ja     f010e9f7 <check_Param+0x23>
f010e9f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9f3:	85 c0                	test   %eax,%eax
f010e9f5:	78 07                	js     f010e9fe <check_Param+0x2a>
	{
		env_exit();
f010e9f7:	e8 4d cf ff ff       	call   f010b949 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010e9fc:	eb 0e                	jmp    f010ea0c <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010e9fe:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010ea05:	76 05                	jbe    f010ea0c <check_Param+0x38>
	{
		env_exit();
f010ea07:	e8 3d cf ff ff       	call   f010b949 <env_exit>
	}
}
f010ea0c:	90                   	nop
f010ea0d:	c9                   	leave  
f010ea0e:	c3                   	ret    

f010ea0f <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010ea0f:	55                   	push   %ebp
f010ea10:	89 e5                	mov    %esp,%ebp
f010ea12:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010ea15:	83 ec 0c             	sub    $0xc,%esp
f010ea18:	ff 75 08             	pushl  0x8(%ebp)
f010ea1b:	e8 b4 ff ff ff       	call   f010e9d4 <check_Param>
f010ea20:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010ea23:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010ea28:	83 ec 04             	sub    $0x4,%esp
f010ea2b:	ff 75 0c             	pushl  0xc(%ebp)
f010ea2e:	ff 75 08             	pushl  0x8(%ebp)
f010ea31:	50                   	push   %eax
f010ea32:	e8 3b c1 ff ff       	call   f010ab72 <allocate_user_mem>
f010ea37:	83 c4 10             	add    $0x10,%esp
	return;
f010ea3a:	90                   	nop
}
f010ea3b:	c9                   	leave  
f010ea3c:	c3                   	ret    

f010ea3d <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010ea3d:	55                   	push   %ebp
f010ea3e:	89 e5                	mov    %esp,%ebp
f010ea40:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010ea43:	83 ec 0c             	sub    $0xc,%esp
f010ea46:	ff 75 08             	pushl  0x8(%ebp)
f010ea49:	e8 86 ff ff ff       	call   f010e9d4 <check_Param>
f010ea4e:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010ea51:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010ea56:	8b 40 64             	mov    0x64(%eax),%eax
f010ea59:	ff 75 10             	pushl  0x10(%ebp)
f010ea5c:	ff 75 0c             	pushl  0xc(%ebp)
f010ea5f:	ff 75 08             	pushl  0x8(%ebp)
f010ea62:	50                   	push   %eax
f010ea63:	e8 32 c0 ff ff       	call   f010aa9a <allocate_chunk>
f010ea68:	83 c4 10             	add    $0x10,%esp
	return;
f010ea6b:	90                   	nop
}
f010ea6c:	c9                   	leave  
f010ea6d:	c3                   	ret    

f010ea6e <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010ea6e:	55                   	push   %ebp
f010ea6f:	89 e5                	mov    %esp,%ebp
f010ea71:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010ea74:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010ea79:	ff 75 10             	pushl  0x10(%ebp)
f010ea7c:	ff 75 0c             	pushl  0xc(%ebp)
f010ea7f:	ff 75 08             	pushl  0x8(%ebp)
f010ea82:	50                   	push   %eax
f010ea83:	e8 92 c2 ff ff       	call   f010ad1a <move_user_mem>
f010ea88:	83 c4 10             	add    $0x10,%esp
	return;
f010ea8b:	90                   	nop
}
f010ea8c:	c9                   	leave  
f010ea8d:	c3                   	ret    

f010ea8e <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010ea8e:	55                   	push   %ebp
f010ea8f:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010ea91:	a1 c4 0a 6c f0       	mov    0xf06c0ac4,%eax
}
f010ea96:	5d                   	pop    %ebp
f010ea97:	c3                   	ret    

f010ea98 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010ea98:	55                   	push   %ebp
f010ea99:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010ea9b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea9e:	a3 c4 0a 6c f0       	mov    %eax,0xf06c0ac4
}
f010eaa3:	90                   	nop
f010eaa4:	5d                   	pop    %ebp
f010eaa5:	c3                   	ret    

f010eaa6 <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010eaa6:	55                   	push   %ebp
f010eaa7:	89 e5                	mov    %esp,%ebp
f010eaa9:	83 ec 18             	sub    $0x18,%esp
f010eaac:	8b 45 10             	mov    0x10(%ebp),%eax
f010eaaf:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010eab2:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010eab6:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010eabb:	8b 40 10             	mov    0x10(%eax),%eax
f010eabe:	83 ec 0c             	sub    $0xc,%esp
f010eac1:	ff 75 14             	pushl  0x14(%ebp)
f010eac4:	52                   	push   %edx
f010eac5:	ff 75 0c             	pushl  0xc(%ebp)
f010eac8:	ff 75 08             	pushl  0x8(%ebp)
f010eacb:	50                   	push   %eax
f010eacc:	e8 b4 a1 ff ff       	call   f0108c85 <createSharedObject>
f010ead1:	83 c4 20             	add    $0x20,%esp
}
f010ead4:	c9                   	leave  
f010ead5:	c3                   	ret    

f010ead6 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010ead6:	55                   	push   %ebp
f010ead7:	89 e5                	mov    %esp,%ebp
f010ead9:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010eadc:	83 ec 08             	sub    $0x8,%esp
f010eadf:	ff 75 0c             	pushl  0xc(%ebp)
f010eae2:	ff 75 08             	pushl  0x8(%ebp)
f010eae5:	e8 96 9f ff ff       	call   f0108a80 <getSizeOfSharedObject>
f010eaea:	83 c4 10             	add    $0x10,%esp
}
f010eaed:	c9                   	leave  
f010eaee:	c3                   	ret    

f010eaef <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010eaef:	55                   	push   %ebp
f010eaf0:	89 e5                	mov    %esp,%ebp
f010eaf2:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010eaf5:	83 ec 04             	sub    $0x4,%esp
f010eaf8:	ff 75 10             	pushl  0x10(%ebp)
f010eafb:	ff 75 0c             	pushl  0xc(%ebp)
f010eafe:	ff 75 08             	pushl  0x8(%ebp)
f010eb01:	e8 12 a3 ff ff       	call   f0108e18 <getSharedObject>
f010eb06:	83 c4 10             	add    $0x10,%esp
}
f010eb09:	c9                   	leave  
f010eb0a:	c3                   	ret    

f010eb0b <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010eb0b:	55                   	push   %ebp
f010eb0c:	89 e5                	mov    %esp,%ebp
f010eb0e:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010eb11:	83 ec 08             	sub    $0x8,%esp
f010eb14:	ff 75 0c             	pushl  0xc(%ebp)
f010eb17:	ff 75 08             	pushl  0x8(%ebp)
f010eb1a:	e8 71 a5 ff ff       	call   f0109090 <freeSharedObject>
f010eb1f:	83 c4 10             	add    $0x10,%esp
}
f010eb22:	c9                   	leave  
f010eb23:	c3                   	ret    

f010eb24 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010eb24:	55                   	push   %ebp
f010eb25:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010eb27:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010eb2c:	8b 40 10             	mov    0x10(%eax),%eax
}
f010eb2f:	5d                   	pop    %ebp
f010eb30:	c3                   	ret    

f010eb31 <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010eb31:	55                   	push   %ebp
f010eb32:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010eb34:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010eb39:	89 c2                	mov    %eax,%edx
f010eb3b:	a1 f0 7a 69 f0       	mov    0xf0697af0,%eax
f010eb40:	29 c2                	sub    %eax,%edx
f010eb42:	89 d0                	mov    %edx,%eax
f010eb44:	c1 f8 02             	sar    $0x2,%eax
f010eb47:	89 c2                	mov    %eax,%edx
f010eb49:	89 d0                	mov    %edx,%eax
f010eb4b:	c1 e0 03             	shl    $0x3,%eax
f010eb4e:	01 d0                	add    %edx,%eax
f010eb50:	c1 e0 03             	shl    $0x3,%eax
f010eb53:	01 d0                	add    %edx,%eax
f010eb55:	c1 e0 02             	shl    $0x2,%eax
f010eb58:	01 d0                	add    %edx,%eax
f010eb5a:	01 c0                	add    %eax,%eax
f010eb5c:	01 d0                	add    %edx,%eax
f010eb5e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010eb65:	01 c8                	add    %ecx,%eax
f010eb67:	c1 e0 02             	shl    $0x2,%eax
f010eb6a:	01 d0                	add    %edx,%eax
f010eb6c:	c1 e0 03             	shl    $0x3,%eax
f010eb6f:	01 d0                	add    %edx,%eax
f010eb71:	c1 e0 05             	shl    $0x5,%eax
f010eb74:	29 d0                	sub    %edx,%eax
f010eb76:	c1 e0 02             	shl    $0x2,%eax
f010eb79:	01 d0                	add    %edx,%eax
f010eb7b:	01 c0                	add    %eax,%eax
f010eb7d:	01 d0                	add    %edx,%eax
f010eb7f:	c1 e0 03             	shl    $0x3,%eax
f010eb82:	01 d0                	add    %edx,%eax
f010eb84:	c1 e0 04             	shl    $0x4,%eax
f010eb87:	29 d0                	sub    %edx,%eax
}
f010eb89:	5d                   	pop    %ebp
f010eb8a:	c3                   	ret    

f010eb8b <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010eb8b:	55                   	push   %ebp
f010eb8c:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010eb8e:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010eb93:	8b 40 14             	mov    0x14(%eax),%eax
}
f010eb96:	5d                   	pop    %ebp
f010eb97:	c3                   	ret    

f010eb98 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010eb98:	55                   	push   %ebp
f010eb99:	89 e5                	mov    %esp,%ebp
f010eb9b:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010eb9e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010eba2:	75 0a                	jne    f010ebae <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010eba4:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010eba9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ebac:	eb 22                	jmp    f010ebd0 <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010ebae:	83 ec 04             	sub    $0x4,%esp
f010ebb1:	6a 00                	push   $0x0
f010ebb3:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010ebb6:	50                   	push   %eax
f010ebb7:	ff 75 08             	pushl  0x8(%ebp)
f010ebba:	e8 1c ce ff ff       	call   f010b9db <envid2env>
f010ebbf:	83 c4 10             	add    $0x10,%esp
f010ebc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ebc5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ebc9:	79 05                	jns    f010ebd0 <sys_destroy_env+0x38>
	{
		return r;
f010ebcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ebce:	eb 5e                	jmp    f010ec2e <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010ebd0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ebd3:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010ebd8:	39 c2                	cmp    %eax,%edx
f010ebda:	75 1b                	jne    f010ebf7 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010ebdc:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010ebe1:	8b 40 10             	mov    0x10(%eax),%eax
f010ebe4:	83 ec 08             	sub    $0x8,%esp
f010ebe7:	50                   	push   %eax
f010ebe8:	68 f3 76 12 f0       	push   $0xf01276f3
f010ebed:	e8 99 23 ff ff       	call   f0100f8b <cprintf>
f010ebf2:	83 c4 10             	add    $0x10,%esp
f010ebf5:	eb 20                	jmp    f010ec17 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010ebf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ebfa:	8b 50 10             	mov    0x10(%eax),%edx
f010ebfd:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010ec02:	8b 40 10             	mov    0x10(%eax),%eax
f010ec05:	83 ec 04             	sub    $0x4,%esp
f010ec08:	52                   	push   %edx
f010ec09:	50                   	push   %eax
f010ec0a:	68 0e 77 12 f0       	push   $0xf012770e
f010ec0f:	e8 77 23 ff ff       	call   f0100f8b <cprintf>
f010ec14:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010ec17:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec1a:	8b 40 10             	mov    0x10(%eax),%eax
f010ec1d:	83 ec 0c             	sub    $0xc,%esp
f010ec20:	50                   	push   %eax
f010ec21:	e8 92 6e ff ff       	call   f0105ab8 <sched_kill_env>
f010ec26:	83 c4 10             	add    $0x10,%esp

	return 0;
f010ec29:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ec2e:	c9                   	leave  
f010ec2f:	c3                   	ret    

f010ec30 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010ec30:	55                   	push   %ebp
f010ec31:	89 e5                	mov    %esp,%ebp
f010ec33:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010ec36:	e8 0e cd ff ff       	call   f010b949 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010ec3b:	90                   	nop
f010ec3c:	c9                   	leave  
f010ec3d:	c3                   	ret    

f010ec3e <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010ec3e:	55                   	push   %ebp
f010ec3f:	89 e5                	mov    %esp,%ebp
f010ec41:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010ec44:	ff 75 14             	pushl  0x14(%ebp)
f010ec47:	ff 75 10             	pushl  0x10(%ebp)
f010ec4a:	ff 75 0c             	pushl  0xc(%ebp)
f010ec4d:	ff 75 08             	pushl  0x8(%ebp)
f010ec50:	e8 b8 c2 ff ff       	call   f010af0d <env_create>
f010ec55:	83 c4 10             	add    $0x10,%esp
f010ec58:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010ec5b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec5f:	75 07                	jne    f010ec68 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010ec61:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010ec66:	eb 14                	jmp    f010ec7c <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010ec68:	83 ec 0c             	sub    $0xc,%esp
f010ec6b:	ff 75 f4             	pushl  -0xc(%ebp)
f010ec6e:	e8 a9 6a ff ff       	call   f010571c <sched_new_env>
f010ec73:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010ec76:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec79:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ec7c:	c9                   	leave  
f010ec7d:	c3                   	ret    

f010ec7e <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010ec7e:	55                   	push   %ebp
f010ec7f:	89 e5                	mov    %esp,%ebp
f010ec81:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010ec84:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec87:	83 ec 0c             	sub    $0xc,%esp
f010ec8a:	50                   	push   %eax
f010ec8b:	e8 e2 6a ff ff       	call   f0105772 <sched_run_env>
f010ec90:	83 c4 10             	add    $0x10,%esp
}
f010ec93:	90                   	nop
f010ec94:	c9                   	leave  
f010ec95:	c3                   	ret    

f010ec96 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010ec96:	55                   	push   %ebp
f010ec97:	89 e5                	mov    %esp,%ebp
f010ec99:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010ec9c:	0f 31                	rdtsc  
f010ec9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010eca1:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010eca4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eca7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ecaa:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010ecad:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010ecb0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ecb3:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ecb6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ecb9:	89 01                	mov    %eax,(%ecx)
f010ecbb:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010ecbe:	8b 45 08             	mov    0x8(%ebp),%eax
f010ecc1:	c9                   	leave  
f010ecc2:	c2 04 00             	ret    $0x4

f010ecc5 <sys_rcr2>:

uint32 sys_rcr2()
{
f010ecc5:	55                   	push   %ebp
f010ecc6:	89 e5                	mov    %esp,%ebp
f010ecc8:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010eccb:	0f 20 d0             	mov    %cr2,%eax
f010ecce:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010ecd1:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010ecd4:	90                   	nop
}
f010ecd5:	c9                   	leave  
f010ecd6:	c3                   	ret    

f010ecd7 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010ecd7:	55                   	push   %ebp
f010ecd8:	89 e5                	mov    %esp,%ebp
f010ecda:	83 ec 04             	sub    $0x4,%esp
f010ecdd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ece0:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010ece3:	8a 45 fc             	mov    -0x4(%ebp),%al
f010ece6:	a2 60 83 69 f0       	mov    %al,0xf0698360
}
f010eceb:	90                   	nop
f010ecec:	c9                   	leave  
f010eced:	c3                   	ret    

f010ecee <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010ecee:	55                   	push   %ebp
f010ecef:	89 e5                	mov    %esp,%ebp
f010ecf1:	56                   	push   %esi
f010ecf2:	53                   	push   %ebx
f010ecf3:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010ecf6:	e8 90 cc ff ff       	call   f010b98b <get_cpu_proc>
f010ecfb:	a3 c0 72 b0 f0       	mov    %eax,0xf0b072c0
	assert(cur_env != NULL);
f010ed00:	a1 c0 72 b0 f0       	mov    0xf0b072c0,%eax
f010ed05:	85 c0                	test   %eax,%eax
f010ed07:	75 19                	jne    f010ed22 <syscall+0x34>
f010ed09:	68 26 77 12 f0       	push   $0xf0127726
f010ed0e:	68 36 77 12 f0       	push   $0xf0127736
f010ed13:	68 05 02 00 00       	push   $0x205
f010ed18:	68 bf 76 12 f0       	push   $0xf01276bf
f010ed1d:	e8 17 16 ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010ed22:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010ed26:	0f 87 06 04 00 00    	ja     f010f132 <syscall+0x444>
f010ed2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed2f:	c1 e0 02             	shl    $0x2,%eax
f010ed32:	05 4c 77 12 f0       	add    $0xf012774c,%eax
f010ed37:	8b 00                	mov    (%eax),%eax
f010ed39:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010ed3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed3e:	83 ec 0c             	sub    $0xc,%esp
f010ed41:	50                   	push   %eax
f010ed42:	e8 a1 bd ff ff       	call   f010aae8 <sys_sbrk>
f010ed47:	83 c4 10             	add    $0x10,%esp
f010ed4a:	e9 e8 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010ed4f:	83 ec 08             	sub    $0x8,%esp
f010ed52:	ff 75 10             	pushl  0x10(%ebp)
f010ed55:	ff 75 0c             	pushl  0xc(%ebp)
f010ed58:	e8 35 fc ff ff       	call   f010e992 <sys_free_user_mem>
f010ed5d:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ed60:	b8 00 00 00 00       	mov    $0x0,%eax
f010ed65:	e9 cd 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010ed6a:	83 ec 08             	sub    $0x8,%esp
f010ed6d:	ff 75 10             	pushl  0x10(%ebp)
f010ed70:	ff 75 0c             	pushl  0xc(%ebp)
f010ed73:	e8 97 fc ff ff       	call   f010ea0f <sys_allocate_user_mem>
f010ed78:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ed7b:	b8 00 00 00 00       	mov    $0x0,%eax
f010ed80:	e9 b2 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010ed85:	8b 45 14             	mov    0x14(%ebp),%eax
f010ed88:	0f b6 d0             	movzbl %al,%edx
f010ed8b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed8e:	83 ec 04             	sub    $0x4,%esp
f010ed91:	52                   	push   %edx
f010ed92:	ff 75 10             	pushl  0x10(%ebp)
f010ed95:	50                   	push   %eax
f010ed96:	e8 c7 f8 ff ff       	call   f010e662 <sys_cputs>
f010ed9b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ed9e:	b8 00 00 00 00       	mov    $0x0,%eax
f010eda3:	e9 8f 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010eda8:	e8 31 f9 ff ff       	call   f010e6de <sys_cgetc>
f010edad:	e9 85 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010edb2:	e8 66 f9 ff ff       	call   f010e71d <sys_lock_cons>
		return 0;
f010edb7:	b8 00 00 00 00       	mov    $0x0,%eax
f010edbc:	e9 76 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010edc1:	e8 65 f9 ff ff       	call   f010e72b <sys_unlock_cons>
		return 0;
f010edc6:	b8 00 00 00 00       	mov    $0x0,%eax
f010edcb:	e9 67 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010edd0:	83 ec 08             	sub    $0x8,%esp
f010edd3:	ff 75 10             	pushl  0x10(%ebp)
f010edd6:	ff 75 0c             	pushl  0xc(%ebp)
f010edd9:	e8 ae fa ff ff       	call   f010e88c <sys_calculate_required_frames>
f010edde:	83 c4 10             	add    $0x10,%esp
f010ede1:	e9 51 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010ede6:	e8 c3 fa ff ff       	call   f010e8ae <sys_calculate_free_frames>
f010edeb:	e9 47 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010edf0:	e8 d8 fa ff ff       	call   f010e8cd <sys_calculate_modified_frames>
f010edf5:	e9 3d 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010edfa:	e8 e8 fa ff ff       	call   f010e8e7 <sys_calculate_notmod_frames>
f010edff:	e9 33 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010ee04:	e8 70 fb ff ff       	call   f010e979 <sys_pf_calculate_allocated_pages>
f010ee09:	e9 29 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010ee0e:	83 ec 0c             	sub    $0xc,%esp
f010ee11:	ff 75 0c             	pushl  0xc(%ebp)
f010ee14:	e8 e8 fa ff ff       	call   f010e901 <sys_calculate_pages_tobe_removed_ready_exit>
f010ee19:	83 c4 10             	add    $0x10,%esp
f010ee1c:	e9 16 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010ee21:	e8 f1 fa ff ff       	call   f010e917 <sys_scarce_memory>
		return 0;
f010ee26:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee2b:	e9 07 03 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010ee30:	83 ec 04             	sub    $0x4,%esp
f010ee33:	ff 75 14             	pushl  0x14(%ebp)
f010ee36:	ff 75 10             	pushl  0x10(%ebp)
f010ee39:	ff 75 0c             	pushl  0xc(%ebp)
f010ee3c:	e8 fc fb ff ff       	call   f010ea3d <sys_allocate_chunk>
f010ee41:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ee44:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee49:	e9 e9 02 00 00       	jmp    f010f137 <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010ee4e:	8b 55 10             	mov    0x10(%ebp),%edx
f010ee51:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee54:	83 ec 08             	sub    $0x8,%esp
f010ee57:	52                   	push   %edx
f010ee58:	50                   	push   %eax
f010ee59:	e8 db f8 ff ff       	call   f010e739 <__sys_allocate_page>
f010ee5e:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ee61:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee66:	e9 cc 02 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010ee6b:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010ee6e:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010ee71:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010ee74:	8b 55 10             	mov    0x10(%ebp),%edx
f010ee77:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee7a:	83 ec 0c             	sub    $0xc,%esp
f010ee7d:	56                   	push   %esi
f010ee7e:	53                   	push   %ebx
f010ee7f:	51                   	push   %ecx
f010ee80:	52                   	push   %edx
f010ee81:	50                   	push   %eax
f010ee82:	e8 cb f9 ff ff       	call   f010e852 <__sys_map_frame>
f010ee87:	83 c4 20             	add    $0x20,%esp
		return 0;
f010ee8a:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee8f:	e9 a3 02 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010ee94:	8b 55 10             	mov    0x10(%ebp),%edx
f010ee97:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee9a:	83 ec 08             	sub    $0x8,%esp
f010ee9d:	52                   	push   %edx
f010ee9e:	50                   	push   %eax
f010ee9f:	e8 cb f9 ff ff       	call   f010e86f <__sys_unmap_frame>
f010eea4:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eea7:	b8 00 00 00 00       	mov    $0x0,%eax
f010eeac:	e9 86 02 00 00       	jmp    f010f137 <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010eeb1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eeb4:	0f be c0             	movsbl %al,%eax
f010eeb7:	83 ec 0c             	sub    $0xc,%esp
f010eeba:	50                   	push   %eax
f010eebb:	e8 fa f7 ff ff       	call   f010e6ba <sys_cputc>
f010eec0:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eec3:	b8 00 00 00 00       	mov    $0x0,%eax
f010eec8:	e9 6a 02 00 00       	jmp    f010f137 <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010eecd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eed0:	0f be c0             	movsbl %al,%eax
f010eed3:	83 ec 0c             	sub    $0xc,%esp
f010eed6:	50                   	push   %eax
f010eed7:	e8 49 fa ff ff       	call   f010e925 <sys_clearFFL>
f010eedc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eedf:	b8 00 00 00 00       	mov    $0x0,%eax
f010eee4:	e9 4e 02 00 00       	jmp    f010f137 <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010eee9:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010eeec:	8b 45 14             	mov    0x14(%ebp),%eax
f010eeef:	0f b6 d0             	movzbl %al,%edx
f010eef2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eef5:	51                   	push   %ecx
f010eef6:	52                   	push   %edx
f010eef7:	ff 75 10             	pushl  0x10(%ebp)
f010eefa:	50                   	push   %eax
f010eefb:	e8 a6 fb ff ff       	call   f010eaa6 <sys_createSharedObject>
f010ef00:	83 c4 10             	add    $0x10,%esp
f010ef03:	e9 2f 02 00 00       	jmp    f010f137 <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010ef08:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010ef0b:	8b 55 10             	mov    0x10(%ebp),%edx
f010ef0e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef11:	83 ec 04             	sub    $0x4,%esp
f010ef14:	51                   	push   %ecx
f010ef15:	52                   	push   %edx
f010ef16:	50                   	push   %eax
f010ef17:	e8 d3 fb ff ff       	call   f010eaef <sys_getSharedObject>
f010ef1c:	83 c4 10             	add    $0x10,%esp
f010ef1f:	e9 13 02 00 00       	jmp    f010f137 <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010ef24:	8b 55 10             	mov    0x10(%ebp),%edx
f010ef27:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef2a:	83 ec 08             	sub    $0x8,%esp
f010ef2d:	52                   	push   %edx
f010ef2e:	50                   	push   %eax
f010ef2f:	e8 d7 fb ff ff       	call   f010eb0b <sys_freeSharedObject>
f010ef34:	83 c4 10             	add    $0x10,%esp
f010ef37:	e9 fb 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010ef3c:	8b 55 10             	mov    0x10(%ebp),%edx
f010ef3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef42:	83 ec 08             	sub    $0x8,%esp
f010ef45:	52                   	push   %edx
f010ef46:	50                   	push   %eax
f010ef47:	e8 8a fb ff ff       	call   f010ead6 <sys_getSizeOfSharedObject>
f010ef4c:	83 c4 10             	add    $0x10,%esp
f010ef4f:	e9 e3 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010ef54:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef57:	ff 75 18             	pushl  0x18(%ebp)
f010ef5a:	ff 75 14             	pushl  0x14(%ebp)
f010ef5d:	ff 75 10             	pushl  0x10(%ebp)
f010ef60:	50                   	push   %eax
f010ef61:	e8 d8 fc ff ff       	call   f010ec3e <sys_create_env>
f010ef66:	83 c4 10             	add    $0x10,%esp
f010ef69:	e9 c9 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010ef6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef71:	83 ec 0c             	sub    $0xc,%esp
f010ef74:	50                   	push   %eax
f010ef75:	e8 04 fd ff ff       	call   f010ec7e <sys_run_env>
f010ef7a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef7d:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef82:	e9 b0 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010ef87:	e8 a5 fb ff ff       	call   f010eb31 <sys_getenvindex>
f010ef8c:	e9 a6 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010ef91:	e8 8e fb ff ff       	call   f010eb24 <sys_getenvid>
f010ef96:	e9 9c 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010ef9b:	e8 eb fb ff ff       	call   f010eb8b <sys_getparentenvid>
f010efa0:	e9 92 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010efa5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efa8:	83 ec 0c             	sub    $0xc,%esp
f010efab:	50                   	push   %eax
f010efac:	e8 e7 fb ff ff       	call   f010eb98 <sys_destroy_env>
f010efb1:	83 c4 10             	add    $0x10,%esp
f010efb4:	e9 7e 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010efb9:	e8 72 fc ff ff       	call   f010ec30 <sys_exit_env>
		return 0;
f010efbe:	b8 00 00 00 00       	mov    $0x0,%eax
f010efc3:	e9 6f 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010efc8:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010efcb:	83 ec 0c             	sub    $0xc,%esp
f010efce:	50                   	push   %eax
f010efcf:	e8 c2 fc ff ff       	call   f010ec96 <sys_get_virtual_time>
f010efd4:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010efd7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efda:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010efdd:	8b 45 10             	mov    0x10(%ebp),%eax
f010efe0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010efe3:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010efe6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010efe9:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010efeb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010efee:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eff1:	89 10                	mov    %edx,(%eax)
		return 0;
f010eff3:	b8 00 00 00 00       	mov    $0x0,%eax
f010eff8:	e9 3a 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010effd:	83 ec 04             	sub    $0x4,%esp
f010f000:	ff 75 14             	pushl  0x14(%ebp)
f010f003:	ff 75 10             	pushl  0x10(%ebp)
f010f006:	ff 75 0c             	pushl  0xc(%ebp)
f010f009:	e8 60 fa ff ff       	call   f010ea6e <sys_move_user_mem>
f010f00e:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f011:	b8 00 00 00 00       	mov    $0x0,%eax
f010f016:	e9 1c 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010f01b:	e8 a5 fc ff ff       	call   f010ecc5 <sys_rcr2>
f010f020:	e9 12 01 00 00       	jmp    f010f137 <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010f025:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f028:	0f b6 c0             	movzbl %al,%eax
f010f02b:	83 ec 0c             	sub    $0xc,%esp
f010f02e:	50                   	push   %eax
f010f02f:	e8 a3 fc ff ff       	call   f010ecd7 <sys_bypassPageFault>
f010f034:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f037:	b8 00 00 00 00       	mov    $0x0,%eax
f010f03c:	e9 f6 00 00 00       	jmp    f010f137 <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010f041:	e8 f8 ee 00 00       	call   f011df3e <rsttst>
		return 0;
f010f046:	b8 00 00 00 00       	mov    $0x0,%eax
f010f04b:	e9 e7 00 00 00       	jmp    f010f137 <syscall+0x449>
	case SYS_inctst:
		inctst();
f010f050:	e8 31 ef 00 00       	call   f011df86 <inctst>
		return 0;
f010f055:	b8 00 00 00 00       	mov    $0x0,%eax
f010f05a:	e9 d8 00 00 00       	jmp    f010f137 <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010f05f:	83 ec 0c             	sub    $0xc,%esp
f010f062:	ff 75 0c             	pushl  0xc(%ebp)
f010f065:	e8 5e f0 00 00       	call   f011e0c8 <chktst>
f010f06a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f06d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f072:	e9 c0 00 00 00       	jmp    f010f137 <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010f077:	e8 3e ef 00 00       	call   f011dfba <gettst>
f010f07c:	e9 b6 00 00 00       	jmp    f010f137 <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010f081:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010f084:	8b 45 18             	mov    0x18(%ebp),%eax
f010f087:	0f be c0             	movsbl %al,%eax
f010f08a:	83 ec 0c             	sub    $0xc,%esp
f010f08d:	52                   	push   %edx
f010f08e:	50                   	push   %eax
f010f08f:	ff 75 14             	pushl  0x14(%ebp)
f010f092:	ff 75 10             	pushl  0x10(%ebp)
f010f095:	ff 75 0c             	pushl  0xc(%ebp)
f010f098:	e8 27 ef 00 00       	call   f011dfc4 <tst>
f010f09d:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f0a0:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0a5:	e9 8d 00 00 00       	jmp    f010f137 <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010f0aa:	e8 df f9 ff ff       	call   f010ea8e <sys_get_heap_strategy>
f010f0af:	e9 83 00 00 00       	jmp    f010f137 <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010f0b4:	83 ec 0c             	sub    $0xc,%esp
f010f0b7:	ff 75 0c             	pushl  0xc(%ebp)
f010f0ba:	e8 d9 f9 ff ff       	call   f010ea98 <sys_set_uheap_strategy>
f010f0bf:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f0c2:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0c7:	eb 6e                	jmp    f010f137 <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010f0c9:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f0cc:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f0cf:	8b 55 10             	mov    0x10(%ebp),%edx
f010f0d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0d5:	53                   	push   %ebx
f010f0d6:	51                   	push   %ecx
f010f0d7:	52                   	push   %edx
f010f0d8:	50                   	push   %eax
f010f0d9:	e8 b3 1d 00 00       	call   f0110e91 <sys_check_LRU_lists>
f010f0de:	83 c4 10             	add    $0x10,%esp
f010f0e1:	eb 54                	jmp    f010f137 <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010f0e3:	8b 55 10             	mov    0x10(%ebp),%edx
f010f0e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0e9:	83 ec 08             	sub    $0x8,%esp
f010f0ec:	52                   	push   %edx
f010f0ed:	50                   	push   %eax
f010f0ee:	e8 60 1f 00 00       	call   f0111053 <sys_check_LRU_lists_free>
f010f0f3:	83 c4 10             	add    $0x10,%esp
f010f0f6:	eb 3f                	jmp    f010f137 <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010f0f8:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f0fb:	8b 55 10             	mov    0x10(%ebp),%edx
f010f0fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f101:	51                   	push   %ecx
f010f102:	ff 75 14             	pushl  0x14(%ebp)
f010f105:	52                   	push   %edx
f010f106:	50                   	push   %eax
f010f107:	e8 d4 20 00 00       	call   f01111e0 <sys_check_WS_list>
f010f10c:	83 c4 10             	add    $0x10,%esp
f010f10f:	eb 26                	jmp    f010f137 <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010f111:	8b 55 10             	mov    0x10(%ebp),%edx
f010f114:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f117:	83 ec 08             	sub    $0x8,%esp
f010f11a:	52                   	push   %edx
f010f11b:	50                   	push   %eax
f010f11c:	e8 a8 f1 00 00       	call   f011e2c9 <sys_utilities>
f010f121:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f124:	b8 00 00 00 00       	mov    $0x0,%eax
f010f129:	eb 0c                	jmp    f010f137 <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010f12b:	b8 03 00 00 00       	mov    $0x3,%eax
f010f130:	eb 05                	jmp    f010f137 <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010f132:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010f137:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f13a:	5b                   	pop    %ebx
f010f13b:	5e                   	pop    %esi
f010f13c:	5d                   	pop    %ebp
f010f13d:	c3                   	ret    

f010f13e <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010f13e:	55                   	push   %ebp
f010f13f:	89 e5                	mov    %esp,%ebp
f010f141:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010f144:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f147:	8b 00                	mov    (%eax),%eax
f010f149:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f14c:	8b 45 10             	mov    0x10(%ebp),%eax
f010f14f:	8b 00                	mov    (%eax),%eax
f010f151:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f154:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010f15b:	e9 ca 00 00 00       	jmp    f010f22a <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010f160:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f163:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f166:	01 d0                	add    %edx,%eax
f010f168:	89 c2                	mov    %eax,%edx
f010f16a:	c1 ea 1f             	shr    $0x1f,%edx
f010f16d:	01 d0                	add    %edx,%eax
f010f16f:	d1 f8                	sar    %eax
f010f171:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f174:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f177:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f17a:	eb 03                	jmp    f010f17f <stab_binsearch+0x41>
			m--;
f010f17c:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f17f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f182:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f185:	7c 1e                	jl     f010f1a5 <stab_binsearch+0x67>
f010f187:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f18a:	89 d0                	mov    %edx,%eax
f010f18c:	01 c0                	add    %eax,%eax
f010f18e:	01 d0                	add    %edx,%eax
f010f190:	c1 e0 02             	shl    $0x2,%eax
f010f193:	89 c2                	mov    %eax,%edx
f010f195:	8b 45 08             	mov    0x8(%ebp),%eax
f010f198:	01 d0                	add    %edx,%eax
f010f19a:	8a 40 04             	mov    0x4(%eax),%al
f010f19d:	0f b6 c0             	movzbl %al,%eax
f010f1a0:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f1a3:	75 d7                	jne    f010f17c <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010f1a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f1a8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f1ab:	7d 09                	jge    f010f1b6 <stab_binsearch+0x78>
			l = true_m + 1;
f010f1ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f1b0:	40                   	inc    %eax
f010f1b1:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010f1b4:	eb 74                	jmp    f010f22a <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010f1b6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010f1bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f1c0:	89 d0                	mov    %edx,%eax
f010f1c2:	01 c0                	add    %eax,%eax
f010f1c4:	01 d0                	add    %edx,%eax
f010f1c6:	c1 e0 02             	shl    $0x2,%eax
f010f1c9:	89 c2                	mov    %eax,%edx
f010f1cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010f1ce:	01 d0                	add    %edx,%eax
f010f1d0:	8b 40 08             	mov    0x8(%eax),%eax
f010f1d3:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f1d6:	73 11                	jae    f010f1e9 <stab_binsearch+0xab>
			*region_left = m;
f010f1d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1db:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f1de:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010f1e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f1e3:	40                   	inc    %eax
f010f1e4:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f1e7:	eb 41                	jmp    f010f22a <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010f1e9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f1ec:	89 d0                	mov    %edx,%eax
f010f1ee:	01 c0                	add    %eax,%eax
f010f1f0:	01 d0                	add    %edx,%eax
f010f1f2:	c1 e0 02             	shl    $0x2,%eax
f010f1f5:	89 c2                	mov    %eax,%edx
f010f1f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010f1fa:	01 d0                	add    %edx,%eax
f010f1fc:	8b 40 08             	mov    0x8(%eax),%eax
f010f1ff:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f202:	76 14                	jbe    f010f218 <stab_binsearch+0xda>
			*region_right = m - 1;
f010f204:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f207:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f20a:	8b 45 10             	mov    0x10(%ebp),%eax
f010f20d:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010f20f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f212:	48                   	dec    %eax
f010f213:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f216:	eb 12                	jmp    f010f22a <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010f218:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f21b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f21e:	89 10                	mov    %edx,(%eax)
			l = m;
f010f220:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f223:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010f226:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010f22a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f22d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010f230:	0f 8e 2a ff ff ff    	jle    f010f160 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010f236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f23a:	75 0f                	jne    f010f24b <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010f23c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f23f:	8b 00                	mov    (%eax),%eax
f010f241:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f244:	8b 45 10             	mov    0x10(%ebp),%eax
f010f247:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010f249:	eb 3d                	jmp    f010f288 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f24b:	8b 45 10             	mov    0x10(%ebp),%eax
f010f24e:	8b 00                	mov    (%eax),%eax
f010f250:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f253:	eb 03                	jmp    f010f258 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010f255:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010f258:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f25b:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f25d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f260:	7d 1e                	jge    f010f280 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010f262:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f265:	89 d0                	mov    %edx,%eax
f010f267:	01 c0                	add    %eax,%eax
f010f269:	01 d0                	add    %edx,%eax
f010f26b:	c1 e0 02             	shl    $0x2,%eax
f010f26e:	89 c2                	mov    %eax,%edx
f010f270:	8b 45 08             	mov    0x8(%ebp),%eax
f010f273:	01 d0                	add    %edx,%eax
f010f275:	8a 40 04             	mov    0x4(%eax),%al
f010f278:	0f b6 c0             	movzbl %al,%eax
f010f27b:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f27e:	75 d5                	jne    f010f255 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010f280:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f283:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f286:	89 10                	mov    %edx,(%eax)
	}
}
f010f288:	90                   	nop
f010f289:	c9                   	leave  
f010f28a:	c3                   	ret    

f010f28b <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010f28b:	55                   	push   %ebp
f010f28c:	89 e5                	mov    %esp,%ebp
f010f28e:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010f291:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f294:	c7 00 08 78 12 f0    	movl   $0xf0127808,(%eax)
	info->eip_line = 0;
f010f29a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f29d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010f2a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2a7:	c7 40 08 08 78 12 f0 	movl   $0xf0127808,0x8(%eax)
	info->eip_fn_namelen = 9;
f010f2ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2b1:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010f2b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2bb:	8b 55 08             	mov    0x8(%ebp),%edx
f010f2be:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010f2c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2c4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010f2cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010f2ce:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010f2d3:	76 1e                	jbe    f010f2f3 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010f2d5:	c7 45 f4 9c 15 13 f0 	movl   $0xf013159c,-0xc(%ebp)
		stab_end = __STAB_END__;
f010f2dc:	c7 45 f0 18 4e 16 f0 	movl   $0xf0164e18,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010f2e3:	c7 45 ec 19 4e 16 f0 	movl   $0xf0164e19,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010f2ea:	c7 45 e8 7b 67 17 f0 	movl   $0xf017677b,-0x18(%ebp)
f010f2f1:	eb 2a                	jmp    f010f31d <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010f2f3:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010f2fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f2fd:	8b 00                	mov    (%eax),%eax
f010f2ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010f302:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f305:	8b 40 04             	mov    0x4(%eax),%eax
f010f308:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010f30b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f30e:	8b 40 08             	mov    0x8(%eax),%eax
f010f311:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010f314:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f317:	8b 40 0c             	mov    0xc(%eax),%eax
f010f31a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010f31d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f320:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f323:	76 0a                	jbe    f010f32f <debuginfo_eip+0xa4>
f010f325:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f328:	48                   	dec    %eax
f010f329:	8a 00                	mov    (%eax),%al
f010f32b:	84 c0                	test   %al,%al
f010f32d:	74 0a                	je     f010f339 <debuginfo_eip+0xae>
		return -1;
f010f32f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f334:	e9 01 02 00 00       	jmp    f010f53a <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010f339:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010f340:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f343:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f346:	29 c2                	sub    %eax,%edx
f010f348:	89 d0                	mov    %edx,%eax
f010f34a:	c1 f8 02             	sar    $0x2,%eax
f010f34d:	89 c2                	mov    %eax,%edx
f010f34f:	89 d0                	mov    %edx,%eax
f010f351:	c1 e0 02             	shl    $0x2,%eax
f010f354:	01 d0                	add    %edx,%eax
f010f356:	c1 e0 02             	shl    $0x2,%eax
f010f359:	01 d0                	add    %edx,%eax
f010f35b:	c1 e0 02             	shl    $0x2,%eax
f010f35e:	01 d0                	add    %edx,%eax
f010f360:	89 c1                	mov    %eax,%ecx
f010f362:	c1 e1 08             	shl    $0x8,%ecx
f010f365:	01 c8                	add    %ecx,%eax
f010f367:	89 c1                	mov    %eax,%ecx
f010f369:	c1 e1 10             	shl    $0x10,%ecx
f010f36c:	01 c8                	add    %ecx,%eax
f010f36e:	01 c0                	add    %eax,%eax
f010f370:	01 d0                	add    %edx,%eax
f010f372:	48                   	dec    %eax
f010f373:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010f376:	ff 75 08             	pushl  0x8(%ebp)
f010f379:	6a 64                	push   $0x64
f010f37b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010f37e:	50                   	push   %eax
f010f37f:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f382:	50                   	push   %eax
f010f383:	ff 75 f4             	pushl  -0xc(%ebp)
f010f386:	e8 b3 fd ff ff       	call   f010f13e <stab_binsearch>
f010f38b:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010f38e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f391:	85 c0                	test   %eax,%eax
f010f393:	75 0a                	jne    f010f39f <debuginfo_eip+0x114>
		return -1;
f010f395:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f39a:	e9 9b 01 00 00       	jmp    f010f53a <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010f39f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f3a2:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010f3a5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f3a8:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010f3ab:	ff 75 08             	pushl  0x8(%ebp)
f010f3ae:	6a 24                	push   $0x24
f010f3b0:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010f3b3:	50                   	push   %eax
f010f3b4:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010f3b7:	50                   	push   %eax
f010f3b8:	ff 75 f4             	pushl  -0xc(%ebp)
f010f3bb:	e8 7e fd ff ff       	call   f010f13e <stab_binsearch>
f010f3c0:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010f3c3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010f3c6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f3c9:	39 c2                	cmp    %eax,%edx
f010f3cb:	0f 8f 86 00 00 00    	jg     f010f457 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010f3d1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f3d4:	89 c2                	mov    %eax,%edx
f010f3d6:	89 d0                	mov    %edx,%eax
f010f3d8:	01 c0                	add    %eax,%eax
f010f3da:	01 d0                	add    %edx,%eax
f010f3dc:	c1 e0 02             	shl    $0x2,%eax
f010f3df:	89 c2                	mov    %eax,%edx
f010f3e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f3e4:	01 d0                	add    %edx,%eax
f010f3e6:	8b 00                	mov    (%eax),%eax
f010f3e8:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f3eb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f3ee:	29 d1                	sub    %edx,%ecx
f010f3f0:	89 ca                	mov    %ecx,%edx
f010f3f2:	39 d0                	cmp    %edx,%eax
f010f3f4:	73 22                	jae    f010f418 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010f3f6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f3f9:	89 c2                	mov    %eax,%edx
f010f3fb:	89 d0                	mov    %edx,%eax
f010f3fd:	01 c0                	add    %eax,%eax
f010f3ff:	01 d0                	add    %edx,%eax
f010f401:	c1 e0 02             	shl    $0x2,%eax
f010f404:	89 c2                	mov    %eax,%edx
f010f406:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f409:	01 d0                	add    %edx,%eax
f010f40b:	8b 10                	mov    (%eax),%edx
f010f40d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f410:	01 c2                	add    %eax,%edx
f010f412:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f415:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010f418:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f41b:	89 c2                	mov    %eax,%edx
f010f41d:	89 d0                	mov    %edx,%eax
f010f41f:	01 c0                	add    %eax,%eax
f010f421:	01 d0                	add    %edx,%eax
f010f423:	c1 e0 02             	shl    $0x2,%eax
f010f426:	89 c2                	mov    %eax,%edx
f010f428:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f42b:	01 d0                	add    %edx,%eax
f010f42d:	8b 50 08             	mov    0x8(%eax),%edx
f010f430:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f433:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010f436:	8b 55 08             	mov    0x8(%ebp),%edx
f010f439:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f43c:	8b 40 10             	mov    0x10(%eax),%eax
f010f43f:	29 c2                	sub    %eax,%edx
f010f441:	89 d0                	mov    %edx,%eax
f010f443:	c1 f8 02             	sar    $0x2,%eax
f010f446:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010f449:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f44c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010f44f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f452:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f455:	eb 15                	jmp    f010f46c <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010f457:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f45a:	8b 55 08             	mov    0x8(%ebp),%edx
f010f45d:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010f460:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f463:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010f466:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f469:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010f46c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f46f:	8b 40 08             	mov    0x8(%eax),%eax
f010f472:	83 ec 08             	sub    $0x8,%esp
f010f475:	6a 3a                	push   $0x3a
f010f477:	50                   	push   %eax
f010f478:	e8 0d 09 01 00       	call   f011fd8a <strfind>
f010f47d:	83 c4 10             	add    $0x10,%esp
f010f480:	89 c2                	mov    %eax,%edx
f010f482:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f485:	8b 40 08             	mov    0x8(%eax),%eax
f010f488:	29 c2                	sub    %eax,%edx
f010f48a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f48d:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f490:	eb 03                	jmp    f010f495 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010f492:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f495:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f498:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f49b:	7c 4e                	jl     f010f4eb <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010f49d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f4a0:	89 d0                	mov    %edx,%eax
f010f4a2:	01 c0                	add    %eax,%eax
f010f4a4:	01 d0                	add    %edx,%eax
f010f4a6:	c1 e0 02             	shl    $0x2,%eax
f010f4a9:	89 c2                	mov    %eax,%edx
f010f4ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f4ae:	01 d0                	add    %edx,%eax
f010f4b0:	8a 40 04             	mov    0x4(%eax),%al
f010f4b3:	3c 84                	cmp    $0x84,%al
f010f4b5:	74 34                	je     f010f4eb <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010f4b7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f4ba:	89 d0                	mov    %edx,%eax
f010f4bc:	01 c0                	add    %eax,%eax
f010f4be:	01 d0                	add    %edx,%eax
f010f4c0:	c1 e0 02             	shl    $0x2,%eax
f010f4c3:	89 c2                	mov    %eax,%edx
f010f4c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f4c8:	01 d0                	add    %edx,%eax
f010f4ca:	8a 40 04             	mov    0x4(%eax),%al
f010f4cd:	3c 64                	cmp    $0x64,%al
f010f4cf:	75 c1                	jne    f010f492 <debuginfo_eip+0x207>
f010f4d1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f4d4:	89 d0                	mov    %edx,%eax
f010f4d6:	01 c0                	add    %eax,%eax
f010f4d8:	01 d0                	add    %edx,%eax
f010f4da:	c1 e0 02             	shl    $0x2,%eax
f010f4dd:	89 c2                	mov    %eax,%edx
f010f4df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f4e2:	01 d0                	add    %edx,%eax
f010f4e4:	8b 40 08             	mov    0x8(%eax),%eax
f010f4e7:	85 c0                	test   %eax,%eax
f010f4e9:	74 a7                	je     f010f492 <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010f4eb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f4ee:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f4f1:	7c 42                	jl     f010f535 <debuginfo_eip+0x2aa>
f010f4f3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f4f6:	89 d0                	mov    %edx,%eax
f010f4f8:	01 c0                	add    %eax,%eax
f010f4fa:	01 d0                	add    %edx,%eax
f010f4fc:	c1 e0 02             	shl    $0x2,%eax
f010f4ff:	89 c2                	mov    %eax,%edx
f010f501:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f504:	01 d0                	add    %edx,%eax
f010f506:	8b 00                	mov    (%eax),%eax
f010f508:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f50b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f50e:	29 d1                	sub    %edx,%ecx
f010f510:	89 ca                	mov    %ecx,%edx
f010f512:	39 d0                	cmp    %edx,%eax
f010f514:	73 1f                	jae    f010f535 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010f516:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f519:	89 d0                	mov    %edx,%eax
f010f51b:	01 c0                	add    %eax,%eax
f010f51d:	01 d0                	add    %edx,%eax
f010f51f:	c1 e0 02             	shl    $0x2,%eax
f010f522:	89 c2                	mov    %eax,%edx
f010f524:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f527:	01 d0                	add    %edx,%eax
f010f529:	8b 10                	mov    (%eax),%edx
f010f52b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f52e:	01 c2                	add    %eax,%edx
f010f530:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f533:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010f535:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f53a:	c9                   	leave  
f010f53b:	c3                   	ret    

f010f53c <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010f53c:	55                   	push   %ebp
f010f53d:	89 e5                	mov    %esp,%ebp
f010f53f:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010f542:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f546:	74 1c                	je     f010f564 <setPageReplacmentAlgorithmLRU+0x28>
f010f548:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f54c:	74 16                	je     f010f564 <setPageReplacmentAlgorithmLRU+0x28>
f010f54e:	68 14 78 12 f0       	push   $0xf0127814
f010f553:	68 5e 78 12 f0       	push   $0xf012785e
f010f558:	6a 1a                	push   $0x1a
f010f55a:	68 73 78 12 f0       	push   $0xf0127873
f010f55f:	e8 d5 0d ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010f564:	8b 45 08             	mov    0x8(%ebp),%eax
f010f567:	a3 30 0d 6c f0       	mov    %eax,0xf06c0d30
}
f010f56c:	90                   	nop
f010f56d:	c9                   	leave  
f010f56e:	c3                   	ret    

f010f56f <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010f56f:	55                   	push   %ebp
f010f570:	89 e5                	mov    %esp,%ebp
f010f572:	c7 05 30 0d 6c f0 03 	movl   $0x3,0xf06c0d30
f010f579:	00 00 00 
f010f57c:	90                   	nop
f010f57d:	5d                   	pop    %ebp
f010f57e:	c3                   	ret    

f010f57f <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010f57f:	55                   	push   %ebp
f010f580:	89 e5                	mov    %esp,%ebp
f010f582:	c7 05 30 0d 6c f0 04 	movl   $0x4,0xf06c0d30
f010f589:	00 00 00 
f010f58c:	90                   	nop
f010f58d:	5d                   	pop    %ebp
f010f58e:	c3                   	ret    

f010f58f <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010f58f:	55                   	push   %ebp
f010f590:	89 e5                	mov    %esp,%ebp
f010f592:	c7 05 30 0d 6c f0 05 	movl   $0x5,0xf06c0d30
f010f599:	00 00 00 
f010f59c:	90                   	nop
f010f59d:	5d                   	pop    %ebp
f010f59e:	c3                   	ret    

f010f59f <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010f59f:	55                   	push   %ebp
f010f5a0:	89 e5                	mov    %esp,%ebp
f010f5a2:	c7 05 30 0d 6c f0 07 	movl   $0x7,0xf06c0d30
f010f5a9:	00 00 00 
f010f5ac:	90                   	nop
f010f5ad:	5d                   	pop    %ebp
f010f5ae:	c3                   	ret    

f010f5af <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010f5af:	55                   	push   %ebp
f010f5b0:	89 e5                	mov    %esp,%ebp
f010f5b2:	c7 05 30 0d 6c f0 06 	movl   $0x6,0xf06c0d30
f010f5b9:	00 00 00 
f010f5bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5bf:	a3 74 06 6c f0       	mov    %eax,0xf06c0674
f010f5c4:	90                   	nop
f010f5c5:	5d                   	pop    %ebp
f010f5c6:	c3                   	ret    

f010f5c7 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010f5c7:	55                   	push   %ebp
f010f5c8:	89 e5                	mov    %esp,%ebp
f010f5ca:	8b 15 30 0d 6c f0    	mov    0xf06c0d30,%edx
f010f5d0:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5d3:	39 c2                	cmp    %eax,%edx
f010f5d5:	0f 94 c0             	sete   %al
f010f5d8:	0f b6 c0             	movzbl %al,%eax
f010f5db:	5d                   	pop    %ebp
f010f5dc:	c3                   	ret    

f010f5dd <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010f5dd:	55                   	push   %ebp
f010f5de:	89 e5                	mov    %esp,%ebp
f010f5e0:	a1 30 0d 6c f0       	mov    0xf06c0d30,%eax
f010f5e5:	83 f8 03             	cmp    $0x3,%eax
f010f5e8:	75 07                	jne    f010f5f1 <isPageReplacmentAlgorithmCLOCK+0x14>
f010f5ea:	b8 01 00 00 00       	mov    $0x1,%eax
f010f5ef:	eb 05                	jmp    f010f5f6 <isPageReplacmentAlgorithmCLOCK+0x19>
f010f5f1:	b8 00 00 00 00       	mov    $0x0,%eax
f010f5f6:	5d                   	pop    %ebp
f010f5f7:	c3                   	ret    

f010f5f8 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010f5f8:	55                   	push   %ebp
f010f5f9:	89 e5                	mov    %esp,%ebp
f010f5fb:	a1 30 0d 6c f0       	mov    0xf06c0d30,%eax
f010f600:	83 f8 04             	cmp    $0x4,%eax
f010f603:	75 07                	jne    f010f60c <isPageReplacmentAlgorithmFIFO+0x14>
f010f605:	b8 01 00 00 00       	mov    $0x1,%eax
f010f60a:	eb 05                	jmp    f010f611 <isPageReplacmentAlgorithmFIFO+0x19>
f010f60c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f611:	5d                   	pop    %ebp
f010f612:	c3                   	ret    

f010f613 <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010f613:	55                   	push   %ebp
f010f614:	89 e5                	mov    %esp,%ebp
f010f616:	a1 30 0d 6c f0       	mov    0xf06c0d30,%eax
f010f61b:	83 f8 05             	cmp    $0x5,%eax
f010f61e:	75 07                	jne    f010f627 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010f620:	b8 01 00 00 00       	mov    $0x1,%eax
f010f625:	eb 05                	jmp    f010f62c <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010f627:	b8 00 00 00 00       	mov    $0x0,%eax
f010f62c:	5d                   	pop    %ebp
f010f62d:	c3                   	ret    

f010f62e <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010f62e:	55                   	push   %ebp
f010f62f:	89 e5                	mov    %esp,%ebp
f010f631:	a1 30 0d 6c f0       	mov    0xf06c0d30,%eax
f010f636:	83 f8 07             	cmp    $0x7,%eax
f010f639:	75 07                	jne    f010f642 <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010f63b:	b8 01 00 00 00       	mov    $0x1,%eax
f010f640:	eb 05                	jmp    f010f647 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010f642:	b8 00 00 00 00       	mov    $0x0,%eax
f010f647:	5d                   	pop    %ebp
f010f648:	c3                   	ret    

f010f649 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010f649:	55                   	push   %ebp
f010f64a:	89 e5                	mov    %esp,%ebp
f010f64c:	a1 30 0d 6c f0       	mov    0xf06c0d30,%eax
f010f651:	83 f8 06             	cmp    $0x6,%eax
f010f654:	75 07                	jne    f010f65d <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010f656:	b8 01 00 00 00       	mov    $0x1,%eax
f010f65b:	eb 05                	jmp    f010f662 <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010f65d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f662:	5d                   	pop    %ebp
f010f663:	c3                   	ret    

f010f664 <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010f664:	55                   	push   %ebp
f010f665:	89 e5                	mov    %esp,%ebp
f010f667:	8b 45 08             	mov    0x8(%ebp),%eax
f010f66a:	a3 d8 0a 6c f0       	mov    %eax,0xf06c0ad8
f010f66f:	90                   	nop
f010f670:	5d                   	pop    %ebp
f010f671:	c3                   	ret    

f010f672 <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010f672:	55                   	push   %ebp
f010f673:	89 e5                	mov    %esp,%ebp
f010f675:	a1 d8 0a 6c f0       	mov    0xf06c0ad8,%eax
f010f67a:	5d                   	pop    %ebp
f010f67b:	c3                   	ret    

f010f67c <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010f67c:	55                   	push   %ebp
f010f67d:	89 e5                	mov    %esp,%ebp
f010f67f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f682:	a3 b4 0d 6c f0       	mov    %eax,0xf06c0db4
f010f687:	90                   	nop
f010f688:	5d                   	pop    %ebp
f010f689:	c3                   	ret    

f010f68a <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010f68a:	55                   	push   %ebp
f010f68b:	89 e5                	mov    %esp,%ebp
f010f68d:	a1 b4 0d 6c f0       	mov    0xf06c0db4,%eax
f010f692:	5d                   	pop    %ebp
f010f693:	c3                   	ret    

f010f694 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010f694:	55                   	push   %ebp
f010f695:	89 e5                	mov    %esp,%ebp
f010f697:	8b 45 08             	mov    0x8(%ebp),%eax
f010f69a:	a3 50 0e 6c f0       	mov    %eax,0xf06c0e50
f010f69f:	90                   	nop
f010f6a0:	5d                   	pop    %ebp
f010f6a1:	c3                   	ret    

f010f6a2 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010f6a2:	55                   	push   %ebp
f010f6a3:	89 e5                	mov    %esp,%ebp
f010f6a5:	a1 50 0e 6c f0       	mov    0xf06c0e50,%eax
f010f6aa:	5d                   	pop    %ebp
f010f6ab:	c3                   	ret    

f010f6ac <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010f6ac:	55                   	push   %ebp
f010f6ad:	89 e5                	mov    %esp,%ebp
f010f6af:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f6b2:	0f 20 d0             	mov    %cr2,%eax
f010f6b5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010f6b8:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010f6bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010f6be:	e8 c8 c2 ff ff       	call   f010b98b <get_cpu_proc>
f010f6c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010f6c6:	a1 6c 83 69 f0       	mov    0xf069836c,%eax
f010f6cb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f6ce:	75 50                	jne    f010f720 <fault_handler+0x74>
f010f6d0:	a1 78 83 69 f0       	mov    0xf0698378,%eax
f010f6d5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f6d8:	75 46                	jne    f010f720 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010f6da:	a0 74 83 69 f0       	mov    0xf0698374,%al
f010f6df:	40                   	inc    %eax
f010f6e0:	a2 74 83 69 f0       	mov    %al,0xf0698374
		if (num_repeated_fault == 3)
f010f6e5:	a0 74 83 69 f0       	mov    0xf0698374,%al
f010f6ea:	3c 03                	cmp    $0x3,%al
f010f6ec:	75 4d                	jne    f010f73b <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010f6ee:	83 ec 0c             	sub    $0xc,%esp
f010f6f1:	ff 75 08             	pushl  0x8(%ebp)
f010f6f4:	e8 48 e9 ff ff       	call   f010e041 <print_trapframe>
f010f6f9:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010f6fc:	8b 15 68 83 69 f0    	mov    0xf0698368,%edx
f010f702:	a1 70 83 69 f0       	mov    0xf0698370,%eax
f010f707:	83 ec 08             	sub    $0x8,%esp
f010f70a:	ff 75 ec             	pushl  -0x14(%ebp)
f010f70d:	52                   	push   %edx
f010f70e:	50                   	push   %eax
f010f70f:	68 90 78 12 f0       	push   $0xf0127890
f010f714:	6a 58                	push   $0x58
f010f716:	68 73 78 12 f0       	push   $0xf0127873
f010f71b:	e8 19 0c ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010f720:	a1 6c 83 69 f0       	mov    0xf069836c,%eax
f010f725:	a3 70 83 69 f0       	mov    %eax,0xf0698370
		before_last_eip = last_eip;
f010f72a:	a1 64 83 69 f0       	mov    0xf0698364,%eax
f010f72f:	a3 68 83 69 f0       	mov    %eax,0xf0698368
		num_repeated_fault = 0;
f010f734:	c6 05 74 83 69 f0 00 	movb   $0x0,0xf0698374
	}
	last_eip = (uint32)tf->tf_eip;
f010f73b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f73e:	8b 40 30             	mov    0x30(%eax),%eax
f010f741:	a3 64 83 69 f0       	mov    %eax,0xf0698364
	last_fault_va = fault_va ;
f010f746:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f749:	a3 6c 83 69 f0       	mov    %eax,0xf069836c
	last_faulted_env = cur_env;
f010f74e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f751:	a3 78 83 69 f0       	mov    %eax,0xf0698378
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010f756:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010f75d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f760:	8b 40 34             	mov    0x34(%eax),%eax
f010f763:	0f b7 c0             	movzwl %ax,%eax
f010f766:	83 e0 03             	and    $0x3,%eax
f010f769:	83 f8 03             	cmp    $0x3,%eax
f010f76c:	75 07                	jne    f010f775 <fault_handler+0xc9>
		userTrap = 1;
f010f76e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010f775:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f779:	0f 85 c2 00 00 00    	jne    f010f841 <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010f77f:	e8 88 79 ff ff       	call   f010710c <mycpu>
f010f784:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010f787:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010f78b:	74 2f                	je     f010f7bc <fault_handler+0x110>
f010f78d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f790:	8b 40 70             	mov    0x70(%eax),%eax
f010f793:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f796:	77 24                	ja     f010f7bc <fault_handler+0x110>
f010f798:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f79b:	8b 40 70             	mov    0x70(%eax),%eax
f010f79e:	05 00 10 00 00       	add    $0x1000,%eax
f010f7a3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f7a6:	76 14                	jbe    f010f7bc <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010f7a8:	83 ec 04             	sub    $0x4,%esp
f010f7ab:	68 00 79 12 f0       	push   $0xf0127900
f010f7b0:	6a 6f                	push   $0x6f
f010f7b2:	68 73 78 12 f0       	push   $0xf0127873
f010f7b7:	e8 7d 0b ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010f7bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f7bf:	8b 40 08             	mov    0x8(%eax),%eax
f010f7c2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f7c5:	77 5d                	ja     f010f824 <fault_handler+0x178>
f010f7c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f7ca:	8b 40 08             	mov    0x8(%eax),%eax
f010f7cd:	05 00 10 00 00       	add    $0x1000,%eax
f010f7d2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f7d5:	76 4d                	jbe    f010f824 <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010f7d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f7da:	ba c0 07 6c f0       	mov    $0xf06c07c0,%edx
f010f7df:	29 d0                	sub    %edx,%eax
f010f7e1:	c1 f8 03             	sar    $0x3,%eax
f010f7e4:	89 c2                	mov    %eax,%edx
f010f7e6:	89 d0                	mov    %edx,%eax
f010f7e8:	c1 e0 02             	shl    $0x2,%eax
f010f7eb:	01 d0                	add    %edx,%eax
f010f7ed:	01 c0                	add    %eax,%eax
f010f7ef:	01 d0                	add    %edx,%eax
f010f7f1:	c1 e0 03             	shl    $0x3,%eax
f010f7f4:	01 d0                	add    %edx,%eax
f010f7f6:	89 c1                	mov    %eax,%ecx
f010f7f8:	c1 e1 0b             	shl    $0xb,%ecx
f010f7fb:	01 c8                	add    %ecx,%eax
f010f7fd:	c1 e0 05             	shl    $0x5,%eax
f010f800:	01 d0                	add    %edx,%eax
f010f802:	c1 e0 02             	shl    $0x2,%eax
f010f805:	01 d0                	add    %edx,%eax
f010f807:	01 c0                	add    %eax,%eax
f010f809:	01 d0                	add    %edx,%eax
f010f80b:	c1 e0 03             	shl    $0x3,%eax
f010f80e:	01 d0                	add    %edx,%eax
f010f810:	f7 d8                	neg    %eax
f010f812:	50                   	push   %eax
f010f813:	68 28 79 12 f0       	push   $0xf0127928
f010f818:	6a 71                	push   $0x71
f010f81a:	68 73 78 12 f0       	push   $0xf0127873
f010f81f:	e8 15 0b ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010f824:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010f82b:	76 3a                	jbe    f010f867 <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010f82d:	83 ec 04             	sub    $0x4,%esp
f010f830:	68 5c 79 12 f0       	push   $0xf012795c
f010f835:	6a 74                	push   $0x74
f010f837:	68 73 78 12 f0       	push   $0xf0127873
f010f83c:	e8 f8 0a ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010f841:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010f848:	76 1d                	jbe    f010f867 <fault_handler+0x1bb>
f010f84a:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010f851:	77 14                	ja     f010f867 <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010f853:	83 ec 04             	sub    $0x4,%esp
f010f856:	68 80 79 12 f0       	push   $0xf0127980
f010f85b:	6a 7c                	push   $0x7c
f010f85d:	68 73 78 12 f0       	push   $0xf0127873
f010f862:	e8 d2 0a ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010f867:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f86a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010f86d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010f871:	75 25                	jne    f010f898 <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010f873:	83 ec 0c             	sub    $0xc,%esp
f010f876:	ff 75 08             	pushl  0x8(%ebp)
f010f879:	e8 c3 e7 ff ff       	call   f010e041 <print_trapframe>
f010f87e:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010f881:	83 ec 04             	sub    $0x4,%esp
f010f884:	68 a1 79 12 f0       	push   $0xf01279a1
f010f889:	68 85 00 00 00       	push   $0x85
f010f88e:	68 73 78 12 f0       	push   $0xf0127873
f010f893:	e8 a1 0a ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010f898:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f89b:	8b 40 64             	mov    0x64(%eax),%eax
f010f89e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f8a1:	c1 ea 16             	shr    $0x16,%edx
f010f8a4:	c1 e2 02             	shl    $0x2,%edx
f010f8a7:	01 d0                	add    %edx,%eax
f010f8a9:	8b 00                	mov    (%eax),%eax
f010f8ab:	83 e0 01             	and    $0x1,%eax
f010f8ae:	85 c0                	test   %eax,%eax
f010f8b0:	75 2b                	jne    f010f8dd <fault_handler+0x231>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010f8b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f8b5:	8b 80 94 05 00 00    	mov    0x594(%eax),%eax
f010f8bb:	8d 50 01             	lea    0x1(%eax),%edx
f010f8be:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f8c1:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		table_fault_handler(faulted_env, fault_va);
f010f8c7:	83 ec 08             	sub    $0x8,%esp
f010f8ca:	ff 75 ec             	pushl  -0x14(%ebp)
f010f8cd:	ff 75 e0             	pushl  -0x20(%ebp)
f010f8d0:	e8 1e 01 00 00       	call   f010f9f3 <table_fault_handler>
f010f8d5:	83 c4 10             	add    $0x10,%esp
f010f8d8:	e9 07 01 00 00       	jmp    f010f9e4 <fault_handler+0x338>
	}
	else
	{
		if (userTrap)
f010f8dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f8e1:	0f 84 82 00 00 00    	je     f010f969 <fault_handler+0x2bd>
		{
			//============================================================================================
			//TODO: [PROJECT'24.MS2 - #08] [2] FAULT HANDLER I - Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
			if (fault_va >= USER_LIMIT)
f010f8e7:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f010f8ee:	76 07                	jbe    f010f8f7 <fault_handler+0x24b>
			{
				env_exit();
f010f8f0:	e8 54 c0 ff ff       	call   f010b949 <env_exit>
f010f8f5:	eb 72                	jmp    f010f969 <fault_handler+0x2bd>
			}
			else if(((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_MARKED) != PERM_MARKED) && (fault_va>=USER_HEAP_START && fault_va<=USER_HEAP_MAX))
f010f8f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f8fa:	8b 40 64             	mov    0x64(%eax),%eax
f010f8fd:	83 ec 08             	sub    $0x8,%esp
f010f900:	ff 75 ec             	pushl  -0x14(%ebp)
f010f903:	50                   	push   %eax
f010f904:	e8 86 a3 ff ff       	call   f0109c8f <pt_get_page_permissions>
f010f909:	83 c4 10             	add    $0x10,%esp
f010f90c:	25 00 02 00 00       	and    $0x200,%eax
f010f911:	85 c0                	test   %eax,%eax
f010f913:	75 17                	jne    f010f92c <fault_handler+0x280>
f010f915:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f918:	85 c0                	test   %eax,%eax
f010f91a:	79 10                	jns    f010f92c <fault_handler+0x280>
f010f91c:	81 7d ec 00 00 00 a0 	cmpl   $0xa0000000,-0x14(%ebp)
f010f923:	77 07                	ja     f010f92c <fault_handler+0x280>
			{
				env_exit();
f010f925:	e8 1f c0 ff ff       	call   f010b949 <env_exit>
f010f92a:	eb 3d                	jmp    f010f969 <fault_handler+0x2bd>
			}
			else if ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_PRESENT) && ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_WRITEABLE)))
f010f92c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f92f:	8b 40 64             	mov    0x64(%eax),%eax
f010f932:	83 ec 08             	sub    $0x8,%esp
f010f935:	ff 75 ec             	pushl  -0x14(%ebp)
f010f938:	50                   	push   %eax
f010f939:	e8 51 a3 ff ff       	call   f0109c8f <pt_get_page_permissions>
f010f93e:	83 c4 10             	add    $0x10,%esp
f010f941:	83 e0 01             	and    $0x1,%eax
f010f944:	85 c0                	test   %eax,%eax
f010f946:	74 21                	je     f010f969 <fault_handler+0x2bd>
f010f948:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f94b:	8b 40 64             	mov    0x64(%eax),%eax
f010f94e:	83 ec 08             	sub    $0x8,%esp
f010f951:	ff 75 ec             	pushl  -0x14(%ebp)
f010f954:	50                   	push   %eax
f010f955:	e8 35 a3 ff ff       	call   f0109c8f <pt_get_page_permissions>
f010f95a:	83 c4 10             	add    $0x10,%esp
f010f95d:	83 e0 02             	and    $0x2,%eax
f010f960:	85 c0                	test   %eax,%eax
f010f962:	74 05                	je     f010f969 <fault_handler+0x2bd>
			{
				env_exit();
f010f964:	e8 e0 bf ff ff       	call   f010b949 <env_exit>
			}
			//============================================================================================
		}

		//2022: Check if fault due to Access Rights
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010f969:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f96c:	8b 40 64             	mov    0x64(%eax),%eax
f010f96f:	83 ec 08             	sub    $0x8,%esp
f010f972:	ff 75 ec             	pushl  -0x14(%ebp)
f010f975:	50                   	push   %eax
f010f976:	e8 14 a3 ff ff       	call   f0109c8f <pt_get_page_permissions>
f010f97b:	83 c4 10             	add    $0x10,%esp
f010f97e:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010f981:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f984:	83 e0 01             	and    $0x1,%eax
f010f987:	85 c0                	test   %eax,%eax
f010f989:	74 17                	je     f010f9a2 <fault_handler+0x2f6>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010f98b:	ff 75 ec             	pushl  -0x14(%ebp)
f010f98e:	68 b8 79 12 f0       	push   $0xf01279b8
f010f993:	68 ad 00 00 00       	push   $0xad
f010f998:	68 73 78 12 f0       	push   $0xf0127873
f010f99d:	e8 97 09 ff ff       	call   f0100339 <_panic>
		//============================================================================================


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010f9a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9a5:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f010f9ab:	8d 50 01             	lea    0x1(%eax),%edx
f010f9ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9b1:	89 90 90 05 00 00    	mov    %edx,0x590(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010f9b7:	e8 ce fc ff ff       	call   f010f68a <isBufferingEnabled>
f010f9bc:	84 c0                	test   %al,%al
f010f9be:	74 13                	je     f010f9d3 <fault_handler+0x327>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010f9c0:	83 ec 08             	sub    $0x8,%esp
f010f9c3:	ff 75 ec             	pushl  -0x14(%ebp)
f010f9c6:	ff 75 e0             	pushl  -0x20(%ebp)
f010f9c9:	e8 fe 01 00 00       	call   f010fbcc <__page_fault_handler_with_buffering>
f010f9ce:	83 c4 10             	add    $0x10,%esp
f010f9d1:	eb 11                	jmp    f010f9e4 <fault_handler+0x338>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010f9d3:	83 ec 08             	sub    $0x8,%esp
f010f9d6:	ff 75 ec             	pushl  -0x14(%ebp)
f010f9d9:	ff 75 e0             	pushl  -0x20(%ebp)
f010f9dc:	e8 33 00 00 00       	call   f010fa14 <page_fault_handler>
f010f9e1:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010f9e4:	0f 20 d8             	mov    %cr3,%eax
f010f9e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010f9ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f9ed:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010f9f0:	90                   	nop
f010f9f1:	c9                   	leave  
f010f9f2:	c3                   	ret    

f010f9f3 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010f9f3:	55                   	push   %ebp
f010f9f4:	89 e5                	mov    %esp,%ebp
f010f9f6:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010f9f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9fc:	8b 40 64             	mov    0x64(%eax),%eax
f010f9ff:	83 ec 08             	sub    $0x8,%esp
f010fa02:	ff 75 0c             	pushl  0xc(%ebp)
f010fa05:	50                   	push   %eax
f010fa06:	e8 3a 8b ff ff       	call   f0108545 <create_page_table>
f010fa0b:	83 c4 10             	add    $0x10,%esp
f010fa0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010fa11:	90                   	nop
f010fa12:	c9                   	leave  
f010fa13:	c3                   	ret    

f010fa14 <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010fa14:	55                   	push   %ebp
f010fa15:	89 e5                	mov    %esp,%ebp
f010fa17:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010fa1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010fa21:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa24:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fa2a:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010fa2d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa30:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fa36:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fa39:	0f 86 74 01 00 00    	jbe    f010fbb3 <page_fault_handler+0x19f>
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
		//refer to the project presentation and documentation for details
		int ret = pf_read_env_page(faulted_env,(void*)fault_va);
f010fa3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fa42:	83 ec 08             	sub    $0x8,%esp
f010fa45:	50                   	push   %eax
f010fa46:	ff 75 08             	pushl  0x8(%ebp)
f010fa49:	e8 93 4a ff ff       	call   f01044e1 <pf_read_env_page>
f010fa4e:	83 c4 10             	add    $0x10,%esp
f010fa51:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if (ret == E_PAGE_NOT_EXIST_IN_PF)
f010fa54:	83 7d ec f7          	cmpl   $0xfffffff7,-0x14(%ebp)
f010fa58:	75 45                	jne    f010fa9f <page_fault_handler+0x8b>
		{
			if (!( (USER_HEAP_START <= fault_va && fault_va < USER_HEAP_MAX) || (USTACKBOTTOM <= fault_va && fault_va < USTACKTOP) ) )
f010fa5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fa5d:	85 c0                	test   %eax,%eax
f010fa5f:	79 09                	jns    f010fa6a <page_fault_handler+0x56>
f010fa61:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010fa68:	76 35                	jbe    f010fa9f <page_fault_handler+0x8b>
f010fa6a:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010fa71:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fa74:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010fa79:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010fa7c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa7f:	ba 00 00 00 00       	mov    $0x0,%edx
f010fa84:	f7 75 e8             	divl   -0x18(%ebp)
f010fa87:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa8a:	29 d0                	sub    %edx,%eax
f010fa8c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fa8f:	77 09                	ja     f010fa9a <page_fault_handler+0x86>
f010fa91:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010fa98:	76 05                	jbe    f010fa9f <page_fault_handler+0x8b>
			{
				env_exit();
f010fa9a:	e8 aa be ff ff       	call   f010b949 <env_exit>
			}
		}

		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
f010fa9f:	83 ec 0c             	sub    $0xc,%esp
f010faa2:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010faa5:	50                   	push   %eax
f010faa6:	e8 07 87 ff ff       	call   f01081b2 <allocate_frame>
f010faab:	83 c4 10             	add    $0x10,%esp
f010faae:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(retk != E_NO_MEM)
f010fab1:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010fab5:	74 34                	je     f010faeb <page_fault_handler+0xd7>
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
f010fab7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010faba:	8b 45 08             	mov    0x8(%ebp),%eax
f010fabd:	8b 40 64             	mov    0x64(%eax),%eax
f010fac0:	6a 06                	push   $0x6
f010fac2:	ff 75 0c             	pushl  0xc(%ebp)
f010fac5:	52                   	push   %edx
f010fac6:	50                   	push   %eax
f010fac7:	e8 b3 8b ff ff       	call   f010867f <map_frame>
f010facc:	83 c4 10             	add    $0x10,%esp
		} else panic("Placement: no memory");
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
f010facf:	83 ec 08             	sub    $0x8,%esp
f010fad2:	ff 75 0c             	pushl  0xc(%ebp)
f010fad5:	ff 75 08             	pushl  0x8(%ebp)
f010fad8:	e8 24 a3 ff ff       	call   f0109e01 <env_page_ws_list_create_element>
f010fadd:	83 c4 10             	add    $0x10,%esp
f010fae0:	89 45 dc             	mov    %eax,-0x24(%ebp)
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fae3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010fae7:	75 30                	jne    f010fb19 <page_fault_handler+0x105>
f010fae9:	eb 17                	jmp    f010fb02 <page_fault_handler+0xee>
		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
		if(retk != E_NO_MEM)
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
		} else panic("Placement: no memory");
f010faeb:	83 ec 04             	sub    $0x4,%esp
f010faee:	68 fc 79 12 f0       	push   $0xf01279fc
f010faf3:	68 03 01 00 00       	push   $0x103
f010faf8:	68 73 78 12 f0       	push   $0xf0127873
f010fafd:	e8 37 08 ff ff       	call   f0100339 <_panic>
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fb02:	83 ec 04             	sub    $0x4,%esp
f010fb05:	68 14 7a 12 f0       	push   $0xf0127a14
f010fb0a:	68 05 01 00 00       	push   $0x105
f010fb0f:	68 73 78 12 f0       	push   $0xf0127873
f010fb14:	e8 20 08 ff ff       	call   f0100339 <_panic>
f010fb19:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb1c:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010fb22:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fb25:	89 50 14             	mov    %edx,0x14(%eax)
f010fb28:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fb2b:	8b 40 14             	mov    0x14(%eax),%eax
f010fb2e:	85 c0                	test   %eax,%eax
f010fb30:	74 11                	je     f010fb43 <page_fault_handler+0x12f>
f010fb32:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb35:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010fb3b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fb3e:	89 50 10             	mov    %edx,0x10(%eax)
f010fb41:	eb 0c                	jmp    f010fb4f <page_fault_handler+0x13b>
f010fb43:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb46:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fb49:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010fb4f:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb52:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fb55:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010fb5b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fb5e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010fb65:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb68:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fb6e:	8d 50 01             	lea    0x1(%eax),%edx
f010fb71:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb74:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		if (LIST_SIZE(&(faulted_env->page_WS_list)) == faulted_env->page_WS_max_size)
f010fb7a:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb7d:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010fb83:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb86:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fb8c:	39 c2                	cmp    %eax,%edx
f010fb8e:	75 14                	jne    f010fba4 <page_fault_handler+0x190>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f010fb90:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb93:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010fb99:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb9c:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010fba2:	eb 26                	jmp    f010fbca <page_fault_handler+0x1b6>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
		}
		else
		{
			faulted_env->page_last_WS_element = NULL;
f010fba4:	8b 45 08             	mov    0x8(%ebp),%eax
f010fba7:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010fbae:	00 00 00 
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010fbb1:	eb 17                	jmp    f010fbca <page_fault_handler+0x1b6>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010fbb3:	83 ec 04             	sub    $0x4,%esp
f010fbb6:	68 38 7a 12 f0       	push   $0xf0127a38
f010fbbb:	68 15 01 00 00       	push   $0x115
f010fbc0:	68 73 78 12 f0       	push   $0xf0127873
f010fbc5:	e8 6f 07 ff ff       	call   f0100339 <_panic>
	}
}
f010fbca:	c9                   	leave  
f010fbcb:	c3                   	ret    

f010fbcc <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010fbcc:	55                   	push   %ebp
f010fbcd:	89 e5                	mov    %esp,%ebp
f010fbcf:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010fbd2:	83 ec 04             	sub    $0x4,%esp
f010fbd5:	68 78 7a 12 f0       	push   $0xf0127a78
f010fbda:	68 1d 01 00 00       	push   $0x11d
f010fbdf:	68 73 78 12 f0       	push   $0xf0127873
f010fbe4:	e8 50 07 ff ff       	call   f0100339 <_panic>

f010fbe9 <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010fbe9:	55                   	push   %ebp
f010fbea:	89 e5                	mov    %esp,%ebp
f010fbec:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010fbef:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbf2:	83 c0 04             	add    $0x4,%eax
f010fbf5:	83 ec 08             	sub    $0x8,%esp
f010fbf8:	ff 75 0c             	pushl  0xc(%ebp)
f010fbfb:	50                   	push   %eax
f010fbfc:	e8 16 00 01 00       	call   f011fc17 <strcpy>
f010fc01:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010fc04:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc07:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010fc0d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc10:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010fc17:	90                   	nop
f010fc18:	c9                   	leave  
f010fc19:	c3                   	ret    

f010fc1a <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010fc1a:	55                   	push   %ebp
f010fc1b:	89 e5                	mov    %esp,%ebp
f010fc1d:	53                   	push   %ebx
f010fc1e:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010fc21:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc24:	83 ec 0c             	sub    $0xc,%esp
f010fc27:	50                   	push   %eax
f010fc28:	e8 06 02 00 00       	call   f010fe33 <holding_spinlock>
f010fc2d:	83 c4 10             	add    $0x10,%esp
f010fc30:	85 c0                	test   %eax,%eax
f010fc32:	74 18                	je     f010fc4c <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010fc34:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc37:	83 c0 04             	add    $0x4,%eax
f010fc3a:	50                   	push   %eax
f010fc3b:	68 bc 7a 12 f0       	push   $0xf0127abc
f010fc40:	6a 1f                	push   $0x1f
f010fc42:	68 f9 7a 12 f0       	push   $0xf0127af9
f010fc47:	e8 ed 06 ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010fc4c:	e8 7e 75 ff ff       	call   f01071cf <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010fc51:	90                   	nop
f010fc52:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc55:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010fc58:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010fc5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010fc62:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fc65:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010fc68:	f0 87 02             	lock xchg %eax,(%edx)
f010fc6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010fc6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fc71:	85 c0                	test   %eax,%eax
f010fc73:	75 dd                	jne    f010fc52 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010fc75:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010fc7a:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010fc7d:	e8 8a 74 ff ff       	call   f010710c <mycpu>
f010fc82:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010fc85:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc88:	83 c0 48             	add    $0x48,%eax
f010fc8b:	83 ec 08             	sub    $0x8,%esp
f010fc8e:	50                   	push   %eax
f010fc8f:	8d 45 08             	lea    0x8(%ebp),%eax
f010fc92:	50                   	push   %eax
f010fc93:	e8 74 00 00 00       	call   f010fd0c <getcallerpcs>
f010fc98:	83 c4 10             	add    $0x10,%esp

}
f010fc9b:	90                   	nop
f010fc9c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010fc9f:	c9                   	leave  
f010fca0:	c3                   	ret    

f010fca1 <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010fca1:	55                   	push   %ebp
f010fca2:	89 e5                	mov    %esp,%ebp
f010fca4:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f010fca7:	83 ec 0c             	sub    $0xc,%esp
f010fcaa:	ff 75 08             	pushl  0x8(%ebp)
f010fcad:	e8 81 01 00 00       	call   f010fe33 <holding_spinlock>
f010fcb2:	83 c4 10             	add    $0x10,%esp
f010fcb5:	85 c0                	test   %eax,%eax
f010fcb7:	75 26                	jne    f010fcdf <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010fcb9:	83 ec 0c             	sub    $0xc,%esp
f010fcbc:	ff 75 08             	pushl  0x8(%ebp)
f010fcbf:	e8 08 01 00 00       	call   f010fdcc <printcallstack>
f010fcc4:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010fcc7:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcca:	83 c0 04             	add    $0x4,%eax
f010fccd:	50                   	push   %eax
f010fcce:	68 10 7b 12 f0       	push   $0xf0127b10
f010fcd3:	6a 3c                	push   $0x3c
f010fcd5:	68 f9 7a 12 f0       	push   $0xf0127af9
f010fcda:	e8 5a 06 ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f010fcdf:	8b 45 08             	mov    0x8(%ebp),%eax
f010fce2:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010fce9:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcec:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010fcf3:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010fcf8:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcfb:	8b 55 08             	mov    0x8(%ebp),%edx
f010fcfe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010fd04:	e8 18 75 ff ff       	call   f0107221 <popcli>
}
f010fd09:	90                   	nop
f010fd0a:	c9                   	leave  
f010fd0b:	c3                   	ret    

f010fd0c <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010fd0c:	55                   	push   %ebp
f010fd0d:	89 e5                	mov    %esp,%ebp
f010fd0f:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010fd12:	e8 74 bc ff ff       	call   f010b98b <get_cpu_proc>
f010fd17:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010fd1a:	e8 ed 73 ff ff       	call   f010710c <mycpu>
f010fd1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010fd22:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd25:	83 e8 08             	sub    $0x8,%eax
f010fd28:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010fd2b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010fd32:	eb 67                	jmp    f010fd9b <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010fd34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fd38:	74 67                	je     f010fda1 <getcallerpcs+0x95>
f010fd3a:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010fd41:	76 5e                	jbe    f010fda1 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fd43:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fd46:	8b 40 08             	mov    0x8(%eax),%eax
f010fd49:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010fd4e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fd51:	77 10                	ja     f010fd63 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fd53:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fd56:	8b 40 08             	mov    0x8(%eax),%eax
f010fd59:	05 00 90 00 00       	add    $0x9000,%eax
f010fd5e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fd61:	77 3e                	ja     f010fda1 <getcallerpcs+0x95>
f010fd63:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fd67:	74 10                	je     f010fd79 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010fd69:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fd6c:	8b 40 70             	mov    0x70(%eax),%eax
f010fd6f:	05 00 80 00 00       	add    $0x8000,%eax
f010fd74:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fd77:	76 28                	jbe    f010fda1 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010fd79:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fd7c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fd83:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fd86:	01 c2                	add    %eax,%edx
f010fd88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fd8b:	8b 40 04             	mov    0x4(%eax),%eax
f010fd8e:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010fd90:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fd93:	8b 00                	mov    (%eax),%eax
f010fd95:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010fd98:	ff 45 f0             	incl   -0x10(%ebp)
f010fd9b:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010fd9f:	7e 93                	jle    f010fd34 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010fda1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fda4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010fda7:	eb 18                	jmp    f010fdc1 <getcallerpcs+0xb5>
		pcs[i] = 0;
f010fda9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fdac:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fdb3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fdb6:	01 d0                	add    %edx,%eax
f010fdb8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010fdbe:	ff 45 f0             	incl   -0x10(%ebp)
f010fdc1:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010fdc5:	7e e2                	jle    f010fda9 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010fdc7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010fdca:	c9                   	leave  
f010fdcb:	c3                   	ret    

f010fdcc <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010fdcc:	55                   	push   %ebp
f010fdcd:	89 e5                	mov    %esp,%ebp
f010fdcf:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010fdd2:	83 ec 0c             	sub    $0xc,%esp
f010fdd5:	68 4e 7b 12 f0       	push   $0xf0127b4e
f010fdda:	e8 ac 11 ff ff       	call   f0100f8b <cprintf>
f010fddf:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010fde2:	8b 45 08             	mov    0x8(%ebp),%eax
f010fde5:	83 c0 48             	add    $0x48,%eax
f010fde8:	83 ec 08             	sub    $0x8,%esp
f010fdeb:	50                   	push   %eax
f010fdec:	8d 45 08             	lea    0x8(%ebp),%eax
f010fdef:	50                   	push   %eax
f010fdf0:	e8 17 ff ff ff       	call   f010fd0c <getcallerpcs>
f010fdf5:	83 c4 10             	add    $0x10,%esp
f010fdf8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010fdfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010fe02:	eb 24                	jmp    f010fe28 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010fe04:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe07:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010fe0a:	83 c2 10             	add    $0x10,%edx
f010fe0d:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010fe11:	83 ec 04             	sub    $0x4,%esp
f010fe14:	50                   	push   %eax
f010fe15:	ff 75 f4             	pushl  -0xc(%ebp)
f010fe18:	68 5e 7b 12 f0       	push   $0xf0127b5e
f010fe1d:	e8 69 11 ff ff       	call   f0100f8b <cprintf>
f010fe22:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010fe25:	ff 45 f4             	incl   -0xc(%ebp)
f010fe28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fe2b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fe2e:	7c d4                	jl     f010fe04 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010fe30:	90                   	nop
f010fe31:	c9                   	leave  
f010fe32:	c3                   	ret    

f010fe33 <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010fe33:	55                   	push   %ebp
f010fe34:	89 e5                	mov    %esp,%ebp
f010fe36:	53                   	push   %ebx
f010fe37:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010fe3a:	e8 90 73 ff ff       	call   f01071cf <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010fe3f:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe42:	8b 00                	mov    (%eax),%eax
f010fe44:	85 c0                	test   %eax,%eax
f010fe46:	74 16                	je     f010fe5e <holding_spinlock+0x2b>
f010fe48:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe4b:	8b 58 44             	mov    0x44(%eax),%ebx
f010fe4e:	e8 b9 72 ff ff       	call   f010710c <mycpu>
f010fe53:	39 c3                	cmp    %eax,%ebx
f010fe55:	75 07                	jne    f010fe5e <holding_spinlock+0x2b>
f010fe57:	b8 01 00 00 00       	mov    $0x1,%eax
f010fe5c:	eb 05                	jmp    f010fe63 <holding_spinlock+0x30>
f010fe5e:	b8 00 00 00 00       	mov    $0x0,%eax
f010fe63:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010fe66:	e8 b6 73 ff ff       	call   f0107221 <popcli>
	return r;
f010fe6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010fe6e:	83 c4 14             	add    $0x14,%esp
f010fe71:	5b                   	pop    %ebx
f010fe72:	5d                   	pop    %ebp
f010fe73:	c3                   	ret    

f010fe74 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010fe74:	55                   	push   %ebp
f010fe75:	89 e5                	mov    %esp,%ebp
f010fe77:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f010fe7a:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe7d:	83 c0 74             	add    $0x74,%eax
f010fe80:	83 ec 08             	sub    $0x8,%esp
f010fe83:	68 6d 7b 12 f0       	push   $0xf0127b6d
f010fe88:	50                   	push   %eax
f010fe89:	e8 4c 01 00 00       	call   f010ffda <init_channel>
f010fe8e:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010fe91:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe94:	83 c0 04             	add    $0x4,%eax
f010fe97:	83 ec 08             	sub    $0x8,%esp
f010fe9a:	68 80 7b 12 f0       	push   $0xf0127b80
f010fe9f:	50                   	push   %eax
f010fea0:	e8 44 fd ff ff       	call   f010fbe9 <init_spinlock>
f010fea5:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010fea8:	8b 45 08             	mov    0x8(%ebp),%eax
f010feab:	05 c4 00 00 00       	add    $0xc4,%eax
f010feb0:	83 ec 08             	sub    $0x8,%esp
f010feb3:	ff 75 0c             	pushl  0xc(%ebp)
f010feb6:	50                   	push   %eax
f010feb7:	e8 5b fd 00 00       	call   f011fc17 <strcpy>
f010febc:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010febf:	8b 45 08             	mov    0x8(%ebp),%eax
f010fec2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010fec8:	8b 45 08             	mov    0x8(%ebp),%eax
f010fecb:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010fed2:	00 00 00 
}
f010fed5:	90                   	nop
f010fed6:	c9                   	leave  
f010fed7:	c3                   	ret    

f010fed8 <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f010fed8:	55                   	push   %ebp
f010fed9:	89 e5                	mov    %esp,%ebp
f010fedb:	53                   	push   %ebx
f010fedc:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010fedf:	8b 45 08             	mov    0x8(%ebp),%eax
f010fee2:	83 c0 04             	add    $0x4,%eax
f010fee5:	83 ec 0c             	sub    $0xc,%esp
f010fee8:	50                   	push   %eax
f010fee9:	e8 2c fd ff ff       	call   f010fc1a <acquire_spinlock>
f010feee:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010fef1:	8b 45 08             	mov    0x8(%ebp),%eax
f010fef4:	8b 00                	mov    (%eax),%eax
f010fef6:	85 c0                	test   %eax,%eax
f010fef8:	74 1c                	je     f010ff16 <holding_sleeplock+0x3e>
f010fefa:	8b 45 08             	mov    0x8(%ebp),%eax
f010fefd:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010ff03:	e8 83 ba ff ff       	call   f010b98b <get_cpu_proc>
f010ff08:	8b 40 10             	mov    0x10(%eax),%eax
f010ff0b:	39 c3                	cmp    %eax,%ebx
f010ff0d:	75 07                	jne    f010ff16 <holding_sleeplock+0x3e>
f010ff0f:	b8 01 00 00 00       	mov    $0x1,%eax
f010ff14:	eb 05                	jmp    f010ff1b <holding_sleeplock+0x43>
f010ff16:	b8 00 00 00 00       	mov    $0x0,%eax
f010ff1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010ff1e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff21:	83 c0 04             	add    $0x4,%eax
f010ff24:	83 ec 0c             	sub    $0xc,%esp
f010ff27:	50                   	push   %eax
f010ff28:	e8 74 fd ff ff       	call   f010fca1 <release_spinlock>
f010ff2d:	83 c4 10             	add    $0x10,%esp
	return r;
f010ff30:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ff33:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ff36:	c9                   	leave  
f010ff37:	c3                   	ret    

f010ff38 <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010ff38:	55                   	push   %ebp
f010ff39:	89 e5                	mov    %esp,%ebp
f010ff3b:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010ff3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff41:	83 c0 04             	add    $0x4,%eax
f010ff44:	83 ec 0c             	sub    $0xc,%esp
f010ff47:	50                   	push   %eax
f010ff48:	e8 cd fc ff ff       	call   f010fc1a <acquire_spinlock>
f010ff4d:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f010ff50:	eb 19                	jmp    f010ff6b <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f010ff52:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff55:	8d 50 04             	lea    0x4(%eax),%edx
f010ff58:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff5b:	83 c0 74             	add    $0x74,%eax
f010ff5e:	83 ec 08             	sub    $0x8,%esp
f010ff61:	52                   	push   %edx
f010ff62:	50                   	push   %eax
f010ff63:	e8 9f 00 00 00       	call   f0110007 <sleep>
f010ff68:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f010ff6b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff6e:	8b 00                	mov    (%eax),%eax
f010ff70:	85 c0                	test   %eax,%eax
f010ff72:	75 de                	jne    f010ff52 <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f010ff74:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff77:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f010ff7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff80:	83 c0 04             	add    $0x4,%eax
f010ff83:	83 ec 0c             	sub    $0xc,%esp
f010ff86:	50                   	push   %eax
f010ff87:	e8 15 fd ff ff       	call   f010fca1 <release_spinlock>
f010ff8c:	83 c4 10             	add    $0x10,%esp

}
f010ff8f:	90                   	nop
f010ff90:	c9                   	leave  
f010ff91:	c3                   	ret    

f010ff92 <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f010ff92:	55                   	push   %ebp
f010ff93:	89 e5                	mov    %esp,%ebp
f010ff95:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010ff98:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff9b:	83 c0 04             	add    $0x4,%eax
f010ff9e:	83 ec 0c             	sub    $0xc,%esp
f010ffa1:	50                   	push   %eax
f010ffa2:	e8 73 fc ff ff       	call   f010fc1a <acquire_spinlock>
f010ffa7:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f010ffaa:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffad:	83 c0 74             	add    $0x74,%eax
f010ffb0:	83 ec 0c             	sub    $0xc,%esp
f010ffb3:	50                   	push   %eax
f010ffb4:	e8 3f 01 00 00       	call   f01100f8 <wakeup_all>
f010ffb9:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f010ffbc:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffbf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f010ffc5:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffc8:	83 c0 04             	add    $0x4,%eax
f010ffcb:	83 ec 0c             	sub    $0xc,%esp
f010ffce:	50                   	push   %eax
f010ffcf:	e8 cd fc ff ff       	call   f010fca1 <release_spinlock>
f010ffd4:	83 c4 10             	add    $0x10,%esp
}
f010ffd7:	90                   	nop
f010ffd8:	c9                   	leave  
f010ffd9:	c3                   	ret    

f010ffda <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f010ffda:	55                   	push   %ebp
f010ffdb:	89 e5                	mov    %esp,%ebp
f010ffdd:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f010ffe0:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffe3:	83 c0 10             	add    $0x10,%eax
f010ffe6:	83 ec 08             	sub    $0x8,%esp
f010ffe9:	ff 75 0c             	pushl  0xc(%ebp)
f010ffec:	50                   	push   %eax
f010ffed:	e8 25 fc 00 00       	call   f011fc17 <strcpy>
f010fff2:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f010fff5:	8b 45 08             	mov    0x8(%ebp),%eax
f010fff8:	83 ec 0c             	sub    $0xc,%esp
f010fffb:	50                   	push   %eax
f010fffc:	e8 68 4f ff ff       	call   f0104f69 <init_queue>
f0110001:	83 c4 10             	add    $0x10,%esp
}
f0110004:	90                   	nop
f0110005:	c9                   	leave  
f0110006:	c3                   	ret    

f0110007 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f0110007:	55                   	push   %ebp
f0110008:	89 e5                	mov    %esp,%ebp
f011000a:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f011000d:	83 ec 0c             	sub    $0xc,%esp
f0110010:	68 e0 05 6c f0       	push   $0xf06c05e0
f0110015:	e8 00 fc ff ff       	call   f010fc1a <acquire_spinlock>
f011001a:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f011001d:	e8 69 b9 ff ff       	call   f010b98b <get_cpu_proc>
f0110022:	89 c2                	mov    %eax,%edx
f0110024:	8b 45 08             	mov    0x8(%ebp),%eax
f0110027:	83 ec 08             	sub    $0x8,%esp
f011002a:	52                   	push   %edx
f011002b:	50                   	push   %eax
f011002c:	e8 79 4f ff ff       	call   f0104faa <enqueue>
f0110031:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f0110034:	e8 52 b9 ff ff       	call   f010b98b <get_cpu_proc>
f0110039:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f0110040:	83 ec 0c             	sub    $0xc,%esp
f0110043:	ff 75 0c             	pushl  0xc(%ebp)
f0110046:	e8 56 fc ff ff       	call   f010fca1 <release_spinlock>
f011004b:	83 c4 10             	add    $0x10,%esp
	sched();
f011004e:	e8 b9 ba ff ff       	call   f010bb0c <sched>
	release_spinlock(&(ProcessQueues.qlock));
f0110053:	83 ec 0c             	sub    $0xc,%esp
f0110056:	68 e0 05 6c f0       	push   $0xf06c05e0
f011005b:	e8 41 fc ff ff       	call   f010fca1 <release_spinlock>
f0110060:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f0110063:	83 ec 0c             	sub    $0xc,%esp
f0110066:	ff 75 0c             	pushl  0xc(%ebp)
f0110069:	e8 ac fb ff ff       	call   f010fc1a <acquire_spinlock>
f011006e:	83 c4 10             	add    $0x10,%esp
}
f0110071:	90                   	nop
f0110072:	c9                   	leave  
f0110073:	c3                   	ret    

f0110074 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f0110074:	55                   	push   %ebp
f0110075:	89 e5                	mov    %esp,%ebp
f0110077:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f011007a:	8b 45 08             	mov    0x8(%ebp),%eax
f011007d:	83 ec 0c             	sub    $0xc,%esp
f0110080:	50                   	push   %eax
f0110081:	e8 0c 4f ff ff       	call   f0104f92 <queue_size>
f0110086:	83 c4 10             	add    $0x10,%esp
f0110089:	85 c0                	test   %eax,%eax
f011008b:	74 68                	je     f01100f5 <wakeup_one+0x81>
		bool locked_by_me = 0;
f011008d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f0110094:	83 ec 0c             	sub    $0xc,%esp
f0110097:	68 e0 05 6c f0       	push   $0xf06c05e0
f011009c:	e8 92 fd ff ff       	call   f010fe33 <holding_spinlock>
f01100a1:	83 c4 10             	add    $0x10,%esp
f01100a4:	85 c0                	test   %eax,%eax
f01100a6:	75 17                	jne    f01100bf <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f01100a8:	83 ec 0c             	sub    $0xc,%esp
f01100ab:	68 e0 05 6c f0       	push   $0xf06c05e0
f01100b0:	e8 65 fb ff ff       	call   f010fc1a <acquire_spinlock>
f01100b5:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f01100b8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f01100bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01100c2:	83 ec 0c             	sub    $0xc,%esp
f01100c5:	50                   	push   %eax
f01100c6:	e8 70 4f ff ff       	call   f010503b <dequeue>
f01100cb:	83 c4 10             	add    $0x10,%esp
f01100ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f01100d1:	83 ec 0c             	sub    $0xc,%esp
f01100d4:	ff 75 f0             	pushl  -0x10(%ebp)
f01100d7:	e8 9a 51 ff ff       	call   f0105276 <sched_insert_ready0>
f01100dc:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f01100df:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01100e3:	74 10                	je     f01100f5 <wakeup_one+0x81>
f01100e5:	83 ec 0c             	sub    $0xc,%esp
f01100e8:	68 e0 05 6c f0       	push   $0xf06c05e0
f01100ed:	e8 af fb ff ff       	call   f010fca1 <release_spinlock>
f01100f2:	83 c4 10             	add    $0x10,%esp
	}
}
f01100f5:	90                   	nop
f01100f6:	c9                   	leave  
f01100f7:	c3                   	ret    

f01100f8 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f01100f8:	55                   	push   %ebp
f01100f9:	89 e5                	mov    %esp,%ebp
f01100fb:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f01100fe:	83 ec 0c             	sub    $0xc,%esp
f0110101:	68 e0 05 6c f0       	push   $0xf06c05e0
f0110106:	e8 0f fb ff ff       	call   f010fc1a <acquire_spinlock>
f011010b:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f011010e:	eb 0e                	jmp    f011011e <wakeup_all+0x26>
		wakeup_one(chan);
f0110110:	83 ec 0c             	sub    $0xc,%esp
f0110113:	ff 75 08             	pushl  0x8(%ebp)
f0110116:	e8 59 ff ff ff       	call   f0110074 <wakeup_one>
f011011b:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f011011e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110121:	83 ec 0c             	sub    $0xc,%esp
f0110124:	50                   	push   %eax
f0110125:	e8 68 4e ff ff       	call   f0104f92 <queue_size>
f011012a:	83 c4 10             	add    $0x10,%esp
f011012d:	85 c0                	test   %eax,%eax
f011012f:	75 df                	jne    f0110110 <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f0110131:	83 ec 0c             	sub    $0xc,%esp
f0110134:	68 e0 05 6c f0       	push   $0xf06c05e0
f0110139:	e8 63 fb ff ff       	call   f010fca1 <release_spinlock>
f011013e:	83 c4 10             	add    $0x10,%esp
}
f0110141:	90                   	nop
f0110142:	c9                   	leave  
f0110143:	c3                   	ret    

f0110144 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f0110144:	55                   	push   %ebp
f0110145:	89 e5                	mov    %esp,%ebp
f0110147:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f011014a:	83 ec 04             	sub    $0x4,%esp
f011014d:	68 94 7b 12 f0       	push   $0xf0127b94
f0110152:	6a 13                	push   $0x13
f0110154:	68 bb 7b 12 f0       	push   $0xf0127bbb
f0110159:	e8 db 01 ff ff       	call   f0100339 <_panic>

f011015e <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f011015e:	55                   	push   %ebp
f011015f:	89 e5                	mov    %esp,%ebp
f0110161:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f0110164:	83 ec 04             	sub    $0x4,%esp
f0110167:	68 d4 7b 12 f0       	push   $0xf0127bd4
f011016c:	6a 1b                	push   $0x1b
f011016e:	68 bb 7b 12 f0       	push   $0xf0127bbb
f0110173:	e8 c1 01 ff ff       	call   f0100339 <_panic>

f0110178 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f0110178:	55                   	push   %ebp
f0110179:	89 e5                	mov    %esp,%ebp
f011017b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f011017e:	83 ec 04             	sub    $0x4,%esp
f0110181:	68 fc 7b 12 f0       	push   $0xf0127bfc
f0110186:	6a 24                	push   $0x24
f0110188:	68 bb 7b 12 f0       	push   $0xf0127bbb
f011018d:	e8 a7 01 ff ff       	call   f0100339 <_panic>

f0110192 <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0110192:	55                   	push   %ebp
f0110193:	89 e5                	mov    %esp,%ebp
f0110195:	c7 05 78 0b 6c f0 01 	movl   $0x1,0xf06c0b78
f011019c:	00 00 00 
f011019f:	90                   	nop
f01101a0:	5d                   	pop    %ebp
f01101a1:	c3                   	ret    

f01101a2 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f01101a2:	55                   	push   %ebp
f01101a3:	89 e5                	mov    %esp,%ebp
f01101a5:	c7 05 78 0b 6c f0 02 	movl   $0x2,0xf06c0b78
f01101ac:	00 00 00 
f01101af:	90                   	nop
f01101b0:	5d                   	pop    %ebp
f01101b1:	c3                   	ret    

f01101b2 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f01101b2:	55                   	push   %ebp
f01101b3:	89 e5                	mov    %esp,%ebp
f01101b5:	c7 05 78 0b 6c f0 03 	movl   $0x3,0xf06c0b78
f01101bc:	00 00 00 
f01101bf:	90                   	nop
f01101c0:	5d                   	pop    %ebp
f01101c1:	c3                   	ret    

f01101c2 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f01101c2:	55                   	push   %ebp
f01101c3:	89 e5                	mov    %esp,%ebp
f01101c5:	a1 78 0b 6c f0       	mov    0xf06c0b78,%eax
f01101ca:	83 f8 01             	cmp    $0x1,%eax
f01101cd:	75 04                	jne    f01101d3 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f01101cf:	b0 01                	mov    $0x1,%al
f01101d1:	eb 02                	jmp    f01101d5 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f01101d3:	b0 00                	mov    $0x0,%al
f01101d5:	5d                   	pop    %ebp
f01101d6:	c3                   	ret    

f01101d7 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f01101d7:	55                   	push   %ebp
f01101d8:	89 e5                	mov    %esp,%ebp
f01101da:	a1 78 0b 6c f0       	mov    0xf06c0b78,%eax
f01101df:	83 f8 02             	cmp    $0x2,%eax
f01101e2:	75 04                	jne    f01101e8 <isKHeapPlacementStrategyBESTFIT+0x11>
f01101e4:	b0 01                	mov    $0x1,%al
f01101e6:	eb 02                	jmp    f01101ea <isKHeapPlacementStrategyBESTFIT+0x13>
f01101e8:	b0 00                	mov    $0x0,%al
f01101ea:	5d                   	pop    %ebp
f01101eb:	c3                   	ret    

f01101ec <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f01101ec:	55                   	push   %ebp
f01101ed:	89 e5                	mov    %esp,%ebp
f01101ef:	a1 78 0b 6c f0       	mov    0xf06c0b78,%eax
f01101f4:	83 f8 03             	cmp    $0x3,%eax
f01101f7:	75 04                	jne    f01101fd <isKHeapPlacementStrategyNEXTFIT+0x11>
f01101f9:	b0 01                	mov    $0x1,%al
f01101fb:	eb 02                	jmp    f01101ff <isKHeapPlacementStrategyNEXTFIT+0x13>
f01101fd:	b0 00                	mov    $0x0,%al
f01101ff:	5d                   	pop    %ebp
f0110200:	c3                   	ret    

f0110201 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f0110201:	55                   	push   %ebp
f0110202:	89 e5                	mov    %esp,%ebp
f0110204:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0110207:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011020e:	eb 26                	jmp    f0110236 <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f0110210:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110213:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011021a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011021d:	01 c2                	add    %eax,%edx
f011021f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110222:	40                   	inc    %eax
f0110223:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011022a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011022d:	01 c8                	add    %ecx,%eax
f011022f:	8b 00                	mov    (%eax),%eax
f0110231:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0110233:	ff 45 f4             	incl   -0xc(%ebp)
f0110236:	8b 45 08             	mov    0x8(%ebp),%eax
f0110239:	48                   	dec    %eax
f011023a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011023d:	7f d1                	jg     f0110210 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f011023f:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f0110242:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f0110249:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0110250:	eb 35                	jmp    f0110287 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f0110252:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110255:	89 d0                	mov    %edx,%eax
f0110257:	01 c0                	add    %eax,%eax
f0110259:	01 d0                	add    %edx,%eax
f011025b:	c1 e0 02             	shl    $0x2,%eax
f011025e:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0110263:	8b 10                	mov    (%eax),%edx
f0110265:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110268:	8b 00                	mov    (%eax),%eax
f011026a:	83 ec 08             	sub    $0x8,%esp
f011026d:	52                   	push   %edx
f011026e:	50                   	push   %eax
f011026f:	e8 60 fa 00 00       	call   f011fcd4 <strcmp>
f0110274:	83 c4 10             	add    $0x10,%esp
f0110277:	85 c0                	test   %eax,%eax
f0110279:	75 09                	jne    f0110284 <tst_handler+0x83>
		{
			test_found = 1;
f011027b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f0110282:	eb 0f                	jmp    f0110293 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f0110284:	ff 45 ec             	incl   -0x14(%ebp)
f0110287:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011028a:	a1 b4 fd 17 f0       	mov    0xf017fdb4,%eax
f011028f:	39 c2                	cmp    %eax,%edx
f0110291:	72 bf                	jb     f0110252 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f0110293:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110297:	74 29                	je     f01102c2 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f0110299:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011029c:	89 d0                	mov    %edx,%eax
f011029e:	01 c0                	add    %eax,%eax
f01102a0:	01 d0                	add    %edx,%eax
f01102a2:	c1 e0 02             	shl    $0x2,%eax
f01102a5:	05 08 fd 17 f0       	add    $0xf017fd08,%eax
f01102aa:	8b 00                	mov    (%eax),%eax
f01102ac:	83 ec 08             	sub    $0x8,%esp
f01102af:	ff 75 0c             	pushl  0xc(%ebp)
f01102b2:	ff 75 08             	pushl  0x8(%ebp)
f01102b5:	ff d0                	call   *%eax
f01102b7:	83 c4 10             	add    $0x10,%esp
f01102ba:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f01102bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01102c0:	eb 1b                	jmp    f01102dd <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f01102c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102c5:	8b 00                	mov    (%eax),%eax
f01102c7:	83 ec 08             	sub    $0x8,%esp
f01102ca:	50                   	push   %eax
f01102cb:	68 3c 7f 12 f0       	push   $0xf0127f3c
f01102d0:	e8 b6 0c ff ff       	call   f0100f8b <cprintf>
f01102d5:	83 c4 10             	add    $0x10,%esp
		return 0;
f01102d8:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f01102dd:	c9                   	leave  
f01102de:	c3                   	ret    

f01102df <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f01102df:	55                   	push   %ebp
f01102e0:	89 e5                	mov    %esp,%ebp
f01102e2:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f01102e5:	e8 69 d0 00 00       	call   f011d353 <test_three_creation_functions>
	return 0;
f01102ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01102ef:	c9                   	leave  
f01102f0:	c3                   	ret    

f01102f1 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f01102f1:	55                   	push   %ebp
f01102f2:	89 e5                	mov    %esp,%ebp
f01102f4:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f01102f7:	e8 03 69 00 00       	call   f0116bff <test_priority_normal_and_higher>
	return 0;
f01102fc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110301:	c9                   	leave  
f0110302:	c3                   	ret    

f0110303 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f0110303:	55                   	push   %ebp
f0110304:	89 e5                	mov    %esp,%ebp
f0110306:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f0110309:	e8 0b 69 00 00       	call   f0116c19 <test_priority_normal_and_lower>
	return 0;
f011030e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110313:	c9                   	leave  
f0110314:	c3                   	ret    

f0110315 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f0110315:	55                   	push   %ebp
f0110316:	89 e5                	mov    %esp,%ebp
f0110318:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f011031b:	e8 e6 d1 00 00       	call   f011d506 <test_kfreeall>
	return 0;
f0110320:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110325:	c9                   	leave  
f0110326:	c3                   	ret    

f0110327 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f0110327:	55                   	push   %ebp
f0110328:	89 e5                	mov    %esp,%ebp
f011032a:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f011032d:	e8 f1 d1 00 00       	call   f011d523 <test_kexpand>
	return 0;
f0110332:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110337:	c9                   	leave  
f0110338:	c3                   	ret    

f0110339 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f0110339:	55                   	push   %ebp
f011033a:	89 e5                	mov    %esp,%ebp
f011033c:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f011033f:	e8 fc d1 00 00       	call   f011d540 <test_kshrink>
	return 0;
f0110344:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110349:	c9                   	leave  
f011034a:	c3                   	ret    

f011034b <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f011034b:	55                   	push   %ebp
f011034c:	89 e5                	mov    %esp,%ebp
f011034e:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f0110351:	e8 07 d2 00 00       	call   f011d55d <test_kfreelast>
	return 0;
f0110356:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011035b:	c9                   	leave  
f011035c:	c3                   	ret    

f011035d <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f011035d:	55                   	push   %ebp
f011035e:	89 e5                	mov    %esp,%ebp
f0110360:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f0110363:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110366:	83 c0 04             	add    $0x4,%eax
f0110369:	8b 00                	mov    (%eax),%eax
f011036b:	83 ec 04             	sub    $0x4,%esp
f011036e:	6a 0a                	push   $0xa
f0110370:	6a 00                	push   $0x0
f0110372:	50                   	push   %eax
f0110373:	e8 b0 fb 00 00       	call   f011ff28 <strtol>
f0110378:	83 c4 10             	add    $0x10,%esp
f011037b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f011037e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f0110385:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f011038c:	83 ec 0c             	sub    $0xc,%esp
f011038f:	68 e0 05 6c f0       	push   $0xf06c05e0
f0110394:	e8 81 f8 ff ff       	call   f010fc1a <acquire_spinlock>
f0110399:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f011039c:	a1 60 06 6c f0       	mov    0xf06c0660,%eax
f01103a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01103a4:	eb 3b                	jmp    f01103e1 <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f01103a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01103a9:	83 c0 20             	add    $0x20,%eax
f01103ac:	83 ec 08             	sub    $0x8,%esp
f01103af:	68 4f 7f 12 f0       	push   $0xf0127f4f
f01103b4:	50                   	push   %eax
f01103b5:	e8 1a f9 00 00       	call   f011fcd4 <strcmp>
f01103ba:	83 c4 10             	add    $0x10,%esp
f01103bd:	85 c0                	test   %eax,%eax
f01103bf:	75 12                	jne    f01103d3 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f01103c1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01103c5:	74 07                	je     f01103ce <tst_sc_MLFQ+0x71>
					firstTime = 0;
f01103c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f01103ce:	ff 45 f4             	incl   -0xc(%ebp)
f01103d1:	eb 06                	jmp    f01103d9 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f01103d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01103d7:	74 31                	je     f011040a <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f01103d9:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f01103de:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01103e1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01103e5:	74 08                	je     f01103ef <tst_sc_MLFQ+0x92>
f01103e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01103ea:	8b 40 08             	mov    0x8(%eax),%eax
f01103ed:	eb 05                	jmp    f01103f4 <tst_sc_MLFQ+0x97>
f01103ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01103f4:	a3 68 06 6c f0       	mov    %eax,0xf06c0668
f01103f9:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f01103fe:	85 c0                	test   %eax,%eax
f0110400:	75 a4                	jne    f01103a6 <tst_sc_MLFQ+0x49>
f0110402:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110406:	75 9e                	jne    f01103a6 <tst_sc_MLFQ+0x49>
f0110408:	eb 01                	jmp    f011040b <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f011040a:	90                   	nop
			}
		if(cnt == numOfSlave2)
f011040b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011040e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0110411:	75 12                	jne    f0110425 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f0110413:	83 ec 0c             	sub    $0xc,%esp
f0110416:	68 58 7f 12 f0       	push   $0xf0127f58
f011041b:	e8 6b 0b ff ff       	call   f0100f8b <cprintf>
f0110420:	83 c4 10             	add    $0x10,%esp
f0110423:	eb 17                	jmp    f011043c <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f0110425:	83 ec 04             	sub    $0x4,%esp
f0110428:	68 91 7f 12 f0       	push   $0xf0127f91
f011042d:	68 9b 00 00 00       	push   $0x9b
f0110432:	68 a7 7f 12 f0       	push   $0xf0127fa7
f0110437:	e8 fd fe fe ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011043c:	83 ec 0c             	sub    $0xc,%esp
f011043f:	68 e0 05 6c f0       	push   $0xf06c05e0
f0110444:	e8 58 f8 ff ff       	call   f010fca1 <release_spinlock>
f0110449:	83 c4 10             	add    $0x10,%esp
	return 0;
f011044c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110451:	c9                   	leave  
f0110452:	c3                   	ret    

f0110453 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f0110453:	55                   	push   %ebp
f0110454:	89 e5                	mov    %esp,%ebp
f0110456:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f0110459:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011045d:	74 17                	je     f0110476 <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f011045f:	83 ec 0c             	sub    $0xc,%esp
f0110462:	68 c0 7f 12 f0       	push   $0xf0127fc0
f0110467:	e8 1f 0b ff ff       	call   f0100f8b <cprintf>
f011046c:	83 c4 10             	add    $0x10,%esp
		return 0;
f011046f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110474:	eb 45                	jmp    f01104bb <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f0110476:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110479:	83 c0 04             	add    $0x4,%eax
f011047c:	8b 00                	mov    (%eax),%eax
f011047e:	83 ec 04             	sub    $0x4,%esp
f0110481:	6a 0a                	push   $0xa
f0110483:	6a 00                	push   $0x0
f0110485:	50                   	push   %eax
f0110486:	e8 9d fa 00 00       	call   f011ff28 <strtol>
f011048b:	83 c4 10             	add    $0x10,%esp
f011048e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f0110491:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110494:	83 f8 01             	cmp    $0x1,%eax
f0110497:	74 10                	je     f01104a9 <tst_bsd_nice+0x56>
f0110499:	83 f8 02             	cmp    $0x2,%eax
f011049c:	74 12                	je     f01104b0 <tst_bsd_nice+0x5d>
f011049e:	85 c0                	test   %eax,%eax
f01104a0:	75 14                	jne    f01104b6 <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f01104a2:	e8 b9 d2 00 00       	call   f011d760 <test_bsd_nice_0>
		break;
f01104a7:	eb 0d                	jmp    f01104b6 <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f01104a9:	e8 3c d5 00 00       	call   f011d9ea <test_bsd_nice_1>
		break;
f01104ae:	eb 06                	jmp    f01104b6 <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f01104b0:	e8 49 d7 00 00       	call   f011dbfe <test_bsd_nice_2>
		break;
f01104b5:	90                   	nop
	}
	return 0;
f01104b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01104bb:	c9                   	leave  
f01104bc:	c3                   	ret    

f01104bd <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f01104bd:	55                   	push   %ebp
f01104be:	89 e5                	mov    %esp,%ebp
f01104c0:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f01104c3:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01104c7:	74 17                	je     f01104e0 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f01104c9:	83 ec 0c             	sub    $0xc,%esp
f01104cc:	68 00 80 12 f0       	push   $0xf0128000
f01104d1:	e8 b5 0a ff ff       	call   f0100f8b <cprintf>
f01104d6:	83 c4 10             	add    $0x10,%esp
		return 0;
f01104d9:	b8 00 00 00 00       	mov    $0x0,%eax
f01104de:	eb 0a                	jmp    f01104ea <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f01104e0:	e8 3f 15 00 00       	call   f0111a24 <test_str2lower_function>
	return 0;
f01104e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01104ea:	c9                   	leave  
f01104eb:	c3                   	ret    

f01104ec <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f01104ec:	55                   	push   %ebp
f01104ed:	89 e5                	mov    %esp,%ebp
f01104ef:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f01104f2:	e8 63 11 00 00       	call   f011165a <TestAutoCompleteCommand>
f01104f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f01104fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01104ff:	c9                   	leave  
f0110500:	c3                   	ret    

f0110501 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f0110501:	55                   	push   %ebp
f0110502:	89 e5                	mov    %esp,%ebp
f0110504:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110507:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011050b:	74 1a                	je     f0110527 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f011050d:	83 ec 0c             	sub    $0xc,%esp
f0110510:	68 34 80 12 f0       	push   $0xf0128034
f0110515:	e8 71 0a ff ff       	call   f0100f8b <cprintf>
f011051a:	83 c4 10             	add    $0x10,%esp
		return 0;
f011051d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110522:	e9 2f 01 00 00       	jmp    f0110656 <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f0110527:	8b 45 0c             	mov    0xc(%ebp),%eax
f011052a:	83 c0 04             	add    $0x4,%eax
f011052d:	8b 00                	mov    (%eax),%eax
f011052f:	83 ec 08             	sub    $0x8,%esp
f0110532:	68 71 80 12 f0       	push   $0xf0128071
f0110537:	50                   	push   %eax
f0110538:	e8 97 f7 00 00       	call   f011fcd4 <strcmp>
f011053d:	83 c4 10             	add    $0x10,%esp
f0110540:	85 c0                	test   %eax,%eax
f0110542:	75 0a                	jne    f011054e <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f0110544:	e8 40 08 00 00       	call   f0110d89 <test_initialize_dynamic_allocator>
f0110549:	e9 03 01 00 00       	jmp    f0110651 <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f011054e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110551:	83 c0 04             	add    $0x4,%eax
f0110554:	8b 00                	mov    (%eax),%eax
f0110556:	83 ec 08             	sub    $0x8,%esp
f0110559:	68 76 80 12 f0       	push   $0xf0128076
f011055e:	50                   	push   %eax
f011055f:	e8 70 f7 00 00       	call   f011fcd4 <strcmp>
f0110564:	83 c4 10             	add    $0x10,%esp
f0110567:	85 c0                	test   %eax,%eax
f0110569:	75 0a                	jne    f0110575 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f011056b:	e8 4d 08 00 00       	call   f0110dbd <test_alloc_block_FF>
f0110570:	e9 dc 00 00 00       	jmp    f0110651 <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f0110575:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110578:	83 c0 04             	add    $0x4,%eax
f011057b:	8b 00                	mov    (%eax),%eax
f011057d:	83 ec 08             	sub    $0x8,%esp
f0110580:	68 7e 80 12 f0       	push   $0xf012807e
f0110585:	50                   	push   %eax
f0110586:	e8 49 f7 00 00       	call   f011fcd4 <strcmp>
f011058b:	83 c4 10             	add    $0x10,%esp
f011058e:	85 c0                	test   %eax,%eax
f0110590:	75 0a                	jne    f011059c <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f0110592:	e8 43 08 00 00       	call   f0110dda <test_alloc_block_BF>
f0110597:	e9 b5 00 00 00       	jmp    f0110651 <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f011059c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011059f:	83 c0 04             	add    $0x4,%eax
f01105a2:	8b 00                	mov    (%eax),%eax
f01105a4:	83 ec 08             	sub    $0x8,%esp
f01105a7:	68 86 80 12 f0       	push   $0xf0128086
f01105ac:	50                   	push   %eax
f01105ad:	e8 22 f7 00 00       	call   f011fcd4 <strcmp>
f01105b2:	83 c4 10             	add    $0x10,%esp
f01105b5:	85 c0                	test   %eax,%eax
f01105b7:	75 0a                	jne    f01105c3 <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f01105b9:	e8 3c 08 00 00       	call   f0110dfa <test_alloc_block_NF>
f01105be:	e9 8e 00 00 00       	jmp    f0110651 <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f01105c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105c6:	83 c0 04             	add    $0x4,%eax
f01105c9:	8b 00                	mov    (%eax),%eax
f01105cb:	83 ec 08             	sub    $0x8,%esp
f01105ce:	68 8e 80 12 f0       	push   $0xf012808e
f01105d3:	50                   	push   %eax
f01105d4:	e8 fb f6 00 00       	call   f011fcd4 <strcmp>
f01105d9:	83 c4 10             	add    $0x10,%esp
f01105dc:	85 c0                	test   %eax,%eax
f01105de:	75 07                	jne    f01105e7 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f01105e0:	e8 1b 08 00 00       	call   f0110e00 <test_free_block_FF>
f01105e5:	eb 6a                	jmp    f0110651 <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f01105e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105ea:	83 c0 04             	add    $0x4,%eax
f01105ed:	8b 00                	mov    (%eax),%eax
f01105ef:	83 ec 08             	sub    $0x8,%esp
f01105f2:	68 95 80 12 f0       	push   $0xf0128095
f01105f7:	50                   	push   %eax
f01105f8:	e8 d7 f6 00 00       	call   f011fcd4 <strcmp>
f01105fd:	83 c4 10             	add    $0x10,%esp
f0110600:	85 c0                	test   %eax,%eax
f0110602:	75 07                	jne    f011060b <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f0110604:	e8 14 08 00 00       	call   f0110e1d <test_free_block_BF>
f0110609:	eb 46                	jmp    f0110651 <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f011060b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011060e:	83 c0 04             	add    $0x4,%eax
f0110611:	8b 00                	mov    (%eax),%eax
f0110613:	83 ec 08             	sub    $0x8,%esp
f0110616:	68 9c 80 12 f0       	push   $0xf012809c
f011061b:	50                   	push   %eax
f011061c:	e8 b3 f6 00 00       	call   f011fcd4 <strcmp>
f0110621:	83 c4 10             	add    $0x10,%esp
f0110624:	85 c0                	test   %eax,%eax
f0110626:	75 07                	jne    f011062f <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f0110628:	e8 0d 08 00 00       	call   f0110e3a <test_free_block_NF>
f011062d:	eb 22                	jmp    f0110651 <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f011062f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110632:	83 c0 04             	add    $0x4,%eax
f0110635:	8b 00                	mov    (%eax),%eax
f0110637:	83 ec 08             	sub    $0x8,%esp
f011063a:	68 a3 80 12 f0       	push   $0xf01280a3
f011063f:	50                   	push   %eax
f0110640:	e8 8f f6 00 00       	call   f011fcd4 <strcmp>
f0110645:	83 c4 10             	add    $0x10,%esp
f0110648:	85 c0                	test   %eax,%eax
f011064a:	75 05                	jne    f0110651 <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f011064c:	e8 06 08 00 00       	call   f0110e57 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f0110651:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110656:	c9                   	leave  
f0110657:	c3                   	ret    

f0110658 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f0110658:	55                   	push   %ebp
f0110659:	89 e5                	mov    %esp,%ebp
f011065b:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f011065e:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110662:	74 1a                	je     f011067e <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f0110664:	83 ec 0c             	sub    $0xc,%esp
f0110667:	68 b0 80 12 f0       	push   $0xf01280b0
f011066c:	e8 1a 09 ff ff       	call   f0100f8b <cprintf>
f0110671:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110674:	b8 00 00 00 00       	mov    $0x0,%eax
f0110679:	e9 e1 00 00 00       	jmp    f011075f <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f011067e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110681:	83 c0 04             	add    $0x4,%eax
f0110684:	8b 00                	mov    (%eax),%eax
f0110686:	83 ec 08             	sub    $0x8,%esp
f0110689:	68 e9 80 12 f0       	push   $0xf01280e9
f011068e:	50                   	push   %eax
f011068f:	e8 40 f6 00 00       	call   f011fcd4 <strcmp>
f0110694:	83 c4 10             	add    $0x10,%esp
f0110697:	85 c0                	test   %eax,%eax
f0110699:	75 0a                	jne    f01106a5 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f011069b:	e8 97 1c 00 00       	call   f0112337 <test_cut_paste_pages>
f01106a0:	e9 b5 00 00 00       	jmp    f011075a <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f01106a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106a8:	83 c0 04             	add    $0x4,%eax
f01106ab:	8b 00                	mov    (%eax),%eax
f01106ad:	83 ec 08             	sub    $0x8,%esp
f01106b0:	68 f2 80 12 f0       	push   $0xf01280f2
f01106b5:	50                   	push   %eax
f01106b6:	e8 19 f6 00 00       	call   f011fcd4 <strcmp>
f01106bb:	83 c4 10             	add    $0x10,%esp
f01106be:	85 c0                	test   %eax,%eax
f01106c0:	75 0a                	jne    f01106cc <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f01106c2:	e8 bb 26 00 00       	call   f0112d82 <test_copy_paste_chunk>
f01106c7:	e9 8e 00 00 00       	jmp    f011075a <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f01106cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106cf:	83 c0 04             	add    $0x4,%eax
f01106d2:	8b 00                	mov    (%eax),%eax
f01106d4:	83 ec 08             	sub    $0x8,%esp
f01106d7:	68 fc 80 12 f0       	push   $0xf01280fc
f01106dc:	50                   	push   %eax
f01106dd:	e8 f2 f5 00 00       	call   f011fcd4 <strcmp>
f01106e2:	83 c4 10             	add    $0x10,%esp
f01106e5:	85 c0                	test   %eax,%eax
f01106e7:	75 07                	jne    f01106f0 <tst_chunks+0x98>
	{
		test_share_chunk();
f01106e9:	e8 92 37 00 00       	call   f0113e80 <test_share_chunk>
f01106ee:	eb 6a                	jmp    f011075a <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f01106f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106f3:	83 c0 04             	add    $0x4,%eax
f01106f6:	8b 00                	mov    (%eax),%eax
f01106f8:	83 ec 08             	sub    $0x8,%esp
f01106fb:	68 02 81 12 f0       	push   $0xf0128102
f0110700:	50                   	push   %eax
f0110701:	e8 ce f5 00 00       	call   f011fcd4 <strcmp>
f0110706:	83 c4 10             	add    $0x10,%esp
f0110709:	85 c0                	test   %eax,%eax
f011070b:	75 07                	jne    f0110714 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f011070d:	e8 96 41 00 00       	call   f01148a8 <test_allocate_chunk>
f0110712:	eb 46                	jmp    f011075a <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f0110714:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110717:	83 c0 04             	add    $0x4,%eax
f011071a:	8b 00                	mov    (%eax),%eax
f011071c:	83 ec 08             	sub    $0x8,%esp
f011071f:	68 0b 81 12 f0       	push   $0xf012810b
f0110724:	50                   	push   %eax
f0110725:	e8 aa f5 00 00       	call   f011fcd4 <strcmp>
f011072a:	83 c4 10             	add    $0x10,%esp
f011072d:	85 c0                	test   %eax,%eax
f011072f:	75 07                	jne    f0110738 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f0110731:	e8 79 4a 00 00       	call   f01151af <test_calculate_required_frames>
f0110736:	eb 22                	jmp    f011075a <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f0110738:	8b 45 0c             	mov    0xc(%ebp),%eax
f011073b:	83 c0 04             	add    $0x4,%eax
f011073e:	8b 00                	mov    (%eax),%eax
f0110740:	83 ec 08             	sub    $0x8,%esp
f0110743:	68 1a 81 12 f0       	push   $0xf012811a
f0110748:	50                   	push   %eax
f0110749:	e8 86 f5 00 00       	call   f011fcd4 <strcmp>
f011074e:	83 c4 10             	add    $0x10,%esp
f0110751:	85 c0                	test   %eax,%eax
f0110753:	75 05                	jne    f011075a <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0110755:	e8 c9 52 00 00       	call   f0115a23 <test_calculate_allocated_space>
	}
	return 0;
f011075a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011075f:	c9                   	leave  
f0110760:	c3                   	ret    

f0110761 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f0110761:	55                   	push   %ebp
f0110762:	89 e5                	mov    %esp,%ebp
f0110764:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110767:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011076b:	74 1a                	je     f0110787 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f011076d:	83 ec 0c             	sub    $0xc,%esp
f0110770:	68 2c 81 12 f0       	push   $0xf012812c
f0110775:	e8 11 08 ff ff       	call   f0100f8b <cprintf>
f011077a:	83 c4 10             	add    $0x10,%esp
		return 0;
f011077d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110782:	e9 ba 00 00 00       	jmp    f0110841 <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f0110787:	8b 45 0c             	mov    0xc(%ebp),%eax
f011078a:	83 c0 04             	add    $0x4,%eax
f011078d:	8b 00                	mov    (%eax),%eax
f011078f:	83 ec 08             	sub    $0x8,%esp
f0110792:	68 62 81 12 f0       	push   $0xf0128162
f0110797:	50                   	push   %eax
f0110798:	e8 37 f5 00 00       	call   f011fcd4 <strcmp>
f011079d:	83 c4 10             	add    $0x10,%esp
f01107a0:	85 c0                	test   %eax,%eax
f01107a2:	75 0a                	jne    f01107ae <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f01107a4:	e8 01 16 00 00       	call   f0111daa <test_pt_set_page_permissions>
f01107a9:	e9 8e 00 00 00       	jmp    f011083c <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f01107ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107b1:	83 c0 04             	add    $0x4,%eax
f01107b4:	8b 00                	mov    (%eax),%eax
f01107b6:	83 ec 08             	sub    $0x8,%esp
f01107b9:	68 6a 81 12 f0       	push   $0xf012816a
f01107be:	50                   	push   %eax
f01107bf:	e8 10 f5 00 00       	call   f011fcd4 <strcmp>
f01107c4:	83 c4 10             	add    $0x10,%esp
f01107c7:	85 c0                	test   %eax,%eax
f01107c9:	75 07                	jne    f01107d2 <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f01107cb:	e8 49 18 00 00       	call   f0112019 <test_pt_set_page_permissions_invalid_va>
f01107d0:	eb 6a                	jmp    f011083c <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f01107d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107d5:	83 c0 04             	add    $0x4,%eax
f01107d8:	8b 00                	mov    (%eax),%eax
f01107da:	83 ec 08             	sub    $0x8,%esp
f01107dd:	68 72 81 12 f0       	push   $0xf0128172
f01107e2:	50                   	push   %eax
f01107e3:	e8 ec f4 00 00       	call   f011fcd4 <strcmp>
f01107e8:	83 c4 10             	add    $0x10,%esp
f01107eb:	85 c0                	test   %eax,%eax
f01107ed:	75 07                	jne    f01107f6 <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f01107ef:	e8 6e 18 00 00       	call   f0112062 <test_pt_get_page_permissions>
f01107f4:	eb 46                	jmp    f011083c <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f01107f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107f9:	83 c0 04             	add    $0x4,%eax
f01107fc:	8b 00                	mov    (%eax),%eax
f01107fe:	83 ec 08             	sub    $0x8,%esp
f0110801:	68 7a 81 12 f0       	push   $0xf012817a
f0110806:	50                   	push   %eax
f0110807:	e8 c8 f4 00 00       	call   f011fcd4 <strcmp>
f011080c:	83 c4 10             	add    $0x10,%esp
f011080f:	85 c0                	test   %eax,%eax
f0110811:	75 07                	jne    f011081a <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f0110813:	e8 8e 19 00 00       	call   f01121a6 <test_pt_clear_page_table_entry>
f0110818:	eb 22                	jmp    f011083c <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f011081a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011081d:	83 c0 04             	add    $0x4,%eax
f0110820:	8b 00                	mov    (%eax),%eax
f0110822:	83 ec 08             	sub    $0x8,%esp
f0110825:	68 81 81 12 f0       	push   $0xf0128181
f011082a:	50                   	push   %eax
f011082b:	e8 a4 f4 00 00       	call   f011fcd4 <strcmp>
f0110830:	83 c4 10             	add    $0x10,%esp
f0110833:	85 c0                	test   %eax,%eax
f0110835:	75 05                	jne    f011083c <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f0110837:	e8 c3 1a 00 00       	call   f01122ff <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f011083c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110841:	c9                   	leave  
f0110842:	c3                   	ret    

f0110843 <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f0110843:	55                   	push   %ebp
f0110844:	89 e5                	mov    %esp,%ebp
f0110846:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f0110849:	8b 45 0c             	mov    0xc(%ebp),%eax
f011084c:	83 c0 08             	add    $0x8,%eax
f011084f:	8b 00                	mov    (%eax),%eax
f0110851:	83 ec 08             	sub    $0x8,%esp
f0110854:	68 88 81 12 f0       	push   $0xf0128188
f0110859:	50                   	push   %eax
f011085a:	e8 75 f4 00 00       	call   f011fcd4 <strcmp>
f011085f:	83 c4 10             	add    $0x10,%esp
f0110862:	85 c0                	test   %eax,%eax
f0110864:	75 20                	jne    f0110886 <tst_kheap+0x43>
f0110866:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f011086a:	74 1a                	je     f0110886 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f011086c:	83 ec 0c             	sub    $0xc,%esp
f011086f:	68 90 81 12 f0       	push   $0xf0128190
f0110874:	e8 12 07 ff ff       	call   f0100f8b <cprintf>
f0110879:	83 c4 10             	add    $0x10,%esp
		return 0;
f011087c:	b8 00 00 00 00       	mov    $0x0,%eax
f0110881:	e9 42 04 00 00       	jmp    f0110cc8 <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f0110886:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110889:	83 c0 08             	add    $0x8,%eax
f011088c:	8b 00                	mov    (%eax),%eax
f011088e:	83 ec 08             	sub    $0x8,%esp
f0110891:	68 88 81 12 f0       	push   $0xf0128188
f0110896:	50                   	push   %eax
f0110897:	e8 38 f4 00 00       	call   f011fcd4 <strcmp>
f011089c:	83 c4 10             	add    $0x10,%esp
f011089f:	85 c0                	test   %eax,%eax
f01108a1:	74 43                	je     f01108e6 <tst_kheap+0xa3>
f01108a3:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01108a7:	74 3d                	je     f01108e6 <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f01108a9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108ac:	83 c0 08             	add    $0x8,%eax
f01108af:	8b 00                	mov    (%eax),%eax
f01108b1:	83 ec 08             	sub    $0x8,%esp
f01108b4:	68 e0 81 12 f0       	push   $0xf01281e0
f01108b9:	50                   	push   %eax
f01108ba:	e8 15 f4 00 00       	call   f011fcd4 <strcmp>
f01108bf:	83 c4 10             	add    $0x10,%esp
f01108c2:	85 c0                	test   %eax,%eax
f01108c4:	74 20                	je     f01108e6 <tst_kheap+0xa3>
f01108c6:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f01108ca:	74 1a                	je     f01108e6 <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f01108cc:	83 ec 0c             	sub    $0xc,%esp
f01108cf:	68 ec 81 12 f0       	push   $0xf01281ec
f01108d4:	e8 b2 06 ff ff       	call   f0100f8b <cprintf>
f01108d9:	83 c4 10             	add    $0x10,%esp
			return 0;
f01108dc:	b8 00 00 00 00       	mov    $0x0,%eax
f01108e1:	e9 e2 03 00 00       	jmp    f0110cc8 <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f01108e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108e9:	83 c0 04             	add    $0x4,%eax
f01108ec:	8b 00                	mov    (%eax),%eax
f01108ee:	83 ec 08             	sub    $0x8,%esp
f01108f1:	68 31 82 12 f0       	push   $0xf0128231
f01108f6:	50                   	push   %eax
f01108f7:	e8 d8 f3 00 00       	call   f011fcd4 <strcmp>
f01108fc:	83 c4 10             	add    $0x10,%esp
f01108ff:	85 c0                	test   %eax,%eax
f0110901:	74 1d                	je     f0110920 <tst_kheap+0xdd>
f0110903:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110906:	83 c0 04             	add    $0x4,%eax
f0110909:	8b 00                	mov    (%eax),%eax
f011090b:	83 ec 08             	sub    $0x8,%esp
f011090e:	68 34 82 12 f0       	push   $0xf0128234
f0110913:	50                   	push   %eax
f0110914:	e8 bb f3 00 00       	call   f011fcd4 <strcmp>
f0110919:	83 c4 10             	add    $0x10,%esp
f011091c:	85 c0                	test   %eax,%eax
f011091e:	75 1a                	jne    f011093a <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f0110920:	e8 6d f8 ff ff       	call   f0110192 <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110925:	83 ec 0c             	sub    $0xc,%esp
f0110928:	68 38 82 12 f0       	push   $0xf0128238
f011092d:	e8 59 06 ff ff       	call   f0100f8b <cprintf>
f0110932:	83 c4 10             	add    $0x10,%esp
f0110935:	e9 a0 00 00 00       	jmp    f01109da <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f011093a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011093d:	83 c0 04             	add    $0x4,%eax
f0110940:	8b 00                	mov    (%eax),%eax
f0110942:	83 ec 08             	sub    $0x8,%esp
f0110945:	68 65 82 12 f0       	push   $0xf0128265
f011094a:	50                   	push   %eax
f011094b:	e8 84 f3 00 00       	call   f011fcd4 <strcmp>
f0110950:	83 c4 10             	add    $0x10,%esp
f0110953:	85 c0                	test   %eax,%eax
f0110955:	74 1d                	je     f0110974 <tst_kheap+0x131>
f0110957:	8b 45 0c             	mov    0xc(%ebp),%eax
f011095a:	83 c0 04             	add    $0x4,%eax
f011095d:	8b 00                	mov    (%eax),%eax
f011095f:	83 ec 08             	sub    $0x8,%esp
f0110962:	68 68 82 12 f0       	push   $0xf0128268
f0110967:	50                   	push   %eax
f0110968:	e8 67 f3 00 00       	call   f011fcd4 <strcmp>
f011096d:	83 c4 10             	add    $0x10,%esp
f0110970:	85 c0                	test   %eax,%eax
f0110972:	75 17                	jne    f011098b <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f0110974:	e8 29 f8 ff ff       	call   f01101a2 <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0110979:	83 ec 0c             	sub    $0xc,%esp
f011097c:	68 6c 82 12 f0       	push   $0xf012826c
f0110981:	e8 05 06 ff ff       	call   f0100f8b <cprintf>
f0110986:	83 c4 10             	add    $0x10,%esp
f0110989:	eb 4f                	jmp    f01109da <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f011098b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011098e:	83 c0 04             	add    $0x4,%eax
f0110991:	8b 00                	mov    (%eax),%eax
f0110993:	83 ec 08             	sub    $0x8,%esp
f0110996:	68 98 82 12 f0       	push   $0xf0128298
f011099b:	50                   	push   %eax
f011099c:	e8 33 f3 00 00       	call   f011fcd4 <strcmp>
f01109a1:	83 c4 10             	add    $0x10,%esp
f01109a4:	85 c0                	test   %eax,%eax
f01109a6:	74 1d                	je     f01109c5 <tst_kheap+0x182>
f01109a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109ab:	83 c0 04             	add    $0x4,%eax
f01109ae:	8b 00                	mov    (%eax),%eax
f01109b0:	83 ec 08             	sub    $0x8,%esp
f01109b3:	68 9b 82 12 f0       	push   $0xf012829b
f01109b8:	50                   	push   %eax
f01109b9:	e8 16 f3 00 00       	call   f011fcd4 <strcmp>
f01109be:	83 c4 10             	add    $0x10,%esp
f01109c1:	85 c0                	test   %eax,%eax
f01109c3:	75 15                	jne    f01109da <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f01109c5:	e8 e8 f7 ff ff       	call   f01101b2 <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f01109ca:	83 ec 0c             	sub    $0xc,%esp
f01109cd:	68 a0 82 12 f0       	push   $0xf01282a0
f01109d2:	e8 b4 05 ff ff       	call   f0100f8b <cprintf>
f01109d7:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f01109da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109dd:	83 c0 08             	add    $0x8,%eax
f01109e0:	8b 00                	mov    (%eax),%eax
f01109e2:	83 ec 08             	sub    $0x8,%esp
f01109e5:	68 88 81 12 f0       	push   $0xf0128188
f01109ea:	50                   	push   %eax
f01109eb:	e8 e4 f2 00 00       	call   f011fcd4 <strcmp>
f01109f0:	83 c4 10             	add    $0x10,%esp
f01109f3:	85 c0                	test   %eax,%eax
f01109f5:	0f 85 13 01 00 00    	jne    f0110b0e <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f01109fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109fe:	83 c0 0c             	add    $0xc,%eax
f0110a01:	8b 00                	mov    (%eax),%eax
f0110a03:	83 ec 04             	sub    $0x4,%esp
f0110a06:	6a 0a                	push   $0xa
f0110a08:	6a 00                	push   $0x0
f0110a0a:	50                   	push   %eax
f0110a0b:	e8 18 f5 00 00       	call   f011ff28 <strtol>
f0110a10:	83 c4 10             	add    $0x10,%esp
f0110a13:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110a16:	e8 a7 f7 ff ff       	call   f01101c2 <isKHeapPlacementStrategyFIRSTFIT>
f0110a1b:	84 c0                	test   %al,%al
f0110a1d:	74 54                	je     f0110a73 <tst_kheap+0x230>
		{
			if (testNum == 0)
f0110a1f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110a23:	75 1a                	jne    f0110a3f <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110a25:	83 ec 0c             	sub    $0xc,%esp
f0110a28:	68 cc 82 12 f0       	push   $0xf01282cc
f0110a2d:	e8 59 05 ff ff       	call   f0100f8b <cprintf>
f0110a32:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110a35:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a3a:	e9 89 02 00 00       	jmp    f0110cc8 <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f0110a3f:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110a43:	75 0a                	jne    f0110a4f <tst_kheap+0x20c>
				test_kmalloc();
f0110a45:	e8 ec 61 00 00       	call   f0116c36 <test_kmalloc>
f0110a4a:	e9 b5 00 00 00       	jmp    f0110b04 <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110a4f:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110a53:	75 0a                	jne    f0110a5f <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f0110a55:	e8 68 6d 00 00       	call   f01177c2 <test_kmalloc_firstfit1>
f0110a5a:	e9 a5 00 00 00       	jmp    f0110b04 <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110a5f:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110a63:	0f 85 9b 00 00 00    	jne    f0110b04 <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f0110a69:	e8 38 78 00 00       	call   f01182a6 <test_kmalloc_firstfit2>
f0110a6e:	e9 91 00 00 00       	jmp    f0110b04 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f0110a73:	e8 5f f7 ff ff       	call   f01101d7 <isKHeapPlacementStrategyBESTFIT>
f0110a78:	84 c0                	test   %al,%al
f0110a7a:	74 47                	je     f0110ac3 <tst_kheap+0x280>
		{
			if (testNum == 0)
f0110a7c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110a80:	75 1a                	jne    f0110a9c <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f0110a82:	83 ec 0c             	sub    $0xc,%esp
f0110a85:	68 1c 83 12 f0       	push   $0xf012831c
f0110a8a:	e8 fc 04 ff ff       	call   f0100f8b <cprintf>
f0110a8f:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110a92:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a97:	e9 2c 02 00 00       	jmp    f0110cc8 <tst_kheap+0x485>
			}
			if (testNum == 1)
f0110a9c:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110aa0:	75 07                	jne    f0110aa9 <tst_kheap+0x266>
				test_kmalloc();
f0110aa2:	e8 8f 61 00 00       	call   f0116c36 <test_kmalloc>
f0110aa7:	eb 5b                	jmp    f0110b04 <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110aa9:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110aad:	75 07                	jne    f0110ab6 <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f0110aaf:	e8 2b c8 00 00       	call   f011d2df <test_kmalloc_bestfit1>
f0110ab4:	eb 4e                	jmp    f0110b04 <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110ab6:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110aba:	75 48                	jne    f0110b04 <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f0110abc:	e8 3b c8 00 00       	call   f011d2fc <test_kmalloc_bestfit2>
f0110ac1:	eb 41                	jmp    f0110b04 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f0110ac3:	e8 24 f7 ff ff       	call   f01101ec <isKHeapPlacementStrategyNEXTFIT>
f0110ac8:	84 c0                	test   %al,%al
f0110aca:	74 38                	je     f0110b04 <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f0110acc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110ad0:	75 1a                	jne    f0110aec <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f0110ad2:	83 ec 0c             	sub    $0xc,%esp
f0110ad5:	68 6c 83 12 f0       	push   $0xf012836c
f0110ada:	e8 ac 04 ff ff       	call   f0100f8b <cprintf>
f0110adf:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110ae2:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ae7:	e9 dc 01 00 00       	jmp    f0110cc8 <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f0110aec:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110af0:	75 07                	jne    f0110af9 <tst_kheap+0x2b6>
				test_kmalloc();
f0110af2:	e8 3f 61 00 00       	call   f0116c36 <test_kmalloc>
f0110af7:	eb 0b                	jmp    f0110b04 <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f0110af9:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110afd:	75 05                	jne    f0110b04 <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f0110aff:	e8 be c7 00 00       	call   f011d2c2 <test_kmalloc_nextfit>
		}
		return 0;
f0110b04:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b09:	e9 ba 01 00 00       	jmp    f0110cc8 <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f0110b0e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b11:	83 c0 08             	add    $0x8,%eax
f0110b14:	8b 00                	mov    (%eax),%eax
f0110b16:	83 ec 08             	sub    $0x8,%esp
f0110b19:	68 ba 83 12 f0       	push   $0xf01283ba
f0110b1e:	50                   	push   %eax
f0110b1f:	e8 b0 f1 00 00       	call   f011fcd4 <strcmp>
f0110b24:	83 c4 10             	add    $0x10,%esp
f0110b27:	85 c0                	test   %eax,%eax
f0110b29:	75 2f                	jne    f0110b5a <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110b2b:	e8 92 f6 ff ff       	call   f01101c2 <isKHeapPlacementStrategyFIRSTFIT>
f0110b30:	84 c0                	test   %al,%al
f0110b32:	74 0f                	je     f0110b43 <tst_kheap+0x300>
		{
			test_fastfirstfit();
f0110b34:	e8 74 82 00 00       	call   f0118dad <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f0110b39:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b3e:	e9 85 01 00 00       	jmp    f0110cc8 <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f0110b43:	83 ec 04             	sub    $0x4,%esp
f0110b46:	68 c0 83 12 f0       	push   $0xf01283c0
f0110b4b:	68 ac 01 00 00       	push   $0x1ac
f0110b50:	68 a7 7f 12 f0       	push   $0xf0127fa7
f0110b55:	e8 df f7 fe ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f0110b5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b5d:	83 c0 08             	add    $0x8,%eax
f0110b60:	8b 00                	mov    (%eax),%eax
f0110b62:	83 ec 08             	sub    $0x8,%esp
f0110b65:	68 01 84 12 f0       	push   $0xf0128401
f0110b6a:	50                   	push   %eax
f0110b6b:	e8 64 f1 00 00       	call   f011fcd4 <strcmp>
f0110b70:	83 c4 10             	add    $0x10,%esp
f0110b73:	85 c0                	test   %eax,%eax
f0110b75:	75 28                	jne    f0110b9f <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f0110b77:	e8 5b f6 ff ff       	call   f01101d7 <isKHeapPlacementStrategyBESTFIT>
f0110b7c:	84 c0                	test   %al,%al
f0110b7e:	75 09                	jne    f0110b89 <tst_kheap+0x346>
f0110b80:	e8 3d f6 ff ff       	call   f01101c2 <isKHeapPlacementStrategyFIRSTFIT>
f0110b85:	84 c0                	test   %al,%al
f0110b87:	74 07                	je     f0110b90 <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f0110b89:	e8 ee 8a 00 00       	call   f011967c <test_kfree_bestfirstfit>
f0110b8e:	eb 05                	jmp    f0110b95 <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f0110b90:	e8 a1 c7 00 00       	call   f011d336 <test_kfree>
		}
		return 0;
f0110b95:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b9a:	e9 29 01 00 00       	jmp    f0110cc8 <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f0110b9f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ba2:	83 c0 08             	add    $0x8,%eax
f0110ba5:	8b 00                	mov    (%eax),%eax
f0110ba7:	83 ec 08             	sub    $0x8,%esp
f0110baa:	68 07 84 12 f0       	push   $0xf0128407
f0110baf:	50                   	push   %eax
f0110bb0:	e8 1f f1 00 00       	call   f011fcd4 <strcmp>
f0110bb5:	83 c4 10             	add    $0x10,%esp
f0110bb8:	85 c0                	test   %eax,%eax
f0110bba:	75 0f                	jne    f0110bcb <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f0110bbc:	e8 17 a1 00 00       	call   f011acd8 <test_kheap_phys_addr>
		return 0;
f0110bc1:	b8 00 00 00 00       	mov    $0x0,%eax
f0110bc6:	e9 fd 00 00 00       	jmp    f0110cc8 <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f0110bcb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bce:	83 c0 08             	add    $0x8,%eax
f0110bd1:	8b 00                	mov    (%eax),%eax
f0110bd3:	83 ec 08             	sub    $0x8,%esp
f0110bd6:	68 11 84 12 f0       	push   $0xf0128411
f0110bdb:	50                   	push   %eax
f0110bdc:	e8 f3 f0 00 00       	call   f011fcd4 <strcmp>
f0110be1:	83 c4 10             	add    $0x10,%esp
f0110be4:	85 c0                	test   %eax,%eax
f0110be6:	75 0f                	jne    f0110bf7 <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f0110be8:	e8 ce ae 00 00       	call   f011babb <test_kheap_virt_addr>
		return 0;
f0110bed:	b8 00 00 00 00       	mov    $0x0,%eax
f0110bf2:	e9 d1 00 00 00       	jmp    f0110cc8 <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f0110bf7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bfa:	83 c0 08             	add    $0x8,%eax
f0110bfd:	8b 00                	mov    (%eax),%eax
f0110bff:	83 ec 08             	sub    $0x8,%esp
f0110c02:	68 e0 81 12 f0       	push   $0xf01281e0
f0110c07:	50                   	push   %eax
f0110c08:	e8 c7 f0 00 00       	call   f011fcd4 <strcmp>
f0110c0d:	83 c4 10             	add    $0x10,%esp
f0110c10:	85 c0                	test   %eax,%eax
f0110c12:	0f 85 89 00 00 00    	jne    f0110ca1 <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110c18:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c1b:	83 c0 0c             	add    $0xc,%eax
f0110c1e:	8b 00                	mov    (%eax),%eax
f0110c20:	83 ec 04             	sub    $0x4,%esp
f0110c23:	6a 0a                	push   $0xa
f0110c25:	6a 00                	push   $0x0
f0110c27:	50                   	push   %eax
f0110c28:	e8 fb f2 00 00       	call   f011ff28 <strtol>
f0110c2d:	83 c4 10             	add    $0x10,%esp
f0110c30:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110c33:	e8 8a f5 ff ff       	call   f01101c2 <isKHeapPlacementStrategyFIRSTFIT>
f0110c38:	84 c0                	test   %al,%al
f0110c3a:	74 42                	je     f0110c7e <tst_kheap+0x43b>
		{
			if (testNum == 0)
f0110c3c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110c40:	75 17                	jne    f0110c59 <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110c42:	83 ec 0c             	sub    $0xc,%esp
f0110c45:	68 cc 82 12 f0       	push   $0xf01282cc
f0110c4a:	e8 3c 03 ff ff       	call   f0100f8b <cprintf>
f0110c4f:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110c52:	b8 00 00 00 00       	mov    $0x0,%eax
f0110c57:	eb 6f                	jmp    f0110cc8 <tst_kheap+0x485>
			}
			if (testNum==1)
f0110c59:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110c5d:	75 07                	jne    f0110c66 <tst_kheap+0x423>
				test_krealloc_FF1();
f0110c5f:	e8 50 c9 00 00       	call   f011d5b4 <test_krealloc_FF1>
f0110c64:	eb 18                	jmp    f0110c7e <tst_kheap+0x43b>
			else if (testNum==2)
f0110c66:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f0110c6a:	75 07                	jne    f0110c73 <tst_kheap+0x430>
				test_krealloc_FF2();
f0110c6c:	e8 60 c9 00 00       	call   f011d5d1 <test_krealloc_FF2>
f0110c71:	eb 0b                	jmp    f0110c7e <tst_kheap+0x43b>
			else if (testNum==3)
f0110c73:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0110c77:	75 05                	jne    f0110c7e <tst_kheap+0x43b>
				test_krealloc_FF3();
f0110c79:	e8 70 c9 00 00       	call   f011d5ee <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f0110c7e:	e8 69 f5 ff ff       	call   f01101ec <isKHeapPlacementStrategyNEXTFIT>
f0110c83:	84 c0                	test   %al,%al
f0110c85:	74 05                	je     f0110c8c <tst_kheap+0x449>
		{
			test_krealloc();
f0110c87:	e8 ee c8 00 00       	call   f011d57a <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f0110c8c:	e8 46 f5 ff ff       	call   f01101d7 <isKHeapPlacementStrategyBESTFIT>
f0110c91:	84 c0                	test   %al,%al
f0110c93:	74 05                	je     f0110c9a <tst_kheap+0x457>
		{
			test_krealloc_BF();
f0110c95:	e8 fd c8 00 00       	call   f011d597 <test_krealloc_BF>
		}
		return 0;
f0110c9a:	b8 00 00 00 00       	mov    $0x0,%eax
f0110c9f:	eb 27                	jmp    f0110cc8 <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f0110ca1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ca4:	83 c0 08             	add    $0x8,%eax
f0110ca7:	8b 00                	mov    (%eax),%eax
f0110ca9:	83 ec 08             	sub    $0x8,%esp
f0110cac:	68 1b 84 12 f0       	push   $0xf012841b
f0110cb1:	50                   	push   %eax
f0110cb2:	e8 1d f0 00 00       	call   f011fcd4 <strcmp>
f0110cb7:	83 c4 10             	add    $0x10,%esp
f0110cba:	85 c0                	test   %eax,%eax
f0110cbc:	75 05                	jne    f0110cc3 <tst_kheap+0x480>
	{
		test_ksbrk();
f0110cbe:	e8 1d bb 00 00       	call   f011c7e0 <test_ksbrk>
	}
	return 0;
f0110cc3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110cc8:	c9                   	leave  
f0110cc9:	c3                   	ret    

f0110cca <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f0110cca:	55                   	push   %ebp
f0110ccb:	89 e5                	mov    %esp,%ebp
f0110ccd:	83 ec 28             	sub    $0x28,%esp
f0110cd0:	8b 45 14             	mov    0x14(%ebp),%eax
f0110cd3:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f0110cd6:	8b 45 08             	mov    0x8(%ebp),%eax
f0110cd9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110cdc:	74 1d                	je     f0110cfb <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f0110cde:	83 ec 04             	sub    $0x4,%esp
f0110ce1:	ff 75 08             	pushl  0x8(%ebp)
f0110ce4:	ff 75 0c             	pushl  0xc(%ebp)
f0110ce7:	68 20 84 12 f0       	push   $0xf0128420
f0110cec:	e8 9a 02 ff ff       	call   f0100f8b <cprintf>
f0110cf1:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110cf4:	b8 00 00 00 00       	mov    $0x0,%eax
f0110cf9:	eb 55                	jmp    f0110d50 <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f0110cfb:	8b 45 08             	mov    0x8(%ebp),%eax
f0110cfe:	8b 40 fc             	mov    -0x4(%eax),%eax
f0110d01:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f0110d04:	8b 45 10             	mov    0x10(%ebp),%eax
f0110d07:	8d 50 f8             	lea    -0x8(%eax),%edx
f0110d0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0110d0d:	01 d0                	add    %edx,%eax
f0110d0f:	8b 00                	mov    (%eax),%eax
f0110d11:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f0110d14:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0110d18:	0b 45 10             	or     0x10(%ebp),%eax
f0110d1b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f0110d1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110d21:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110d24:	75 08                	jne    f0110d2e <check_block+0x64>
f0110d26:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110d29:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110d2c:	74 1d                	je     f0110d4b <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f0110d2e:	ff 75 f0             	pushl  -0x10(%ebp)
f0110d31:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d34:	ff 75 ec             	pushl  -0x14(%ebp)
f0110d37:	68 50 84 12 f0       	push   $0xf0128450
f0110d3c:	e8 4a 02 ff ff       	call   f0100f8b <cprintf>
f0110d41:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110d44:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d49:	eb 05                	jmp    f0110d50 <check_block+0x86>
	}
	return 1;
f0110d4b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110d50:	c9                   	leave  
f0110d51:	c3                   	ret    

f0110d52 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f0110d52:	55                   	push   %ebp
f0110d53:	89 e5                	mov    %esp,%ebp
f0110d55:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f0110d58:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0110d5d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0110d60:	74 20                	je     f0110d82 <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f0110d62:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0110d67:	83 ec 04             	sub    $0x4,%esp
f0110d6a:	50                   	push   %eax
f0110d6b:	ff 75 08             	pushl  0x8(%ebp)
f0110d6e:	68 8c 84 12 f0       	push   $0xf012848c
f0110d73:	e8 13 02 ff ff       	call   f0100f8b <cprintf>
f0110d78:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110d7b:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d80:	eb 05                	jmp    f0110d87 <check_list_size+0x35>
	}
	return 1;
f0110d82:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110d87:	c9                   	leave  
f0110d88:	c3                   	ret    

f0110d89 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f0110d89:	55                   	push   %ebp
f0110d8a:	89 e5                	mov    %esp,%ebp
f0110d8c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f0110d8f:	83 ec 04             	sub    $0x4,%esp
f0110d92:	68 c0 84 12 f0       	push   $0xf01284c0
f0110d97:	6a 3f                	push   $0x3f
f0110d99:	68 20 85 12 f0       	push   $0xf0128520
f0110d9e:	e8 96 f5 fe ff       	call   f0100339 <_panic>

f0110da3 <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f0110da3:	55                   	push   %ebp
f0110da4:	89 e5                	mov    %esp,%ebp
f0110da6:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110da9:	83 ec 04             	sub    $0x4,%esp
f0110dac:	68 44 85 12 f0       	push   $0xf0128544
f0110db1:	6a 61                	push   $0x61
f0110db3:	68 20 85 12 f0       	push   $0xf0128520
f0110db8:	e8 7c f5 fe ff       	call   f0100339 <_panic>

f0110dbd <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f0110dbd:	55                   	push   %ebp
f0110dbe:	89 e5                	mov    %esp,%ebp
f0110dc0:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110dc3:	83 ec 04             	sub    $0x4,%esp
f0110dc6:	68 94 85 12 f0       	push   $0xf0128594
f0110dcb:	68 e7 00 00 00       	push   $0xe7
f0110dd0:	68 20 85 12 f0       	push   $0xf0128520
f0110dd5:	e8 5f f5 fe ff       	call   f0100339 <_panic>

f0110dda <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f0110dda:	55                   	push   %ebp
f0110ddb:	89 e5                	mov    %esp,%ebp
f0110ddd:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110de3:	83 ec 04             	sub    $0x4,%esp
f0110de6:	68 e8 85 12 f0       	push   $0xf01285e8
f0110deb:	68 88 01 00 00       	push   $0x188
f0110df0:	68 20 85 12 f0       	push   $0xf0128520
f0110df5:	e8 3f f5 fe ff       	call   f0100339 <_panic>

f0110dfa <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f0110dfa:	55                   	push   %ebp
f0110dfb:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f0110dfd:	90                   	nop
f0110dfe:	5d                   	pop    %ebp
f0110dff:	c3                   	ret    

f0110e00 <test_free_block_FF>:

void test_free_block_FF()
{
f0110e00:	55                   	push   %ebp
f0110e01:	89 e5                	mov    %esp,%ebp
f0110e03:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110e06:	83 ec 04             	sub    $0x4,%esp
f0110e09:	68 3c 86 12 f0       	push   $0xf012863c
f0110e0e:	68 4e 02 00 00       	push   $0x24e
f0110e13:	68 20 85 12 f0       	push   $0xf0128520
f0110e18:	e8 1c f5 fe ff       	call   f0100339 <_panic>

f0110e1d <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f0110e1d:	55                   	push   %ebp
f0110e1e:	89 e5                	mov    %esp,%ebp
f0110e20:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110e23:	83 ec 04             	sub    $0x4,%esp
f0110e26:	68 3c 86 12 f0       	push   $0xf012863c
f0110e2b:	68 9a 03 00 00       	push   $0x39a
f0110e30:	68 20 85 12 f0       	push   $0xf0128520
f0110e35:	e8 ff f4 fe ff       	call   f0100339 <_panic>

f0110e3a <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f0110e3a:	55                   	push   %ebp
f0110e3b:	89 e5                	mov    %esp,%ebp
f0110e3d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f0110e40:	83 ec 04             	sub    $0x4,%esp
f0110e43:	68 89 86 12 f0       	push   $0xf0128689
f0110e48:	68 ba 04 00 00       	push   $0x4ba
f0110e4d:	68 20 85 12 f0       	push   $0xf0128520
f0110e52:	e8 e2 f4 fe ff       	call   f0100339 <_panic>

f0110e57 <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f0110e57:	55                   	push   %ebp
f0110e58:	89 e5                	mov    %esp,%ebp
f0110e5a:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110e5d:	83 ec 04             	sub    $0x4,%esp
f0110e60:	68 3c 86 12 f0       	push   $0xf012863c
f0110e65:	68 c0 04 00 00       	push   $0x4c0
f0110e6a:	68 20 85 12 f0       	push   $0xf0128520
f0110e6f:	e8 c5 f4 fe ff       	call   f0100339 <_panic>

f0110e74 <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f0110e74:	55                   	push   %ebp
f0110e75:	89 e5                	mov    %esp,%ebp
f0110e77:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110e7a:	83 ec 04             	sub    $0x4,%esp
f0110e7d:	68 3c 86 12 f0       	push   $0xf012863c
f0110e82:	68 e7 05 00 00       	push   $0x5e7
f0110e87:	68 20 85 12 f0       	push   $0xf0128520
f0110e8c:	e8 a8 f4 fe ff       	call   f0100339 <_panic>

f0110e91 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0110e91:	55                   	push   %ebp
f0110e92:	89 e5                	mov    %esp,%ebp
f0110e94:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0110e97:	e8 ef aa ff ff       	call   f010b98b <get_cpu_proc>
f0110e9c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0110e9f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110ea3:	75 16                	jne    f0110ebb <sys_check_LRU_lists+0x2a>
f0110ea5:	68 9c 86 12 f0       	push   $0xf012869c
f0110eaa:	68 ac 86 12 f0       	push   $0xf01286ac
f0110eaf:	6a 10                	push   $0x10
f0110eb1:	68 c1 86 12 f0       	push   $0xf01286c1
f0110eb6:	e8 7e f4 fe ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f0110ebb:	83 ec 0c             	sub    $0xc,%esp
f0110ebe:	68 e0 86 12 f0       	push   $0xf01286e0
f0110ec3:	e8 c3 00 ff ff       	call   f0100f8b <cprintf>
f0110ec8:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f0110ecb:	83 ec 0c             	sub    $0xc,%esp
f0110ece:	ff 75 e0             	pushl  -0x20(%ebp)
f0110ed1:	e8 f3 94 ff ff       	call   f010a3c9 <env_page_ws_print>
f0110ed6:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f0110ed9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110edc:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f0110edf:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f0110ee6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0110eed:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0110ef1:	0f 84 a5 00 00 00    	je     f0110f9c <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f0110ef7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110efe:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110f01:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0110f07:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110f0a:	eb 4a                	jmp    f0110f56 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0110f0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110f0f:	8b 00                	mov    (%eax),%eax
f0110f11:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0110f14:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110f17:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110f1c:	89 c2                	mov    %eax,%edx
f0110f1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110f21:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110f28:	8b 45 08             	mov    0x8(%ebp),%eax
f0110f2b:	01 c8                	add    %ecx,%eax
f0110f2d:	8b 00                	mov    (%eax),%eax
f0110f2f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0110f32:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110f35:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110f3a:	39 c2                	cmp    %eax,%edx
f0110f3c:	74 09                	je     f0110f47 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0110f3e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110f45:	eb 3e                	jmp    f0110f85 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f0110f47:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110f4a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110f4d:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110f53:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110f56:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110f5a:	74 08                	je     f0110f64 <sys_check_LRU_lists+0xd3>
f0110f5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110f5f:	8b 40 10             	mov    0x10(%eax),%eax
f0110f62:	eb 05                	jmp    f0110f69 <sys_check_LRU_lists+0xd8>
f0110f64:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f69:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0110f6c:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0110f72:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110f75:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110f7b:	85 c0                	test   %eax,%eax
f0110f7d:	75 8d                	jne    f0110f0c <sys_check_LRU_lists+0x7b>
f0110f7f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110f83:	75 87                	jne    f0110f0c <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f0110f85:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110f88:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f0110f8e:	8b 45 10             	mov    0x10(%ebp),%eax
f0110f91:	39 c2                	cmp    %eax,%edx
f0110f93:	74 07                	je     f0110f9c <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f0110f95:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0110f9c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0110fa0:	0f 84 a5 00 00 00    	je     f011104b <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f0110fa6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0110fad:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110fb0:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0110fb6:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110fb9:	eb 4a                	jmp    f0111005 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f0110fbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110fbe:	8b 00                	mov    (%eax),%eax
f0110fc0:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0110fc3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110fc6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110fcb:	89 c2                	mov    %eax,%edx
f0110fcd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110fd0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110fd7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110fda:	01 c8                	add    %ecx,%eax
f0110fdc:	8b 00                	mov    (%eax),%eax
f0110fde:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0110fe1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110fe4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110fe9:	39 c2                	cmp    %eax,%edx
f0110feb:	74 09                	je     f0110ff6 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f0110fed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f0110ff4:	eb 3e                	jmp    f0111034 <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f0110ff6:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0110ff9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110ffc:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0111002:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111005:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111009:	74 08                	je     f0111013 <sys_check_LRU_lists+0x182>
f011100b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011100e:	8b 40 10             	mov    0x10(%eax),%eax
f0111011:	eb 05                	jmp    f0111018 <sys_check_LRU_lists+0x187>
f0111013:	b8 00 00 00 00       	mov    $0x0,%eax
f0111018:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011101b:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0111021:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111024:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011102a:	85 c0                	test   %eax,%eax
f011102c:	75 8d                	jne    f0110fbb <sys_check_LRU_lists+0x12a>
f011102e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111032:	75 87                	jne    f0110fbb <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f0111034:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111037:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f011103d:	8b 45 14             	mov    0x14(%ebp),%eax
f0111040:	39 c2                	cmp    %eax,%edx
f0111042:	74 07                	je     f011104b <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f0111044:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f011104b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011104e:	23 45 f0             	and    -0x10(%ebp),%eax
}
f0111051:	c9                   	leave  
f0111052:	c3                   	ret    

f0111053 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f0111053:	55                   	push   %ebp
f0111054:	89 e5                	mov    %esp,%ebp
f0111056:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0111059:	e8 2d a9 ff ff       	call   f010b98b <get_cpu_proc>
f011105e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0111061:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0111065:	75 16                	jne    f011107d <sys_check_LRU_lists_free+0x2a>
f0111067:	68 9c 86 12 f0       	push   $0xf012869c
f011106c:	68 ac 86 12 f0       	push   $0xf01286ac
f0111071:	6a 45                	push   $0x45
f0111073:	68 c1 86 12 f0       	push   $0xf01286c1
f0111078:	e8 bc f2 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f011107d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111080:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0111083:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f011108a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011108d:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0111093:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111096:	eb 65                	jmp    f01110fd <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0111098:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011109f:	eb 3a                	jmp    f01110db <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f01110a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01110a4:	8b 00                	mov    (%eax),%eax
f01110a6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01110a9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01110ac:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01110b1:	89 c2                	mov    %eax,%edx
f01110b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01110b6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01110bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01110c0:	01 c8                	add    %ecx,%eax
f01110c2:	8b 00                	mov    (%eax),%eax
f01110c4:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01110c7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01110ca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01110cf:	39 c2                	cmp    %eax,%edx
f01110d1:	75 05                	jne    f01110d8 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f01110d3:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01110d6:	eb 0b                	jmp    f01110e3 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f01110d8:	ff 45 ec             	incl   -0x14(%ebp)
f01110db:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01110de:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01110e1:	7c be                	jl     f01110a1 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01110e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01110e7:	7e 08                	jle    f01110f1 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f01110e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01110ec:	e9 ed 00 00 00       	jmp    f01111de <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01110f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01110f4:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01110fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01110fd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111101:	74 08                	je     f011110b <sys_check_LRU_lists_free+0xb8>
f0111103:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111106:	8b 40 10             	mov    0x10(%eax),%eax
f0111109:	eb 05                	jmp    f0111110 <sys_check_LRU_lists_free+0xbd>
f011110b:	b8 00 00 00 00       	mov    $0x0,%eax
f0111110:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111113:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0111119:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011111c:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111122:	85 c0                	test   %eax,%eax
f0111124:	0f 85 6e ff ff ff    	jne    f0111098 <sys_check_LRU_lists_free+0x45>
f011112a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011112e:	0f 85 64 ff ff ff    	jne    f0111098 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111134:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111137:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f011113d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111140:	eb 62                	jmp    f01111a4 <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0111142:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111149:	eb 3a                	jmp    f0111185 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f011114b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011114e:	8b 00                	mov    (%eax),%eax
f0111150:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0111153:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111156:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011115b:	89 c2                	mov    %eax,%edx
f011115d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111160:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111167:	8b 45 08             	mov    0x8(%ebp),%eax
f011116a:	01 c8                	add    %ecx,%eax
f011116c:	8b 00                	mov    (%eax),%eax
f011116e:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0111171:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111174:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111179:	39 c2                	cmp    %eax,%edx
f011117b:	75 05                	jne    f0111182 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f011117d:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0111180:	eb 0b                	jmp    f011118d <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0111182:	ff 45 e8             	incl   -0x18(%ebp)
f0111185:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111188:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011118b:	7c be                	jl     f011114b <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f011118d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111191:	7e 05                	jle    f0111198 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0111193:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111196:	eb 46                	jmp    f01111de <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111198:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011119b:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01111a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01111a4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01111a8:	74 08                	je     f01111b2 <sys_check_LRU_lists_free+0x15f>
f01111aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01111ad:	8b 40 10             	mov    0x10(%eax),%eax
f01111b0:	eb 05                	jmp    f01111b7 <sys_check_LRU_lists_free+0x164>
f01111b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01111b7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01111ba:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f01111c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01111c3:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01111c9:	85 c0                	test   %eax,%eax
f01111cb:	0f 85 71 ff ff ff    	jne    f0111142 <sys_check_LRU_lists_free+0xef>
f01111d1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01111d5:	0f 85 67 ff ff ff    	jne    f0111142 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f01111db:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01111de:	c9                   	leave  
f01111df:	c3                   	ret    

f01111e0 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f01111e0:	55                   	push   %ebp
f01111e1:	89 e5                	mov    %esp,%ebp
f01111e3:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f01111e6:	e8 a0 a7 ff ff       	call   f010b98b <get_cpu_proc>
f01111eb:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f01111ee:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01111f2:	75 16                	jne    f011120a <sys_check_WS_list+0x2a>
f01111f4:	68 9c 86 12 f0       	push   $0xf012869c
f01111f9:	68 ac 86 12 f0       	push   $0xf01286ac
f01111fe:	6a 79                	push   $0x79
f0111200:	68 c1 86 12 f0       	push   $0xf01286c1
f0111205:	e8 2f f1 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f011120a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011120d:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f0111210:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f0111217:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f011121b:	74 06                	je     f0111223 <sys_check_WS_list+0x43>
f011121d:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111221:	75 1f                	jne    f0111242 <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0111223:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111226:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f011122c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011122f:	39 c2                	cmp    %eax,%edx
f0111231:	74 0f                	je     f0111242 <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f0111233:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011123a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011123d:	e9 15 03 00 00       	jmp    f0111557 <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f0111242:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0111246:	74 39                	je     f0111281 <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0111248:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011124b:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0111251:	8b 00                	mov    (%eax),%eax
f0111253:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0111256:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111259:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011125e:	89 c2                	mov    %eax,%edx
f0111260:	8b 45 10             	mov    0x10(%ebp),%eax
f0111263:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0111266:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111269:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011126e:	39 c2                	cmp    %eax,%edx
f0111270:	74 0f                	je     f0111281 <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f0111272:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111279:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011127c:	e9 d6 02 00 00       	jmp    f0111557 <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f0111281:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111285:	0f 85 3c 01 00 00    	jne    f01113c7 <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f011128b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f0111292:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0111296:	74 4c                	je     f01112e4 <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0111298:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011129f:	eb 3b                	jmp    f01112dc <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f01112a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01112a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01112ab:	8b 45 08             	mov    0x8(%ebp),%eax
f01112ae:	01 d0                	add    %edx,%eax
f01112b0:	8b 00                	mov    (%eax),%eax
f01112b2:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01112b5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01112b8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112bd:	89 c2                	mov    %eax,%edx
f01112bf:	8b 45 10             	mov    0x10(%ebp),%eax
f01112c2:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01112c5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01112c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112cd:	39 c2                	cmp    %eax,%edx
f01112cf:	75 08                	jne    f01112d9 <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f01112d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01112d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f01112d7:	eb 0b                	jmp    f01112e4 <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f01112d9:	ff 45 e8             	incl   -0x18(%ebp)
f01112dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01112df:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01112e2:	7c bd                	jl     f01112a1 <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f01112e4:	83 ec 08             	sub    $0x8,%esp
f01112e7:	ff 75 ec             	pushl  -0x14(%ebp)
f01112ea:	68 08 87 12 f0       	push   $0xf0128708
f01112ef:	e8 97 fc fe ff       	call   f0100f8b <cprintf>
f01112f4:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f01112f7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01112fa:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0111300:	85 c0                	test   %eax,%eax
f0111302:	74 0e                	je     f0111312 <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f0111304:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111307:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f011130d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111310:	eb 0c                	jmp    f011131e <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0111312:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111315:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011131b:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f011131e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111321:	8b 00                	mov    (%eax),%eax
f0111323:	83 ec 08             	sub    $0x8,%esp
f0111326:	50                   	push   %eax
f0111327:	68 27 87 12 f0       	push   $0xf0128727
f011132c:	e8 5a fc fe ff       	call   f0100f8b <cprintf>
f0111331:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111334:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011133b:	eb 79                	jmp    f01113b6 <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f011133d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111340:	8b 00                	mov    (%eax),%eax
f0111342:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0111345:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111348:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011134d:	89 c2                	mov    %eax,%edx
f011134f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111352:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111359:	8b 45 08             	mov    0x8(%ebp),%eax
f011135c:	01 c8                	add    %ecx,%eax
f011135e:	8b 00                	mov    (%eax),%eax
f0111360:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0111363:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111366:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011136b:	39 c2                	cmp    %eax,%edx
f011136d:	74 0c                	je     f011137b <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f011136f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111376:	e9 d9 01 00 00       	jmp    f0111554 <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f011137b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011137e:	40                   	inc    %eax
f011137f:	89 c2                	mov    %eax,%edx
f0111381:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111384:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011138a:	89 d0                	mov    %edx,%eax
f011138c:	ba 00 00 00 00       	mov    $0x0,%edx
f0111391:	f7 f1                	div    %ecx
f0111393:	89 d0                	mov    %edx,%eax
f0111395:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0111398:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011139b:	8b 40 10             	mov    0x10(%eax),%eax
f011139e:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f01113a1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01113a5:	75 0c                	jne    f01113b3 <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f01113a7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01113aa:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01113b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f01113b3:	ff 45 e4             	incl   -0x1c(%ebp)
f01113b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01113b9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01113bc:	0f 8c 7b ff ff ff    	jl     f011133d <sys_check_WS_list+0x15d>
f01113c2:	e9 8d 01 00 00       	jmp    f0111554 <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f01113c7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f01113cb:	74 0a                	je     f01113d7 <sys_check_WS_list+0x1f7>
f01113cd:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f01113d1:	0f 85 be 00 00 00    	jne    f0111495 <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01113d7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f01113de:	e9 a1 00 00 00       	jmp    f0111484 <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f01113e3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01113ea:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01113ed:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01113f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01113f6:	eb 47                	jmp    f011143f <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f01113f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01113fb:	8b 00                	mov    (%eax),%eax
f01113fd:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0111400:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111403:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111408:	89 c2                	mov    %eax,%edx
f011140a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011140d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111414:	8b 45 08             	mov    0x8(%ebp),%eax
f0111417:	01 c8                	add    %ecx,%eax
f0111419:	8b 00                	mov    (%eax),%eax
f011141b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f011141e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0111421:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111426:	39 c2                	cmp    %eax,%edx
f0111428:	75 09                	jne    f0111433 <sys_check_WS_list+0x253>
				{
					found = 1;
f011142a:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f0111431:	eb 3b                	jmp    f011146e <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111433:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111436:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f011143c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011143f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111443:	74 08                	je     f011144d <sys_check_WS_list+0x26d>
f0111445:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111448:	8b 40 10             	mov    0x10(%eax),%eax
f011144b:	eb 05                	jmp    f0111452 <sys_check_WS_list+0x272>
f011144d:	b8 00 00 00 00       	mov    $0x0,%eax
f0111452:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111455:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f011145b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011145e:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111464:	85 c0                	test   %eax,%eax
f0111466:	75 90                	jne    f01113f8 <sys_check_WS_list+0x218>
f0111468:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011146c:	75 8a                	jne    f01113f8 <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f011146e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0111472:	75 0d                	jne    f0111481 <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f0111474:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f011147b:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011147c:	e9 d3 00 00 00       	jmp    f0111554 <sys_check_WS_list+0x374>
f0111481:	ff 45 e0             	incl   -0x20(%ebp)
f0111484:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111487:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011148a:	0f 8c 53 ff ff ff    	jl     f01113e3 <sys_check_WS_list+0x203>
f0111490:	e9 bf 00 00 00       	jmp    f0111554 <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f0111495:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f0111499:	0f 85 b5 00 00 00    	jne    f0111554 <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011149f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01114a6:	e9 9d 00 00 00       	jmp    f0111548 <sys_check_WS_list+0x368>
		{
			bool found = 0;
f01114ab:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01114b2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114b5:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01114bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01114be:	eb 47                	jmp    f0111507 <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f01114c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01114c3:	8b 00                	mov    (%eax),%eax
f01114c5:	89 45 b0             	mov    %eax,-0x50(%ebp)
f01114c8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01114cb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01114d0:	89 c2                	mov    %eax,%edx
f01114d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01114d5:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01114dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01114df:	01 c8                	add    %ecx,%eax
f01114e1:	8b 00                	mov    (%eax),%eax
f01114e3:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01114e6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01114e9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01114ee:	39 c2                	cmp    %eax,%edx
f01114f0:	75 09                	jne    f01114fb <sys_check_WS_list+0x31b>
				{
					found = 1;
f01114f2:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f01114f9:	eb 3b                	jmp    f0111536 <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01114fb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114fe:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111504:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111507:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011150b:	74 08                	je     f0111515 <sys_check_WS_list+0x335>
f011150d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111510:	8b 40 10             	mov    0x10(%eax),%eax
f0111513:	eb 05                	jmp    f011151a <sys_check_WS_list+0x33a>
f0111515:	b8 00 00 00 00       	mov    $0x0,%eax
f011151a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011151d:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0111523:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111526:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f011152c:	85 c0                	test   %eax,%eax
f011152e:	75 90                	jne    f01114c0 <sys_check_WS_list+0x2e0>
f0111530:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111534:	75 8a                	jne    f01114c0 <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f0111536:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011153a:	74 09                	je     f0111545 <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f011153c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111543:	eb 0f                	jmp    f0111554 <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111545:	ff 45 d8             	incl   -0x28(%ebp)
f0111548:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011154b:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011154e:	0f 8c 57 ff ff ff    	jl     f01114ab <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f0111554:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f0111557:	c9                   	leave  
f0111558:	c3                   	ret    

f0111559 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0111559:	55                   	push   %ebp
f011155a:	89 e5                	mov    %esp,%ebp
f011155c:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f011155f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0111566:	8b 15 44 0d 6c f0    	mov    0xf06c0d44,%edx
f011156c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011156f:	39 c2                	cmp    %eax,%edx
f0111571:	74 0a                	je     f011157d <hasExpectedCommands+0x24>
		return 0;
f0111573:	b8 00 00 00 00       	mov    $0x0,%eax
f0111578:	e9 8b 00 00 00       	jmp    f0111608 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f011157d:	a1 38 0d 6c f0       	mov    0xf06c0d38,%eax
f0111582:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111585:	eb 55                	jmp    f01115dc <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111587:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011158e:	eb 2a                	jmp    f01115ba <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f0111590:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111593:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011159a:	8b 45 08             	mov    0x8(%ebp),%eax
f011159d:	01 d0                	add    %edx,%eax
f011159f:	8b 10                	mov    (%eax),%edx
f01115a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01115a4:	8b 00                	mov    (%eax),%eax
f01115a6:	83 ec 08             	sub    $0x8,%esp
f01115a9:	52                   	push   %edx
f01115aa:	50                   	push   %eax
f01115ab:	e8 24 e7 00 00       	call   f011fcd4 <strcmp>
f01115b0:	83 c4 10             	add    $0x10,%esp
f01115b3:	85 c0                	test   %eax,%eax
f01115b5:	74 0d                	je     f01115c4 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f01115b7:	ff 45 f0             	incl   -0x10(%ebp)
f01115ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01115bd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01115c0:	7c ce                	jl     f0111590 <hasExpectedCommands+0x37>
f01115c2:	eb 01                	jmp    f01115c5 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f01115c4:	90                   	nop
		if (i == commandsCount)
f01115c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01115c8:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01115cb:	75 07                	jne    f01115d4 <hasExpectedCommands+0x7b>
			return 0;
f01115cd:	b8 00 00 00 00       	mov    $0x0,%eax
f01115d2:	eb 34                	jmp    f0111608 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f01115d4:	a1 40 0d 6c f0       	mov    0xf06c0d40,%eax
f01115d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01115dc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01115e0:	74 08                	je     f01115ea <hasExpectedCommands+0x91>
f01115e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01115e5:	8b 40 10             	mov    0x10(%eax),%eax
f01115e8:	eb 05                	jmp    f01115ef <hasExpectedCommands+0x96>
f01115ea:	b8 00 00 00 00       	mov    $0x0,%eax
f01115ef:	a3 40 0d 6c f0       	mov    %eax,0xf06c0d40
f01115f4:	a1 40 0d 6c f0       	mov    0xf06c0d40,%eax
f01115f9:	85 c0                	test   %eax,%eax
f01115fb:	75 8a                	jne    f0111587 <hasExpectedCommands+0x2e>
f01115fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111601:	75 84                	jne    f0111587 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f0111603:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0111608:	c9                   	leave  
f0111609:	c3                   	ret    

f011160a <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f011160a:	55                   	push   %ebp
f011160b:	89 e5                	mov    %esp,%ebp
f011160d:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111610:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111617:	eb 2e                	jmp    f0111647 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f0111619:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011161c:	89 d0                	mov    %edx,%eax
f011161e:	01 c0                	add    %eax,%eax
f0111620:	01 d0                	add    %edx,%eax
f0111622:	c1 e0 03             	shl    $0x3,%eax
f0111625:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f011162a:	8b 00                	mov    (%eax),%eax
f011162c:	83 ec 08             	sub    $0x8,%esp
f011162f:	ff 75 08             	pushl  0x8(%ebp)
f0111632:	50                   	push   %eax
f0111633:	e8 9c e6 00 00       	call   f011fcd4 <strcmp>
f0111638:	83 c4 10             	add    $0x10,%esp
f011163b:	85 c0                	test   %eax,%eax
f011163d:	75 05                	jne    f0111644 <getIndexOfCommand+0x3a>
			return i;
f011163f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111642:	eb 14                	jmp    f0111658 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111644:	ff 45 f4             	incl   -0xc(%ebp)
f0111647:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011164a:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f011164f:	39 c2                	cmp    %eax,%edx
f0111651:	72 c6                	jb     f0111619 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f0111653:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0111658:	c9                   	leave  
f0111659:	c3                   	ret    

f011165a <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f011165a:	55                   	push   %ebp
f011165b:	89 e5                	mov    %esp,%ebp
f011165d:	57                   	push   %edi
f011165e:	56                   	push   %esi
f011165f:	53                   	push   %ebx
f0111660:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111666:	83 ec 0c             	sub    $0xc,%esp
f0111669:	68 60 87 12 f0       	push   $0xf0128760
f011166e:	e8 18 f9 fe ff       	call   f0100f8b <cprintf>
f0111673:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0111676:	83 ec 0c             	sub    $0xc,%esp
f0111679:	68 84 87 12 f0       	push   $0xf0128784
f011167e:	e8 08 f9 fe ff       	call   f0100f8b <cprintf>
f0111683:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0111686:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f011168d:	c7 45 8c 9f 87 12 f0 	movl   $0xf012879f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0111694:	83 ec 08             	sub    $0x8,%esp
f0111697:	8d 45 8c             	lea    -0x74(%ebp),%eax
f011169a:	50                   	push   %eax
f011169b:	6a 01                	push   $0x1
f011169d:	e8 2e 0b ff ff       	call   f01021d0 <process_command>
f01116a2:	83 c4 10             	add    $0x10,%esp
f01116a5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f01116a8:	83 ec 0c             	sub    $0xc,%esp
f01116ab:	68 ac 87 12 f0       	push   $0xf01287ac
f01116b0:	e8 d6 f8 fe ff       	call   f0100f8b <cprintf>
f01116b5:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f01116b8:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01116bb:	83 ec 0c             	sub    $0xc,%esp
f01116be:	50                   	push   %eax
f01116bf:	e8 46 ff ff ff       	call   f011160a <getIndexOfCommand>
f01116c4:	83 c4 10             	add    $0x10,%esp
f01116c7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01116ca:	75 0f                	jne    f01116db <TestAutoCompleteCommand+0x81>
f01116cc:	a1 38 0d 6c f0       	mov    0xf06c0d38,%eax
f01116d1:	85 c0                	test   %eax,%eax
f01116d3:	75 06                	jne    f01116db <TestAutoCompleteCommand+0x81>
		eval += 15;
f01116d5:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01116d9:	eb 10                	jmp    f01116eb <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01116db:	83 ec 0c             	sub    $0xc,%esp
f01116de:	68 dc 87 12 f0       	push   $0xf01287dc
f01116e3:	e8 a3 f8 fe ff       	call   f0100f8b <cprintf>
f01116e8:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f01116eb:	83 ec 0c             	sub    $0xc,%esp
f01116ee:	68 2c 88 12 f0       	push   $0xf012882c
f01116f3:	e8 93 f8 fe ff       	call   f0100f8b <cprintf>
f01116f8:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f01116fb:	c7 45 88 52 88 12 f0 	movl   $0xf0128852,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f0111702:	83 ec 08             	sub    $0x8,%esp
f0111705:	8d 45 88             	lea    -0x78(%ebp),%eax
f0111708:	50                   	push   %eax
f0111709:	6a 01                	push   $0x1
f011170b:	e8 c0 0a ff ff       	call   f01021d0 <process_command>
f0111710:	83 c4 10             	add    $0x10,%esp
f0111713:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f0111716:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f011171a:	75 30                	jne    f011174c <TestAutoCompleteCommand+0xf2>
f011171c:	8d 45 90             	lea    -0x70(%ebp),%eax
f011171f:	bb 30 8c 12 f0       	mov    $0xf0128c30,%ebx
f0111724:	ba 03 00 00 00       	mov    $0x3,%edx
f0111729:	89 c7                	mov    %eax,%edi
f011172b:	89 de                	mov    %ebx,%esi
f011172d:	89 d1                	mov    %edx,%ecx
f011172f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111731:	83 ec 08             	sub    $0x8,%esp
f0111734:	6a 03                	push   $0x3
f0111736:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111739:	50                   	push   %eax
f011173a:	e8 1a fe ff ff       	call   f0111559 <hasExpectedCommands>
f011173f:	83 c4 10             	add    $0x10,%esp
f0111742:	85 c0                	test   %eax,%eax
f0111744:	74 06                	je     f011174c <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111746:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011174a:	eb 10                	jmp    f011175c <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011174c:	83 ec 0c             	sub    $0xc,%esp
f011174f:	68 58 88 12 f0       	push   $0xf0128858
f0111754:	e8 32 f8 fe ff       	call   f0100f8b <cprintf>
f0111759:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f011175c:	83 ec 0c             	sub    $0xc,%esp
f011175f:	68 a8 88 12 f0       	push   $0xf01288a8
f0111764:	e8 22 f8 fe ff       	call   f0100f8b <cprintf>
f0111769:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f011176c:	c7 45 84 cd 88 12 f0 	movl   $0xf01288cd,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f0111773:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0111776:	83 ec 04             	sub    $0x4,%esp
f0111779:	50                   	push   %eax
f011177a:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011177d:	50                   	push   %eax
f011177e:	68 d0 88 12 f0       	push   $0xf01288d0
f0111783:	e8 03 f8 fe ff       	call   f0100f8b <cprintf>
f0111788:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f011178b:	83 ec 08             	sub    $0x8,%esp
f011178e:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111791:	50                   	push   %eax
f0111792:	6a 01                	push   $0x1
f0111794:	e8 37 0a ff ff       	call   f01021d0 <process_command>
f0111799:	83 c4 10             	add    $0x10,%esp
f011179c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f011179f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f01117a3:	75 1b                	jne    f01117c0 <TestAutoCompleteCommand+0x166>
f01117a5:	83 ec 08             	sub    $0x8,%esp
f01117a8:	6a 01                	push   $0x1
f01117aa:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01117ad:	50                   	push   %eax
f01117ae:	e8 a6 fd ff ff       	call   f0111559 <hasExpectedCommands>
f01117b3:	83 c4 10             	add    $0x10,%esp
f01117b6:	85 c0                	test   %eax,%eax
f01117b8:	74 06                	je     f01117c0 <TestAutoCompleteCommand+0x166>
		eval += 15;
f01117ba:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01117be:	eb 10                	jmp    f01117d0 <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f01117c0:	83 ec 0c             	sub    $0xc,%esp
f01117c3:	68 f0 88 12 f0       	push   $0xf01288f0
f01117c8:	e8 be f7 fe ff       	call   f0100f8b <cprintf>
f01117cd:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f01117d0:	83 ec 0c             	sub    $0xc,%esp
f01117d3:	68 48 89 12 f0       	push   $0xf0128948
f01117d8:	e8 ae f7 fe ff       	call   f0100f8b <cprintf>
f01117dd:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f01117e0:	c7 45 80 6e 89 12 f0 	movl   $0xf012896e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f01117e7:	83 ec 08             	sub    $0x8,%esp
f01117ea:	8d 45 80             	lea    -0x80(%ebp),%eax
f01117ed:	50                   	push   %eax
f01117ee:	6a 01                	push   $0x1
f01117f0:	e8 db 09 ff ff       	call   f01021d0 <process_command>
f01117f5:	83 c4 10             	add    $0x10,%esp
f01117f8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f01117fb:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f01117ff:	75 0f                	jne    f0111810 <TestAutoCompleteCommand+0x1b6>
f0111801:	a1 44 0d 6c f0       	mov    0xf06c0d44,%eax
f0111806:	85 c0                	test   %eax,%eax
f0111808:	75 06                	jne    f0111810 <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f011180a:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011180e:	eb 10                	jmp    f0111820 <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111810:	83 ec 0c             	sub    $0xc,%esp
f0111813:	68 74 89 12 f0       	push   $0xf0128974
f0111818:	e8 6e f7 fe ff       	call   f0100f8b <cprintf>
f011181d:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f0111820:	83 ec 0c             	sub    $0xc,%esp
f0111823:	68 c4 89 12 f0       	push   $0xf01289c4
f0111828:	e8 5e f7 fe ff       	call   f0100f8b <cprintf>
f011182d:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f0111830:	c7 85 7c ff ff ff e9 	movl   $0xf01289e9,-0x84(%ebp)
f0111837:	89 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f011183a:	83 ec 08             	sub    $0x8,%esp
f011183d:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f0111843:	50                   	push   %eax
f0111844:	6a 01                	push   $0x1
f0111846:	e8 85 09 ff ff       	call   f01021d0 <process_command>
f011184b:	83 c4 10             	add    $0x10,%esp
f011184e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f0111851:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111855:	75 30                	jne    f0111887 <TestAutoCompleteCommand+0x22d>
f0111857:	8d 45 9c             	lea    -0x64(%ebp),%eax
f011185a:	bb c0 8c 12 f0       	mov    $0xf0128cc0,%ebx
f011185f:	ba 0c 00 00 00       	mov    $0xc,%edx
f0111864:	89 c7                	mov    %eax,%edi
f0111866:	89 de                	mov    %ebx,%esi
f0111868:	89 d1                	mov    %edx,%ecx
f011186a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011186c:	83 ec 08             	sub    $0x8,%esp
f011186f:	6a 0c                	push   $0xc
f0111871:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111874:	50                   	push   %eax
f0111875:	e8 df fc ff ff       	call   f0111559 <hasExpectedCommands>
f011187a:	83 c4 10             	add    $0x10,%esp
f011187d:	85 c0                	test   %eax,%eax
f011187f:	74 06                	je     f0111887 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f0111881:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111885:	eb 10                	jmp    f0111897 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111887:	83 ec 0c             	sub    $0xc,%esp
f011188a:	68 ec 89 12 f0       	push   $0xf01289ec
f011188f:	e8 f7 f6 fe ff       	call   f0100f8b <cprintf>
f0111894:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0111897:	83 ec 0c             	sub    $0xc,%esp
f011189a:	68 44 8a 12 f0       	push   $0xf0128a44
f011189f:	e8 e7 f6 fe ff       	call   f0100f8b <cprintf>
f01118a4:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f01118a7:	c7 85 78 ff ff ff 69 	movl   $0xf0128a69,-0x88(%ebp)
f01118ae:	8a 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f01118b1:	83 ec 08             	sub    $0x8,%esp
f01118b4:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01118ba:	50                   	push   %eax
f01118bb:	6a 01                	push   $0x1
f01118bd:	e8 0e 09 ff ff       	call   f01021d0 <process_command>
f01118c2:	83 c4 10             	add    $0x10,%esp
f01118c5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f01118c8:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01118cc:	75 30                	jne    f01118fe <TestAutoCompleteCommand+0x2a4>
f01118ce:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01118d1:	bb 08 8d 12 f0       	mov    $0xf0128d08,%ebx
f01118d6:	ba 05 00 00 00       	mov    $0x5,%edx
f01118db:	89 c7                	mov    %eax,%edi
f01118dd:	89 de                	mov    %ebx,%esi
f01118df:	89 d1                	mov    %edx,%ecx
f01118e1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01118e3:	83 ec 08             	sub    $0x8,%esp
f01118e6:	6a 05                	push   $0x5
f01118e8:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01118eb:	50                   	push   %eax
f01118ec:	e8 68 fc ff ff       	call   f0111559 <hasExpectedCommands>
f01118f1:	83 c4 10             	add    $0x10,%esp
f01118f4:	85 c0                	test   %eax,%eax
f01118f6:	74 06                	je     f01118fe <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f01118f8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01118fc:	eb 10                	jmp    f011190e <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f01118fe:	83 ec 0c             	sub    $0xc,%esp
f0111901:	68 6c 8a 12 f0       	push   $0xf0128a6c
f0111906:	e8 80 f6 fe ff       	call   f0100f8b <cprintf>
f011190b:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f011190e:	83 ec 0c             	sub    $0xc,%esp
f0111911:	68 c4 8a 12 f0       	push   $0xf0128ac4
f0111916:	e8 70 f6 fe ff       	call   f0100f8b <cprintf>
f011191b:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f011191e:	c7 85 70 ff ff ff f0 	movl   $0xf0128af0,-0x90(%ebp)
f0111925:	8a 12 f0 
f0111928:	c7 85 74 ff ff ff f5 	movl   $0xf0128af5,-0x8c(%ebp)
f011192f:	8a 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f0111932:	83 ec 08             	sub    $0x8,%esp
f0111935:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f011193b:	50                   	push   %eax
f011193c:	6a 02                	push   $0x2
f011193e:	e8 8d 08 ff ff       	call   f01021d0 <process_command>
f0111943:	83 c4 10             	add    $0x10,%esp
f0111946:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111949:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011194f:	83 ec 0c             	sub    $0xc,%esp
f0111952:	50                   	push   %eax
f0111953:	e8 b2 fc ff ff       	call   f011160a <getIndexOfCommand>
f0111958:	83 c4 10             	add    $0x10,%esp
f011195b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011195e:	75 0f                	jne    f011196f <TestAutoCompleteCommand+0x315>
f0111960:	a1 38 0d 6c f0       	mov    0xf06c0d38,%eax
f0111965:	85 c0                	test   %eax,%eax
f0111967:	75 06                	jne    f011196f <TestAutoCompleteCommand+0x315>
		eval += 10;
f0111969:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f011196d:	eb 10                	jmp    f011197f <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011196f:	83 ec 0c             	sub    $0xc,%esp
f0111972:	68 fc 8a 12 f0       	push   $0xf0128afc
f0111977:	e8 0f f6 fe ff       	call   f0100f8b <cprintf>
f011197c:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f011197f:	83 ec 0c             	sub    $0xc,%esp
f0111982:	68 4c 8b 12 f0       	push   $0xf0128b4c
f0111987:	e8 ff f5 fe ff       	call   f0100f8b <cprintf>
f011198c:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f011198f:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111995:	bb 30 8d 12 f0       	mov    $0xf0128d30,%ebx
f011199a:	ba 03 00 00 00       	mov    $0x3,%edx
f011199f:	89 c7                	mov    %eax,%edi
f01119a1:	89 de                	mov    %ebx,%esi
f01119a3:	89 d1                	mov    %edx,%ecx
f01119a5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f01119a7:	83 ec 08             	sub    $0x8,%esp
f01119aa:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01119b0:	50                   	push   %eax
f01119b1:	6a 03                	push   $0x3
f01119b3:	e8 18 08 ff ff       	call   f01021d0 <process_command>
f01119b8:	83 c4 10             	add    $0x10,%esp
f01119bb:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f01119be:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f01119c4:	83 ec 0c             	sub    $0xc,%esp
f01119c7:	50                   	push   %eax
f01119c8:	e8 3d fc ff ff       	call   f011160a <getIndexOfCommand>
f01119cd:	83 c4 10             	add    $0x10,%esp
f01119d0:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01119d3:	75 0f                	jne    f01119e4 <TestAutoCompleteCommand+0x38a>
f01119d5:	a1 38 0d 6c f0       	mov    0xf06c0d38,%eax
f01119da:	85 c0                	test   %eax,%eax
f01119dc:	75 06                	jne    f01119e4 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f01119de:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01119e2:	eb 10                	jmp    f01119f4 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01119e4:	83 ec 0c             	sub    $0xc,%esp
f01119e7:	68 80 8b 12 f0       	push   $0xf0128b80
f01119ec:	e8 9a f5 fe ff       	call   f0100f8b <cprintf>
f01119f1:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f01119f4:	83 ec 08             	sub    $0x8,%esp
f01119f7:	ff 75 e4             	pushl  -0x1c(%ebp)
f01119fa:	68 d0 8b 12 f0       	push   $0xf0128bd0
f01119ff:	e8 87 f5 fe ff       	call   f0100f8b <cprintf>
f0111a04:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111a07:	83 ec 0c             	sub    $0xc,%esp
f0111a0a:	68 00 8c 12 f0       	push   $0xf0128c00
f0111a0f:	e8 77 f5 fe ff       	call   f0100f8b <cprintf>
f0111a14:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111a17:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111a1c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111a1f:	5b                   	pop    %ebx
f0111a20:	5e                   	pop    %esi
f0111a21:	5f                   	pop    %edi
f0111a22:	5d                   	pop    %ebp
f0111a23:	c3                   	ret    

f0111a24 <test_str2lower_function>:

int test_str2lower_function()
{
f0111a24:	55                   	push   %ebp
f0111a25:	89 e5                	mov    %esp,%ebp
f0111a27:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111a2d:	83 ec 0c             	sub    $0xc,%esp
f0111a30:	68 3c 8d 12 f0       	push   $0xf0128d3c
f0111a35:	e8 51 f5 fe ff       	call   f0100f8b <cprintf>
f0111a3a:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111a3d:	83 ec 0c             	sub    $0xc,%esp
f0111a40:	68 5d 8d 12 f0       	push   $0xf0128d5d
f0111a45:	e8 41 f5 fe ff       	call   f0100f8b <cprintf>
f0111a4a:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111a4d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111a54:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111a5b:	c7 45 ec 77 8d 12 f0 	movl   $0xf0128d77,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0111a62:	83 ec 08             	sub    $0x8,%esp
f0111a65:	ff 75 ec             	pushl  -0x14(%ebp)
f0111a68:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111a6e:	50                   	push   %eax
f0111a6f:	e8 3d e8 00 00       	call   f01202b1 <str2lower>
f0111a74:	83 c4 10             	add    $0x10,%esp
f0111a77:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111a7a:	83 ec 0c             	sub    $0xc,%esp
f0111a7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111a80:	e8 43 e1 00 00       	call   f011fbc8 <strlen>
f0111a85:	83 c4 10             	add    $0x10,%esp
f0111a88:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111a8b:	83 ec 08             	sub    $0x8,%esp
f0111a8e:	68 82 8d 12 f0       	push   $0xf0128d82
f0111a93:	ff 75 e8             	pushl  -0x18(%ebp)
f0111a96:	e8 39 e2 00 00       	call   f011fcd4 <strcmp>
f0111a9b:	83 c4 10             	add    $0x10,%esp
f0111a9e:	85 c0                	test   %eax,%eax
f0111aa0:	75 13                	jne    f0111ab5 <test_str2lower_function+0x91>
f0111aa2:	83 ec 0c             	sub    $0xc,%esp
f0111aa5:	ff 75 ec             	pushl  -0x14(%ebp)
f0111aa8:	e8 1b e1 00 00       	call   f011fbc8 <strlen>
f0111aad:	83 c4 10             	add    $0x10,%esp
f0111ab0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111ab3:	74 15                	je     f0111aca <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0111ab5:	83 ec 08             	sub    $0x8,%esp
f0111ab8:	ff 75 e8             	pushl  -0x18(%ebp)
f0111abb:	68 90 8d 12 f0       	push   $0xf0128d90
f0111ac0:	e8 c6 f4 fe ff       	call   f0100f8b <cprintf>
f0111ac5:	83 c4 10             	add    $0x10,%esp
f0111ac8:	eb 04                	jmp    f0111ace <test_str2lower_function+0xaa>
	else
		eval += 10;
f0111aca:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0111ace:	c7 45 e0 f2 8d 12 f0 	movl   $0xf0128df2,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0111ad5:	83 ec 08             	sub    $0x8,%esp
f0111ad8:	ff 75 e0             	pushl  -0x20(%ebp)
f0111adb:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111ae1:	50                   	push   %eax
f0111ae2:	e8 ca e7 00 00       	call   f01202b1 <str2lower>
f0111ae7:	83 c4 10             	add    $0x10,%esp
f0111aea:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111aed:	83 ec 0c             	sub    $0xc,%esp
f0111af0:	ff 75 e8             	pushl  -0x18(%ebp)
f0111af3:	e8 d0 e0 00 00       	call   f011fbc8 <strlen>
f0111af8:	83 c4 10             	add    $0x10,%esp
f0111afb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111afe:	83 ec 08             	sub    $0x8,%esp
f0111b01:	68 f2 8d 12 f0       	push   $0xf0128df2
f0111b06:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b09:	e8 c6 e1 00 00       	call   f011fcd4 <strcmp>
f0111b0e:	83 c4 10             	add    $0x10,%esp
f0111b11:	85 c0                	test   %eax,%eax
f0111b13:	75 13                	jne    f0111b28 <test_str2lower_function+0x104>
f0111b15:	83 ec 0c             	sub    $0xc,%esp
f0111b18:	ff 75 e0             	pushl  -0x20(%ebp)
f0111b1b:	e8 a8 e0 00 00       	call   f011fbc8 <strlen>
f0111b20:	83 c4 10             	add    $0x10,%esp
f0111b23:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111b26:	74 15                	je     f0111b3d <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111b28:	83 ec 08             	sub    $0x8,%esp
f0111b2b:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b2e:	68 f4 8d 12 f0       	push   $0xf0128df4
f0111b33:	e8 53 f4 fe ff       	call   f0100f8b <cprintf>
f0111b38:	83 c4 10             	add    $0x10,%esp
f0111b3b:	eb 04                	jmp    f0111b41 <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111b3d:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0111b41:	c7 45 dc 4c 8e 12 f0 	movl   $0xf0128e4c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111b48:	83 ec 08             	sub    $0x8,%esp
f0111b4b:	ff 75 dc             	pushl  -0x24(%ebp)
f0111b4e:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111b54:	50                   	push   %eax
f0111b55:	e8 57 e7 00 00       	call   f01202b1 <str2lower>
f0111b5a:	83 c4 10             	add    $0x10,%esp
f0111b5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111b60:	83 ec 0c             	sub    $0xc,%esp
f0111b63:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b66:	e8 5d e0 00 00       	call   f011fbc8 <strlen>
f0111b6b:	83 c4 10             	add    $0x10,%esp
f0111b6e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0111b71:	83 ec 08             	sub    $0x8,%esp
f0111b74:	68 4c 8e 12 f0       	push   $0xf0128e4c
f0111b79:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b7c:	e8 53 e1 00 00       	call   f011fcd4 <strcmp>
f0111b81:	83 c4 10             	add    $0x10,%esp
f0111b84:	85 c0                	test   %eax,%eax
f0111b86:	75 13                	jne    f0111b9b <test_str2lower_function+0x177>
f0111b88:	83 ec 0c             	sub    $0xc,%esp
f0111b8b:	ff 75 dc             	pushl  -0x24(%ebp)
f0111b8e:	e8 35 e0 00 00       	call   f011fbc8 <strlen>
f0111b93:	83 c4 10             	add    $0x10,%esp
f0111b96:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111b99:	74 15                	je     f0111bb0 <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111b9b:	83 ec 08             	sub    $0x8,%esp
f0111b9e:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ba1:	68 58 8e 12 f0       	push   $0xf0128e58
f0111ba6:	e8 e0 f3 fe ff       	call   f0100f8b <cprintf>
f0111bab:	83 c4 10             	add    $0x10,%esp
f0111bae:	eb 04                	jmp    f0111bb4 <test_str2lower_function+0x190>
	else
		eval += 15;
f0111bb0:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0111bb4:	c7 45 d8 bb 8e 12 f0 	movl   $0xf0128ebb,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0111bbb:	83 ec 08             	sub    $0x8,%esp
f0111bbe:	ff 75 d8             	pushl  -0x28(%ebp)
f0111bc1:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0111bc7:	50                   	push   %eax
f0111bc8:	e8 e4 e6 00 00       	call   f01202b1 <str2lower>
f0111bcd:	83 c4 10             	add    $0x10,%esp
f0111bd0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111bd3:	83 ec 0c             	sub    $0xc,%esp
f0111bd6:	ff 75 e8             	pushl  -0x18(%ebp)
f0111bd9:	e8 ea df 00 00       	call   f011fbc8 <strlen>
f0111bde:	83 c4 10             	add    $0x10,%esp
f0111be1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0111be4:	83 ec 08             	sub    $0x8,%esp
f0111be7:	68 bb 8e 12 f0       	push   $0xf0128ebb
f0111bec:	ff 75 e8             	pushl  -0x18(%ebp)
f0111bef:	e8 e0 e0 00 00       	call   f011fcd4 <strcmp>
f0111bf4:	83 c4 10             	add    $0x10,%esp
f0111bf7:	85 c0                	test   %eax,%eax
f0111bf9:	75 13                	jne    f0111c0e <test_str2lower_function+0x1ea>
f0111bfb:	83 ec 0c             	sub    $0xc,%esp
f0111bfe:	ff 75 d8             	pushl  -0x28(%ebp)
f0111c01:	e8 c2 df 00 00       	call   f011fbc8 <strlen>
f0111c06:	83 c4 10             	add    $0x10,%esp
f0111c09:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111c0c:	74 15                	je     f0111c23 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111c0e:	83 ec 08             	sub    $0x8,%esp
f0111c11:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c14:	68 c8 8e 12 f0       	push   $0xf0128ec8
f0111c19:	e8 6d f3 fe ff       	call   f0100f8b <cprintf>
f0111c1e:	83 c4 10             	add    $0x10,%esp
f0111c21:	eb 04                	jmp    f0111c27 <test_str2lower_function+0x203>
	else
		eval += 15;
f0111c23:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111c27:	c7 45 d4 2a 8f 12 f0 	movl   $0xf0128f2a,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111c2e:	83 ec 08             	sub    $0x8,%esp
f0111c31:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111c34:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111c3a:	50                   	push   %eax
f0111c3b:	e8 71 e6 00 00       	call   f01202b1 <str2lower>
f0111c40:	83 c4 10             	add    $0x10,%esp
f0111c43:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111c46:	83 ec 0c             	sub    $0xc,%esp
f0111c49:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c4c:	e8 77 df 00 00       	call   f011fbc8 <strlen>
f0111c51:	83 c4 10             	add    $0x10,%esp
f0111c54:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111c57:	83 ec 08             	sub    $0x8,%esp
f0111c5a:	68 40 8f 12 f0       	push   $0xf0128f40
f0111c5f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c62:	e8 6d e0 00 00       	call   f011fcd4 <strcmp>
f0111c67:	83 c4 10             	add    $0x10,%esp
f0111c6a:	85 c0                	test   %eax,%eax
f0111c6c:	75 13                	jne    f0111c81 <test_str2lower_function+0x25d>
f0111c6e:	83 ec 0c             	sub    $0xc,%esp
f0111c71:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111c74:	e8 4f df 00 00       	call   f011fbc8 <strlen>
f0111c79:	83 c4 10             	add    $0x10,%esp
f0111c7c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111c7f:	74 15                	je     f0111c96 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0111c81:	83 ec 08             	sub    $0x8,%esp
f0111c84:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c87:	68 58 8f 12 f0       	push   $0xf0128f58
f0111c8c:	e8 fa f2 fe ff       	call   f0100f8b <cprintf>
f0111c91:	83 c4 10             	add    $0x10,%esp
f0111c94:	eb 04                	jmp    f0111c9a <test_str2lower_function+0x276>
	else
		eval += 15;
f0111c96:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111c9a:	c7 45 d0 c5 8f 12 f0 	movl   $0xf0128fc5,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0111ca1:	83 ec 08             	sub    $0x8,%esp
f0111ca4:	ff 75 d0             	pushl  -0x30(%ebp)
f0111ca7:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0111cad:	50                   	push   %eax
f0111cae:	e8 fe e5 00 00       	call   f01202b1 <str2lower>
f0111cb3:	83 c4 10             	add    $0x10,%esp
f0111cb6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111cb9:	83 ec 0c             	sub    $0xc,%esp
f0111cbc:	ff 75 e8             	pushl  -0x18(%ebp)
f0111cbf:	e8 04 df 00 00       	call   f011fbc8 <strlen>
f0111cc4:	83 c4 10             	add    $0x10,%esp
f0111cc7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0111cca:	83 ec 08             	sub    $0x8,%esp
f0111ccd:	68 d1 8f 12 f0       	push   $0xf0128fd1
f0111cd2:	ff 75 e8             	pushl  -0x18(%ebp)
f0111cd5:	e8 fa df 00 00       	call   f011fcd4 <strcmp>
f0111cda:	83 c4 10             	add    $0x10,%esp
f0111cdd:	85 c0                	test   %eax,%eax
f0111cdf:	75 13                	jne    f0111cf4 <test_str2lower_function+0x2d0>
f0111ce1:	83 ec 0c             	sub    $0xc,%esp
f0111ce4:	ff 75 d0             	pushl  -0x30(%ebp)
f0111ce7:	e8 dc de 00 00       	call   f011fbc8 <strlen>
f0111cec:	83 c4 10             	add    $0x10,%esp
f0111cef:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111cf2:	74 15                	je     f0111d09 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0111cf4:	83 ec 08             	sub    $0x8,%esp
f0111cf7:	ff 75 e8             	pushl  -0x18(%ebp)
f0111cfa:	68 e0 8f 12 f0       	push   $0xf0128fe0
f0111cff:	e8 87 f2 fe ff       	call   f0100f8b <cprintf>
f0111d04:	83 c4 10             	add    $0x10,%esp
f0111d07:	eb 04                	jmp    f0111d0d <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111d09:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0111d0d:	c7 45 cc 43 90 12 f0 	movl   $0xf0129043,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0111d14:	83 ec 08             	sub    $0x8,%esp
f0111d17:	ff 75 cc             	pushl  -0x34(%ebp)
f0111d1a:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0111d20:	50                   	push   %eax
f0111d21:	e8 8b e5 00 00       	call   f01202b1 <str2lower>
f0111d26:	83 c4 10             	add    $0x10,%esp
f0111d29:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111d2c:	83 ec 0c             	sub    $0xc,%esp
f0111d2f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d32:	e8 91 de 00 00       	call   f011fbc8 <strlen>
f0111d37:	83 c4 10             	add    $0x10,%esp
f0111d3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0111d3d:	83 ec 08             	sub    $0x8,%esp
f0111d40:	68 5e 90 12 f0       	push   $0xf012905e
f0111d45:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d48:	e8 87 df 00 00       	call   f011fcd4 <strcmp>
f0111d4d:	83 c4 10             	add    $0x10,%esp
f0111d50:	85 c0                	test   %eax,%eax
f0111d52:	75 13                	jne    f0111d67 <test_str2lower_function+0x343>
f0111d54:	83 ec 0c             	sub    $0xc,%esp
f0111d57:	ff 75 cc             	pushl  -0x34(%ebp)
f0111d5a:	e8 69 de 00 00       	call   f011fbc8 <strlen>
f0111d5f:	83 c4 10             	add    $0x10,%esp
f0111d62:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111d65:	74 15                	je     f0111d7c <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0111d67:	83 ec 08             	sub    $0x8,%esp
f0111d6a:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d6d:	68 7c 90 12 f0       	push   $0xf012907c
f0111d72:	e8 14 f2 fe ff       	call   f0100f8b <cprintf>
f0111d77:	83 c4 10             	add    $0x10,%esp
f0111d7a:	eb 04                	jmp    f0111d80 <test_str2lower_function+0x35c>
	else
		eval += 20;
f0111d7c:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0111d80:	83 ec 08             	sub    $0x8,%esp
f0111d83:	ff 75 f4             	pushl  -0xc(%ebp)
f0111d86:	68 f0 90 12 f0       	push   $0xf01290f0
f0111d8b:	e8 fb f1 fe ff       	call   f0100f8b <cprintf>
f0111d90:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111d93:	83 ec 0c             	sub    $0xc,%esp
f0111d96:	68 00 8c 12 f0       	push   $0xf0128c00
f0111d9b:	e8 eb f1 fe ff       	call   f0100f8b <cprintf>
f0111da0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111da3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111da8:	c9                   	leave  
f0111da9:	c3                   	ret    

f0111daa <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0111daa:	55                   	push   %ebp
f0111dab:	89 e5                	mov    %esp,%ebp
f0111dad:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0111db0:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111db7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111dbe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111dc5:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111dca:	ff 75 ec             	pushl  -0x14(%ebp)
f0111dcd:	ff 75 f0             	pushl  -0x10(%ebp)
f0111dd0:	ff 75 f4             	pushl  -0xc(%ebp)
f0111dd3:	50                   	push   %eax
f0111dd4:	e8 f2 7d ff ff       	call   f0109bcb <pt_set_page_permissions>
f0111dd9:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111ddc:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111de1:	ff 75 ec             	pushl  -0x14(%ebp)
f0111de4:	ff 75 f0             	pushl  -0x10(%ebp)
f0111de7:	ff 75 f4             	pushl  -0xc(%ebp)
f0111dea:	50                   	push   %eax
f0111deb:	e8 74 4b 00 00       	call   f0116964 <CP>
f0111df0:	83 c4 10             	add    $0x10,%esp
f0111df3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111df6:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111dfa:	74 17                	je     f0111e13 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0111dfc:	83 ec 04             	sub    $0x4,%esp
f0111dff:	68 20 91 12 f0       	push   $0xf0129120
f0111e04:	68 23 01 00 00       	push   $0x123
f0111e09:	68 42 91 12 f0       	push   $0xf0129142
f0111e0e:	e8 26 e5 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0111e13:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0111e1a:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0111e21:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111e28:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111e2d:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e30:	ff 75 f0             	pushl  -0x10(%ebp)
f0111e33:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e36:	50                   	push   %eax
f0111e37:	e8 8f 7d ff ff       	call   f0109bcb <pt_set_page_permissions>
f0111e3c:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111e3f:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111e44:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e47:	ff 75 f0             	pushl  -0x10(%ebp)
f0111e4a:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e4d:	50                   	push   %eax
f0111e4e:	e8 11 4b 00 00       	call   f0116964 <CP>
f0111e53:	83 c4 10             	add    $0x10,%esp
f0111e56:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111e59:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111e5d:	74 17                	je     f0111e76 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0111e5f:	83 ec 04             	sub    $0x4,%esp
f0111e62:	68 60 91 12 f0       	push   $0xf0129160
f0111e67:	68 2f 01 00 00       	push   $0x12f
f0111e6c:	68 42 91 12 f0       	push   $0xf0129142
f0111e71:	e8 c3 e4 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0111e76:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0111e7d:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0111e84:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111e8b:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111e90:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e93:	ff 75 f0             	pushl  -0x10(%ebp)
f0111e96:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e99:	50                   	push   %eax
f0111e9a:	e8 2c 7d ff ff       	call   f0109bcb <pt_set_page_permissions>
f0111e9f:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111ea2:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111ea7:	ff 75 ec             	pushl  -0x14(%ebp)
f0111eaa:	ff 75 f0             	pushl  -0x10(%ebp)
f0111ead:	ff 75 f4             	pushl  -0xc(%ebp)
f0111eb0:	50                   	push   %eax
f0111eb1:	e8 ae 4a 00 00       	call   f0116964 <CP>
f0111eb6:	83 c4 10             	add    $0x10,%esp
f0111eb9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111ebc:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111ec0:	74 17                	je     f0111ed9 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0111ec2:	83 ec 04             	sub    $0x4,%esp
f0111ec5:	68 84 91 12 f0       	push   $0xf0129184
f0111eca:	68 3a 01 00 00       	push   $0x13a
f0111ecf:	68 42 91 12 f0       	push   $0xf0129142
f0111ed4:	e8 60 e4 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0111ed9:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0111ee0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0111ee7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111eee:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111ef3:	ff 75 ec             	pushl  -0x14(%ebp)
f0111ef6:	ff 75 f0             	pushl  -0x10(%ebp)
f0111ef9:	ff 75 f4             	pushl  -0xc(%ebp)
f0111efc:	50                   	push   %eax
f0111efd:	e8 c9 7c ff ff       	call   f0109bcb <pt_set_page_permissions>
f0111f02:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111f05:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111f0a:	ff 75 ec             	pushl  -0x14(%ebp)
f0111f0d:	ff 75 f0             	pushl  -0x10(%ebp)
f0111f10:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f13:	50                   	push   %eax
f0111f14:	e8 4b 4a 00 00       	call   f0116964 <CP>
f0111f19:	83 c4 10             	add    $0x10,%esp
f0111f1c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111f1f:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111f23:	74 17                	je     f0111f3c <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0111f25:	83 ec 04             	sub    $0x4,%esp
f0111f28:	68 a8 91 12 f0       	push   $0xf01291a8
f0111f2d:	68 46 01 00 00       	push   $0x146
f0111f32:	68 42 91 12 f0       	push   $0xf0129142
f0111f37:	e8 fd e3 fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0111f3c:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0111f43:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0111f4a:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111f51:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111f56:	ff 75 ec             	pushl  -0x14(%ebp)
f0111f59:	ff 75 f0             	pushl  -0x10(%ebp)
f0111f5c:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f5f:	50                   	push   %eax
f0111f60:	e8 66 7c ff ff       	call   f0109bcb <pt_set_page_permissions>
f0111f65:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111f68:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111f6d:	ff 75 ec             	pushl  -0x14(%ebp)
f0111f70:	ff 75 f0             	pushl  -0x10(%ebp)
f0111f73:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f76:	50                   	push   %eax
f0111f77:	e8 e8 49 00 00       	call   f0116964 <CP>
f0111f7c:	83 c4 10             	add    $0x10,%esp
f0111f7f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111f82:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111f86:	74 17                	je     f0111f9f <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0111f88:	83 ec 04             	sub    $0x4,%esp
f0111f8b:	68 cc 91 12 f0       	push   $0xf01291cc
f0111f90:	68 52 01 00 00       	push   $0x152
f0111f95:	68 42 91 12 f0       	push   $0xf0129142
f0111f9a:	e8 9a e3 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0111f9f:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0111fa6:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0111fad:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111fb4:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111fb9:	ff 75 ec             	pushl  -0x14(%ebp)
f0111fbc:	ff 75 f0             	pushl  -0x10(%ebp)
f0111fbf:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fc2:	50                   	push   %eax
f0111fc3:	e8 03 7c ff ff       	call   f0109bcb <pt_set_page_permissions>
f0111fc8:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111fcb:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0111fd0:	ff 75 ec             	pushl  -0x14(%ebp)
f0111fd3:	ff 75 f0             	pushl  -0x10(%ebp)
f0111fd6:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fd9:	50                   	push   %eax
f0111fda:	e8 85 49 00 00       	call   f0116964 <CP>
f0111fdf:	83 c4 10             	add    $0x10,%esp
f0111fe2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111fe5:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111fe9:	74 17                	je     f0112002 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0111feb:	83 ec 04             	sub    $0x4,%esp
f0111fee:	68 f0 91 12 f0       	push   $0xf01291f0
f0111ff3:	68 5e 01 00 00       	push   $0x15e
f0111ff8:	68 42 91 12 f0       	push   $0xf0129142
f0111ffd:	e8 37 e3 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0112002:	83 ec 0c             	sub    $0xc,%esp
f0112005:	68 1c 92 12 f0       	push   $0xf012921c
f011200a:	e8 7c ef fe ff       	call   f0100f8b <cprintf>
f011200f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112012:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112017:	c9                   	leave  
f0112018:	c3                   	ret    

f0112019 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0112019:	55                   	push   %ebp
f011201a:	89 e5                	mov    %esp,%ebp
f011201c:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f011201f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0112026:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f011202d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112034:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0112039:	ff 75 ec             	pushl  -0x14(%ebp)
f011203c:	ff 75 f0             	pushl  -0x10(%ebp)
f011203f:	ff 75 f4             	pushl  -0xc(%ebp)
f0112042:	50                   	push   %eax
f0112043:	e8 83 7b ff ff       	call   f0109bcb <pt_set_page_permissions>
f0112048:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f011204b:	83 ec 04             	sub    $0x4,%esp
f011204e:	68 6c 92 12 f0       	push   $0xf012926c
f0112053:	68 6b 01 00 00       	push   $0x16b
f0112058:	68 42 91 12 f0       	push   $0xf0129142
f011205d:	e8 d7 e2 fe ff       	call   f0100339 <_panic>

f0112062 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0112062:	55                   	push   %ebp
f0112063:	89 e5                	mov    %esp,%ebp
f0112065:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0112068:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f011206f:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0112074:	83 ec 08             	sub    $0x8,%esp
f0112077:	ff 75 f4             	pushl  -0xc(%ebp)
f011207a:	50                   	push   %eax
f011207b:	e8 0f 7c ff ff       	call   f0109c8f <pt_get_page_permissions>
f0112080:	83 c4 10             	add    $0x10,%esp
f0112083:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0112086:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f011208a:	74 17                	je     f01120a3 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f011208c:	83 ec 04             	sub    $0x4,%esp
f011208f:	68 08 93 12 f0       	push   $0xf0129308
f0112094:	68 79 01 00 00       	push   $0x179
f0112099:	68 42 91 12 f0       	push   $0xf0129142
f011209e:	e8 96 e2 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f01120a3:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01120aa:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01120af:	83 ec 08             	sub    $0x8,%esp
f01120b2:	ff 75 f4             	pushl  -0xc(%ebp)
f01120b5:	50                   	push   %eax
f01120b6:	e8 d4 7b ff ff       	call   f0109c8f <pt_get_page_permissions>
f01120bb:	83 c4 10             	add    $0x10,%esp
f01120be:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f01120c1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01120c5:	74 17                	je     f01120de <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f01120c7:	83 ec 04             	sub    $0x4,%esp
f01120ca:	68 2c 93 12 f0       	push   $0xf012932c
f01120cf:	68 81 01 00 00       	push   $0x181
f01120d4:	68 42 91 12 f0       	push   $0xf0129142
f01120d9:	e8 5b e2 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f01120de:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01120e5:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01120ea:	83 ec 08             	sub    $0x8,%esp
f01120ed:	ff 75 f4             	pushl  -0xc(%ebp)
f01120f0:	50                   	push   %eax
f01120f1:	e8 99 7b ff ff       	call   f0109c8f <pt_get_page_permissions>
f01120f6:	83 c4 10             	add    $0x10,%esp
f01120f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f01120fc:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0112100:	74 17                	je     f0112119 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0112102:	83 ec 04             	sub    $0x4,%esp
f0112105:	68 50 93 12 f0       	push   $0xf0129350
f011210a:	68 89 01 00 00       	push   $0x189
f011210f:	68 42 91 12 f0       	push   $0xf0129142
f0112114:	e8 20 e2 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f0112119:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112120:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0112125:	83 ec 08             	sub    $0x8,%esp
f0112128:	ff 75 f4             	pushl  -0xc(%ebp)
f011212b:	50                   	push   %eax
f011212c:	e8 5e 7b ff ff       	call   f0109c8f <pt_get_page_permissions>
f0112131:	83 c4 10             	add    $0x10,%esp
f0112134:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0112137:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f011213b:	74 17                	je     f0112154 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f011213d:	83 ec 04             	sub    $0x4,%esp
f0112140:	68 74 93 12 f0       	push   $0xf0129374
f0112145:	68 90 01 00 00       	push   $0x190
f011214a:	68 42 91 12 f0       	push   $0xf0129142
f011214f:	e8 e5 e1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0112154:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f011215b:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0112160:	83 ec 08             	sub    $0x8,%esp
f0112163:	ff 75 f4             	pushl  -0xc(%ebp)
f0112166:	50                   	push   %eax
f0112167:	e8 23 7b ff ff       	call   f0109c8f <pt_get_page_permissions>
f011216c:	83 c4 10             	add    $0x10,%esp
f011216f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0112172:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0112176:	74 17                	je     f011218f <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0112178:	83 ec 04             	sub    $0x4,%esp
f011217b:	68 98 93 12 f0       	push   $0xf0129398
f0112180:	68 97 01 00 00       	push   $0x197
f0112185:	68 42 91 12 f0       	push   $0xf0129142
f011218a:	e8 aa e1 fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f011218f:	83 ec 0c             	sub    $0xc,%esp
f0112192:	68 bc 93 12 f0       	push   $0xf01293bc
f0112197:	e8 ef ed fe ff       	call   f0100f8b <cprintf>
f011219c:	83 c4 10             	add    $0x10,%esp
	return 0;
f011219f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01121a4:	c9                   	leave  
f01121a5:	c3                   	ret    

f01121a6 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f01121a6:	55                   	push   %ebp
f01121a7:	89 e5                	mov    %esp,%ebp
f01121a9:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f01121ac:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01121b3:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01121b8:	83 ec 08             	sub    $0x8,%esp
f01121bb:	ff 75 f4             	pushl  -0xc(%ebp)
f01121be:	50                   	push   %eax
f01121bf:	e8 14 7b ff ff       	call   f0109cd8 <pt_clear_page_table_entry>
f01121c4:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f01121c7:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01121cc:	83 ec 08             	sub    $0x8,%esp
f01121cf:	ff 75 f4             	pushl  -0xc(%ebp)
f01121d2:	50                   	push   %eax
f01121d3:	e8 e8 46 00 00       	call   f01168c0 <CE>
f01121d8:	83 c4 10             	add    $0x10,%esp
f01121db:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01121de:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01121e2:	74 17                	je     f01121fb <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f01121e4:	83 ec 04             	sub    $0x4,%esp
f01121e7:	68 04 94 12 f0       	push   $0xf0129404
f01121ec:	68 a7 01 00 00       	push   $0x1a7
f01121f1:	68 42 91 12 f0       	push   $0xf0129142
f01121f6:	e8 3e e1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f01121fb:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112202:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0112207:	83 ec 08             	sub    $0x8,%esp
f011220a:	ff 75 f4             	pushl  -0xc(%ebp)
f011220d:	50                   	push   %eax
f011220e:	e8 c5 7a ff ff       	call   f0109cd8 <pt_clear_page_table_entry>
f0112213:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112216:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011221b:	83 ec 08             	sub    $0x8,%esp
f011221e:	ff 75 f4             	pushl  -0xc(%ebp)
f0112221:	50                   	push   %eax
f0112222:	e8 99 46 00 00       	call   f01168c0 <CE>
f0112227:	83 c4 10             	add    $0x10,%esp
f011222a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011222d:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112231:	74 17                	je     f011224a <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0112233:	83 ec 04             	sub    $0x4,%esp
f0112236:	68 30 94 12 f0       	push   $0xf0129430
f011223b:	68 af 01 00 00       	push   $0x1af
f0112240:	68 42 91 12 f0       	push   $0xf0129142
f0112245:	e8 ef e0 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f011224a:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112251:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0112256:	83 ec 08             	sub    $0x8,%esp
f0112259:	ff 75 f4             	pushl  -0xc(%ebp)
f011225c:	50                   	push   %eax
f011225d:	e8 76 7a ff ff       	call   f0109cd8 <pt_clear_page_table_entry>
f0112262:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112265:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011226a:	83 ec 08             	sub    $0x8,%esp
f011226d:	ff 75 f4             	pushl  -0xc(%ebp)
f0112270:	50                   	push   %eax
f0112271:	e8 4a 46 00 00       	call   f01168c0 <CE>
f0112276:	83 c4 10             	add    $0x10,%esp
f0112279:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011227c:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112280:	74 17                	je     f0112299 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0112282:	83 ec 04             	sub    $0x4,%esp
f0112285:	68 5c 94 12 f0       	push   $0xf012945c
f011228a:	68 b7 01 00 00       	push   $0x1b7
f011228f:	68 42 91 12 f0       	push   $0xf0129142
f0112294:	e8 a0 e0 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f0112299:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01122a0:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01122a5:	83 ec 08             	sub    $0x8,%esp
f01122a8:	ff 75 f4             	pushl  -0xc(%ebp)
f01122ab:	50                   	push   %eax
f01122ac:	e8 27 7a ff ff       	call   f0109cd8 <pt_clear_page_table_entry>
f01122b1:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01122b4:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f01122b9:	83 ec 08             	sub    $0x8,%esp
f01122bc:	ff 75 f4             	pushl  -0xc(%ebp)
f01122bf:	50                   	push   %eax
f01122c0:	e8 fb 45 00 00       	call   f01168c0 <CE>
f01122c5:	83 c4 10             	add    $0x10,%esp
f01122c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01122cb:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01122cf:	74 17                	je     f01122e8 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f01122d1:	83 ec 04             	sub    $0x4,%esp
f01122d4:	68 88 94 12 f0       	push   $0xf0129488
f01122d9:	68 bf 01 00 00       	push   $0x1bf
f01122de:	68 42 91 12 f0       	push   $0xf0129142
f01122e3:	e8 51 e0 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f01122e8:	83 ec 0c             	sub    $0xc,%esp
f01122eb:	68 b4 94 12 f0       	push   $0xf01294b4
f01122f0:	e8 96 ec fe ff       	call   f0100f8b <cprintf>
f01122f5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01122f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01122fd:	c9                   	leave  
f01122fe:	c3                   	ret    

f01122ff <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f01122ff:	55                   	push   %ebp
f0112300:	89 e5                	mov    %esp,%ebp
f0112302:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0112305:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011230c:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f0112311:	83 ec 08             	sub    $0x8,%esp
f0112314:	ff 75 f4             	pushl  -0xc(%ebp)
f0112317:	50                   	push   %eax
f0112318:	e8 bb 79 ff ff       	call   f0109cd8 <pt_clear_page_table_entry>
f011231d:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0112320:	83 ec 04             	sub    $0x4,%esp
f0112323:	68 00 95 12 f0       	push   $0xf0129500
f0112328:	68 ca 01 00 00       	push   $0x1ca
f011232d:	68 42 91 12 f0       	push   $0xf0129142
f0112332:	e8 02 e0 fe ff       	call   f0100339 <_panic>

f0112337 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f0112337:	55                   	push   %ebp
f0112338:	89 e5                	mov    %esp,%ebp
f011233a:	57                   	push   %edi
f011233b:	56                   	push   %esi
f011233c:	53                   	push   %ebx
f011233d:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112343:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112349:	bb 44 98 12 f0       	mov    $0xf0129844,%ebx
f011234e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112353:	89 c7                	mov    %eax,%edi
f0112355:	89 de                	mov    %ebx,%esi
f0112357:	89 d1                	mov    %edx,%ecx
f0112359:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011235b:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0112361:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112366:	b0 00                	mov    $0x0,%al
f0112368:	89 d7                	mov    %edx,%edi
f011236a:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011236c:	6a 00                	push   $0x0
f011236e:	6a 0a                	push   $0xa
f0112370:	6a 14                	push   $0x14
f0112372:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112378:	50                   	push   %eax
f0112379:	e8 8f 8b ff ff       	call   f010af0d <env_create>
f011237e:	83 c4 10             	add    $0x10,%esp
f0112381:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112384:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112387:	8b 40 64             	mov    0x64(%eax),%eax
f011238a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f011238d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112390:	8b 40 68             	mov    0x68(%eax),%eax
f0112393:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0112396:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112399:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011239c:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f01123a3:	75 70 20 
f01123a6:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f01123ad:	00 00 00 
f01123b0:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f01123b6:	b9 03 00 00 00       	mov    $0x3,%ecx
f01123bb:	b8 00 00 00 00       	mov    $0x0,%eax
f01123c0:	89 d7                	mov    %edx,%edi
f01123c2:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01123c4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01123c7:	8b 40 10             	mov    0x10(%eax),%eax
f01123ca:	83 ec 08             	sub    $0x8,%esp
f01123cd:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01123d3:	52                   	push   %edx
f01123d4:	50                   	push   %eax
f01123d5:	e8 94 dc 00 00       	call   f012006e <ltostr>
f01123da:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01123dd:	83 ec 04             	sub    $0x4,%esp
f01123e0:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01123e6:	50                   	push   %eax
f01123e7:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f01123ed:	50                   	push   %eax
f01123ee:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f01123f4:	50                   	push   %eax
f01123f5:	e8 4d dd 00 00       	call   f0120147 <strcconcat>
f01123fa:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f01123fd:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0112404:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f011240b:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0112412:	83 ec 0c             	sub    $0xc,%esp
f0112415:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112418:	e8 85 45 00 00       	call   f01169a2 <ClearUserSpace>
f011241d:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0112420:	83 ec 04             	sub    $0x4,%esp
f0112423:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0112429:	50                   	push   %eax
f011242a:	68 96 95 12 f0       	push   $0xf0129596
f011242f:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112435:	50                   	push   %eax
f0112436:	e8 0c dd 00 00       	call   f0120147 <strcconcat>
f011243b:	83 c4 10             	add    $0x10,%esp
f011243e:	83 ec 0c             	sub    $0xc,%esp
f0112441:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0112447:	50                   	push   %eax
f0112448:	e8 ae fa fe ff       	call   f0101efb <execute_command>
f011244d:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f0112450:	83 ec 04             	sub    $0x4,%esp
f0112453:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112459:	50                   	push   %eax
f011245a:	68 a1 95 12 f0       	push   $0xf01295a1
f011245f:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112465:	50                   	push   %eax
f0112466:	e8 dc dc 00 00       	call   f0120147 <strcconcat>
f011246b:	83 c4 10             	add    $0x10,%esp
f011246e:	83 ec 0c             	sub    $0xc,%esp
f0112471:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112477:	50                   	push   %eax
f0112478:	e8 7e fa fe ff       	call   f0101efb <execute_command>
f011247d:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f0112480:	83 ec 04             	sub    $0x4,%esp
f0112483:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112489:	50                   	push   %eax
f011248a:	68 ac 95 12 f0       	push   $0xf01295ac
f011248f:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112495:	50                   	push   %eax
f0112496:	e8 ac dc 00 00       	call   f0120147 <strcconcat>
f011249b:	83 c4 10             	add    $0x10,%esp
f011249e:	83 ec 0c             	sub    $0xc,%esp
f01124a1:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01124a7:	50                   	push   %eax
f01124a8:	e8 4e fa fe ff       	call   f0101efb <execute_command>
f01124ad:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f01124b0:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f01124b7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01124ba:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f01124bd:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f01124c4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01124c7:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f01124ca:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f01124d1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01124d4:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f01124d7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01124da:	83 ec 08             	sub    $0x8,%esp
f01124dd:	50                   	push   %eax
f01124de:	ff 75 d4             	pushl  -0x2c(%ebp)
f01124e1:	e8 9d 44 00 00       	call   f0116983 <GP>
f01124e6:	83 c4 10             	add    $0x10,%esp
f01124e9:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f01124ec:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f01124f3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f01124fa:	e8 af c3 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01124ff:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0112502:	83 ec 0c             	sub    $0xc,%esp
f0112505:	68 b8 95 12 f0       	push   $0xf01295b8
f011250a:	e8 7c ea fe ff       	call   f0100f8b <cprintf>
f011250f:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0112512:	6a 03                	push   $0x3
f0112514:	68 00 00 90 02       	push   $0x2900000
f0112519:	68 00 00 80 02       	push   $0x2800000
f011251e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112521:	e8 26 85 ff ff       	call   f010aa4c <cut_paste_pages>
f0112526:	83 c4 10             	add    $0x10,%esp
f0112529:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f011252c:	e8 7d c3 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0112531:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0112534:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f011253b:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f011253f:	75 08                	jne    f0112549 <test_cut_paste_pages+0x212>
f0112541:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112544:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112547:	74 2b                	je     f0112574 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112549:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011254c:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011254f:	83 ec 0c             	sub    $0xc,%esp
f0112552:	50                   	push   %eax
f0112553:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112556:	68 e8 95 12 f0       	push   $0xf01295e8
f011255b:	68 04 02 00 00       	push   $0x204
f0112560:	68 42 91 12 f0       	push   $0xf0129142
f0112565:	e8 6c df fe ff       	call   f01004d6 <_warn>
f011256a:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f011256d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0112574:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112578:	74 04                	je     f011257e <test_cut_paste_pages+0x247>
f011257a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f011257e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112585:	83 ec 08             	sub    $0x8,%esp
f0112588:	6a 00                	push   $0x0
f011258a:	6a 01                	push   $0x1
f011258c:	6a 00                	push   $0x0
f011258e:	68 ff 0f 00 00       	push   $0xfff
f0112593:	ff 75 bc             	pushl  -0x44(%ebp)
f0112596:	6a 01                	push   $0x1
f0112598:	68 00 30 00 00       	push   $0x3000
f011259d:	68 00 00 90 02       	push   $0x2900000
f01125a2:	68 00 00 80 02       	push   $0x2800000
f01125a7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125aa:	e8 27 44 00 00       	call   f01169d6 <CCP>
f01125af:	83 c4 30             	add    $0x30,%esp
f01125b2:	83 f8 01             	cmp    $0x1,%eax
f01125b5:	74 21                	je     f01125d8 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01125b7:	83 ec 04             	sub    $0x4,%esp
f01125ba:	68 3c 96 12 f0       	push   $0xf012963c
f01125bf:	68 0c 02 00 00       	push   $0x20c
f01125c4:	68 42 91 12 f0       	push   $0xf0129142
f01125c9:	e8 08 df fe ff       	call   f01004d6 <_warn>
f01125ce:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01125d1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f01125d8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01125dc:	74 04                	je     f01125e2 <test_cut_paste_pages+0x2ab>
f01125de:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f01125e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f01125e9:	83 ec 04             	sub    $0x4,%esp
f01125ec:	6a 00                	push   $0x0
f01125ee:	68 00 00 90 02       	push   $0x2900000
f01125f3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125f6:	e8 b7 41 00 00       	call   f01167b2 <CB>
f01125fb:	83 c4 10             	add    $0x10,%esp
f01125fe:	85 c0                	test   %eax,%eax
f0112600:	0f 84 f6 00 00 00    	je     f01126fc <test_cut_paste_pages+0x3c5>
f0112606:	83 ec 04             	sub    $0x4,%esp
f0112609:	6a 00                	push   $0x0
f011260b:	68 00 10 90 02       	push   $0x2901000
f0112610:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112613:	e8 9a 41 00 00       	call   f01167b2 <CB>
f0112618:	83 c4 10             	add    $0x10,%esp
f011261b:	85 c0                	test   %eax,%eax
f011261d:	0f 84 d9 00 00 00    	je     f01126fc <test_cut_paste_pages+0x3c5>
f0112623:	83 ec 04             	sub    $0x4,%esp
f0112626:	6a 00                	push   $0x0
f0112628:	68 00 20 90 02       	push   $0x2902000
f011262d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112630:	e8 7d 41 00 00       	call   f01167b2 <CB>
f0112635:	83 c4 10             	add    $0x10,%esp
f0112638:	85 c0                	test   %eax,%eax
f011263a:	0f 84 bc 00 00 00    	je     f01126fc <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f0112640:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0112647:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f011264e:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0112655:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112658:	8a 00                	mov    (%eax),%al
f011265a:	3c 61                	cmp    $0x61,%al
f011265c:	75 12                	jne    f0112670 <test_cut_paste_pages+0x339>
f011265e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112661:	8a 00                	mov    (%eax),%al
f0112663:	3c 62                	cmp    $0x62,%al
f0112665:	75 09                	jne    f0112670 <test_cut_paste_pages+0x339>
f0112667:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011266a:	8a 00                	mov    (%eax),%al
f011266c:	3c 63                	cmp    $0x63,%al
f011266e:	74 21                	je     f0112691 <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112670:	83 ec 04             	sub    $0x4,%esp
f0112673:	68 88 96 12 f0       	push   $0xf0129688
f0112678:	68 19 02 00 00       	push   $0x219
f011267d:	68 42 91 12 f0       	push   $0xf0129142
f0112682:	e8 4f de fe ff       	call   f01004d6 <_warn>
f0112687:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011268a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112691:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112695:	74 04                	je     f011269b <test_cut_paste_pages+0x364>
f0112697:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011269b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f01126a2:	83 ec 04             	sub    $0x4,%esp
f01126a5:	6a 01                	push   $0x1
f01126a7:	68 00 10 90 02       	push   $0x2901000
f01126ac:	ff 75 d4             	pushl  -0x2c(%ebp)
f01126af:	e8 fe 40 00 00       	call   f01167b2 <CB>
f01126b4:	83 c4 10             	add    $0x10,%esp
f01126b7:	85 c0                	test   %eax,%eax
f01126b9:	74 41                	je     f01126fc <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f01126bb:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01126be:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f01126c1:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01126c4:	8a 00                	mov    (%eax),%al
f01126c6:	3c 79                	cmp    $0x79,%al
f01126c8:	74 21                	je     f01126eb <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01126ca:	83 ec 04             	sub    $0x4,%esp
f01126cd:	68 88 96 12 f0       	push   $0xf0129688
f01126d2:	68 24 02 00 00       	push   $0x224
f01126d7:	68 42 91 12 f0       	push   $0xf0129142
f01126dc:	e8 f5 dd fe ff       	call   f01004d6 <_warn>
f01126e1:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01126e4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01126eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01126ef:	74 04                	je     f01126f5 <test_cut_paste_pages+0x3be>
f01126f1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01126f5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f01126fc:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01126ff:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0112702:	6a 02                	push   $0x2
f0112704:	68 00 f0 bf 02       	push   $0x2bff000
f0112709:	68 00 10 90 02       	push   $0x2901000
f011270e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112711:	e8 36 83 ff ff       	call   f010aa4c <cut_paste_pages>
f0112716:	83 c4 10             	add    $0x10,%esp
f0112719:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f011271c:	e8 8d c1 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0112721:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112724:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112728:	75 0b                	jne    f0112735 <test_cut_paste_pages+0x3fe>
f011272a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011272d:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112730:	83 f8 01             	cmp    $0x1,%eax
f0112733:	74 2b                	je     f0112760 <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112735:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112738:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011273b:	83 ec 0c             	sub    $0xc,%esp
f011273e:	50                   	push   %eax
f011273f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112742:	68 e8 95 12 f0       	push   $0xf01295e8
f0112747:	68 35 02 00 00       	push   $0x235
f011274c:	68 42 91 12 f0       	push   $0xf0129142
f0112751:	e8 80 dd fe ff       	call   f01004d6 <_warn>
f0112756:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112759:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112760:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112764:	74 04                	je     f011276a <test_cut_paste_pages+0x433>
f0112766:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f011276a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112771:	83 ec 08             	sub    $0x8,%esp
f0112774:	6a 00                	push   $0x0
f0112776:	6a 01                	push   $0x1
f0112778:	6a 00                	push   $0x0
f011277a:	68 ff 0f 00 00       	push   $0xfff
f011277f:	ff 75 bc             	pushl  -0x44(%ebp)
f0112782:	6a 01                	push   $0x1
f0112784:	68 00 20 00 00       	push   $0x2000
f0112789:	68 00 f0 bf 02       	push   $0x2bff000
f011278e:	68 00 10 90 02       	push   $0x2901000
f0112793:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112796:	e8 3b 42 00 00       	call   f01169d6 <CCP>
f011279b:	83 c4 30             	add    $0x30,%esp
f011279e:	83 f8 01             	cmp    $0x1,%eax
f01127a1:	74 21                	je     f01127c4 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01127a3:	83 ec 04             	sub    $0x4,%esp
f01127a6:	68 3c 96 12 f0       	push   $0xf012963c
f01127ab:	68 3d 02 00 00       	push   $0x23d
f01127b0:	68 42 91 12 f0       	push   $0xf0129142
f01127b5:	e8 1c dd fe ff       	call   f01004d6 <_warn>
f01127ba:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01127bd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01127c4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01127c8:	74 04                	je     f01127ce <test_cut_paste_pages+0x497>
f01127ca:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01127ce:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f01127d5:	83 ec 04             	sub    $0x4,%esp
f01127d8:	6a 00                	push   $0x0
f01127da:	68 ff f7 bf 02       	push   $0x2bff7ff
f01127df:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127e2:	e8 cb 3f 00 00       	call   f01167b2 <CB>
f01127e7:	83 c4 10             	add    $0x10,%esp
f01127ea:	85 c0                	test   %eax,%eax
f01127ec:	74 6b                	je     f0112859 <test_cut_paste_pages+0x522>
f01127ee:	83 ec 04             	sub    $0x4,%esp
f01127f1:	6a 00                	push   $0x0
f01127f3:	68 ff 0f c0 02       	push   $0x2c00fff
f01127f8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127fb:	e8 b2 3f 00 00       	call   f01167b2 <CB>
f0112800:	83 c4 10             	add    $0x10,%esp
f0112803:	85 c0                	test   %eax,%eax
f0112805:	74 52                	je     f0112859 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112807:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f011280e:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112815:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112818:	8a 00                	mov    (%eax),%al
f011281a:	3c 79                	cmp    $0x79,%al
f011281c:	75 09                	jne    f0112827 <test_cut_paste_pages+0x4f0>
f011281e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112821:	8a 00                	mov    (%eax),%al
f0112823:	3c 63                	cmp    $0x63,%al
f0112825:	74 21                	je     f0112848 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112827:	83 ec 04             	sub    $0x4,%esp
f011282a:	68 88 96 12 f0       	push   $0xf0129688
f011282f:	68 49 02 00 00       	push   $0x249
f0112834:	68 42 91 12 f0       	push   $0xf0129142
f0112839:	e8 98 dc fe ff       	call   f01004d6 <_warn>
f011283e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112841:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112848:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011284c:	74 04                	je     f0112852 <test_cut_paste_pages+0x51b>
f011284e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112852:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112859:	83 ec 0c             	sub    $0xc,%esp
f011285c:	68 c1 96 12 f0       	push   $0xf01296c1
f0112861:	e8 25 e7 fe ff       	call   f0100f8b <cprintf>
f0112866:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112869:	83 ec 0c             	sub    $0xc,%esp
f011286c:	68 d0 96 12 f0       	push   $0xf01296d0
f0112871:	e8 15 e7 fe ff       	call   f0100f8b <cprintf>
f0112876:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112879:	83 ec 04             	sub    $0x4,%esp
f011287c:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112882:	50                   	push   %eax
f0112883:	68 f9 96 12 f0       	push   $0xf01296f9
f0112888:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011288e:	50                   	push   %eax
f011288f:	e8 b3 d8 00 00       	call   f0120147 <strcconcat>
f0112894:	83 c4 10             	add    $0x10,%esp
f0112897:	83 ec 0c             	sub    $0xc,%esp
f011289a:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01128a0:	50                   	push   %eax
f01128a1:	e8 55 f6 fe ff       	call   f0101efb <execute_command>
f01128a6:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f01128a9:	83 ec 04             	sub    $0x4,%esp
f01128ac:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01128b2:	50                   	push   %eax
f01128b3:	68 04 97 12 f0       	push   $0xf0129704
f01128b8:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01128be:	50                   	push   %eax
f01128bf:	e8 83 d8 00 00       	call   f0120147 <strcconcat>
f01128c4:	83 c4 10             	add    $0x10,%esp
f01128c7:	83 ec 0c             	sub    $0xc,%esp
f01128ca:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01128d0:	50                   	push   %eax
f01128d1:	e8 25 f6 fe ff       	call   f0101efb <execute_command>
f01128d6:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f01128d9:	83 ec 04             	sub    $0x4,%esp
f01128dc:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01128e2:	50                   	push   %eax
f01128e3:	68 0f 97 12 f0       	push   $0xf012970f
f01128e8:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01128ee:	50                   	push   %eax
f01128ef:	e8 53 d8 00 00       	call   f0120147 <strcconcat>
f01128f4:	83 c4 10             	add    $0x10,%esp
f01128f7:	83 ec 0c             	sub    $0xc,%esp
f01128fa:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112900:	50                   	push   %eax
f0112901:	e8 f5 f5 fe ff       	call   f0101efb <execute_command>
f0112906:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112909:	83 ec 04             	sub    $0x4,%esp
f011290c:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112912:	50                   	push   %eax
f0112913:	68 1a 97 12 f0       	push   $0xf012971a
f0112918:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011291e:	50                   	push   %eax
f011291f:	e8 23 d8 00 00       	call   f0120147 <strcconcat>
f0112924:	83 c4 10             	add    $0x10,%esp
f0112927:	83 ec 0c             	sub    $0xc,%esp
f011292a:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112930:	50                   	push   %eax
f0112931:	e8 c5 f5 fe ff       	call   f0101efb <execute_command>
f0112936:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112939:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f0112940:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112943:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112946:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f011294d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112950:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f0112953:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f011295a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011295d:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f0112960:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112967:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011296a:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f011296d:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0112974:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112977:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f011297a:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f0112981:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112984:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0112987:	83 ec 08             	sub    $0x8,%esp
f011298a:	68 00 00 c0 01       	push   $0x1c00000
f011298f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112992:	e8 ec 3f 00 00       	call   f0116983 <GP>
f0112997:	83 c4 10             	add    $0x10,%esp
f011299a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f011299d:	83 ec 08             	sub    $0x8,%esp
f01129a0:	68 00 00 40 01       	push   $0x1400000
f01129a5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129a8:	e8 d6 3f 00 00       	call   f0116983 <GP>
f01129ad:	83 c4 10             	add    $0x10,%esp
f01129b0:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f01129b3:	e8 f6 be ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01129b8:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f01129bb:	6a 01                	push   $0x1
f01129bd:	68 00 00 40 01       	push   $0x1400000
f01129c2:	68 00 00 c0 01       	push   $0x1c00000
f01129c7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129ca:	e8 7d 80 ff ff       	call   f010aa4c <cut_paste_pages>
f01129cf:	83 c4 10             	add    $0x10,%esp
f01129d2:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01129d5:	e8 d4 be ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01129da:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f01129dd:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f01129e1:	75 08                	jne    f01129eb <test_cut_paste_pages+0x6b4>
f01129e3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01129e6:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01129e9:	74 2b                	je     f0112a16 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f01129eb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01129ee:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01129f1:	83 ec 0c             	sub    $0xc,%esp
f01129f4:	50                   	push   %eax
f01129f5:	ff 75 b4             	pushl  -0x4c(%ebp)
f01129f8:	68 28 97 12 f0       	push   $0xf0129728
f01129fd:	68 6c 02 00 00       	push   $0x26c
f0112a02:	68 42 91 12 f0       	push   $0xf0129142
f0112a07:	e8 ca da fe ff       	call   f01004d6 <_warn>
f0112a0c:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112a0f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112a16:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112a1a:	74 04                	je     f0112a20 <test_cut_paste_pages+0x6e9>
f0112a1c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112a20:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112a27:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0112a2e:	83 ec 08             	sub    $0x8,%esp
f0112a31:	6a 00                	push   $0x0
f0112a33:	68 ff 0f 00 00       	push   $0xfff
f0112a38:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112a3b:	68 ff 0f 00 00       	push   $0xfff
f0112a40:	ff 75 a0             	pushl  -0x60(%ebp)
f0112a43:	6a 01                	push   $0x1
f0112a45:	68 00 10 00 00       	push   $0x1000
f0112a4a:	68 00 00 40 01       	push   $0x1400000
f0112a4f:	68 00 00 c0 01       	push   $0x1c00000
f0112a54:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a57:	e8 7a 3f 00 00       	call   f01169d6 <CCP>
f0112a5c:	83 c4 30             	add    $0x30,%esp
f0112a5f:	83 f8 01             	cmp    $0x1,%eax
f0112a62:	74 28                	je     f0112a8c <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112a64:	83 ec 04             	sub    $0x4,%esp
f0112a67:	68 3c 96 12 f0       	push   $0xf012963c
f0112a6c:	68 75 02 00 00       	push   $0x275
f0112a71:	68 42 91 12 f0       	push   $0xf0129142
f0112a76:	e8 5b da fe ff       	call   f01004d6 <_warn>
f0112a7b:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112a7e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112a85:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112a8c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112a90:	74 04                	je     f0112a96 <test_cut_paste_pages+0x75f>
f0112a92:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112a96:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112a9d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112aa1:	0f 84 92 00 00 00    	je     f0112b39 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0112aa7:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112aae:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112ab5:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112abc:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112ac3:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112aca:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112ad1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112ad4:	8a 00                	mov    (%eax),%al
f0112ad6:	3c 61                	cmp    $0x61,%al
f0112ad8:	75 2d                	jne    f0112b07 <test_cut_paste_pages+0x7d0>
f0112ada:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112add:	8a 00                	mov    (%eax),%al
f0112adf:	3c 78                	cmp    $0x78,%al
f0112ae1:	75 24                	jne    f0112b07 <test_cut_paste_pages+0x7d0>
f0112ae3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112ae6:	8a 00                	mov    (%eax),%al
f0112ae8:	3c 62                	cmp    $0x62,%al
f0112aea:	75 1b                	jne    f0112b07 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112aec:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112aef:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112af1:	3c 79                	cmp    $0x79,%al
f0112af3:	75 12                	jne    f0112b07 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112af5:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112af8:	8a 00                	mov    (%eax),%al
f0112afa:	3c 63                	cmp    $0x63,%al
f0112afc:	75 09                	jne    f0112b07 <test_cut_paste_pages+0x7d0>
f0112afe:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112b01:	8a 00                	mov    (%eax),%al
f0112b03:	3c 7a                	cmp    $0x7a,%al
f0112b05:	74 21                	je     f0112b28 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112b07:	83 ec 04             	sub    $0x4,%esp
f0112b0a:	68 88 96 12 f0       	push   $0xf0129688
f0112b0f:	68 87 02 00 00       	push   $0x287
f0112b14:	68 42 91 12 f0       	push   $0xf0129142
f0112b19:	e8 b8 d9 fe ff       	call   f01004d6 <_warn>
f0112b1e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112b21:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112b28:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b2c:	74 04                	je     f0112b32 <test_cut_paste_pages+0x7fb>
f0112b2e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112b32:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112b39:	e8 70 bd ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0112b3e:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f0112b41:	6a 03                	push   $0x3
f0112b43:	68 00 f0 bf 01       	push   $0x1bff000
f0112b48:	68 00 00 40 01       	push   $0x1400000
f0112b4d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b50:	e8 f7 7e ff ff       	call   f010aa4c <cut_paste_pages>
f0112b55:	83 c4 10             	add    $0x10,%esp
f0112b58:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112b5b:	e8 4e bd ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0112b60:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112b63:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112b67:	75 08                	jne    f0112b71 <test_cut_paste_pages+0x83a>
f0112b69:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112b6c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112b6f:	74 2b                	je     f0112b9c <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112b71:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112b74:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112b77:	83 ec 0c             	sub    $0xc,%esp
f0112b7a:	50                   	push   %eax
f0112b7b:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112b7e:	68 28 97 12 f0       	push   $0xf0129728
f0112b83:	68 96 02 00 00       	push   $0x296
f0112b88:	68 42 91 12 f0       	push   $0xf0129142
f0112b8d:	e8 44 d9 fe ff       	call   f01004d6 <_warn>
f0112b92:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112b95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112b9c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112ba0:	74 04                	je     f0112ba6 <test_cut_paste_pages+0x86f>
f0112ba2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112ba6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0112bad:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112bb4:	83 ec 04             	sub    $0x4,%esp
f0112bb7:	6a 00                	push   $0x0
f0112bb9:	68 00 00 40 01       	push   $0x1400000
f0112bbe:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112bc1:	e8 ec 3b 00 00       	call   f01167b2 <CB>
f0112bc6:	83 c4 10             	add    $0x10,%esp
f0112bc9:	83 f8 01             	cmp    $0x1,%eax
f0112bcc:	0f 85 80 00 00 00    	jne    f0112c52 <test_cut_paste_pages+0x91b>
f0112bd2:	83 ec 04             	sub    $0x4,%esp
f0112bd5:	6a 00                	push   $0x0
f0112bd7:	68 00 10 40 01       	push   $0x1401000
f0112bdc:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112bdf:	e8 ce 3b 00 00       	call   f01167b2 <CB>
f0112be4:	83 c4 10             	add    $0x10,%esp
f0112be7:	83 f8 01             	cmp    $0x1,%eax
f0112bea:	75 66                	jne    f0112c52 <test_cut_paste_pages+0x91b>
f0112bec:	83 ec 04             	sub    $0x4,%esp
f0112bef:	6a 00                	push   $0x0
f0112bf1:	68 00 20 40 01       	push   $0x1402000
f0112bf6:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112bf9:	e8 b4 3b 00 00       	call   f01167b2 <CB>
f0112bfe:	83 c4 10             	add    $0x10,%esp
f0112c01:	83 f8 01             	cmp    $0x1,%eax
f0112c04:	75 4c                	jne    f0112c52 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112c06:	83 ec 04             	sub    $0x4,%esp
f0112c09:	6a 00                	push   $0x0
f0112c0b:	68 00 f0 bf 01       	push   $0x1bff000
f0112c10:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c13:	e8 9a 3b 00 00       	call   f01167b2 <CB>
f0112c18:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112c1b:	85 c0                	test   %eax,%eax
f0112c1d:	75 33                	jne    f0112c52 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112c1f:	83 ec 04             	sub    $0x4,%esp
f0112c22:	6a 00                	push   $0x0
f0112c24:	68 00 00 c0 01       	push   $0x1c00000
f0112c29:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c2c:	e8 81 3b 00 00       	call   f01167b2 <CB>
f0112c31:	83 c4 10             	add    $0x10,%esp
f0112c34:	83 f8 01             	cmp    $0x1,%eax
f0112c37:	75 19                	jne    f0112c52 <test_cut_paste_pages+0x91b>
f0112c39:	83 ec 04             	sub    $0x4,%esp
f0112c3c:	6a 00                	push   $0x0
f0112c3e:	68 00 10 c0 01       	push   $0x1c01000
f0112c43:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c46:	e8 67 3b 00 00       	call   f01167b2 <CB>
f0112c4b:	83 c4 10             	add    $0x10,%esp
f0112c4e:	85 c0                	test   %eax,%eax
f0112c50:	74 28                	je     f0112c7a <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0112c52:	83 ec 04             	sub    $0x4,%esp
f0112c55:	68 88 97 12 f0       	push   $0xf0129788
f0112c5a:	68 9f 02 00 00       	push   $0x29f
f0112c5f:	68 42 91 12 f0       	push   $0xf0129142
f0112c64:	e8 6d d8 fe ff       	call   f01004d6 <_warn>
f0112c69:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112c6c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112c73:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112c7a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c7e:	74 04                	je     f0112c84 <test_cut_paste_pages+0x94d>
f0112c80:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112c84:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112c8b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112c8f:	0f 84 99 00 00 00    	je     f0112d2e <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0112c95:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112c9c:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112ca3:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112caa:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112cb1:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112cb8:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112cbf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112cc2:	8a 00                	mov    (%eax),%al
f0112cc4:	3c 61                	cmp    $0x61,%al
f0112cc6:	75 2d                	jne    f0112cf5 <test_cut_paste_pages+0x9be>
f0112cc8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112ccb:	8a 00                	mov    (%eax),%al
f0112ccd:	3c 78                	cmp    $0x78,%al
f0112ccf:	75 24                	jne    f0112cf5 <test_cut_paste_pages+0x9be>
f0112cd1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112cd4:	8a 00                	mov    (%eax),%al
f0112cd6:	3c 62                	cmp    $0x62,%al
f0112cd8:	75 1b                	jne    f0112cf5 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112cda:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112cdd:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112cdf:	3c 79                	cmp    $0x79,%al
f0112ce1:	75 12                	jne    f0112cf5 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112ce3:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112ce6:	8a 00                	mov    (%eax),%al
f0112ce8:	3c 63                	cmp    $0x63,%al
f0112cea:	75 09                	jne    f0112cf5 <test_cut_paste_pages+0x9be>
f0112cec:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112cef:	8a 00                	mov    (%eax),%al
f0112cf1:	3c 7a                	cmp    $0x7a,%al
f0112cf3:	74 28                	je     f0112d1d <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0112cf5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0112cfc:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112d03:	83 ec 04             	sub    $0x4,%esp
f0112d06:	68 88 96 12 f0       	push   $0xf0129688
f0112d0b:	68 b3 02 00 00       	push   $0x2b3
f0112d10:	68 42 91 12 f0       	push   $0xf0129142
f0112d15:	e8 bc d7 fe ff       	call   f01004d6 <_warn>
f0112d1a:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0112d1d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d21:	74 04                	je     f0112d27 <test_cut_paste_pages+0x9f0>
f0112d23:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112d27:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0112d2e:	83 ec 0c             	sub    $0xc,%esp
f0112d31:	68 c1 97 12 f0       	push   $0xf01297c1
f0112d36:	e8 50 e2 fe ff       	call   f0100f8b <cprintf>
f0112d3b:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0112d3e:	83 ec 08             	sub    $0x8,%esp
f0112d41:	ff 75 e4             	pushl  -0x1c(%ebp)
f0112d44:	68 d0 97 12 f0       	push   $0xf01297d0
f0112d49:	e8 3d e2 fe ff       	call   f0100f8b <cprintf>
f0112d4e:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0112d51:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112d55:	75 10                	jne    f0112d67 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0112d57:	83 ec 0c             	sub    $0xc,%esp
f0112d5a:	68 04 98 12 f0       	push   $0xf0129804
f0112d5f:	e8 27 e2 fe ff       	call   f0100f8b <cprintf>
f0112d64:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112d67:	a1 c4 0d 6c f0       	mov    0xf06c0dc4,%eax
f0112d6c:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0112d6f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112d72:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0112d75:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112d7a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0112d7d:	5b                   	pop    %ebx
f0112d7e:	5e                   	pop    %esi
f0112d7f:	5f                   	pop    %edi
f0112d80:	5d                   	pop    %ebp
f0112d81:	c3                   	ret    

f0112d82 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0112d82:	55                   	push   %ebp
f0112d83:	89 e5                	mov    %esp,%ebp
f0112d85:	57                   	push   %edi
f0112d86:	56                   	push   %esi
f0112d87:	53                   	push   %ebx
f0112d88:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112d8e:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112d94:	bb 44 98 12 f0       	mov    $0xf0129844,%ebx
f0112d99:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112d9e:	89 c7                	mov    %eax,%edi
f0112da0:	89 de                	mov    %ebx,%esi
f0112da2:	89 d1                	mov    %edx,%ecx
f0112da4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112da6:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0112dac:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112db1:	b0 00                	mov    $0x0,%al
f0112db3:	89 d7                	mov    %edx,%edi
f0112db5:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112db7:	6a 00                	push   $0x0
f0112db9:	6a 0a                	push   $0xa
f0112dbb:	6a 14                	push   $0x14
f0112dbd:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112dc3:	50                   	push   %eax
f0112dc4:	e8 44 81 ff ff       	call   f010af0d <env_create>
f0112dc9:	83 c4 10             	add    $0x10,%esp
f0112dcc:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112dcf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112dd2:	8b 40 64             	mov    0x64(%eax),%eax
f0112dd5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112dd8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112ddb:	8b 40 68             	mov    0x68(%eax),%eax
f0112dde:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0112de4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0112dea:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112ded:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0112df4:	75 70 20 
f0112df7:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0112dfe:	00 00 00 
f0112e01:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112e07:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112e0c:	b8 00 00 00 00       	mov    $0x0,%eax
f0112e11:	89 d7                	mov    %edx,%edi
f0112e13:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112e15:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112e18:	8b 40 10             	mov    0x10(%eax),%eax
f0112e1b:	83 ec 08             	sub    $0x8,%esp
f0112e1e:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0112e24:	52                   	push   %edx
f0112e25:	50                   	push   %eax
f0112e26:	e8 43 d2 00 00       	call   f012006e <ltostr>
f0112e2b:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112e2e:	83 ec 04             	sub    $0x4,%esp
f0112e31:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112e37:	50                   	push   %eax
f0112e38:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0112e3e:	50                   	push   %eax
f0112e3f:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0112e45:	50                   	push   %eax
f0112e46:	e8 fc d2 00 00       	call   f0120147 <strcconcat>
f0112e4b:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0112e4e:	83 ec 0c             	sub    $0xc,%esp
f0112e51:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112e54:	e8 49 3b 00 00       	call   f01169a2 <ClearUserSpace>
f0112e59:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0112e5c:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0112e63:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0112e6a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0112e71:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0112e78:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0112e7f:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0112e86:	83 ec 0c             	sub    $0xc,%esp
f0112e89:	68 78 98 12 f0       	push   $0xf0129878
f0112e8e:	e8 f8 e0 fe ff       	call   f0100f8b <cprintf>
f0112e93:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0112e96:	83 ec 04             	sub    $0x4,%esp
f0112e99:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112e9f:	50                   	push   %eax
f0112ea0:	68 ae 98 12 f0       	push   $0xf01298ae
f0112ea5:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112eab:	50                   	push   %eax
f0112eac:	e8 96 d2 00 00       	call   f0120147 <strcconcat>
f0112eb1:	83 c4 10             	add    $0x10,%esp
f0112eb4:	83 ec 0c             	sub    $0xc,%esp
f0112eb7:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112ebd:	50                   	push   %eax
f0112ebe:	e8 38 f0 fe ff       	call   f0101efb <execute_command>
f0112ec3:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0112ec6:	83 ec 04             	sub    $0x4,%esp
f0112ec9:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112ecf:	50                   	push   %eax
f0112ed0:	68 b3 98 12 f0       	push   $0xf01298b3
f0112ed5:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112edb:	50                   	push   %eax
f0112edc:	e8 66 d2 00 00       	call   f0120147 <strcconcat>
f0112ee1:	83 c4 10             	add    $0x10,%esp
f0112ee4:	83 ec 0c             	sub    $0xc,%esp
f0112ee7:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112eed:	50                   	push   %eax
f0112eee:	e8 08 f0 fe ff       	call   f0101efb <execute_command>
f0112ef3:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0112ef6:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112efc:	bb b9 9b 12 f0       	mov    $0xf0129bb9,%ebx
f0112f01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f06:	89 c7                	mov    %eax,%edi
f0112f08:	89 de                	mov    %ebx,%esi
f0112f0a:	89 d1                	mov    %edx,%ecx
f0112f0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f0e:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0112f14:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112f19:	b0 00                	mov    $0x0,%al
f0112f1b:	89 d7                	mov    %edx,%edi
f0112f1d:	f3 aa                	rep stos %al,%es:(%edi)
f0112f1f:	83 ec 0c             	sub    $0xc,%esp
f0112f22:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112f28:	50                   	push   %eax
f0112f29:	e8 cd ef fe ff       	call   f0101efb <execute_command>
f0112f2e:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0112f31:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112f37:	bb 1d 9c 12 f0       	mov    $0xf0129c1d,%ebx
f0112f3c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f41:	89 c7                	mov    %eax,%edi
f0112f43:	89 de                	mov    %ebx,%esi
f0112f45:	89 d1                	mov    %edx,%ecx
f0112f47:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f49:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0112f4f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112f54:	b0 00                	mov    $0x0,%al
f0112f56:	89 d7                	mov    %edx,%edi
f0112f58:	f3 aa                	rep stos %al,%es:(%edi)
f0112f5a:	83 ec 0c             	sub    $0xc,%esp
f0112f5d:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112f63:	50                   	push   %eax
f0112f64:	e8 92 ef fe ff       	call   f0101efb <execute_command>
f0112f69:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0112f6c:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112f72:	bb 81 9c 12 f0       	mov    $0xf0129c81,%ebx
f0112f77:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f7c:	89 c7                	mov    %eax,%edi
f0112f7e:	89 de                	mov    %ebx,%esi
f0112f80:	89 d1                	mov    %edx,%ecx
f0112f82:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f84:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0112f8a:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112f8f:	b0 00                	mov    $0x0,%al
f0112f91:	89 d7                	mov    %edx,%edi
f0112f93:	f3 aa                	rep stos %al,%es:(%edi)
f0112f95:	83 ec 0c             	sub    $0xc,%esp
f0112f98:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112f9e:	50                   	push   %eax
f0112f9f:	e8 57 ef fe ff       	call   f0101efb <execute_command>
f0112fa4:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0112fa7:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112fad:	bb e5 9c 12 f0       	mov    $0xf0129ce5,%ebx
f0112fb2:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112fb7:	89 c7                	mov    %eax,%edi
f0112fb9:	89 de                	mov    %ebx,%esi
f0112fbb:	89 d1                	mov    %edx,%ecx
f0112fbd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112fbf:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0112fc5:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112fca:	b0 00                	mov    $0x0,%al
f0112fcc:	89 d7                	mov    %edx,%edi
f0112fce:	f3 aa                	rep stos %al,%es:(%edi)
f0112fd0:	83 ec 0c             	sub    $0xc,%esp
f0112fd3:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112fd9:	50                   	push   %eax
f0112fda:	e8 1c ef fe ff       	call   f0101efb <execute_command>
f0112fdf:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0112fe2:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112fe8:	bb 49 9d 12 f0       	mov    $0xf0129d49,%ebx
f0112fed:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112ff2:	89 c7                	mov    %eax,%edi
f0112ff4:	89 de                	mov    %ebx,%esi
f0112ff6:	89 d1                	mov    %edx,%ecx
f0112ff8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112ffa:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0113000:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113005:	b0 00                	mov    $0x0,%al
f0113007:	89 d7                	mov    %edx,%edi
f0113009:	f3 aa                	rep stos %al,%es:(%edi)
f011300b:	83 ec 0c             	sub    $0xc,%esp
f011300e:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113014:	50                   	push   %eax
f0113015:	e8 e1 ee fe ff       	call   f0101efb <execute_command>
f011301a:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f011301d:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113023:	bb ad 9d 12 f0       	mov    $0xf0129dad,%ebx
f0113028:	ba 0f 00 00 00       	mov    $0xf,%edx
f011302d:	89 c7                	mov    %eax,%edi
f011302f:	89 de                	mov    %ebx,%esi
f0113031:	89 d1                	mov    %edx,%ecx
f0113033:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113035:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f011303b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113040:	b0 00                	mov    $0x0,%al
f0113042:	89 d7                	mov    %edx,%edi
f0113044:	f3 aa                	rep stos %al,%es:(%edi)
f0113046:	83 ec 0c             	sub    $0xc,%esp
f0113049:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f011304f:	50                   	push   %eax
f0113050:	e8 a6 ee fe ff       	call   f0101efb <execute_command>
f0113055:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0113058:	83 ec 04             	sub    $0x4,%esp
f011305b:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113061:	50                   	push   %eax
f0113062:	68 bb 98 12 f0       	push   $0xf01298bb
f0113067:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011306d:	50                   	push   %eax
f011306e:	e8 d4 d0 00 00       	call   f0120147 <strcconcat>
f0113073:	83 c4 10             	add    $0x10,%esp
f0113076:	83 ec 0c             	sub    $0xc,%esp
f0113079:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011307f:	50                   	push   %eax
f0113080:	e8 76 ee fe ff       	call   f0101efb <execute_command>
f0113085:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0113088:	83 ec 04             	sub    $0x4,%esp
f011308b:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113091:	50                   	push   %eax
f0113092:	68 c5 98 12 f0       	push   $0xf01298c5
f0113097:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011309d:	50                   	push   %eax
f011309e:	e8 a4 d0 00 00       	call   f0120147 <strcconcat>
f01130a3:	83 c4 10             	add    $0x10,%esp
f01130a6:	83 ec 0c             	sub    $0xc,%esp
f01130a9:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01130af:	50                   	push   %eax
f01130b0:	e8 46 ee fe ff       	call   f0101efb <execute_command>
f01130b5:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f01130b8:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01130be:	bb 11 9e 12 f0       	mov    $0xf0129e11,%ebx
f01130c3:	ba 0f 00 00 00       	mov    $0xf,%edx
f01130c8:	89 c7                	mov    %eax,%edi
f01130ca:	89 de                	mov    %ebx,%esi
f01130cc:	89 d1                	mov    %edx,%ecx
f01130ce:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01130d0:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01130d6:	b9 55 00 00 00       	mov    $0x55,%ecx
f01130db:	b0 00                	mov    $0x0,%al
f01130dd:	89 d7                	mov    %edx,%edi
f01130df:	f3 aa                	rep stos %al,%es:(%edi)
f01130e1:	83 ec 0c             	sub    $0xc,%esp
f01130e4:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01130ea:	50                   	push   %eax
f01130eb:	e8 0b ee fe ff       	call   f0101efb <execute_command>
f01130f0:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f01130f3:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01130f9:	bb 75 9e 12 f0       	mov    $0xf0129e75,%ebx
f01130fe:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113103:	89 c7                	mov    %eax,%edi
f0113105:	89 de                	mov    %ebx,%esi
f0113107:	89 d1                	mov    %edx,%ecx
f0113109:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011310b:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113111:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113116:	b0 00                	mov    $0x0,%al
f0113118:	89 d7                	mov    %edx,%edi
f011311a:	f3 aa                	rep stos %al,%es:(%edi)
f011311c:	83 ec 0c             	sub    $0xc,%esp
f011311f:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113125:	50                   	push   %eax
f0113126:	e8 d0 ed fe ff       	call   f0101efb <execute_command>
f011312b:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f011312e:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113134:	bb d9 9e 12 f0       	mov    $0xf0129ed9,%ebx
f0113139:	ba 0f 00 00 00       	mov    $0xf,%edx
f011313e:	89 c7                	mov    %eax,%edi
f0113140:	89 de                	mov    %ebx,%esi
f0113142:	89 d1                	mov    %edx,%ecx
f0113144:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113146:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f011314c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113151:	b0 00                	mov    $0x0,%al
f0113153:	89 d7                	mov    %edx,%edi
f0113155:	f3 aa                	rep stos %al,%es:(%edi)
f0113157:	83 ec 0c             	sub    $0xc,%esp
f011315a:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113160:	50                   	push   %eax
f0113161:	e8 95 ed fe ff       	call   f0101efb <execute_command>
f0113166:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0113169:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0113170:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0113177:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f011317e:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0113185:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f011318c:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0113193:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f011319a:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f01131a1:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f01131a8:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f01131af:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f01131b6:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f01131bd:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01131c0:	8a 00                	mov    (%eax),%al
f01131c2:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f01131c8:	8b 45 98             	mov    -0x68(%ebp),%eax
f01131cb:	8a 00                	mov    (%eax),%al
f01131cd:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f01131d3:	8b 45 90             	mov    -0x70(%ebp),%eax
f01131d6:	8a 00                	mov    (%eax),%al
f01131d8:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01131de:	e8 cb b6 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01131e3:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f01131e6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01131e9:	89 d0                	mov    %edx,%eax
f01131eb:	01 c0                	add    %eax,%eax
f01131ed:	01 d0                	add    %edx,%eax
f01131ef:	01 c0                	add    %eax,%eax
f01131f1:	50                   	push   %eax
f01131f2:	68 00 00 10 00       	push   $0x100000
f01131f7:	6a 00                	push   $0x0
f01131f9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131fc:	e8 65 78 ff ff       	call   f010aa66 <copy_paste_chunk>
f0113201:	83 c4 10             	add    $0x10,%esp
f0113204:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113207:	e8 a2 b6 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011320c:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f011320f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113216:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f011321a:	75 08                	jne    f0113224 <test_copy_paste_chunk+0x4a2>
f011321c:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011321f:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113222:	74 2b                	je     f011324f <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113224:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113227:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011322a:	83 ec 0c             	sub    $0xc,%esp
f011322d:	50                   	push   %eax
f011322e:	ff 75 88             	pushl  -0x78(%ebp)
f0113231:	68 d4 98 12 f0       	push   $0xf01298d4
f0113236:	68 06 03 00 00       	push   $0x306
f011323b:	68 42 91 12 f0       	push   $0xf0129142
f0113240:	e8 91 d2 fe ff       	call   f01004d6 <_warn>
f0113245:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113248:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011324f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113253:	74 04                	je     f0113259 <test_copy_paste_chunk+0x4d7>
f0113255:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113259:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f0113260:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113263:	8a 00                	mov    (%eax),%al
f0113265:	3c 61                	cmp    $0x61,%al
f0113267:	75 75                	jne    f01132de <test_copy_paste_chunk+0x55c>
f0113269:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011326c:	8a 00                	mov    (%eax),%al
f011326e:	3c 78                	cmp    $0x78,%al
f0113270:	75 6c                	jne    f01132de <test_copy_paste_chunk+0x55c>
f0113272:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113275:	8a 00                	mov    (%eax),%al
f0113277:	3c 62                	cmp    $0x62,%al
f0113279:	75 63                	jne    f01132de <test_copy_paste_chunk+0x55c>
f011327b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011327e:	8a 00                	mov    (%eax),%al
f0113280:	3c 79                	cmp    $0x79,%al
f0113282:	75 5a                	jne    f01132de <test_copy_paste_chunk+0x55c>
f0113284:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113287:	8a 00                	mov    (%eax),%al
f0113289:	3c 63                	cmp    $0x63,%al
f011328b:	75 51                	jne    f01132de <test_copy_paste_chunk+0x55c>
f011328d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113290:	8a 00                	mov    (%eax),%al
f0113292:	3c 7a                	cmp    $0x7a,%al
f0113294:	75 48                	jne    f01132de <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0113296:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113299:	8a 00                	mov    (%eax),%al
f011329b:	3c 64                	cmp    $0x64,%al
f011329d:	75 3f                	jne    f01132de <test_copy_paste_chunk+0x55c>
f011329f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01132a2:	8a 10                	mov    (%eax),%dl
f01132a4:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f01132aa:	38 c2                	cmp    %al,%dl
f01132ac:	75 30                	jne    f01132de <test_copy_paste_chunk+0x55c>
f01132ae:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01132b1:	8a 00                	mov    (%eax),%al
f01132b3:	3c 65                	cmp    $0x65,%al
f01132b5:	75 27                	jne    f01132de <test_copy_paste_chunk+0x55c>
f01132b7:	8b 45 98             	mov    -0x68(%ebp),%eax
f01132ba:	8a 10                	mov    (%eax),%dl
f01132bc:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f01132c2:	38 c2                	cmp    %al,%dl
f01132c4:	75 18                	jne    f01132de <test_copy_paste_chunk+0x55c>
f01132c6:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01132c9:	8a 00                	mov    (%eax),%al
f01132cb:	3c 66                	cmp    $0x66,%al
f01132cd:	75 0f                	jne    f01132de <test_copy_paste_chunk+0x55c>
f01132cf:	8b 45 90             	mov    -0x70(%ebp),%eax
f01132d2:	8a 10                	mov    (%eax),%dl
f01132d4:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01132da:	38 c2                	cmp    %al,%dl
f01132dc:	74 21                	je     f01132ff <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01132de:	83 ec 04             	sub    $0x4,%esp
f01132e1:	68 38 99 12 f0       	push   $0xf0129938
f01132e6:	68 0f 03 00 00       	push   $0x30f
f01132eb:	68 42 91 12 f0       	push   $0xf0129142
f01132f0:	e8 e1 d1 fe ff       	call   f01004d6 <_warn>
f01132f5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01132f8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01132ff:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113303:	74 04                	je     f0113309 <test_copy_paste_chunk+0x587>
f0113305:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113309:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f0113310:	83 ec 0c             	sub    $0xc,%esp
f0113313:	68 72 99 12 f0       	push   $0xf0129972
f0113318:	e8 6e dc fe ff       	call   f0100f8b <cprintf>
f011331d:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0113320:	83 ec 0c             	sub    $0xc,%esp
f0113323:	68 84 99 12 f0       	push   $0xf0129984
f0113328:	e8 5e dc fe ff       	call   f0100f8b <cprintf>
f011332d:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f0113330:	83 ec 04             	sub    $0x4,%esp
f0113333:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113339:	50                   	push   %eax
f011333a:	68 ba 99 12 f0       	push   $0xf01299ba
f011333f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113345:	50                   	push   %eax
f0113346:	e8 fc cd 00 00       	call   f0120147 <strcconcat>
f011334b:	83 c4 10             	add    $0x10,%esp
f011334e:	83 ec 0c             	sub    $0xc,%esp
f0113351:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113357:	50                   	push   %eax
f0113358:	e8 9e eb fe ff       	call   f0101efb <execute_command>
f011335d:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f0113360:	83 ec 04             	sub    $0x4,%esp
f0113363:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113369:	50                   	push   %eax
f011336a:	68 c4 99 12 f0       	push   $0xf01299c4
f011336f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113375:	50                   	push   %eax
f0113376:	e8 cc cd 00 00       	call   f0120147 <strcconcat>
f011337b:	83 c4 10             	add    $0x10,%esp
f011337e:	83 ec 0c             	sub    $0xc,%esp
f0113381:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113387:	50                   	push   %eax
f0113388:	e8 6e eb fe ff       	call   f0101efb <execute_command>
f011338d:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f0113390:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113396:	bb 3d 9f 12 f0       	mov    $0xf0129f3d,%ebx
f011339b:	ba 0f 00 00 00       	mov    $0xf,%edx
f01133a0:	89 c7                	mov    %eax,%edi
f01133a2:	89 de                	mov    %ebx,%esi
f01133a4:	89 d1                	mov    %edx,%ecx
f01133a6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01133a8:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f01133ae:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133b3:	b0 00                	mov    $0x0,%al
f01133b5:	89 d7                	mov    %edx,%edi
f01133b7:	f3 aa                	rep stos %al,%es:(%edi)
f01133b9:	83 ec 0c             	sub    $0xc,%esp
f01133bc:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01133c2:	50                   	push   %eax
f01133c3:	e8 33 eb fe ff       	call   f0101efb <execute_command>
f01133c8:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f01133cb:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01133d1:	bb a1 9f 12 f0       	mov    $0xf0129fa1,%ebx
f01133d6:	ba 0f 00 00 00       	mov    $0xf,%edx
f01133db:	89 c7                	mov    %eax,%edi
f01133dd:	89 de                	mov    %ebx,%esi
f01133df:	89 d1                	mov    %edx,%ecx
f01133e1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01133e3:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f01133e9:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133ee:	b0 00                	mov    $0x0,%al
f01133f0:	89 d7                	mov    %edx,%edi
f01133f2:	f3 aa                	rep stos %al,%es:(%edi)
f01133f4:	83 ec 0c             	sub    $0xc,%esp
f01133f7:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01133fd:	50                   	push   %eax
f01133fe:	e8 f8 ea fe ff       	call   f0101efb <execute_command>
f0113403:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0113406:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011340c:	bb 05 a0 12 f0       	mov    $0xf012a005,%ebx
f0113411:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113416:	89 c7                	mov    %eax,%edi
f0113418:	89 de                	mov    %ebx,%esi
f011341a:	89 d1                	mov    %edx,%ecx
f011341c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011341e:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113424:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113429:	b0 00                	mov    $0x0,%al
f011342b:	89 d7                	mov    %edx,%edi
f011342d:	f3 aa                	rep stos %al,%es:(%edi)
f011342f:	83 ec 0c             	sub    $0xc,%esp
f0113432:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113438:	50                   	push   %eax
f0113439:	e8 bd ea fe ff       	call   f0101efb <execute_command>
f011343e:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f0113441:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113447:	bb 69 a0 12 f0       	mov    $0xf012a069,%ebx
f011344c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113451:	89 c7                	mov    %eax,%edi
f0113453:	89 de                	mov    %ebx,%esi
f0113455:	89 d1                	mov    %edx,%ecx
f0113457:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113459:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f011345f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113464:	b0 00                	mov    $0x0,%al
f0113466:	89 d7                	mov    %edx,%edi
f0113468:	f3 aa                	rep stos %al,%es:(%edi)
f011346a:	83 ec 0c             	sub    $0xc,%esp
f011346d:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113473:	50                   	push   %eax
f0113474:	e8 82 ea fe ff       	call   f0101efb <execute_command>
f0113479:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f011347c:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113482:	bb cd a0 12 f0       	mov    $0xf012a0cd,%ebx
f0113487:	ba 0f 00 00 00       	mov    $0xf,%edx
f011348c:	89 c7                	mov    %eax,%edi
f011348e:	89 de                	mov    %ebx,%esi
f0113490:	89 d1                	mov    %edx,%ecx
f0113492:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113494:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f011349a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011349f:	b0 00                	mov    $0x0,%al
f01134a1:	89 d7                	mov    %edx,%edi
f01134a3:	f3 aa                	rep stos %al,%es:(%edi)
f01134a5:	83 ec 0c             	sub    $0xc,%esp
f01134a8:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01134ae:	50                   	push   %eax
f01134af:	e8 47 ea fe ff       	call   f0101efb <execute_command>
f01134b4:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f01134b7:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01134bd:	bb 31 a1 12 f0       	mov    $0xf012a131,%ebx
f01134c2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134c7:	89 c7                	mov    %eax,%edi
f01134c9:	89 de                	mov    %ebx,%esi
f01134cb:	89 d1                	mov    %edx,%ecx
f01134cd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134cf:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01134d5:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134da:	b0 00                	mov    $0x0,%al
f01134dc:	89 d7                	mov    %edx,%edi
f01134de:	f3 aa                	rep stos %al,%es:(%edi)
f01134e0:	83 ec 0c             	sub    $0xc,%esp
f01134e3:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01134e9:	50                   	push   %eax
f01134ea:	e8 0c ea fe ff       	call   f0101efb <execute_command>
f01134ef:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f01134f2:	83 ec 04             	sub    $0x4,%esp
f01134f5:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01134fb:	50                   	push   %eax
f01134fc:	68 ce 99 12 f0       	push   $0xf01299ce
f0113501:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113507:	50                   	push   %eax
f0113508:	e8 3a cc 00 00       	call   f0120147 <strcconcat>
f011350d:	83 c4 10             	add    $0x10,%esp
f0113510:	83 ec 0c             	sub    $0xc,%esp
f0113513:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113519:	50                   	push   %eax
f011351a:	e8 dc e9 fe ff       	call   f0101efb <execute_command>
f011351f:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0113522:	83 ec 04             	sub    $0x4,%esp
f0113525:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011352b:	50                   	push   %eax
f011352c:	68 d8 99 12 f0       	push   $0xf01299d8
f0113531:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113537:	50                   	push   %eax
f0113538:	e8 0a cc 00 00       	call   f0120147 <strcconcat>
f011353d:	83 c4 10             	add    $0x10,%esp
f0113540:	83 ec 0c             	sub    $0xc,%esp
f0113543:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113549:	50                   	push   %eax
f011354a:	e8 ac e9 fe ff       	call   f0101efb <execute_command>
f011354f:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f0113552:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113558:	bb 95 a1 12 f0       	mov    $0xf012a195,%ebx
f011355d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113562:	89 c7                	mov    %eax,%edi
f0113564:	89 de                	mov    %ebx,%esi
f0113566:	89 d1                	mov    %edx,%ecx
f0113568:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011356a:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113570:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113575:	b0 00                	mov    $0x0,%al
f0113577:	89 d7                	mov    %edx,%edi
f0113579:	f3 aa                	rep stos %al,%es:(%edi)
f011357b:	83 ec 0c             	sub    $0xc,%esp
f011357e:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113584:	50                   	push   %eax
f0113585:	e8 71 e9 fe ff       	call   f0101efb <execute_command>
f011358a:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f011358d:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113593:	bb f9 a1 12 f0       	mov    $0xf012a1f9,%ebx
f0113598:	ba 0f 00 00 00       	mov    $0xf,%edx
f011359d:	89 c7                	mov    %eax,%edi
f011359f:	89 de                	mov    %ebx,%esi
f01135a1:	89 d1                	mov    %edx,%ecx
f01135a3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01135a5:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01135ab:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135b0:	b0 00                	mov    $0x0,%al
f01135b2:	89 d7                	mov    %edx,%edi
f01135b4:	f3 aa                	rep stos %al,%es:(%edi)
f01135b6:	83 ec 0c             	sub    $0xc,%esp
f01135b9:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01135bf:	50                   	push   %eax
f01135c0:	e8 36 e9 fe ff       	call   f0101efb <execute_command>
f01135c5:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f01135c8:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01135ce:	bb 5d a2 12 f0       	mov    $0xf012a25d,%ebx
f01135d3:	ba 0f 00 00 00       	mov    $0xf,%edx
f01135d8:	89 c7                	mov    %eax,%edi
f01135da:	89 de                	mov    %ebx,%esi
f01135dc:	89 d1                	mov    %edx,%ecx
f01135de:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01135e0:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01135e6:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135eb:	b0 00                	mov    $0x0,%al
f01135ed:	89 d7                	mov    %edx,%edi
f01135ef:	f3 aa                	rep stos %al,%es:(%edi)
f01135f1:	83 ec 0c             	sub    $0xc,%esp
f01135f4:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01135fa:	50                   	push   %eax
f01135fb:	e8 fb e8 fe ff       	call   f0101efb <execute_command>
f0113600:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f0113603:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f011360a:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f0113611:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0113618:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f011361f:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0113626:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f011362d:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0113634:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f011363b:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f0113642:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0113649:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f0113650:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0113657:	8b 45 90             	mov    -0x70(%ebp),%eax
f011365a:	8a 00                	mov    (%eax),%al
f011365c:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113662:	e8 47 b2 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0113667:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f011366a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011366d:	89 d0                	mov    %edx,%eax
f011366f:	01 c0                	add    %eax,%eax
f0113671:	01 d0                	add    %edx,%eax
f0113673:	01 c0                	add    %eax,%eax
f0113675:	50                   	push   %eax
f0113676:	68 00 00 40 00       	push   $0x400000
f011367b:	68 00 00 20 00       	push   $0x200000
f0113680:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113683:	e8 de 73 ff ff       	call   f010aa66 <copy_paste_chunk>
f0113688:	83 c4 10             	add    $0x10,%esp
f011368b:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011368e:	e8 1b b2 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0113693:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113696:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f011369d:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01136a1:	75 08                	jne    f01136ab <test_copy_paste_chunk+0x929>
f01136a3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01136a6:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01136a9:	74 2b                	je     f01136d6 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01136ab:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01136ae:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01136b1:	83 ec 0c             	sub    $0xc,%esp
f01136b4:	50                   	push   %eax
f01136b5:	ff 75 80             	pushl  -0x80(%ebp)
f01136b8:	68 e4 99 12 f0       	push   $0xf01299e4
f01136bd:	68 3f 03 00 00       	push   $0x33f
f01136c2:	68 42 91 12 f0       	push   $0xf0129142
f01136c7:	e8 0a ce fe ff       	call   f01004d6 <_warn>
f01136cc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01136cf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01136d6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01136da:	74 04                	je     f01136e0 <test_copy_paste_chunk+0x95e>
f01136dc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01136e0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f01136e7:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f01136ee:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01136f1:	83 ec 08             	sub    $0x8,%esp
f01136f4:	6a 01                	push   $0x1
f01136f6:	6a 07                	push   $0x7
f01136f8:	6a 07                	push   $0x7
f01136fa:	6a 07                	push   $0x7
f01136fc:	6a 07                	push   $0x7
f01136fe:	6a 01                	push   $0x1
f0113700:	68 00 20 00 00       	push   $0x2000
f0113705:	68 00 00 40 00       	push   $0x400000
f011370a:	68 00 00 20 00       	push   $0x200000
f011370f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113712:	e8 bf 32 00 00       	call   f01169d6 <CCP>
f0113717:	83 c4 30             	add    $0x30,%esp
f011371a:	83 f8 01             	cmp    $0x1,%eax
f011371d:	74 2b                	je     f011374a <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f011371f:	83 ec 04             	sub    $0x4,%esp
f0113722:	68 38 9a 12 f0       	push   $0xf0129a38
f0113727:	68 48 03 00 00       	push   $0x348
f011372c:	68 42 91 12 f0       	push   $0xf0129142
f0113731:	e8 a0 cd fe ff       	call   f01004d6 <_warn>
f0113736:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113739:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f0113740:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113747:	00 00 00 
		}
		if (correct) eval += 5 ;
f011374a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011374e:	74 04                	je     f0113754 <test_copy_paste_chunk+0x9d2>
f0113750:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113754:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f011375b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011375e:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f0113761:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113764:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113767:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011376a:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f011376d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113770:	8a 00                	mov    (%eax),%al
f0113772:	3c 61                	cmp    $0x61,%al
f0113774:	75 69                	jne    f01137df <test_copy_paste_chunk+0xa5d>
f0113776:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113779:	8a 00                	mov    (%eax),%al
f011377b:	3c 61                	cmp    $0x61,%al
f011377d:	75 60                	jne    f01137df <test_copy_paste_chunk+0xa5d>
f011377f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113782:	8a 00                	mov    (%eax),%al
f0113784:	3c 79                	cmp    $0x79,%al
f0113786:	75 57                	jne    f01137df <test_copy_paste_chunk+0xa5d>
f0113788:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011378b:	8a 00                	mov    (%eax),%al
f011378d:	3c 62                	cmp    $0x62,%al
f011378f:	75 4e                	jne    f01137df <test_copy_paste_chunk+0xa5d>
f0113791:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113794:	8a 00                	mov    (%eax),%al
f0113796:	3c 63                	cmp    $0x63,%al
f0113798:	75 45                	jne    f01137df <test_copy_paste_chunk+0xa5d>
f011379a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011379d:	8a 00                	mov    (%eax),%al
f011379f:	3c 7a                	cmp    $0x7a,%al
f01137a1:	75 3c                	jne    f01137df <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f01137a3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01137a6:	8a 00                	mov    (%eax),%al
f01137a8:	3c 77                	cmp    $0x77,%al
f01137aa:	75 33                	jne    f01137df <test_copy_paste_chunk+0xa5d>
f01137ac:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01137af:	8a 00                	mov    (%eax),%al
f01137b1:	3c 64                	cmp    $0x64,%al
f01137b3:	75 2a                	jne    f01137df <test_copy_paste_chunk+0xa5d>
f01137b5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01137b8:	8a 00                	mov    (%eax),%al
f01137ba:	3c 65                	cmp    $0x65,%al
f01137bc:	75 21                	jne    f01137df <test_copy_paste_chunk+0xa5d>
f01137be:	8b 45 98             	mov    -0x68(%ebp),%eax
f01137c1:	8a 00                	mov    (%eax),%al
f01137c3:	3c 65                	cmp    $0x65,%al
f01137c5:	75 18                	jne    f01137df <test_copy_paste_chunk+0xa5d>
f01137c7:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01137ca:	8a 00                	mov    (%eax),%al
f01137cc:	3c 66                	cmp    $0x66,%al
f01137ce:	75 0f                	jne    f01137df <test_copy_paste_chunk+0xa5d>
f01137d0:	8b 45 90             	mov    -0x70(%ebp),%eax
f01137d3:	8a 10                	mov    (%eax),%dl
f01137d5:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01137db:	38 c2                	cmp    %al,%dl
f01137dd:	74 21                	je     f0113800 <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01137df:	83 ec 04             	sub    $0x4,%esp
f01137e2:	68 38 99 12 f0       	push   $0xf0129938
f01137e7:	68 56 03 00 00       	push   $0x356
f01137ec:	68 42 91 12 f0       	push   $0xf0129142
f01137f1:	e8 e0 cc fe ff       	call   f01004d6 <_warn>
f01137f6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01137f9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113800:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113804:	74 04                	je     f011380a <test_copy_paste_chunk+0xa88>
f0113806:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011380a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0113811:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113814:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113817:	e8 92 b0 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011381c:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f011381f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113822:	89 c2                	mov    %eax,%edx
f0113824:	01 d2                	add    %edx,%edx
f0113826:	01 d0                	add    %edx,%eax
f0113828:	50                   	push   %eax
f0113829:	68 00 08 20 00       	push   $0x200800
f011382e:	68 00 08 40 00       	push   $0x400800
f0113833:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113836:	e8 2b 72 ff ff       	call   f010aa66 <copy_paste_chunk>
f011383b:	83 c4 10             	add    $0x10,%esp
f011383e:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113841:	e8 68 b0 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0113846:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113849:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f011384d:	75 08                	jne    f0113857 <test_copy_paste_chunk+0xad5>
f011384f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113852:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113855:	74 2b                	je     f0113882 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113857:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011385a:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011385d:	83 ec 0c             	sub    $0xc,%esp
f0113860:	50                   	push   %eax
f0113861:	ff 75 80             	pushl  -0x80(%ebp)
f0113864:	68 e4 99 12 f0       	push   $0xf01299e4
f0113869:	68 66 03 00 00       	push   $0x366
f011386e:	68 42 91 12 f0       	push   $0xf0129142
f0113873:	e8 5e cc fe ff       	call   f01004d6 <_warn>
f0113878:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011387b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113882:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113886:	74 04                	je     f011388c <test_copy_paste_chunk+0xb0a>
f0113888:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011388c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113893:	83 ec 08             	sub    $0x8,%esp
f0113896:	6a 01                	push   $0x1
f0113898:	6a 07                	push   $0x7
f011389a:	6a 07                	push   $0x7
f011389c:	6a 07                	push   $0x7
f011389e:	6a 07                	push   $0x7
f01138a0:	6a 01                	push   $0x1
f01138a2:	68 00 20 00 00       	push   $0x2000
f01138a7:	68 00 00 20 00       	push   $0x200000
f01138ac:	68 00 00 40 00       	push   $0x400000
f01138b1:	ff 75 d4             	pushl  -0x2c(%ebp)
f01138b4:	e8 1d 31 00 00       	call   f01169d6 <CCP>
f01138b9:	83 c4 30             	add    $0x30,%esp
f01138bc:	83 f8 01             	cmp    $0x1,%eax
f01138bf:	74 21                	je     f01138e2 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01138c1:	83 ec 04             	sub    $0x4,%esp
f01138c4:	68 84 9a 12 f0       	push   $0xf0129a84
f01138c9:	68 6e 03 00 00       	push   $0x36e
f01138ce:	68 42 91 12 f0       	push   $0xf0129142
f01138d3:	e8 fe cb fe ff       	call   f01004d6 <_warn>
f01138d8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01138db:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01138e2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01138e6:	74 04                	je     f01138ec <test_copy_paste_chunk+0xb6a>
f01138e8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01138ec:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f01138f3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01138f6:	8a 00                	mov    (%eax),%al
f01138f8:	3c 61                	cmp    $0x61,%al
f01138fa:	75 69                	jne    f0113965 <test_copy_paste_chunk+0xbe3>
f01138fc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01138ff:	8a 00                	mov    (%eax),%al
f0113901:	3c 61                	cmp    $0x61,%al
f0113903:	75 60                	jne    f0113965 <test_copy_paste_chunk+0xbe3>
f0113905:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113908:	8a 00                	mov    (%eax),%al
f011390a:	3c 79                	cmp    $0x79,%al
f011390c:	75 57                	jne    f0113965 <test_copy_paste_chunk+0xbe3>
f011390e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113911:	8a 00                	mov    (%eax),%al
f0113913:	3c 62                	cmp    $0x62,%al
f0113915:	75 4e                	jne    f0113965 <test_copy_paste_chunk+0xbe3>
f0113917:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011391a:	8a 00                	mov    (%eax),%al
f011391c:	3c 7a                	cmp    $0x7a,%al
f011391e:	75 45                	jne    f0113965 <test_copy_paste_chunk+0xbe3>
f0113920:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113923:	8a 00                	mov    (%eax),%al
f0113925:	3c 7a                	cmp    $0x7a,%al
f0113927:	75 3c                	jne    f0113965 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113929:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011392c:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f011392e:	3c 64                	cmp    $0x64,%al
f0113930:	75 33                	jne    f0113965 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113932:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113935:	8a 00                	mov    (%eax),%al
f0113937:	3c 64                	cmp    $0x64,%al
f0113939:	75 2a                	jne    f0113965 <test_copy_paste_chunk+0xbe3>
f011393b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011393e:	8a 00                	mov    (%eax),%al
f0113940:	3c 65                	cmp    $0x65,%al
f0113942:	75 21                	jne    f0113965 <test_copy_paste_chunk+0xbe3>
f0113944:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113947:	8a 00                	mov    (%eax),%al
f0113949:	3c 78                	cmp    $0x78,%al
f011394b:	75 18                	jne    f0113965 <test_copy_paste_chunk+0xbe3>
f011394d:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113950:	8a 00                	mov    (%eax),%al
f0113952:	3c 66                	cmp    $0x66,%al
f0113954:	75 0f                	jne    f0113965 <test_copy_paste_chunk+0xbe3>
f0113956:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113959:	8a 10                	mov    (%eax),%dl
f011395b:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113961:	38 c2                	cmp    %al,%dl
f0113963:	74 21                	je     f0113986 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113965:	83 ec 04             	sub    $0x4,%esp
f0113968:	68 38 99 12 f0       	push   $0xf0129938
f011396d:	68 77 03 00 00       	push   $0x377
f0113972:	68 42 91 12 f0       	push   $0xf0129142
f0113977:	e8 5a cb fe ff       	call   f01004d6 <_warn>
f011397c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011397f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113986:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011398a:	74 04                	je     f0113990 <test_copy_paste_chunk+0xc0e>
f011398c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113990:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0113997:	83 ec 0c             	sub    $0xc,%esp
f011399a:	68 cf 9a 12 f0       	push   $0xf0129acf
f011399f:	e8 e7 d5 fe ff       	call   f0100f8b <cprintf>
f01139a4:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f01139a7:	83 ec 0c             	sub    $0xc,%esp
f01139aa:	68 e0 9a 12 f0       	push   $0xf0129ae0
f01139af:	e8 d7 d5 fe ff       	call   f0100f8b <cprintf>
f01139b4:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f01139b7:	83 ec 04             	sub    $0x4,%esp
f01139ba:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01139c0:	50                   	push   %eax
f01139c1:	68 14 9b 12 f0       	push   $0xf0129b14
f01139c6:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01139cc:	50                   	push   %eax
f01139cd:	e8 75 c7 00 00       	call   f0120147 <strcconcat>
f01139d2:	83 c4 10             	add    $0x10,%esp
f01139d5:	83 ec 0c             	sub    $0xc,%esp
f01139d8:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01139de:	50                   	push   %eax
f01139df:	e8 17 e5 fe ff       	call   f0101efb <execute_command>
f01139e4:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f01139e7:	83 ec 04             	sub    $0x4,%esp
f01139ea:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01139f0:	50                   	push   %eax
f01139f1:	68 1e 9b 12 f0       	push   $0xf0129b1e
f01139f6:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01139fc:	50                   	push   %eax
f01139fd:	e8 45 c7 00 00       	call   f0120147 <strcconcat>
f0113a02:	83 c4 10             	add    $0x10,%esp
f0113a05:	83 ec 0c             	sub    $0xc,%esp
f0113a08:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a0e:	50                   	push   %eax
f0113a0f:	e8 e7 e4 fe ff       	call   f0101efb <execute_command>
f0113a14:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113a17:	83 ec 04             	sub    $0x4,%esp
f0113a1a:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a20:	50                   	push   %eax
f0113a21:	68 28 9b 12 f0       	push   $0xf0129b28
f0113a26:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113a2c:	50                   	push   %eax
f0113a2d:	e8 15 c7 00 00       	call   f0120147 <strcconcat>
f0113a32:	83 c4 10             	add    $0x10,%esp
f0113a35:	83 ec 0c             	sub    $0xc,%esp
f0113a38:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a3e:	50                   	push   %eax
f0113a3f:	e8 b7 e4 fe ff       	call   f0101efb <execute_command>
f0113a44:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113a47:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113a4d:	bb c1 a2 12 f0       	mov    $0xf012a2c1,%ebx
f0113a52:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113a57:	89 c7                	mov    %eax,%edi
f0113a59:	89 de                	mov    %ebx,%esi
f0113a5b:	89 d1                	mov    %edx,%ecx
f0113a5d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113a5f:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113a65:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113a6a:	b0 00                	mov    $0x0,%al
f0113a6c:	89 d7                	mov    %edx,%edi
f0113a6e:	f3 aa                	rep stos %al,%es:(%edi)
f0113a70:	83 ec 0c             	sub    $0xc,%esp
f0113a73:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113a79:	50                   	push   %eax
f0113a7a:	e8 7c e4 fe ff       	call   f0101efb <execute_command>
f0113a7f:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0113a82:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113a88:	bb 25 a3 12 f0       	mov    $0xf012a325,%ebx
f0113a8d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113a92:	89 c7                	mov    %eax,%edi
f0113a94:	89 de                	mov    %ebx,%esi
f0113a96:	89 d1                	mov    %edx,%ecx
f0113a98:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113a9a:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113aa0:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113aa5:	b0 00                	mov    $0x0,%al
f0113aa7:	89 d7                	mov    %edx,%edi
f0113aa9:	f3 aa                	rep stos %al,%es:(%edi)
f0113aab:	83 ec 0c             	sub    $0xc,%esp
f0113aae:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113ab4:	50                   	push   %eax
f0113ab5:	e8 41 e4 fe ff       	call   f0101efb <execute_command>
f0113aba:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0113abd:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113ac3:	bb 89 a3 12 f0       	mov    $0xf012a389,%ebx
f0113ac8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113acd:	89 c7                	mov    %eax,%edi
f0113acf:	89 de                	mov    %ebx,%esi
f0113ad1:	89 d1                	mov    %edx,%ecx
f0113ad3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113ad5:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113adb:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113ae0:	b0 00                	mov    $0x0,%al
f0113ae2:	89 d7                	mov    %edx,%edi
f0113ae4:	f3 aa                	rep stos %al,%es:(%edi)
f0113ae6:	83 ec 0c             	sub    $0xc,%esp
f0113ae9:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113aef:	50                   	push   %eax
f0113af0:	e8 06 e4 fe ff       	call   f0101efb <execute_command>
f0113af5:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113af8:	e8 b1 ad ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0113afd:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f0113b00:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113b03:	89 d0                	mov    %edx,%eax
f0113b05:	01 c0                	add    %eax,%eax
f0113b07:	01 d0                	add    %edx,%eax
f0113b09:	c1 e0 02             	shl    $0x2,%eax
f0113b0c:	50                   	push   %eax
f0113b0d:	68 00 00 90 00       	push   $0x900000
f0113b12:	68 00 00 80 00       	push   $0x800000
f0113b17:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113b1a:	e8 47 6f ff ff       	call   f010aa66 <copy_paste_chunk>
f0113b1f:	83 c4 10             	add    $0x10,%esp
f0113b22:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113b28:	e8 81 ad ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0113b2d:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113b30:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113b37:	75 0b                	jne    f0113b44 <test_copy_paste_chunk+0xdc2>
f0113b39:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113b3c:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113b3f:	83 f8 03             	cmp    $0x3,%eax
f0113b42:	74 2e                	je     f0113b72 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113b44:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113b47:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113b4a:	83 ec 0c             	sub    $0xc,%esp
f0113b4d:	50                   	push   %eax
f0113b4e:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113b54:	68 e4 99 12 f0       	push   $0xf01299e4
f0113b59:	68 95 03 00 00       	push   $0x395
f0113b5e:	68 42 91 12 f0       	push   $0xf0129142
f0113b63:	e8 6e c9 fe ff       	call   f01004d6 <_warn>
f0113b68:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113b6b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113b72:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113b76:	74 04                	je     f0113b7c <test_copy_paste_chunk+0xdfa>
f0113b78:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113b7c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0113b83:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113b8a:	83 ec 08             	sub    $0x8,%esp
f0113b8d:	6a 01                	push   $0x1
f0113b8f:	6a 07                	push   $0x7
f0113b91:	6a 07                	push   $0x7
f0113b93:	6a 07                	push   $0x7
f0113b95:	6a 07                	push   $0x7
f0113b97:	6a 01                	push   $0x1
f0113b99:	68 00 30 00 00       	push   $0x3000
f0113b9e:	68 00 00 90 00       	push   $0x900000
f0113ba3:	68 00 00 80 00       	push   $0x800000
f0113ba8:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113bab:	e8 26 2e 00 00       	call   f01169d6 <CCP>
f0113bb0:	83 c4 30             	add    $0x30,%esp
f0113bb3:	83 f8 01             	cmp    $0x1,%eax
f0113bb6:	74 28                	je     f0113be0 <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113bb8:	83 ec 04             	sub    $0x4,%esp
f0113bbb:	68 84 9a 12 f0       	push   $0xf0129a84
f0113bc0:	68 9e 03 00 00       	push   $0x39e
f0113bc5:	68 42 91 12 f0       	push   $0xf0129142
f0113bca:	e8 07 c9 fe ff       	call   f01004d6 <_warn>
f0113bcf:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113bd2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113bd9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0113be0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113be4:	74 04                	je     f0113bea <test_copy_paste_chunk+0xe68>
f0113be6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113bea:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113bf1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113bf5:	0f 84 9e 00 00 00    	je     f0113c99 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0113bfb:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0113c02:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0113c09:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0113c10:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0113c17:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0113c1e:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0113c25:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113c28:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0113c2b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113c2e:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0113c31:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c34:	8a 00                	mov    (%eax),%al
f0113c36:	3c 61                	cmp    $0x61,%al
f0113c38:	75 2d                	jne    f0113c67 <test_copy_paste_chunk+0xee5>
f0113c3a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113c3d:	8a 00                	mov    (%eax),%al
f0113c3f:	3c 61                	cmp    $0x61,%al
f0113c41:	75 24                	jne    f0113c67 <test_copy_paste_chunk+0xee5>
f0113c43:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113c46:	8a 00                	mov    (%eax),%al
f0113c48:	3c 79                	cmp    $0x79,%al
f0113c4a:	75 1b                	jne    f0113c67 <test_copy_paste_chunk+0xee5>
f0113c4c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113c4f:	8a 00                	mov    (%eax),%al
f0113c51:	3c 62                	cmp    $0x62,%al
f0113c53:	75 12                	jne    f0113c67 <test_copy_paste_chunk+0xee5>
f0113c55:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113c58:	8a 00                	mov    (%eax),%al
f0113c5a:	3c 63                	cmp    $0x63,%al
f0113c5c:	75 09                	jne    f0113c67 <test_copy_paste_chunk+0xee5>
f0113c5e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113c61:	8a 00                	mov    (%eax),%al
f0113c63:	3c 7a                	cmp    $0x7a,%al
f0113c65:	74 21                	je     f0113c88 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113c67:	83 ec 04             	sub    $0x4,%esp
f0113c6a:	68 38 99 12 f0       	push   $0xf0129938
f0113c6f:	68 b0 03 00 00       	push   $0x3b0
f0113c74:	68 42 91 12 f0       	push   $0xf0129142
f0113c79:	e8 58 c8 fe ff       	call   f01004d6 <_warn>
f0113c7e:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113c81:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0113c88:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c8c:	74 04                	je     f0113c92 <test_copy_paste_chunk+0xf10>
f0113c8e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0113c92:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113c99:	e8 10 ac ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0113c9e:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0113ca1:	6a 00                	push   $0x0
f0113ca3:	6a 02                	push   $0x2
f0113ca5:	68 00 10 90 00       	push   $0x901000
f0113caa:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113cad:	e8 b1 2b 00 00       	call   f0116863 <SB>
f0113cb2:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0113cb5:	6a 00                	push   $0x0
f0113cb7:	6a 02                	push   $0x2
f0113cb9:	68 00 20 90 00       	push   $0x902000
f0113cbe:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113cc1:	e8 9d 2b 00 00       	call   f0116863 <SB>
f0113cc6:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0113cc9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113ccc:	c1 e0 03             	shl    $0x3,%eax
f0113ccf:	50                   	push   %eax
f0113cd0:	68 00 f0 bf 00       	push   $0xbff000
f0113cd5:	68 00 10 90 00       	push   $0x901000
f0113cda:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113cdd:	e8 84 6d ff ff       	call   f010aa66 <copy_paste_chunk>
f0113ce2:	83 c4 10             	add    $0x10,%esp
f0113ce5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113ceb:	e8 be ab ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0113cf0:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113cf3:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113cfa:	75 0b                	jne    f0113d07 <test_copy_paste_chunk+0xf85>
f0113cfc:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113cff:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113d02:	83 f8 03             	cmp    $0x3,%eax
f0113d05:	74 2e                	je     f0113d35 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113d07:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113d0a:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113d0d:	83 ec 0c             	sub    $0xc,%esp
f0113d10:	50                   	push   %eax
f0113d11:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113d17:	68 e4 99 12 f0       	push   $0xf01299e4
f0113d1c:	68 c0 03 00 00       	push   $0x3c0
f0113d21:	68 42 91 12 f0       	push   $0xf0129142
f0113d26:	e8 ab c7 fe ff       	call   f01004d6 <_warn>
f0113d2b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113d2e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113d35:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113d39:	74 04                	je     f0113d3f <test_copy_paste_chunk+0xfbd>
f0113d3b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113d3f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0113d46:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0113d4d:	83 ec 08             	sub    $0x8,%esp
f0113d50:	6a 01                	push   $0x1
f0113d52:	6a 07                	push   $0x7
f0113d54:	6a 03                	push   $0x3
f0113d56:	6a 07                	push   $0x7
f0113d58:	6a 03                	push   $0x3
f0113d5a:	6a 01                	push   $0x1
f0113d5c:	68 00 20 00 00       	push   $0x2000
f0113d61:	68 00 f0 bf 00       	push   $0xbff000
f0113d66:	68 00 10 90 00       	push   $0x901000
f0113d6b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113d6e:	e8 63 2c 00 00       	call   f01169d6 <CCP>
f0113d73:	83 c4 30             	add    $0x30,%esp
f0113d76:	83 f8 01             	cmp    $0x1,%eax
f0113d79:	74 28                	je     f0113da3 <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113d7b:	83 ec 04             	sub    $0x4,%esp
f0113d7e:	68 84 9a 12 f0       	push   $0xf0129a84
f0113d83:	68 c9 03 00 00       	push   $0x3c9
f0113d88:	68 42 91 12 f0       	push   $0xf0129142
f0113d8d:	e8 44 c7 fe ff       	call   f01004d6 <_warn>
f0113d92:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113d95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113d9c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0113da3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113da7:	74 04                	je     f0113dad <test_copy_paste_chunk+0x102b>
f0113da9:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113dad:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113db4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113db8:	74 72                	je     f0113e2c <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0113dba:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0113dc1:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0113dc8:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0113dcf:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0113dd6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113dd9:	8a 00                	mov    (%eax),%al
f0113ddb:	3c 62                	cmp    $0x62,%al
f0113ddd:	75 1b                	jne    f0113dfa <test_copy_paste_chunk+0x1078>
f0113ddf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113de2:	8a 00                	mov    (%eax),%al
f0113de4:	3c 62                	cmp    $0x62,%al
f0113de6:	75 12                	jne    f0113dfa <test_copy_paste_chunk+0x1078>
f0113de8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113deb:	8a 00                	mov    (%eax),%al
f0113ded:	3c 7a                	cmp    $0x7a,%al
f0113def:	75 09                	jne    f0113dfa <test_copy_paste_chunk+0x1078>
f0113df1:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113df4:	8a 00                	mov    (%eax),%al
f0113df6:	3c 7a                	cmp    $0x7a,%al
f0113df8:	74 21                	je     f0113e1b <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113dfa:	83 ec 04             	sub    $0x4,%esp
f0113dfd:	68 38 99 12 f0       	push   $0xf0129938
f0113e02:	68 d5 03 00 00       	push   $0x3d5
f0113e07:	68 42 91 12 f0       	push   $0xf0129142
f0113e0c:	e8 c5 c6 fe ff       	call   f01004d6 <_warn>
f0113e11:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113e14:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0113e1b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113e1f:	74 04                	je     f0113e25 <test_copy_paste_chunk+0x10a3>
f0113e21:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113e25:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113e2c:	83 ec 0c             	sub    $0xc,%esp
f0113e2f:	68 32 9b 12 f0       	push   $0xf0129b32
f0113e34:	e8 52 d1 fe ff       	call   f0100f8b <cprintf>
f0113e39:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0113e3c:	83 ec 08             	sub    $0x8,%esp
f0113e3f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0113e42:	68 44 9b 12 f0       	push   $0xf0129b44
f0113e47:	e8 3f d1 fe ff       	call   f0100f8b <cprintf>
f0113e4c:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0113e4f:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0113e53:	75 10                	jne    f0113e65 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0113e55:	83 ec 0c             	sub    $0xc,%esp
f0113e58:	68 78 9b 12 f0       	push   $0xf0129b78
f0113e5d:	e8 29 d1 fe ff       	call   f0100f8b <cprintf>
f0113e62:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113e65:	a1 c4 0d 6c f0       	mov    0xf06c0dc4,%eax
f0113e6a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0113e6d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113e70:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113e73:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113e78:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113e7b:	5b                   	pop    %ebx
f0113e7c:	5e                   	pop    %esi
f0113e7d:	5f                   	pop    %edi
f0113e7e:	5d                   	pop    %ebp
f0113e7f:	c3                   	ret    

f0113e80 <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0113e80:	55                   	push   %ebp
f0113e81:	89 e5                	mov    %esp,%ebp
f0113e83:	57                   	push   %edi
f0113e84:	56                   	push   %esi
f0113e85:	53                   	push   %ebx
f0113e86:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113e8c:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113e92:	bb 44 98 12 f0       	mov    $0xf0129844,%ebx
f0113e97:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113e9c:	89 c7                	mov    %eax,%edi
f0113e9e:	89 de                	mov    %ebx,%esi
f0113ea0:	89 d1                	mov    %edx,%ecx
f0113ea2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113ea4:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0113eaa:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113eaf:	b0 00                	mov    $0x0,%al
f0113eb1:	89 d7                	mov    %edx,%edi
f0113eb3:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113eb5:	6a 00                	push   $0x0
f0113eb7:	6a 0a                	push   $0xa
f0113eb9:	6a 14                	push   $0x14
f0113ebb:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113ec1:	50                   	push   %eax
f0113ec2:	e8 46 70 ff ff       	call   f010af0d <env_create>
f0113ec7:	83 c4 10             	add    $0x10,%esp
f0113eca:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113ecd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113ed0:	8b 40 64             	mov    0x64(%eax),%eax
f0113ed3:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0113ed6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113ed9:	8b 40 68             	mov    0x68(%eax),%eax
f0113edc:	89 45 80             	mov    %eax,-0x80(%ebp)
f0113edf:	8b 45 80             	mov    -0x80(%ebp),%eax
f0113ee2:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0113ee5:	83 ec 0c             	sub    $0xc,%esp
f0113ee8:	ff 75 cc             	pushl  -0x34(%ebp)
f0113eeb:	e8 b2 2a 00 00       	call   f01169a2 <ClearUserSpace>
f0113ef0:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0113ef3:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0113efa:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0113f01:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0113f08:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0113f0c:	83 ec 0c             	sub    $0xc,%esp
f0113f0f:	68 f0 a3 12 f0       	push   $0xf012a3f0
f0113f14:	e8 72 d0 fe ff       	call   f0100f8b <cprintf>
f0113f19:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0113f1c:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0113f23:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0113f2a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113f2d:	8a 00                	mov    (%eax),%al
f0113f2f:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0113f35:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113f38:	8a 00                	mov    (%eax),%al
f0113f3a:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113f40:	e8 69 a9 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0113f45:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0113f48:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113f4b:	89 d0                	mov    %edx,%eax
f0113f4d:	01 c0                	add    %eax,%eax
f0113f4f:	01 d0                	add    %edx,%eax
f0113f51:	01 c0                	add    %eax,%eax
f0113f53:	83 ec 0c             	sub    $0xc,%esp
f0113f56:	6a 02                	push   $0x2
f0113f58:	50                   	push   %eax
f0113f59:	68 00 40 10 f0       	push   $0xf0104000
f0113f5e:	68 00 00 10 f0       	push   $0xf0100000
f0113f63:	ff 75 cc             	pushl  -0x34(%ebp)
f0113f66:	e8 15 6b ff ff       	call   f010aa80 <share_chunk>
f0113f6b:	83 c4 20             	add    $0x20,%esp
f0113f6e:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113f71:	e8 38 a9 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0113f76:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0113f79:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0113f7d:	75 08                	jne    f0113f87 <test_share_chunk+0x107>
f0113f7f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113f82:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0113f85:	74 28                	je     f0113faf <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0113f87:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113f8a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113f8d:	83 ec 0c             	sub    $0xc,%esp
f0113f90:	50                   	push   %eax
f0113f91:	ff 75 b0             	pushl  -0x50(%ebp)
f0113f94:	68 1c a4 12 f0       	push   $0xf012a41c
f0113f99:	68 11 04 00 00       	push   $0x411
f0113f9e:	68 42 91 12 f0       	push   $0xf0129142
f0113fa3:	e8 2e c5 fe ff       	call   f01004d6 <_warn>
f0113fa8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113fab:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113faf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113fb3:	74 04                	je     f0113fb9 <test_share_chunk+0x139>
f0113fb5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113fb9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0113fbd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113fc0:	c1 e0 03             	shl    $0x3,%eax
f0113fc3:	83 ec 08             	sub    $0x8,%esp
f0113fc6:	68 fd 00 00 00       	push   $0xfd
f0113fcb:	6a 07                	push   $0x7
f0113fcd:	6a 03                	push   $0x3
f0113fcf:	6a 07                	push   $0x7
f0113fd1:	6a 03                	push   $0x3
f0113fd3:	6a 01                	push   $0x1
f0113fd5:	50                   	push   %eax
f0113fd6:	68 00 40 10 f0       	push   $0xf0104000
f0113fdb:	68 00 00 10 f0       	push   $0xf0100000
f0113fe0:	ff 75 cc             	pushl  -0x34(%ebp)
f0113fe3:	e8 ee 29 00 00       	call   f01169d6 <CCP>
f0113fe8:	83 c4 30             	add    $0x30,%esp
f0113feb:	85 c0                	test   %eax,%eax
f0113fed:	75 1e                	jne    f011400d <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113fef:	83 ec 04             	sub    $0x4,%esp
f0113ff2:	68 78 a4 12 f0       	push   $0xf012a478
f0113ff7:	68 19 04 00 00       	push   $0x419
f0113ffc:	68 42 91 12 f0       	push   $0xf0129142
f0114001:	e8 d0 c4 fe ff       	call   f01004d6 <_warn>
f0114006:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114009:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011400d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114011:	74 04                	je     f0114017 <test_share_chunk+0x197>
f0114013:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0114017:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011401a:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f011401d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114020:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0114023:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114026:	8a 00                	mov    (%eax),%al
f0114028:	3c 41                	cmp    $0x41,%al
f011402a:	75 09                	jne    f0114035 <test_share_chunk+0x1b5>
f011402c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011402f:	8a 00                	mov    (%eax),%al
f0114031:	3c 42                	cmp    $0x42,%al
f0114033:	74 1e                	je     f0114053 <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114035:	83 ec 04             	sub    $0x4,%esp
f0114038:	68 c0 a4 12 f0       	push   $0xf012a4c0
f011403d:	68 23 04 00 00       	push   $0x423
f0114042:	68 42 91 12 f0       	push   $0xf0129142
f0114047:	e8 8a c4 fe ff       	call   f01004d6 <_warn>
f011404c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011404f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114053:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114057:	74 04                	je     f011405d <test_share_chunk+0x1dd>
f0114059:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011405d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0114061:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0114067:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011406a:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f011406c:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0114072:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114075:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0114077:	83 ec 0c             	sub    $0xc,%esp
f011407a:	68 f5 a4 12 f0       	push   $0xf012a4f5
f011407f:	e8 07 cf fe ff       	call   f0100f8b <cprintf>
f0114084:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0114087:	83 ec 0c             	sub    $0xc,%esp
f011408a:	68 04 a5 12 f0       	push   $0xf012a504
f011408f:	e8 f7 ce fe ff       	call   f0100f8b <cprintf>
f0114094:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114097:	e8 12 a8 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011409c:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f011409f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01140a2:	c1 e0 05             	shl    $0x5,%eax
f01140a5:	83 ec 0c             	sub    $0xc,%esp
f01140a8:	68 02 0e 00 00       	push   $0xe02
f01140ad:	50                   	push   %eax
f01140ae:	68 00 00 00 40       	push   $0x40000000
f01140b3:	68 00 00 00 f0       	push   $0xf0000000
f01140b8:	ff 75 cc             	pushl  -0x34(%ebp)
f01140bb:	e8 c0 69 ff ff       	call   f010aa80 <share_chunk>
f01140c0:	83 c4 20             	add    $0x20,%esp
f01140c3:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01140c6:	e8 e3 a7 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01140cb:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f01140ce:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f01140d2:	75 1f                	jne    f01140f3 <test_share_chunk+0x273>
f01140d4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01140d7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01140da:	89 c1                	mov    %eax,%ecx
f01140dc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01140df:	c1 e0 05             	shl    $0x5,%eax
f01140e2:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01140e5:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01140ec:	99                   	cltd   
f01140ed:	f7 fb                	idiv   %ebx
f01140ef:	39 c1                	cmp    %eax,%ecx
f01140f1:	74 28                	je     f011411b <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01140f3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01140f6:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01140f9:	83 ec 0c             	sub    $0xc,%esp
f01140fc:	50                   	push   %eax
f01140fd:	ff 75 a8             	pushl  -0x58(%ebp)
f0114100:	68 40 a5 12 f0       	push   $0xf012a540
f0114105:	68 3b 04 00 00       	push   $0x43b
f011410a:	68 42 91 12 f0       	push   $0xf0129142
f011410f:	e8 c2 c3 fe ff       	call   f01004d6 <_warn>
f0114114:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114117:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011411b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011411f:	74 04                	je     f0114125 <test_share_chunk+0x2a5>
f0114121:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114125:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114129:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114130:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114133:	c1 e0 05             	shl    $0x5,%eax
f0114136:	83 ec 08             	sub    $0x8,%esp
f0114139:	6a 02                	push   $0x2
f011413b:	6a 07                	push   $0x7
f011413d:	6a 03                	push   $0x3
f011413f:	68 07 0e 00 00       	push   $0xe07
f0114144:	68 03 0e 00 00       	push   $0xe03
f0114149:	6a ff                	push   $0xffffffff
f011414b:	50                   	push   %eax
f011414c:	68 00 00 00 40       	push   $0x40000000
f0114151:	68 00 00 00 f0       	push   $0xf0000000
f0114156:	ff 75 cc             	pushl  -0x34(%ebp)
f0114159:	e8 78 28 00 00       	call   f01169d6 <CCP>
f011415e:	83 c4 30             	add    $0x30,%esp
f0114161:	85 c0                	test   %eax,%eax
f0114163:	75 25                	jne    f011418a <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114165:	83 ec 04             	sub    $0x4,%esp
f0114168:	68 78 a4 12 f0       	push   $0xf012a478
f011416d:	68 44 04 00 00       	push   $0x444
f0114172:	68 42 91 12 f0       	push   $0xf0129142
f0114177:	e8 5a c3 fe ff       	call   f01004d6 <_warn>
f011417c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011417f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114183:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f011418a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011418d:	89 d0                	mov    %edx,%eax
f011418f:	01 c0                	add    %eax,%eax
f0114191:	01 d0                	add    %edx,%eax
f0114193:	c1 e0 02             	shl    $0x2,%eax
f0114196:	83 ec 08             	sub    $0x8,%esp
f0114199:	6a 02                	push   $0x2
f011419b:	6a 07                	push   $0x7
f011419d:	6a 03                	push   $0x3
f011419f:	68 07 0e 00 00       	push   $0xe07
f01141a4:	68 03 0e 00 00       	push   $0xe03
f01141a9:	6a 02                	push   $0x2
f01141ab:	50                   	push   %eax
f01141ac:	68 00 00 00 40       	push   $0x40000000
f01141b1:	68 00 00 00 f0       	push   $0xf0000000
f01141b6:	ff 75 cc             	pushl  -0x34(%ebp)
f01141b9:	e8 18 28 00 00       	call   f01169d6 <CCP>
f01141be:	83 c4 30             	add    $0x30,%esp
f01141c1:	85 c0                	test   %eax,%eax
f01141c3:	75 1e                	jne    f01141e3 <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01141c5:	83 ec 04             	sub    $0x4,%esp
f01141c8:	68 78 a4 12 f0       	push   $0xf012a478
f01141cd:	68 4b 04 00 00       	push   $0x44b
f01141d2:	68 42 91 12 f0       	push   $0xf0129142
f01141d7:	e8 fa c2 fe ff       	call   f01004d6 <_warn>
f01141dc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01141df:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01141e3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01141e7:	74 04                	je     f01141ed <test_share_chunk+0x36d>
f01141e9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01141ed:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f01141f1:	b8 b0 b7 b0 f0       	mov    $0xf0b0b7b0,%eax
f01141f6:	05 00 00 00 10       	add    $0x10000000,%eax
f01141fb:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01141fe:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0114201:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0114206:	83 ec 08             	sub    $0x8,%esp
f0114209:	6a 02                	push   $0x2
f011420b:	6a 07                	push   $0x7
f011420d:	6a 03                	push   $0x3
f011420f:	68 07 0e 00 00       	push   $0xe07
f0114214:	68 03 0e 00 00       	push   $0xe03
f0114219:	6a 02                	push   $0x2
f011421b:	50                   	push   %eax
f011421c:	68 00 00 0a 40       	push   $0x400a0000
f0114221:	68 00 00 0a f0       	push   $0xf00a0000
f0114226:	ff 75 cc             	pushl  -0x34(%ebp)
f0114229:	e8 a8 27 00 00       	call   f01169d6 <CCP>
f011422e:	83 c4 30             	add    $0x30,%esp
f0114231:	85 c0                	test   %eax,%eax
f0114233:	75 1e                	jne    f0114253 <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114235:	83 ec 04             	sub    $0x4,%esp
f0114238:	68 78 a4 12 f0       	push   $0xf012a478
f011423d:	68 55 04 00 00       	push   $0x455
f0114242:	68 42 91 12 f0       	push   $0xf0129142
f0114247:	e8 8a c2 fe ff       	call   f01004d6 <_warn>
f011424c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011424f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114253:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114257:	74 04                	je     f011425d <test_share_chunk+0x3dd>
f0114259:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011425d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114261:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114265:	0f 84 a4 00 00 00    	je     f011430f <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f011426b:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0114272:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114275:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0114278:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f011427f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114282:	8a 00                	mov    (%eax),%al
f0114284:	3c 41                	cmp    $0x41,%al
f0114286:	75 09                	jne    f0114291 <test_share_chunk+0x411>
f0114288:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011428b:	8a 00                	mov    (%eax),%al
f011428d:	3c 41                	cmp    $0x41,%al
f011428f:	74 1e                	je     f01142af <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114291:	83 ec 04             	sub    $0x4,%esp
f0114294:	68 c0 a4 12 f0       	push   $0xf012a4c0
f0114299:	68 62 04 00 00       	push   $0x462
f011429e:	68 42 91 12 f0       	push   $0xf0129142
f01142a3:	e8 2e c2 fe ff       	call   f01004d6 <_warn>
f01142a8:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01142ab:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01142af:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01142b3:	74 04                	je     f01142b9 <test_share_chunk+0x439>
f01142b5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01142b9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f01142bd:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f01142c4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01142c7:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f01142ca:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f01142d1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01142d4:	8a 00                	mov    (%eax),%al
f01142d6:	3c 43                	cmp    $0x43,%al
f01142d8:	75 09                	jne    f01142e3 <test_share_chunk+0x463>
f01142da:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01142dd:	8a 00                	mov    (%eax),%al
f01142df:	3c 43                	cmp    $0x43,%al
f01142e1:	74 1e                	je     f0114301 <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01142e3:	83 ec 04             	sub    $0x4,%esp
f01142e6:	68 c0 a4 12 f0       	push   $0xf012a4c0
f01142eb:	68 6d 04 00 00       	push   $0x46d
f01142f0:	68 42 91 12 f0       	push   $0xf0129142
f01142f5:	e8 dc c1 fe ff       	call   f01004d6 <_warn>
f01142fa:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01142fd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114301:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114305:	74 04                	je     f011430b <test_share_chunk+0x48b>
f0114307:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011430b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f011430f:	83 ec 0c             	sub    $0xc,%esp
f0114312:	68 cf 9a 12 f0       	push   $0xf0129acf
f0114317:	e8 6f cc fe ff       	call   f0100f8b <cprintf>
f011431c:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f011431f:	83 ec 0c             	sub    $0xc,%esp
f0114322:	68 90 a5 12 f0       	push   $0xf012a590
f0114327:	e8 5f cc fe ff       	call   f0100f8b <cprintf>
f011432c:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011432f:	e8 7a a5 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0114334:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f0114337:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011433a:	89 d0                	mov    %edx,%eax
f011433c:	c1 e0 03             	shl    $0x3,%eax
f011433f:	01 d0                	add    %edx,%eax
f0114341:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0114348:	01 d0                	add    %edx,%eax
f011434a:	c1 e0 03             	shl    $0x3,%eax
f011434d:	83 ec 0c             	sub    $0xc,%esp
f0114350:	6a 06                	push   $0x6
f0114352:	50                   	push   %eax
f0114353:	6a 00                	push   $0x0
f0114355:	68 00 00 00 40       	push   $0x40000000
f011435a:	ff 75 cc             	pushl  -0x34(%ebp)
f011435d:	e8 1e 67 ff ff       	call   f010aa80 <share_chunk>
f0114362:	83 c4 20             	add    $0x20,%esp
f0114365:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114368:	e8 41 a5 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011436d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114370:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0114374:	75 0b                	jne    f0114381 <test_share_chunk+0x501>
f0114376:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114379:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011437c:	83 f8 01             	cmp    $0x1,%eax
f011437f:	74 28                	je     f01143a9 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114381:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114384:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114387:	83 ec 0c             	sub    $0xc,%esp
f011438a:	50                   	push   %eax
f011438b:	ff 75 a0             	pushl  -0x60(%ebp)
f011438e:	68 40 a5 12 f0       	push   $0xf012a540
f0114393:	68 83 04 00 00       	push   $0x483
f0114398:	68 42 91 12 f0       	push   $0xf0129142
f011439d:	e8 34 c1 fe ff       	call   f01004d6 <_warn>
f01143a2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01143a5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01143a9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01143ad:	74 04                	je     f01143b3 <test_share_chunk+0x533>
f01143af:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01143b3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01143b7:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01143be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01143c1:	05 00 80 02 00       	add    $0x28000,%eax
f01143c6:	c1 e0 02             	shl    $0x2,%eax
f01143c9:	83 ec 08             	sub    $0x8,%esp
f01143cc:	6a 02                	push   $0x2
f01143ce:	6a 07                	push   $0x7
f01143d0:	6a 03                	push   $0x3
f01143d2:	6a 07                	push   $0x7
f01143d4:	6a 07                	push   $0x7
f01143d6:	6a ff                	push   $0xffffffff
f01143d8:	50                   	push   %eax
f01143d9:	6a 00                	push   $0x0
f01143db:	68 00 00 00 40       	push   $0x40000000
f01143e0:	ff 75 cc             	pushl  -0x34(%ebp)
f01143e3:	e8 ee 25 00 00       	call   f01169d6 <CCP>
f01143e8:	83 c4 30             	add    $0x30,%esp
f01143eb:	85 c0                	test   %eax,%eax
f01143ed:	75 25                	jne    f0114414 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01143ef:	83 ec 04             	sub    $0x4,%esp
f01143f2:	68 78 a4 12 f0       	push   $0xf012a478
f01143f7:	68 8c 04 00 00       	push   $0x48c
f01143fc:	68 42 91 12 f0       	push   $0xf0129142
f0114401:	e8 d0 c0 fe ff       	call   f01004d6 <_warn>
f0114406:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114409:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f011440d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114414:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114417:	89 d0                	mov    %edx,%eax
f0114419:	01 c0                	add    %eax,%eax
f011441b:	01 d0                	add    %edx,%eax
f011441d:	c1 e0 02             	shl    $0x2,%eax
f0114420:	83 ec 08             	sub    $0x8,%esp
f0114423:	6a 02                	push   $0x2
f0114425:	6a 07                	push   $0x7
f0114427:	6a 03                	push   $0x3
f0114429:	6a 07                	push   $0x7
f011442b:	6a 07                	push   $0x7
f011442d:	6a 03                	push   $0x3
f011442f:	50                   	push   %eax
f0114430:	6a 00                	push   $0x0
f0114432:	68 00 00 00 40       	push   $0x40000000
f0114437:	ff 75 cc             	pushl  -0x34(%ebp)
f011443a:	e8 97 25 00 00       	call   f01169d6 <CCP>
f011443f:	83 c4 30             	add    $0x30,%esp
f0114442:	85 c0                	test   %eax,%eax
f0114444:	75 1e                	jne    f0114464 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114446:	83 ec 04             	sub    $0x4,%esp
f0114449:	68 78 a4 12 f0       	push   $0xf012a478
f011444e:	68 93 04 00 00       	push   $0x493
f0114453:	68 42 91 12 f0       	push   $0xf0129142
f0114458:	e8 79 c0 fe ff       	call   f01004d6 <_warn>
f011445d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114460:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114464:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114468:	74 04                	je     f011446e <test_share_chunk+0x5ee>
f011446a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011446e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114472:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114475:	89 d0                	mov    %edx,%eax
f0114477:	01 c0                	add    %eax,%eax
f0114479:	01 d0                	add    %edx,%eax
f011447b:	c1 e0 02             	shl    $0x2,%eax
f011447e:	f7 d8                	neg    %eax
f0114480:	05 00 00 0a 00       	add    $0xa0000,%eax
f0114485:	83 ec 08             	sub    $0x8,%esp
f0114488:	6a 02                	push   $0x2
f011448a:	6a 07                	push   $0x7
f011448c:	6a 03                	push   $0x3
f011448e:	6a 07                	push   $0x7
f0114490:	6a 07                	push   $0x7
f0114492:	6a 02                	push   $0x2
f0114494:	50                   	push   %eax
f0114495:	68 00 30 00 00       	push   $0x3000
f011449a:	68 00 30 00 40       	push   $0x40003000
f011449f:	ff 75 cc             	pushl  -0x34(%ebp)
f01144a2:	e8 2f 25 00 00       	call   f01169d6 <CCP>
f01144a7:	83 c4 30             	add    $0x30,%esp
f01144aa:	85 c0                	test   %eax,%eax
f01144ac:	75 1e                	jne    f01144cc <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01144ae:	83 ec 04             	sub    $0x4,%esp
f01144b1:	68 78 a4 12 f0       	push   $0xf012a478
f01144b6:	68 9b 04 00 00       	push   $0x49b
f01144bb:	68 42 91 12 f0       	push   $0xf0129142
f01144c0:	e8 11 c0 fe ff       	call   f01004d6 <_warn>
f01144c5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01144c8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01144cc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01144d0:	74 04                	je     f01144d6 <test_share_chunk+0x656>
f01144d2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01144d6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01144da:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01144dd:	c1 e0 02             	shl    $0x2,%eax
f01144e0:	83 ec 08             	sub    $0x8,%esp
f01144e3:	6a 02                	push   $0x2
f01144e5:	6a 07                	push   $0x7
f01144e7:	6a 03                	push   $0x3
f01144e9:	6a 07                	push   $0x7
f01144eb:	6a 07                	push   $0x7
f01144ed:	6a 03                	push   $0x3
f01144ef:	50                   	push   %eax
f01144f0:	68 00 00 0a 00       	push   $0xa0000
f01144f5:	68 00 00 0a 40       	push   $0x400a0000
f01144fa:	ff 75 cc             	pushl  -0x34(%ebp)
f01144fd:	e8 d4 24 00 00       	call   f01169d6 <CCP>
f0114502:	83 c4 30             	add    $0x30,%esp
f0114505:	85 c0                	test   %eax,%eax
f0114507:	75 1e                	jne    f0114527 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114509:	83 ec 04             	sub    $0x4,%esp
f011450c:	68 78 a4 12 f0       	push   $0xf012a478
f0114511:	68 a3 04 00 00       	push   $0x4a3
f0114516:	68 42 91 12 f0       	push   $0xf0129142
f011451b:	e8 b6 bf fe ff       	call   f01004d6 <_warn>
f0114520:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114523:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114527:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011452b:	74 04                	je     f0114531 <test_share_chunk+0x6b1>
f011452d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114531:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114535:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114539:	0f 84 92 00 00 00    	je     f01145d1 <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f011453f:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0114546:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f011454d:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f0114554:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f011455b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011455e:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f0114561:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0114568:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f011456f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114572:	8a 00                	mov    (%eax),%al
f0114574:	3c 41                	cmp    $0x41,%al
f0114576:	75 2d                	jne    f01145a5 <test_share_chunk+0x725>
f0114578:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011457b:	8a 00                	mov    (%eax),%al
f011457d:	3c 41                	cmp    $0x41,%al
f011457f:	75 24                	jne    f01145a5 <test_share_chunk+0x725>
f0114581:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114584:	8a 00                	mov    (%eax),%al
f0114586:	3c 41                	cmp    $0x41,%al
f0114588:	75 1b                	jne    f01145a5 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f011458a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011458d:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f011458f:	3c 44                	cmp    $0x44,%al
f0114591:	75 12                	jne    f01145a5 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114593:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114596:	8a 00                	mov    (%eax),%al
f0114598:	3c 44                	cmp    $0x44,%al
f011459a:	75 09                	jne    f01145a5 <test_share_chunk+0x725>
f011459c:	8b 45 90             	mov    -0x70(%ebp),%eax
f011459f:	8a 00                	mov    (%eax),%al
f01145a1:	3c 44                	cmp    $0x44,%al
f01145a3:	74 1e                	je     f01145c3 <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01145a5:	83 ec 04             	sub    $0x4,%esp
f01145a8:	68 c0 a4 12 f0       	push   $0xf012a4c0
f01145ad:	68 b5 04 00 00       	push   $0x4b5
f01145b2:	68 42 91 12 f0       	push   $0xf0129142
f01145b7:	e8 1a bf fe ff       	call   f01004d6 <_warn>
f01145bc:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01145bf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01145c3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145c7:	74 04                	je     f01145cd <test_share_chunk+0x74d>
f01145c9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01145cd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f01145d1:	83 ec 0c             	sub    $0xc,%esp
f01145d4:	68 32 9b 12 f0       	push   $0xf0129b32
f01145d9:	e8 ad c9 fe ff       	call   f0100f8b <cprintf>
f01145de:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f01145e1:	83 ec 0c             	sub    $0xc,%esp
f01145e4:	68 cc a5 12 f0       	push   $0xf012a5cc
f01145e9:	e8 9d c9 fe ff       	call   f0100f8b <cprintf>
f01145ee:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01145f1:	e8 b8 a2 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01145f6:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f01145f9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01145fc:	89 d0                	mov    %edx,%eax
f01145fe:	01 c0                	add    %eax,%eax
f0114600:	01 d0                	add    %edx,%eax
f0114602:	01 c0                	add    %eax,%eax
f0114604:	01 d0                	add    %edx,%eax
f0114606:	83 ec 0c             	sub    $0xc,%esp
f0114609:	6a 04                	push   $0x4
f011460b:	50                   	push   %eax
f011460c:	68 00 fc 3f 00       	push   $0x3ffc00
f0114611:	68 00 fc 09 00       	push   $0x9fc00
f0114616:	ff 75 cc             	pushl  -0x34(%ebp)
f0114619:	e8 62 64 ff ff       	call   f010aa80 <share_chunk>
f011461e:	83 c4 20             	add    $0x20,%esp
f0114621:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114624:	e8 85 a2 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0114629:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f011462c:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f0114630:	75 0b                	jne    f011463d <test_share_chunk+0x7bd>
f0114632:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114635:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114638:	83 f8 01             	cmp    $0x1,%eax
f011463b:	74 28                	je     f0114665 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011463d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114640:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114643:	83 ec 0c             	sub    $0xc,%esp
f0114646:	50                   	push   %eax
f0114647:	ff 75 8c             	pushl  -0x74(%ebp)
f011464a:	68 40 a5 12 f0       	push   $0xf012a540
f011464f:	68 cb 04 00 00       	push   $0x4cb
f0114654:	68 42 91 12 f0       	push   $0xf0129142
f0114659:	e8 78 be fe ff       	call   f01004d6 <_warn>
f011465e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114661:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114665:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114669:	74 04                	je     f011466f <test_share_chunk+0x7ef>
f011466b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011466f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114673:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f011467a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011467d:	89 d0                	mov    %edx,%eax
f011467f:	01 c0                	add    %eax,%eax
f0114681:	01 d0                	add    %edx,%eax
f0114683:	c1 e0 02             	shl    $0x2,%eax
f0114686:	83 ec 08             	sub    $0x8,%esp
f0114689:	6a 02                	push   $0x2
f011468b:	6a 07                	push   $0x7
f011468d:	6a 07                	push   $0x7
f011468f:	6a 07                	push   $0x7
f0114691:	6a 05                	push   $0x5
f0114693:	6a ff                	push   $0xffffffff
f0114695:	50                   	push   %eax
f0114696:	68 00 f0 3f 00       	push   $0x3ff000
f011469b:	68 00 f0 09 00       	push   $0x9f000
f01146a0:	ff 75 cc             	pushl  -0x34(%ebp)
f01146a3:	e8 2e 23 00 00       	call   f01169d6 <CCP>
f01146a8:	83 c4 30             	add    $0x30,%esp
f01146ab:	85 c0                	test   %eax,%eax
f01146ad:	75 25                	jne    f01146d4 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01146af:	83 ec 04             	sub    $0x4,%esp
f01146b2:	68 78 a4 12 f0       	push   $0xf012a478
f01146b7:	68 d4 04 00 00       	push   $0x4d4
f01146bc:	68 42 91 12 f0       	push   $0xf0129142
f01146c1:	e8 10 be fe ff       	call   f01004d6 <_warn>
f01146c6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01146c9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01146cd:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f01146d4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01146d8:	74 04                	je     f01146de <test_share_chunk+0x85e>
f01146da:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01146de:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01146e2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01146e5:	c1 e0 02             	shl    $0x2,%eax
f01146e8:	83 ec 08             	sub    $0x8,%esp
f01146eb:	6a 02                	push   $0x2
f01146ed:	6a 07                	push   $0x7
f01146ef:	6a 07                	push   $0x7
f01146f1:	6a 07                	push   $0x7
f01146f3:	6a 05                	push   $0x5
f01146f5:	6a 03                	push   $0x3
f01146f7:	50                   	push   %eax
f01146f8:	68 00 f0 3f 00       	push   $0x3ff000
f01146fd:	68 00 f0 09 00       	push   $0x9f000
f0114702:	ff 75 cc             	pushl  -0x34(%ebp)
f0114705:	e8 cc 22 00 00       	call   f01169d6 <CCP>
f011470a:	83 c4 30             	add    $0x30,%esp
f011470d:	85 c0                	test   %eax,%eax
f011470f:	75 1e                	jne    f011472f <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114711:	83 ec 04             	sub    $0x4,%esp
f0114714:	68 78 a4 12 f0       	push   $0xf012a478
f0114719:	68 dd 04 00 00       	push   $0x4dd
f011471e:	68 42 91 12 f0       	push   $0xf0129142
f0114723:	e8 ae bd fe ff       	call   f01004d6 <_warn>
f0114728:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011472b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011472f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114733:	74 04                	je     f0114739 <test_share_chunk+0x8b9>
f0114735:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114739:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f011473d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114740:	c1 e0 03             	shl    $0x3,%eax
f0114743:	83 ec 08             	sub    $0x8,%esp
f0114746:	6a 02                	push   $0x2
f0114748:	6a 07                	push   $0x7
f011474a:	6a 07                	push   $0x7
f011474c:	6a 07                	push   $0x7
f011474e:	6a 05                	push   $0x5
f0114750:	6a 04                	push   $0x4
f0114752:	50                   	push   %eax
f0114753:	68 00 00 40 00       	push   $0x400000
f0114758:	68 00 00 0a 00       	push   $0xa0000
f011475d:	ff 75 cc             	pushl  -0x34(%ebp)
f0114760:	e8 71 22 00 00       	call   f01169d6 <CCP>
f0114765:	83 c4 30             	add    $0x30,%esp
f0114768:	85 c0                	test   %eax,%eax
f011476a:	75 1e                	jne    f011478a <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011476c:	83 ec 04             	sub    $0x4,%esp
f011476f:	68 78 a4 12 f0       	push   $0xf012a478
f0114774:	68 e5 04 00 00       	push   $0x4e5
f0114779:	68 42 91 12 f0       	push   $0xf0129142
f011477e:	e8 53 bd fe ff       	call   f01004d6 <_warn>
f0114783:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114786:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011478a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011478e:	74 04                	je     f0114794 <test_share_chunk+0x914>
f0114790:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114794:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114798:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011479c:	0f 84 b2 00 00 00    	je     f0114854 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f01147a2:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f01147a9:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f01147b0:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f01147b7:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f01147be:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f01147c5:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f01147cc:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f01147d3:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f01147da:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01147dd:	8a 00                	mov    (%eax),%al
f01147df:	3c 44                	cmp    $0x44,%al
f01147e1:	75 45                	jne    f0114828 <test_share_chunk+0x9a8>
f01147e3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01147e6:	8a 00                	mov    (%eax),%al
f01147e8:	3c 44                	cmp    $0x44,%al
f01147ea:	75 3c                	jne    f0114828 <test_share_chunk+0x9a8>
f01147ec:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01147ef:	8a 00                	mov    (%eax),%al
f01147f1:	3c 44                	cmp    $0x44,%al
f01147f3:	75 33                	jne    f0114828 <test_share_chunk+0x9a8>
f01147f5:	8b 45 98             	mov    -0x68(%ebp),%eax
f01147f8:	8a 00                	mov    (%eax),%al
f01147fa:	3c 44                	cmp    $0x44,%al
f01147fc:	75 2a                	jne    f0114828 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f01147fe:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114801:	8a 10                	mov    (%eax),%dl
f0114803:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114806:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114808:	38 c2                	cmp    %al,%dl
f011480a:	75 1c                	jne    f0114828 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f011480c:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011480f:	8a 10                	mov    (%eax),%dl
f0114811:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114814:	8a 00                	mov    (%eax),%al
f0114816:	38 c2                	cmp    %al,%dl
f0114818:	75 0e                	jne    f0114828 <test_share_chunk+0x9a8>
f011481a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011481d:	8a 10                	mov    (%eax),%dl
f011481f:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0114822:	8a 00                	mov    (%eax),%al
f0114824:	38 c2                	cmp    %al,%dl
f0114826:	74 1e                	je     f0114846 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114828:	83 ec 04             	sub    $0x4,%esp
f011482b:	68 c0 a4 12 f0       	push   $0xf012a4c0
f0114830:	68 fa 04 00 00       	push   $0x4fa
f0114835:	68 42 91 12 f0       	push   $0xf0129142
f011483a:	e8 97 bc fe ff       	call   f01004d6 <_warn>
f011483f:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114842:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114846:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011484a:	74 04                	je     f0114850 <test_share_chunk+0x9d0>
f011484c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114850:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114854:	83 ec 0c             	sub    $0xc,%esp
f0114857:	68 04 a6 12 f0       	push   $0xf012a604
f011485c:	e8 2a c7 fe ff       	call   f0100f8b <cprintf>
f0114861:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0114864:	83 ec 08             	sub    $0x8,%esp
f0114867:	ff 75 e4             	pushl  -0x1c(%ebp)
f011486a:	68 14 a6 12 f0       	push   $0xf012a614
f011486f:	e8 17 c7 fe ff       	call   f0100f8b <cprintf>
f0114874:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114877:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f011487b:	75 10                	jne    f011488d <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f011487d:	83 ec 0c             	sub    $0xc,%esp
f0114880:	68 44 a6 12 f0       	push   $0xf012a644
f0114885:	e8 01 c7 fe ff       	call   f0100f8b <cprintf>
f011488a:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f011488d:	a1 c4 0d 6c f0       	mov    0xf06c0dc4,%eax
f0114892:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114895:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114898:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011489b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01148a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01148a3:	5b                   	pop    %ebx
f01148a4:	5e                   	pop    %esi
f01148a5:	5f                   	pop    %edi
f01148a6:	5d                   	pop    %ebp
f01148a7:	c3                   	ret    

f01148a8 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f01148a8:	55                   	push   %ebp
f01148a9:	89 e5                	mov    %esp,%ebp
f01148ab:	57                   	push   %edi
f01148ac:	56                   	push   %esi
f01148ad:	53                   	push   %ebx
f01148ae:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01148b4:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01148ba:	bb 44 98 12 f0       	mov    $0xf0129844,%ebx
f01148bf:	ba 0f 00 00 00       	mov    $0xf,%edx
f01148c4:	89 c7                	mov    %eax,%edi
f01148c6:	89 de                	mov    %ebx,%esi
f01148c8:	89 d1                	mov    %edx,%ecx
f01148ca:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01148cc:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01148d2:	b9 23 00 00 00       	mov    $0x23,%ecx
f01148d7:	b0 00                	mov    $0x0,%al
f01148d9:	89 d7                	mov    %edx,%edi
f01148db:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01148dd:	6a 00                	push   $0x0
f01148df:	6a 0a                	push   $0xa
f01148e1:	6a 14                	push   $0x14
f01148e3:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01148e9:	50                   	push   %eax
f01148ea:	e8 1e 66 ff ff       	call   f010af0d <env_create>
f01148ef:	83 c4 10             	add    $0x10,%esp
f01148f2:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01148f5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01148f8:	8b 40 64             	mov    0x64(%eax),%eax
f01148fb:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f01148fe:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114901:	8b 40 68             	mov    0x68(%eax),%eax
f0114904:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114907:	8b 45 90             	mov    -0x70(%ebp),%eax
f011490a:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f011490d:	83 ec 0c             	sub    $0xc,%esp
f0114910:	ff 75 cc             	pushl  -0x34(%ebp)
f0114913:	e8 8a 20 00 00       	call   f01169a2 <ClearUserSpace>
f0114918:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f011491b:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114922:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114929:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f0114930:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114934:	83 ec 0c             	sub    $0xc,%esp
f0114937:	68 80 a6 12 f0       	push   $0xf012a680
f011493c:	e8 4a c6 fe ff       	call   f0100f8b <cprintf>
f0114941:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114944:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f011494b:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f0114952:	eb 03                	jmp    f0114957 <test_allocate_chunk+0xaf>
f0114954:	ff 4d e4             	decl   -0x1c(%ebp)
f0114957:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011495e:	76 09                	jbe    f0114969 <test_allocate_chunk+0xc1>
f0114960:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114963:	8a 00                	mov    (%eax),%al
f0114965:	84 c0                	test   %al,%al
f0114967:	74 eb                	je     f0114954 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114969:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114970:	75 06                	jne    f0114978 <test_allocate_chunk+0xd0>
f0114972:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114975:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0114978:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011497b:	8a 00                	mov    (%eax),%al
f011497d:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f0114983:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114986:	8a 00                	mov    (%eax),%al
f0114988:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f011498e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114991:	8a 00                	mov    (%eax),%al
f0114993:	0f be c0             	movsbl %al,%eax
f0114996:	83 ec 08             	sub    $0x8,%esp
f0114999:	50                   	push   %eax
f011499a:	68 aa a6 12 f0       	push   $0xf012a6aa
f011499f:	e8 e7 c5 fe ff       	call   f0100f8b <cprintf>
f01149a4:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f01149a7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01149aa:	8a 00                	mov    (%eax),%al
f01149ac:	0f be c0             	movsbl %al,%eax
f01149af:	83 ec 08             	sub    $0x8,%esp
f01149b2:	50                   	push   %eax
f01149b3:	68 b6 a6 12 f0       	push   $0xf012a6b6
f01149b8:	e8 ce c5 fe ff       	call   f0100f8b <cprintf>
f01149bd:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f01149c0:	83 ec 08             	sub    $0x8,%esp
f01149c3:	68 00 f0 bf ef       	push   $0xefbff000
f01149c8:	ff 75 cc             	pushl  -0x34(%ebp)
f01149cb:	e8 b3 1f 00 00       	call   f0116983 <GP>
f01149d0:	83 c4 10             	add    $0x10,%esp
f01149d3:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01149d6:	e8 d3 9e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01149db:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f01149de:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01149e1:	c1 e0 02             	shl    $0x2,%eax
f01149e4:	6a 02                	push   $0x2
f01149e6:	50                   	push   %eax
f01149e7:	68 00 f0 bf ef       	push   $0xefbff000
f01149ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01149ef:	e8 a6 60 ff ff       	call   f010aa9a <allocate_chunk>
f01149f4:	83 c4 10             	add    $0x10,%esp
f01149f7:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01149fa:	e8 af 9e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01149ff:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114a02:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114a06:	75 08                	jne    f0114a10 <test_allocate_chunk+0x168>
f0114a08:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a0b:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114a0e:	74 2a                	je     f0114a3a <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114a10:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a13:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114a16:	83 ec 08             	sub    $0x8,%esp
f0114a19:	6a 00                	push   $0x0
f0114a1b:	50                   	push   %eax
f0114a1c:	ff 75 b0             	pushl  -0x50(%ebp)
f0114a1f:	68 c4 a6 12 f0       	push   $0xf012a6c4
f0114a24:	68 3a 05 00 00       	push   $0x53a
f0114a29:	68 42 91 12 f0       	push   $0xf0129142
f0114a2e:	e8 a3 ba fe ff       	call   f01004d6 <_warn>
f0114a33:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114a36:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114a3a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114a3e:	74 04                	je     f0114a44 <test_allocate_chunk+0x19c>
f0114a40:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114a44:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114a48:	e8 61 9e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0114a4d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f0114a50:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114a53:	01 c0                	add    %eax,%eax
f0114a55:	89 c1                	mov    %eax,%ecx
f0114a57:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114a5a:	89 d0                	mov    %edx,%eax
f0114a5c:	c1 e0 02             	shl    $0x2,%eax
f0114a5f:	01 d0                	add    %edx,%eax
f0114a61:	f7 d8                	neg    %eax
f0114a63:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114a68:	6a 02                	push   $0x2
f0114a6a:	51                   	push   %ecx
f0114a6b:	50                   	push   %eax
f0114a6c:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a6f:	e8 26 60 ff ff       	call   f010aa9a <allocate_chunk>
f0114a74:	83 c4 10             	add    $0x10,%esp
f0114a77:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114a7a:	e8 2f 9e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0114a7f:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114a82:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114a86:	75 08                	jne    f0114a90 <test_allocate_chunk+0x1e8>
f0114a88:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a8b:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114a8e:	74 2a                	je     f0114aba <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114a90:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a93:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114a96:	83 ec 08             	sub    $0x8,%esp
f0114a99:	6a 00                	push   $0x0
f0114a9b:	50                   	push   %eax
f0114a9c:	ff 75 b0             	pushl  -0x50(%ebp)
f0114a9f:	68 c4 a6 12 f0       	push   $0xf012a6c4
f0114aa4:	68 48 05 00 00       	push   $0x548
f0114aa9:	68 42 91 12 f0       	push   $0xf0129142
f0114aae:	e8 23 ba fe ff       	call   f01004d6 <_warn>
f0114ab3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ab6:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114aba:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114abe:	74 04                	je     f0114ac4 <test_allocate_chunk+0x21c>
f0114ac0:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114ac4:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0114ac8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114acb:	c1 e0 02             	shl    $0x2,%eax
f0114ace:	83 ec 08             	sub    $0x8,%esp
f0114ad1:	6a 03                	push   $0x3
f0114ad3:	6a 00                	push   $0x0
f0114ad5:	6a 00                	push   $0x0
f0114ad7:	68 ff 0f 00 00       	push   $0xfff
f0114adc:	ff 75 b8             	pushl  -0x48(%ebp)
f0114adf:	6a 01                	push   $0x1
f0114ae1:	50                   	push   %eax
f0114ae2:	68 00 f0 bf ef       	push   $0xefbff000
f0114ae7:	6a 00                	push   $0x0
f0114ae9:	ff 75 cc             	pushl  -0x34(%ebp)
f0114aec:	e8 e5 1e 00 00       	call   f01169d6 <CCP>
f0114af1:	83 c4 30             	add    $0x30,%esp
f0114af4:	85 c0                	test   %eax,%eax
f0114af6:	75 1e                	jne    f0114b16 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114af8:	83 ec 04             	sub    $0x4,%esp
f0114afb:	68 2c a7 12 f0       	push   $0xf012a72c
f0114b00:	68 50 05 00 00       	push   $0x550
f0114b05:	68 42 91 12 f0       	push   $0xf0129142
f0114b0a:	e8 c7 b9 fe ff       	call   f01004d6 <_warn>
f0114b0f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114b12:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114b16:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114b1a:	74 04                	je     f0114b20 <test_allocate_chunk+0x278>
f0114b1c:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114b20:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0114b24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114b27:	8a 10                	mov    (%eax),%dl
f0114b29:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0114b2f:	38 c2                	cmp    %al,%dl
f0114b31:	75 0f                	jne    f0114b42 <test_allocate_chunk+0x29a>
f0114b33:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114b36:	8a 10                	mov    (%eax),%dl
f0114b38:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0114b3e:	38 c2                	cmp    %al,%dl
f0114b40:	74 1e                	je     f0114b60 <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114b42:	83 ec 04             	sub    $0x4,%esp
f0114b45:	68 78 a7 12 f0       	push   $0xf012a778
f0114b4a:	68 58 05 00 00       	push   $0x558
f0114b4f:	68 42 91 12 f0       	push   $0xf0129142
f0114b54:	e8 7d b9 fe ff       	call   f01004d6 <_warn>
f0114b59:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114b5c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114b60:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114b64:	74 04                	je     f0114b6a <test_allocate_chunk+0x2c2>
f0114b66:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114b6a:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114b6e:	83 ec 0c             	sub    $0xc,%esp
f0114b71:	68 f5 a4 12 f0       	push   $0xf012a4f5
f0114b76:	e8 10 c4 fe ff       	call   f0100f8b <cprintf>
f0114b7b:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f0114b7e:	83 ec 0c             	sub    $0xc,%esp
f0114b81:	68 b0 a7 12 f0       	push   $0xf012a7b0
f0114b86:	e8 00 c4 fe ff       	call   f0100f8b <cprintf>
f0114b8b:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114b8e:	e8 1b 9d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0114b93:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114b96:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114b99:	c1 e0 05             	shl    $0x5,%eax
f0114b9c:	68 02 0e 00 00       	push   $0xe02
f0114ba1:	50                   	push   %eax
f0114ba2:	6a 00                	push   $0x0
f0114ba4:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ba7:	e8 ee 5e ff ff       	call   f010aa9a <allocate_chunk>
f0114bac:	83 c4 10             	add    $0x10,%esp
f0114baf:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114bb2:	e8 f7 9c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0114bb7:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0114bba:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0114bbe:	75 36                	jne    f0114bf6 <test_allocate_chunk+0x34e>
f0114bc0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114bc3:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114bc6:	89 c1                	mov    %eax,%ecx
f0114bc8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114bcb:	c1 e0 05             	shl    $0x5,%eax
f0114bce:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114bd1:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114bd8:	99                   	cltd   
f0114bd9:	f7 fe                	idiv   %esi
f0114bdb:	89 c3                	mov    %eax,%ebx
f0114bdd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114be0:	c1 e0 05             	shl    $0x5,%eax
f0114be3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114be6:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114bed:	99                   	cltd   
f0114bee:	f7 fe                	idiv   %esi
f0114bf0:	01 d8                	add    %ebx,%eax
f0114bf2:	39 c1                	cmp    %eax,%ecx
f0114bf4:	74 54                	je     f0114c4a <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0114bf6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114bf9:	c1 e0 05             	shl    $0x5,%eax
f0114bfc:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114bff:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114c06:	99                   	cltd   
f0114c07:	f7 ff                	idiv   %edi
f0114c09:	89 c1                	mov    %eax,%ecx
f0114c0b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c0e:	c1 e0 05             	shl    $0x5,%eax
f0114c11:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114c14:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114c1b:	99                   	cltd   
f0114c1c:	f7 fe                	idiv   %esi
f0114c1e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114c21:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114c24:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114c27:	83 ec 08             	sub    $0x8,%esp
f0114c2a:	52                   	push   %edx
f0114c2b:	50                   	push   %eax
f0114c2c:	ff 75 a8             	pushl  -0x58(%ebp)
f0114c2f:	68 f0 a7 12 f0       	push   $0xf012a7f0
f0114c34:	68 6d 05 00 00       	push   $0x56d
f0114c39:	68 42 91 12 f0       	push   $0xf0129142
f0114c3e:	e8 93 b8 fe ff       	call   f01004d6 <_warn>
f0114c43:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114c46:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114c4a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114c4e:	74 04                	je     f0114c54 <test_allocate_chunk+0x3ac>
f0114c50:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114c54:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114c58:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114c5f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c62:	c1 e0 05             	shl    $0x5,%eax
f0114c65:	83 ec 08             	sub    $0x8,%esp
f0114c68:	6a 03                	push   $0x3
f0114c6a:	6a 00                	push   $0x0
f0114c6c:	6a 00                	push   $0x0
f0114c6e:	68 07 0e 00 00       	push   $0xe07
f0114c73:	68 03 0e 00 00       	push   $0xe03
f0114c78:	6a 01                	push   $0x1
f0114c7a:	50                   	push   %eax
f0114c7b:	6a 00                	push   $0x0
f0114c7d:	6a 00                	push   $0x0
f0114c7f:	ff 75 cc             	pushl  -0x34(%ebp)
f0114c82:	e8 4f 1d 00 00       	call   f01169d6 <CCP>
f0114c87:	83 c4 30             	add    $0x30,%esp
f0114c8a:	85 c0                	test   %eax,%eax
f0114c8c:	75 25                	jne    f0114cb3 <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114c8e:	83 ec 04             	sub    $0x4,%esp
f0114c91:	68 2c a7 12 f0       	push   $0xf012a72c
f0114c96:	68 76 05 00 00       	push   $0x576
f0114c9b:	68 42 91 12 f0       	push   $0xf0129142
f0114ca0:	e8 31 b8 fe ff       	call   f01004d6 <_warn>
f0114ca5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114ca8:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114cac:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0114cb3:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114cb7:	74 04                	je     f0114cbd <test_allocate_chunk+0x415>
f0114cb9:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114cbd:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0114cc1:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114cc5:	74 5a                	je     f0114d21 <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0114cc7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114cca:	01 c0                	add    %eax,%eax
f0114ccc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0114ccf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114cd2:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0114cd5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114cd8:	01 c0                	add    %eax,%eax
f0114cda:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114cdd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114ce0:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0114ce3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114ce6:	8a 00                	mov    (%eax),%al
f0114ce8:	3c 4b                	cmp    $0x4b,%al
f0114cea:	75 09                	jne    f0114cf5 <test_allocate_chunk+0x44d>
f0114cec:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114cef:	8a 00                	mov    (%eax),%al
f0114cf1:	3c 4d                	cmp    $0x4d,%al
f0114cf3:	74 1e                	je     f0114d13 <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114cf5:	83 ec 04             	sub    $0x4,%esp
f0114cf8:	68 78 a7 12 f0       	push   $0xf012a778
f0114cfd:	68 84 05 00 00       	push   $0x584
f0114d02:	68 42 91 12 f0       	push   $0xf0129142
f0114d07:	e8 ca b7 fe ff       	call   f01004d6 <_warn>
f0114d0c:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114d0f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114d13:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114d17:	74 04                	je     f0114d1d <test_allocate_chunk+0x475>
f0114d19:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114d1d:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0114d21:	83 ec 0c             	sub    $0xc,%esp
f0114d24:	68 cf 9a 12 f0       	push   $0xf0129acf
f0114d29:	e8 5d c2 fe ff       	call   f0100f8b <cprintf>
f0114d2e:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0114d31:	83 ec 0c             	sub    $0xc,%esp
f0114d34:	68 50 a8 12 f0       	push   $0xf012a850
f0114d39:	e8 4d c2 fe ff       	call   f0100f8b <cprintf>
f0114d3e:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114d41:	e8 68 9b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0114d46:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0114d49:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d4c:	c1 e0 06             	shl    $0x6,%eax
f0114d4f:	89 c2                	mov    %eax,%edx
f0114d51:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d54:	c1 e0 05             	shl    $0x5,%eax
f0114d57:	6a 00                	push   $0x0
f0114d59:	52                   	push   %edx
f0114d5a:	50                   	push   %eax
f0114d5b:	ff 75 cc             	pushl  -0x34(%ebp)
f0114d5e:	e8 37 5d ff ff       	call   f010aa9a <allocate_chunk>
f0114d63:	83 c4 10             	add    $0x10,%esp
f0114d66:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114d69:	e8 40 9b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0114d6e:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0114d71:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0114d75:	75 36                	jne    f0114dad <test_allocate_chunk+0x505>
f0114d77:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114d7a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114d7d:	89 c1                	mov    %eax,%ecx
f0114d7f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d82:	c1 e0 06             	shl    $0x6,%eax
f0114d85:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114d88:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114d8f:	99                   	cltd   
f0114d90:	f7 ff                	idiv   %edi
f0114d92:	89 c3                	mov    %eax,%ebx
f0114d94:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d97:	c1 e0 06             	shl    $0x6,%eax
f0114d9a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114d9d:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114da4:	99                   	cltd   
f0114da5:	f7 fe                	idiv   %esi
f0114da7:	01 d8                	add    %ebx,%eax
f0114da9:	39 c1                	cmp    %eax,%ecx
f0114dab:	74 54                	je     f0114e01 <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0114dad:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114db0:	c1 e0 06             	shl    $0x6,%eax
f0114db3:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114db6:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114dbd:	99                   	cltd   
f0114dbe:	f7 fb                	idiv   %ebx
f0114dc0:	89 c1                	mov    %eax,%ecx
f0114dc2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114dc5:	c1 e0 06             	shl    $0x6,%eax
f0114dc8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114dcb:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114dd2:	99                   	cltd   
f0114dd3:	f7 ff                	idiv   %edi
f0114dd5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114dd8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ddb:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114dde:	83 ec 08             	sub    $0x8,%esp
f0114de1:	52                   	push   %edx
f0114de2:	50                   	push   %eax
f0114de3:	ff 75 a4             	pushl  -0x5c(%ebp)
f0114de6:	68 f0 a7 12 f0       	push   $0xf012a7f0
f0114deb:	68 9a 05 00 00       	push   $0x59a
f0114df0:	68 42 91 12 f0       	push   $0xf0129142
f0114df5:	e8 dc b6 fe ff       	call   f01004d6 <_warn>
f0114dfa:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114dfd:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114e01:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114e05:	74 04                	je     f0114e0b <test_allocate_chunk+0x563>
f0114e07:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114e0b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114e0f:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114e16:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e19:	c1 e0 06             	shl    $0x6,%eax
f0114e1c:	89 c2                	mov    %eax,%edx
f0114e1e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e21:	c1 e0 05             	shl    $0x5,%eax
f0114e24:	83 ec 08             	sub    $0x8,%esp
f0114e27:	6a 03                	push   $0x3
f0114e29:	6a 00                	push   $0x0
f0114e2b:	6a 00                	push   $0x0
f0114e2d:	68 07 0e 00 00       	push   $0xe07
f0114e32:	6a 01                	push   $0x1
f0114e34:	6a 01                	push   $0x1
f0114e36:	52                   	push   %edx
f0114e37:	50                   	push   %eax
f0114e38:	6a 00                	push   $0x0
f0114e3a:	ff 75 cc             	pushl  -0x34(%ebp)
f0114e3d:	e8 94 1b 00 00       	call   f01169d6 <CCP>
f0114e42:	83 c4 30             	add    $0x30,%esp
f0114e45:	85 c0                	test   %eax,%eax
f0114e47:	75 25                	jne    f0114e6e <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114e49:	83 ec 04             	sub    $0x4,%esp
f0114e4c:	68 2c a7 12 f0       	push   $0xf012a72c
f0114e51:	68 a3 05 00 00       	push   $0x5a3
f0114e56:	68 42 91 12 f0       	push   $0xf0129142
f0114e5b:	e8 76 b6 fe ff       	call   f01004d6 <_warn>
f0114e60:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114e63:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114e67:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0114e6e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114e72:	74 04                	je     f0114e78 <test_allocate_chunk+0x5d0>
f0114e74:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114e78:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0114e7c:	83 ec 0c             	sub    $0xc,%esp
f0114e7f:	68 32 9b 12 f0       	push   $0xf0129b32
f0114e84:	e8 02 c1 fe ff       	call   f0100f8b <cprintf>
f0114e89:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0114e8c:	83 ec 0c             	sub    $0xc,%esp
f0114e8f:	68 90 a8 12 f0       	push   $0xf012a890
f0114e94:	e8 f2 c0 fe ff       	call   f0100f8b <cprintf>
f0114e99:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114e9c:	e8 0d 9a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0114ea1:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0114ea4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ea7:	c1 e0 06             	shl    $0x6,%eax
f0114eaa:	68 06 0e 00 00       	push   $0xe06
f0114eaf:	50                   	push   %eax
f0114eb0:	68 00 00 00 80       	push   $0x80000000
f0114eb5:	ff 75 cc             	pushl  -0x34(%ebp)
f0114eb8:	e8 dd 5b ff ff       	call   f010aa9a <allocate_chunk>
f0114ebd:	83 c4 10             	add    $0x10,%esp
f0114ec0:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114ec3:	e8 e6 99 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0114ec8:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0114ecb:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0114ecf:	75 36                	jne    f0114f07 <test_allocate_chunk+0x65f>
f0114ed1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ed4:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ed7:	89 c1                	mov    %eax,%ecx
f0114ed9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114edc:	c1 e0 06             	shl    $0x6,%eax
f0114edf:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114ee2:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114ee9:	99                   	cltd   
f0114eea:	f7 fb                	idiv   %ebx
f0114eec:	89 c3                	mov    %eax,%ebx
f0114eee:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ef1:	c1 e0 06             	shl    $0x6,%eax
f0114ef4:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114ef7:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114efe:	99                   	cltd   
f0114eff:	f7 fe                	idiv   %esi
f0114f01:	01 d8                	add    %ebx,%eax
f0114f03:	39 c1                	cmp    %eax,%ecx
f0114f05:	74 54                	je     f0114f5b <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0114f07:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f0a:	c1 e0 06             	shl    $0x6,%eax
f0114f0d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114f10:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114f17:	99                   	cltd   
f0114f18:	f7 ff                	idiv   %edi
f0114f1a:	89 c1                	mov    %eax,%ecx
f0114f1c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f1f:	c1 e0 06             	shl    $0x6,%eax
f0114f22:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114f25:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114f2c:	99                   	cltd   
f0114f2d:	f7 fb                	idiv   %ebx
f0114f2f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114f32:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114f35:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114f38:	83 ec 08             	sub    $0x8,%esp
f0114f3b:	52                   	push   %edx
f0114f3c:	50                   	push   %eax
f0114f3d:	ff 75 9c             	pushl  -0x64(%ebp)
f0114f40:	68 f0 a7 12 f0       	push   $0xf012a7f0
f0114f45:	68 b9 05 00 00       	push   $0x5b9
f0114f4a:	68 42 91 12 f0       	push   $0xf0129142
f0114f4f:	e8 82 b5 fe ff       	call   f01004d6 <_warn>
f0114f54:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f57:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114f5b:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114f5f:	74 04                	je     f0114f65 <test_allocate_chunk+0x6bd>
f0114f61:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114f65:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114f69:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114f70:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f73:	c1 e0 06             	shl    $0x6,%eax
f0114f76:	83 ec 08             	sub    $0x8,%esp
f0114f79:	6a 03                	push   $0x3
f0114f7b:	6a 00                	push   $0x0
f0114f7d:	6a 00                	push   $0x0
f0114f7f:	68 07 0e 00 00       	push   $0xe07
f0114f84:	68 07 0e 00 00       	push   $0xe07
f0114f89:	6a 01                	push   $0x1
f0114f8b:	50                   	push   %eax
f0114f8c:	68 00 00 00 80       	push   $0x80000000
f0114f91:	6a 00                	push   $0x0
f0114f93:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f96:	e8 3b 1a 00 00       	call   f01169d6 <CCP>
f0114f9b:	83 c4 30             	add    $0x30,%esp
f0114f9e:	85 c0                	test   %eax,%eax
f0114fa0:	75 25                	jne    f0114fc7 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114fa2:	83 ec 04             	sub    $0x4,%esp
f0114fa5:	68 2c a7 12 f0       	push   $0xf012a72c
f0114faa:	68 c2 05 00 00       	push   $0x5c2
f0114faf:	68 42 91 12 f0       	push   $0xf0129142
f0114fb4:	e8 1d b5 fe ff       	call   f01004d6 <_warn>
f0114fb9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114fbc:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114fc0:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0114fc7:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114fcb:	74 04                	je     f0114fd1 <test_allocate_chunk+0x729>
f0114fcd:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114fd1:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0114fd5:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114fd9:	74 6f                	je     f011504a <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0114fdb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114fde:	01 c0                	add    %eax,%eax
f0114fe0:	05 00 00 00 80       	add    $0x80000000,%eax
f0114fe5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0114fe8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114feb:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0114fee:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114ff1:	89 d0                	mov    %edx,%eax
f0114ff3:	c1 e0 02             	shl    $0x2,%eax
f0114ff6:	01 d0                	add    %edx,%eax
f0114ff8:	01 c0                	add    %eax,%eax
f0114ffa:	01 d0                	add    %edx,%eax
f0114ffc:	01 c0                	add    %eax,%eax
f0114ffe:	05 00 00 00 80       	add    $0x80000000,%eax
f0115003:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0115006:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115009:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f011500c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011500f:	8a 00                	mov    (%eax),%al
f0115011:	3c 4b                	cmp    $0x4b,%al
f0115013:	75 09                	jne    f011501e <test_allocate_chunk+0x776>
f0115015:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115018:	8a 00                	mov    (%eax),%al
f011501a:	3c 4d                	cmp    $0x4d,%al
f011501c:	74 1e                	je     f011503c <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011501e:	83 ec 04             	sub    $0x4,%esp
f0115021:	68 78 a7 12 f0       	push   $0xf012a778
f0115026:	68 d0 05 00 00       	push   $0x5d0
f011502b:	68 42 91 12 f0       	push   $0xf0129142
f0115030:	e8 a1 b4 fe ff       	call   f01004d6 <_warn>
f0115035:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0115038:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f011503c:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115040:	74 04                	je     f0115046 <test_allocate_chunk+0x79e>
f0115042:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0115046:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f011504a:	83 ec 0c             	sub    $0xc,%esp
f011504d:	68 04 a6 12 f0       	push   $0xf012a604
f0115052:	e8 34 bf fe ff       	call   f0100f8b <cprintf>
f0115057:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f011505a:	83 ec 0c             	sub    $0xc,%esp
f011505d:	68 cc a8 12 f0       	push   $0xf012a8cc
f0115062:	e8 24 bf fe ff       	call   f0100f8b <cprintf>
f0115067:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011506a:	e8 3f 98 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011506f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0115072:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115075:	89 d0                	mov    %edx,%eax
f0115077:	01 c0                	add    %eax,%eax
f0115079:	01 d0                	add    %edx,%eax
f011507b:	01 c0                	add    %eax,%eax
f011507d:	01 d0                	add    %edx,%eax
f011507f:	68 04 0e 00 00       	push   $0xe04
f0115084:	50                   	push   %eax
f0115085:	68 00 fc 3f 40       	push   $0x403ffc00
f011508a:	ff 75 cc             	pushl  -0x34(%ebp)
f011508d:	e8 08 5a ff ff       	call   f010aa9a <allocate_chunk>
f0115092:	83 c4 10             	add    $0x10,%esp
f0115095:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115098:	e8 11 98 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011509d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f01150a0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f01150a4:	75 0b                	jne    f01150b1 <test_allocate_chunk+0x809>
f01150a6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01150a9:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01150ac:	83 f8 05             	cmp    $0x5,%eax
f01150af:	74 2a                	je     f01150db <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f01150b1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01150b4:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01150b7:	83 ec 08             	sub    $0x8,%esp
f01150ba:	6a 05                	push   $0x5
f01150bc:	50                   	push   %eax
f01150bd:	ff 75 98             	pushl  -0x68(%ebp)
f01150c0:	68 f0 a7 12 f0       	push   $0xf012a7f0
f01150c5:	68 e7 05 00 00       	push   $0x5e7
f01150ca:	68 42 91 12 f0       	push   $0xf0129142
f01150cf:	e8 02 b4 fe ff       	call   f01004d6 <_warn>
f01150d4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01150d7:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01150db:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01150df:	74 04                	je     f01150e5 <test_allocate_chunk+0x83d>
f01150e1:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01150e5:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01150e9:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01150f0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01150f3:	89 d0                	mov    %edx,%eax
f01150f5:	01 c0                	add    %eax,%eax
f01150f7:	01 d0                	add    %edx,%eax
f01150f9:	c1 e0 02             	shl    $0x2,%eax
f01150fc:	83 ec 08             	sub    $0x8,%esp
f01150ff:	6a 03                	push   $0x3
f0115101:	6a 00                	push   $0x0
f0115103:	6a 00                	push   $0x0
f0115105:	68 07 0e 00 00       	push   $0xe07
f011510a:	68 05 0e 00 00       	push   $0xe05
f011510f:	6a 01                	push   $0x1
f0115111:	50                   	push   %eax
f0115112:	68 00 f0 3f 40       	push   $0x403ff000
f0115117:	6a 00                	push   $0x0
f0115119:	ff 75 cc             	pushl  -0x34(%ebp)
f011511c:	e8 b5 18 00 00       	call   f01169d6 <CCP>
f0115121:	83 c4 30             	add    $0x30,%esp
f0115124:	85 c0                	test   %eax,%eax
f0115126:	75 25                	jne    f011514d <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0115128:	83 ec 04             	sub    $0x4,%esp
f011512b:	68 2c a7 12 f0       	push   $0xf012a72c
f0115130:	68 f0 05 00 00       	push   $0x5f0
f0115135:	68 42 91 12 f0       	push   $0xf0129142
f011513a:	e8 97 b3 fe ff       	call   f01004d6 <_warn>
f011513f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115142:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115146:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f011514d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115151:	74 04                	je     f0115157 <test_allocate_chunk+0x8af>
f0115153:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115157:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f011515b:	83 ec 0c             	sub    $0xc,%esp
f011515e:	68 03 a9 12 f0       	push   $0xf012a903
f0115163:	e8 23 be fe ff       	call   f0100f8b <cprintf>
f0115168:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f011516b:	83 ec 08             	sub    $0x8,%esp
f011516e:	ff 75 e0             	pushl  -0x20(%ebp)
f0115171:	68 14 a9 12 f0       	push   $0xf012a914
f0115176:	e8 10 be fe ff       	call   f0100f8b <cprintf>
f011517b:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011517e:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0115182:	75 10                	jne    f0115194 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0115184:	83 ec 0c             	sub    $0xc,%esp
f0115187:	68 48 a9 12 f0       	push   $0xf012a948
f011518c:	e8 fa bd fe ff       	call   f0100f8b <cprintf>
f0115191:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115194:	a1 c4 0d 6c f0       	mov    0xf06c0dc4,%eax
f0115199:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011519c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011519f:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01151a2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01151a7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01151aa:	5b                   	pop    %ebx
f01151ab:	5e                   	pop    %esi
f01151ac:	5f                   	pop    %edi
f01151ad:	5d                   	pop    %ebp
f01151ae:	c3                   	ret    

f01151af <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f01151af:	55                   	push   %ebp
f01151b0:	89 e5                	mov    %esp,%ebp
f01151b2:	57                   	push   %edi
f01151b3:	56                   	push   %esi
f01151b4:	53                   	push   %ebx
f01151b5:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01151bb:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01151be:	bb 44 98 12 f0       	mov    $0xf0129844,%ebx
f01151c3:	ba 0f 00 00 00       	mov    $0xf,%edx
f01151c8:	89 c7                	mov    %eax,%edi
f01151ca:	89 de                	mov    %ebx,%esi
f01151cc:	89 d1                	mov    %edx,%ecx
f01151ce:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01151d0:	8d 55 9d             	lea    -0x63(%ebp),%edx
f01151d3:	b9 23 00 00 00       	mov    $0x23,%ecx
f01151d8:	b0 00                	mov    $0x0,%al
f01151da:	89 d7                	mov    %edx,%edi
f01151dc:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01151de:	6a 00                	push   $0x0
f01151e0:	6a 0a                	push   $0xa
f01151e2:	6a 14                	push   $0x14
f01151e4:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01151e7:	50                   	push   %eax
f01151e8:	e8 20 5d ff ff       	call   f010af0d <env_create>
f01151ed:	83 c4 10             	add    $0x10,%esp
f01151f0:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01151f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01151f6:	8b 40 64             	mov    0x64(%eax),%eax
f01151f9:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f01151fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01151ff:	8b 40 68             	mov    0x68(%eax),%eax
f0115202:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115205:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115208:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011520b:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115212:	75 70 20 
f0115215:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f011521c:	00 00 00 
f011521f:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115222:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115227:	b8 00 00 00 00       	mov    $0x0,%eax
f011522c:	89 d7                	mov    %edx,%edi
f011522e:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115230:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115233:	8b 40 10             	mov    0x10(%eax),%eax
f0115236:	83 ec 08             	sub    $0x8,%esp
f0115239:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f011523f:	52                   	push   %edx
f0115240:	50                   	push   %eax
f0115241:	e8 28 ae 00 00       	call   f012006e <ltostr>
f0115246:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115249:	83 ec 04             	sub    $0x4,%esp
f011524c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115252:	50                   	push   %eax
f0115253:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115259:	50                   	push   %eax
f011525a:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0115260:	50                   	push   %eax
f0115261:	e8 e1 ae 00 00       	call   f0120147 <strcconcat>
f0115266:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115269:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0115270:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115277:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f011527e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0115285:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0115289:	83 ec 0c             	sub    $0xc,%esp
f011528c:	ff 75 d8             	pushl  -0x28(%ebp)
f011528f:	e8 0e 17 00 00       	call   f01169a2 <ClearUserSpace>
f0115294:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115297:	83 ec 0c             	sub    $0xc,%esp
f011529a:	68 88 a9 12 f0       	push   $0xf012a988
f011529f:	e8 e7 bc fe ff       	call   f0100f8b <cprintf>
f01152a4:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f01152a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01152aa:	c1 e0 03             	shl    $0x3,%eax
f01152ad:	83 ec 04             	sub    $0x4,%esp
f01152b0:	50                   	push   %eax
f01152b1:	6a 00                	push   $0x0
f01152b3:	ff 75 d8             	pushl  -0x28(%ebp)
f01152b6:	e8 13 58 ff ff       	call   f010aace <calculate_required_frames>
f01152bb:	83 c4 10             	add    $0x10,%esp
f01152be:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01152c1:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01152c5:	74 23                	je     f01152ea <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01152c7:	83 ec 0c             	sub    $0xc,%esp
f01152ca:	6a 03                	push   $0x3
f01152cc:	ff 75 c8             	pushl  -0x38(%ebp)
f01152cf:	68 bc a9 12 f0       	push   $0xf012a9bc
f01152d4:	68 29 06 00 00       	push   $0x629
f01152d9:	68 42 91 12 f0       	push   $0xf0129142
f01152de:	e8 f3 b1 fe ff       	call   f01004d6 <_warn>
f01152e3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152e6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01152ea:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01152ee:	74 04                	je     f01152f4 <test_calculate_required_frames+0x145>
f01152f0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01152f4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f01152f8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01152fb:	c1 e0 02             	shl    $0x2,%eax
f01152fe:	83 ec 04             	sub    $0x4,%esp
f0115301:	50                   	push   %eax
f0115302:	6a 00                	push   $0x0
f0115304:	ff 75 d8             	pushl  -0x28(%ebp)
f0115307:	e8 c2 57 ff ff       	call   f010aace <calculate_required_frames>
f011530c:	83 c4 10             	add    $0x10,%esp
f011530f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0115312:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0115319:	74 26                	je     f0115341 <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f011531b:	83 ec 0c             	sub    $0xc,%esp
f011531e:	68 01 04 00 00       	push   $0x401
f0115323:	ff 75 c8             	pushl  -0x38(%ebp)
f0115326:	68 bc a9 12 f0       	push   $0xf012a9bc
f011532b:	68 33 06 00 00       	push   $0x633
f0115330:	68 42 91 12 f0       	push   $0xf0129142
f0115335:	e8 9c b1 fe ff       	call   f01004d6 <_warn>
f011533a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011533d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115341:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115345:	74 04                	je     f011534b <test_calculate_required_frames+0x19c>
f0115347:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011534b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f011534f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115352:	c1 e0 0a             	shl    $0xa,%eax
f0115355:	83 ec 04             	sub    $0x4,%esp
f0115358:	50                   	push   %eax
f0115359:	6a 00                	push   $0x0
f011535b:	ff 75 d8             	pushl  -0x28(%ebp)
f011535e:	e8 6b 57 ff ff       	call   f010aace <calculate_required_frames>
f0115363:	83 c4 10             	add    $0x10,%esp
f0115366:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0115369:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011536c:	c1 e0 0a             	shl    $0xa,%eax
f011536f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115372:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115379:	99                   	cltd   
f011537a:	f7 fb                	idiv   %ebx
f011537c:	89 c1                	mov    %eax,%ecx
f011537e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115381:	c1 e0 0a             	shl    $0xa,%eax
f0115384:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115387:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011538e:	99                   	cltd   
f011538f:	f7 fe                	idiv   %esi
f0115391:	01 c8                	add    %ecx,%eax
f0115393:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115396:	74 4c                	je     f01153e4 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0115398:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011539b:	c1 e0 0a             	shl    $0xa,%eax
f011539e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01153a1:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01153a8:	99                   	cltd   
f01153a9:	f7 fb                	idiv   %ebx
f01153ab:	89 c1                	mov    %eax,%ecx
f01153ad:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01153b0:	c1 e0 0a             	shl    $0xa,%eax
f01153b3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01153b6:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01153bd:	99                   	cltd   
f01153be:	f7 fe                	idiv   %esi
f01153c0:	01 c8                	add    %ecx,%eax
f01153c2:	83 ec 0c             	sub    $0xc,%esp
f01153c5:	50                   	push   %eax
f01153c6:	ff 75 c8             	pushl  -0x38(%ebp)
f01153c9:	68 bc a9 12 f0       	push   $0xf012a9bc
f01153ce:	68 3d 06 00 00       	push   $0x63d
f01153d3:	68 42 91 12 f0       	push   $0xf0129142
f01153d8:	e8 f9 b0 fe ff       	call   f01004d6 <_warn>
f01153dd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153e0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01153e4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01153e8:	74 04                	je     f01153ee <test_calculate_required_frames+0x23f>
f01153ea:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01153ee:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f01153f2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01153f5:	89 d0                	mov    %edx,%eax
f01153f7:	01 c0                	add    %eax,%eax
f01153f9:	01 d0                	add    %edx,%eax
f01153fb:	01 c0                	add    %eax,%eax
f01153fd:	83 ec 04             	sub    $0x4,%esp
f0115400:	50                   	push   %eax
f0115401:	68 00 10 00 00       	push   $0x1000
f0115406:	ff 75 d8             	pushl  -0x28(%ebp)
f0115409:	e8 c0 56 ff ff       	call   f010aace <calculate_required_frames>
f011540e:	83 c4 10             	add    $0x10,%esp
f0115411:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115414:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115418:	74 23                	je     f011543d <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011541a:	83 ec 0c             	sub    $0xc,%esp
f011541d:	6a 03                	push   $0x3
f011541f:	ff 75 c8             	pushl  -0x38(%ebp)
f0115422:	68 bc a9 12 f0       	push   $0xf012a9bc
f0115427:	68 49 06 00 00       	push   $0x649
f011542c:	68 42 91 12 f0       	push   $0xf0129142
f0115431:	e8 a0 b0 fe ff       	call   f01004d6 <_warn>
f0115436:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115439:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011543d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115441:	74 04                	je     f0115447 <test_calculate_required_frames+0x298>
f0115443:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115447:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f011544b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011544e:	89 c2                	mov    %eax,%edx
f0115450:	01 d2                	add    %edx,%edx
f0115452:	01 d0                	add    %edx,%eax
f0115454:	83 ec 04             	sub    $0x4,%esp
f0115457:	50                   	push   %eax
f0115458:	68 00 18 00 00       	push   $0x1800
f011545d:	ff 75 d8             	pushl  -0x28(%ebp)
f0115460:	e8 69 56 ff ff       	call   f010aace <calculate_required_frames>
f0115465:	83 c4 10             	add    $0x10,%esp
f0115468:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f011546b:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011546f:	74 23                	je     f0115494 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115471:	83 ec 0c             	sub    $0xc,%esp
f0115474:	6a 03                	push   $0x3
f0115476:	ff 75 c8             	pushl  -0x38(%ebp)
f0115479:	68 bc a9 12 f0       	push   $0xf012a9bc
f011547e:	68 53 06 00 00       	push   $0x653
f0115483:	68 42 91 12 f0       	push   $0xf0129142
f0115488:	e8 49 b0 fe ff       	call   f01004d6 <_warn>
f011548d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115490:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115494:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115498:	74 04                	je     f011549e <test_calculate_required_frames+0x2ef>
f011549a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011549e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01154a2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01154a5:	89 d0                	mov    %edx,%eax
f01154a7:	c1 e0 02             	shl    $0x2,%eax
f01154aa:	01 d0                	add    %edx,%eax
f01154ac:	01 c0                	add    %eax,%eax
f01154ae:	83 ec 04             	sub    $0x4,%esp
f01154b1:	50                   	push   %eax
f01154b2:	68 00 00 40 00       	push   $0x400000
f01154b7:	ff 75 d8             	pushl  -0x28(%ebp)
f01154ba:	e8 0f 56 ff ff       	call   f010aace <calculate_required_frames>
f01154bf:	83 c4 10             	add    $0x10,%esp
f01154c2:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f01154c5:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f01154cc:	74 26                	je     f01154f4 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01154ce:	83 ec 0c             	sub    $0xc,%esp
f01154d1:	68 03 0a 00 00       	push   $0xa03
f01154d6:	ff 75 c8             	pushl  -0x38(%ebp)
f01154d9:	68 bc a9 12 f0       	push   $0xf012a9bc
f01154de:	68 5d 06 00 00       	push   $0x65d
f01154e3:	68 42 91 12 f0       	push   $0xf0129142
f01154e8:	e8 e9 af fe ff       	call   f01004d6 <_warn>
f01154ed:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01154f0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01154f4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01154f8:	74 04                	je     f01154fe <test_calculate_required_frames+0x34f>
f01154fa:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01154fe:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115502:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115505:	01 c0                	add    %eax,%eax
f0115507:	83 ec 04             	sub    $0x4,%esp
f011550a:	50                   	push   %eax
f011550b:	68 00 00 70 00       	push   $0x700000
f0115510:	ff 75 d8             	pushl  -0x28(%ebp)
f0115513:	e8 b6 55 ff ff       	call   f010aace <calculate_required_frames>
f0115518:	83 c4 10             	add    $0x10,%esp
f011551b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f011551e:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0115525:	74 26                	je     f011554d <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0115527:	83 ec 0c             	sub    $0xc,%esp
f011552a:	68 02 02 00 00       	push   $0x202
f011552f:	ff 75 c8             	pushl  -0x38(%ebp)
f0115532:	68 bc a9 12 f0       	push   $0xf012a9bc
f0115537:	68 69 06 00 00       	push   $0x669
f011553c:	68 42 91 12 f0       	push   $0xf0129142
f0115541:	e8 90 af fe ff       	call   f01004d6 <_warn>
f0115546:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115549:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011554d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115551:	74 04                	je     f0115557 <test_calculate_required_frames+0x3a8>
f0115553:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115557:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f011555b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011555e:	83 ec 04             	sub    $0x4,%esp
f0115561:	50                   	push   %eax
f0115562:	68 ff ff 3f 00       	push   $0x3fffff
f0115567:	ff 75 d8             	pushl  -0x28(%ebp)
f011556a:	e8 5f 55 ff ff       	call   f010aace <calculate_required_frames>
f011556f:	83 c4 10             	add    $0x10,%esp
f0115572:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0115575:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0115579:	74 23                	je     f011559e <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f011557b:	83 ec 0c             	sub    $0xc,%esp
f011557e:	6a 04                	push   $0x4
f0115580:	ff 75 c8             	pushl  -0x38(%ebp)
f0115583:	68 bc a9 12 f0       	push   $0xf012a9bc
f0115588:	68 73 06 00 00       	push   $0x673
f011558d:	68 42 91 12 f0       	push   $0xf0129142
f0115592:	e8 3f af fe ff       	call   f01004d6 <_warn>
f0115597:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011559a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011559e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01155a2:	74 04                	je     f01155a8 <test_calculate_required_frames+0x3f9>
f01155a4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01155a8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f01155ac:	83 ec 0c             	sub    $0xc,%esp
f01155af:	68 f5 a4 12 f0       	push   $0xf012a4f5
f01155b4:	e8 d2 b9 fe ff       	call   f0100f8b <cprintf>
f01155b9:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f01155bc:	83 ec 0c             	sub    $0xc,%esp
f01155bf:	68 14 aa 12 f0       	push   $0xf012aa14
f01155c4:	e8 c2 b9 fe ff       	call   f0100f8b <cprintf>
f01155c9:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01155cc:	83 ec 04             	sub    $0x4,%esp
f01155cf:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f01155d5:	50                   	push   %eax
f01155d6:	68 ae 98 12 f0       	push   $0xf01298ae
f01155db:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01155e1:	50                   	push   %eax
f01155e2:	e8 60 ab 00 00       	call   f0120147 <strcconcat>
f01155e7:	83 c4 10             	add    $0x10,%esp
f01155ea:	83 ec 0c             	sub    $0xc,%esp
f01155ed:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f01155f3:	50                   	push   %eax
f01155f4:	e8 02 c9 fe ff       	call   f0101efb <execute_command>
f01155f9:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f01155fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01155ff:	c1 e0 03             	shl    $0x3,%eax
f0115602:	83 ec 04             	sub    $0x4,%esp
f0115605:	50                   	push   %eax
f0115606:	6a 00                	push   $0x0
f0115608:	ff 75 d8             	pushl  -0x28(%ebp)
f011560b:	e8 be 54 ff ff       	call   f010aace <calculate_required_frames>
f0115610:	83 c4 10             	add    $0x10,%esp
f0115613:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115616:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f011561d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115620:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115623:	74 24                	je     f0115649 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115625:	83 ec 0c             	sub    $0xc,%esp
f0115628:	ff 75 c4             	pushl  -0x3c(%ebp)
f011562b:	ff 75 c8             	pushl  -0x38(%ebp)
f011562e:	68 bc a9 12 f0       	push   $0xf012a9bc
f0115633:	68 87 06 00 00       	push   $0x687
f0115638:	68 42 91 12 f0       	push   $0xf0129142
f011563d:	e8 94 ae fe ff       	call   f01004d6 <_warn>
f0115642:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115645:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115649:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011564d:	74 04                	je     f0115653 <test_calculate_required_frames+0x4a4>
f011564f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115653:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115657:	83 ec 04             	sub    $0x4,%esp
f011565a:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115660:	50                   	push   %eax
f0115661:	68 bb 98 12 f0       	push   $0xf01298bb
f0115666:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011566c:	50                   	push   %eax
f011566d:	e8 d5 aa 00 00       	call   f0120147 <strcconcat>
f0115672:	83 c4 10             	add    $0x10,%esp
f0115675:	83 ec 0c             	sub    $0xc,%esp
f0115678:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011567e:	50                   	push   %eax
f011567f:	e8 77 c8 fe ff       	call   f0101efb <execute_command>
f0115684:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115687:	83 ec 04             	sub    $0x4,%esp
f011568a:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115690:	50                   	push   %eax
f0115691:	68 48 aa 12 f0       	push   $0xf012aa48
f0115696:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011569c:	50                   	push   %eax
f011569d:	e8 a5 aa 00 00       	call   f0120147 <strcconcat>
f01156a2:	83 c4 10             	add    $0x10,%esp
f01156a5:	83 ec 0c             	sub    $0xc,%esp
f01156a8:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01156ae:	50                   	push   %eax
f01156af:	e8 47 c8 fe ff       	call   f0101efb <execute_command>
f01156b4:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f01156b7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01156ba:	c1 e0 03             	shl    $0x3,%eax
f01156bd:	83 ec 04             	sub    $0x4,%esp
f01156c0:	50                   	push   %eax
f01156c1:	6a 00                	push   $0x0
f01156c3:	ff 75 d8             	pushl  -0x28(%ebp)
f01156c6:	e8 03 54 ff ff       	call   f010aace <calculate_required_frames>
f01156cb:	83 c4 10             	add    $0x10,%esp
f01156ce:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f01156d1:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f01156d8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01156db:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01156de:	74 24                	je     f0115704 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01156e0:	83 ec 0c             	sub    $0xc,%esp
f01156e3:	ff 75 c4             	pushl  -0x3c(%ebp)
f01156e6:	ff 75 c8             	pushl  -0x38(%ebp)
f01156e9:	68 bc a9 12 f0       	push   $0xf012a9bc
f01156ee:	68 95 06 00 00       	push   $0x695
f01156f3:	68 42 91 12 f0       	push   $0xf0129142
f01156f8:	e8 d9 ad fe ff       	call   f01004d6 <_warn>
f01156fd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115700:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115704:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115708:	74 04                	je     f011570e <test_calculate_required_frames+0x55f>
f011570a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011570e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115712:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115715:	c1 e0 0a             	shl    $0xa,%eax
f0115718:	83 ec 04             	sub    $0x4,%esp
f011571b:	50                   	push   %eax
f011571c:	6a 00                	push   $0x0
f011571e:	ff 75 d8             	pushl  -0x28(%ebp)
f0115721:	e8 a8 53 ff ff       	call   f010aace <calculate_required_frames>
f0115726:	83 c4 10             	add    $0x10,%esp
f0115729:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f011572c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011572f:	c1 e0 0a             	shl    $0xa,%eax
f0115732:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115735:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011573c:	99                   	cltd   
f011573d:	f7 fb                	idiv   %ebx
f011573f:	89 c1                	mov    %eax,%ecx
f0115741:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115744:	c1 e0 0a             	shl    $0xa,%eax
f0115747:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011574a:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115751:	99                   	cltd   
f0115752:	f7 fe                	idiv   %esi
f0115754:	01 c8                	add    %ecx,%eax
f0115756:	83 e8 05             	sub    $0x5,%eax
f0115759:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f011575c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011575f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115762:	74 24                	je     f0115788 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115764:	83 ec 0c             	sub    $0xc,%esp
f0115767:	ff 75 c4             	pushl  -0x3c(%ebp)
f011576a:	ff 75 c8             	pushl  -0x38(%ebp)
f011576d:	68 bc a9 12 f0       	push   $0xf012a9bc
f0115772:	68 a0 06 00 00       	push   $0x6a0
f0115777:	68 42 91 12 f0       	push   $0xf0129142
f011577c:	e8 55 ad fe ff       	call   f01004d6 <_warn>
f0115781:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115784:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115788:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011578c:	74 04                	je     f0115792 <test_calculate_required_frames+0x5e3>
f011578e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115792:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115796:	83 ec 04             	sub    $0x4,%esp
f0115799:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011579f:	50                   	push   %eax
f01157a0:	68 54 aa 12 f0       	push   $0xf012aa54
f01157a5:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01157ab:	50                   	push   %eax
f01157ac:	e8 96 a9 00 00       	call   f0120147 <strcconcat>
f01157b1:	83 c4 10             	add    $0x10,%esp
f01157b4:	83 ec 0c             	sub    $0xc,%esp
f01157b7:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01157bd:	50                   	push   %eax
f01157be:	e8 38 c7 fe ff       	call   f0101efb <execute_command>
f01157c3:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01157c6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01157c9:	89 c2                	mov    %eax,%edx
f01157cb:	01 d2                	add    %edx,%edx
f01157cd:	01 d0                	add    %edx,%eax
f01157cf:	83 ec 04             	sub    $0x4,%esp
f01157d2:	50                   	push   %eax
f01157d3:	68 00 18 00 00       	push   $0x1800
f01157d8:	ff 75 d8             	pushl  -0x28(%ebp)
f01157db:	e8 ee 52 ff ff       	call   f010aace <calculate_required_frames>
f01157e0:	83 c4 10             	add    $0x10,%esp
f01157e3:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01157e6:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01157ed:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01157f0:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01157f3:	74 24                	je     f0115819 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01157f5:	83 ec 0c             	sub    $0xc,%esp
f01157f8:	ff 75 c4             	pushl  -0x3c(%ebp)
f01157fb:	ff 75 c8             	pushl  -0x38(%ebp)
f01157fe:	68 bc a9 12 f0       	push   $0xf012a9bc
f0115803:	68 af 06 00 00       	push   $0x6af
f0115808:	68 42 91 12 f0       	push   $0xf0129142
f011580d:	e8 c4 ac fe ff       	call   f01004d6 <_warn>
f0115812:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115815:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115819:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011581d:	74 04                	je     f0115823 <test_calculate_required_frames+0x674>
f011581f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115823:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115827:	83 ec 04             	sub    $0x4,%esp
f011582a:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115830:	50                   	push   %eax
f0115831:	68 14 9b 12 f0       	push   $0xf0129b14
f0115836:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011583c:	50                   	push   %eax
f011583d:	e8 05 a9 00 00       	call   f0120147 <strcconcat>
f0115842:	83 c4 10             	add    $0x10,%esp
f0115845:	83 ec 0c             	sub    $0xc,%esp
f0115848:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011584e:	50                   	push   %eax
f011584f:	e8 a7 c6 fe ff       	call   f0101efb <execute_command>
f0115854:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115857:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011585a:	89 d0                	mov    %edx,%eax
f011585c:	c1 e0 02             	shl    $0x2,%eax
f011585f:	01 d0                	add    %edx,%eax
f0115861:	01 c0                	add    %eax,%eax
f0115863:	83 ec 04             	sub    $0x4,%esp
f0115866:	50                   	push   %eax
f0115867:	68 00 00 40 00       	push   $0x400000
f011586c:	ff 75 d8             	pushl  -0x28(%ebp)
f011586f:	e8 5a 52 ff ff       	call   f010aace <calculate_required_frames>
f0115874:	83 c4 10             	add    $0x10,%esp
f0115877:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f011587a:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f0115881:	74 26                	je     f01158a9 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115883:	83 ec 0c             	sub    $0xc,%esp
f0115886:	68 03 0a 00 00       	push   $0xa03
f011588b:	ff 75 c8             	pushl  -0x38(%ebp)
f011588e:	68 bc a9 12 f0       	push   $0xf012a9bc
f0115893:	68 bb 06 00 00       	push   $0x6bb
f0115898:	68 42 91 12 f0       	push   $0xf0129142
f011589d:	e8 34 ac fe ff       	call   f01004d6 <_warn>
f01158a2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158a5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01158a9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01158ad:	74 04                	je     f01158b3 <test_calculate_required_frames+0x704>
f01158af:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01158b3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01158b7:	83 ec 04             	sub    $0x4,%esp
f01158ba:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01158c0:	50                   	push   %eax
f01158c1:	68 1e 9b 12 f0       	push   $0xf0129b1e
f01158c6:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01158cc:	50                   	push   %eax
f01158cd:	e8 75 a8 00 00       	call   f0120147 <strcconcat>
f01158d2:	83 c4 10             	add    $0x10,%esp
f01158d5:	83 ec 0c             	sub    $0xc,%esp
f01158d8:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01158de:	50                   	push   %eax
f01158df:	e8 17 c6 fe ff       	call   f0101efb <execute_command>
f01158e4:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01158e7:	83 ec 04             	sub    $0x4,%esp
f01158ea:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01158f0:	50                   	push   %eax
f01158f1:	68 5c aa 12 f0       	push   $0xf012aa5c
f01158f6:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01158fc:	50                   	push   %eax
f01158fd:	e8 45 a8 00 00       	call   f0120147 <strcconcat>
f0115902:	83 c4 10             	add    $0x10,%esp
f0115905:	83 ec 0c             	sub    $0xc,%esp
f0115908:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011590e:	50                   	push   %eax
f011590f:	e8 e7 c5 fe ff       	call   f0101efb <execute_command>
f0115914:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115917:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011591a:	01 c0                	add    %eax,%eax
f011591c:	83 ec 04             	sub    $0x4,%esp
f011591f:	50                   	push   %eax
f0115920:	68 00 00 70 00       	push   $0x700000
f0115925:	ff 75 d8             	pushl  -0x28(%ebp)
f0115928:	e8 a1 51 ff ff       	call   f010aace <calculate_required_frames>
f011592d:	83 c4 10             	add    $0x10,%esp
f0115930:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f0115933:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f011593a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011593d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115940:	74 24                	je     f0115966 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115942:	83 ec 0c             	sub    $0xc,%esp
f0115945:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115948:	ff 75 c8             	pushl  -0x38(%ebp)
f011594b:	68 bc a9 12 f0       	push   $0xf012a9bc
f0115950:	68 cb 06 00 00       	push   $0x6cb
f0115955:	68 42 91 12 f0       	push   $0xf0129142
f011595a:	e8 77 ab fe ff       	call   f01004d6 <_warn>
f011595f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115962:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115966:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011596a:	74 04                	je     f0115970 <test_calculate_required_frames+0x7c1>
f011596c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115970:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115974:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115977:	83 ec 04             	sub    $0x4,%esp
f011597a:	50                   	push   %eax
f011597b:	68 ff ff 3f 00       	push   $0x3fffff
f0115980:	ff 75 d8             	pushl  -0x28(%ebp)
f0115983:	e8 46 51 ff ff       	call   f010aace <calculate_required_frames>
f0115988:	83 c4 10             	add    $0x10,%esp
f011598b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f011598e:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0115995:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115998:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011599b:	74 24                	je     f01159c1 <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011599d:	83 ec 0c             	sub    $0xc,%esp
f01159a0:	ff 75 c4             	pushl  -0x3c(%ebp)
f01159a3:	ff 75 c8             	pushl  -0x38(%ebp)
f01159a6:	68 bc a9 12 f0       	push   $0xf012a9bc
f01159ab:	68 d6 06 00 00       	push   $0x6d6
f01159b0:	68 42 91 12 f0       	push   $0xf0129142
f01159b5:	e8 1c ab fe ff       	call   f01004d6 <_warn>
f01159ba:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159bd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01159c1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159c5:	74 04                	je     f01159cb <test_calculate_required_frames+0x81c>
f01159c7:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01159cb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01159cf:	83 ec 0c             	sub    $0xc,%esp
f01159d2:	68 cf 9a 12 f0       	push   $0xf0129acf
f01159d7:	e8 af b5 fe ff       	call   f0100f8b <cprintf>
f01159dc:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f01159df:	83 ec 08             	sub    $0x8,%esp
f01159e2:	ff 75 e4             	pushl  -0x1c(%ebp)
f01159e5:	68 68 aa 12 f0       	push   $0xf012aa68
f01159ea:	e8 9c b5 fe ff       	call   f0100f8b <cprintf>
f01159ef:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01159f2:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01159f6:	75 10                	jne    f0115a08 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f01159f8:	83 ec 0c             	sub    $0xc,%esp
f01159fb:	68 a8 aa 12 f0       	push   $0xf012aaa8
f0115a00:	e8 86 b5 fe ff       	call   f0100f8b <cprintf>
f0115a05:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115a08:	a1 c4 0d 6c f0       	mov    0xf06c0dc4,%eax
f0115a0d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0115a10:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115a13:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115a16:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115a1b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115a1e:	5b                   	pop    %ebx
f0115a1f:	5e                   	pop    %esi
f0115a20:	5f                   	pop    %edi
f0115a21:	5d                   	pop    %ebp
f0115a22:	c3                   	ret    

f0115a23 <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0115a23:	55                   	push   %ebp
f0115a24:	89 e5                	mov    %esp,%ebp
f0115a26:	57                   	push   %edi
f0115a27:	56                   	push   %esi
f0115a28:	53                   	push   %ebx
f0115a29:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115a2f:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115a32:	bb 44 98 12 f0       	mov    $0xf0129844,%ebx
f0115a37:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115a3c:	89 c7                	mov    %eax,%edi
f0115a3e:	89 de                	mov    %ebx,%esi
f0115a40:	89 d1                	mov    %edx,%ecx
f0115a42:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115a44:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115a47:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115a4c:	b0 00                	mov    $0x0,%al
f0115a4e:	89 d7                	mov    %edx,%edi
f0115a50:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115a52:	6a 00                	push   $0x0
f0115a54:	6a 0a                	push   $0xa
f0115a56:	6a 14                	push   $0x14
f0115a58:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115a5b:	50                   	push   %eax
f0115a5c:	e8 ac 54 ff ff       	call   f010af0d <env_create>
f0115a61:	83 c4 10             	add    $0x10,%esp
f0115a64:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115a67:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115a6a:	8b 40 64             	mov    0x64(%eax),%eax
f0115a6d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115a70:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115a73:	8b 40 68             	mov    0x68(%eax),%eax
f0115a76:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115a79:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115a7c:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0115a7f:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115a86:	75 70 20 
f0115a89:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115a90:	00 00 00 
f0115a93:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115a96:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115a9b:	b8 00 00 00 00       	mov    $0x0,%eax
f0115aa0:	89 d7                	mov    %edx,%edi
f0115aa2:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115aa4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115aa7:	8b 40 10             	mov    0x10(%eax),%eax
f0115aaa:	83 ec 08             	sub    $0x8,%esp
f0115aad:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115ab3:	52                   	push   %edx
f0115ab4:	50                   	push   %eax
f0115ab5:	e8 b4 a5 00 00       	call   f012006e <ltostr>
f0115aba:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115abd:	83 ec 04             	sub    $0x4,%esp
f0115ac0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115ac6:	50                   	push   %eax
f0115ac7:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115acd:	50                   	push   %eax
f0115ace:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0115ad4:	50                   	push   %eax
f0115ad5:	e8 6d a6 00 00       	call   f0120147 <strcconcat>
f0115ada:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115add:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0115ae4:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115aeb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0115af2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0115af6:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115afd:	00 00 00 
	uint32 num_tables = 0;
f0115b00:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115b07:	00 00 00 
	ClearUserSpace(proc_directory);
f0115b0a:	83 ec 0c             	sub    $0xc,%esp
f0115b0d:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b10:	e8 8d 0e 00 00       	call   f01169a2 <ClearUserSpace>
f0115b15:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115b18:	83 ec 0c             	sub    $0xc,%esp
f0115b1b:	68 88 a9 12 f0       	push   $0xf012a988
f0115b20:	e8 66 b4 fe ff       	call   f0100f8b <cprintf>
f0115b25:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115b28:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115b2b:	c1 e0 03             	shl    $0x3,%eax
f0115b2e:	89 c2                	mov    %eax,%edx
f0115b30:	83 ec 0c             	sub    $0xc,%esp
f0115b33:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115b39:	50                   	push   %eax
f0115b3a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115b40:	50                   	push   %eax
f0115b41:	52                   	push   %edx
f0115b42:	6a 00                	push   $0x0
f0115b44:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b47:	e8 68 4f ff ff       	call   f010aab4 <calculate_allocated_space>
f0115b4c:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115b4f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b55:	85 c0                	test   %eax,%eax
f0115b57:	74 27                	je     f0115b80 <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115b59:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b5f:	83 ec 0c             	sub    $0xc,%esp
f0115b62:	6a 00                	push   $0x0
f0115b64:	50                   	push   %eax
f0115b65:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0115b6a:	68 0b 07 00 00       	push   $0x70b
f0115b6f:	68 42 91 12 f0       	push   $0xf0129142
f0115b74:	e8 5d a9 fe ff       	call   f01004d6 <_warn>
f0115b79:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b7c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115b80:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115b86:	85 c0                	test   %eax,%eax
f0115b88:	74 27                	je     f0115bb1 <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115b8a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115b90:	83 ec 0c             	sub    $0xc,%esp
f0115b93:	6a 00                	push   $0x0
f0115b95:	50                   	push   %eax
f0115b96:	68 54 ab 12 f0       	push   $0xf012ab54
f0115b9b:	68 10 07 00 00       	push   $0x710
f0115ba0:	68 42 91 12 f0       	push   $0xf0129142
f0115ba5:	e8 2c a9 fe ff       	call   f01004d6 <_warn>
f0115baa:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115bad:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115bb1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115bb5:	74 04                	je     f0115bbb <test_calculate_allocated_space+0x198>
f0115bb7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115bbb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0115bbf:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115bc6:	00 00 00 
		num_pages = 0;
f0115bc9:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115bd0:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0115bd3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115bd6:	c1 e0 02             	shl    $0x2,%eax
f0115bd9:	89 c2                	mov    %eax,%edx
f0115bdb:	83 ec 0c             	sub    $0xc,%esp
f0115bde:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115be4:	50                   	push   %eax
f0115be5:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115beb:	50                   	push   %eax
f0115bec:	52                   	push   %edx
f0115bed:	6a 00                	push   $0x0
f0115bef:	ff 75 d8             	pushl  -0x28(%ebp)
f0115bf2:	e8 bd 4e ff ff       	call   f010aab4 <calculate_allocated_space>
f0115bf7:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115bfa:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c00:	85 c0                	test   %eax,%eax
f0115c02:	74 27                	je     f0115c2b <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115c04:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c0a:	83 ec 0c             	sub    $0xc,%esp
f0115c0d:	6a 00                	push   $0x0
f0115c0f:	50                   	push   %eax
f0115c10:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0115c15:	68 1c 07 00 00       	push   $0x71c
f0115c1a:	68 42 91 12 f0       	push   $0xf0129142
f0115c1f:	e8 b2 a8 fe ff       	call   f01004d6 <_warn>
f0115c24:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c27:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115c2b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c31:	85 c0                	test   %eax,%eax
f0115c33:	74 27                	je     f0115c5c <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115c35:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c3b:	83 ec 0c             	sub    $0xc,%esp
f0115c3e:	6a 00                	push   $0x0
f0115c40:	50                   	push   %eax
f0115c41:	68 54 ab 12 f0       	push   $0xf012ab54
f0115c46:	68 21 07 00 00       	push   $0x721
f0115c4b:	68 42 91 12 f0       	push   $0xf0129142
f0115c50:	e8 81 a8 fe ff       	call   f01004d6 <_warn>
f0115c55:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c58:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115c5c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115c60:	74 04                	je     f0115c66 <test_calculate_allocated_space+0x243>
f0115c62:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115c66:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115c6a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115c71:	00 00 00 
		num_pages = 0;
f0115c74:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115c7b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0115c7e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115c81:	c1 e0 0a             	shl    $0xa,%eax
f0115c84:	89 c2                	mov    %eax,%edx
f0115c86:	83 ec 0c             	sub    $0xc,%esp
f0115c89:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115c8f:	50                   	push   %eax
f0115c90:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115c96:	50                   	push   %eax
f0115c97:	52                   	push   %edx
f0115c98:	6a 00                	push   $0x0
f0115c9a:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c9d:	e8 12 4e ff ff       	call   f010aab4 <calculate_allocated_space>
f0115ca2:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115ca5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115cab:	85 c0                	test   %eax,%eax
f0115cad:	74 27                	je     f0115cd6 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115caf:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115cb5:	83 ec 0c             	sub    $0xc,%esp
f0115cb8:	6a 00                	push   $0x0
f0115cba:	50                   	push   %eax
f0115cbb:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0115cc0:	68 2d 07 00 00       	push   $0x72d
f0115cc5:	68 42 91 12 f0       	push   $0xf0129142
f0115cca:	e8 07 a8 fe ff       	call   f01004d6 <_warn>
f0115ccf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115cd2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115cd6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115cdc:	85 c0                	test   %eax,%eax
f0115cde:	74 27                	je     f0115d07 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115ce0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115ce6:	83 ec 0c             	sub    $0xc,%esp
f0115ce9:	6a 00                	push   $0x0
f0115ceb:	50                   	push   %eax
f0115cec:	68 54 ab 12 f0       	push   $0xf012ab54
f0115cf1:	68 32 07 00 00       	push   $0x732
f0115cf6:	68 42 91 12 f0       	push   $0xf0129142
f0115cfb:	e8 d6 a7 fe ff       	call   f01004d6 <_warn>
f0115d00:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d03:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115d07:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d0b:	74 04                	je     f0115d11 <test_calculate_allocated_space+0x2ee>
f0115d0d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115d11:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0115d15:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115d1c:	00 00 00 
		num_pages = 0;
f0115d1f:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115d26:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0115d29:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115d2c:	89 d0                	mov    %edx,%eax
f0115d2e:	01 c0                	add    %eax,%eax
f0115d30:	01 d0                	add    %edx,%eax
f0115d32:	01 c0                	add    %eax,%eax
f0115d34:	05 00 10 00 00       	add    $0x1000,%eax
f0115d39:	89 c2                	mov    %eax,%edx
f0115d3b:	83 ec 0c             	sub    $0xc,%esp
f0115d3e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115d44:	50                   	push   %eax
f0115d45:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115d4b:	50                   	push   %eax
f0115d4c:	52                   	push   %edx
f0115d4d:	68 00 10 00 00       	push   $0x1000
f0115d52:	ff 75 d8             	pushl  -0x28(%ebp)
f0115d55:	e8 5a 4d ff ff       	call   f010aab4 <calculate_allocated_space>
f0115d5a:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115d5d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d63:	85 c0                	test   %eax,%eax
f0115d65:	74 27                	je     f0115d8e <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115d67:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d6d:	83 ec 0c             	sub    $0xc,%esp
f0115d70:	6a 00                	push   $0x0
f0115d72:	50                   	push   %eax
f0115d73:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0115d78:	68 3f 07 00 00       	push   $0x73f
f0115d7d:	68 42 91 12 f0       	push   $0xf0129142
f0115d82:	e8 4f a7 fe ff       	call   f01004d6 <_warn>
f0115d87:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d8a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115d8e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d94:	85 c0                	test   %eax,%eax
f0115d96:	74 27                	je     f0115dbf <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115d98:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d9e:	83 ec 0c             	sub    $0xc,%esp
f0115da1:	6a 00                	push   $0x0
f0115da3:	50                   	push   %eax
f0115da4:	68 54 ab 12 f0       	push   $0xf012ab54
f0115da9:	68 44 07 00 00       	push   $0x744
f0115dae:	68 42 91 12 f0       	push   $0xf0129142
f0115db3:	e8 1e a7 fe ff       	call   f01004d6 <_warn>
f0115db8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115dbb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115dbf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115dc3:	74 04                	je     f0115dc9 <test_calculate_allocated_space+0x3a6>
f0115dc5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115dc9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0115dcd:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115dd4:	00 00 00 
		num_pages = 0;
f0115dd7:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115dde:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0115de1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115de4:	89 c2                	mov    %eax,%edx
f0115de6:	01 d2                	add    %edx,%edx
f0115de8:	01 d0                	add    %edx,%eax
f0115dea:	05 00 18 00 00       	add    $0x1800,%eax
f0115def:	89 c2                	mov    %eax,%edx
f0115df1:	83 ec 0c             	sub    $0xc,%esp
f0115df4:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115dfa:	50                   	push   %eax
f0115dfb:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115e01:	50                   	push   %eax
f0115e02:	52                   	push   %edx
f0115e03:	68 00 18 00 00       	push   $0x1800
f0115e08:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e0b:	e8 a4 4c ff ff       	call   f010aab4 <calculate_allocated_space>
f0115e10:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115e13:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e19:	85 c0                	test   %eax,%eax
f0115e1b:	74 27                	je     f0115e44 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115e1d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e23:	83 ec 0c             	sub    $0xc,%esp
f0115e26:	6a 00                	push   $0x0
f0115e28:	50                   	push   %eax
f0115e29:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0115e2e:	68 50 07 00 00       	push   $0x750
f0115e33:	68 42 91 12 f0       	push   $0xf0129142
f0115e38:	e8 99 a6 fe ff       	call   f01004d6 <_warn>
f0115e3d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e40:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115e44:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e4a:	85 c0                	test   %eax,%eax
f0115e4c:	74 27                	je     f0115e75 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115e4e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e54:	83 ec 0c             	sub    $0xc,%esp
f0115e57:	6a 00                	push   $0x0
f0115e59:	50                   	push   %eax
f0115e5a:	68 54 ab 12 f0       	push   $0xf012ab54
f0115e5f:	68 55 07 00 00       	push   $0x755
f0115e64:	68 42 91 12 f0       	push   $0xf0129142
f0115e69:	e8 68 a6 fe ff       	call   f01004d6 <_warn>
f0115e6e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e71:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115e75:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e79:	74 04                	je     f0115e7f <test_calculate_allocated_space+0x45c>
f0115e7b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115e7f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0115e83:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115e8a:	00 00 00 
		num_pages = 0;
f0115e8d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115e94:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115e97:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115e9a:	89 d0                	mov    %edx,%eax
f0115e9c:	c1 e0 02             	shl    $0x2,%eax
f0115e9f:	01 d0                	add    %edx,%eax
f0115ea1:	01 c0                	add    %eax,%eax
f0115ea3:	05 00 00 40 00       	add    $0x400000,%eax
f0115ea8:	89 c2                	mov    %eax,%edx
f0115eaa:	83 ec 0c             	sub    $0xc,%esp
f0115ead:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115eb3:	50                   	push   %eax
f0115eb4:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115eba:	50                   	push   %eax
f0115ebb:	52                   	push   %edx
f0115ebc:	68 00 00 40 00       	push   $0x400000
f0115ec1:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ec4:	e8 eb 4b ff ff       	call   f010aab4 <calculate_allocated_space>
f0115ec9:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115ecc:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115ed2:	85 c0                	test   %eax,%eax
f0115ed4:	74 27                	je     f0115efd <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115ed6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115edc:	83 ec 0c             	sub    $0xc,%esp
f0115edf:	6a 00                	push   $0x0
f0115ee1:	50                   	push   %eax
f0115ee2:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0115ee7:	68 61 07 00 00       	push   $0x761
f0115eec:	68 42 91 12 f0       	push   $0xf0129142
f0115ef1:	e8 e0 a5 fe ff       	call   f01004d6 <_warn>
f0115ef6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ef9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115efd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f03:	85 c0                	test   %eax,%eax
f0115f05:	74 27                	je     f0115f2e <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115f07:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f0d:	83 ec 0c             	sub    $0xc,%esp
f0115f10:	6a 00                	push   $0x0
f0115f12:	50                   	push   %eax
f0115f13:	68 54 ab 12 f0       	push   $0xf012ab54
f0115f18:	68 66 07 00 00       	push   $0x766
f0115f1d:	68 42 91 12 f0       	push   $0xf0129142
f0115f22:	e8 af a5 fe ff       	call   f01004d6 <_warn>
f0115f27:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f2a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f2e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f32:	74 04                	je     f0115f38 <test_calculate_allocated_space+0x515>
f0115f34:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f38:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0115f3c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115f43:	00 00 00 
		num_pages = 0;
f0115f46:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115f4d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0115f50:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115f53:	05 00 00 38 00       	add    $0x380000,%eax
f0115f58:	01 c0                	add    %eax,%eax
f0115f5a:	89 c2                	mov    %eax,%edx
f0115f5c:	83 ec 0c             	sub    $0xc,%esp
f0115f5f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115f65:	50                   	push   %eax
f0115f66:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115f6c:	50                   	push   %eax
f0115f6d:	52                   	push   %edx
f0115f6e:	68 00 00 70 00       	push   $0x700000
f0115f73:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f76:	e8 39 4b ff ff       	call   f010aab4 <calculate_allocated_space>
f0115f7b:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115f7e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f84:	85 c0                	test   %eax,%eax
f0115f86:	74 27                	je     f0115faf <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115f88:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f8e:	83 ec 0c             	sub    $0xc,%esp
f0115f91:	6a 00                	push   $0x0
f0115f93:	50                   	push   %eax
f0115f94:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0115f99:	68 73 07 00 00       	push   $0x773
f0115f9e:	68 42 91 12 f0       	push   $0xf0129142
f0115fa3:	e8 2e a5 fe ff       	call   f01004d6 <_warn>
f0115fa8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fab:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115faf:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115fb5:	85 c0                	test   %eax,%eax
f0115fb7:	74 27                	je     f0115fe0 <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115fb9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115fbf:	83 ec 0c             	sub    $0xc,%esp
f0115fc2:	6a 00                	push   $0x0
f0115fc4:	50                   	push   %eax
f0115fc5:	68 54 ab 12 f0       	push   $0xf012ab54
f0115fca:	68 78 07 00 00       	push   $0x778
f0115fcf:	68 42 91 12 f0       	push   $0xf0129142
f0115fd4:	e8 fd a4 fe ff       	call   f01004d6 <_warn>
f0115fd9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fdc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115fe0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115fe4:	74 04                	je     f0115fea <test_calculate_allocated_space+0x5c7>
f0115fe6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115fea:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0115fee:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115ff5:	00 00 00 
		num_pages = 0;
f0115ff8:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115fff:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116002:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116005:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f011600a:	89 c2                	mov    %eax,%edx
f011600c:	83 ec 0c             	sub    $0xc,%esp
f011600f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116015:	50                   	push   %eax
f0116016:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011601c:	50                   	push   %eax
f011601d:	52                   	push   %edx
f011601e:	68 ff ff 3f 00       	push   $0x3fffff
f0116023:	ff 75 d8             	pushl  -0x28(%ebp)
f0116026:	e8 89 4a ff ff       	call   f010aab4 <calculate_allocated_space>
f011602b:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011602e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116034:	85 c0                	test   %eax,%eax
f0116036:	74 27                	je     f011605f <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116038:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011603e:	83 ec 0c             	sub    $0xc,%esp
f0116041:	6a 00                	push   $0x0
f0116043:	50                   	push   %eax
f0116044:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0116049:	68 84 07 00 00       	push   $0x784
f011604e:	68 42 91 12 f0       	push   $0xf0129142
f0116053:	e8 7e a4 fe ff       	call   f01004d6 <_warn>
f0116058:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011605b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011605f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116065:	85 c0                	test   %eax,%eax
f0116067:	74 27                	je     f0116090 <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116069:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011606f:	83 ec 0c             	sub    $0xc,%esp
f0116072:	6a 00                	push   $0x0
f0116074:	50                   	push   %eax
f0116075:	68 54 ab 12 f0       	push   $0xf012ab54
f011607a:	68 89 07 00 00       	push   $0x789
f011607f:	68 42 91 12 f0       	push   $0xf0129142
f0116084:	e8 4d a4 fe ff       	call   f01004d6 <_warn>
f0116089:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011608c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116090:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116094:	74 04                	je     f011609a <test_calculate_allocated_space+0x677>
f0116096:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011609a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011609e:	83 ec 0c             	sub    $0xc,%esp
f01160a1:	68 f5 a4 12 f0       	push   $0xf012a4f5
f01160a6:	e8 e0 ae fe ff       	call   f0100f8b <cprintf>
f01160ab:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f01160ae:	83 ec 0c             	sub    $0xc,%esp
f01160b1:	68 14 aa 12 f0       	push   $0xf012aa14
f01160b6:	e8 d0 ae fe ff       	call   f0100f8b <cprintf>
f01160bb:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01160be:	83 ec 04             	sub    $0x4,%esp
f01160c1:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f01160c7:	50                   	push   %eax
f01160c8:	68 ae 98 12 f0       	push   $0xf01298ae
f01160cd:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01160d3:	50                   	push   %eax
f01160d4:	e8 6e a0 00 00       	call   f0120147 <strcconcat>
f01160d9:	83 c4 10             	add    $0x10,%esp
f01160dc:	83 ec 0c             	sub    $0xc,%esp
f01160df:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f01160e5:	50                   	push   %eax
f01160e6:	e8 10 be fe ff       	call   f0101efb <execute_command>
f01160eb:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f01160ee:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01160f5:	00 00 00 
		num_pages = 0;
f01160f8:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01160ff:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0116102:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116105:	c1 e0 03             	shl    $0x3,%eax
f0116108:	89 c2                	mov    %eax,%edx
f011610a:	83 ec 0c             	sub    $0xc,%esp
f011610d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116113:	50                   	push   %eax
f0116114:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011611a:	50                   	push   %eax
f011611b:	52                   	push   %edx
f011611c:	6a 00                	push   $0x0
f011611e:	ff 75 d8             	pushl  -0x28(%ebp)
f0116121:	e8 8e 49 ff ff       	call   f010aab4 <calculate_allocated_space>
f0116126:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0116129:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0116130:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116137:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011613d:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116140:	74 28                	je     f011616a <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116142:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116148:	83 ec 0c             	sub    $0xc,%esp
f011614b:	ff 75 c8             	pushl  -0x38(%ebp)
f011614e:	50                   	push   %eax
f011614f:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0116154:	68 a0 07 00 00       	push   $0x7a0
f0116159:	68 42 91 12 f0       	push   $0xf0129142
f011615e:	e8 73 a3 fe ff       	call   f01004d6 <_warn>
f0116163:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116166:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011616a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116170:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116173:	74 28                	je     f011619d <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116175:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011617b:	83 ec 0c             	sub    $0xc,%esp
f011617e:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116181:	50                   	push   %eax
f0116182:	68 54 ab 12 f0       	push   $0xf012ab54
f0116187:	68 a5 07 00 00       	push   $0x7a5
f011618c:	68 42 91 12 f0       	push   $0xf0129142
f0116191:	e8 40 a3 fe ff       	call   f01004d6 <_warn>
f0116196:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116199:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011619d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01161a1:	74 04                	je     f01161a7 <test_calculate_allocated_space+0x784>
f01161a3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01161a7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f01161ab:	83 ec 04             	sub    $0x4,%esp
f01161ae:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01161b4:	50                   	push   %eax
f01161b5:	68 bb 98 12 f0       	push   $0xf01298bb
f01161ba:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01161c0:	50                   	push   %eax
f01161c1:	e8 81 9f 00 00       	call   f0120147 <strcconcat>
f01161c6:	83 c4 10             	add    $0x10,%esp
f01161c9:	83 ec 0c             	sub    $0xc,%esp
f01161cc:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01161d2:	50                   	push   %eax
f01161d3:	e8 23 bd fe ff       	call   f0101efb <execute_command>
f01161d8:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f01161db:	83 ec 04             	sub    $0x4,%esp
f01161de:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01161e4:	50                   	push   %eax
f01161e5:	68 48 aa 12 f0       	push   $0xf012aa48
f01161ea:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01161f0:	50                   	push   %eax
f01161f1:	e8 51 9f 00 00       	call   f0120147 <strcconcat>
f01161f6:	83 c4 10             	add    $0x10,%esp
f01161f9:	83 ec 0c             	sub    $0xc,%esp
f01161fc:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116202:	50                   	push   %eax
f0116203:	e8 f3 bc fe ff       	call   f0101efb <execute_command>
f0116208:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f011620b:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116212:	00 00 00 
		num_pages = 0;
f0116215:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011621c:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f011621f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116222:	c1 e0 03             	shl    $0x3,%eax
f0116225:	89 c2                	mov    %eax,%edx
f0116227:	83 ec 0c             	sub    $0xc,%esp
f011622a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116230:	50                   	push   %eax
f0116231:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116237:	50                   	push   %eax
f0116238:	52                   	push   %edx
f0116239:	6a 00                	push   $0x0
f011623b:	ff 75 d8             	pushl  -0x28(%ebp)
f011623e:	e8 71 48 ff ff       	call   f010aab4 <calculate_allocated_space>
f0116243:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0116246:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f011624d:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116254:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011625a:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011625d:	74 28                	je     f0116287 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011625f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116265:	83 ec 0c             	sub    $0xc,%esp
f0116268:	ff 75 c8             	pushl  -0x38(%ebp)
f011626b:	50                   	push   %eax
f011626c:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0116271:	68 b6 07 00 00       	push   $0x7b6
f0116276:	68 42 91 12 f0       	push   $0xf0129142
f011627b:	e8 56 a2 fe ff       	call   f01004d6 <_warn>
f0116280:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116283:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116287:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011628d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116290:	74 28                	je     f01162ba <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116292:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116298:	83 ec 0c             	sub    $0xc,%esp
f011629b:	ff 75 c4             	pushl  -0x3c(%ebp)
f011629e:	50                   	push   %eax
f011629f:	68 54 ab 12 f0       	push   $0xf012ab54
f01162a4:	68 bb 07 00 00       	push   $0x7bb
f01162a9:	68 42 91 12 f0       	push   $0xf0129142
f01162ae:	e8 23 a2 fe ff       	call   f01004d6 <_warn>
f01162b3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01162b6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01162ba:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01162be:	74 04                	je     f01162c4 <test_calculate_allocated_space+0x8a1>
f01162c0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01162c4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f01162c8:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01162cf:	00 00 00 
		num_pages = 0;
f01162d2:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01162d9:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f01162dc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01162df:	c1 e0 0a             	shl    $0xa,%eax
f01162e2:	89 c2                	mov    %eax,%edx
f01162e4:	83 ec 0c             	sub    $0xc,%esp
f01162e7:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01162ed:	50                   	push   %eax
f01162ee:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01162f4:	50                   	push   %eax
f01162f5:	52                   	push   %edx
f01162f6:	6a 00                	push   $0x0
f01162f8:	ff 75 d8             	pushl  -0x28(%ebp)
f01162fb:	e8 b4 47 ff ff       	call   f010aab4 <calculate_allocated_space>
f0116300:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0116303:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f011630a:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116311:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116317:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011631a:	74 28                	je     f0116344 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011631c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116322:	83 ec 0c             	sub    $0xc,%esp
f0116325:	ff 75 c8             	pushl  -0x38(%ebp)
f0116328:	50                   	push   %eax
f0116329:	68 f4 aa 12 f0       	push   $0xf012aaf4
f011632e:	68 c9 07 00 00       	push   $0x7c9
f0116333:	68 42 91 12 f0       	push   $0xf0129142
f0116338:	e8 99 a1 fe ff       	call   f01004d6 <_warn>
f011633d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116340:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116344:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011634a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011634d:	74 28                	je     f0116377 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011634f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116355:	83 ec 0c             	sub    $0xc,%esp
f0116358:	ff 75 c4             	pushl  -0x3c(%ebp)
f011635b:	50                   	push   %eax
f011635c:	68 54 ab 12 f0       	push   $0xf012ab54
f0116361:	68 ce 07 00 00       	push   $0x7ce
f0116366:	68 42 91 12 f0       	push   $0xf0129142
f011636b:	e8 66 a1 fe ff       	call   f01004d6 <_warn>
f0116370:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116373:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116377:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011637b:	74 04                	je     f0116381 <test_calculate_allocated_space+0x95e>
f011637d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116381:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0116385:	83 ec 04             	sub    $0x4,%esp
f0116388:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011638e:	50                   	push   %eax
f011638f:	68 54 aa 12 f0       	push   $0xf012aa54
f0116394:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011639a:	50                   	push   %eax
f011639b:	e8 a7 9d 00 00       	call   f0120147 <strcconcat>
f01163a0:	83 c4 10             	add    $0x10,%esp
f01163a3:	83 ec 0c             	sub    $0xc,%esp
f01163a6:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01163ac:	50                   	push   %eax
f01163ad:	e8 49 bb fe ff       	call   f0101efb <execute_command>
f01163b2:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f01163b5:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01163bc:	00 00 00 
		num_pages = 0;
f01163bf:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01163c6:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f01163c9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01163cc:	89 c2                	mov    %eax,%edx
f01163ce:	01 d2                	add    %edx,%edx
f01163d0:	01 d0                	add    %edx,%eax
f01163d2:	05 00 18 00 00       	add    $0x1800,%eax
f01163d7:	89 c2                	mov    %eax,%edx
f01163d9:	83 ec 0c             	sub    $0xc,%esp
f01163dc:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01163e2:	50                   	push   %eax
f01163e3:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01163e9:	50                   	push   %eax
f01163ea:	52                   	push   %edx
f01163eb:	68 00 18 00 00       	push   $0x1800
f01163f0:	ff 75 d8             	pushl  -0x28(%ebp)
f01163f3:	e8 bc 46 ff ff       	call   f010aab4 <calculate_allocated_space>
f01163f8:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01163fb:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116402:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116409:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011640f:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116412:	74 28                	je     f011643c <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116414:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011641a:	83 ec 0c             	sub    $0xc,%esp
f011641d:	ff 75 c8             	pushl  -0x38(%ebp)
f0116420:	50                   	push   %eax
f0116421:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0116426:	68 df 07 00 00       	push   $0x7df
f011642b:	68 42 91 12 f0       	push   $0xf0129142
f0116430:	e8 a1 a0 fe ff       	call   f01004d6 <_warn>
f0116435:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116438:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011643c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116442:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116445:	74 28                	je     f011646f <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116447:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011644d:	83 ec 0c             	sub    $0xc,%esp
f0116450:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116453:	50                   	push   %eax
f0116454:	68 54 ab 12 f0       	push   $0xf012ab54
f0116459:	68 e4 07 00 00       	push   $0x7e4
f011645e:	68 42 91 12 f0       	push   $0xf0129142
f0116463:	e8 6e a0 fe ff       	call   f01004d6 <_warn>
f0116468:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011646b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011646f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116473:	74 04                	je     f0116479 <test_calculate_allocated_space+0xa56>
f0116475:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116479:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f011647d:	83 ec 04             	sub    $0x4,%esp
f0116480:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116486:	50                   	push   %eax
f0116487:	68 14 9b 12 f0       	push   $0xf0129b14
f011648c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116492:	50                   	push   %eax
f0116493:	e8 af 9c 00 00       	call   f0120147 <strcconcat>
f0116498:	83 c4 10             	add    $0x10,%esp
f011649b:	83 ec 0c             	sub    $0xc,%esp
f011649e:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01164a4:	50                   	push   %eax
f01164a5:	e8 51 ba fe ff       	call   f0101efb <execute_command>
f01164aa:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f01164ad:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01164b4:	00 00 00 
		num_pages = 0;
f01164b7:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01164be:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f01164c1:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01164c4:	89 d0                	mov    %edx,%eax
f01164c6:	c1 e0 02             	shl    $0x2,%eax
f01164c9:	01 d0                	add    %edx,%eax
f01164cb:	01 c0                	add    %eax,%eax
f01164cd:	05 00 00 40 00       	add    $0x400000,%eax
f01164d2:	89 c2                	mov    %eax,%edx
f01164d4:	83 ec 0c             	sub    $0xc,%esp
f01164d7:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01164dd:	50                   	push   %eax
f01164de:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01164e4:	50                   	push   %eax
f01164e5:	52                   	push   %edx
f01164e6:	68 00 00 40 00       	push   $0x400000
f01164eb:	ff 75 d8             	pushl  -0x28(%ebp)
f01164ee:	e8 c1 45 ff ff       	call   f010aab4 <calculate_allocated_space>
f01164f3:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01164f6:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f01164fd:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116504:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011650a:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011650d:	74 28                	je     f0116537 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011650f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116515:	83 ec 0c             	sub    $0xc,%esp
f0116518:	ff 75 c8             	pushl  -0x38(%ebp)
f011651b:	50                   	push   %eax
f011651c:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0116521:	68 f4 07 00 00       	push   $0x7f4
f0116526:	68 42 91 12 f0       	push   $0xf0129142
f011652b:	e8 a6 9f fe ff       	call   f01004d6 <_warn>
f0116530:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116533:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116537:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011653d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116540:	74 28                	je     f011656a <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116542:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116548:	83 ec 0c             	sub    $0xc,%esp
f011654b:	ff 75 c4             	pushl  -0x3c(%ebp)
f011654e:	50                   	push   %eax
f011654f:	68 54 ab 12 f0       	push   $0xf012ab54
f0116554:	68 f9 07 00 00       	push   $0x7f9
f0116559:	68 42 91 12 f0       	push   $0xf0129142
f011655e:	e8 73 9f fe ff       	call   f01004d6 <_warn>
f0116563:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116566:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011656a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011656e:	74 04                	je     f0116574 <test_calculate_allocated_space+0xb51>
f0116570:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116574:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0116578:	83 ec 04             	sub    $0x4,%esp
f011657b:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116581:	50                   	push   %eax
f0116582:	68 1e 9b 12 f0       	push   $0xf0129b1e
f0116587:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011658d:	50                   	push   %eax
f011658e:	e8 b4 9b 00 00       	call   f0120147 <strcconcat>
f0116593:	83 c4 10             	add    $0x10,%esp
f0116596:	83 ec 0c             	sub    $0xc,%esp
f0116599:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011659f:	50                   	push   %eax
f01165a0:	e8 56 b9 fe ff       	call   f0101efb <execute_command>
f01165a5:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01165a8:	83 ec 04             	sub    $0x4,%esp
f01165ab:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01165b1:	50                   	push   %eax
f01165b2:	68 5c aa 12 f0       	push   $0xf012aa5c
f01165b7:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01165bd:	50                   	push   %eax
f01165be:	e8 84 9b 00 00       	call   f0120147 <strcconcat>
f01165c3:	83 c4 10             	add    $0x10,%esp
f01165c6:	83 ec 0c             	sub    $0xc,%esp
f01165c9:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01165cf:	50                   	push   %eax
f01165d0:	e8 26 b9 fe ff       	call   f0101efb <execute_command>
f01165d5:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f01165d8:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01165df:	00 00 00 
		num_pages = 0;
f01165e2:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01165e9:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f01165ec:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01165ef:	05 00 00 38 00       	add    $0x380000,%eax
f01165f4:	01 c0                	add    %eax,%eax
f01165f6:	89 c2                	mov    %eax,%edx
f01165f8:	83 ec 0c             	sub    $0xc,%esp
f01165fb:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116601:	50                   	push   %eax
f0116602:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116608:	50                   	push   %eax
f0116609:	52                   	push   %edx
f011660a:	68 00 00 70 00       	push   $0x700000
f011660f:	ff 75 d8             	pushl  -0x28(%ebp)
f0116612:	e8 9d 44 ff ff       	call   f010aab4 <calculate_allocated_space>
f0116617:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011661a:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f0116621:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116628:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011662e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116631:	74 28                	je     f011665b <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116633:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116639:	83 ec 0c             	sub    $0xc,%esp
f011663c:	ff 75 c8             	pushl  -0x38(%ebp)
f011663f:	50                   	push   %eax
f0116640:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0116645:	68 0b 08 00 00       	push   $0x80b
f011664a:	68 42 91 12 f0       	push   $0xf0129142
f011664f:	e8 82 9e fe ff       	call   f01004d6 <_warn>
f0116654:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116657:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011665b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116661:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116664:	74 28                	je     f011668e <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116666:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011666c:	83 ec 0c             	sub    $0xc,%esp
f011666f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116672:	50                   	push   %eax
f0116673:	68 54 ab 12 f0       	push   $0xf012ab54
f0116678:	68 10 08 00 00       	push   $0x810
f011667d:	68 42 91 12 f0       	push   $0xf0129142
f0116682:	e8 4f 9e fe ff       	call   f01004d6 <_warn>
f0116687:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011668a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011668e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116692:	74 04                	je     f0116698 <test_calculate_allocated_space+0xc75>
f0116694:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116698:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f011669c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01166a3:	00 00 00 
		num_pages = 0;
f01166a6:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01166ad:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f01166b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01166b3:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01166b8:	89 c2                	mov    %eax,%edx
f01166ba:	83 ec 0c             	sub    $0xc,%esp
f01166bd:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01166c3:	50                   	push   %eax
f01166c4:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01166ca:	50                   	push   %eax
f01166cb:	52                   	push   %edx
f01166cc:	68 ff ff 3f 00       	push   $0x3fffff
f01166d1:	ff 75 d8             	pushl  -0x28(%ebp)
f01166d4:	e8 db 43 ff ff       	call   f010aab4 <calculate_allocated_space>
f01166d9:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01166dc:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f01166e3:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01166ea:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166f0:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01166f3:	74 28                	je     f011671d <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01166f5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166fb:	83 ec 0c             	sub    $0xc,%esp
f01166fe:	ff 75 c8             	pushl  -0x38(%ebp)
f0116701:	50                   	push   %eax
f0116702:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0116707:	68 1e 08 00 00       	push   $0x81e
f011670c:	68 42 91 12 f0       	push   $0xf0129142
f0116711:	e8 c0 9d fe ff       	call   f01004d6 <_warn>
f0116716:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116719:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011671d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116723:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116726:	74 28                	je     f0116750 <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116728:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011672e:	83 ec 0c             	sub    $0xc,%esp
f0116731:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116734:	50                   	push   %eax
f0116735:	68 54 ab 12 f0       	push   $0xf012ab54
f011673a:	68 23 08 00 00       	push   $0x823
f011673f:	68 42 91 12 f0       	push   $0xf0129142
f0116744:	e8 8d 9d fe ff       	call   f01004d6 <_warn>
f0116749:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011674c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116750:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116754:	74 04                	je     f011675a <test_calculate_allocated_space+0xd37>
f0116756:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011675a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f011675e:	83 ec 0c             	sub    $0xc,%esp
f0116761:	68 cf 9a 12 f0       	push   $0xf0129acf
f0116766:	e8 20 a8 fe ff       	call   f0100f8b <cprintf>
f011676b:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f011676e:	83 ec 08             	sub    $0x8,%esp
f0116771:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116774:	68 b0 ab 12 f0       	push   $0xf012abb0
f0116779:	e8 0d a8 fe ff       	call   f0100f8b <cprintf>
f011677e:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0116781:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116785:	75 10                	jne    f0116797 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116787:	83 ec 0c             	sub    $0xc,%esp
f011678a:	68 f0 ab 12 f0       	push   $0xf012abf0
f011678f:	e8 f7 a7 fe ff       	call   f0100f8b <cprintf>
f0116794:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116797:	a1 c4 0d 6c f0       	mov    0xf06c0dc4,%eax
f011679c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011679f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01167a2:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01167a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01167aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01167ad:	5b                   	pop    %ebx
f01167ae:	5e                   	pop    %esi
f01167af:	5f                   	pop    %edi
f01167b0:	5d                   	pop    %ebp
f01167b1:	c3                   	ret    

f01167b2 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f01167b2:	55                   	push   %ebp
f01167b3:	89 e5                	mov    %esp,%ebp
f01167b5:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f01167b8:	8b 45 10             	mov    0x10(%ebp),%eax
f01167bb:	ba 01 00 00 00       	mov    $0x1,%edx
f01167c0:	88 c1                	mov    %al,%cl
f01167c2:	d3 e2                	shl    %cl,%edx
f01167c4:	89 d0                	mov    %edx,%eax
f01167c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01167c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01167cc:	c1 e8 16             	shr    $0x16,%eax
f01167cf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01167d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01167d9:	01 d0                	add    %edx,%eax
f01167db:	8b 00                	mov    (%eax),%eax
f01167dd:	83 e0 01             	and    $0x1,%eax
f01167e0:	85 c0                	test   %eax,%eax
f01167e2:	75 07                	jne    f01167eb <CB+0x39>
f01167e4:	b8 00 00 00 00       	mov    $0x0,%eax
f01167e9:	eb 76                	jmp    f0116861 <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01167eb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01167ee:	c1 e8 16             	shr    $0x16,%eax
f01167f1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01167f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01167fb:	01 d0                	add    %edx,%eax
f01167fd:	8b 00                	mov    (%eax),%eax
f01167ff:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116804:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116807:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011680a:	c1 e8 0c             	shr    $0xc,%eax
f011680d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0116810:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f0116815:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116818:	72 17                	jb     f0116831 <CB+0x7f>
f011681a:	ff 75 f0             	pushl  -0x10(%ebp)
f011681d:	68 3c ac 12 f0       	push   $0xf012ac3c
f0116822:	68 3e 08 00 00       	push   $0x83e
f0116827:	68 42 91 12 f0       	push   $0xf0129142
f011682c:	e8 08 9b fe ff       	call   f0100339 <_panic>
f0116831:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116834:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116839:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f011683c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011683f:	c1 e8 0c             	shr    $0xc,%eax
f0116842:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116847:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011684e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116851:	01 d0                	add    %edx,%eax
f0116853:	8b 00                	mov    (%eax),%eax
f0116855:	23 45 f4             	and    -0xc(%ebp),%eax
f0116858:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011685b:	0f 94 c0             	sete   %al
f011685e:	0f b6 c0             	movzbl %al,%eax
}
f0116861:	c9                   	leave  
f0116862:	c3                   	ret    

f0116863 <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f0116863:	55                   	push   %ebp
f0116864:	89 e5                	mov    %esp,%ebp
f0116866:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116869:	68 6b ac 12 f0       	push   $0xf012ac6b
f011686e:	68 7a ac 12 f0       	push   $0xf012ac7a
f0116873:	68 43 08 00 00       	push   $0x843
f0116878:	68 42 91 12 f0       	push   $0xf0129142
f011687d:	e8 b7 9a fe ff       	call   f0100339 <_panic>

f0116882 <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0116882:	55                   	push   %ebp
f0116883:	89 e5                	mov    %esp,%ebp
f0116885:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116888:	68 6b ac 12 f0       	push   $0xf012ac6b
f011688d:	68 7a ac 12 f0       	push   $0xf012ac7a
f0116892:	68 4d 08 00 00       	push   $0x84d
f0116897:	68 42 91 12 f0       	push   $0xf0129142
f011689c:	e8 98 9a fe ff       	call   f0100339 <_panic>

f01168a1 <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f01168a1:	55                   	push   %ebp
f01168a2:	89 e5                	mov    %esp,%ebp
f01168a4:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01168a7:	68 6b ac 12 f0       	push   $0xf012ac6b
f01168ac:	68 7a ac 12 f0       	push   $0xf012ac7a
f01168b1:	68 5c 08 00 00       	push   $0x85c
f01168b6:	68 42 91 12 f0       	push   $0xf0129142
f01168bb:	e8 79 9a fe ff       	call   f0100339 <_panic>

f01168c0 <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f01168c0:	55                   	push   %ebp
f01168c1:	89 e5                	mov    %esp,%ebp
f01168c3:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01168c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01168c9:	c1 e8 16             	shr    $0x16,%eax
f01168cc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01168d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01168d6:	01 d0                	add    %edx,%eax
f01168d8:	8b 00                	mov    (%eax),%eax
f01168da:	83 e0 01             	and    $0x1,%eax
f01168dd:	85 c0                	test   %eax,%eax
f01168df:	75 07                	jne    f01168e8 <CE+0x28>
f01168e1:	b8 00 00 00 00       	mov    $0x0,%eax
f01168e6:	eb 7a                	jmp    f0116962 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01168e8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01168eb:	c1 e8 16             	shr    $0x16,%eax
f01168ee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01168f5:	8b 45 08             	mov    0x8(%ebp),%eax
f01168f8:	01 d0                	add    %edx,%eax
f01168fa:	8b 00                	mov    (%eax),%eax
f01168fc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116901:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116904:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116907:	c1 e8 0c             	shr    $0xc,%eax
f011690a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011690d:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f0116912:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116915:	72 17                	jb     f011692e <CE+0x6e>
f0116917:	ff 75 f4             	pushl  -0xc(%ebp)
f011691a:	68 3c ac 12 f0       	push   $0xf012ac3c
f011691f:	68 65 08 00 00       	push   $0x865
f0116924:	68 42 91 12 f0       	push   $0xf0129142
f0116929:	e8 0b 9a fe ff       	call   f0100339 <_panic>
f011692e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116931:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116936:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116939:	8b 45 0c             	mov    0xc(%ebp),%eax
f011693c:	c1 e8 0c             	shr    $0xc,%eax
f011693f:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116944:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011694b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011694e:	01 d0                	add    %edx,%eax
f0116950:	8b 00                	mov    (%eax),%eax
f0116952:	85 c0                	test   %eax,%eax
f0116954:	74 07                	je     f011695d <CE+0x9d>
f0116956:	b8 00 00 00 00       	mov    $0x0,%eax
f011695b:	eb 05                	jmp    f0116962 <CE+0xa2>
	return 1;
f011695d:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116962:	c9                   	leave  
f0116963:	c3                   	ret    

f0116964 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0116964:	55                   	push   %ebp
f0116965:	89 e5                	mov    %esp,%ebp
f0116967:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f011696a:	68 6b ac 12 f0       	push   $0xf012ac6b
f011696f:	68 7a ac 12 f0       	push   $0xf012ac7a
f0116974:	68 6c 08 00 00       	push   $0x86c
f0116979:	68 42 91 12 f0       	push   $0xf0129142
f011697e:	e8 b6 99 fe ff       	call   f0100339 <_panic>

f0116983 <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0116983:	55                   	push   %ebp
f0116984:	89 e5                	mov    %esp,%ebp
f0116986:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116989:	68 6b ac 12 f0       	push   $0xf012ac6b
f011698e:	68 7a ac 12 f0       	push   $0xf012ac7a
f0116993:	68 7c 08 00 00       	push   $0x87c
f0116998:	68 42 91 12 f0       	push   $0xf0129142
f011699d:	e8 97 99 fe ff       	call   f0100339 <_panic>

f01169a2 <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f01169a2:	55                   	push   %ebp
f01169a3:	89 e5                	mov    %esp,%ebp
f01169a5:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01169a8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01169af:	eb 18                	jmp    f01169c9 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f01169b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01169b4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01169bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01169be:	01 d0                	add    %edx,%eax
f01169c0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01169c6:	ff 45 fc             	incl   -0x4(%ebp)
f01169c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01169cc:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f01169d1:	76 de                	jbe    f01169b1 <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f01169d3:	90                   	nop
f01169d4:	c9                   	leave  
f01169d5:	c3                   	ret    

f01169d6 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f01169d6:	55                   	push   %ebp
f01169d7:	89 e5                	mov    %esp,%ebp
f01169d9:	83 ec 38             	sub    $0x38,%esp
f01169dc:	8b 45 2c             	mov    0x2c(%ebp),%eax
f01169df:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f01169e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01169e5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01169ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f01169ed:	8b 45 10             	mov    0x10(%ebp),%eax
f01169f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01169f5:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f01169f8:	e9 ea 01 00 00       	jmp    f0116be7 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f01169fd:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116a01:	74 44                	je     f0116a47 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116a03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116a06:	83 ec 04             	sub    $0x4,%esp
f0116a09:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116a0c:	52                   	push   %edx
f0116a0d:	50                   	push   %eax
f0116a0e:	ff 75 08             	pushl  0x8(%ebp)
f0116a11:	e8 53 1d ff ff       	call   f0108769 <get_frame_info>
f0116a16:	83 c4 10             	add    $0x10,%esp
f0116a19:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116a1c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116a1f:	85 c0                	test   %eax,%eax
f0116a21:	75 24                	jne    f0116a47 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116a23:	83 ec 04             	sub    $0x4,%esp
f0116a26:	68 90 ac 12 f0       	push   $0xf012ac90
f0116a2b:	68 99 08 00 00       	push   $0x899
f0116a30:	68 42 91 12 f0       	push   $0xf0129142
f0116a35:	e8 9c 9a fe ff       	call   f01004d6 <_warn>
f0116a3a:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116a3d:	b8 00 00 00 00       	mov    $0x0,%eax
f0116a42:	e9 b6 01 00 00       	jmp    f0116bfd <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116a47:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116a4a:	83 ec 04             	sub    $0x4,%esp
f0116a4d:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0116a50:	52                   	push   %edx
f0116a51:	50                   	push   %eax
f0116a52:	ff 75 08             	pushl  0x8(%ebp)
f0116a55:	e8 0f 1d ff ff       	call   f0108769 <get_frame_info>
f0116a5a:	83 c4 10             	add    $0x10,%esp
f0116a5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0116a60:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116a63:	85 c0                	test   %eax,%eax
f0116a65:	75 24                	jne    f0116a8b <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116a67:	83 ec 04             	sub    $0x4,%esp
f0116a6a:	68 bc ac 12 f0       	push   $0xf012acbc
f0116a6f:	68 a0 08 00 00       	push   $0x8a0
f0116a74:	68 42 91 12 f0       	push   $0xf0129142
f0116a79:	e8 58 9a fe ff       	call   f01004d6 <_warn>
f0116a7e:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116a81:	b8 00 00 00 00       	mov    $0x0,%eax
f0116a86:	e9 72 01 00 00       	jmp    f0116bfd <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0116a8b:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0116a8f:	75 70                	jne    f0116b01 <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0116a91:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116a94:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0116a97:	c1 ea 0c             	shr    $0xc,%edx
f0116a9a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116aa0:	c1 e2 02             	shl    $0x2,%edx
f0116aa3:	01 d0                	add    %edx,%eax
f0116aa5:	8b 00                	mov    (%eax),%eax
f0116aa7:	c1 e8 0c             	shr    $0xc,%eax
f0116aaa:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0116aad:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116ab0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0116ab3:	c1 ea 0c             	shr    $0xc,%edx
f0116ab6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116abc:	c1 e2 02             	shl    $0x2,%edx
f0116abf:	01 d0                	add    %edx,%eax
f0116ac1:	8b 00                	mov    (%eax),%eax
f0116ac3:	c1 e8 0c             	shr    $0xc,%eax
f0116ac6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0116ac9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116acc:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0116acf:	74 30                	je     f0116b01 <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0116ad1:	83 ec 04             	sub    $0x4,%esp
f0116ad4:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116ad7:	ff 75 e8             	pushl  -0x18(%ebp)
f0116ada:	ff 75 f0             	pushl  -0x10(%ebp)
f0116add:	ff 75 f4             	pushl  -0xc(%ebp)
f0116ae0:	68 e8 ac 12 f0       	push   $0xf012ace8
f0116ae5:	68 aa 08 00 00       	push   $0x8aa
f0116aea:	68 42 91 12 f0       	push   $0xf0129142
f0116aef:	e8 e2 99 fe ff       	call   f01004d6 <_warn>
f0116af4:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116af7:	b8 00 00 00 00       	mov    $0x0,%eax
f0116afc:	e9 fc 00 00 00       	jmp    f0116bfd <CCP+0x227>
			}
		}
		if (ref != -1)
f0116b01:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116b05:	74 52                	je     f0116b59 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116b07:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116b0b:	74 0e                	je     f0116b1b <CCP+0x145>
f0116b0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116b10:	8b 40 08             	mov    0x8(%eax),%eax
f0116b13:	0f b7 c0             	movzwl %ax,%eax
f0116b16:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116b19:	74 3e                	je     f0116b59 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116b1b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116b1f:	74 0b                	je     f0116b2c <CCP+0x156>
f0116b21:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116b24:	8b 40 08             	mov    0x8(%eax),%eax
f0116b27:	0f b7 c0             	movzwl %ax,%eax
f0116b2a:	eb 05                	jmp    f0116b31 <CCP+0x15b>
f0116b2c:	b8 00 00 00 00       	mov    $0x0,%eax
f0116b31:	83 ec 0c             	sub    $0xc,%esp
f0116b34:	50                   	push   %eax
f0116b35:	ff 75 f0             	pushl  -0x10(%ebp)
f0116b38:	68 44 ad 12 f0       	push   $0xf012ad44
f0116b3d:	68 b2 08 00 00       	push   $0x8b2
f0116b42:	68 42 91 12 f0       	push   $0xf0129142
f0116b47:	e8 8a 99 fe ff       	call   f01004d6 <_warn>
f0116b4c:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116b4f:	b8 00 00 00 00       	mov    $0x0,%eax
f0116b54:	e9 a4 00 00 00       	jmp    f0116bfd <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116b59:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116b5c:	ff 75 20             	pushl  0x20(%ebp)
f0116b5f:	ff 75 1c             	pushl  0x1c(%ebp)
f0116b62:	50                   	push   %eax
f0116b63:	ff 75 08             	pushl  0x8(%ebp)
f0116b66:	e8 17 fd ff ff       	call   f0116882 <CPs>
f0116b6b:	83 c4 10             	add    $0x10,%esp
f0116b6e:	85 c0                	test   %eax,%eax
f0116b70:	7f 21                	jg     f0116b93 <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0116b72:	83 ec 04             	sub    $0x4,%esp
f0116b75:	68 b4 ad 12 f0       	push   $0xf012adb4
f0116b7a:	68 b8 08 00 00       	push   $0x8b8
f0116b7f:	68 42 91 12 f0       	push   $0xf0129142
f0116b84:	e8 4d 99 fe ff       	call   f01004d6 <_warn>
f0116b89:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116b8c:	b8 00 00 00 00       	mov    $0x0,%eax
f0116b91:	eb 6a                	jmp    f0116bfd <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0116b93:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116b97:	74 3a                	je     f0116bd3 <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0116b99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116b9c:	ff 75 28             	pushl  0x28(%ebp)
f0116b9f:	ff 75 24             	pushl  0x24(%ebp)
f0116ba2:	50                   	push   %eax
f0116ba3:	ff 75 08             	pushl  0x8(%ebp)
f0116ba6:	e8 d7 fc ff ff       	call   f0116882 <CPs>
f0116bab:	83 c4 10             	add    $0x10,%esp
f0116bae:	85 c0                	test   %eax,%eax
f0116bb0:	7f 21                	jg     f0116bd3 <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0116bb2:	83 ec 04             	sub    $0x4,%esp
f0116bb5:	68 fc ad 12 f0       	push   $0xf012adfc
f0116bba:	68 bf 08 00 00       	push   $0x8bf
f0116bbf:	68 42 91 12 f0       	push   $0xf0129142
f0116bc4:	e8 0d 99 fe ff       	call   f01004d6 <_warn>
f0116bc9:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116bcc:	b8 00 00 00 00       	mov    $0x0,%eax
f0116bd1:	eb 2a                	jmp    f0116bfd <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0116bd3:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116bd7:	74 07                	je     f0116be0 <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0116bd9:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116be0:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0116be7:	8b 55 10             	mov    0x10(%ebp),%edx
f0116bea:	8b 45 14             	mov    0x14(%ebp),%eax
f0116bed:	01 d0                	add    %edx,%eax
f0116bef:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0116bf2:	0f 87 05 fe ff ff    	ja     f01169fd <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0116bf8:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116bfd:	c9                   	leave  
f0116bfe:	c3                   	ret    

f0116bff <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0116bff:	55                   	push   %ebp
f0116c00:	89 e5                	mov    %esp,%ebp
f0116c02:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116c05:	83 ec 04             	sub    $0x4,%esp
f0116c08:	68 3c ae 12 f0       	push   $0xf012ae3c
f0116c0d:	6a 0e                	push   $0xe
f0116c0f:	68 4c ae 12 f0       	push   $0xf012ae4c
f0116c14:	e8 20 97 fe ff       	call   f0100339 <_panic>

f0116c19 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0116c19:	55                   	push   %ebp
f0116c1a:	89 e5                	mov    %esp,%ebp
f0116c1c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116c1f:	83 ec 04             	sub    $0x4,%esp
f0116c22:	68 3c ae 12 f0       	push   $0xf012ae3c
f0116c27:	68 d7 00 00 00       	push   $0xd7
f0116c2c:	68 4c ae 12 f0       	push   $0xf012ae4c
f0116c31:	e8 03 97 fe ff       	call   f0100339 <_panic>

f0116c36 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0116c36:	55                   	push   %ebp
f0116c37:	89 e5                	mov    %esp,%ebp
f0116c39:	57                   	push   %edi
f0116c3a:	53                   	push   %ebx
f0116c3b:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0116c41:	83 ec 0c             	sub    $0xc,%esp
f0116c44:	68 68 ae 12 f0       	push   $0xf012ae68
f0116c49:	e8 3d a3 fe ff       	call   f0100f8b <cprintf>
f0116c4e:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0116c51:	83 ec 0c             	sub    $0xc,%esp
f0116c54:	68 98 ae 12 f0       	push   $0xf012ae98
f0116c59:	e8 2d a3 fe ff       	call   f0100f8b <cprintf>
f0116c5e:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0116c61:	83 ec 0c             	sub    $0xc,%esp
f0116c64:	68 68 ae 12 f0       	push   $0xf012ae68
f0116c69:	e8 1d a3 fe ff       	call   f0100f8b <cprintf>
f0116c6e:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0116c71:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f0116c75:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0116c79:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f0116c7f:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f0116c85:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0116c8c:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f0116c93:	e8 16 7c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0116c98:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0116c9b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0116ca2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f0116ca9:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0116caf:	b9 14 00 00 00       	mov    $0x14,%ecx
f0116cb4:	b8 00 00 00 00       	mov    $0x0,%eax
f0116cb9:	89 d7                	mov    %edx,%edi
f0116cbb:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f0116cbd:	83 ec 0c             	sub    $0xc,%esp
f0116cc0:	68 f1 ae 12 f0       	push   $0xf012aef1
f0116cc5:	e8 c1 a2 fe ff       	call   f0100f8b <cprintf>
f0116cca:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0116ccd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f0116cd4:	e8 d5 7b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0116cd9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116cdc:	e8 c4 db fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116ce1:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f0116ce4:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f0116ceb:	83 ec 0c             	sub    $0xc,%esp
f0116cee:	ff 75 cc             	pushl  -0x34(%ebp)
f0116cf1:	e8 9b 27 ff ff       	call   f0109491 <kmalloc>
f0116cf6:	83 c4 10             	add    $0x10,%esp
f0116cf9:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0116cff:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116d05:	85 c0                	test   %eax,%eax
f0116d07:	74 17                	je     f0116d20 <test_kmalloc+0xea>
f0116d09:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d10:	83 ec 0c             	sub    $0xc,%esp
f0116d13:	68 10 af 12 f0       	push   $0xf012af10
f0116d18:	e8 6e a2 fe ff       	call   f0100f8b <cprintf>
f0116d1d:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116d20:	e8 80 db fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116d25:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116d28:	74 17                	je     f0116d41 <test_kmalloc+0x10b>
f0116d2a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d31:	83 ec 0c             	sub    $0xc,%esp
f0116d34:	68 44 af 12 f0       	push   $0xf012af44
f0116d39:	e8 4d a2 fe ff       	call   f0100f8b <cprintf>
f0116d3e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116d41:	e8 68 7b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0116d46:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0116d49:	74 17                	je     f0116d62 <test_kmalloc+0x12c>
f0116d4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d52:	83 ec 0c             	sub    $0xc,%esp
f0116d55:	68 b0 af 12 f0       	push   $0xf012afb0
f0116d5a:	e8 2c a2 fe ff       	call   f0100f8b <cprintf>
f0116d5f:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116d62:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116d66:	74 04                	je     f0116d6c <test_kmalloc+0x136>
f0116d68:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f0116d6c:	83 ec 0c             	sub    $0xc,%esp
f0116d6f:	68 f4 af 12 f0       	push   $0xf012aff4
f0116d74:	e8 12 a2 fe ff       	call   f0100f8b <cprintf>
f0116d79:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0116d7c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116d83:	e8 26 7b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0116d88:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116d8b:	e8 15 db fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116d90:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0116d93:	83 ec 0c             	sub    $0xc,%esp
f0116d96:	68 00 fc 1f 00       	push   $0x1ffc00
f0116d9b:	e8 f1 26 ff ff       	call   f0109491 <kmalloc>
f0116da0:	83 c4 10             	add    $0x10,%esp
f0116da3:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116da9:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116daf:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0116db4:	74 17                	je     f0116dcd <test_kmalloc+0x197>
f0116db6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116dbd:	83 ec 0c             	sub    $0xc,%esp
f0116dc0:	68 38 b0 12 f0       	push   $0xf012b038
f0116dc5:	e8 c1 a1 fe ff       	call   f0100f8b <cprintf>
f0116dca:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116dcd:	e8 d3 da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116dd2:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116dd5:	74 17                	je     f0116dee <test_kmalloc+0x1b8>
f0116dd7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116dde:	83 ec 0c             	sub    $0xc,%esp
f0116de1:	68 8c b0 12 f0       	push   $0xf012b08c
f0116de6:	e8 a0 a1 fe ff       	call   f0100f8b <cprintf>
f0116deb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116dee:	e8 bb 7a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0116df3:	89 c2                	mov    %eax,%edx
f0116df5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116df8:	29 d0                	sub    %edx,%eax
f0116dfa:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116dff:	7f 17                	jg     f0116e18 <test_kmalloc+0x1e2>
f0116e01:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e08:	83 ec 0c             	sub    $0xc,%esp
f0116e0b:	68 f8 b0 12 f0       	push   $0xf012b0f8
f0116e10:	e8 76 a1 fe ff       	call   f0100f8b <cprintf>
f0116e15:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116e18:	e8 91 7a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0116e1d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116e20:	e8 80 da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116e25:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0116e28:	83 ec 0c             	sub    $0xc,%esp
f0116e2b:	68 00 fc 1f 00       	push   $0x1ffc00
f0116e30:	e8 5c 26 ff ff       	call   f0109491 <kmalloc>
f0116e35:	83 c4 10             	add    $0x10,%esp
f0116e38:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116e3e:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0116e44:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0116e49:	74 17                	je     f0116e62 <test_kmalloc+0x22c>
f0116e4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e52:	83 ec 0c             	sub    $0xc,%esp
f0116e55:	68 3c b1 12 f0       	push   $0xf012b13c
f0116e5a:	e8 2c a1 fe ff       	call   f0100f8b <cprintf>
f0116e5f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116e62:	e8 3e da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116e67:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116e6a:	74 17                	je     f0116e83 <test_kmalloc+0x24d>
f0116e6c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e73:	83 ec 0c             	sub    $0xc,%esp
f0116e76:	68 90 b1 12 f0       	push   $0xf012b190
f0116e7b:	e8 0b a1 fe ff       	call   f0100f8b <cprintf>
f0116e80:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116e83:	e8 26 7a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0116e88:	89 c2                	mov    %eax,%edx
f0116e8a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116e8d:	29 d0                	sub    %edx,%eax
f0116e8f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116e94:	7f 17                	jg     f0116ead <test_kmalloc+0x277>
f0116e96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e9d:	83 ec 0c             	sub    $0xc,%esp
f0116ea0:	68 fc b1 12 f0       	push   $0xf012b1fc
f0116ea5:	e8 e1 a0 fe ff       	call   f0100f8b <cprintf>
f0116eaa:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f0116ead:	e8 fc 79 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0116eb2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116eb5:	e8 eb d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116eba:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f0116ebd:	83 ec 0c             	sub    $0xc,%esp
f0116ec0:	68 ff 07 00 00       	push   $0x7ff
f0116ec5:	e8 c7 25 ff ff       	call   f0109491 <kmalloc>
f0116eca:	83 c4 10             	add    $0x10,%esp
f0116ecd:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0116ed3:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116ed9:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0116ede:	76 28                	jbe    f0116f08 <test_kmalloc+0x2d2>
f0116ee0:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0116ee6:	83 ec 0c             	sub    $0xc,%esp
f0116ee9:	6a 00                	push   $0x0
f0116eeb:	e8 6e 24 ff ff       	call   f010935e <sbrk>
f0116ef0:	83 c4 10             	add    $0x10,%esp
f0116ef3:	39 c3                	cmp    %eax,%ebx
f0116ef5:	73 11                	jae    f0116f08 <test_kmalloc+0x2d2>
f0116ef7:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116efd:	89 c2                	mov    %eax,%edx
f0116eff:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0116f04:	39 c2                	cmp    %eax,%edx
f0116f06:	72 17                	jb     f0116f1f <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0116f08:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f0f:	83 ec 0c             	sub    $0xc,%esp
f0116f12:	68 40 b2 12 f0       	push   $0xf012b240
f0116f17:	e8 6f a0 fe ff       	call   f0100f8b <cprintf>
f0116f1c:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116f1f:	e8 81 d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116f24:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116f27:	74 17                	je     f0116f40 <test_kmalloc+0x30a>
f0116f29:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f30:	83 ec 0c             	sub    $0xc,%esp
f0116f33:	68 cc b2 12 f0       	push   $0xf012b2cc
f0116f38:	e8 4e a0 fe ff       	call   f0100f8b <cprintf>
f0116f3d:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116f40:	e8 60 d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116f45:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f0116f48:	83 ec 0c             	sub    $0xc,%esp
f0116f4b:	68 ff 07 00 00       	push   $0x7ff
f0116f50:	e8 3c 25 ff ff       	call   f0109491 <kmalloc>
f0116f55:	83 c4 10             	add    $0x10,%esp
f0116f58:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0116f5e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116f64:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0116f69:	76 28                	jbe    f0116f93 <test_kmalloc+0x35d>
f0116f6b:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f0116f71:	83 ec 0c             	sub    $0xc,%esp
f0116f74:	6a 00                	push   $0x0
f0116f76:	e8 e3 23 ff ff       	call   f010935e <sbrk>
f0116f7b:	83 c4 10             	add    $0x10,%esp
f0116f7e:	39 c3                	cmp    %eax,%ebx
f0116f80:	73 11                	jae    f0116f93 <test_kmalloc+0x35d>
f0116f82:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116f88:	89 c2                	mov    %eax,%edx
f0116f8a:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0116f8f:	39 c2                	cmp    %eax,%edx
f0116f91:	72 17                	jb     f0116faa <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0116f93:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f9a:	83 ec 0c             	sub    $0xc,%esp
f0116f9d:	68 38 b3 12 f0       	push   $0xf012b338
f0116fa2:	e8 e4 9f fe ff       	call   f0100f8b <cprintf>
f0116fa7:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116faa:	e8 f6 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116faf:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116fb2:	74 17                	je     f0116fcb <test_kmalloc+0x395>
f0116fb4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fbb:	83 ec 0c             	sub    $0xc,%esp
f0116fbe:	68 c4 b3 12 f0       	push   $0xf012b3c4
f0116fc3:	e8 c3 9f fe ff       	call   f0100f8b <cprintf>
f0116fc8:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f0116fcb:	e8 de 78 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0116fd0:	89 c2                	mov    %eax,%edx
f0116fd2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116fd5:	29 d0                	sub    %edx,%eax
f0116fd7:	83 f8 01             	cmp    $0x1,%eax
f0116fda:	74 17                	je     f0116ff3 <test_kmalloc+0x3bd>
f0116fdc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fe3:	83 ec 0c             	sub    $0xc,%esp
f0116fe6:	68 30 b4 12 f0       	push   $0xf012b430
f0116feb:	e8 9b 9f fe ff       	call   f0100f8b <cprintf>
f0116ff0:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116ff3:	e8 b6 78 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0116ff8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116ffb:	e8 a5 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117000:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f0117003:	83 ec 0c             	sub    $0xc,%esp
f0117006:	68 00 1c 00 00       	push   $0x1c00
f011700b:	e8 81 24 ff ff       	call   f0109491 <kmalloc>
f0117010:	83 c4 10             	add    $0x10,%esp
f0117013:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117019:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011701f:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117024:	74 17                	je     f011703d <test_kmalloc+0x407>
f0117026:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011702d:	83 ec 0c             	sub    $0xc,%esp
f0117030:	68 50 b4 12 f0       	push   $0xf012b450
f0117035:	e8 51 9f fe ff       	call   f0100f8b <cprintf>
f011703a:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011703d:	e8 63 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117042:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117045:	74 17                	je     f011705e <test_kmalloc+0x428>
f0117047:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011704e:	83 ec 0c             	sub    $0xc,%esp
f0117051:	68 a4 b4 12 f0       	push   $0xf012b4a4
f0117056:	e8 30 9f fe ff       	call   f0100f8b <cprintf>
f011705b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011705e:	e8 4b 78 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117063:	89 c2                	mov    %eax,%edx
f0117065:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117068:	29 d0                	sub    %edx,%eax
f011706a:	83 f8 01             	cmp    $0x1,%eax
f011706d:	7f 17                	jg     f0117086 <test_kmalloc+0x450>
f011706f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117076:	83 ec 0c             	sub    $0xc,%esp
f0117079:	68 10 b5 12 f0       	push   $0xf012b510
f011707e:	e8 08 9f fe ff       	call   f0100f8b <cprintf>
f0117083:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117086:	e8 23 78 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011708b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011708e:	e8 12 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117093:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0117096:	83 ec 0c             	sub    $0xc,%esp
f0117099:	68 00 fc 2f 00       	push   $0x2ffc00
f011709e:	e8 ee 23 ff ff       	call   f0109491 <kmalloc>
f01170a3:	83 c4 10             	add    $0x10,%esp
f01170a6:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01170ac:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f01170b2:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01170b7:	74 17                	je     f01170d0 <test_kmalloc+0x49a>
f01170b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170c0:	83 ec 0c             	sub    $0xc,%esp
f01170c3:	68 54 b5 12 f0       	push   $0xf012b554
f01170c8:	e8 be 9e fe ff       	call   f0100f8b <cprintf>
f01170cd:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01170d0:	e8 d0 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01170d5:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01170d8:	74 17                	je     f01170f1 <test_kmalloc+0x4bb>
f01170da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170e1:	83 ec 0c             	sub    $0xc,%esp
f01170e4:	68 a8 b5 12 f0       	push   $0xf012b5a8
f01170e9:	e8 9d 9e fe ff       	call   f0100f8b <cprintf>
f01170ee:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01170f1:	e8 b8 77 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01170f6:	89 c2                	mov    %eax,%edx
f01170f8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01170fb:	29 d0                	sub    %edx,%eax
f01170fd:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117102:	7f 17                	jg     f011711b <test_kmalloc+0x4e5>
f0117104:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011710b:	83 ec 0c             	sub    $0xc,%esp
f011710e:	68 14 b6 12 f0       	push   $0xf012b614
f0117113:	e8 73 9e fe ff       	call   f0100f8b <cprintf>
f0117118:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011711b:	e8 8e 77 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117120:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117123:	e8 7d d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117128:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011712b:	83 ec 0c             	sub    $0xc,%esp
f011712e:	68 00 fc 5f 00       	push   $0x5ffc00
f0117133:	e8 59 23 ff ff       	call   f0109491 <kmalloc>
f0117138:	83 c4 10             	add    $0x10,%esp
f011713b:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117141:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0117147:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011714c:	74 17                	je     f0117165 <test_kmalloc+0x52f>
f011714e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117155:	83 ec 0c             	sub    $0xc,%esp
f0117158:	68 58 b6 12 f0       	push   $0xf012b658
f011715d:	e8 29 9e fe ff       	call   f0100f8b <cprintf>
f0117162:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117165:	e8 3b d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011716a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011716d:	74 17                	je     f0117186 <test_kmalloc+0x550>
f011716f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117176:	83 ec 0c             	sub    $0xc,%esp
f0117179:	68 ac b6 12 f0       	push   $0xf012b6ac
f011717e:	e8 08 9e fe ff       	call   f0100f8b <cprintf>
f0117183:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117186:	e8 23 77 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011718b:	89 c2                	mov    %eax,%edx
f011718d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117190:	29 d0                	sub    %edx,%eax
f0117192:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0117197:	7f 17                	jg     f01171b0 <test_kmalloc+0x57a>
f0117199:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171a0:	83 ec 0c             	sub    $0xc,%esp
f01171a3:	68 18 b7 12 f0       	push   $0xf012b718
f01171a8:	e8 de 9d fe ff       	call   f0100f8b <cprintf>
f01171ad:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01171b0:	e8 f9 76 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01171b5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01171b8:	e8 e8 d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01171bd:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f01171c0:	83 ec 0c             	sub    $0xc,%esp
f01171c3:	68 00 38 00 00       	push   $0x3800
f01171c8:	e8 c4 22 ff ff       	call   f0109491 <kmalloc>
f01171cd:	83 c4 10             	add    $0x10,%esp
f01171d0:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01171d6:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f01171dc:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f01171e1:	74 17                	je     f01171fa <test_kmalloc+0x5c4>
f01171e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171ea:	83 ec 0c             	sub    $0xc,%esp
f01171ed:	68 5c b7 12 f0       	push   $0xf012b75c
f01171f2:	e8 94 9d fe ff       	call   f0100f8b <cprintf>
f01171f7:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01171fa:	e8 a6 d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01171ff:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117202:	74 17                	je     f011721b <test_kmalloc+0x5e5>
f0117204:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011720b:	83 ec 0c             	sub    $0xc,%esp
f011720e:	68 b0 b7 12 f0       	push   $0xf012b7b0
f0117213:	e8 73 9d fe ff       	call   f0100f8b <cprintf>
f0117218:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011721b:	e8 8e 76 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117220:	89 c2                	mov    %eax,%edx
f0117222:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117225:	29 d0                	sub    %edx,%eax
f0117227:	83 f8 03             	cmp    $0x3,%eax
f011722a:	7f 17                	jg     f0117243 <test_kmalloc+0x60d>
f011722c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117233:	83 ec 0c             	sub    $0xc,%esp
f0117236:	68 1c b8 12 f0       	push   $0xf012b81c
f011723b:	e8 4b 9d fe ff       	call   f0100f8b <cprintf>
f0117240:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0117243:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117247:	74 04                	je     f011724d <test_kmalloc+0x617>
f0117249:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f011724d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f0117254:	83 ec 0c             	sub    $0xc,%esp
f0117257:	68 60 b8 12 f0       	push   $0xf012b860
f011725c:	e8 2a 9d fe ff       	call   f0100f8b <cprintf>
f0117261:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0117264:	e8 45 76 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117269:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011726c:	e8 34 d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117271:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f0117274:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f011727b:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0117281:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f0117284:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117287:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011728a:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f011728c:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011728f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117292:	01 c2                	add    %eax,%edx
f0117294:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117297:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f0117299:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011729f:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f01172a2:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f01172a9:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01172ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01172af:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f01172b2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01172b5:	01 c0                	add    %eax,%eax
f01172b7:	89 c2                	mov    %eax,%edx
f01172b9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01172bc:	01 c2                	add    %eax,%edx
f01172be:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01172c2:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f01172c5:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01172cb:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f01172ce:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f01172d5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01172d8:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01172db:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f01172dd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01172e0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01172e7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01172ea:	01 c2                	add    %eax,%edx
f01172ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01172ef:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f01172f1:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f01172f7:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f01172fa:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f0117301:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117304:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117307:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f0117309:	8b 55 ac             	mov    -0x54(%ebp),%edx
f011730c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011730f:	01 c2                	add    %eax,%edx
f0117311:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117314:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f0117316:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011731c:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f011731f:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f0117326:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117329:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011732c:	88 10                	mov    %dl,(%eax)
f011732e:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0117331:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117334:	66 89 42 02          	mov    %ax,0x2(%edx)
f0117338:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011733b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011733e:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f0117341:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117344:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011734b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011734e:	01 c2                	add    %eax,%edx
f0117350:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117353:	88 02                	mov    %al,(%edx)
f0117355:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117358:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011735f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117362:	01 c2                	add    %eax,%edx
f0117364:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0117368:	66 89 42 02          	mov    %ax,0x2(%edx)
f011736c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011736f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117376:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117379:	01 c2                	add    %eax,%edx
f011737b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011737e:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f0117381:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f0117388:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011738e:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f0117391:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117394:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117397:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f0117399:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011739c:	89 c2                	mov    %eax,%edx
f011739e:	c1 ea 1f             	shr    $0x1f,%edx
f01173a1:	01 d0                	add    %edx,%eax
f01173a3:	d1 f8                	sar    %eax
f01173a5:	89 c2                	mov    %eax,%edx
f01173a7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01173aa:	01 c2                	add    %eax,%edx
f01173ac:	8a 45 ea             	mov    -0x16(%ebp),%al
f01173af:	88 c1                	mov    %al,%cl
f01173b1:	c0 e9 07             	shr    $0x7,%cl
f01173b4:	01 c8                	add    %ecx,%eax
f01173b6:	d0 f8                	sar    %al
f01173b8:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f01173ba:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01173bd:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01173c0:	01 c2                	add    %eax,%edx
f01173c2:	8a 45 ea             	mov    -0x16(%ebp),%al
f01173c5:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f01173c7:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f01173cd:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f01173d0:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f01173d7:	8b 55 98             	mov    -0x68(%ebp),%edx
f01173da:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01173dd:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f01173e0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01173e3:	01 c0                	add    %eax,%eax
f01173e5:	89 c2                	mov    %eax,%edx
f01173e7:	8b 45 98             	mov    -0x68(%ebp),%eax
f01173ea:	01 c2                	add    %eax,%edx
f01173ec:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01173f0:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f01173f3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01173f6:	8a 00                	mov    (%eax),%al
f01173f8:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01173fb:	75 0f                	jne    f011740c <test_kmalloc+0x7d6>
f01173fd:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0117400:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117403:	01 d0                	add    %edx,%eax
f0117405:	8a 00                	mov    (%eax),%al
f0117407:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011740a:	74 17                	je     f0117423 <test_kmalloc+0x7ed>
f011740c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117413:	83 ec 0c             	sub    $0xc,%esp
f0117416:	68 98 b8 12 f0       	push   $0xf012b898
f011741b:	e8 6b 9b fe ff       	call   f0100f8b <cprintf>
f0117420:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f0117423:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117426:	66 8b 00             	mov    (%eax),%ax
f0117429:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f011742d:	75 15                	jne    f0117444 <test_kmalloc+0x80e>
f011742f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117432:	01 c0                	add    %eax,%eax
f0117434:	89 c2                	mov    %eax,%edx
f0117436:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117439:	01 d0                	add    %edx,%eax
f011743b:	66 8b 00             	mov    (%eax),%ax
f011743e:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0117442:	74 17                	je     f011745b <test_kmalloc+0x825>
f0117444:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011744b:	83 ec 0c             	sub    $0xc,%esp
f011744e:	68 d0 b8 12 f0       	push   $0xf012b8d0
f0117453:	e8 33 9b fe ff       	call   f0100f8b <cprintf>
f0117458:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f011745b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011745e:	8b 00                	mov    (%eax),%eax
f0117460:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0117463:	75 16                	jne    f011747b <test_kmalloc+0x845>
f0117465:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117468:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011746f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117472:	01 d0                	add    %edx,%eax
f0117474:	8b 00                	mov    (%eax),%eax
f0117476:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0117479:	74 17                	je     f0117492 <test_kmalloc+0x85c>
f011747b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117482:	83 ec 0c             	sub    $0xc,%esp
f0117485:	68 0c b9 12 f0       	push   $0xf012b90c
f011748a:	e8 fc 9a fe ff       	call   f0100f8b <cprintf>
f011748f:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f0117492:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117495:	8a 00                	mov    (%eax),%al
f0117497:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011749a:	75 0f                	jne    f01174ab <test_kmalloc+0x875>
f011749c:	8b 55 ac             	mov    -0x54(%ebp),%edx
f011749f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01174a2:	01 d0                	add    %edx,%eax
f01174a4:	8a 00                	mov    (%eax),%al
f01174a6:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01174a9:	74 17                	je     f01174c2 <test_kmalloc+0x88c>
f01174ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174b2:	83 ec 0c             	sub    $0xc,%esp
f01174b5:	68 48 b9 12 f0       	push   $0xf012b948
f01174ba:	e8 cc 9a fe ff       	call   f0100f8b <cprintf>
f01174bf:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f01174c2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01174c5:	8a 00                	mov    (%eax),%al
f01174c7:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01174ca:	75 16                	jne    f01174e2 <test_kmalloc+0x8ac>
f01174cc:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01174cf:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01174d6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01174d9:	01 d0                	add    %edx,%eax
f01174db:	8a 00                	mov    (%eax),%al
f01174dd:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01174e0:	74 17                	je     f01174f9 <test_kmalloc+0x8c3>
f01174e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174e9:	83 ec 0c             	sub    $0xc,%esp
f01174ec:	68 84 b9 12 f0       	push   $0xf012b984
f01174f1:	e8 95 9a fe ff       	call   f0100f8b <cprintf>
f01174f6:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f01174f9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01174fc:	66 8b 40 02          	mov    0x2(%eax),%ax
f0117500:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0117504:	75 19                	jne    f011751f <test_kmalloc+0x8e9>
f0117506:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117509:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117510:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117513:	01 d0                	add    %edx,%eax
f0117515:	66 8b 40 02          	mov    0x2(%eax),%ax
f0117519:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011751d:	74 17                	je     f0117536 <test_kmalloc+0x900>
f011751f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117526:	83 ec 0c             	sub    $0xc,%esp
f0117529:	68 c0 b9 12 f0       	push   $0xf012b9c0
f011752e:	e8 58 9a fe ff       	call   f0100f8b <cprintf>
f0117533:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f0117536:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117539:	8b 40 04             	mov    0x4(%eax),%eax
f011753c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011753f:	75 17                	jne    f0117558 <test_kmalloc+0x922>
f0117541:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117544:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011754b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011754e:	01 d0                	add    %edx,%eax
f0117550:	8b 40 04             	mov    0x4(%eax),%eax
f0117553:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0117556:	74 17                	je     f011756f <test_kmalloc+0x939>
f0117558:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011755f:	83 ec 0c             	sub    $0xc,%esp
f0117562:	68 fc b9 12 f0       	push   $0xf012b9fc
f0117567:	e8 1f 9a fe ff       	call   f0100f8b <cprintf>
f011756c:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011756f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117572:	8a 00                	mov    (%eax),%al
f0117574:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0117577:	75 34                	jne    f01175ad <test_kmalloc+0x977>
f0117579:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011757c:	89 c2                	mov    %eax,%edx
f011757e:	c1 ea 1f             	shr    $0x1f,%edx
f0117581:	01 d0                	add    %edx,%eax
f0117583:	d1 f8                	sar    %eax
f0117585:	89 c2                	mov    %eax,%edx
f0117587:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011758a:	01 d0                	add    %edx,%eax
f011758c:	8a 10                	mov    (%eax),%dl
f011758e:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117591:	88 c1                	mov    %al,%cl
f0117593:	c0 e9 07             	shr    $0x7,%cl
f0117596:	01 c8                	add    %ecx,%eax
f0117598:	d0 f8                	sar    %al
f011759a:	38 c2                	cmp    %al,%dl
f011759c:	75 0f                	jne    f01175ad <test_kmalloc+0x977>
f011759e:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01175a1:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01175a4:	01 d0                	add    %edx,%eax
f01175a6:	8a 00                	mov    (%eax),%al
f01175a8:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01175ab:	74 17                	je     f01175c4 <test_kmalloc+0x98e>
f01175ad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175b4:	83 ec 0c             	sub    $0xc,%esp
f01175b7:	68 38 ba 12 f0       	push   $0xf012ba38
f01175bc:	e8 ca 99 fe ff       	call   f0100f8b <cprintf>
f01175c1:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f01175c4:	8b 45 98             	mov    -0x68(%ebp),%eax
f01175c7:	66 8b 00             	mov    (%eax),%ax
f01175ca:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01175ce:	75 15                	jne    f01175e5 <test_kmalloc+0x9af>
f01175d0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01175d3:	01 c0                	add    %eax,%eax
f01175d5:	89 c2                	mov    %eax,%edx
f01175d7:	8b 45 98             	mov    -0x68(%ebp),%eax
f01175da:	01 d0                	add    %edx,%eax
f01175dc:	66 8b 00             	mov    (%eax),%ax
f01175df:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01175e3:	74 17                	je     f01175fc <test_kmalloc+0x9c6>
f01175e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175ec:	83 ec 0c             	sub    $0xc,%esp
f01175ef:	68 70 ba 12 f0       	push   $0xf012ba70
f01175f4:	e8 92 99 fe ff       	call   f0100f8b <cprintf>
f01175f9:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01175fc:	e8 ad 72 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117601:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0117604:	74 17                	je     f011761d <test_kmalloc+0x9e7>
f0117606:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011760d:	83 ec 0c             	sub    $0xc,%esp
f0117610:	68 ac ba 12 f0       	push   $0xf012baac
f0117615:	e8 71 99 fe ff       	call   f0100f8b <cprintf>
f011761a:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011761d:	e8 83 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117622:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117625:	74 17                	je     f011763e <test_kmalloc+0xa08>
f0117627:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011762e:	83 ec 0c             	sub    $0xc,%esp
f0117631:	68 f0 ba 12 f0       	push   $0xf012baf0
f0117636:	e8 50 99 fe ff       	call   f0100f8b <cprintf>
f011763b:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f011763e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117642:	74 04                	je     f0117648 <test_kmalloc+0xa12>
f0117644:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f0117648:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f011764f:	83 ec 0c             	sub    $0xc,%esp
f0117652:	68 5c bb 12 f0       	push   $0xf012bb5c
f0117657:	e8 2f 99 fe ff       	call   f0100f8b <cprintf>
f011765c:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f011765f:	e8 4a 72 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117664:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117667:	e8 39 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011766c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo);
f011766f:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f0117676:	8b 45 90             	mov    -0x70(%ebp),%eax
f0117679:	40                   	inc    %eax
f011767a:	83 ec 0c             	sub    $0xc,%esp
f011767d:	50                   	push   %eax
f011767e:	e8 0e 1e ff ff       	call   f0109491 <kmalloc>
f0117683:	83 c4 10             	add    $0x10,%esp
f0117686:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f011768c:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0117692:	85 c0                	test   %eax,%eax
f0117694:	74 17                	je     f01176ad <test_kmalloc+0xa77>
f0117696:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011769d:	83 ec 0c             	sub    $0xc,%esp
f01176a0:	68 80 bb 12 f0       	push   $0xf012bb80
f01176a5:	e8 e1 98 fe ff       	call   f0100f8b <cprintf>
f01176aa:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01176ad:	e8 f3 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01176b2:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01176b5:	74 17                	je     f01176ce <test_kmalloc+0xa98>
f01176b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176be:	83 ec 0c             	sub    $0xc,%esp
f01176c1:	68 b8 bb 12 f0       	push   $0xf012bbb8
f01176c6:	e8 c0 98 fe ff       	call   f0100f8b <cprintf>
f01176cb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01176ce:	e8 db 71 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01176d3:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01176d6:	74 17                	je     f01176ef <test_kmalloc+0xab9>
f01176d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176df:	83 ec 0c             	sub    $0xc,%esp
f01176e2:	68 24 bc 12 f0       	push   $0xf012bc24
f01176e7:	e8 9f 98 fe ff       	call   f0100f8b <cprintf>
f01176ec:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01176ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01176f3:	74 04                	je     f01176f9 <test_kmalloc+0xac3>
f01176f5:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01176f9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f0117700:	83 ec 0c             	sub    $0xc,%esp
f0117703:	68 68 bc 12 f0       	push   $0xf012bc68
f0117708:	e8 7e 98 fe ff       	call   f0100f8b <cprintf>
f011770d:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f0117710:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117716:	05 00 40 00 00       	add    $0x4000,%eax
f011771b:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011771e:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0117725:	eb 6a                	jmp    f0117791 <test_kmalloc+0xb5b>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f0117727:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011772c:	83 ec 04             	sub    $0x4,%esp
f011772f:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0117735:	52                   	push   %edx
f0117736:	ff 75 ec             	pushl  -0x14(%ebp)
f0117739:	50                   	push   %eax
f011773a:	e8 b0 0c ff ff       	call   f01083ef <get_page_table>
f011773f:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f0117742:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0117748:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011774b:	c1 ea 0c             	shr    $0xc,%edx
f011774e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0117754:	c1 e2 02             	shl    $0x2,%edx
f0117757:	01 d0                	add    %edx,%eax
f0117759:	8b 00                	mov    (%eax),%eax
f011775b:	25 ff 0f 00 00       	and    $0xfff,%eax
f0117760:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f0117763:	8b 45 88             	mov    -0x78(%ebp),%eax
f0117766:	83 e0 04             	and    $0x4,%eax
f0117769:	85 c0                	test   %eax,%eax
f011776b:	74 1d                	je     f011778a <test_kmalloc+0xb54>
			{
				if (correct)
f011776d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117771:	74 17                	je     f011778a <test_kmalloc+0xb54>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f0117773:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011777a:	83 ec 0c             	sub    $0xc,%esp
f011777d:	68 ac bc 12 f0       	push   $0xf012bcac
f0117782:	e8 04 98 fe ff       	call   f0100f8b <cprintf>
f0117787:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011778a:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f0117791:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117794:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0117797:	72 8e                	jb     f0117727 <test_kmalloc+0xaf1>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f0117799:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011779d:	74 04                	je     f01177a3 <test_kmalloc+0xb6d>
f011779f:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f01177a3:	83 ec 08             	sub    $0x8,%esp
f01177a6:	ff 75 f4             	pushl  -0xc(%ebp)
f01177a9:	68 fc bc 12 f0       	push   $0xf012bcfc
f01177ae:	e8 d8 97 fe ff       	call   f0100f8b <cprintf>
f01177b3:	83 c4 10             	add    $0x10,%esp

	return 1;
f01177b6:	b8 01 00 00 00       	mov    $0x1,%eax

}
f01177bb:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01177be:	5b                   	pop    %ebx
f01177bf:	5f                   	pop    %edi
f01177c0:	5d                   	pop    %ebp
f01177c1:	c3                   	ret    

f01177c2 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f01177c2:	55                   	push   %ebp
f01177c3:	89 e5                	mov    %esp,%ebp
f01177c5:	57                   	push   %edi
f01177c6:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01177c9:	83 ec 0c             	sub    $0xc,%esp
f01177cc:	68 68 ae 12 f0       	push   $0xf012ae68
f01177d1:	e8 b5 97 fe ff       	call   f0100f8b <cprintf>
f01177d6:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01177d9:	83 ec 0c             	sub    $0xc,%esp
f01177dc:	68 98 ae 12 f0       	push   $0xf012ae98
f01177e1:	e8 a5 97 fe ff       	call   f0100f8b <cprintf>
f01177e6:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01177e9:	83 ec 0c             	sub    $0xc,%esp
f01177ec:	68 68 ae 12 f0       	push   $0xf012ae68
f01177f1:	e8 95 97 fe ff       	call   f0100f8b <cprintf>
f01177f6:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f01177f9:	8d 55 98             	lea    -0x68(%ebp),%edx
f01177fc:	b9 14 00 00 00       	mov    $0x14,%ecx
f0117801:	b8 00 00 00 00       	mov    $0x0,%eax
f0117806:	89 d7                	mov    %edx,%edi
f0117808:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f011780a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0117811:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117818:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f011781f:	83 ec 0c             	sub    $0xc,%esp
f0117822:	68 28 bd 12 f0       	push   $0xf012bd28
f0117827:	e8 5f 97 fe ff       	call   f0100f8b <cprintf>
f011782c:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011782f:	e8 7a 70 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117834:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117837:	e8 69 d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011783c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f011783f:	83 ec 0c             	sub    $0xc,%esp
f0117842:	68 00 fc 0f 00       	push   $0xffc00
f0117847:	e8 45 1c ff ff       	call   f0109491 <kmalloc>
f011784c:	83 c4 10             	add    $0x10,%esp
f011784f:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f0117852:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117855:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011785a:	74 17                	je     f0117873 <test_kmalloc_firstfit1+0xb1>
f011785c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117863:	83 ec 0c             	sub    $0xc,%esp
f0117866:	68 68 bd 12 f0       	push   $0xf012bd68
f011786b:	e8 1b 97 fe ff       	call   f0100f8b <cprintf>
f0117870:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117873:	e8 2d d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117878:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011787b:	74 17                	je     f0117894 <test_kmalloc_firstfit1+0xd2>
f011787d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117884:	83 ec 0c             	sub    $0xc,%esp
f0117887:	68 8c b0 12 f0       	push   $0xf012b08c
f011788c:	e8 fa 96 fe ff       	call   f0100f8b <cprintf>
f0117891:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f0117894:	e8 15 70 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117899:	89 c2                	mov    %eax,%edx
f011789b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011789e:	29 d0                	sub    %edx,%eax
f01178a0:	3d ff 00 00 00       	cmp    $0xff,%eax
f01178a5:	7f 17                	jg     f01178be <test_kmalloc_firstfit1+0xfc>
f01178a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178ae:	83 ec 0c             	sub    $0xc,%esp
f01178b1:	68 9b bd 12 f0       	push   $0xf012bd9b
f01178b6:	e8 d0 96 fe ff       	call   f0100f8b <cprintf>
f01178bb:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01178be:	e8 eb 6f ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01178c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01178c6:	e8 da cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01178cb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f01178ce:	83 ec 0c             	sub    $0xc,%esp
f01178d1:	68 00 fc 0f 00       	push   $0xffc00
f01178d6:	e8 b6 1b ff ff       	call   f0109491 <kmalloc>
f01178db:	83 c4 10             	add    $0x10,%esp
f01178de:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f01178e1:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01178e4:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f01178e9:	74 17                	je     f0117902 <test_kmalloc_firstfit1+0x140>
f01178eb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178f2:	83 ec 0c             	sub    $0xc,%esp
f01178f5:	68 b4 bd 12 f0       	push   $0xf012bdb4
f01178fa:	e8 8c 96 fe ff       	call   f0100f8b <cprintf>
f01178ff:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117902:	e8 9e cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117907:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011790a:	74 17                	je     f0117923 <test_kmalloc_firstfit1+0x161>
f011790c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117913:	83 ec 0c             	sub    $0xc,%esp
f0117916:	68 90 b1 12 f0       	push   $0xf012b190
f011791b:	e8 6b 96 fe ff       	call   f0100f8b <cprintf>
f0117920:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117923:	e8 86 6f ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117928:	89 c2                	mov    %eax,%edx
f011792a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011792d:	29 d0                	sub    %edx,%eax
f011792f:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117934:	7f 17                	jg     f011794d <test_kmalloc_firstfit1+0x18b>
f0117936:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011793d:	83 ec 0c             	sub    $0xc,%esp
f0117940:	68 e7 bd 12 f0       	push   $0xf012bde7
f0117945:	e8 41 96 fe ff       	call   f0100f8b <cprintf>
f011794a:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011794d:	e8 5c 6f ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117952:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117955:	e8 4b cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011795a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f011795d:	83 ec 0c             	sub    $0xc,%esp
f0117960:	68 00 fc 0f 00       	push   $0xffc00
f0117965:	e8 27 1b ff ff       	call   f0109491 <kmalloc>
f011796a:	83 c4 10             	add    $0x10,%esp
f011796d:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0117970:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117973:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117978:	74 17                	je     f0117991 <test_kmalloc_firstfit1+0x1cf>
f011797a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117981:	83 ec 0c             	sub    $0xc,%esp
f0117984:	68 00 be 12 f0       	push   $0xf012be00
f0117989:	e8 fd 95 fe ff       	call   f0100f8b <cprintf>
f011798e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117991:	e8 0f cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117996:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117999:	74 17                	je     f01179b2 <test_kmalloc_firstfit1+0x1f0>
f011799b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179a2:	83 ec 0c             	sub    $0xc,%esp
f01179a5:	68 cc b2 12 f0       	push   $0xf012b2cc
f01179aa:	e8 dc 95 fe ff       	call   f0100f8b <cprintf>
f01179af:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f01179b2:	e8 f7 6e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01179b7:	89 c2                	mov    %eax,%edx
f01179b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01179bc:	29 d0                	sub    %edx,%eax
f01179be:	3d ff 00 00 00       	cmp    $0xff,%eax
f01179c3:	7f 17                	jg     f01179dc <test_kmalloc_firstfit1+0x21a>
f01179c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179cc:	83 ec 0c             	sub    $0xc,%esp
f01179cf:	68 33 be 12 f0       	push   $0xf012be33
f01179d4:	e8 b2 95 fe ff       	call   f0100f8b <cprintf>
f01179d9:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01179dc:	e8 cd 6e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01179e1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01179e4:	e8 bc ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01179e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f01179ec:	83 ec 0c             	sub    $0xc,%esp
f01179ef:	68 00 fc 0f 00       	push   $0xffc00
f01179f4:	e8 98 1a ff ff       	call   f0109491 <kmalloc>
f01179f9:	83 c4 10             	add    $0x10,%esp
f01179fc:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f01179ff:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117a02:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0117a07:	74 17                	je     f0117a20 <test_kmalloc_firstfit1+0x25e>
f0117a09:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a10:	83 ec 0c             	sub    $0xc,%esp
f0117a13:	68 4c be 12 f0       	push   $0xf012be4c
f0117a18:	e8 6e 95 fe ff       	call   f0100f8b <cprintf>
f0117a1d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a20:	e8 80 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a25:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117a28:	74 17                	je     f0117a41 <test_kmalloc_firstfit1+0x27f>
f0117a2a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a31:	83 ec 0c             	sub    $0xc,%esp
f0117a34:	68 c4 b3 12 f0       	push   $0xf012b3c4
f0117a39:	e8 4d 95 fe ff       	call   f0100f8b <cprintf>
f0117a3e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117a41:	e8 68 6e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117a46:	89 c2                	mov    %eax,%edx
f0117a48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117a4b:	29 d0                	sub    %edx,%eax
f0117a4d:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117a52:	7f 17                	jg     f0117a6b <test_kmalloc_firstfit1+0x2a9>
f0117a54:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a5b:	83 ec 0c             	sub    $0xc,%esp
f0117a5e:	68 7f be 12 f0       	push   $0xf012be7f
f0117a63:	e8 23 95 fe ff       	call   f0100f8b <cprintf>
f0117a68:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a6b:	e8 3e 6e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117a70:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a73:	e8 2d ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a78:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0117a7b:	83 ec 0c             	sub    $0xc,%esp
f0117a7e:	68 00 fc 1f 00       	push   $0x1ffc00
f0117a83:	e8 09 1a ff ff       	call   f0109491 <kmalloc>
f0117a88:	83 c4 10             	add    $0x10,%esp
f0117a8b:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f0117a8e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117a91:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117a96:	74 17                	je     f0117aaf <test_kmalloc_firstfit1+0x2ed>
f0117a98:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a9f:	83 ec 0c             	sub    $0xc,%esp
f0117aa2:	68 98 be 12 f0       	push   $0xf012be98
f0117aa7:	e8 df 94 fe ff       	call   f0100f8b <cprintf>
f0117aac:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117aaf:	e8 f1 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ab4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ab7:	74 17                	je     f0117ad0 <test_kmalloc_firstfit1+0x30e>
f0117ab9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ac0:	83 ec 0c             	sub    $0xc,%esp
f0117ac3:	68 a4 b4 12 f0       	push   $0xf012b4a4
f0117ac8:	e8 be 94 fe ff       	call   f0100f8b <cprintf>
f0117acd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f0117ad0:	e8 d9 6d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117ad5:	89 c2                	mov    %eax,%edx
f0117ad7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ada:	29 d0                	sub    %edx,%eax
f0117adc:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117ae1:	7f 17                	jg     f0117afa <test_kmalloc_firstfit1+0x338>
f0117ae3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117aea:	83 ec 0c             	sub    $0xc,%esp
f0117aed:	68 cb be 12 f0       	push   $0xf012becb
f0117af2:	e8 94 94 fe ff       	call   f0100f8b <cprintf>
f0117af7:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117afa:	e8 af 6d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117aff:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b02:	e8 9e cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b07:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0117b0a:	83 ec 0c             	sub    $0xc,%esp
f0117b0d:	68 00 fc 1f 00       	push   $0x1ffc00
f0117b12:	e8 7a 19 ff ff       	call   f0109491 <kmalloc>
f0117b17:	83 c4 10             	add    $0x10,%esp
f0117b1a:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117b1d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117b20:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0117b25:	74 17                	je     f0117b3e <test_kmalloc_firstfit1+0x37c>
f0117b27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b2e:	83 ec 0c             	sub    $0xc,%esp
f0117b31:	68 e4 be 12 f0       	push   $0xf012bee4
f0117b36:	e8 50 94 fe ff       	call   f0100f8b <cprintf>
f0117b3b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b3e:	e8 62 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b43:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b46:	74 17                	je     f0117b5f <test_kmalloc_firstfit1+0x39d>
f0117b48:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b4f:	83 ec 0c             	sub    $0xc,%esp
f0117b52:	68 a8 b5 12 f0       	push   $0xf012b5a8
f0117b57:	e8 2f 94 fe ff       	call   f0100f8b <cprintf>
f0117b5c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117b5f:	e8 4a 6d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117b64:	89 c2                	mov    %eax,%edx
f0117b66:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117b69:	29 d0                	sub    %edx,%eax
f0117b6b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117b70:	7f 17                	jg     f0117b89 <test_kmalloc_firstfit1+0x3c7>
f0117b72:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b79:	83 ec 0c             	sub    $0xc,%esp
f0117b7c:	68 17 bf 12 f0       	push   $0xf012bf17
f0117b81:	e8 05 94 fe ff       	call   f0100f8b <cprintf>
f0117b86:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117b89:	e8 20 6d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117b8e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b91:	e8 0f cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b96:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0117b99:	83 ec 0c             	sub    $0xc,%esp
f0117b9c:	68 00 fc 2f 00       	push   $0x2ffc00
f0117ba1:	e8 eb 18 ff ff       	call   f0109491 <kmalloc>
f0117ba6:	83 c4 10             	add    $0x10,%esp
f0117ba9:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0117bac:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117baf:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0117bb4:	74 17                	je     f0117bcd <test_kmalloc_firstfit1+0x40b>
f0117bb6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bbd:	83 ec 0c             	sub    $0xc,%esp
f0117bc0:	68 30 bf 12 f0       	push   $0xf012bf30
f0117bc5:	e8 c1 93 fe ff       	call   f0100f8b <cprintf>
f0117bca:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117bcd:	e8 d3 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117bd2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117bd5:	74 17                	je     f0117bee <test_kmalloc_firstfit1+0x42c>
f0117bd7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bde:	83 ec 0c             	sub    $0xc,%esp
f0117be1:	68 ac b6 12 f0       	push   $0xf012b6ac
f0117be6:	e8 a0 93 fe ff       	call   f0100f8b <cprintf>
f0117beb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0117bee:	e8 bb 6c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117bf3:	89 c2                	mov    %eax,%edx
f0117bf5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117bf8:	29 d0                	sub    %edx,%eax
f0117bfa:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117bff:	7f 17                	jg     f0117c18 <test_kmalloc_firstfit1+0x456>
f0117c01:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c08:	83 ec 0c             	sub    $0xc,%esp
f0117c0b:	68 63 bf 12 f0       	push   $0xf012bf63
f0117c10:	e8 76 93 fe ff       	call   f0100f8b <cprintf>
f0117c15:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c18:	e8 91 6c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117c1d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c20:	e8 80 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c25:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0117c28:	83 ec 0c             	sub    $0xc,%esp
f0117c2b:	68 00 fc 2f 00       	push   $0x2ffc00
f0117c30:	e8 5c 18 ff ff       	call   f0109491 <kmalloc>
f0117c35:	83 c4 10             	add    $0x10,%esp
f0117c38:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0117c3b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117c3e:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0117c43:	74 17                	je     f0117c5c <test_kmalloc_firstfit1+0x49a>
f0117c45:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c4c:	83 ec 0c             	sub    $0xc,%esp
f0117c4f:	68 7c bf 12 f0       	push   $0xf012bf7c
f0117c54:	e8 32 93 fe ff       	call   f0100f8b <cprintf>
f0117c59:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c5c:	e8 44 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c61:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c64:	74 17                	je     f0117c7d <test_kmalloc_firstfit1+0x4bb>
f0117c66:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c6d:	83 ec 0c             	sub    $0xc,%esp
f0117c70:	68 b0 b7 12 f0       	push   $0xf012b7b0
f0117c75:	e8 11 93 fe ff       	call   f0100f8b <cprintf>
f0117c7a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f0117c7d:	e8 2c 6c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117c82:	89 c2                	mov    %eax,%edx
f0117c84:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117c87:	29 d0                	sub    %edx,%eax
f0117c89:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117c8e:	7f 17                	jg     f0117ca7 <test_kmalloc_firstfit1+0x4e5>
f0117c90:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c97:	83 ec 0c             	sub    $0xc,%esp
f0117c9a:	68 af bf 12 f0       	push   $0xf012bfaf
f0117c9f:	e8 e7 92 fe ff       	call   f0100f8b <cprintf>
f0117ca4:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117ca7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117cab:	74 04                	je     f0117cb1 <test_kmalloc_firstfit1+0x4ef>
f0117cad:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117cb1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f0117cb8:	83 ec 0c             	sub    $0xc,%esp
f0117cbb:	68 c8 bf 12 f0       	push   $0xf012bfc8
f0117cc0:	e8 c6 92 fe ff       	call   f0100f8b <cprintf>
f0117cc5:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117cc8:	e8 e1 6b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117ccd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117cd0:	e8 d0 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117cd5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0117cd8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117cdb:	83 ec 0c             	sub    $0xc,%esp
f0117cde:	50                   	push   %eax
f0117cdf:	e8 0d 1a ff ff       	call   f01096f1 <kfree>
f0117ce4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117ce7:	e8 b9 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117cec:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117cef:	74 17                	je     f0117d08 <test_kmalloc_firstfit1+0x546>
f0117cf1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cf8:	83 ec 0c             	sub    $0xc,%esp
f0117cfb:	68 f0 bf 12 f0       	push   $0xf012bff0
f0117d00:	e8 86 92 fe ff       	call   f0100f8b <cprintf>
f0117d05:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f0117d08:	e8 a1 6b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117d0d:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117d10:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117d15:	7f 17                	jg     f0117d2e <test_kmalloc_firstfit1+0x56c>
f0117d17:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d1e:	83 ec 0c             	sub    $0xc,%esp
f0117d21:	68 5b c0 12 f0       	push   $0xf012c05b
f0117d26:	e8 60 92 fe ff       	call   f0100f8b <cprintf>
f0117d2b:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d2e:	e8 7b 6b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117d33:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d36:	e8 6a cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d3b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f0117d3e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117d41:	83 ec 0c             	sub    $0xc,%esp
f0117d44:	50                   	push   %eax
f0117d45:	e8 a7 19 ff ff       	call   f01096f1 <kfree>
f0117d4a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117d4d:	e8 53 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d52:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117d55:	74 17                	je     f0117d6e <test_kmalloc_firstfit1+0x5ac>
f0117d57:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d5e:	83 ec 0c             	sub    $0xc,%esp
f0117d61:	68 6c c0 12 f0       	push   $0xf012c06c
f0117d66:	e8 20 92 fe ff       	call   f0100f8b <cprintf>
f0117d6b:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f0117d6e:	e8 3b 6b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117d73:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117d76:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117d7b:	7f 17                	jg     f0117d94 <test_kmalloc_firstfit1+0x5d2>
f0117d7d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d84:	83 ec 0c             	sub    $0xc,%esp
f0117d87:	68 d8 c0 12 f0       	push   $0xf012c0d8
f0117d8c:	e8 fa 91 fe ff       	call   f0100f8b <cprintf>
f0117d91:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d94:	e8 15 6b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117d99:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d9c:	e8 04 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117da1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0117da4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117da7:	83 ec 0c             	sub    $0xc,%esp
f0117daa:	50                   	push   %eax
f0117dab:	e8 41 19 ff ff       	call   f01096f1 <kfree>
f0117db0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117db3:	e8 ed ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117db8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117dbb:	74 17                	je     f0117dd4 <test_kmalloc_firstfit1+0x612>
f0117dbd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dc4:	83 ec 0c             	sub    $0xc,%esp
f0117dc7:	68 ec c0 12 f0       	push   $0xf012c0ec
f0117dcc:	e8 ba 91 fe ff       	call   f0100f8b <cprintf>
f0117dd1:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f0117dd4:	e8 d5 6a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117dd9:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117ddc:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117de1:	7f 17                	jg     f0117dfa <test_kmalloc_firstfit1+0x638>
f0117de3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dea:	83 ec 0c             	sub    $0xc,%esp
f0117ded:	68 58 c1 12 f0       	push   $0xf012c158
f0117df2:	e8 94 91 fe ff       	call   f0100f8b <cprintf>
f0117df7:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117dfa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117dfe:	74 04                	je     f0117e04 <test_kmalloc_firstfit1+0x642>
f0117e00:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117e04:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f0117e0b:	83 ec 0c             	sub    $0xc,%esp
f0117e0e:	68 6c c1 12 f0       	push   $0xf012c16c
f0117e13:	e8 73 91 fe ff       	call   f0100f8b <cprintf>
f0117e18:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e1b:	e8 8e 6a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117e20:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e23:	e8 7d ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e28:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f0117e2b:	83 ec 0c             	sub    $0xc,%esp
f0117e2e:	68 00 fc 07 00       	push   $0x7fc00
f0117e33:	e8 59 16 ff ff       	call   f0109491 <kmalloc>
f0117e38:	83 c4 10             	add    $0x10,%esp
f0117e3b:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f0117e3e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117e41:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0117e46:	74 17                	je     f0117e5f <test_kmalloc_firstfit1+0x69d>
f0117e48:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e4f:	83 ec 0c             	sub    $0xc,%esp
f0117e52:	68 98 c1 12 f0       	push   $0xf012c198
f0117e57:	e8 2f 91 fe ff       	call   f0100f8b <cprintf>
f0117e5c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117e5f:	e8 41 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e64:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e67:	74 17                	je     f0117e80 <test_kmalloc_firstfit1+0x6be>
f0117e69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e70:	83 ec 0c             	sub    $0xc,%esp
f0117e73:	68 cc c1 12 f0       	push   $0xf012c1cc
f0117e78:	e8 0e 91 fe ff       	call   f0100f8b <cprintf>
f0117e7d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f0117e80:	e8 29 6a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117e85:	89 c2                	mov    %eax,%edx
f0117e87:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117e8a:	29 d0                	sub    %edx,%eax
f0117e8c:	83 f8 7f             	cmp    $0x7f,%eax
f0117e8f:	7f 17                	jg     f0117ea8 <test_kmalloc_firstfit1+0x6e6>
f0117e91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e98:	83 ec 0c             	sub    $0xc,%esp
f0117e9b:	68 38 c2 12 f0       	push   $0xf012c238
f0117ea0:	e8 e6 90 fe ff       	call   f0100f8b <cprintf>
f0117ea5:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117ea8:	e8 01 6a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117ead:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117eb0:	e8 f0 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117eb5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f0117eb8:	83 ec 0c             	sub    $0xc,%esp
f0117ebb:	68 00 fc 0f 00       	push   $0xffc00
f0117ec0:	e8 cc 15 ff ff       	call   f0109491 <kmalloc>
f0117ec5:	83 c4 10             	add    $0x10,%esp
f0117ec8:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f0117ecb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117ece:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117ed3:	74 17                	je     f0117eec <test_kmalloc_firstfit1+0x72a>
f0117ed5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117edc:	83 ec 0c             	sub    $0xc,%esp
f0117edf:	68 50 c2 12 f0       	push   $0xf012c250
f0117ee4:	e8 a2 90 fe ff       	call   f0100f8b <cprintf>
f0117ee9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117eec:	e8 b4 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ef1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ef4:	74 17                	je     f0117f0d <test_kmalloc_firstfit1+0x74b>
f0117ef6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117efd:	83 ec 0c             	sub    $0xc,%esp
f0117f00:	68 84 c2 12 f0       	push   $0xf012c284
f0117f05:	e8 81 90 fe ff       	call   f0100f8b <cprintf>
f0117f0a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f0117f0d:	e8 9c 69 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117f12:	89 c2                	mov    %eax,%edx
f0117f14:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117f17:	29 d0                	sub    %edx,%eax
f0117f19:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117f1e:	7f 17                	jg     f0117f37 <test_kmalloc_firstfit1+0x775>
f0117f20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f27:	83 ec 0c             	sub    $0xc,%esp
f0117f2a:	68 f0 c2 12 f0       	push   $0xf012c2f0
f0117f2f:	e8 57 90 fe ff       	call   f0100f8b <cprintf>
f0117f34:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117f37:	e8 72 69 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117f3c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f3f:	e8 61 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f44:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f0117f47:	83 ec 0c             	sub    $0xc,%esp
f0117f4a:	68 00 fc 03 00       	push   $0x3fc00
f0117f4f:	e8 3d 15 ff ff       	call   f0109491 <kmalloc>
f0117f54:	83 c4 10             	add    $0x10,%esp
f0117f57:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f0117f5a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117f5d:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f0117f62:	74 17                	je     f0117f7b <test_kmalloc_firstfit1+0x7b9>
f0117f64:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f6b:	83 ec 0c             	sub    $0xc,%esp
f0117f6e:	68 08 c3 12 f0       	push   $0xf012c308
f0117f73:	e8 13 90 fe ff       	call   f0100f8b <cprintf>
f0117f78:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f7b:	e8 25 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f80:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f83:	74 17                	je     f0117f9c <test_kmalloc_firstfit1+0x7da>
f0117f85:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f8c:	83 ec 0c             	sub    $0xc,%esp
f0117f8f:	68 3c c3 12 f0       	push   $0xf012c33c
f0117f94:	e8 f2 8f fe ff       	call   f0100f8b <cprintf>
f0117f99:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f0117f9c:	e8 0d 69 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117fa1:	89 c2                	mov    %eax,%edx
f0117fa3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117fa6:	29 d0                	sub    %edx,%eax
f0117fa8:	83 f8 3f             	cmp    $0x3f,%eax
f0117fab:	7f 17                	jg     f0117fc4 <test_kmalloc_firstfit1+0x802>
f0117fad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fb4:	83 ec 0c             	sub    $0xc,%esp
f0117fb7:	68 a8 c3 12 f0       	push   $0xf012c3a8
f0117fbc:	e8 ca 8f fe ff       	call   f0100f8b <cprintf>
f0117fc1:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117fc4:	e8 e5 68 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0117fc9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117fcc:	e8 d4 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117fd1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f0117fd4:	83 ec 0c             	sub    $0xc,%esp
f0117fd7:	68 00 00 20 00       	push   $0x200000
f0117fdc:	e8 b0 14 ff ff       	call   f0109491 <kmalloc>
f0117fe1:	83 c4 10             	add    $0x10,%esp
f0117fe4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f0117fe7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117fea:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0117fef:	74 17                	je     f0118008 <test_kmalloc_firstfit1+0x846>
f0117ff1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ff8:	83 ec 0c             	sub    $0xc,%esp
f0117ffb:	68 c0 c3 12 f0       	push   $0xf012c3c0
f0118000:	e8 86 8f fe ff       	call   f0100f8b <cprintf>
f0118005:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f0118008:	e8 a1 68 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011800d:	89 c2                	mov    %eax,%edx
f011800f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118012:	29 d0                	sub    %edx,%eax
f0118014:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118019:	7f 17                	jg     f0118032 <test_kmalloc_firstfit1+0x870>
f011801b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118022:	83 ec 0c             	sub    $0xc,%esp
f0118025:	68 f4 c3 12 f0       	push   $0xf012c3f4
f011802a:	e8 5c 8f fe ff       	call   f0100f8b <cprintf>
f011802f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118032:	e8 6e c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118037:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011803a:	74 17                	je     f0118053 <test_kmalloc_firstfit1+0x891>
f011803c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118043:	83 ec 0c             	sub    $0xc,%esp
f0118046:	68 0c c4 12 f0       	push   $0xf012c40c
f011804b:	e8 3b 8f fe ff       	call   f0100f8b <cprintf>
f0118050:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f0118053:	e8 56 68 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118058:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011805b:	e8 45 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118060:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f0118063:	83 ec 0c             	sub    $0xc,%esp
f0118066:	68 00 fc 3f 00       	push   $0x3ffc00
f011806b:	e8 21 14 ff ff       	call   f0109491 <kmalloc>
f0118070:	83 c4 10             	add    $0x10,%esp
f0118073:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f0118076:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118079:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f011807e:	74 17                	je     f0118097 <test_kmalloc_firstfit1+0x8d5>
f0118080:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118087:	83 ec 0c             	sub    $0xc,%esp
f011808a:	68 78 c4 12 f0       	push   $0xf012c478
f011808f:	e8 f7 8e fe ff       	call   f0100f8b <cprintf>
f0118094:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118097:	e8 09 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011809c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011809f:	74 17                	je     f01180b8 <test_kmalloc_firstfit1+0x8f6>
f01180a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180a8:	83 ec 0c             	sub    $0xc,%esp
f01180ab:	68 ac c4 12 f0       	push   $0xf012c4ac
f01180b0:	e8 d6 8e fe ff       	call   f0100f8b <cprintf>
f01180b5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f01180b8:	e8 f1 67 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01180bd:	89 c2                	mov    %eax,%edx
f01180bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01180c2:	29 d0                	sub    %edx,%eax
f01180c4:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f01180c9:	7f 17                	jg     f01180e2 <test_kmalloc_firstfit1+0x920>
f01180cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180d2:	83 ec 0c             	sub    $0xc,%esp
f01180d5:	68 18 c5 12 f0       	push   $0xf012c518
f01180da:	e8 ac 8e fe ff       	call   f0100f8b <cprintf>
f01180df:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f01180e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01180e6:	74 04                	je     f01180ec <test_kmalloc_firstfit1+0x92a>
f01180e8:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f01180ec:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f01180f3:	83 ec 0c             	sub    $0xc,%esp
f01180f6:	68 30 c5 12 f0       	push   $0xf012c530
f01180fb:	e8 8b 8e fe ff       	call   f0100f8b <cprintf>
f0118100:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118103:	e8 a6 67 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118108:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011810b:	e8 95 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118110:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0118113:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118116:	83 ec 0c             	sub    $0xc,%esp
f0118119:	50                   	push   %eax
f011811a:	e8 d2 15 ff ff       	call   f01096f1 <kfree>
f011811f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118122:	e8 7e c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118127:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011812a:	74 17                	je     f0118143 <test_kmalloc_firstfit1+0x981>
f011812c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118133:	83 ec 0c             	sub    $0xc,%esp
f0118136:	68 f0 ba 12 f0       	push   $0xf012baf0
f011813b:	e8 4b 8e fe ff       	call   f0100f8b <cprintf>
f0118140:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f0118143:	e8 66 67 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118148:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011814b:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118150:	7f 17                	jg     f0118169 <test_kmalloc_firstfit1+0x9a7>
f0118152:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118159:	83 ec 0c             	sub    $0xc,%esp
f011815c:	68 64 c5 12 f0       	push   $0xf012c564
f0118161:	e8 25 8e fe ff       	call   f0100f8b <cprintf>
f0118166:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f0118169:	e8 40 67 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011816e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118171:	e8 2f c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118176:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0118179:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011817c:	83 ec 0c             	sub    $0xc,%esp
f011817f:	50                   	push   %eax
f0118180:	e8 6c 15 ff ff       	call   f01096f1 <kfree>
f0118185:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118188:	e8 18 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011818d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118190:	74 17                	je     f01181a9 <test_kmalloc_firstfit1+0x9e7>
f0118192:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118199:	83 ec 0c             	sub    $0xc,%esp
f011819c:	68 b8 bb 12 f0       	push   $0xf012bbb8
f01181a1:	e8 e5 8d fe ff       	call   f0100f8b <cprintf>
f01181a6:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f01181a9:	e8 00 67 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01181ae:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01181b1:	3d ff 00 00 00       	cmp    $0xff,%eax
f01181b6:	7f 17                	jg     f01181cf <test_kmalloc_firstfit1+0xa0d>
f01181b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181bf:	83 ec 0c             	sub    $0xc,%esp
f01181c2:	68 75 c5 12 f0       	push   $0xf012c575
f01181c7:	e8 bf 8d fe ff       	call   f0100f8b <cprintf>
f01181cc:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01181cf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01181d3:	74 04                	je     f01181d9 <test_kmalloc_firstfit1+0xa17>
f01181d5:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01181d9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f01181e0:	83 ec 0c             	sub    $0xc,%esp
f01181e3:	68 88 c5 12 f0       	push   $0xf012c588
f01181e8:	e8 9e 8d fe ff       	call   f0100f8b <cprintf>
f01181ed:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f01181f0:	e8 b9 66 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01181f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01181f8:	e8 a8 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f0118200:	83 ec 0c             	sub    $0xc,%esp
f0118203:	68 00 00 10 00       	push   $0x100000
f0118208:	e8 84 12 ff ff       	call   f0109491 <kmalloc>
f011820d:	83 c4 10             	add    $0x10,%esp
f0118210:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118213:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118216:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f011821b:	74 17                	je     f0118234 <test_kmalloc_firstfit1+0xa72>
f011821d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118224:	83 ec 0c             	sub    $0xc,%esp
f0118227:	68 c8 c5 12 f0       	push   $0xf012c5c8
f011822c:	e8 5a 8d fe ff       	call   f0100f8b <cprintf>
f0118231:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118234:	e8 6c c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118239:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011823c:	74 17                	je     f0118255 <test_kmalloc_firstfit1+0xa93>
f011823e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118245:	83 ec 0c             	sub    $0xc,%esp
f0118248:	68 fc c5 12 f0       	push   $0xf012c5fc
f011824d:	e8 39 8d fe ff       	call   f0100f8b <cprintf>
f0118252:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0118255:	e8 54 66 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011825a:	89 c2                	mov    %eax,%edx
f011825c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011825f:	29 d0                	sub    %edx,%eax
f0118261:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118266:	7f 17                	jg     f011827f <test_kmalloc_firstfit1+0xabd>
f0118268:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011826f:	83 ec 0c             	sub    $0xc,%esp
f0118272:	68 68 c6 12 f0       	push   $0xf012c668
f0118277:	e8 0f 8d fe ff       	call   f0100f8b <cprintf>
f011827c:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f011827f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118283:	74 04                	je     f0118289 <test_kmalloc_firstfit1+0xac7>
f0118285:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f0118289:	83 ec 08             	sub    $0x8,%esp
f011828c:	ff 75 f4             	pushl  -0xc(%ebp)
f011828f:	68 80 c6 12 f0       	push   $0xf012c680
f0118294:	e8 f2 8c fe ff       	call   f0100f8b <cprintf>
f0118299:	83 c4 10             	add    $0x10,%esp

	return 1;
f011829c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01182a1:	8b 7d fc             	mov    -0x4(%ebp),%edi
f01182a4:	c9                   	leave  
f01182a5:	c3                   	ret    

f01182a6 <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f01182a6:	55                   	push   %ebp
f01182a7:	89 e5                	mov    %esp,%ebp
f01182a9:	57                   	push   %edi
f01182aa:	53                   	push   %ebx
f01182ab:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01182ae:	83 ec 0c             	sub    $0xc,%esp
f01182b1:	68 68 ae 12 f0       	push   $0xf012ae68
f01182b6:	e8 d0 8c fe ff       	call   f0100f8b <cprintf>
f01182bb:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01182be:	83 ec 0c             	sub    $0xc,%esp
f01182c1:	68 98 ae 12 f0       	push   $0xf012ae98
f01182c6:	e8 c0 8c fe ff       	call   f0100f8b <cprintf>
f01182cb:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01182ce:	83 ec 0c             	sub    $0xc,%esp
f01182d1:	68 68 ae 12 f0       	push   $0xf012ae68
f01182d6:	e8 b0 8c fe ff       	call   f0100f8b <cprintf>
f01182db:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f01182de:	8d 55 98             	lea    -0x68(%ebp),%edx
f01182e1:	b9 14 00 00 00       	mov    $0x14,%ecx
f01182e6:	b8 00 00 00 00       	mov    $0x0,%eax
f01182eb:	89 d7                	mov    %edx,%edi
f01182ed:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f01182ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f01182f6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f01182fd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f0118304:	83 ec 0c             	sub    $0xc,%esp
f0118307:	68 b8 c6 12 f0       	push   $0xf012c6b8
f011830c:	e8 7a 8c fe ff       	call   f0100f8b <cprintf>
f0118311:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0118314:	83 ec 0c             	sub    $0xc,%esp
f0118317:	68 01 e0 ff 07       	push   $0x7ffe001
f011831c:	e8 70 11 ff ff       	call   f0109491 <kmalloc>
f0118321:	83 c4 10             	add    $0x10,%esp
f0118324:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f0118327:	8b 45 98             	mov    -0x68(%ebp),%eax
f011832a:	85 c0                	test   %eax,%eax
f011832c:	74 17                	je     f0118345 <test_kmalloc_firstfit2+0x9f>
f011832e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118335:	83 ec 0c             	sub    $0xc,%esp
f0118338:	68 ec c6 12 f0       	push   $0xf012c6ec
f011833d:	e8 49 8c fe ff       	call   f0100f8b <cprintf>
f0118342:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118345:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118349:	74 04                	je     f011834f <test_kmalloc_firstfit2+0xa9>
f011834b:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011834f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f0118356:	83 ec 0c             	sub    $0xc,%esp
f0118359:	68 34 c7 12 f0       	push   $0xf012c734
f011835e:	e8 28 8c fe ff       	call   f0100f8b <cprintf>
f0118363:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118366:	e8 43 65 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011836b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011836e:	e8 32 c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118373:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0118376:	83 ec 0c             	sub    $0xc,%esp
f0118379:	68 00 fc 1f 00       	push   $0x1ffc00
f011837e:	e8 0e 11 ff ff       	call   f0109491 <kmalloc>
f0118383:	83 c4 10             	add    $0x10,%esp
f0118386:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0118389:	8b 45 98             	mov    -0x68(%ebp),%eax
f011838c:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118391:	74 17                	je     f01183aa <test_kmalloc_firstfit2+0x104>
f0118393:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011839a:	83 ec 0c             	sub    $0xc,%esp
f011839d:	68 b4 bd 12 f0       	push   $0xf012bdb4
f01183a2:	e8 e4 8b fe ff       	call   f0100f8b <cprintf>
f01183a7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01183aa:	e8 f6 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01183af:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01183b2:	74 17                	je     f01183cb <test_kmalloc_firstfit2+0x125>
f01183b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183bb:	83 ec 0c             	sub    $0xc,%esp
f01183be:	68 90 b1 12 f0       	push   $0xf012b190
f01183c3:	e8 c3 8b fe ff       	call   f0100f8b <cprintf>
f01183c8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f01183cb:	e8 de 64 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01183d0:	89 c2                	mov    %eax,%edx
f01183d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01183d5:	29 d0                	sub    %edx,%eax
f01183d7:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01183dc:	7f 17                	jg     f01183f5 <test_kmalloc_firstfit2+0x14f>
f01183de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183e5:	83 ec 0c             	sub    $0xc,%esp
f01183e8:	68 e7 bd 12 f0       	push   $0xf012bde7
f01183ed:	e8 99 8b fe ff       	call   f0100f8b <cprintf>
f01183f2:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01183f5:	e8 b4 64 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01183fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01183fd:	e8 a3 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118402:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0118405:	83 ec 0c             	sub    $0xc,%esp
f0118408:	68 00 fc 1f 00       	push   $0x1ffc00
f011840d:	e8 7f 10 ff ff       	call   f0109491 <kmalloc>
f0118412:	83 c4 10             	add    $0x10,%esp
f0118415:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0118418:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011841b:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0118420:	74 17                	je     f0118439 <test_kmalloc_firstfit2+0x193>
f0118422:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118429:	83 ec 0c             	sub    $0xc,%esp
f011842c:	68 00 be 12 f0       	push   $0xf012be00
f0118431:	e8 55 8b fe ff       	call   f0100f8b <cprintf>
f0118436:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118439:	e8 67 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011843e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118441:	74 17                	je     f011845a <test_kmalloc_firstfit2+0x1b4>
f0118443:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011844a:	83 ec 0c             	sub    $0xc,%esp
f011844d:	68 cc b2 12 f0       	push   $0xf012b2cc
f0118452:	e8 34 8b fe ff       	call   f0100f8b <cprintf>
f0118457:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f011845a:	e8 4f 64 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011845f:	89 c2                	mov    %eax,%edx
f0118461:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118464:	29 d0                	sub    %edx,%eax
f0118466:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011846b:	7f 17                	jg     f0118484 <test_kmalloc_firstfit2+0x1de>
f011846d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118474:	83 ec 0c             	sub    $0xc,%esp
f0118477:	68 33 be 12 f0       	push   $0xf012be33
f011847c:	e8 0a 8b fe ff       	call   f0100f8b <cprintf>
f0118481:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118484:	e8 25 64 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118489:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011848c:	e8 14 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118491:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f0118494:	83 ec 0c             	sub    $0xc,%esp
f0118497:	68 00 1c 00 00       	push   $0x1c00
f011849c:	e8 f0 0f ff ff       	call   f0109491 <kmalloc>
f01184a1:	83 c4 10             	add    $0x10,%esp
f01184a4:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f01184a7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01184aa:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01184af:	74 17                	je     f01184c8 <test_kmalloc_firstfit2+0x222>
f01184b1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184b8:	83 ec 0c             	sub    $0xc,%esp
f01184bb:	68 4c be 12 f0       	push   $0xf012be4c
f01184c0:	e8 c6 8a fe ff       	call   f0100f8b <cprintf>
f01184c5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01184c8:	e8 d8 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01184cd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01184d0:	74 17                	je     f01184e9 <test_kmalloc_firstfit2+0x243>
f01184d2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184d9:	83 ec 0c             	sub    $0xc,%esp
f01184dc:	68 c4 b3 12 f0       	push   $0xf012b3c4
f01184e1:	e8 a5 8a fe ff       	call   f0100f8b <cprintf>
f01184e6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f01184e9:	e8 c0 63 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01184ee:	89 c2                	mov    %eax,%edx
f01184f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01184f3:	29 d0                	sub    %edx,%eax
f01184f5:	83 f8 01             	cmp    $0x1,%eax
f01184f8:	7f 17                	jg     f0118511 <test_kmalloc_firstfit2+0x26b>
f01184fa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118501:	83 ec 0c             	sub    $0xc,%esp
f0118504:	68 7f be 12 f0       	push   $0xf012be7f
f0118509:	e8 7d 8a fe ff       	call   f0100f8b <cprintf>
f011850e:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118511:	e8 98 63 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118516:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118519:	e8 87 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011851e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f0118521:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118524:	83 ec 0c             	sub    $0xc,%esp
f0118527:	50                   	push   %eax
f0118528:	e8 c4 11 ff ff       	call   f01096f1 <kfree>
f011852d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118530:	e8 70 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118535:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118538:	74 17                	je     f0118551 <test_kmalloc_firstfit2+0x2ab>
f011853a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118541:	83 ec 0c             	sub    $0xc,%esp
f0118544:	68 a4 b4 12 f0       	push   $0xf012b4a4
f0118549:	e8 3d 8a fe ff       	call   f0100f8b <cprintf>
f011854e:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f0118551:	e8 58 63 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118556:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118559:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011855e:	7f 17                	jg     f0118577 <test_kmalloc_firstfit2+0x2d1>
f0118560:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118567:	83 ec 0c             	sub    $0xc,%esp
f011856a:	68 7a c7 12 f0       	push   $0xf012c77a
f011856f:	e8 17 8a fe ff       	call   f0100f8b <cprintf>
f0118574:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118577:	e8 32 63 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011857c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011857f:	e8 21 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118584:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0118587:	83 ec 0c             	sub    $0xc,%esp
f011858a:	68 00 fc 2f 00       	push   $0x2ffc00
f011858f:	e8 fd 0e ff ff       	call   f0109491 <kmalloc>
f0118594:	83 c4 10             	add    $0x10,%esp
f0118597:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f011859a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011859d:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01185a2:	74 17                	je     f01185bb <test_kmalloc_firstfit2+0x315>
f01185a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185ab:	83 ec 0c             	sub    $0xc,%esp
f01185ae:	68 e4 be 12 f0       	push   $0xf012bee4
f01185b3:	e8 d3 89 fe ff       	call   f0100f8b <cprintf>
f01185b8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185bb:	e8 e5 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01185c0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01185c3:	74 17                	je     f01185dc <test_kmalloc_firstfit2+0x336>
f01185c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185cc:	83 ec 0c             	sub    $0xc,%esp
f01185cf:	68 a8 b5 12 f0       	push   $0xf012b5a8
f01185d4:	e8 b2 89 fe ff       	call   f0100f8b <cprintf>
f01185d9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f01185dc:	e8 cd 62 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01185e1:	89 c2                	mov    %eax,%edx
f01185e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01185e6:	29 d0                	sub    %edx,%eax
f01185e8:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01185ed:	7f 17                	jg     f0118606 <test_kmalloc_firstfit2+0x360>
f01185ef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185f6:	83 ec 0c             	sub    $0xc,%esp
f01185f9:	68 17 bf 12 f0       	push   $0xf012bf17
f01185fe:	e8 88 89 fe ff       	call   f0100f8b <cprintf>
f0118603:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118606:	e8 a3 62 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011860b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011860e:	e8 92 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118613:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f0118616:	83 ec 0c             	sub    $0xc,%esp
f0118619:	68 00 18 20 00       	push   $0x201800
f011861e:	e8 6e 0e ff ff       	call   f0109491 <kmalloc>
f0118623:	83 c4 10             	add    $0x10,%esp
f0118626:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0118629:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011862c:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0118631:	74 17                	je     f011864a <test_kmalloc_firstfit2+0x3a4>
f0118633:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011863a:	83 ec 0c             	sub    $0xc,%esp
f011863d:	68 30 bf 12 f0       	push   $0xf012bf30
f0118642:	e8 44 89 fe ff       	call   f0100f8b <cprintf>
f0118647:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011864a:	e8 56 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011864f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118652:	74 17                	je     f011866b <test_kmalloc_firstfit2+0x3c5>
f0118654:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011865b:	83 ec 0c             	sub    $0xc,%esp
f011865e:	68 ac b6 12 f0       	push   $0xf012b6ac
f0118663:	e8 23 89 fe ff       	call   f0100f8b <cprintf>
f0118668:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f011866b:	e8 3e 62 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118670:	89 c2                	mov    %eax,%edx
f0118672:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118675:	29 d0                	sub    %edx,%eax
f0118677:	3d 01 02 00 00       	cmp    $0x201,%eax
f011867c:	7f 17                	jg     f0118695 <test_kmalloc_firstfit2+0x3ef>
f011867e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118685:	83 ec 0c             	sub    $0xc,%esp
f0118688:	68 63 bf 12 f0       	push   $0xf012bf63
f011868d:	e8 f9 88 fe ff       	call   f0100f8b <cprintf>
f0118692:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118695:	e8 14 62 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011869a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011869d:	e8 03 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01186a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01186a5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01186a8:	83 ec 0c             	sub    $0xc,%esp
f01186ab:	50                   	push   %eax
f01186ac:	e8 40 10 ff ff       	call   f01096f1 <kfree>
f01186b1:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01186b4:	e8 ec c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01186b9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01186bc:	74 17                	je     f01186d5 <test_kmalloc_firstfit2+0x42f>
f01186be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186c5:	83 ec 0c             	sub    $0xc,%esp
f01186c8:	68 b0 b7 12 f0       	push   $0xf012b7b0
f01186cd:	e8 b9 88 fe ff       	call   f0100f8b <cprintf>
f01186d2:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f01186d5:	e8 d4 61 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01186da:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01186dd:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01186e2:	7f 17                	jg     f01186fb <test_kmalloc_firstfit2+0x455>
f01186e4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186eb:	83 ec 0c             	sub    $0xc,%esp
f01186ee:	68 8a c7 12 f0       	push   $0xf012c78a
f01186f3:	e8 93 88 fe ff       	call   f0100f8b <cprintf>
f01186f8:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01186fb:	e8 ae 61 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118700:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118703:	e8 9d c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118708:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f011870b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011870e:	83 ec 0c             	sub    $0xc,%esp
f0118711:	50                   	push   %eax
f0118712:	e8 da 0f ff ff       	call   f01096f1 <kfree>
f0118717:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f011871a:	e8 8f 61 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011871f:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118722:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118727:	7f 17                	jg     f0118740 <test_kmalloc_firstfit2+0x49a>
f0118729:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118730:	83 ec 0c             	sub    $0xc,%esp
f0118733:	68 5b c0 12 f0       	push   $0xf012c05b
f0118738:	e8 4e 88 fe ff       	call   f0100f8b <cprintf>
f011873d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118740:	e8 60 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118745:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118748:	74 17                	je     f0118761 <test_kmalloc_firstfit2+0x4bb>
f011874a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118751:	83 ec 0c             	sub    $0xc,%esp
f0118754:	68 f0 bf 12 f0       	push   $0xf012bff0
f0118759:	e8 2d 88 fe ff       	call   f0100f8b <cprintf>
f011875e:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118761:	e8 48 61 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118766:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118769:	e8 37 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011876e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f0118771:	83 ec 0c             	sub    $0xc,%esp
f0118774:	68 00 fc 4f 00       	push   $0x4ffc00
f0118779:	e8 13 0d ff ff       	call   f0109491 <kmalloc>
f011877e:	83 c4 10             	add    $0x10,%esp
f0118781:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f0118784:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118787:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f011878c:	74 17                	je     f01187a5 <test_kmalloc_firstfit2+0x4ff>
f011878e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118795:	83 ec 0c             	sub    $0xc,%esp
f0118798:	68 9c c7 12 f0       	push   $0xf012c79c
f011879d:	e8 e9 87 fe ff       	call   f0100f8b <cprintf>
f01187a2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01187a5:	e8 fb c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01187aa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01187ad:	74 17                	je     f01187c6 <test_kmalloc_firstfit2+0x520>
f01187af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187b6:	83 ec 0c             	sub    $0xc,%esp
f01187b9:	68 6c c0 12 f0       	push   $0xf012c06c
f01187be:	e8 c8 87 fe ff       	call   f0100f8b <cprintf>
f01187c3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f01187c6:	e8 e3 60 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01187cb:	89 c2                	mov    %eax,%edx
f01187cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01187d0:	29 d0                	sub    %edx,%eax
f01187d2:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f01187d7:	7f 17                	jg     f01187f0 <test_kmalloc_firstfit2+0x54a>
f01187d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187e0:	83 ec 0c             	sub    $0xc,%esp
f01187e3:	68 d0 c7 12 f0       	push   $0xf012c7d0
f01187e8:	e8 9e 87 fe ff       	call   f0100f8b <cprintf>
f01187ed:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01187f0:	e8 b9 60 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01187f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01187f8:	e8 a8 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01187fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f0118800:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118803:	83 ec 0c             	sub    $0xc,%esp
f0118806:	50                   	push   %eax
f0118807:	e8 e5 0e ff ff       	call   f01096f1 <kfree>
f011880c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011880f:	e8 91 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118814:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118817:	74 17                	je     f0118830 <test_kmalloc_firstfit2+0x58a>
f0118819:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118820:	83 ec 0c             	sub    $0xc,%esp
f0118823:	68 ec c0 12 f0       	push   $0xf012c0ec
f0118828:	e8 5e 87 fe ff       	call   f0100f8b <cprintf>
f011882d:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f0118830:	e8 79 60 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118835:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118838:	83 f8 01             	cmp    $0x1,%eax
f011883b:	7f 17                	jg     f0118854 <test_kmalloc_firstfit2+0x5ae>
f011883d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118844:	83 ec 0c             	sub    $0xc,%esp
f0118847:	68 58 c1 12 f0       	push   $0xf012c158
f011884c:	e8 3a 87 fe ff       	call   f0100f8b <cprintf>
f0118851:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f0118854:	e8 55 60 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118859:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011885c:	e8 44 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118861:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f0118864:	83 ec 0c             	sub    $0xc,%esp
f0118867:	68 00 04 00 00       	push   $0x400
f011886c:	e8 20 0c ff ff       	call   f0109491 <kmalloc>
f0118871:	83 c4 10             	add    $0x10,%esp
f0118874:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0118877:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011887a:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011887f:	76 22                	jbe    f01188a3 <test_kmalloc_firstfit2+0x5fd>
f0118881:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f0118884:	83 ec 0c             	sub    $0xc,%esp
f0118887:	6a 00                	push   $0x0
f0118889:	e8 d0 0a ff ff       	call   f010935e <sbrk>
f011888e:	83 c4 10             	add    $0x10,%esp
f0118891:	39 c3                	cmp    %eax,%ebx
f0118893:	73 0e                	jae    f01188a3 <test_kmalloc_firstfit2+0x5fd>
f0118895:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118898:	89 c2                	mov    %eax,%edx
f011889a:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011889f:	39 c2                	cmp    %eax,%edx
f01188a1:	72 17                	jb     f01188ba <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01188a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188aa:	83 ec 0c             	sub    $0xc,%esp
f01188ad:	68 e8 c7 12 f0       	push   $0xf012c7e8
f01188b2:	e8 d4 86 fe ff       	call   f0100f8b <cprintf>
f01188b7:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01188ba:	e8 e6 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01188bf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01188c2:	74 17                	je     f01188db <test_kmalloc_firstfit2+0x635>
f01188c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188cb:	83 ec 0c             	sub    $0xc,%esp
f01188ce:	68 cc c1 12 f0       	push   $0xf012c1cc
f01188d3:	e8 b3 86 fe ff       	call   f0100f8b <cprintf>
f01188d8:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01188db:	e8 c5 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01188e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f01188e3:	83 ec 0c             	sub    $0xc,%esp
f01188e6:	68 00 08 00 00       	push   $0x800
f01188eb:	e8 a1 0b ff ff       	call   f0109491 <kmalloc>
f01188f0:	83 c4 10             	add    $0x10,%esp
f01188f3:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f01188f6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01188f9:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01188fe:	76 22                	jbe    f0118922 <test_kmalloc_firstfit2+0x67c>
f0118900:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0118903:	83 ec 0c             	sub    $0xc,%esp
f0118906:	6a 00                	push   $0x0
f0118908:	e8 51 0a ff ff       	call   f010935e <sbrk>
f011890d:	83 c4 10             	add    $0x10,%esp
f0118910:	39 c3                	cmp    %eax,%ebx
f0118912:	73 0e                	jae    f0118922 <test_kmalloc_firstfit2+0x67c>
f0118914:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118917:	89 c2                	mov    %eax,%edx
f0118919:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011891e:	39 c2                	cmp    %eax,%edx
f0118920:	72 17                	jb     f0118939 <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118922:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118929:	83 ec 0c             	sub    $0xc,%esp
f011892c:	68 74 c8 12 f0       	push   $0xf012c874
f0118931:	e8 55 86 fe ff       	call   f0100f8b <cprintf>
f0118936:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118939:	e8 67 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011893e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118941:	74 17                	je     f011895a <test_kmalloc_firstfit2+0x6b4>
f0118943:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011894a:	83 ec 0c             	sub    $0xc,%esp
f011894d:	68 84 c2 12 f0       	push   $0xf012c284
f0118952:	e8 34 86 fe ff       	call   f0100f8b <cprintf>
f0118957:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011895a:	e8 46 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011895f:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f0118962:	83 ec 0c             	sub    $0xc,%esp
f0118965:	68 00 04 00 00       	push   $0x400
f011896a:	e8 22 0b ff ff       	call   f0109491 <kmalloc>
f011896f:	83 c4 10             	add    $0x10,%esp
f0118972:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0118975:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118978:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011897d:	76 22                	jbe    f01189a1 <test_kmalloc_firstfit2+0x6fb>
f011897f:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0118982:	83 ec 0c             	sub    $0xc,%esp
f0118985:	6a 00                	push   $0x0
f0118987:	e8 d2 09 ff ff       	call   f010935e <sbrk>
f011898c:	83 c4 10             	add    $0x10,%esp
f011898f:	39 c3                	cmp    %eax,%ebx
f0118991:	73 0e                	jae    f01189a1 <test_kmalloc_firstfit2+0x6fb>
f0118993:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118996:	89 c2                	mov    %eax,%edx
f0118998:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011899d:	39 c2                	cmp    %eax,%edx
f011899f:	72 17                	jb     f01189b8 <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01189a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189a8:	83 ec 0c             	sub    $0xc,%esp
f01189ab:	68 00 c9 12 f0       	push   $0xf012c900
f01189b0:	e8 d6 85 fe ff       	call   f0100f8b <cprintf>
f01189b5:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01189b8:	e8 e8 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01189bd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01189c0:	74 17                	je     f01189d9 <test_kmalloc_firstfit2+0x733>
f01189c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189c9:	83 ec 0c             	sub    $0xc,%esp
f01189cc:	68 3c c3 12 f0       	push   $0xf012c33c
f01189d1:	e8 b5 85 fe ff       	call   f0100f8b <cprintf>
f01189d6:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f01189d9:	e8 d0 5e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01189de:	89 c2                	mov    %eax,%edx
f01189e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01189e3:	29 d0                	sub    %edx,%eax
f01189e5:	83 f8 01             	cmp    $0x1,%eax
f01189e8:	74 17                	je     f0118a01 <test_kmalloc_firstfit2+0x75b>
f01189ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189f1:	83 ec 0c             	sub    $0xc,%esp
f01189f4:	68 8c c9 12 f0       	push   $0xf012c98c
f01189f9:	e8 8d 85 fe ff       	call   f0100f8b <cprintf>
f01189fe:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f0118a01:	e8 a8 5e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118a06:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118a09:	e8 97 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a0e:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f0118a11:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118a14:	83 ec 0c             	sub    $0xc,%esp
f0118a17:	50                   	push   %eax
f0118a18:	e8 d4 0c ff ff       	call   f01096f1 <kfree>
f0118a1d:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a20:	e8 80 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a25:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a28:	74 17                	je     f0118a41 <test_kmalloc_firstfit2+0x79b>
f0118a2a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a31:	83 ec 0c             	sub    $0xc,%esp
f0118a34:	68 0c c4 12 f0       	push   $0xf012c40c
f0118a39:	e8 4d 85 fe ff       	call   f0100f8b <cprintf>
f0118a3e:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118a41:	e8 68 5e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118a46:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118a49:	74 17                	je     f0118a62 <test_kmalloc_firstfit2+0x7bc>
f0118a4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a52:	83 ec 0c             	sub    $0xc,%esp
f0118a55:	68 b0 c9 12 f0       	push   $0xf012c9b0
f0118a5a:	e8 2c 85 fe ff       	call   f0100f8b <cprintf>
f0118a5f:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f0118a62:	e8 47 5e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118a67:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118a6a:	e8 36 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a6f:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f0118a72:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118a75:	83 ec 0c             	sub    $0xc,%esp
f0118a78:	50                   	push   %eax
f0118a79:	e8 73 0c ff ff       	call   f01096f1 <kfree>
f0118a7e:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a81:	e8 1f be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a86:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a89:	74 17                	je     f0118aa2 <test_kmalloc_firstfit2+0x7fc>
f0118a8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a92:	83 ec 0c             	sub    $0xc,%esp
f0118a95:	68 ac c4 12 f0       	push   $0xf012c4ac
f0118a9a:	e8 ec 84 fe ff       	call   f0100f8b <cprintf>
f0118a9f:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118aa2:	e8 07 5e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118aa7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118aaa:	74 17                	je     f0118ac3 <test_kmalloc_firstfit2+0x81d>
f0118aac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ab3:	83 ec 0c             	sub    $0xc,%esp
f0118ab6:	68 10 ca 12 f0       	push   $0xf012ca10
f0118abb:	e8 cb 84 fe ff       	call   f0100f8b <cprintf>
f0118ac0:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f0118ac3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118ac7:	74 04                	je     f0118acd <test_kmalloc_firstfit2+0x827>
f0118ac9:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118acd:	83 ec 0c             	sub    $0xc,%esp
f0118ad0:	68 70 ca 12 f0       	push   $0xf012ca70
f0118ad5:	e8 b1 84 fe ff       	call   f0100f8b <cprintf>
f0118ada:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118add:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118ae4:	e8 c5 5d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118ae9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118aec:	e8 b4 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118af1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f0118af4:	83 ec 0c             	sub    $0xc,%esp
f0118af7:	68 00 08 00 00       	push   $0x800
f0118afc:	e8 90 09 ff ff       	call   f0109491 <kmalloc>
f0118b01:	83 c4 10             	add    $0x10,%esp
f0118b04:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0118b07:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118b0a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118b0d:	39 c2                	cmp    %eax,%edx
f0118b0f:	74 17                	je     f0118b28 <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f0118b11:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b18:	83 ec 0c             	sub    $0xc,%esp
f0118b1b:	68 a8 ca 12 f0       	push   $0xf012caa8
f0118b20:	e8 66 84 fe ff       	call   f0100f8b <cprintf>
f0118b25:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b28:	e8 78 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b2d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b30:	74 17                	je     f0118b49 <test_kmalloc_firstfit2+0x8a3>
f0118b32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b39:	83 ec 0c             	sub    $0xc,%esp
f0118b3c:	68 f0 ba 12 f0       	push   $0xf012baf0
f0118b41:	e8 45 84 fe ff       	call   f0100f8b <cprintf>
f0118b46:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0118b49:	e8 60 5d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118b4e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118b51:	74 17                	je     f0118b6a <test_kmalloc_firstfit2+0x8c4>
f0118b53:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b5a:	83 ec 0c             	sub    $0xc,%esp
f0118b5d:	68 dc ca 12 f0       	push   $0xf012cadc
f0118b62:	e8 24 84 fe ff       	call   f0100f8b <cprintf>
f0118b67:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118b6a:	e8 3f 5d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118b6f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118b72:	e8 2e bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b77:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f0118b7a:	83 ec 0c             	sub    $0xc,%esp
f0118b7d:	68 00 04 00 00       	push   $0x400
f0118b82:	e8 0a 09 ff ff       	call   f0109491 <kmalloc>
f0118b87:	83 c4 10             	add    $0x10,%esp
f0118b8a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f0118b8d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118b90:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0118b93:	81 c2 08 08 00 00    	add    $0x808,%edx
f0118b99:	39 d0                	cmp    %edx,%eax
f0118b9b:	74 17                	je     f0118bb4 <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f0118b9d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ba4:	83 ec 0c             	sub    $0xc,%esp
f0118ba7:	68 f4 ca 12 f0       	push   $0xf012caf4
f0118bac:	e8 da 83 fe ff       	call   f0100f8b <cprintf>
f0118bb1:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118bb4:	e8 ec bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118bb9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118bbc:	74 17                	je     f0118bd5 <test_kmalloc_firstfit2+0x92f>
f0118bbe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bc5:	83 ec 0c             	sub    $0xc,%esp
f0118bc8:	68 b8 bb 12 f0       	push   $0xf012bbb8
f0118bcd:	e8 b9 83 fe ff       	call   f0100f8b <cprintf>
f0118bd2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f0118bd5:	e8 d4 5c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118bda:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118bdd:	74 17                	je     f0118bf6 <test_kmalloc_firstfit2+0x950>
f0118bdf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118be6:	83 ec 0c             	sub    $0xc,%esp
f0118be9:	68 28 cb 12 f0       	push   $0xf012cb28
f0118bee:	e8 98 83 fe ff       	call   f0100f8b <cprintf>
f0118bf3:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f0118bf6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118bfa:	74 04                	je     f0118c00 <test_kmalloc_firstfit2+0x95a>
f0118bfc:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118c00:	83 ec 0c             	sub    $0xc,%esp
f0118c03:	68 40 cb 12 f0       	push   $0xf012cb40
f0118c08:	e8 7e 83 fe ff       	call   f0100f8b <cprintf>
f0118c0d:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118c10:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118c17:	e8 92 5c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118c1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118c1f:	e8 81 bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c24:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0118c27:	83 ec 0c             	sub    $0xc,%esp
f0118c2a:	68 00 04 70 00       	push   $0x700400
f0118c2f:	e8 5d 08 ff ff       	call   f0109491 <kmalloc>
f0118c34:	83 c4 10             	add    $0x10,%esp
f0118c37:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118c3a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118c3d:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118c42:	74 17                	je     f0118c5b <test_kmalloc_firstfit2+0x9b5>
f0118c44:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c4b:	83 ec 0c             	sub    $0xc,%esp
f0118c4e:	68 c8 c5 12 f0       	push   $0xf012c5c8
f0118c53:	e8 33 83 fe ff       	call   f0100f8b <cprintf>
f0118c58:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c5b:	e8 45 bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c60:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c63:	74 17                	je     f0118c7c <test_kmalloc_firstfit2+0x9d6>
f0118c65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c6c:	83 ec 0c             	sub    $0xc,%esp
f0118c6f:	68 fc c5 12 f0       	push   $0xf012c5fc
f0118c74:	e8 12 83 fe ff       	call   f0100f8b <cprintf>
f0118c79:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0118c7c:	e8 2d 5c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118c81:	89 c2                	mov    %eax,%edx
f0118c83:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118c86:	29 d0                	sub    %edx,%eax
f0118c88:	3d 00 07 00 00       	cmp    $0x700,%eax
f0118c8d:	7f 17                	jg     f0118ca6 <test_kmalloc_firstfit2+0xa00>
f0118c8f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c96:	83 ec 0c             	sub    $0xc,%esp
f0118c99:	68 68 c6 12 f0       	push   $0xf012c668
f0118c9e:	e8 e8 82 fe ff       	call   f0100f8b <cprintf>
f0118ca3:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118ca6:	e8 03 5c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118cab:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118cae:	e8 f2 bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118cb3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f0118cb6:	83 ec 0c             	sub    $0xc,%esp
f0118cb9:	68 00 0c 00 00       	push   $0xc00
f0118cbe:	e8 ce 07 ff ff       	call   f0109491 <kmalloc>
f0118cc3:	83 c4 10             	add    $0x10,%esp
f0118cc6:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f0118cc9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118ccc:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f0118cd1:	74 17                	je     f0118cea <test_kmalloc_firstfit2+0xa44>
f0118cd3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cda:	83 ec 0c             	sub    $0xc,%esp
f0118cdd:	68 74 cb 12 f0       	push   $0xf012cb74
f0118ce2:	e8 a4 82 fe ff       	call   f0100f8b <cprintf>
f0118ce7:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118cea:	e8 b6 bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118cef:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118cf2:	74 17                	je     f0118d0b <test_kmalloc_firstfit2+0xa65>
f0118cf4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cfb:	83 ec 0c             	sub    $0xc,%esp
f0118cfe:	68 a8 cb 12 f0       	push   $0xf012cba8
f0118d03:	e8 83 82 fe ff       	call   f0100f8b <cprintf>
f0118d08:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f0118d0b:	e8 9e 5b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118d10:	89 c2                	mov    %eax,%edx
f0118d12:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118d15:	29 d0                	sub    %edx,%eax
f0118d17:	85 c0                	test   %eax,%eax
f0118d19:	7f 17                	jg     f0118d32 <test_kmalloc_firstfit2+0xa8c>
f0118d1b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d22:	83 ec 0c             	sub    $0xc,%esp
f0118d25:	68 14 cc 12 f0       	push   $0xf012cc14
f0118d2a:	e8 5c 82 fe ff       	call   f0100f8b <cprintf>
f0118d2f:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f0118d32:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118d36:	74 04                	je     f0118d3c <test_kmalloc_firstfit2+0xa96>
f0118d38:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f0118d3c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f0118d43:	83 ec 0c             	sub    $0xc,%esp
f0118d46:	68 2c cc 12 f0       	push   $0xf012cc2c
f0118d4b:	e8 3b 82 fe ff       	call   f0100f8b <cprintf>
f0118d50:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f0118d53:	83 ec 0c             	sub    $0xc,%esp
f0118d56:	68 00 e0 1f 07       	push   $0x71fe000
f0118d5b:	e8 31 07 ff ff       	call   f0109491 <kmalloc>
f0118d60:	83 c4 10             	add    $0x10,%esp
f0118d63:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f0118d66:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118d69:	85 c0                	test   %eax,%eax
f0118d6b:	74 17                	je     f0118d84 <test_kmalloc_firstfit2+0xade>
f0118d6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d74:	83 ec 0c             	sub    $0xc,%esp
f0118d77:	68 80 cc 12 f0       	push   $0xf012cc80
f0118d7c:	e8 0a 82 fe ff       	call   f0100f8b <cprintf>
f0118d81:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f0118d84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118d88:	74 04                	je     f0118d8e <test_kmalloc_firstfit2+0xae8>
f0118d8a:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f0118d8e:	83 ec 08             	sub    $0x8,%esp
f0118d91:	ff 75 f4             	pushl  -0xc(%ebp)
f0118d94:	68 e8 cc 12 f0       	push   $0xf012cce8
f0118d99:	e8 ed 81 fe ff       	call   f0100f8b <cprintf>
f0118d9e:	83 c4 10             	add    $0x10,%esp

	return 1;
f0118da1:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0118da6:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0118da9:	5b                   	pop    %ebx
f0118daa:	5f                   	pop    %edi
f0118dab:	5d                   	pop    %ebp
f0118dac:	c3                   	ret    

f0118dad <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f0118dad:	55                   	push   %ebp
f0118dae:	89 e5                	mov    %esp,%ebp
f0118db0:	53                   	push   %ebx
f0118db1:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118db4:	83 ec 0c             	sub    $0xc,%esp
f0118db7:	68 68 ae 12 f0       	push   $0xf012ae68
f0118dbc:	e8 ca 81 fe ff       	call   f0100f8b <cprintf>
f0118dc1:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118dc4:	83 ec 0c             	sub    $0xc,%esp
f0118dc7:	68 98 ae 12 f0       	push   $0xf012ae98
f0118dcc:	e8 ba 81 fe ff       	call   f0100f8b <cprintf>
f0118dd1:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118dd4:	83 ec 0c             	sub    $0xc,%esp
f0118dd7:	68 68 ae 12 f0       	push   $0xf012ae68
f0118ddc:	e8 aa 81 fe ff       	call   f0100f8b <cprintf>
f0118de1:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f0118de4:	e8 c5 5a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118de9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f0118dec:	e8 b4 ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118df1:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f0118df4:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f0118dfb:	83 ec 0c             	sub    $0xc,%esp
f0118dfe:	68 1d cd 12 f0       	push   $0xf012cd1d
f0118e03:	e8 83 81 fe ff       	call   f0100f8b <cprintf>
f0118e08:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f0118e0b:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0118e10:	ba 00 00 00 00       	mov    $0x0,%edx
f0118e15:	f7 75 e4             	divl   -0x1c(%ebp)
f0118e18:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f0118e1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118e22:	eb 1d                	jmp    f0118e41 <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0118e24:	83 ec 0c             	sub    $0xc,%esp
f0118e27:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118e2a:	e8 62 06 ff ff       	call   f0109491 <kmalloc>
f0118e2f:	83 c4 10             	add    $0x10,%esp
f0118e32:	89 c2                	mov    %eax,%edx
f0118e34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118e37:	89 14 85 80 83 69 f0 	mov    %edx,-0xf967c80(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f0118e3e:	ff 45 f4             	incl   -0xc(%ebp)
f0118e41:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118e44:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118e47:	7c db                	jl     f0118e24 <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f0118e49:	83 ec 0c             	sub    $0xc,%esp
f0118e4c:	68 21 cd 12 f0       	push   $0xf012cd21
f0118e51:	e8 35 81 fe ff       	call   f0100f8b <cprintf>
f0118e56:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f0118e59:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0118e5e:	ba 00 00 00 00       	mov    $0x0,%edx
f0118e63:	f7 75 e4             	divl   -0x1c(%ebp)
f0118e66:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f0118e69:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0118e6d:	74 1e                	je     f0118e8d <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f0118e6f:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0118e72:	8d 43 01             	lea    0x1(%ebx),%eax
f0118e75:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118e78:	83 ec 0c             	sub    $0xc,%esp
f0118e7b:	ff 75 e0             	pushl  -0x20(%ebp)
f0118e7e:	e8 0e 06 ff ff       	call   f0109491 <kmalloc>
f0118e83:	83 c4 10             	add    $0x10,%esp
f0118e86:	89 04 9d 80 83 69 f0 	mov    %eax,-0xf967c80(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f0118e8d:	83 ec 04             	sub    $0x4,%esp
f0118e90:	ff 75 f0             	pushl  -0x10(%ebp)
f0118e93:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118e96:	68 28 cd 12 f0       	push   $0xf012cd28
f0118e9b:	e8 eb 80 fe ff       	call   f0100f8b <cprintf>
f0118ea0:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0118ea3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118eaa:	eb 36                	jmp    f0118ee2 <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f0118eac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118eaf:	8b 04 85 80 83 69 f0 	mov    -0xf967c80(,%eax,4),%eax
f0118eb6:	89 c2                	mov    %eax,%edx
f0118eb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118ebb:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118ebf:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f0118ec4:	39 c2                	cmp    %eax,%edx
f0118ec6:	74 17                	je     f0118edf <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f0118ec8:	83 ec 04             	sub    $0x4,%esp
f0118ecb:	68 70 cd 12 f0       	push   $0xf012cd70
f0118ed0:	68 e3 02 00 00       	push   $0x2e3
f0118ed5:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0118eda:	e8 5a 74 fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0118edf:	ff 45 f4             	incl   -0xc(%ebp)
f0118ee2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118ee5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118ee8:	7c c2                	jl     f0118eac <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118eea:	e8 b6 b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118eef:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118ef2:	74 17                	je     f0118f0b <test_fastfirstfit+0x15e>
f0118ef4:	83 ec 04             	sub    $0x4,%esp
f0118ef7:	68 cc cd 12 f0       	push   $0xf012cdcc
f0118efc:	68 e6 02 00 00       	push   $0x2e6
f0118f01:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0118f06:	e8 2e 74 fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f0118f0b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118f0e:	e8 9b 59 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118f13:	29 c3                	sub    %eax,%ebx
f0118f15:	89 d8                	mov    %ebx,%eax
f0118f17:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f0118f1c:	77 17                	ja     f0118f35 <test_fastfirstfit+0x188>
f0118f1e:	83 ec 04             	sub    $0x4,%esp
f0118f21:	68 34 ce 12 f0       	push   $0xf012ce34
f0118f26:	68 e7 02 00 00       	push   $0x2e7
f0118f2b:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0118f30:	e8 04 74 fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0118f35:	e8 6b b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118f3a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f0118f3d:	e8 6c 59 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0118f42:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0118f45:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f0118f49:	7f 17                	jg     f0118f62 <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f0118f4b:	83 ec 04             	sub    $0x4,%esp
f0118f4e:	68 48 ce 12 f0       	push   $0xf012ce48
f0118f53:	68 ee 02 00 00       	push   $0x2ee
f0118f58:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0118f5d:	e8 d7 73 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f0118f62:	a1 80 83 69 f0       	mov    0xf0698380,%eax
f0118f67:	83 ec 0c             	sub    $0xc,%esp
f0118f6a:	50                   	push   %eax
f0118f6b:	e8 81 07 ff ff       	call   f01096f1 <kfree>
f0118f70:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f0118f73:	a1 88 83 69 f0       	mov    0xf0698388,%eax
f0118f78:	83 ec 0c             	sub    $0xc,%esp
f0118f7b:	50                   	push   %eax
f0118f7c:	e8 70 07 ff ff       	call   f01096f1 <kfree>
f0118f81:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f0118f84:	a1 8c 83 69 f0       	mov    0xf069838c,%eax
f0118f89:	83 ec 0c             	sub    $0xc,%esp
f0118f8c:	50                   	push   %eax
f0118f8d:	e8 5f 07 ff ff       	call   f01096f1 <kfree>
f0118f92:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f0118f95:	a1 94 83 69 f0       	mov    0xf0698394,%eax
f0118f9a:	83 ec 0c             	sub    $0xc,%esp
f0118f9d:	50                   	push   %eax
f0118f9e:	e8 4e 07 ff ff       	call   f01096f1 <kfree>
f0118fa3:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f0118fa6:	a1 a8 83 69 f0       	mov    0xf06983a8,%eax
f0118fab:	83 ec 0c             	sub    $0xc,%esp
f0118fae:	50                   	push   %eax
f0118faf:	e8 3d 07 ff ff       	call   f01096f1 <kfree>
f0118fb4:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f0118fb7:	a1 b0 83 69 f0       	mov    0xf06983b0,%eax
f0118fbc:	83 ec 0c             	sub    $0xc,%esp
f0118fbf:	50                   	push   %eax
f0118fc0:	e8 2c 07 ff ff       	call   f01096f1 <kfree>
f0118fc5:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f0118fc8:	a1 ac 83 69 f0       	mov    0xf06983ac,%eax
f0118fcd:	83 ec 0c             	sub    $0xc,%esp
f0118fd0:	50                   	push   %eax
f0118fd1:	e8 1b 07 ff ff       	call   f01096f1 <kfree>
f0118fd6:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f0118fd9:	a1 d0 83 69 f0       	mov    0xf06983d0,%eax
f0118fde:	83 ec 0c             	sub    $0xc,%esp
f0118fe1:	50                   	push   %eax
f0118fe2:	e8 0a 07 ff ff       	call   f01096f1 <kfree>
f0118fe7:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f0118fea:	a1 e4 83 69 f0       	mov    0xf06983e4,%eax
f0118fef:	83 ec 0c             	sub    $0xc,%esp
f0118ff2:	50                   	push   %eax
f0118ff3:	e8 f9 06 ff ff       	call   f01096f1 <kfree>
f0118ff8:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f0118ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118ffe:	83 e8 02             	sub    $0x2,%eax
f0119001:	8b 04 85 80 83 69 f0 	mov    -0xf967c80(,%eax,4),%eax
f0119008:	83 ec 0c             	sub    $0xc,%esp
f011900b:	50                   	push   %eax
f011900c:	e8 e0 06 ff ff       	call   f01096f1 <kfree>
f0119011:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f0119014:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119017:	83 e8 03             	sub    $0x3,%eax
f011901a:	8b 04 85 80 83 69 f0 	mov    -0xf967c80(,%eax,4),%eax
f0119021:	83 ec 0c             	sub    $0xc,%esp
f0119024:	50                   	push   %eax
f0119025:	e8 c7 06 ff ff       	call   f01096f1 <kfree>
f011902a:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011902d:	e8 73 b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119032:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119035:	74 17                	je     f011904e <test_fastfirstfit+0x2a1>
f0119037:	83 ec 04             	sub    $0x4,%esp
f011903a:	68 cc cd 12 f0       	push   $0xf012cdcc
f011903f:	68 fb 02 00 00       	push   $0x2fb
f0119044:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0119049:	e8 eb 72 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f011904e:	e8 5b 58 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119053:	89 c2                	mov    %eax,%edx
f0119055:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119058:	89 d1                	mov    %edx,%ecx
f011905a:	29 c1                	sub    %eax,%ecx
f011905c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011905f:	89 d0                	mov    %edx,%eax
f0119061:	c1 e0 02             	shl    $0x2,%eax
f0119064:	01 d0                	add    %edx,%eax
f0119066:	01 c0                	add    %eax,%eax
f0119068:	01 d0                	add    %edx,%eax
f011906a:	c1 e8 0c             	shr    $0xc,%eax
f011906d:	39 c1                	cmp    %eax,%ecx
f011906f:	74 17                	je     f0119088 <test_fastfirstfit+0x2db>
f0119071:	83 ec 04             	sub    $0x4,%esp
f0119074:	68 84 ce 12 f0       	push   $0xf012ce84
f0119079:	68 fc 02 00 00       	push   $0x2fc
f011907e:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0119083:	e8 b1 72 fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f0119088:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011908b:	01 c0                	add    %eax,%eax
f011908d:	89 c2                	mov    %eax,%edx
f011908f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119092:	d1 e8                	shr    %eax
f0119094:	01 d0                	add    %edx,%eax
f0119096:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119099:	e8 07 b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011909e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01190a1:	e8 08 58 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01190a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01190a9:	83 ec 0c             	sub    $0xc,%esp
f01190ac:	ff 75 dc             	pushl  -0x24(%ebp)
f01190af:	e8 dd 03 ff ff       	call   f0109491 <kmalloc>
f01190b4:	83 c4 10             	add    $0x10,%esp
f01190b7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f01190ba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01190bd:	89 d0                	mov    %edx,%eax
f01190bf:	c1 e0 02             	shl    $0x2,%eax
f01190c2:	01 d0                	add    %edx,%eax
f01190c4:	01 c0                	add    %eax,%eax
f01190c6:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01190cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01190cf:	39 c2                	cmp    %eax,%edx
f01190d1:	74 17                	je     f01190ea <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f01190d3:	83 ec 04             	sub    $0x4,%esp
f01190d6:	68 c4 ce 12 f0       	push   $0xf012cec4
f01190db:	68 07 03 00 00       	push   $0x307
f01190e0:	68 b3 cd 12 f0       	push   $0xf012cdb3
f01190e5:	e8 4f 72 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01190ea:	e8 b6 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01190ef:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01190f2:	74 17                	je     f011910b <test_fastfirstfit+0x35e>
f01190f4:	83 ec 04             	sub    $0x4,%esp
f01190f7:	68 cc cd 12 f0       	push   $0xf012cdcc
f01190fc:	68 08 03 00 00       	push   $0x308
f0119101:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0119106:	e8 2e 72 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f011910b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011910e:	e8 9b 57 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119113:	29 c3                	sub    %eax,%ebx
f0119115:	89 da                	mov    %ebx,%edx
f0119117:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011911a:	c1 e8 0c             	shr    $0xc,%eax
f011911d:	39 c2                	cmp    %eax,%edx
f011911f:	73 17                	jae    f0119138 <test_fastfirstfit+0x38b>
f0119121:	83 ec 04             	sub    $0x4,%esp
f0119124:	68 34 ce 12 f0       	push   $0xf012ce34
f0119129:	68 09 03 00 00       	push   $0x309
f011912e:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0119133:	e8 01 72 fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f0119138:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011913b:	01 c0                	add    %eax,%eax
f011913d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119140:	e8 60 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119145:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119148:	e8 61 57 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011914d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119150:	83 ec 0c             	sub    $0xc,%esp
f0119153:	ff 75 dc             	pushl  -0x24(%ebp)
f0119156:	e8 36 03 ff ff       	call   f0109491 <kmalloc>
f011915b:	83 c4 10             	add    $0x10,%esp
f011915e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f0119161:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119164:	05 00 08 00 7c       	add    $0x7c000800,%eax
f0119169:	01 c0                	add    %eax,%eax
f011916b:	89 c2                	mov    %eax,%edx
f011916d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0119170:	39 c2                	cmp    %eax,%edx
f0119172:	74 17                	je     f011918b <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f0119174:	83 ec 04             	sub    $0x4,%esp
f0119177:	68 c4 ce 12 f0       	push   $0xf012cec4
f011917c:	68 13 03 00 00       	push   $0x313
f0119181:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0119186:	e8 ae 71 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011918b:	e8 15 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119190:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119193:	74 17                	je     f01191ac <test_fastfirstfit+0x3ff>
f0119195:	83 ec 04             	sub    $0x4,%esp
f0119198:	68 cc cd 12 f0       	push   $0xf012cdcc
f011919d:	68 14 03 00 00       	push   $0x314
f01191a2:	68 b3 cd 12 f0       	push   $0xf012cdb3
f01191a7:	e8 8d 71 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01191ac:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01191af:	e8 fa 56 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01191b4:	29 c3                	sub    %eax,%ebx
f01191b6:	89 da                	mov    %ebx,%edx
f01191b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01191bb:	c1 e8 0c             	shr    $0xc,%eax
f01191be:	39 c2                	cmp    %eax,%edx
f01191c0:	73 17                	jae    f01191d9 <test_fastfirstfit+0x42c>
f01191c2:	83 ec 04             	sub    $0x4,%esp
f01191c5:	68 34 ce 12 f0       	push   $0xf012ce34
f01191ca:	68 15 03 00 00       	push   $0x315
f01191cf:	68 b3 cd 12 f0       	push   $0xf012cdb3
f01191d4:	e8 60 71 fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f01191d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01191dc:	89 c2                	mov    %eax,%edx
f01191de:	01 d2                	add    %edx,%edx
f01191e0:	01 d0                	add    %edx,%eax
f01191e2:	d1 e8                	shr    %eax
f01191e4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01191e7:	e8 b9 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01191ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01191ef:	e8 ba 56 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01191f4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01191f7:	83 ec 0c             	sub    $0xc,%esp
f01191fa:	ff 75 dc             	pushl  -0x24(%ebp)
f01191fd:	e8 8f 02 ff ff       	call   f0109491 <kmalloc>
f0119202:	83 c4 10             	add    $0x10,%esp
f0119205:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f0119208:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011920b:	83 e8 03             	sub    $0x3,%eax
f011920e:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0119212:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119218:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011921b:	39 c2                	cmp    %eax,%edx
f011921d:	74 17                	je     f0119236 <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f011921f:	83 ec 04             	sub    $0x4,%esp
f0119222:	68 c4 ce 12 f0       	push   $0xf012cec4
f0119227:	68 1f 03 00 00       	push   $0x31f
f011922c:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0119231:	e8 03 71 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119236:	e8 6a b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011923b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011923e:	74 17                	je     f0119257 <test_fastfirstfit+0x4aa>
f0119240:	83 ec 04             	sub    $0x4,%esp
f0119243:	68 cc cd 12 f0       	push   $0xf012cdcc
f0119248:	68 20 03 00 00       	push   $0x320
f011924d:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0119252:	e8 e2 70 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119257:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011925a:	e8 4f 56 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011925f:	29 c3                	sub    %eax,%ebx
f0119261:	89 da                	mov    %ebx,%edx
f0119263:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119266:	c1 e8 0c             	shr    $0xc,%eax
f0119269:	39 c2                	cmp    %eax,%edx
f011926b:	73 17                	jae    f0119284 <test_fastfirstfit+0x4d7>
f011926d:	83 ec 04             	sub    $0x4,%esp
f0119270:	68 34 ce 12 f0       	push   $0xf012ce34
f0119275:	68 21 03 00 00       	push   $0x321
f011927a:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011927f:	e8 b5 70 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119284:	e8 1c b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119289:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011928c:	e8 1d 56 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119291:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119294:	83 ec 0c             	sub    $0xc,%esp
f0119297:	ff 75 e4             	pushl  -0x1c(%ebp)
f011929a:	e8 f2 01 ff ff       	call   f0109491 <kmalloc>
f011929f:	83 c4 10             	add    $0x10,%esp
f01192a2:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f01192a5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01192a8:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01192ad:	74 17                	je     f01192c6 <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f01192af:	83 ec 04             	sub    $0x4,%esp
f01192b2:	68 c4 ce 12 f0       	push   $0xf012cec4
f01192b7:	68 2a 03 00 00       	push   $0x32a
f01192bc:	68 b3 cd 12 f0       	push   $0xf012cdb3
f01192c1:	e8 73 70 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01192c6:	e8 da b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01192cb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01192ce:	74 17                	je     f01192e7 <test_fastfirstfit+0x53a>
f01192d0:	83 ec 04             	sub    $0x4,%esp
f01192d3:	68 cc cd 12 f0       	push   $0xf012cdcc
f01192d8:	68 2b 03 00 00       	push   $0x32b
f01192dd:	68 b3 cd 12 f0       	push   $0xf012cdb3
f01192e2:	e8 52 70 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01192e7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01192ea:	e8 bf 55 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01192ef:	29 c3                	sub    %eax,%ebx
f01192f1:	89 da                	mov    %ebx,%edx
f01192f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01192f6:	c1 e8 0c             	shr    $0xc,%eax
f01192f9:	39 c2                	cmp    %eax,%edx
f01192fb:	73 17                	jae    f0119314 <test_fastfirstfit+0x567>
f01192fd:	83 ec 04             	sub    $0x4,%esp
f0119300:	68 34 ce 12 f0       	push   $0xf012ce34
f0119305:	68 2c 03 00 00       	push   $0x32c
f011930a:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011930f:	e8 25 70 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119314:	e8 8c b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119319:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011931c:	e8 8d 55 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119321:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119324:	83 ec 0c             	sub    $0xc,%esp
f0119327:	ff 75 e4             	pushl  -0x1c(%ebp)
f011932a:	e8 62 01 ff ff       	call   f0109491 <kmalloc>
f011932f:	83 c4 10             	add    $0x10,%esp
f0119332:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f0119335:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119338:	89 d0                	mov    %edx,%eax
f011933a:	c1 e0 02             	shl    $0x2,%eax
f011933d:	01 d0                	add    %edx,%eax
f011933f:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119345:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119348:	39 c2                	cmp    %eax,%edx
f011934a:	74 17                	je     f0119363 <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f011934c:	83 ec 04             	sub    $0x4,%esp
f011934f:	68 c4 ce 12 f0       	push   $0xf012cec4
f0119354:	68 35 03 00 00       	push   $0x335
f0119359:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011935e:	e8 d6 6f fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119363:	e8 3d b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119368:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011936b:	74 17                	je     f0119384 <test_fastfirstfit+0x5d7>
f011936d:	83 ec 04             	sub    $0x4,%esp
f0119370:	68 cc cd 12 f0       	push   $0xf012cdcc
f0119375:	68 36 03 00 00       	push   $0x336
f011937a:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011937f:	e8 b5 6f fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119384:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119387:	e8 22 55 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011938c:	29 c3                	sub    %eax,%ebx
f011938e:	89 da                	mov    %ebx,%edx
f0119390:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119393:	c1 e8 0c             	shr    $0xc,%eax
f0119396:	39 c2                	cmp    %eax,%edx
f0119398:	73 17                	jae    f01193b1 <test_fastfirstfit+0x604>
f011939a:	83 ec 04             	sub    $0x4,%esp
f011939d:	68 34 ce 12 f0       	push   $0xf012ce34
f01193a2:	68 37 03 00 00       	push   $0x337
f01193a7:	68 b3 cd 12 f0       	push   $0xf012cdb3
f01193ac:	e8 88 6f fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01193b1:	e8 ef b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01193b6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01193b9:	e8 f0 54 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01193be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01193c1:	83 ec 0c             	sub    $0xc,%esp
f01193c4:	ff 75 e4             	pushl  -0x1c(%ebp)
f01193c7:	e8 c5 00 ff ff       	call   f0109491 <kmalloc>
f01193cc:	83 c4 10             	add    $0x10,%esp
f01193cf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f01193d2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01193d5:	89 d0                	mov    %edx,%eax
f01193d7:	c1 e0 02             	shl    $0x2,%eax
f01193da:	01 d0                	add    %edx,%eax
f01193dc:	c1 e0 02             	shl    $0x2,%eax
f01193df:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01193e5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01193e8:	39 c2                	cmp    %eax,%edx
f01193ea:	74 17                	je     f0119403 <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f01193ec:	83 ec 04             	sub    $0x4,%esp
f01193ef:	68 c4 ce 12 f0       	push   $0xf012cec4
f01193f4:	68 40 03 00 00       	push   $0x340
f01193f9:	68 b3 cd 12 f0       	push   $0xf012cdb3
f01193fe:	e8 36 6f fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119403:	e8 9d b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119408:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011940b:	74 17                	je     f0119424 <test_fastfirstfit+0x677>
f011940d:	83 ec 04             	sub    $0x4,%esp
f0119410:	68 cc cd 12 f0       	push   $0xf012cdcc
f0119415:	68 41 03 00 00       	push   $0x341
f011941a:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011941f:	e8 15 6f fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119424:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119427:	e8 82 54 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011942c:	29 c3                	sub    %eax,%ebx
f011942e:	89 da                	mov    %ebx,%edx
f0119430:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119433:	c1 e8 0c             	shr    $0xc,%eax
f0119436:	39 c2                	cmp    %eax,%edx
f0119438:	73 17                	jae    f0119451 <test_fastfirstfit+0x6a4>
f011943a:	83 ec 04             	sub    $0x4,%esp
f011943d:	68 34 ce 12 f0       	push   $0xf012ce34
f0119442:	68 42 03 00 00       	push   $0x342
f0119447:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011944c:	e8 e8 6e fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119451:	e8 4f b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119456:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119459:	e8 50 54 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011945e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119461:	83 ec 0c             	sub    $0xc,%esp
f0119464:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119467:	e8 25 00 ff ff       	call   f0109491 <kmalloc>
f011946c:	83 c4 10             	add    $0x10,%esp
f011946f:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f0119472:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119475:	89 d0                	mov    %edx,%eax
f0119477:	c1 e0 02             	shl    $0x2,%eax
f011947a:	01 d0                	add    %edx,%eax
f011947c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119483:	01 d0                	add    %edx,%eax
f0119485:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011948b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011948e:	39 c2                	cmp    %eax,%edx
f0119490:	74 17                	je     f01194a9 <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f0119492:	83 ec 04             	sub    $0x4,%esp
f0119495:	68 c4 ce 12 f0       	push   $0xf012cec4
f011949a:	68 4b 03 00 00       	push   $0x34b
f011949f:	68 b3 cd 12 f0       	push   $0xf012cdb3
f01194a4:	e8 90 6e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01194a9:	e8 f7 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01194ae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01194b1:	74 17                	je     f01194ca <test_fastfirstfit+0x71d>
f01194b3:	83 ec 04             	sub    $0x4,%esp
f01194b6:	68 cc cd 12 f0       	push   $0xf012cdcc
f01194bb:	68 4c 03 00 00       	push   $0x34c
f01194c0:	68 b3 cd 12 f0       	push   $0xf012cdb3
f01194c5:	e8 6f 6e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01194ca:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01194cd:	e8 dc 53 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01194d2:	29 c3                	sub    %eax,%ebx
f01194d4:	89 da                	mov    %ebx,%edx
f01194d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01194d9:	c1 e8 0c             	shr    $0xc,%eax
f01194dc:	39 c2                	cmp    %eax,%edx
f01194de:	73 17                	jae    f01194f7 <test_fastfirstfit+0x74a>
f01194e0:	83 ec 04             	sub    $0x4,%esp
f01194e3:	68 34 ce 12 f0       	push   $0xf012ce34
f01194e8:	68 4d 03 00 00       	push   $0x34d
f01194ed:	68 b3 cd 12 f0       	push   $0xf012cdb3
f01194f2:	e8 42 6e fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f01194f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01194fa:	d1 e8                	shr    %eax
f01194fc:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01194ff:	e8 a1 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119504:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119507:	e8 a2 53 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011950c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011950f:	83 ec 0c             	sub    $0xc,%esp
f0119512:	ff 75 dc             	pushl  -0x24(%ebp)
f0119515:	e8 77 ff fe ff       	call   f0109491 <kmalloc>
f011951a:	83 c4 10             	add    $0x10,%esp
f011951d:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f0119520:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119523:	89 d0                	mov    %edx,%eax
f0119525:	c1 e0 02             	shl    $0x2,%eax
f0119528:	01 d0                	add    %edx,%eax
f011952a:	01 c0                	add    %eax,%eax
f011952c:	89 c1                	mov    %eax,%ecx
f011952e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119531:	89 d0                	mov    %edx,%eax
f0119533:	c1 e0 02             	shl    $0x2,%eax
f0119536:	01 d0                	add    %edx,%eax
f0119538:	d1 e8                	shr    %eax
f011953a:	01 c8                	add    %ecx,%eax
f011953c:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119542:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119545:	39 c2                	cmp    %eax,%edx
f0119547:	74 17                	je     f0119560 <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f0119549:	83 ec 04             	sub    $0x4,%esp
f011954c:	68 c4 ce 12 f0       	push   $0xf012cec4
f0119551:	68 57 03 00 00       	push   $0x357
f0119556:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011955b:	e8 d9 6d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119560:	e8 40 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119565:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119568:	74 17                	je     f0119581 <test_fastfirstfit+0x7d4>
f011956a:	83 ec 04             	sub    $0x4,%esp
f011956d:	68 cc cd 12 f0       	push   $0xf012cdcc
f0119572:	68 58 03 00 00       	push   $0x358
f0119577:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011957c:	e8 b8 6d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119581:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119584:	e8 25 53 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119589:	29 c3                	sub    %eax,%ebx
f011958b:	89 da                	mov    %ebx,%edx
f011958d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119590:	c1 e8 0c             	shr    $0xc,%eax
f0119593:	39 c2                	cmp    %eax,%edx
f0119595:	73 17                	jae    f01195ae <test_fastfirstfit+0x801>
f0119597:	83 ec 04             	sub    $0x4,%esp
f011959a:	68 34 ce 12 f0       	push   $0xf012ce34
f011959f:	68 59 03 00 00       	push   $0x359
f01195a4:	68 b3 cd 12 f0       	push   $0xf012cdb3
f01195a9:	e8 8b 6d fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f01195ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01195b1:	d1 e8                	shr    %eax
f01195b3:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01195b6:	e8 ea b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01195bb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01195be:	e8 eb 52 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01195c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01195c6:	83 ec 0c             	sub    $0xc,%esp
f01195c9:	ff 75 dc             	pushl  -0x24(%ebp)
f01195cc:	e8 c0 fe fe ff       	call   f0109491 <kmalloc>
f01195d1:	83 c4 10             	add    $0x10,%esp
f01195d4:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f01195d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01195da:	83 e8 03             	sub    $0x3,%eax
f01195dd:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f01195e1:	89 c2                	mov    %eax,%edx
f01195e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01195e6:	89 c1                	mov    %eax,%ecx
f01195e8:	01 c9                	add    %ecx,%ecx
f01195ea:	01 c8                	add    %ecx,%eax
f01195ec:	d1 e8                	shr    %eax
f01195ee:	01 d0                	add    %edx,%eax
f01195f0:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01195f6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01195f9:	39 c2                	cmp    %eax,%edx
f01195fb:	74 17                	je     f0119614 <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f01195fd:	83 ec 04             	sub    $0x4,%esp
f0119600:	68 c4 ce 12 f0       	push   $0xf012cec4
f0119605:	68 63 03 00 00       	push   $0x363
f011960a:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011960f:	e8 25 6d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119614:	e8 8c b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119619:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011961c:	74 17                	je     f0119635 <test_fastfirstfit+0x888>
f011961e:	83 ec 04             	sub    $0x4,%esp
f0119621:	68 cc cd 12 f0       	push   $0xf012cdcc
f0119626:	68 64 03 00 00       	push   $0x364
f011962b:	68 b3 cd 12 f0       	push   $0xf012cdb3
f0119630:	e8 04 6d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119635:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119638:	e8 71 52 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011963d:	29 c3                	sub    %eax,%ebx
f011963f:	89 da                	mov    %ebx,%edx
f0119641:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119644:	c1 e8 0c             	shr    $0xc,%eax
f0119647:	39 c2                	cmp    %eax,%edx
f0119649:	73 17                	jae    f0119662 <test_fastfirstfit+0x8b5>
f011964b:	83 ec 04             	sub    $0x4,%esp
f011964e:	68 34 ce 12 f0       	push   $0xf012ce34
f0119653:	68 65 03 00 00       	push   $0x365
f0119658:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011965d:	e8 d7 6c fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f0119662:	83 ec 0c             	sub    $0xc,%esp
f0119665:	68 e4 ce 12 f0       	push   $0xf012cee4
f011966a:	e8 1c 79 fe ff       	call   f0100f8b <cprintf>
f011966f:	83 c4 10             	add    $0x10,%esp
	return 1;
f0119672:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0119677:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011967a:	c9                   	leave  
f011967b:	c3                   	ret    

f011967c <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f011967c:	55                   	push   %ebp
f011967d:	89 e5                	mov    %esp,%ebp
f011967f:	57                   	push   %edi
f0119680:	53                   	push   %ebx
f0119681:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119687:	83 ec 0c             	sub    $0xc,%esp
f011968a:	68 68 ae 12 f0       	push   $0xf012ae68
f011968f:	e8 f7 78 fe ff       	call   f0100f8b <cprintf>
f0119694:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0119697:	83 ec 0c             	sub    $0xc,%esp
f011969a:	68 98 ae 12 f0       	push   $0xf012ae98
f011969f:	e8 e7 78 fe ff       	call   f0100f8b <cprintf>
f01196a4:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01196a7:	83 ec 0c             	sub    $0xc,%esp
f01196aa:	68 68 ae 12 f0       	push   $0xf012ae68
f01196af:	e8 d7 78 fe ff       	call   f0100f8b <cprintf>
f01196b4:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f01196b7:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f01196bb:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f01196bf:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f01196c5:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f01196cb:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f01196d2:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f01196d9:	e8 d0 51 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01196de:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f01196e1:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f01196e7:	b9 14 00 00 00       	mov    $0x14,%ecx
f01196ec:	b8 00 00 00 00       	mov    $0x0,%eax
f01196f1:	89 d7                	mov    %edx,%edi
f01196f3:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f01196f5:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f01196fb:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119700:	b8 00 00 00 00       	mov    $0x0,%eax
f0119705:	89 d7                	mov    %edx,%edi
f0119707:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f0119709:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f0119710:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f0119717:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011971e:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f0119724:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119729:	b8 00 00 00 00       	mov    $0x0,%eax
f011972e:	89 d7                	mov    %edx,%edi
f0119730:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f0119732:	83 ec 0c             	sub    $0xc,%esp
f0119735:	68 28 cf 12 f0       	push   $0xf012cf28
f011973a:	e8 4c 78 fe ff       	call   f0100f8b <cprintf>
f011973f:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119742:	e8 67 51 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119747:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011974a:	e8 56 b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011974f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0119752:	83 ec 0c             	sub    $0xc,%esp
f0119755:	68 00 fc 1f 00       	push   $0x1ffc00
f011975a:	e8 32 fd fe ff       	call   f0109491 <kmalloc>
f011975f:	83 c4 10             	add    $0x10,%esp
f0119762:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119768:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011976e:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119773:	74 17                	je     f011978c <test_kfree_bestfirstfit+0x110>
f0119775:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011977c:	83 ec 0c             	sub    $0xc,%esp
f011977f:	68 60 cf 12 f0       	push   $0xf012cf60
f0119784:	e8 02 78 fe ff       	call   f0100f8b <cprintf>
f0119789:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011978c:	e8 14 b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119791:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119794:	74 17                	je     f01197ad <test_kfree_bestfirstfit+0x131>
f0119796:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011979d:	83 ec 0c             	sub    $0xc,%esp
f01197a0:	68 b4 cf 12 f0       	push   $0xf012cfb4
f01197a5:	e8 e1 77 fe ff       	call   f0100f8b <cprintf>
f01197aa:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01197ad:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01197b0:	e8 f9 50 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01197b5:	29 c3                	sub    %eax,%ebx
f01197b7:	89 d8                	mov    %ebx,%eax
f01197b9:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01197be:	77 17                	ja     f01197d7 <test_kfree_bestfirstfit+0x15b>
f01197c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197c7:	83 ec 0c             	sub    $0xc,%esp
f01197ca:	68 24 d0 12 f0       	push   $0xf012d024
f01197cf:	e8 b7 77 fe ff       	call   f0100f8b <cprintf>
f01197d4:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f01197d7:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f01197de:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f01197e1:	e8 c8 50 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01197e6:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01197e9:	e8 b7 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01197ee:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01197f1:	83 ec 0c             	sub    $0xc,%esp
f01197f4:	68 00 fc 1f 00       	push   $0x1ffc00
f01197f9:	e8 93 fc fe ff       	call   f0109491 <kmalloc>
f01197fe:	83 c4 10             	add    $0x10,%esp
f0119801:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119807:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011980d:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119812:	74 17                	je     f011982b <test_kfree_bestfirstfit+0x1af>
f0119814:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011981b:	83 ec 0c             	sub    $0xc,%esp
f011981e:	68 6c d0 12 f0       	push   $0xf012d06c
f0119823:	e8 63 77 fe ff       	call   f0100f8b <cprintf>
f0119828:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011982b:	e8 75 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119830:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119833:	74 17                	je     f011984c <test_kfree_bestfirstfit+0x1d0>
f0119835:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011983c:	83 ec 0c             	sub    $0xc,%esp
f011983f:	68 c0 d0 12 f0       	push   $0xf012d0c0
f0119844:	e8 42 77 fe ff       	call   f0100f8b <cprintf>
f0119849:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011984c:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011984f:	e8 5a 50 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119854:	29 c3                	sub    %eax,%ebx
f0119856:	89 d8                	mov    %ebx,%eax
f0119858:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011985d:	77 17                	ja     f0119876 <test_kfree_bestfirstfit+0x1fa>
f011985f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119866:	83 ec 0c             	sub    $0xc,%esp
f0119869:	68 30 d1 12 f0       	push   $0xf012d130
f011986e:	e8 18 77 fe ff       	call   f0100f8b <cprintf>
f0119873:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f0119876:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f011987d:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f0119880:	e8 29 50 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119885:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119888:	e8 18 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011988d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f0119890:	83 ec 0c             	sub    $0xc,%esp
f0119893:	68 00 1c 00 00       	push   $0x1c00
f0119898:	e8 f4 fb fe ff       	call   f0109491 <kmalloc>
f011989d:	83 c4 10             	add    $0x10,%esp
f01198a0:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01198a6:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f01198ac:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01198b1:	74 17                	je     f01198ca <test_kfree_bestfirstfit+0x24e>
f01198b3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198ba:	83 ec 0c             	sub    $0xc,%esp
f01198bd:	68 78 d1 12 f0       	push   $0xf012d178
f01198c2:	e8 c4 76 fe ff       	call   f0100f8b <cprintf>
f01198c7:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01198ca:	e8 d6 af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01198cf:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01198d2:	74 17                	je     f01198eb <test_kfree_bestfirstfit+0x26f>
f01198d4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198db:	83 ec 0c             	sub    $0xc,%esp
f01198de:	68 cc d1 12 f0       	push   $0xf012d1cc
f01198e3:	e8 a3 76 fe ff       	call   f0100f8b <cprintf>
f01198e8:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01198eb:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01198ee:	e8 bb 4f ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01198f3:	29 c3                	sub    %eax,%ebx
f01198f5:	89 d8                	mov    %ebx,%eax
f01198f7:	83 f8 01             	cmp    $0x1,%eax
f01198fa:	77 17                	ja     f0119913 <test_kfree_bestfirstfit+0x297>
f01198fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119903:	83 ec 0c             	sub    $0xc,%esp
f0119906:	68 3c d2 12 f0       	push   $0xf012d23c
f011990b:	e8 7b 76 fe ff       	call   f0100f8b <cprintf>
f0119910:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f0119913:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f011991a:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f011991d:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119923:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f0119926:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011992d:	eb 0e                	jmp    f011993d <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f011992f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119932:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119935:	01 d0                	add    %edx,%eax
f0119937:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f011993a:	ff 45 f4             	incl   -0xc(%ebp)
f011993d:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0119943:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119946:	7f e7                	jg     f011992f <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f0119948:	e8 61 4f ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011994d:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119950:	e8 50 af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119955:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0119958:	83 ec 0c             	sub    $0xc,%esp
f011995b:	68 00 fc 2f 00       	push   $0x2ffc00
f0119960:	e8 2c fb fe ff       	call   f0109491 <kmalloc>
f0119965:	83 c4 10             	add    $0x10,%esp
f0119968:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011996e:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119974:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0119979:	74 17                	je     f0119992 <test_kfree_bestfirstfit+0x316>
f011997b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119982:	83 ec 0c             	sub    $0xc,%esp
f0119985:	68 84 d2 12 f0       	push   $0xf012d284
f011998a:	e8 fc 75 fe ff       	call   f0100f8b <cprintf>
f011998f:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119992:	e8 0e af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119997:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011999a:	74 17                	je     f01199b3 <test_kfree_bestfirstfit+0x337>
f011999c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01199a3:	83 ec 0c             	sub    $0xc,%esp
f01199a6:	68 d8 d2 12 f0       	push   $0xf012d2d8
f01199ab:	e8 db 75 fe ff       	call   f0100f8b <cprintf>
f01199b0:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01199b3:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01199b6:	e8 f3 4e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f01199bb:	29 c3                	sub    %eax,%ebx
f01199bd:	89 d8                	mov    %ebx,%eax
f01199bf:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01199c4:	77 17                	ja     f01199dd <test_kfree_bestfirstfit+0x361>
f01199c6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01199cd:	83 ec 0c             	sub    $0xc,%esp
f01199d0:	68 48 d3 12 f0       	push   $0xf012d348
f01199d5:	e8 b1 75 fe ff       	call   f0100f8b <cprintf>
f01199da:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f01199dd:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f01199e4:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f01199e7:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f01199ed:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f01199f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01199f7:	eb 0e                	jmp    f0119a07 <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f01199f9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01199fc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01199ff:	01 d0                	add    %edx,%eax
f0119a01:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f0119a04:	ff 45 f4             	incl   -0xc(%ebp)
f0119a07:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0119a0d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a10:	7f e7                	jg     f01199f9 <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f0119a12:	e8 97 4e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119a17:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119a1a:	e8 86 ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119a1f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0119a22:	83 ec 0c             	sub    $0xc,%esp
f0119a25:	68 00 fc 5f 00       	push   $0x5ffc00
f0119a2a:	e8 62 fa fe ff       	call   f0109491 <kmalloc>
f0119a2f:	83 c4 10             	add    $0x10,%esp
f0119a32:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119a38:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0119a3e:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119a43:	74 17                	je     f0119a5c <test_kfree_bestfirstfit+0x3e0>
f0119a45:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a4c:	83 ec 0c             	sub    $0xc,%esp
f0119a4f:	68 90 d3 12 f0       	push   $0xf012d390
f0119a54:	e8 32 75 fe ff       	call   f0100f8b <cprintf>
f0119a59:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119a5c:	e8 44 ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119a61:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119a64:	74 17                	je     f0119a7d <test_kfree_bestfirstfit+0x401>
f0119a66:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a6d:	83 ec 0c             	sub    $0xc,%esp
f0119a70:	68 e4 d3 12 f0       	push   $0xf012d3e4
f0119a75:	e8 11 75 fe ff       	call   f0100f8b <cprintf>
f0119a7a:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119a7d:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119a80:	e8 29 4e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119a85:	29 c3                	sub    %eax,%ebx
f0119a87:	89 d8                	mov    %ebx,%eax
f0119a89:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119a8e:	77 17                	ja     f0119aa7 <test_kfree_bestfirstfit+0x42b>
f0119a90:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a97:	83 ec 0c             	sub    $0xc,%esp
f0119a9a:	68 54 d4 12 f0       	push   $0xf012d454
f0119a9f:	e8 e7 74 fe ff       	call   f0100f8b <cprintf>
f0119aa4:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f0119aa7:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f0119aae:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f0119ab1:	e8 f8 4d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119ab6:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119ab9:	e8 e7 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119abe:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f0119ac1:	83 ec 0c             	sub    $0xc,%esp
f0119ac4:	68 00 38 00 00       	push   $0x3800
f0119ac9:	e8 c3 f9 fe ff       	call   f0109491 <kmalloc>
f0119ace:	83 c4 10             	add    $0x10,%esp
f0119ad1:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119ad7:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119add:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0119ae2:	74 17                	je     f0119afb <test_kfree_bestfirstfit+0x47f>
f0119ae4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119aeb:	83 ec 0c             	sub    $0xc,%esp
f0119aee:	68 9c d4 12 f0       	push   $0xf012d49c
f0119af3:	e8 93 74 fe ff       	call   f0100f8b <cprintf>
f0119af8:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119afb:	e8 a5 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b00:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119b03:	74 17                	je     f0119b1c <test_kfree_bestfirstfit+0x4a0>
f0119b05:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b0c:	83 ec 0c             	sub    $0xc,%esp
f0119b0f:	68 f0 d4 12 f0       	push   $0xf012d4f0
f0119b14:	e8 72 74 fe ff       	call   f0100f8b <cprintf>
f0119b19:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119b1c:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119b1f:	e8 8a 4d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119b24:	29 c3                	sub    %eax,%ebx
f0119b26:	89 d8                	mov    %ebx,%eax
f0119b28:	83 f8 03             	cmp    $0x3,%eax
f0119b2b:	77 17                	ja     f0119b44 <test_kfree_bestfirstfit+0x4c8>
f0119b2d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b34:	83 ec 0c             	sub    $0xc,%esp
f0119b37:	68 60 d5 12 f0       	push   $0xf012d560
f0119b3c:	e8 4a 74 fe ff       	call   f0100f8b <cprintf>
f0119b41:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0119b44:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0119b4b:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119b51:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0119b54:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119b5b:	eb 0e                	jmp    f0119b6b <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f0119b5d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119b60:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119b63:	01 d0                	add    %edx,%eax
f0119b65:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f0119b68:	ff 45 f4             	incl   -0xc(%ebp)
f0119b6b:	8b 45 80             	mov    -0x80(%ebp),%eax
f0119b6e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119b71:	7f ea                	jg     f0119b5d <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f0119b73:	e8 36 4d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119b78:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119b7b:	e8 25 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b80:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f0119b83:	83 ec 0c             	sub    $0xc,%esp
f0119b86:	68 00 08 00 00       	push   $0x800
f0119b8b:	e8 01 f9 fe ff       	call   f0109491 <kmalloc>
f0119b90:	83 c4 10             	add    $0x10,%esp
f0119b93:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119b99:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119b9f:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119ba4:	76 28                	jbe    f0119bce <test_kfree_bestfirstfit+0x552>
f0119ba6:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f0119bac:	83 ec 0c             	sub    $0xc,%esp
f0119baf:	6a 00                	push   $0x0
f0119bb1:	e8 a8 f7 fe ff       	call   f010935e <sbrk>
f0119bb6:	83 c4 10             	add    $0x10,%esp
f0119bb9:	39 c3                	cmp    %eax,%ebx
f0119bbb:	73 11                	jae    f0119bce <test_kfree_bestfirstfit+0x552>
f0119bbd:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119bc3:	89 c2                	mov    %eax,%edx
f0119bc5:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0119bca:	39 c2                	cmp    %eax,%edx
f0119bcc:	72 17                	jb     f0119be5 <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119bce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bd5:	83 ec 0c             	sub    $0xc,%esp
f0119bd8:	68 a8 d5 12 f0       	push   $0xf012d5a8
f0119bdd:	e8 a9 73 fe ff       	call   f0100f8b <cprintf>
f0119be2:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119be5:	e8 bb ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119bea:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119bed:	74 17                	je     f0119c06 <test_kfree_bestfirstfit+0x58a>
f0119bef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bf6:	83 ec 0c             	sub    $0xc,%esp
f0119bf9:	68 34 d6 12 f0       	push   $0xf012d634
f0119bfe:	e8 88 73 fe ff       	call   f0100f8b <cprintf>
f0119c03:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f0119c06:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f0119c0d:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f0119c10:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119c16:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f0119c19:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119c20:	eb 0e                	jmp    f0119c30 <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f0119c22:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119c25:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119c28:	01 d0                	add    %edx,%eax
f0119c2a:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f0119c2d:	ff 45 f4             	incl   -0xc(%ebp)
f0119c30:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0119c36:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119c39:	7f e7                	jg     f0119c22 <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119c3b:	e8 65 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c40:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0119c43:	83 ec 0c             	sub    $0xc,%esp
f0119c46:	68 00 08 00 00       	push   $0x800
f0119c4b:	e8 41 f8 fe ff       	call   f0109491 <kmalloc>
f0119c50:	83 c4 10             	add    $0x10,%esp
f0119c53:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119c59:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119c5f:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119c64:	76 28                	jbe    f0119c8e <test_kfree_bestfirstfit+0x612>
f0119c66:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f0119c6c:	83 ec 0c             	sub    $0xc,%esp
f0119c6f:	6a 00                	push   $0x0
f0119c71:	e8 e8 f6 fe ff       	call   f010935e <sbrk>
f0119c76:	83 c4 10             	add    $0x10,%esp
f0119c79:	39 c3                	cmp    %eax,%ebx
f0119c7b:	73 11                	jae    f0119c8e <test_kfree_bestfirstfit+0x612>
f0119c7d:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119c83:	89 c2                	mov    %eax,%edx
f0119c85:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0119c8a:	39 c2                	cmp    %eax,%edx
f0119c8c:	72 17                	jb     f0119ca5 <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119c8e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c95:	83 ec 0c             	sub    $0xc,%esp
f0119c98:	68 a4 d6 12 f0       	push   $0xf012d6a4
f0119c9d:	e8 e9 72 fe ff       	call   f0100f8b <cprintf>
f0119ca2:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ca5:	e8 fb ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119caa:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119cad:	74 17                	je     f0119cc6 <test_kfree_bestfirstfit+0x64a>
f0119caf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119cb6:	83 ec 0c             	sub    $0xc,%esp
f0119cb9:	68 30 d7 12 f0       	push   $0xf012d730
f0119cbe:	e8 c8 72 fe ff       	call   f0100f8b <cprintf>
f0119cc3:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f0119cc6:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f0119ccd:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f0119cd0:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119cd6:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f0119cd9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119ce0:	eb 0e                	jmp    f0119cf0 <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f0119ce2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119ce5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119ce8:	01 d0                	add    %edx,%eax
f0119cea:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f0119ced:	ff 45 f4             	incl   -0xc(%ebp)
f0119cf0:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119cf6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119cf9:	7f e7                	jg     f0119ce2 <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f0119cfb:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119cfe:	e8 ab 4b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119d03:	29 c3                	sub    %eax,%ebx
f0119d05:	89 d8                	mov    %ebx,%eax
f0119d07:	83 f8 01             	cmp    $0x1,%eax
f0119d0a:	74 17                	je     f0119d23 <test_kfree_bestfirstfit+0x6a7>
f0119d0c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d13:	83 ec 0c             	sub    $0xc,%esp
f0119d16:	68 a0 d7 12 f0       	push   $0xf012d7a0
f0119d1b:	e8 6b 72 fe ff       	call   f0100f8b <cprintf>
f0119d20:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f0119d23:	83 ec 0c             	sub    $0xc,%esp
f0119d26:	68 c4 d7 12 f0       	push   $0xf012d7c4
f0119d2b:	e8 5b 72 fe ff       	call   f0100f8b <cprintf>
f0119d30:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f0119d33:	e8 76 4b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119d38:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f0119d3b:	e8 65 ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d40:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f0119d43:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0119d49:	83 ec 0c             	sub    $0xc,%esp
f0119d4c:	50                   	push   %eax
f0119d4d:	e8 9f f9 fe ff       	call   f01096f1 <kfree>
f0119d52:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d55:	e8 4b ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d5a:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119d5d:	74 17                	je     f0119d76 <test_kfree_bestfirstfit+0x6fa>
f0119d5f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d66:	83 ec 0c             	sub    $0xc,%esp
f0119d69:	68 f4 d7 12 f0       	push   $0xf012d7f4
f0119d6e:	e8 18 72 fe ff       	call   f0100f8b <cprintf>
f0119d73:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119d76:	e8 33 4b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119d7b:	89 c2                	mov    %eax,%edx
f0119d7d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119d80:	29 c2                	sub    %eax,%edx
f0119d82:	89 d0                	mov    %edx,%eax
f0119d84:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119d89:	77 17                	ja     f0119da2 <test_kfree_bestfirstfit+0x726>
f0119d8b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d92:	83 ec 0c             	sub    $0xc,%esp
f0119d95:	68 64 d8 12 f0       	push   $0xf012d864
f0119d9a:	e8 ec 71 fe ff       	call   f0100f8b <cprintf>
f0119d9f:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f0119da2:	e8 07 4b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119da7:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119daa:	e8 f6 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119daf:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f0119db2:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119db8:	83 ec 0c             	sub    $0xc,%esp
f0119dbb:	50                   	push   %eax
f0119dbc:	e8 30 f9 fe ff       	call   f01096f1 <kfree>
f0119dc1:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119dc4:	e8 dc aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119dc9:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119dcc:	74 17                	je     f0119de5 <test_kfree_bestfirstfit+0x769>
f0119dce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dd5:	83 ec 0c             	sub    $0xc,%esp
f0119dd8:	68 a0 d8 12 f0       	push   $0xf012d8a0
f0119ddd:	e8 a9 71 fe ff       	call   f0100f8b <cprintf>
f0119de2:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119de5:	e8 c4 4a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119dea:	89 c2                	mov    %eax,%edx
f0119dec:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119def:	39 c2                	cmp    %eax,%edx
f0119df1:	74 17                	je     f0119e0a <test_kfree_bestfirstfit+0x78e>
f0119df3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dfa:	83 ec 0c             	sub    $0xc,%esp
f0119dfd:	68 10 d9 12 f0       	push   $0xf012d910
f0119e02:	e8 84 71 fe ff       	call   f0100f8b <cprintf>
f0119e07:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f0119e0a:	e8 9f 4a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119e0f:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119e12:	e8 8e aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e17:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f0119e1a:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0119e20:	83 ec 0c             	sub    $0xc,%esp
f0119e23:	50                   	push   %eax
f0119e24:	e8 c8 f8 fe ff       	call   f01096f1 <kfree>
f0119e29:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e2c:	e8 74 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e31:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119e34:	74 17                	je     f0119e4d <test_kfree_bestfirstfit+0x7d1>
f0119e36:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e3d:	83 ec 0c             	sub    $0xc,%esp
f0119e40:	68 70 d9 12 f0       	push   $0xf012d970
f0119e45:	e8 41 71 fe ff       	call   f0100f8b <cprintf>
f0119e4a:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119e4d:	e8 5c 4a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119e52:	89 c2                	mov    %eax,%edx
f0119e54:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119e57:	29 c2                	sub    %eax,%edx
f0119e59:	89 d0                	mov    %edx,%eax
f0119e5b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119e60:	77 17                	ja     f0119e79 <test_kfree_bestfirstfit+0x7fd>
f0119e62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e69:	83 ec 0c             	sub    $0xc,%esp
f0119e6c:	68 e0 d9 12 f0       	push   $0xf012d9e0
f0119e71:	e8 15 71 fe ff       	call   f0100f8b <cprintf>
f0119e76:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f0119e79:	e8 30 4a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119e7e:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119e81:	e8 1f aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e86:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f0119e89:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0119e8f:	83 ec 0c             	sub    $0xc,%esp
f0119e92:	50                   	push   %eax
f0119e93:	e8 59 f8 fe ff       	call   f01096f1 <kfree>
f0119e98:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e9b:	e8 05 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ea0:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119ea3:	74 17                	je     f0119ebc <test_kfree_bestfirstfit+0x840>
f0119ea5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119eac:	83 ec 0c             	sub    $0xc,%esp
f0119eaf:	68 1c da 12 f0       	push   $0xf012da1c
f0119eb4:	e8 d2 70 fe ff       	call   f0100f8b <cprintf>
f0119eb9:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119ebc:	e8 ed 49 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f0119ec1:	89 c2                	mov    %eax,%edx
f0119ec3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119ec6:	29 c2                	sub    %eax,%edx
f0119ec8:	89 d0                	mov    %edx,%eax
f0119eca:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119ecf:	77 17                	ja     f0119ee8 <test_kfree_bestfirstfit+0x86c>
f0119ed1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ed8:	83 ec 0c             	sub    $0xc,%esp
f0119edb:	68 8c da 12 f0       	push   $0xf012da8c
f0119ee0:	e8 a6 70 fe ff       	call   f0100f8b <cprintf>
f0119ee5:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0119ee8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119eec:	74 04                	je     f0119ef2 <test_kfree_bestfirstfit+0x876>
f0119eee:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0119ef2:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f0119ef9:	83 ec 0c             	sub    $0xc,%esp
f0119efc:	68 c8 da 12 f0       	push   $0xf012dac8
f0119f01:	e8 85 70 fe ff       	call   f0100f8b <cprintf>
f0119f06:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f0119f09:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119f0f:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f0119f12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119f19:	eb 1e                	jmp    f0119f39 <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f0119f1b:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0119f21:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119f24:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119f27:	01 c8                	add    %ecx,%eax
f0119f29:	8a 00                	mov    (%eax),%al
f0119f2b:	0f be c0             	movsbl %al,%eax
f0119f2e:	01 d0                	add    %edx,%eax
f0119f30:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f0119f36:	ff 45 f4             	incl   -0xc(%ebp)
f0119f39:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119f3f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119f42:	7f d7                	jg     f0119f1b <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f0119f44:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0119f4a:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119f50:	89 c1                	mov    %eax,%ecx
f0119f52:	01 c9                	add    %ecx,%ecx
f0119f54:	01 c8                	add    %ecx,%eax
f0119f56:	39 c2                	cmp    %eax,%edx
f0119f58:	74 17                	je     f0119f71 <test_kfree_bestfirstfit+0x8f5>
f0119f5a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f61:	83 ec 0c             	sub    $0xc,%esp
f0119f64:	68 10 db 12 f0       	push   $0xf012db10
f0119f69:	e8 1d 70 fe ff       	call   f0100f8b <cprintf>
f0119f6e:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f0119f71:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119f77:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f0119f7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119f81:	eb 1e                	jmp    f0119fa1 <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f0119f83:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f0119f89:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119f8c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119f8f:	01 c8                	add    %ecx,%eax
f0119f91:	8a 00                	mov    (%eax),%al
f0119f93:	0f be c0             	movsbl %al,%eax
f0119f96:	01 d0                	add    %edx,%eax
f0119f98:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f0119f9e:	ff 45 f4             	incl   -0xc(%ebp)
f0119fa1:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0119fa7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119faa:	7f d7                	jg     f0119f83 <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f0119fac:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0119fb2:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f0119fb8:	c1 e2 02             	shl    $0x2,%edx
f0119fbb:	39 d0                	cmp    %edx,%eax
f0119fbd:	74 17                	je     f0119fd6 <test_kfree_bestfirstfit+0x95a>
f0119fbf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fc6:	83 ec 0c             	sub    $0xc,%esp
f0119fc9:	68 48 db 12 f0       	push   $0xf012db48
f0119fce:	e8 b8 6f fe ff       	call   f0100f8b <cprintf>
f0119fd3:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f0119fd6:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119fdc:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f0119fdf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119fe6:	eb 1e                	jmp    f011a006 <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f0119fe8:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f0119fee:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119ff1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119ff4:	01 c8                	add    %ecx,%eax
f0119ff6:	8a 00                	mov    (%eax),%al
f0119ff8:	0f be c0             	movsbl %al,%eax
f0119ffb:	01 d0                	add    %edx,%eax
f0119ffd:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011a003:	ff 45 f4             	incl   -0xc(%ebp)
f011a006:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a00c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a00f:	7f d7                	jg     f0119fe8 <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f011a011:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f011a017:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011a01d:	89 d0                	mov    %edx,%eax
f011a01f:	c1 e0 02             	shl    $0x2,%eax
f011a022:	01 d0                	add    %edx,%eax
f011a024:	39 c1                	cmp    %eax,%ecx
f011a026:	74 17                	je     f011a03f <test_kfree_bestfirstfit+0x9c3>
f011a028:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a02f:	83 ec 0c             	sub    $0xc,%esp
f011a032:	68 80 db 12 f0       	push   $0xf012db80
f011a037:	e8 4f 6f fe ff       	call   f0100f8b <cprintf>
f011a03c:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011a03f:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a045:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011a048:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a04f:	eb 1e                	jmp    f011a06f <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f011a051:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011a057:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a05a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a05d:	01 c8                	add    %ecx,%eax
f011a05f:	8a 00                	mov    (%eax),%al
f011a061:	0f be c0             	movsbl %al,%eax
f011a064:	01 d0                	add    %edx,%eax
f011a066:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011a06c:	ff 45 f4             	incl   -0xc(%ebp)
f011a06f:	8b 45 80             	mov    -0x80(%ebp),%eax
f011a072:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a075:	7f da                	jg     f011a051 <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f011a077:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f011a07d:	8b 55 80             	mov    -0x80(%ebp),%edx
f011a080:	89 d0                	mov    %edx,%eax
f011a082:	01 c0                	add    %eax,%eax
f011a084:	01 d0                	add    %edx,%eax
f011a086:	01 c0                	add    %eax,%eax
f011a088:	01 d0                	add    %edx,%eax
f011a08a:	39 c1                	cmp    %eax,%ecx
f011a08c:	74 17                	je     f011a0a5 <test_kfree_bestfirstfit+0xa29>
f011a08e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a095:	83 ec 0c             	sub    $0xc,%esp
f011a098:	68 b8 db 12 f0       	push   $0xf012dbb8
f011a09d:	e8 e9 6e fe ff       	call   f0100f8b <cprintf>
f011a0a2:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a0a5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a0a9:	74 04                	je     f011a0af <test_kfree_bestfirstfit+0xa33>
f011a0ab:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a0af:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f011a0b6:	83 ec 0c             	sub    $0xc,%esp
f011a0b9:	68 f0 db 12 f0       	push   $0xf012dbf0
f011a0be:	e8 c8 6e fe ff       	call   f0100f8b <cprintf>
f011a0c3:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011a0c6:	e8 e3 47 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a0cb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a0ce:	e8 d2 a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a0d3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011a0d6:	83 ec 0c             	sub    $0xc,%esp
f011a0d9:	68 00 04 00 00       	push   $0x400
f011a0de:	e8 ae f3 fe ff       	call   f0109491 <kmalloc>
f011a0e3:	83 c4 10             	add    $0x10,%esp
f011a0e6:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f011a0ec:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f011a0f2:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a0f8:	39 c2                	cmp    %eax,%edx
f011a0fa:	74 17                	je     f011a113 <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a0fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a103:	83 ec 0c             	sub    $0xc,%esp
f011a106:	68 10 dc 12 f0       	push   $0xf012dc10
f011a10b:	e8 7b 6e fe ff       	call   f0100f8b <cprintf>
f011a110:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a113:	e8 8d a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a118:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a11b:	74 17                	je     f011a134 <test_kfree_bestfirstfit+0xab8>
f011a11d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a124:	83 ec 0c             	sub    $0xc,%esp
f011a127:	68 64 dc 12 f0       	push   $0xf012dc64
f011a12c:	e8 5a 6e fe ff       	call   f0100f8b <cprintf>
f011a131:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a134:	e8 75 47 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a139:	89 c2                	mov    %eax,%edx
f011a13b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a13e:	39 c2                	cmp    %eax,%edx
f011a140:	74 17                	je     f011a159 <test_kfree_bestfirstfit+0xadd>
f011a142:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a149:	83 ec 0c             	sub    $0xc,%esp
f011a14c:	68 d4 dc 12 f0       	push   $0xf012dcd4
f011a151:	e8 35 6e fe ff       	call   f0100f8b <cprintf>
f011a156:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011a159:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f011a160:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a166:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011a169:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a170:	eb 0e                	jmp    f011a180 <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f011a172:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a175:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a178:	01 d0                	add    %edx,%eax
f011a17a:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011a17d:	ff 45 f4             	incl   -0xc(%ebp)
f011a180:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a183:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a186:	7f ea                	jg     f011a172 <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011a188:	e8 21 47 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a18d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a190:	e8 10 a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a195:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011a198:	83 ec 0c             	sub    $0xc,%esp
f011a19b:	68 00 00 30 00       	push   $0x300000
f011a1a0:	e8 ec f2 fe ff       	call   f0109491 <kmalloc>
f011a1a5:	83 c4 10             	add    $0x10,%esp
f011a1a8:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a1ae:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a1b4:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a1b9:	74 17                	je     f011a1d2 <test_kfree_bestfirstfit+0xb56>
f011a1bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1c2:	83 ec 0c             	sub    $0xc,%esp
f011a1c5:	68 50 dd 12 f0       	push   $0xf012dd50
f011a1ca:	e8 bc 6d fe ff       	call   f0100f8b <cprintf>
f011a1cf:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a1d2:	e8 ce a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a1d7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a1da:	74 17                	je     f011a1f3 <test_kfree_bestfirstfit+0xb77>
f011a1dc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1e3:	83 ec 0c             	sub    $0xc,%esp
f011a1e6:	68 a4 dd 12 f0       	push   $0xf012dda4
f011a1eb:	e8 9b 6d fe ff       	call   f0100f8b <cprintf>
f011a1f0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a1f3:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a1f6:	e8 b3 46 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a1fb:	29 c3                	sub    %eax,%ebx
f011a1fd:	89 d8                	mov    %ebx,%eax
f011a1ff:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a204:	77 17                	ja     f011a21d <test_kfree_bestfirstfit+0xba1>
f011a206:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a20d:	83 ec 0c             	sub    $0xc,%esp
f011a210:	68 14 de 12 f0       	push   $0xf012de14
f011a215:	e8 71 6d fe ff       	call   f0100f8b <cprintf>
f011a21a:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011a21d:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f011a224:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a22a:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011a22d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a234:	eb 0e                	jmp    f011a244 <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f011a236:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a239:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a23c:	01 d0                	add    %edx,%eax
f011a23e:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011a241:	ff 45 f4             	incl   -0xc(%ebp)
f011a244:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011a247:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a24a:	7f ea                	jg     f011a236 <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011a24c:	e8 5d 46 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a251:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a254:	e8 4c a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a259:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011a25c:	83 ec 0c             	sub    $0xc,%esp
f011a25f:	68 00 00 10 00       	push   $0x100000
f011a264:	e8 28 f2 fe ff       	call   f0109491 <kmalloc>
f011a269:	83 c4 10             	add    $0x10,%esp
f011a26c:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a272:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a278:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011a27d:	74 17                	je     f011a296 <test_kfree_bestfirstfit+0xc1a>
f011a27f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a286:	83 ec 0c             	sub    $0xc,%esp
f011a289:	68 5c de 12 f0       	push   $0xf012de5c
f011a28e:	e8 f8 6c fe ff       	call   f0100f8b <cprintf>
f011a293:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a296:	e8 0a a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a29b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a29e:	74 17                	je     f011a2b7 <test_kfree_bestfirstfit+0xc3b>
f011a2a0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2a7:	83 ec 0c             	sub    $0xc,%esp
f011a2aa:	68 b0 de 12 f0       	push   $0xf012deb0
f011a2af:	e8 d7 6c fe ff       	call   f0100f8b <cprintf>
f011a2b4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a2b7:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a2ba:	e8 ef 45 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a2bf:	29 c3                	sub    %eax,%ebx
f011a2c1:	89 d8                	mov    %ebx,%eax
f011a2c3:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a2c8:	77 17                	ja     f011a2e1 <test_kfree_bestfirstfit+0xc65>
f011a2ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2d1:	83 ec 0c             	sub    $0xc,%esp
f011a2d4:	68 20 df 12 f0       	push   $0xf012df20
f011a2d9:	e8 ad 6c fe ff       	call   f0100f8b <cprintf>
f011a2de:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011a2e1:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f011a2e8:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a2ee:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011a2f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a2f8:	eb 0e                	jmp    f011a308 <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f011a2fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a2fd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a300:	01 d0                	add    %edx,%eax
f011a302:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011a305:	ff 45 f4             	incl   -0xc(%ebp)
f011a308:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a30b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a30e:	7f ea                	jg     f011a2fa <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f011a310:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a314:	74 04                	je     f011a31a <test_kfree_bestfirstfit+0xc9e>
f011a316:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a31a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f011a321:	83 ec 0c             	sub    $0xc,%esp
f011a324:	68 68 df 12 f0       	push   $0xf012df68
f011a329:	e8 5d 6c fe ff       	call   f0100f8b <cprintf>
f011a32e:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f011a331:	e8 78 45 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a336:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a339:	e8 67 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a33e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f011a341:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a347:	83 ec 0c             	sub    $0xc,%esp
f011a34a:	50                   	push   %eax
f011a34b:	e8 a1 f3 fe ff       	call   f01096f1 <kfree>
f011a350:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a353:	e8 4d a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a358:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a35b:	74 17                	je     f011a374 <test_kfree_bestfirstfit+0xcf8>
f011a35d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a364:	83 ec 0c             	sub    $0xc,%esp
f011a367:	68 94 df 12 f0       	push   $0xf012df94
f011a36c:	e8 1a 6c fe ff       	call   f0100f8b <cprintf>
f011a371:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a374:	e8 35 45 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a379:	89 c2                	mov    %eax,%edx
f011a37b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a37e:	29 c2                	sub    %eax,%edx
f011a380:	89 d0                	mov    %edx,%eax
f011a382:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a387:	77 17                	ja     f011a3a0 <test_kfree_bestfirstfit+0xd24>
f011a389:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a390:	83 ec 0c             	sub    $0xc,%esp
f011a393:	68 04 e0 12 f0       	push   $0xf012e004
f011a398:	e8 ee 6b fe ff       	call   f0100f8b <cprintf>
f011a39d:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f011a3a0:	e8 09 45 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a3a5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a3a8:	e8 f8 a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a3ad:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f011a3b0:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a3b6:	83 ec 0c             	sub    $0xc,%esp
f011a3b9:	50                   	push   %eax
f011a3ba:	e8 32 f3 fe ff       	call   f01096f1 <kfree>
f011a3bf:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a3c2:	e8 de a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a3c7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a3ca:	74 17                	je     f011a3e3 <test_kfree_bestfirstfit+0xd67>
f011a3cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3d3:	83 ec 0c             	sub    $0xc,%esp
f011a3d6:	68 40 e0 12 f0       	push   $0xf012e040
f011a3db:	e8 ab 6b fe ff       	call   f0100f8b <cprintf>
f011a3e0:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a3e3:	e8 c6 44 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a3e8:	89 c2                	mov    %eax,%edx
f011a3ea:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a3ed:	29 c2                	sub    %eax,%edx
f011a3ef:	89 d0                	mov    %edx,%eax
f011a3f1:	83 f8 01             	cmp    $0x1,%eax
f011a3f4:	77 17                	ja     f011a40d <test_kfree_bestfirstfit+0xd91>
f011a3f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3fd:	83 ec 0c             	sub    $0xc,%esp
f011a400:	68 b0 e0 12 f0       	push   $0xf012e0b0
f011a405:	e8 81 6b fe ff       	call   f0100f8b <cprintf>
f011a40a:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f011a40d:	e8 9c 44 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a412:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a415:	e8 8b a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a41a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f011a41d:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a423:	83 ec 0c             	sub    $0xc,%esp
f011a426:	50                   	push   %eax
f011a427:	e8 c5 f2 fe ff       	call   f01096f1 <kfree>
f011a42c:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a42f:	e8 71 a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a434:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a437:	74 17                	je     f011a450 <test_kfree_bestfirstfit+0xdd4>
f011a439:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a440:	83 ec 0c             	sub    $0xc,%esp
f011a443:	68 ec e0 12 f0       	push   $0xf012e0ec
f011a448:	e8 3e 6b fe ff       	call   f0100f8b <cprintf>
f011a44d:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a450:	e8 59 44 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a455:	89 c2                	mov    %eax,%edx
f011a457:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a45a:	29 c2                	sub    %eax,%edx
f011a45c:	89 d0                	mov    %edx,%eax
f011a45e:	83 f8 03             	cmp    $0x3,%eax
f011a461:	77 17                	ja     f011a47a <test_kfree_bestfirstfit+0xdfe>
f011a463:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a46a:	83 ec 0c             	sub    $0xc,%esp
f011a46d:	68 5c e1 12 f0       	push   $0xf012e15c
f011a472:	e8 14 6b fe ff       	call   f0100f8b <cprintf>
f011a477:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f011a47a:	e8 2f 44 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a47f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a482:	e8 1e a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a487:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f011a48a:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a490:	83 ec 0c             	sub    $0xc,%esp
f011a493:	50                   	push   %eax
f011a494:	e8 58 f2 fe ff       	call   f01096f1 <kfree>
f011a499:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a49c:	e8 04 a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a4a1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a4a4:	74 17                	je     f011a4bd <test_kfree_bestfirstfit+0xe41>
f011a4a6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4ad:	83 ec 0c             	sub    $0xc,%esp
f011a4b0:	68 98 e1 12 f0       	push   $0xf012e198
f011a4b5:	e8 d1 6a fe ff       	call   f0100f8b <cprintf>
f011a4ba:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a4bd:	e8 ec 43 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a4c2:	89 c2                	mov    %eax,%edx
f011a4c4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a4c7:	29 c2                	sub    %eax,%edx
f011a4c9:	89 d0                	mov    %edx,%eax
f011a4cb:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a4d0:	77 17                	ja     f011a4e9 <test_kfree_bestfirstfit+0xe6d>
f011a4d2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4d9:	83 ec 0c             	sub    $0xc,%esp
f011a4dc:	68 08 e2 12 f0       	push   $0xf012e208
f011a4e1:	e8 a5 6a fe ff       	call   f0100f8b <cprintf>
f011a4e6:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f011a4e9:	e8 c0 43 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a4ee:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a4f1:	e8 af a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a4f6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f011a4f9:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a4ff:	83 ec 0c             	sub    $0xc,%esp
f011a502:	50                   	push   %eax
f011a503:	e8 e9 f1 fe ff       	call   f01096f1 <kfree>
f011a508:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a50b:	e8 95 a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a510:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a513:	74 17                	je     f011a52c <test_kfree_bestfirstfit+0xeb0>
f011a515:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a51c:	83 ec 0c             	sub    $0xc,%esp
f011a51f:	68 44 e2 12 f0       	push   $0xf012e244
f011a524:	e8 62 6a fe ff       	call   f0100f8b <cprintf>
f011a529:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a52c:	e8 7d 43 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a531:	89 c2                	mov    %eax,%edx
f011a533:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a536:	29 c2                	sub    %eax,%edx
f011a538:	89 d0                	mov    %edx,%eax
f011a53a:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a53f:	77 17                	ja     f011a558 <test_kfree_bestfirstfit+0xedc>
f011a541:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a548:	83 ec 0c             	sub    $0xc,%esp
f011a54b:	68 b4 e2 12 f0       	push   $0xf012e2b4
f011a550:	e8 36 6a fe ff       	call   f0100f8b <cprintf>
f011a555:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f011a558:	e8 51 43 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a55d:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a560:	e8 40 a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a565:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f011a568:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a56e:	83 ec 0c             	sub    $0xc,%esp
f011a571:	50                   	push   %eax
f011a572:	e8 7a f1 fe ff       	call   f01096f1 <kfree>
f011a577:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a57a:	e8 26 a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a57f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a582:	74 17                	je     f011a59b <test_kfree_bestfirstfit+0xf1f>
f011a584:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a58b:	83 ec 0c             	sub    $0xc,%esp
f011a58e:	68 f0 e2 12 f0       	push   $0xf012e2f0
f011a593:	e8 f3 69 fe ff       	call   f0100f8b <cprintf>
f011a598:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a59b:	e8 0e 43 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a5a0:	89 c2                	mov    %eax,%edx
f011a5a2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a5a5:	39 c2                	cmp    %eax,%edx
f011a5a7:	74 17                	je     f011a5c0 <test_kfree_bestfirstfit+0xf44>
f011a5a9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5b0:	83 ec 0c             	sub    $0xc,%esp
f011a5b3:	68 60 e3 12 f0       	push   $0xf012e360
f011a5b8:	e8 ce 69 fe ff       	call   f0100f8b <cprintf>
f011a5bd:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f011a5c0:	e8 e9 42 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a5c5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a5c8:	e8 d8 a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a5cd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f011a5d0:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a5d6:	83 ec 0c             	sub    $0xc,%esp
f011a5d9:	50                   	push   %eax
f011a5da:	e8 12 f1 fe ff       	call   f01096f1 <kfree>
f011a5df:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a5e2:	e8 be a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a5e7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a5ea:	74 17                	je     f011a603 <test_kfree_bestfirstfit+0xf87>
f011a5ec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5f3:	83 ec 0c             	sub    $0xc,%esp
f011a5f6:	68 9c e3 12 f0       	push   $0xf012e39c
f011a5fb:	e8 8b 69 fe ff       	call   f0100f8b <cprintf>
f011a600:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a603:	e8 a6 42 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a608:	89 c2                	mov    %eax,%edx
f011a60a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a60d:	39 c2                	cmp    %eax,%edx
f011a60f:	74 17                	je     f011a628 <test_kfree_bestfirstfit+0xfac>
f011a611:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a618:	83 ec 0c             	sub    $0xc,%esp
f011a61b:	68 0c e4 12 f0       	push   $0xf012e40c
f011a620:	e8 66 69 fe ff       	call   f0100f8b <cprintf>
f011a625:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011a628:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a62c:	74 04                	je     f011a632 <test_kfree_bestfirstfit+0xfb6>
f011a62e:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a632:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f011a639:	83 ec 0c             	sub    $0xc,%esp
f011a63c:	68 6c e4 12 f0       	push   $0xf012e46c
f011a641:	e8 45 69 fe ff       	call   f0100f8b <cprintf>
f011a646:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011a649:	83 ec 0c             	sub    $0xc,%esp
f011a64c:	6a 03                	push   $0x3
f011a64e:	e8 84 46 ff ff       	call   f010ecd7 <sys_bypassPageFault>
f011a653:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011a656:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a65d:	e9 af 00 00 00       	jmp    f011a711 <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011a662:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011a666:	0f 84 a1 00 00 00    	je     f011a70d <test_kfree_bestfirstfit+0x1091>
f011a66c:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011a670:	0f 84 97 00 00 00    	je     f011a70d <test_kfree_bestfirstfit+0x1091>
f011a676:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011a67a:	0f 84 8d 00 00 00    	je     f011a70d <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011a680:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a683:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f011a68a:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011a68d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a690:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011a693:	e8 2d 46 ff ff       	call   f010ecc5 <sys_rcr2>
f011a698:	89 c2                	mov    %eax,%edx
f011a69a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a69d:	39 c2                	cmp    %eax,%edx
f011a69f:	74 1d                	je     f011a6be <test_kfree_bestfirstfit+0x1042>
				if (correct)
f011a6a1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a6a5:	74 17                	je     f011a6be <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a6a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6ae:	83 ec 0c             	sub    $0xc,%esp
f011a6b1:	68 ac e4 12 f0       	push   $0xf012e4ac
f011a6b6:	e8 d0 68 fe ff       	call   f0100f8b <cprintf>
f011a6bb:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011a6be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a6c1:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a6c8:	89 c2                	mov    %eax,%edx
f011a6ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a6cd:	01 d0                	add    %edx,%eax
f011a6cf:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011a6d2:	e8 ee 45 ff ff       	call   f010ecc5 <sys_rcr2>
f011a6d7:	89 c2                	mov    %eax,%edx
f011a6d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a6dc:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a6e3:	89 c1                	mov    %eax,%ecx
f011a6e5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a6e8:	01 c8                	add    %ecx,%eax
f011a6ea:	39 c2                	cmp    %eax,%edx
f011a6ec:	74 20                	je     f011a70e <test_kfree_bestfirstfit+0x1092>
				if (correct)
f011a6ee:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a6f2:	74 1a                	je     f011a70e <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a6f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6fb:	83 ec 0c             	sub    $0xc,%esp
f011a6fe:	68 f8 e4 12 f0       	push   $0xf012e4f8
f011a703:	e8 83 68 fe ff       	call   f0100f8b <cprintf>
f011a708:	83 c4 10             	add    $0x10,%esp
f011a70b:	eb 01                	jmp    f011a70e <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011a70d:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011a70e:	ff 45 f4             	incl   -0xc(%ebp)
f011a711:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011a715:	0f 8e 47 ff ff ff    	jle    f011a662 <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011a71b:	83 ec 0c             	sub    $0xc,%esp
f011a71e:	6a 00                	push   $0x0
f011a720:	e8 b2 45 ff ff       	call   f010ecd7 <sys_bypassPageFault>
f011a725:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011a728:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a72c:	74 04                	je     f011a732 <test_kfree_bestfirstfit+0x10b6>
f011a72e:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a732:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f011a739:	83 ec 0c             	sub    $0xc,%esp
f011a73c:	68 44 e5 12 f0       	push   $0xf012e544
f011a741:	e8 45 68 fe ff       	call   f0100f8b <cprintf>
f011a746:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011a749:	e8 60 41 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a74e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a751:	e8 4f a1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a756:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f011a759:	83 ec 0c             	sub    $0xc,%esp
f011a75c:	68 00 04 00 00       	push   $0x400
f011a761:	e8 2b ed fe ff       	call   f0109491 <kmalloc>
f011a766:	83 c4 10             	add    $0x10,%esp
f011a769:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f011a76f:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011a775:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a77b:	39 c2                	cmp    %eax,%edx
f011a77d:	74 17                	je     f011a796 <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a77f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a786:	83 ec 0c             	sub    $0xc,%esp
f011a789:	68 68 e5 12 f0       	push   $0xf012e568
f011a78e:	e8 f8 67 fe ff       	call   f0100f8b <cprintf>
f011a793:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a796:	e8 0a a1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a79b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a79e:	74 17                	je     f011a7b7 <test_kfree_bestfirstfit+0x113b>
f011a7a0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7a7:	83 ec 0c             	sub    $0xc,%esp
f011a7aa:	68 bc e5 12 f0       	push   $0xf012e5bc
f011a7af:	e8 d7 67 fe ff       	call   f0100f8b <cprintf>
f011a7b4:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a7b7:	e8 f2 40 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a7bc:	89 c2                	mov    %eax,%edx
f011a7be:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a7c1:	39 c2                	cmp    %eax,%edx
f011a7c3:	74 17                	je     f011a7dc <test_kfree_bestfirstfit+0x1160>
f011a7c5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7cc:	83 ec 0c             	sub    $0xc,%esp
f011a7cf:	68 2c e6 12 f0       	push   $0xf012e62c
f011a7d4:	e8 b2 67 fe ff       	call   f0100f8b <cprintf>
f011a7d9:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011a7dc:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011a7e3:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011a7e9:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011a7ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a7f3:	eb 0e                	jmp    f011a803 <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011a7f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a7f8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a7fb:	01 d0                	add    %edx,%eax
f011a7fd:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011a800:	ff 45 f4             	incl   -0xc(%ebp)
f011a803:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a806:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a809:	7f ea                	jg     f011a7f5 <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a80b:	e8 9e 40 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a810:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a813:	e8 8d a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a818:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f011a81b:	83 ec 0c             	sub    $0xc,%esp
f011a81e:	68 00 08 00 00       	push   $0x800
f011a823:	e8 69 ec fe ff       	call   f0109491 <kmalloc>
f011a828:	83 c4 10             	add    $0x10,%esp
f011a82b:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f011a831:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a837:	05 08 04 00 00       	add    $0x408,%eax
f011a83c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f011a83f:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a845:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a848:	74 35                	je     f011a87f <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f011a84a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011a851:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a857:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a85d:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011a863:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a869:	81 c2 00 04 00 00    	add    $0x400,%edx
f011a86f:	50                   	push   %eax
f011a870:	51                   	push   %ecx
f011a871:	52                   	push   %edx
f011a872:	68 a8 e6 12 f0       	push   $0xf012e6a8
f011a877:	e8 0f 67 fe ff       	call   f0100f8b <cprintf>
f011a87c:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a87f:	e8 21 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a884:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a887:	74 17                	je     f011a8a0 <test_kfree_bestfirstfit+0x1224>
f011a889:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a890:	83 ec 0c             	sub    $0xc,%esp
f011a893:	68 1c e7 12 f0       	push   $0xf012e71c
f011a898:	e8 ee 66 fe ff       	call   f0100f8b <cprintf>
f011a89d:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a8a0:	e8 09 40 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a8a5:	89 c2                	mov    %eax,%edx
f011a8a7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a8aa:	39 c2                	cmp    %eax,%edx
f011a8ac:	74 17                	je     f011a8c5 <test_kfree_bestfirstfit+0x1249>
f011a8ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8b5:	83 ec 0c             	sub    $0xc,%esp
f011a8b8:	68 8c e7 12 f0       	push   $0xf012e78c
f011a8bd:	e8 c9 66 fe ff       	call   f0100f8b <cprintf>
f011a8c2:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011a8c5:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f011a8cc:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a8d2:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011a8d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a8dc:	eb 0e                	jmp    f011a8ec <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f011a8de:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a8e1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a8e4:	01 d0                	add    %edx,%eax
f011a8e6:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011a8e9:	ff 45 f4             	incl   -0xc(%ebp)
f011a8ec:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a8ef:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a8f2:	7f ea                	jg     f011a8de <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011a8f4:	e8 b5 3f ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a8f9:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a8fc:	e8 a4 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a901:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011a904:	83 ec 0c             	sub    $0xc,%esp
f011a907:	68 00 06 00 00       	push   $0x600
f011a90c:	e8 80 eb fe ff       	call   f0109491 <kmalloc>
f011a911:	83 c4 10             	add    $0x10,%esp
f011a914:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011a91a:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a920:	05 10 0c 00 00       	add    $0xc10,%eax
f011a925:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011a928:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a92e:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a931:	74 17                	je     f011a94a <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a933:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a93a:	83 ec 0c             	sub    $0xc,%esp
f011a93d:	68 08 e8 12 f0       	push   $0xf012e808
f011a942:	e8 44 66 fe ff       	call   f0100f8b <cprintf>
f011a947:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a94a:	e8 56 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a94f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a952:	74 17                	je     f011a96b <test_kfree_bestfirstfit+0x12ef>
f011a954:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a95b:	83 ec 0c             	sub    $0xc,%esp
f011a95e:	68 5c e8 12 f0       	push   $0xf012e85c
f011a963:	e8 23 66 fe ff       	call   f0100f8b <cprintf>
f011a968:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a96b:	e8 3e 3f ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a970:	89 c2                	mov    %eax,%edx
f011a972:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a975:	39 c2                	cmp    %eax,%edx
f011a977:	74 17                	je     f011a990 <test_kfree_bestfirstfit+0x1314>
f011a979:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a980:	83 ec 0c             	sub    $0xc,%esp
f011a983:	68 cc e8 12 f0       	push   $0xf012e8cc
f011a988:	e8 fe 65 fe ff       	call   f0100f8b <cprintf>
f011a98d:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011a990:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011a997:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a99d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011a9a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a9a7:	eb 0e                	jmp    f011a9b7 <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011a9a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a9ac:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a9af:	01 d0                	add    %edx,%eax
f011a9b1:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011a9b4:	ff 45 f4             	incl   -0xc(%ebp)
f011a9b7:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a9ba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a9bd:	7f ea                	jg     f011a9a9 <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f011a9bf:	e8 ea 3e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011a9c4:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a9c7:	e8 d9 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a9cc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f011a9cf:	83 ec 0c             	sub    $0xc,%esp
f011a9d2:	68 00 00 e0 01       	push   $0x1e00000
f011a9d7:	e8 b5 ea fe ff       	call   f0109491 <kmalloc>
f011a9dc:	83 c4 10             	add    $0x10,%esp
f011a9df:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a9e5:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a9eb:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a9f0:	74 17                	je     f011aa09 <test_kfree_bestfirstfit+0x138d>
f011a9f2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9f9:	83 ec 0c             	sub    $0xc,%esp
f011a9fc:	68 48 e9 12 f0       	push   $0xf012e948
f011aa01:	e8 85 65 fe ff       	call   f0100f8b <cprintf>
f011aa06:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa09:	e8 97 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa0e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011aa11:	74 17                	je     f011aa2a <test_kfree_bestfirstfit+0x13ae>
f011aa13:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa1a:	83 ec 0c             	sub    $0xc,%esp
f011aa1d:	68 9c e9 12 f0       	push   $0xf012e99c
f011aa22:	e8 64 65 fe ff       	call   f0100f8b <cprintf>
f011aa27:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aa2a:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011aa2d:	e8 7c 3e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011aa32:	29 c3                	sub    %eax,%ebx
f011aa34:	89 d8                	mov    %ebx,%eax
f011aa36:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011aa3b:	77 17                	ja     f011aa54 <test_kfree_bestfirstfit+0x13d8>
f011aa3d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa44:	83 ec 0c             	sub    $0xc,%esp
f011aa47:	68 0c ea 12 f0       	push   $0xf012ea0c
f011aa4c:	e8 3a 65 fe ff       	call   f0100f8b <cprintf>
f011aa51:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011aa54:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f011aa5b:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011aa61:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011aa64:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aa6b:	eb 0e                	jmp    f011aa7b <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f011aa6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aa70:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aa73:	01 d0                	add    %edx,%eax
f011aa75:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011aa78:	ff 45 f4             	incl   -0xc(%ebp)
f011aa7b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011aa7e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aa81:	7f ea                	jg     f011aa6d <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f011aa83:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011aa89:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011aa8c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aa93:	eb 1e                	jmp    f011aab3 <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f011aa95:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011aa9b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011aa9e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aaa1:	01 c8                	add    %ecx,%eax
f011aaa3:	8a 00                	mov    (%eax),%al
f011aaa5:	0f be c0             	movsbl %al,%eax
f011aaa8:	01 d0                	add    %edx,%eax
f011aaaa:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011aab0:	ff 45 f4             	incl   -0xc(%ebp)
f011aab3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011aab6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aab9:	7f da                	jg     f011aa95 <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f011aabb:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f011aac1:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011aac4:	89 d0                	mov    %edx,%eax
f011aac6:	c1 e0 02             	shl    $0x2,%eax
f011aac9:	01 d0                	add    %edx,%eax
f011aacb:	01 c0                	add    %eax,%eax
f011aacd:	39 c1                	cmp    %eax,%ecx
f011aacf:	74 17                	je     f011aae8 <test_kfree_bestfirstfit+0x146c>
f011aad1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aad8:	83 ec 0c             	sub    $0xc,%esp
f011aadb:	68 54 ea 12 f0       	push   $0xf012ea54
f011aae0:	e8 a6 64 fe ff       	call   f0100f8b <cprintf>
f011aae5:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f011aae8:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011aaee:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011aaf1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aaf8:	eb 1e                	jmp    f011ab18 <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f011aafa:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011ab00:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ab03:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab06:	01 c8                	add    %ecx,%eax
f011ab08:	8a 00                	mov    (%eax),%al
f011ab0a:	0f be c0             	movsbl %al,%eax
f011ab0d:	01 d0                	add    %edx,%eax
f011ab0f:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011ab15:	ff 45 f4             	incl   -0xc(%ebp)
f011ab18:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ab1b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab1e:	7f da                	jg     f011aafa <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f011ab20:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011ab26:	8b 55 90             	mov    -0x70(%ebp),%edx
f011ab29:	89 d0                	mov    %edx,%eax
f011ab2b:	c1 e0 02             	shl    $0x2,%eax
f011ab2e:	01 d0                	add    %edx,%eax
f011ab30:	01 c0                	add    %eax,%eax
f011ab32:	01 d0                	add    %edx,%eax
f011ab34:	39 c1                	cmp    %eax,%ecx
f011ab36:	74 17                	je     f011ab4f <test_kfree_bestfirstfit+0x14d3>
f011ab38:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab3f:	83 ec 0c             	sub    $0xc,%esp
f011ab42:	68 84 ea 12 f0       	push   $0xf012ea84
f011ab47:	e8 3f 64 fe ff       	call   f0100f8b <cprintf>
f011ab4c:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f011ab4f:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011ab55:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011ab58:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ab5f:	eb 1e                	jmp    f011ab7f <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f011ab61:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011ab67:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ab6a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab6d:	01 c8                	add    %ecx,%eax
f011ab6f:	8a 00                	mov    (%eax),%al
f011ab71:	0f be c0             	movsbl %al,%eax
f011ab74:	01 d0                	add    %edx,%eax
f011ab76:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011ab7c:	ff 45 f4             	incl   -0xc(%ebp)
f011ab7f:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011ab82:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab85:	7f da                	jg     f011ab61 <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f011ab87:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011ab8d:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011ab90:	89 d0                	mov    %edx,%eax
f011ab92:	01 c0                	add    %eax,%eax
f011ab94:	01 d0                	add    %edx,%eax
f011ab96:	c1 e0 02             	shl    $0x2,%eax
f011ab99:	39 c1                	cmp    %eax,%ecx
f011ab9b:	74 17                	je     f011abb4 <test_kfree_bestfirstfit+0x1538>
f011ab9d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aba4:	83 ec 0c             	sub    $0xc,%esp
f011aba7:	68 b4 ea 12 f0       	push   $0xf012eab4
f011abac:	e8 da 63 fe ff       	call   f0100f8b <cprintf>
f011abb1:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f011abb4:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011abba:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011abbd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011abc4:	eb 1e                	jmp    f011abe4 <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011abc6:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011abcc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011abcf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011abd2:	01 c8                	add    %ecx,%eax
f011abd4:	8a 00                	mov    (%eax),%al
f011abd6:	0f be c0             	movsbl %al,%eax
f011abd9:	01 d0                	add    %edx,%eax
f011abdb:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011abe1:	ff 45 f4             	incl   -0xc(%ebp)
f011abe4:	8b 45 98             	mov    -0x68(%ebp),%eax
f011abe7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011abea:	7f da                	jg     f011abc6 <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f011abec:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011abf2:	8b 55 98             	mov    -0x68(%ebp),%edx
f011abf5:	89 d0                	mov    %edx,%eax
f011abf7:	01 c0                	add    %eax,%eax
f011abf9:	01 d0                	add    %edx,%eax
f011abfb:	c1 e0 02             	shl    $0x2,%eax
f011abfe:	01 d0                	add    %edx,%eax
f011ac00:	39 c1                	cmp    %eax,%ecx
f011ac02:	74 17                	je     f011ac1b <test_kfree_bestfirstfit+0x159f>
f011ac04:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac0b:	83 ec 0c             	sub    $0xc,%esp
f011ac0e:	68 e4 ea 12 f0       	push   $0xf012eae4
f011ac13:	e8 73 63 fe ff       	call   f0100f8b <cprintf>
f011ac18:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f011ac1b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ac1f:	74 04                	je     f011ac25 <test_kfree_bestfirstfit+0x15a9>
f011ac21:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011ac25:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f011ac2c:	83 ec 0c             	sub    $0xc,%esp
f011ac2f:	68 11 eb 12 f0       	push   $0xf012eb11
f011ac34:	e8 52 63 fe ff       	call   f0100f8b <cprintf>
f011ac39:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011ac3c:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011ac43:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011ac4a:	eb 4e                	jmp    f011ac9a <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011ac4c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011ac4f:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011ac54:	83 ec 04             	sub    $0x4,%esp
f011ac57:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f011ac5d:	51                   	push   %ecx
f011ac5e:	52                   	push   %edx
f011ac5f:	50                   	push   %eax
f011ac60:	e8 8a d7 fe ff       	call   f01083ef <get_page_table>
f011ac65:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ac68:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f011ac6e:	85 c0                	test   %eax,%eax
f011ac70:	75 1d                	jne    f011ac8f <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f011ac72:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ac76:	74 17                	je     f011ac8f <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011ac78:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac7f:	83 ec 0c             	sub    $0xc,%esp
f011ac82:	68 30 eb 12 f0       	push   $0xf012eb30
f011ac87:	e8 ff 62 fe ff       	call   f0100f8b <cprintf>
f011ac8c:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011ac8f:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011ac96:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011ac9a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ac9e:	78 ac                	js     f011ac4c <test_kfree_bestfirstfit+0x15d0>
f011aca0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011aca4:	7f 09                	jg     f011acaf <test_kfree_bestfirstfit+0x1633>
f011aca6:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011acad:	76 9d                	jbe    f011ac4c <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011acaf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011acb3:	74 04                	je     f011acb9 <test_kfree_bestfirstfit+0x163d>
f011acb5:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011acb9:	83 ec 08             	sub    $0x8,%esp
f011acbc:	ff 75 f0             	pushl  -0x10(%ebp)
f011acbf:	68 98 eb 12 f0       	push   $0xf012eb98
f011acc4:	e8 c2 62 fe ff       	call   f0100f8b <cprintf>
f011acc9:	83 c4 10             	add    $0x10,%esp

	return 1;
f011accc:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011acd1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011acd4:	5b                   	pop    %ebx
f011acd5:	5f                   	pop    %edi
f011acd6:	5d                   	pop    %ebp
f011acd7:	c3                   	ret    

f011acd8 <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011acd8:	55                   	push   %ebp
f011acd9:	89 e5                	mov    %esp,%ebp
f011acdb:	57                   	push   %edi
f011acdc:	53                   	push   %ebx
f011acdd:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011ace3:	83 ec 0c             	sub    $0xc,%esp
f011ace6:	68 68 ae 12 f0       	push   $0xf012ae68
f011aceb:	e8 9b 62 fe ff       	call   f0100f8b <cprintf>
f011acf0:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011acf3:	83 ec 0c             	sub    $0xc,%esp
f011acf6:	68 98 ae 12 f0       	push   $0xf012ae98
f011acfb:	e8 8b 62 fe ff       	call   f0100f8b <cprintf>
f011ad00:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011ad03:	83 ec 0c             	sub    $0xc,%esp
f011ad06:	68 68 ae 12 f0       	push   $0xf012ae68
f011ad0b:	e8 7b 62 fe ff       	call   f0100f8b <cprintf>
f011ad10:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011ad13:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011ad17:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011ad1b:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011ad21:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011ad27:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011ad2e:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011ad35:	e8 74 3b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011ad3a:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011ad3d:	83 ec 0c             	sub    $0xc,%esp
f011ad40:	68 bc eb 12 f0       	push   $0xf012ebbc
f011ad45:	e8 41 62 fe ff       	call   f0100f8b <cprintf>
f011ad4a:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011ad4d:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011ad53:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ad58:	b8 00 00 00 00       	mov    $0x0,%eax
f011ad5d:	89 d7                	mov    %edx,%edi
f011ad5f:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011ad61:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f011ad67:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ad6c:	b8 00 00 00 00       	mov    $0x0,%eax
f011ad71:	89 d7                	mov    %edx,%edi
f011ad73:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011ad75:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011ad7c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011ad83:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011ad89:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ad8e:	b8 00 00 00 00       	mov    $0x0,%eax
f011ad93:	89 d7                	mov    %edx,%edi
f011ad95:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ad97:	e8 12 3b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011ad9c:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ad9f:	e8 01 9b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ada4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011ada7:	83 ec 0c             	sub    $0xc,%esp
f011adaa:	68 00 fc 1f 00       	push   $0x1ffc00
f011adaf:	e8 dd e6 fe ff       	call   f0109491 <kmalloc>
f011adb4:	83 c4 10             	add    $0x10,%esp
f011adb7:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011adbd:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011adc3:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011adc8:	74 17                	je     f011ade1 <test_kheap_phys_addr+0x109>
f011adca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011add1:	83 ec 0c             	sub    $0xc,%esp
f011add4:	68 60 cf 12 f0       	push   $0xf012cf60
f011add9:	e8 ad 61 fe ff       	call   f0100f8b <cprintf>
f011adde:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ade1:	e8 bf 9a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ade6:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ade9:	74 17                	je     f011ae02 <test_kheap_phys_addr+0x12a>
f011adeb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011adf2:	83 ec 0c             	sub    $0xc,%esp
f011adf5:	68 b4 cf 12 f0       	push   $0xf012cfb4
f011adfa:	e8 8c 61 fe ff       	call   f0100f8b <cprintf>
f011adff:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ae02:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ae05:	e8 a4 3a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011ae0a:	29 c3                	sub    %eax,%ebx
f011ae0c:	89 d8                	mov    %ebx,%eax
f011ae0e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ae13:	77 17                	ja     f011ae2c <test_kheap_phys_addr+0x154>
f011ae15:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae1c:	83 ec 0c             	sub    $0xc,%esp
f011ae1f:	68 24 d0 12 f0       	push   $0xf012d024
f011ae24:	e8 62 61 fe ff       	call   f0100f8b <cprintf>
f011ae29:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ae2c:	e8 7d 3a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011ae31:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ae34:	e8 6c 9a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ae39:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011ae3c:	83 ec 0c             	sub    $0xc,%esp
f011ae3f:	68 00 fc 1f 00       	push   $0x1ffc00
f011ae44:	e8 48 e6 fe ff       	call   f0109491 <kmalloc>
f011ae49:	83 c4 10             	add    $0x10,%esp
f011ae4c:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ae52:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011ae58:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011ae5d:	74 17                	je     f011ae76 <test_kheap_phys_addr+0x19e>
f011ae5f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae66:	83 ec 0c             	sub    $0xc,%esp
f011ae69:	68 6c d0 12 f0       	push   $0xf012d06c
f011ae6e:	e8 18 61 fe ff       	call   f0100f8b <cprintf>
f011ae73:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae76:	e8 2a 9a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ae7b:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ae7e:	74 17                	je     f011ae97 <test_kheap_phys_addr+0x1bf>
f011ae80:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae87:	83 ec 0c             	sub    $0xc,%esp
f011ae8a:	68 c0 d0 12 f0       	push   $0xf012d0c0
f011ae8f:	e8 f7 60 fe ff       	call   f0100f8b <cprintf>
f011ae94:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ae97:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ae9a:	e8 0f 3a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011ae9f:	29 c3                	sub    %eax,%ebx
f011aea1:	89 d8                	mov    %ebx,%eax
f011aea3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011aea8:	77 17                	ja     f011aec1 <test_kheap_phys_addr+0x1e9>
f011aeaa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aeb1:	83 ec 0c             	sub    $0xc,%esp
f011aeb4:	68 30 d1 12 f0       	push   $0xf012d130
f011aeb9:	e8 cd 60 fe ff       	call   f0100f8b <cprintf>
f011aebe:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011aec1:	e8 e8 39 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011aec6:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aec9:	e8 d7 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aece:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011aed1:	83 ec 0c             	sub    $0xc,%esp
f011aed4:	68 00 04 00 00       	push   $0x400
f011aed9:	e8 b3 e5 fe ff       	call   f0109491 <kmalloc>
f011aede:	83 c4 10             	add    $0x10,%esp
f011aee1:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011aee7:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011aeed:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011aef2:	76 28                	jbe    f011af1c <test_kheap_phys_addr+0x244>
f011aef4:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011aefa:	83 ec 0c             	sub    $0xc,%esp
f011aefd:	6a 00                	push   $0x0
f011aeff:	e8 5a e4 fe ff       	call   f010935e <sbrk>
f011af04:	83 c4 10             	add    $0x10,%esp
f011af07:	39 c3                	cmp    %eax,%ebx
f011af09:	73 11                	jae    f011af1c <test_kheap_phys_addr+0x244>
f011af0b:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011af11:	89 c2                	mov    %eax,%edx
f011af13:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011af18:	39 c2                	cmp    %eax,%edx
f011af1a:	72 17                	jb     f011af33 <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011af1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af23:	83 ec 0c             	sub    $0xc,%esp
f011af26:	68 ec eb 12 f0       	push   $0xf012ebec
f011af2b:	e8 5b 60 fe ff       	call   f0100f8b <cprintf>
f011af30:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af33:	e8 6d 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af38:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011af3b:	74 17                	je     f011af54 <test_kheap_phys_addr+0x27c>
f011af3d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af44:	83 ec 0c             	sub    $0xc,%esp
f011af47:	68 cc d1 12 f0       	push   $0xf012d1cc
f011af4c:	e8 3a 60 fe ff       	call   f0100f8b <cprintf>
f011af51:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011af54:	e8 55 39 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011af59:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011af5c:	e8 44 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af61:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011af64:	83 ec 0c             	sub    $0xc,%esp
f011af67:	68 00 08 00 00       	push   $0x800
f011af6c:	e8 20 e5 fe ff       	call   f0109491 <kmalloc>
f011af71:	83 c4 10             	add    $0x10,%esp
f011af74:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011af7a:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011af80:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011af85:	76 28                	jbe    f011afaf <test_kheap_phys_addr+0x2d7>
f011af87:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011af8d:	83 ec 0c             	sub    $0xc,%esp
f011af90:	6a 00                	push   $0x0
f011af92:	e8 c7 e3 fe ff       	call   f010935e <sbrk>
f011af97:	83 c4 10             	add    $0x10,%esp
f011af9a:	39 c3                	cmp    %eax,%ebx
f011af9c:	73 11                	jae    f011afaf <test_kheap_phys_addr+0x2d7>
f011af9e:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011afa4:	89 c2                	mov    %eax,%edx
f011afa6:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011afab:	39 c2                	cmp    %eax,%edx
f011afad:	72 17                	jb     f011afc6 <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011afaf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afb6:	83 ec 0c             	sub    $0xc,%esp
f011afb9:	68 78 ec 12 f0       	push   $0xf012ec78
f011afbe:	e8 c8 5f fe ff       	call   f0100f8b <cprintf>
f011afc3:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011afc6:	e8 da 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011afcb:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011afce:	74 17                	je     f011afe7 <test_kheap_phys_addr+0x30f>
f011afd0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afd7:	83 ec 0c             	sub    $0xc,%esp
f011afda:	68 d8 d2 12 f0       	push   $0xf012d2d8
f011afdf:	e8 a7 5f fe ff       	call   f0100f8b <cprintf>
f011afe4:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011afe7:	e8 c2 38 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011afec:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011afef:	e8 b1 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aff4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011aff7:	83 ec 0c             	sub    $0xc,%esp
f011affa:	68 00 06 00 00       	push   $0x600
f011afff:	e8 8d e4 fe ff       	call   f0109491 <kmalloc>
f011b004:	83 c4 10             	add    $0x10,%esp
f011b007:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011b00d:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b013:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b018:	76 28                	jbe    f011b042 <test_kheap_phys_addr+0x36a>
f011b01a:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011b020:	83 ec 0c             	sub    $0xc,%esp
f011b023:	6a 00                	push   $0x0
f011b025:	e8 34 e3 fe ff       	call   f010935e <sbrk>
f011b02a:	83 c4 10             	add    $0x10,%esp
f011b02d:	39 c3                	cmp    %eax,%ebx
f011b02f:	73 11                	jae    f011b042 <test_kheap_phys_addr+0x36a>
f011b031:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b037:	89 c2                	mov    %eax,%edx
f011b039:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b03e:	39 c2                	cmp    %eax,%edx
f011b040:	72 17                	jb     f011b059 <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b042:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b049:	83 ec 0c             	sub    $0xc,%esp
f011b04c:	68 04 ed 12 f0       	push   $0xf012ed04
f011b051:	e8 35 5f fe ff       	call   f0100f8b <cprintf>
f011b056:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b059:	e8 47 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b05e:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b061:	74 17                	je     f011b07a <test_kheap_phys_addr+0x3a2>
f011b063:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b06a:	83 ec 0c             	sub    $0xc,%esp
f011b06d:	68 e4 d3 12 f0       	push   $0xf012d3e4
f011b072:	e8 14 5f fe ff       	call   f0100f8b <cprintf>
f011b077:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011b07a:	e8 2f 38 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b07f:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b082:	e8 1e 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b087:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011b08a:	83 ec 0c             	sub    $0xc,%esp
f011b08d:	68 00 1c 00 00       	push   $0x1c00
f011b092:	e8 fa e3 fe ff       	call   f0109491 <kmalloc>
f011b097:	83 c4 10             	add    $0x10,%esp
f011b09a:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b0a0:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011b0a6:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b0ab:	74 17                	je     f011b0c4 <test_kheap_phys_addr+0x3ec>
f011b0ad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0b4:	83 ec 0c             	sub    $0xc,%esp
f011b0b7:	68 9c d4 12 f0       	push   $0xf012d49c
f011b0bc:	e8 ca 5e fe ff       	call   f0100f8b <cprintf>
f011b0c1:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b0c4:	e8 dc 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b0c9:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b0cc:	74 17                	je     f011b0e5 <test_kheap_phys_addr+0x40d>
f011b0ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0d5:	83 ec 0c             	sub    $0xc,%esp
f011b0d8:	68 f0 d4 12 f0       	push   $0xf012d4f0
f011b0dd:	e8 a9 5e fe ff       	call   f0100f8b <cprintf>
f011b0e2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b0e5:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b0e8:	e8 c1 37 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b0ed:	29 c3                	sub    %eax,%ebx
f011b0ef:	89 d8                	mov    %ebx,%eax
f011b0f1:	83 f8 01             	cmp    $0x1,%eax
f011b0f4:	77 17                	ja     f011b10d <test_kheap_phys_addr+0x435>
f011b0f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0fd:	83 ec 0c             	sub    $0xc,%esp
f011b100:	68 60 d5 12 f0       	push   $0xf012d560
f011b105:	e8 81 5e fe ff       	call   f0100f8b <cprintf>
f011b10a:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011b10d:	e8 9c 37 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b112:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b115:	e8 8b 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b11a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011b11d:	83 ec 0c             	sub    $0xc,%esp
f011b120:	68 00 fc 2f 00       	push   $0x2ffc00
f011b125:	e8 67 e3 fe ff       	call   f0109491 <kmalloc>
f011b12a:	83 c4 10             	add    $0x10,%esp
f011b12d:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b133:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b139:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011b13e:	74 17                	je     f011b157 <test_kheap_phys_addr+0x47f>
f011b140:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b147:	83 ec 0c             	sub    $0xc,%esp
f011b14a:	68 90 ed 12 f0       	push   $0xf012ed90
f011b14f:	e8 37 5e fe ff       	call   f0100f8b <cprintf>
f011b154:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b157:	e8 49 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b15c:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b15f:	74 17                	je     f011b178 <test_kheap_phys_addr+0x4a0>
f011b161:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b168:	83 ec 0c             	sub    $0xc,%esp
f011b16b:	68 34 d6 12 f0       	push   $0xf012d634
f011b170:	e8 16 5e fe ff       	call   f0100f8b <cprintf>
f011b175:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b178:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b17b:	e8 2e 37 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b180:	29 c3                	sub    %eax,%ebx
f011b182:	89 d8                	mov    %ebx,%eax
f011b184:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b189:	77 17                	ja     f011b1a2 <test_kheap_phys_addr+0x4ca>
f011b18b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b192:	83 ec 0c             	sub    $0xc,%esp
f011b195:	68 e4 ed 12 f0       	push   $0xf012ede4
f011b19a:	e8 ec 5d fe ff       	call   f0100f8b <cprintf>
f011b19f:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b1a2:	e8 07 37 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b1a7:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b1aa:	e8 f6 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b1af:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011b1b2:	83 ec 0c             	sub    $0xc,%esp
f011b1b5:	68 00 fc 5f 00       	push   $0x5ffc00
f011b1ba:	e8 d2 e2 fe ff       	call   f0109491 <kmalloc>
f011b1bf:	83 c4 10             	add    $0x10,%esp
f011b1c2:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b1c8:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b1ce:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011b1d3:	74 17                	je     f011b1ec <test_kheap_phys_addr+0x514>
f011b1d5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1dc:	83 ec 0c             	sub    $0xc,%esp
f011b1df:	68 2c ee 12 f0       	push   $0xf012ee2c
f011b1e4:	e8 a2 5d fe ff       	call   f0100f8b <cprintf>
f011b1e9:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b1ec:	e8 b4 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b1f1:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b1f4:	74 17                	je     f011b20d <test_kheap_phys_addr+0x535>
f011b1f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1fd:	83 ec 0c             	sub    $0xc,%esp
f011b200:	68 30 d7 12 f0       	push   $0xf012d730
f011b205:	e8 81 5d fe ff       	call   f0100f8b <cprintf>
f011b20a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b20d:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b210:	e8 99 36 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b215:	29 c3                	sub    %eax,%ebx
f011b217:	89 d8                	mov    %ebx,%eax
f011b219:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b21e:	77 17                	ja     f011b237 <test_kheap_phys_addr+0x55f>
f011b220:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b227:	83 ec 0c             	sub    $0xc,%esp
f011b22a:	68 80 ee 12 f0       	push   $0xf012ee80
f011b22f:	e8 57 5d fe ff       	call   f0100f8b <cprintf>
f011b234:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011b237:	e8 72 36 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b23c:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b23f:	e8 61 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b244:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011b247:	83 ec 0c             	sub    $0xc,%esp
f011b24a:	68 00 38 00 00       	push   $0x3800
f011b24f:	e8 3d e2 fe ff       	call   f0109491 <kmalloc>
f011b254:	83 c4 10             	add    $0x10,%esp
f011b257:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b25d:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011b263:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011b268:	74 17                	je     f011b281 <test_kheap_phys_addr+0x5a9>
f011b26a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b271:	83 ec 0c             	sub    $0xc,%esp
f011b274:	68 c8 ee 12 f0       	push   $0xf012eec8
f011b279:	e8 0d 5d fe ff       	call   f0100f8b <cprintf>
f011b27e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b281:	e8 1f 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b286:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b289:	74 17                	je     f011b2a2 <test_kheap_phys_addr+0x5ca>
f011b28b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b292:	83 ec 0c             	sub    $0xc,%esp
f011b295:	68 1c ef 12 f0       	push   $0xf012ef1c
f011b29a:	e8 ec 5c fe ff       	call   f0100f8b <cprintf>
f011b29f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b2a2:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b2a5:	e8 04 36 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b2aa:	29 c3                	sub    %eax,%ebx
f011b2ac:	89 d8                	mov    %ebx,%eax
f011b2ae:	83 f8 03             	cmp    $0x3,%eax
f011b2b1:	77 17                	ja     f011b2ca <test_kheap_phys_addr+0x5f2>
f011b2b3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2ba:	83 ec 0c             	sub    $0xc,%esp
f011b2bd:	68 8c ef 12 f0       	push   $0xf012ef8c
f011b2c2:	e8 c4 5c fe ff       	call   f0100f8b <cprintf>
f011b2c7:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011b2ca:	83 ec 0c             	sub    $0xc,%esp
f011b2cd:	68 d4 ef 12 f0       	push   $0xf012efd4
f011b2d2:	e8 b4 5c fe ff       	call   f0100f8b <cprintf>
f011b2d7:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b2da:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b2e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011b2e8:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b2ef:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b2f4:	05 00 10 00 00       	add    $0x1000,%eax
f011b2f9:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b2fc:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b2ff:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b302:	eb 2e                	jmp    f011b332 <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b304:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b307:	8d 43 01             	lea    0x1(%ebx),%eax
f011b30a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b30d:	83 ec 0c             	sub    $0xc,%esp
f011b310:	ff 75 e8             	pushl  -0x18(%ebp)
f011b313:	e8 bf e4 fe ff       	call   f01097d7 <kheap_physical_address>
f011b318:	83 c4 10             	add    $0x10,%esp
f011b31b:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b322:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b325:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b328:	01 d0                	add    %edx,%eax
f011b32a:	05 00 10 00 00       	add    $0x1000,%eax
f011b32f:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b332:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b335:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b338:	72 ca                	jb     f011b304 <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b33a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b33d:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011b340:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b347:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b34a:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b34d:	e9 ce 00 00 00       	jmp    f011b420 <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b352:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011b357:	83 ec 04             	sub    $0x4,%esp
f011b35a:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011b360:	52                   	push   %edx
f011b361:	ff 75 e8             	pushl  -0x18(%ebp)
f011b364:	50                   	push   %eax
f011b365:	e8 85 d0 fe ff       	call   f01083ef <get_page_table>
f011b36a:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b36d:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b373:	85 c0                	test   %eax,%eax
f011b375:	75 1e                	jne    f011b395 <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b377:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b37e:	83 ec 04             	sub    $0x4,%esp
f011b381:	68 20 f0 12 f0       	push   $0xf012f020
f011b386:	68 e7 05 00 00       	push   $0x5e7
f011b38b:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011b390:	e8 a4 4f fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b395:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b398:	c1 e8 0c             	shr    $0xc,%eax
f011b39b:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b3a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011b3a3:	eb 62                	jmp    f011b407 <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011b3a5:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b3ab:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b3ae:	c1 e2 02             	shl    $0x2,%edx
f011b3b1:	01 d0                	add    %edx,%eax
f011b3b3:	8b 00                	mov    (%eax),%eax
f011b3b5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b3ba:	89 c2                	mov    %eax,%edx
f011b3bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b3bf:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b3c4:	01 c2                	add    %eax,%edx
f011b3c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b3c9:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b3d0:	39 c2                	cmp    %eax,%edx
f011b3d2:	74 1d                	je     f011b3f1 <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b3d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b3d8:	74 17                	je     f011b3f1 <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011b3da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b3e1:	83 ec 0c             	sub    $0xc,%esp
f011b3e4:	68 80 f0 12 f0       	push   $0xf012f080
f011b3e9:	e8 9d 5b fe ff       	call   f0100f8b <cprintf>
f011b3ee:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011b3f1:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b3f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b3f7:	01 d0                	add    %edx,%eax
f011b3f9:	05 00 10 00 00       	add    $0x1000,%eax
f011b3fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b401:	ff 45 e4             	incl   -0x1c(%ebp)
f011b404:	ff 45 f4             	incl   -0xc(%ebp)
f011b407:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b40a:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011b40d:	7d 11                	jge    f011b420 <test_kheap_phys_addr+0x748>
f011b40f:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011b416:	7f 08                	jg     f011b420 <test_kheap_phys_addr+0x748>
f011b418:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b41b:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b41e:	72 85                	jb     f011b3a5 <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b420:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b423:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b426:	0f 82 26 ff ff ff    	jb     f011b352 <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011b42c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b430:	74 04                	je     f011b436 <test_kheap_phys_addr+0x75e>
f011b432:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b436:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011b43d:	83 ec 0c             	sub    $0xc,%esp
f011b440:	68 a4 f0 12 f0       	push   $0xf012f0a4
f011b445:	e8 41 5b fe ff       	call   f0100f8b <cprintf>
f011b44a:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b44d:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011b454:	e9 b0 00 00 00       	jmp    f011b509 <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011b459:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011b45c:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011b463:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011b466:	83 ec 0c             	sub    $0xc,%esp
f011b469:	ff 75 90             	pushl  -0x70(%ebp)
f011b46c:	e8 66 e3 fe ff       	call   f01097d7 <kheap_physical_address>
f011b471:	83 c4 10             	add    $0x10,%esp
f011b474:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b477:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011b47c:	83 ec 04             	sub    $0x4,%esp
f011b47f:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011b485:	52                   	push   %edx
f011b486:	ff 75 90             	pushl  -0x70(%ebp)
f011b489:	50                   	push   %eax
f011b48a:	e8 60 cf fe ff       	call   f01083ef <get_page_table>
f011b48f:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b492:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b498:	85 c0                	test   %eax,%eax
f011b49a:	75 1e                	jne    f011b4ba <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b49c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b4a3:	83 ec 04             	sub    $0x4,%esp
f011b4a6:	68 f4 f0 12 f0       	push   $0xf012f0f4
f011b4ab:	68 04 06 00 00       	push   $0x604
f011b4b0:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011b4b5:	e8 7f 4e fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b4ba:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b4c0:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b4c3:	c1 ea 0c             	shr    $0xc,%edx
f011b4c6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b4cc:	c1 e2 02             	shl    $0x2,%edx
f011b4cf:	01 d0                	add    %edx,%eax
f011b4d1:	8b 00                	mov    (%eax),%eax
f011b4d3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b4d8:	89 c2                	mov    %eax,%edx
f011b4da:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b4dd:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b4e2:	01 d0                	add    %edx,%eax
f011b4e4:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011b4e7:	74 1d                	je     f011b506 <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b4e9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b4ed:	74 17                	je     f011b506 <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011b4ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b4f6:	83 ec 0c             	sub    $0xc,%esp
f011b4f9:	68 54 f1 12 f0       	push   $0xf012f154
f011b4fe:	e8 88 5a fe ff       	call   f0100f8b <cprintf>
f011b503:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b506:	ff 45 e0             	incl   -0x20(%ebp)
f011b509:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011b50d:	0f 8e 46 ff ff ff    	jle    f011b459 <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011b513:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b517:	74 04                	je     f011b51d <test_kheap_phys_addr+0x845>
f011b519:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011b51d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011b524:	83 ec 0c             	sub    $0xc,%esp
f011b527:	68 78 f1 12 f0       	push   $0xf012f178
f011b52c:	e8 5a 5a fe ff       	call   f0100f8b <cprintf>
f011b531:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011b534:	e8 75 33 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b539:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011b53c:	e8 64 93 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b541:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011b544:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b54a:	83 ec 0c             	sub    $0xc,%esp
f011b54d:	50                   	push   %eax
f011b54e:	e8 9e e1 fe ff       	call   f01096f1 <kfree>
f011b553:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b556:	e8 4a 93 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b55b:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b55e:	74 17                	je     f011b577 <test_kheap_phys_addr+0x89f>
f011b560:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b567:	83 ec 0c             	sub    $0xc,%esp
f011b56a:	68 64 dc 12 f0       	push   $0xf012dc64
f011b56f:	e8 17 5a fe ff       	call   f0100f8b <cprintf>
f011b574:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b577:	e8 32 33 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b57c:	89 c2                	mov    %eax,%edx
f011b57e:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b581:	29 c2                	sub    %eax,%edx
f011b583:	89 d0                	mov    %edx,%eax
f011b585:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b58a:	77 17                	ja     f011b5a3 <test_kheap_phys_addr+0x8cb>
f011b58c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b593:	83 ec 0c             	sub    $0xc,%esp
f011b596:	68 a0 f1 12 f0       	push   $0xf012f1a0
f011b59b:	e8 eb 59 fe ff       	call   f0100f8b <cprintf>
f011b5a0:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b5a3:	e8 06 33 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b5a8:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b5ab:	e8 f5 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b5b0:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011b5b3:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b5b9:	83 ec 0c             	sub    $0xc,%esp
f011b5bc:	50                   	push   %eax
f011b5bd:	e8 2f e1 fe ff       	call   f01096f1 <kfree>
f011b5c2:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b5c5:	e8 db 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b5ca:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b5cd:	74 17                	je     f011b5e6 <test_kheap_phys_addr+0x90e>
f011b5cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5d6:	83 ec 0c             	sub    $0xc,%esp
f011b5d9:	68 a4 dd 12 f0       	push   $0xf012dda4
f011b5de:	e8 a8 59 fe ff       	call   f0100f8b <cprintf>
f011b5e3:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b5e6:	e8 c3 32 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b5eb:	89 c2                	mov    %eax,%edx
f011b5ed:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b5f0:	29 c2                	sub    %eax,%edx
f011b5f2:	89 d0                	mov    %edx,%eax
f011b5f4:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b5f9:	77 17                	ja     f011b612 <test_kheap_phys_addr+0x93a>
f011b5fb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b602:	83 ec 0c             	sub    $0xc,%esp
f011b605:	68 dc f1 12 f0       	push   $0xf012f1dc
f011b60a:	e8 7c 59 fe ff       	call   f0100f8b <cprintf>
f011b60f:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b612:	e8 97 32 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b617:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b61a:	e8 86 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b61f:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011b622:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b628:	83 ec 0c             	sub    $0xc,%esp
f011b62b:	50                   	push   %eax
f011b62c:	e8 c0 e0 fe ff       	call   f01096f1 <kfree>
f011b631:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b634:	e8 6c 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b639:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b63c:	74 17                	je     f011b655 <test_kheap_phys_addr+0x97d>
f011b63e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b645:	83 ec 0c             	sub    $0xc,%esp
f011b648:	68 b0 de 12 f0       	push   $0xf012deb0
f011b64d:	e8 39 59 fe ff       	call   f0100f8b <cprintf>
f011b652:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b655:	e8 54 32 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011b65a:	89 c2                	mov    %eax,%edx
f011b65c:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b65f:	29 c2                	sub    %eax,%edx
f011b661:	89 d0                	mov    %edx,%eax
f011b663:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b668:	77 17                	ja     f011b681 <test_kheap_phys_addr+0x9a9>
f011b66a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b671:	83 ec 0c             	sub    $0xc,%esp
f011b674:	68 18 f2 12 f0       	push   $0xf012f218
f011b679:	e8 0d 59 fe ff       	call   f0100f8b <cprintf>
f011b67e:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011b681:	83 ec 0c             	sub    $0xc,%esp
f011b684:	68 54 f2 12 f0       	push   $0xf012f254
f011b689:	e8 fd 58 fe ff       	call   f0100f8b <cprintf>
f011b68e:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b691:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b698:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011b69f:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011b6a6:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011b6a9:	8b 15 d8 fd 17 f0    	mov    0xf017fdd8,%edx
f011b6af:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b6b5:	01 d0                	add    %edx,%eax
f011b6b7:	05 00 10 00 00       	add    $0x1000,%eax
f011b6bc:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b6c2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b6c8:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b6cb:	eb 25                	jmp    f011b6f2 <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b6cd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b6d0:	8d 43 01             	lea    0x1(%ebx),%eax
f011b6d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b6d6:	83 ec 0c             	sub    $0xc,%esp
f011b6d9:	ff 75 d8             	pushl  -0x28(%ebp)
f011b6dc:	e8 f6 e0 fe ff       	call   f01097d7 <kheap_physical_address>
f011b6e1:	83 c4 10             	add    $0x10,%esp
f011b6e4:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b6eb:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011b6f2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b6f5:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b6f8:	72 d3                	jb     f011b6cd <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b6fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b6fd:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011b703:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b70a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b710:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b713:	e9 f4 00 00 00       	jmp    f011b80c <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b718:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011b71d:	83 ec 04             	sub    $0x4,%esp
f011b720:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011b726:	52                   	push   %edx
f011b727:	ff 75 d8             	pushl  -0x28(%ebp)
f011b72a:	50                   	push   %eax
f011b72b:	e8 bf cc fe ff       	call   f01083ef <get_page_table>
f011b730:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b733:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b739:	85 c0                	test   %eax,%eax
f011b73b:	75 24                	jne    f011b761 <test_kheap_phys_addr+0xa89>
				if (correct)
f011b73d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b741:	74 1e                	je     f011b761 <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b743:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b74a:	83 ec 04             	sub    $0x4,%esp
f011b74d:	68 a4 f2 12 f0       	push   $0xf012f2a4
f011b752:	68 42 06 00 00       	push   $0x642
f011b757:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011b75c:	e8 d8 4b fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b761:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b764:	c1 e8 0c             	shr    $0xc,%eax
f011b767:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b76c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011b76f:	eb 7b                	jmp    f011b7ec <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011b771:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011b778:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b77e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b781:	c1 e2 02             	shl    $0x2,%edx
f011b784:	01 d0                	add    %edx,%eax
f011b786:	8b 00                	mov    (%eax),%eax
f011b788:	83 e0 01             	and    $0x1,%eax
f011b78b:	85 c0                	test   %eax,%eax
f011b78d:	74 24                	je     f011b7b3 <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011b78f:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b795:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b798:	c1 e2 02             	shl    $0x2,%edx
f011b79b:	01 d0                	add    %edx,%eax
f011b79d:	8b 00                	mov    (%eax),%eax
f011b79f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b7a4:	89 c2                	mov    %eax,%edx
f011b7a6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b7a9:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b7ae:	01 d0                	add    %edx,%eax
f011b7b0:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011b7b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b7b6:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b7bd:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011b7c0:	74 1d                	je     f011b7df <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b7c2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b7c6:	74 17                	je     f011b7df <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011b7c8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b7cf:	83 ec 0c             	sub    $0xc,%esp
f011b7d2:	68 04 f3 12 f0       	push   $0xf012f304
f011b7d7:	e8 af 57 fe ff       	call   f0100f8b <cprintf>
f011b7dc:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011b7df:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b7e6:	ff 45 d4             	incl   -0x2c(%ebp)
f011b7e9:	ff 45 f4             	incl   -0xc(%ebp)
f011b7ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b7ef:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011b7f5:	7d 15                	jge    f011b80c <test_kheap_phys_addr+0xb34>
f011b7f7:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011b7fe:	7f 0c                	jg     f011b80c <test_kheap_phys_addr+0xb34>
f011b800:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b803:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b806:	0f 82 65 ff ff ff    	jb     f011b771 <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b80c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b80f:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b812:	0f 82 00 ff ff ff    	jb     f011b718 <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011b818:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b81c:	74 04                	je     f011b822 <test_kheap_phys_addr+0xb4a>
f011b81e:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011b822:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011b829:	83 ec 0c             	sub    $0xc,%esp
f011b82c:	68 28 f3 12 f0       	push   $0xf012f328
f011b831:	e8 55 57 fe ff       	call   f0100f8b <cprintf>
f011b836:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011b839:	83 ec 0c             	sub    $0xc,%esp
f011b83c:	6a 00                	push   $0x0
f011b83e:	e8 1b db fe ff       	call   f010935e <sbrk>
f011b843:	83 c4 10             	add    $0x10,%esp
f011b846:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011b84b:	77 17                	ja     f011b864 <test_kheap_phys_addr+0xb8c>
f011b84d:	83 ec 04             	sub    $0x4,%esp
f011b850:	68 80 f3 12 f0       	push   $0xf012f380
f011b855:	68 5d 06 00 00       	push   $0x65d
f011b85a:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011b85f:	e8 d5 4a fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b864:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011b86b:	e9 af 00 00 00       	jmp    f011b91f <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011b870:	83 ec 0c             	sub    $0xc,%esp
f011b873:	ff 75 d0             	pushl  -0x30(%ebp)
f011b876:	e8 5c df fe ff       	call   f01097d7 <kheap_physical_address>
f011b87b:	83 c4 10             	add    $0x10,%esp
f011b87e:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b884:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011b889:	83 ec 04             	sub    $0x4,%esp
f011b88c:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011b892:	52                   	push   %edx
f011b893:	ff 75 d0             	pushl  -0x30(%ebp)
f011b896:	50                   	push   %eax
f011b897:	e8 53 cb fe ff       	call   f01083ef <get_page_table>
f011b89c:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b89f:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b8a5:	85 c0                	test   %eax,%eax
f011b8a7:	75 24                	jne    f011b8cd <test_kheap_phys_addr+0xbf5>
				if (correct)
f011b8a9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b8ad:	74 1e                	je     f011b8cd <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b8af:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b8b6:	83 ec 04             	sub    $0x4,%esp
f011b8b9:	68 9c f3 12 f0       	push   $0xf012f39c
f011b8be:	68 65 06 00 00       	push   $0x665
f011b8c3:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011b8c8:	e8 6c 4a fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b8cd:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b8d3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b8d6:	c1 ea 0c             	shr    $0xc,%edx
f011b8d9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b8df:	c1 e2 02             	shl    $0x2,%edx
f011b8e2:	01 d0                	add    %edx,%eax
f011b8e4:	8b 00                	mov    (%eax),%eax
f011b8e6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b8eb:	89 c2                	mov    %eax,%edx
f011b8ed:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b8f0:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b8f5:	01 d0                	add    %edx,%eax
f011b8f7:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011b8fd:	74 1d                	je     f011b91c <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b8ff:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b903:	74 17                	je     f011b91c <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011b905:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b90c:	83 ec 0c             	sub    $0xc,%esp
f011b90f:	68 fc f3 12 f0       	push   $0xf012f3fc
f011b914:	e8 72 56 fe ff       	call   f0100f8b <cprintf>
f011b919:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b91c:	ff 45 d0             	incl   -0x30(%ebp)
f011b91f:	83 ec 0c             	sub    $0xc,%esp
f011b922:	6a 00                	push   $0x0
f011b924:	e8 35 da fe ff       	call   f010935e <sbrk>
f011b929:	83 c4 10             	add    $0x10,%esp
f011b92c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011b92f:	0f 87 3b ff ff ff    	ja     f011b870 <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011b935:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b939:	74 04                	je     f011b93f <test_kheap_phys_addr+0xc67>
f011b93b:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b93f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011b946:	83 ec 0c             	sub    $0xc,%esp
f011b949:	68 20 f4 12 f0       	push   $0xf012f420
f011b94e:	e8 38 56 fe ff       	call   f0100f8b <cprintf>
f011b953:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011b956:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011b95d:	10 00 f9 
		i = 0;
f011b960:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011b967:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b96d:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011b970:	eb 0a                	jmp    f011b97c <test_kheap_phys_addr+0xca4>
		{
			i++;
f011b972:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011b975:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011b97c:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011b983:	76 ed                	jbe    f011b972 <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011b985:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b988:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011b98e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011b995:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b99b:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011b99e:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011b9a5:	e9 cb 00 00 00       	jmp    f011ba75 <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011b9aa:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011b9ad:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011b9b2:	83 ec 04             	sub    $0x4,%esp
f011b9b5:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011b9bb:	51                   	push   %ecx
f011b9bc:	52                   	push   %edx
f011b9bd:	50                   	push   %eax
f011b9be:	e8 2c ca fe ff       	call   f01083ef <get_page_table>
f011b9c3:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b9c6:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011b9cc:	85 c0                	test   %eax,%eax
f011b9ce:	75 24                	jne    f011b9f4 <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011b9d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b9d4:	74 1e                	je     f011b9f4 <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b9d6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9dd:	83 ec 04             	sub    $0x4,%esp
f011b9e0:	68 5c f4 12 f0       	push   $0xf012f45c
f011b9e5:	68 87 06 00 00       	push   $0x687
f011b9ea:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011b9ef:	e8 45 49 fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011b9f4:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011b9fb:	eb 59                	jmp    f011ba56 <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011b9fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ba00:	c1 e0 0c             	shl    $0xc,%eax
f011ba03:	89 c2                	mov    %eax,%edx
f011ba05:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011ba0b:	01 d0                	add    %edx,%eax
f011ba0d:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011ba13:	83 ec 0c             	sub    $0xc,%esp
f011ba16:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011ba1c:	e8 b6 dd fe ff       	call   f01097d7 <kheap_physical_address>
f011ba21:	83 c4 10             	add    $0x10,%esp
f011ba24:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011ba2a:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011ba31:	74 1d                	je     f011ba50 <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011ba33:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ba37:	74 17                	je     f011ba50 <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011ba39:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba40:	83 ec 0c             	sub    $0xc,%esp
f011ba43:	68 bc f4 12 f0       	push   $0xf012f4bc
f011ba48:	e8 3e 55 fe ff       	call   f0100f8b <cprintf>
f011ba4d:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011ba50:	ff 45 c8             	incl   -0x38(%ebp)
f011ba53:	ff 45 f4             	incl   -0xc(%ebp)
f011ba56:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ba59:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011ba5f:	7d 09                	jge    f011ba6a <test_kheap_phys_addr+0xd92>
f011ba61:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011ba68:	7e 93                	jle    f011b9fd <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011ba6a:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011ba71:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011ba75:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011ba79:	0f 88 2b ff ff ff    	js     f011b9aa <test_kheap_phys_addr+0xcd2>
f011ba7f:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011ba83:	7f 0d                	jg     f011ba92 <test_kheap_phys_addr+0xdba>
f011ba85:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011ba8c:	0f 86 18 ff ff ff    	jbe    f011b9aa <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011ba92:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ba96:	74 04                	je     f011ba9c <test_kheap_phys_addr+0xdc4>
f011ba98:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011ba9c:	83 ec 08             	sub    $0x8,%esp
f011ba9f:	ff 75 f0             	pushl  -0x10(%ebp)
f011baa2:	68 e0 f4 12 f0       	push   $0xf012f4e0
f011baa7:	e8 df 54 fe ff       	call   f0100f8b <cprintf>
f011baac:	83 c4 10             	add    $0x10,%esp

	return 1;
f011baaf:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011bab4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011bab7:	5b                   	pop    %ebx
f011bab8:	5f                   	pop    %edi
f011bab9:	5d                   	pop    %ebp
f011baba:	c3                   	ret    

f011babb <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011babb:	55                   	push   %ebp
f011babc:	89 e5                	mov    %esp,%ebp
f011babe:	57                   	push   %edi
f011babf:	56                   	push   %esi
f011bac0:	53                   	push   %ebx
f011bac1:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011bac7:	89 e0                	mov    %esp,%eax
f011bac9:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011bacb:	83 ec 0c             	sub    $0xc,%esp
f011bace:	68 68 ae 12 f0       	push   $0xf012ae68
f011bad3:	e8 b3 54 fe ff       	call   f0100f8b <cprintf>
f011bad8:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011badb:	83 ec 0c             	sub    $0xc,%esp
f011bade:	68 98 ae 12 f0       	push   $0xf012ae98
f011bae3:	e8 a3 54 fe ff       	call   f0100f8b <cprintf>
f011bae8:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011baeb:	83 ec 0c             	sub    $0xc,%esp
f011baee:	68 68 ae 12 f0       	push   $0xf012ae68
f011baf3:	e8 93 54 fe ff       	call   f0100f8b <cprintf>
f011baf8:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011bafb:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011baff:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011bb03:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011bb09:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011bb0f:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011bb16:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011bb1d:	e8 8c 2d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bb22:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011bb25:	83 ec 0c             	sub    $0xc,%esp
f011bb28:	68 bc eb 12 f0       	push   $0xf012ebbc
f011bb2d:	e8 59 54 fe ff       	call   f0100f8b <cprintf>
f011bb32:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011bb35:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011bb3b:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bb40:	b8 00 00 00 00       	mov    $0x0,%eax
f011bb45:	89 d7                	mov    %edx,%edi
f011bb47:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011bb49:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011bb4f:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bb54:	b8 00 00 00 00       	mov    $0x0,%eax
f011bb59:	89 d7                	mov    %edx,%edi
f011bb5b:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011bb5d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011bb64:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011bb6b:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011bb71:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bb76:	b8 00 00 00 00       	mov    $0x0,%eax
f011bb7b:	89 d7                	mov    %edx,%edi
f011bb7d:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bb7f:	e8 2a 2d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bb84:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bb87:	e8 19 8d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bb8c:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011bb8f:	83 ec 0c             	sub    $0xc,%esp
f011bb92:	68 00 fc 1f 00       	push   $0x1ffc00
f011bb97:	e8 f5 d8 fe ff       	call   f0109491 <kmalloc>
f011bb9c:	83 c4 10             	add    $0x10,%esp
f011bb9f:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bba5:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011bbab:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011bbb0:	74 17                	je     f011bbc9 <test_kheap_virt_addr+0x10e>
f011bbb2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bbb9:	83 ec 0c             	sub    $0xc,%esp
f011bbbc:	68 60 cf 12 f0       	push   $0xf012cf60
f011bbc1:	e8 c5 53 fe ff       	call   f0100f8b <cprintf>
f011bbc6:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bbc9:	e8 d7 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bbce:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bbd1:	74 17                	je     f011bbea <test_kheap_virt_addr+0x12f>
f011bbd3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bbda:	83 ec 0c             	sub    $0xc,%esp
f011bbdd:	68 b4 cf 12 f0       	push   $0xf012cfb4
f011bbe2:	e8 a4 53 fe ff       	call   f0100f8b <cprintf>
f011bbe7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bbea:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bbed:	e8 bc 2c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bbf2:	29 c3                	sub    %eax,%ebx
f011bbf4:	89 d8                	mov    %ebx,%eax
f011bbf6:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bbfb:	77 17                	ja     f011bc14 <test_kheap_virt_addr+0x159>
f011bbfd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc04:	83 ec 0c             	sub    $0xc,%esp
f011bc07:	68 24 d0 12 f0       	push   $0xf012d024
f011bc0c:	e8 7a 53 fe ff       	call   f0100f8b <cprintf>
f011bc11:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bc14:	e8 95 2c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bc19:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bc1c:	e8 84 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bc21:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011bc24:	83 ec 0c             	sub    $0xc,%esp
f011bc27:	68 00 fc 1f 00       	push   $0x1ffc00
f011bc2c:	e8 60 d8 fe ff       	call   f0109491 <kmalloc>
f011bc31:	83 c4 10             	add    $0x10,%esp
f011bc34:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bc3a:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bc40:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011bc45:	74 17                	je     f011bc5e <test_kheap_virt_addr+0x1a3>
f011bc47:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc4e:	83 ec 0c             	sub    $0xc,%esp
f011bc51:	68 6c d0 12 f0       	push   $0xf012d06c
f011bc56:	e8 30 53 fe ff       	call   f0100f8b <cprintf>
f011bc5b:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc5e:	e8 42 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bc63:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bc66:	74 17                	je     f011bc7f <test_kheap_virt_addr+0x1c4>
f011bc68:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc6f:	83 ec 0c             	sub    $0xc,%esp
f011bc72:	68 c0 d0 12 f0       	push   $0xf012d0c0
f011bc77:	e8 0f 53 fe ff       	call   f0100f8b <cprintf>
f011bc7c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bc7f:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bc82:	e8 27 2c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bc87:	29 c3                	sub    %eax,%ebx
f011bc89:	89 d8                	mov    %ebx,%eax
f011bc8b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bc90:	77 17                	ja     f011bca9 <test_kheap_virt_addr+0x1ee>
f011bc92:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc99:	83 ec 0c             	sub    $0xc,%esp
f011bc9c:	68 30 d1 12 f0       	push   $0xf012d130
f011bca1:	e8 e5 52 fe ff       	call   f0100f8b <cprintf>
f011bca6:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011bca9:	e8 00 2c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bcae:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bcb1:	e8 ef 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bcb6:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011bcb9:	83 ec 0c             	sub    $0xc,%esp
f011bcbc:	68 00 04 00 00       	push   $0x400
f011bcc1:	e8 cb d7 fe ff       	call   f0109491 <kmalloc>
f011bcc6:	83 c4 10             	add    $0x10,%esp
f011bcc9:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011bccf:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011bcd5:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bcda:	76 28                	jbe    f011bd04 <test_kheap_virt_addr+0x249>
f011bcdc:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011bce2:	83 ec 0c             	sub    $0xc,%esp
f011bce5:	6a 00                	push   $0x0
f011bce7:	e8 72 d6 fe ff       	call   f010935e <sbrk>
f011bcec:	83 c4 10             	add    $0x10,%esp
f011bcef:	39 c3                	cmp    %eax,%ebx
f011bcf1:	73 11                	jae    f011bd04 <test_kheap_virt_addr+0x249>
f011bcf3:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011bcf9:	89 c2                	mov    %eax,%edx
f011bcfb:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011bd00:	39 c2                	cmp    %eax,%edx
f011bd02:	72 17                	jb     f011bd1b <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bd04:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd0b:	83 ec 0c             	sub    $0xc,%esp
f011bd0e:	68 ec eb 12 f0       	push   $0xf012ebec
f011bd13:	e8 73 52 fe ff       	call   f0100f8b <cprintf>
f011bd18:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd1b:	e8 85 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd20:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bd23:	74 17                	je     f011bd3c <test_kheap_virt_addr+0x281>
f011bd25:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd2c:	83 ec 0c             	sub    $0xc,%esp
f011bd2f:	68 cc d1 12 f0       	push   $0xf012d1cc
f011bd34:	e8 52 52 fe ff       	call   f0100f8b <cprintf>
f011bd39:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011bd3c:	e8 6d 2b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bd41:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bd44:	e8 5c 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd49:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011bd4c:	83 ec 0c             	sub    $0xc,%esp
f011bd4f:	68 00 08 00 00       	push   $0x800
f011bd54:	e8 38 d7 fe ff       	call   f0109491 <kmalloc>
f011bd59:	83 c4 10             	add    $0x10,%esp
f011bd5c:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011bd62:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011bd68:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bd6d:	76 28                	jbe    f011bd97 <test_kheap_virt_addr+0x2dc>
f011bd6f:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011bd75:	83 ec 0c             	sub    $0xc,%esp
f011bd78:	6a 00                	push   $0x0
f011bd7a:	e8 df d5 fe ff       	call   f010935e <sbrk>
f011bd7f:	83 c4 10             	add    $0x10,%esp
f011bd82:	39 c3                	cmp    %eax,%ebx
f011bd84:	73 11                	jae    f011bd97 <test_kheap_virt_addr+0x2dc>
f011bd86:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011bd8c:	89 c2                	mov    %eax,%edx
f011bd8e:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011bd93:	39 c2                	cmp    %eax,%edx
f011bd95:	72 17                	jb     f011bdae <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bd97:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd9e:	83 ec 0c             	sub    $0xc,%esp
f011bda1:	68 78 ec 12 f0       	push   $0xf012ec78
f011bda6:	e8 e0 51 fe ff       	call   f0100f8b <cprintf>
f011bdab:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bdae:	e8 f2 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bdb3:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bdb6:	74 17                	je     f011bdcf <test_kheap_virt_addr+0x314>
f011bdb8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bdbf:	83 ec 0c             	sub    $0xc,%esp
f011bdc2:	68 d8 d2 12 f0       	push   $0xf012d2d8
f011bdc7:	e8 bf 51 fe ff       	call   f0100f8b <cprintf>
f011bdcc:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011bdcf:	e8 da 2a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bdd4:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bdd7:	e8 c9 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bddc:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011bddf:	83 ec 0c             	sub    $0xc,%esp
f011bde2:	68 00 06 00 00       	push   $0x600
f011bde7:	e8 a5 d6 fe ff       	call   f0109491 <kmalloc>
f011bdec:	83 c4 10             	add    $0x10,%esp
f011bdef:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011bdf5:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011bdfb:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011be00:	76 28                	jbe    f011be2a <test_kheap_virt_addr+0x36f>
f011be02:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011be08:	83 ec 0c             	sub    $0xc,%esp
f011be0b:	6a 00                	push   $0x0
f011be0d:	e8 4c d5 fe ff       	call   f010935e <sbrk>
f011be12:	83 c4 10             	add    $0x10,%esp
f011be15:	39 c3                	cmp    %eax,%ebx
f011be17:	73 11                	jae    f011be2a <test_kheap_virt_addr+0x36f>
f011be19:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011be1f:	89 c2                	mov    %eax,%edx
f011be21:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011be26:	39 c2                	cmp    %eax,%edx
f011be28:	72 17                	jb     f011be41 <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011be2a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be31:	83 ec 0c             	sub    $0xc,%esp
f011be34:	68 04 ed 12 f0       	push   $0xf012ed04
f011be39:	e8 4d 51 fe ff       	call   f0100f8b <cprintf>
f011be3e:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011be41:	e8 5f 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011be46:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011be49:	74 17                	je     f011be62 <test_kheap_virt_addr+0x3a7>
f011be4b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be52:	83 ec 0c             	sub    $0xc,%esp
f011be55:	68 e4 d3 12 f0       	push   $0xf012d3e4
f011be5a:	e8 2c 51 fe ff       	call   f0100f8b <cprintf>
f011be5f:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011be62:	e8 47 2a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011be67:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011be6a:	e8 36 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011be6f:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011be72:	83 ec 0c             	sub    $0xc,%esp
f011be75:	68 00 1c 00 00       	push   $0x1c00
f011be7a:	e8 12 d6 fe ff       	call   f0109491 <kmalloc>
f011be7f:	83 c4 10             	add    $0x10,%esp
f011be82:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011be88:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011be8e:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011be93:	74 17                	je     f011beac <test_kheap_virt_addr+0x3f1>
f011be95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be9c:	83 ec 0c             	sub    $0xc,%esp
f011be9f:	68 9c d4 12 f0       	push   $0xf012d49c
f011bea4:	e8 e2 50 fe ff       	call   f0100f8b <cprintf>
f011bea9:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011beac:	e8 f4 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011beb1:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011beb4:	74 17                	je     f011becd <test_kheap_virt_addr+0x412>
f011beb6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bebd:	83 ec 0c             	sub    $0xc,%esp
f011bec0:	68 f0 d4 12 f0       	push   $0xf012d4f0
f011bec5:	e8 c1 50 fe ff       	call   f0100f8b <cprintf>
f011beca:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011becd:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bed0:	e8 d9 29 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bed5:	29 c3                	sub    %eax,%ebx
f011bed7:	89 d8                	mov    %ebx,%eax
f011bed9:	83 f8 01             	cmp    $0x1,%eax
f011bedc:	77 17                	ja     f011bef5 <test_kheap_virt_addr+0x43a>
f011bede:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bee5:	83 ec 0c             	sub    $0xc,%esp
f011bee8:	68 60 d5 12 f0       	push   $0xf012d560
f011beed:	e8 99 50 fe ff       	call   f0100f8b <cprintf>
f011bef2:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011bef5:	e8 b4 29 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011befa:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011befd:	e8 a3 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bf02:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011bf05:	83 ec 0c             	sub    $0xc,%esp
f011bf08:	68 00 fc 2f 00       	push   $0x2ffc00
f011bf0d:	e8 7f d5 fe ff       	call   f0109491 <kmalloc>
f011bf12:	83 c4 10             	add    $0x10,%esp
f011bf15:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bf1b:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011bf21:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011bf26:	74 17                	je     f011bf3f <test_kheap_virt_addr+0x484>
f011bf28:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf2f:	83 ec 0c             	sub    $0xc,%esp
f011bf32:	68 90 ed 12 f0       	push   $0xf012ed90
f011bf37:	e8 4f 50 fe ff       	call   f0100f8b <cprintf>
f011bf3c:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bf3f:	e8 61 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bf44:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bf47:	74 17                	je     f011bf60 <test_kheap_virt_addr+0x4a5>
f011bf49:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf50:	83 ec 0c             	sub    $0xc,%esp
f011bf53:	68 34 d6 12 f0       	push   $0xf012d634
f011bf58:	e8 2e 50 fe ff       	call   f0100f8b <cprintf>
f011bf5d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bf60:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bf63:	e8 46 29 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bf68:	29 c3                	sub    %eax,%ebx
f011bf6a:	89 d8                	mov    %ebx,%eax
f011bf6c:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011bf71:	77 17                	ja     f011bf8a <test_kheap_virt_addr+0x4cf>
f011bf73:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf7a:	83 ec 0c             	sub    $0xc,%esp
f011bf7d:	68 e4 ed 12 f0       	push   $0xf012ede4
f011bf82:	e8 04 50 fe ff       	call   f0100f8b <cprintf>
f011bf87:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011bf8a:	e8 1f 29 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bf8f:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bf92:	e8 0e 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bf97:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011bf9a:	83 ec 0c             	sub    $0xc,%esp
f011bf9d:	68 00 fc 5f 00       	push   $0x5ffc00
f011bfa2:	e8 ea d4 fe ff       	call   f0109491 <kmalloc>
f011bfa7:	83 c4 10             	add    $0x10,%esp
f011bfaa:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bfb0:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011bfb6:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011bfbb:	74 17                	je     f011bfd4 <test_kheap_virt_addr+0x519>
f011bfbd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bfc4:	83 ec 0c             	sub    $0xc,%esp
f011bfc7:	68 2c ee 12 f0       	push   $0xf012ee2c
f011bfcc:	e8 ba 4f fe ff       	call   f0100f8b <cprintf>
f011bfd1:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bfd4:	e8 cc 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bfd9:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bfdc:	74 17                	je     f011bff5 <test_kheap_virt_addr+0x53a>
f011bfde:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bfe5:	83 ec 0c             	sub    $0xc,%esp
f011bfe8:	68 30 d7 12 f0       	push   $0xf012d730
f011bfed:	e8 99 4f fe ff       	call   f0100f8b <cprintf>
f011bff2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bff5:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bff8:	e8 b1 28 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011bffd:	29 c3                	sub    %eax,%ebx
f011bfff:	89 d8                	mov    %ebx,%eax
f011c001:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c006:	77 17                	ja     f011c01f <test_kheap_virt_addr+0x564>
f011c008:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c00f:	83 ec 0c             	sub    $0xc,%esp
f011c012:	68 80 ee 12 f0       	push   $0xf012ee80
f011c017:	e8 6f 4f fe ff       	call   f0100f8b <cprintf>
f011c01c:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011c01f:	e8 8a 28 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011c024:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c027:	e8 79 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c02c:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011c02f:	83 ec 0c             	sub    $0xc,%esp
f011c032:	68 00 38 00 00       	push   $0x3800
f011c037:	e8 55 d4 fe ff       	call   f0109491 <kmalloc>
f011c03c:	83 c4 10             	add    $0x10,%esp
f011c03f:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c045:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011c04b:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011c050:	74 17                	je     f011c069 <test_kheap_virt_addr+0x5ae>
f011c052:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c059:	83 ec 0c             	sub    $0xc,%esp
f011c05c:	68 c8 ee 12 f0       	push   $0xf012eec8
f011c061:	e8 25 4f fe ff       	call   f0100f8b <cprintf>
f011c066:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c069:	e8 37 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c06e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c071:	74 17                	je     f011c08a <test_kheap_virt_addr+0x5cf>
f011c073:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c07a:	83 ec 0c             	sub    $0xc,%esp
f011c07d:	68 1c ef 12 f0       	push   $0xf012ef1c
f011c082:	e8 04 4f fe ff       	call   f0100f8b <cprintf>
f011c087:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c08a:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c08d:	e8 1c 28 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011c092:	29 c3                	sub    %eax,%ebx
f011c094:	89 d8                	mov    %ebx,%eax
f011c096:	83 f8 03             	cmp    $0x3,%eax
f011c099:	77 17                	ja     f011c0b2 <test_kheap_virt_addr+0x5f7>
f011c09b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0a2:	83 ec 0c             	sub    $0xc,%esp
f011c0a5:	68 8c ef 12 f0       	push   $0xf012ef8c
f011c0aa:	e8 dc 4e fe ff       	call   f0100f8b <cprintf>
f011c0af:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011c0b2:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011c0b9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c0bc:	c1 e8 0c             	shr    $0xc,%eax
f011c0bf:	89 c2                	mov    %eax,%edx
f011c0c1:	4a                   	dec    %edx
f011c0c2:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011c0c5:	c1 e0 02             	shl    $0x2,%eax
f011c0c8:	8d 50 03             	lea    0x3(%eax),%edx
f011c0cb:	b8 10 00 00 00       	mov    $0x10,%eax
f011c0d0:	48                   	dec    %eax
f011c0d1:	01 d0                	add    %edx,%eax
f011c0d3:	bf 10 00 00 00       	mov    $0x10,%edi
f011c0d8:	ba 00 00 00 00       	mov    $0x0,%edx
f011c0dd:	f7 f7                	div    %edi
f011c0df:	6b c0 10             	imul   $0x10,%eax,%eax
f011c0e2:	29 c4                	sub    %eax,%esp
f011c0e4:	89 e0                	mov    %esp,%eax
f011c0e6:	83 c0 03             	add    $0x3,%eax
f011c0e9:	c1 e8 02             	shr    $0x2,%eax
f011c0ec:	c1 e0 02             	shl    $0x2,%eax
f011c0ef:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011c0f2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c0f5:	c1 e8 0c             	shr    $0xc,%eax
f011c0f8:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011c0fb:	83 ec 0c             	sub    $0xc,%esp
f011c0fe:	68 14 f5 12 f0       	push   $0xf012f514
f011c103:	e8 83 4e fe ff       	call   f0100f8b <cprintf>
f011c108:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c10b:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c112:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011c117:	05 00 10 00 00       	add    $0x1000,%eax
f011c11c:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011c11f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011c126:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c129:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011c12c:	e9 2d 01 00 00       	jmp    f011c25e <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c131:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011c136:	83 ec 04             	sub    $0x4,%esp
f011c139:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011c13f:	52                   	push   %edx
f011c140:	ff 75 dc             	pushl  -0x24(%ebp)
f011c143:	50                   	push   %eax
f011c144:	e8 a6 c2 fe ff       	call   f01083ef <get_page_table>
f011c149:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c14c:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c152:	85 c0                	test   %eax,%eax
f011c154:	75 1e                	jne    f011c174 <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c156:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c15d:	83 ec 04             	sub    $0x4,%esp
f011c160:	68 20 f0 12 f0       	push   $0xf012f020
f011c165:	68 26 07 00 00       	push   $0x726
f011c16a:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011c16f:	e8 c5 41 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c174:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c177:	c1 e8 0c             	shr    $0xc,%eax
f011c17a:	25 ff 03 00 00       	and    $0x3ff,%eax
f011c17f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011c182:	e9 ba 00 00 00       	jmp    f011c241 <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011c187:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c18a:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011c18d:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c193:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c196:	c1 e2 02             	shl    $0x2,%edx
f011c199:	01 d0                	add    %edx,%eax
f011c19b:	8b 00                	mov    (%eax),%eax
f011c19d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c1a2:	89 c2                	mov    %eax,%edx
f011c1a4:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c1a7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c1aa:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c1ad:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c1b0:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c1b3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c1b6:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c1b9:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c1bc:	83 ec 0c             	sub    $0xc,%esp
f011c1bf:	50                   	push   %eax
f011c1c0:	e8 6f d6 fe ff       	call   f0109834 <kheap_virtual_address>
f011c1c5:	83 c4 10             	add    $0x10,%esp
f011c1c8:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011c1cb:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c1ce:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c1d1:	01 d0                	add    %edx,%eax
f011c1d3:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c1d6:	74 5c                	je     f011c234 <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011c1d8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c1dc:	74 56                	je     f011c234 <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011c1de:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c1e1:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c1e4:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c1e7:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011c1ed:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011c1f0:	c1 e1 02             	shl    $0x2,%ecx
f011c1f3:	01 ca                	add    %ecx,%edx
f011c1f5:	8b 12                	mov    (%edx),%edx
f011c1f7:	89 d1                	mov    %edx,%ecx
f011c1f9:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011c1ff:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011c202:	8b 55 90             	mov    -0x70(%ebp),%edx
f011c205:	01 da                	add    %ebx,%edx
f011c207:	83 ec 0c             	sub    $0xc,%esp
f011c20a:	50                   	push   %eax
f011c20b:	51                   	push   %ecx
f011c20c:	52                   	push   %edx
f011c20d:	ff 75 8c             	pushl  -0x74(%ebp)
f011c210:	68 60 f5 12 f0       	push   $0xf012f560
f011c215:	e8 71 4d fe ff       	call   f0100f8b <cprintf>
f011c21a:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011c21d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c224:	83 ec 0c             	sub    $0xc,%esp
f011c227:	68 a4 f5 12 f0       	push   $0xf012f5a4
f011c22c:	e8 5a 4d fe ff       	call   f0100f8b <cprintf>
f011c231:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011c234:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c23b:	ff 45 d4             	incl   -0x2c(%ebp)
f011c23e:	ff 45 d8             	incl   -0x28(%ebp)
f011c241:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c244:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011c247:	7d 15                	jge    f011c25e <test_kheap_virt_addr+0x7a3>
f011c249:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011c250:	7f 0c                	jg     f011c25e <test_kheap_virt_addr+0x7a3>
f011c252:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c255:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c258:	0f 82 29 ff ff ff    	jb     f011c187 <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011c25e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c261:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c264:	0f 82 c7 fe ff ff    	jb     f011c131 <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011c26a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c26e:	74 04                	je     f011c274 <test_kheap_virt_addr+0x7b9>
f011c270:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c274:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011c27b:	83 ec 0c             	sub    $0xc,%esp
f011c27e:	68 c8 f5 12 f0       	push   $0xf012f5c8
f011c283:	e8 03 4d fe ff       	call   f0100f8b <cprintf>
f011c288:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c28b:	e8 1e 26 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011c290:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c293:	e8 0d 86 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c298:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011c29b:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c2a1:	83 ec 0c             	sub    $0xc,%esp
f011c2a4:	50                   	push   %eax
f011c2a5:	e8 47 d4 fe ff       	call   f01096f1 <kfree>
f011c2aa:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c2ad:	e8 f3 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c2b2:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c2b5:	74 17                	je     f011c2ce <test_kheap_virt_addr+0x813>
f011c2b7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c2be:	83 ec 0c             	sub    $0xc,%esp
f011c2c1:	68 f0 f5 12 f0       	push   $0xf012f5f0
f011c2c6:	e8 c0 4c fe ff       	call   f0100f8b <cprintf>
f011c2cb:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c2ce:	e8 db 25 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011c2d3:	89 c2                	mov    %eax,%edx
f011c2d5:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c2d8:	29 c2                	sub    %eax,%edx
f011c2da:	89 d0                	mov    %edx,%eax
f011c2dc:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c2e1:	77 17                	ja     f011c2fa <test_kheap_virt_addr+0x83f>
f011c2e3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c2ea:	83 ec 0c             	sub    $0xc,%esp
f011c2ed:	68 60 f6 12 f0       	push   $0xf012f660
f011c2f2:	e8 94 4c fe ff       	call   f0100f8b <cprintf>
f011c2f7:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c2fa:	e8 af 25 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011c2ff:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c302:	e8 9e 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c307:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011c30a:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c310:	83 ec 0c             	sub    $0xc,%esp
f011c313:	50                   	push   %eax
f011c314:	e8 d8 d3 fe ff       	call   f01096f1 <kfree>
f011c319:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c31c:	e8 84 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c321:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c324:	74 17                	je     f011c33d <test_kheap_virt_addr+0x882>
f011c326:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c32d:	83 ec 0c             	sub    $0xc,%esp
f011c330:	68 9c f6 12 f0       	push   $0xf012f69c
f011c335:	e8 51 4c fe ff       	call   f0100f8b <cprintf>
f011c33a:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c33d:	e8 6c 25 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011c342:	89 c2                	mov    %eax,%edx
f011c344:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c347:	29 c2                	sub    %eax,%edx
f011c349:	89 d0                	mov    %edx,%eax
f011c34b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c350:	77 17                	ja     f011c369 <test_kheap_virt_addr+0x8ae>
f011c352:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c359:	83 ec 0c             	sub    $0xc,%esp
f011c35c:	68 0c f7 12 f0       	push   $0xf012f70c
f011c361:	e8 25 4c fe ff       	call   f0100f8b <cprintf>
f011c366:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c369:	e8 40 25 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011c36e:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c371:	e8 2f 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c376:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011c379:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c37f:	83 ec 0c             	sub    $0xc,%esp
f011c382:	50                   	push   %eax
f011c383:	e8 69 d3 fe ff       	call   f01096f1 <kfree>
f011c388:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c38b:	e8 15 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c390:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c393:	74 17                	je     f011c3ac <test_kheap_virt_addr+0x8f1>
f011c395:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c39c:	83 ec 0c             	sub    $0xc,%esp
f011c39f:	68 48 f7 12 f0       	push   $0xf012f748
f011c3a4:	e8 e2 4b fe ff       	call   f0100f8b <cprintf>
f011c3a9:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c3ac:	e8 fd 24 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011c3b1:	89 c2                	mov    %eax,%edx
f011c3b3:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c3b6:	29 c2                	sub    %eax,%edx
f011c3b8:	89 d0                	mov    %edx,%eax
f011c3ba:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c3bf:	77 17                	ja     f011c3d8 <test_kheap_virt_addr+0x91d>
f011c3c1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3c8:	83 ec 0c             	sub    $0xc,%esp
f011c3cb:	68 b8 f7 12 f0       	push   $0xf012f7b8
f011c3d0:	e8 b6 4b fe ff       	call   f0100f8b <cprintf>
f011c3d5:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011c3d8:	83 ec 0c             	sub    $0xc,%esp
f011c3db:	68 f4 f7 12 f0       	push   $0xf012f7f4
f011c3e0:	e8 a6 4b fe ff       	call   f0100f8b <cprintf>
f011c3e5:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c3e8:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c3ef:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011c3f4:	05 00 10 00 00       	add    $0x1000,%eax
f011c3f9:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011c3ff:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011c406:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011c40d:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c410:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c416:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c419:	eb 44                	jmp    f011c45f <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c41b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c41e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c421:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c424:	83 ec 0c             	sub    $0xc,%esp
f011c427:	50                   	push   %eax
f011c428:	e8 07 d4 fe ff       	call   f0109834 <kheap_virtual_address>
f011c42d:	83 c4 10             	add    $0x10,%esp
f011c430:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011c436:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011c43d:	74 1d                	je     f011c45c <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011c43f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c443:	74 17                	je     f011c45c <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011c445:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c44c:	83 ec 0c             	sub    $0xc,%esp
f011c44f:	68 44 f8 12 f0       	push   $0xf012f844
f011c454:	e8 32 4b fe ff       	call   f0100f8b <cprintf>
f011c459:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c45c:	ff 45 d0             	incl   -0x30(%ebp)
f011c45f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c465:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011c46b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c46e:	39 c2                	cmp    %eax,%edx
f011c470:	77 a9                	ja     f011c41b <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c472:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c478:	05 00 04 00 00       	add    $0x400,%eax
f011c47d:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c480:	eb 64                	jmp    f011c4e6 <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c482:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c485:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c488:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c48b:	83 ec 0c             	sub    $0xc,%esp
f011c48e:	50                   	push   %eax
f011c48f:	e8 a0 d3 fe ff       	call   f0109834 <kheap_virtual_address>
f011c494:	83 c4 10             	add    $0x10,%esp
f011c497:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c49d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c4a0:	c1 e0 0c             	shl    $0xc,%eax
f011c4a3:	89 c2                	mov    %eax,%edx
f011c4a5:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c4ab:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c4ae:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c4b1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c4b4:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c4b7:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c4bc:	01 c8                	add    %ecx,%eax
f011c4be:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011c4c4:	74 1d                	je     f011c4e3 <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011c4c6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c4ca:	74 17                	je     f011c4e3 <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011c4cc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4d3:	83 ec 0c             	sub    $0xc,%esp
f011c4d6:	68 68 f8 12 f0       	push   $0xf012f868
f011c4db:	e8 ab 4a fe ff       	call   f0100f8b <cprintf>
f011c4e0:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c4e3:	ff 45 d0             	incl   -0x30(%ebp)
f011c4e6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c4ec:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011c4f2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c4f5:	39 c2                	cmp    %eax,%edx
f011c4f7:	77 89                	ja     f011c482 <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c4f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c4ff:	05 02 07 00 00       	add    $0x702,%eax
f011c504:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c507:	eb 44                	jmp    f011c54d <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c509:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c50c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c50f:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c512:	83 ec 0c             	sub    $0xc,%esp
f011c515:	50                   	push   %eax
f011c516:	e8 19 d3 fe ff       	call   f0109834 <kheap_virtual_address>
f011c51b:	83 c4 10             	add    $0x10,%esp
f011c51e:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011c524:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011c52b:	74 1d                	je     f011c54a <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011c52d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c531:	74 17                	je     f011c54a <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011c533:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c53a:	83 ec 0c             	sub    $0xc,%esp
f011c53d:	68 8c f8 12 f0       	push   $0xf012f88c
f011c542:	e8 44 4a fe ff       	call   f0100f8b <cprintf>
f011c547:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c54a:	ff 45 d0             	incl   -0x30(%ebp)
f011c54d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c553:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011c559:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c55c:	39 c2                	cmp    %eax,%edx
f011c55e:	77 a9                	ja     f011c509 <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c560:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c566:	05 02 0d 00 00       	add    $0xd02,%eax
f011c56b:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c56e:	eb 64                	jmp    f011c5d4 <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c570:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c573:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c576:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c579:	83 ec 0c             	sub    $0xc,%esp
f011c57c:	50                   	push   %eax
f011c57d:	e8 b2 d2 fe ff       	call   f0109834 <kheap_virtual_address>
f011c582:	83 c4 10             	add    $0x10,%esp
f011c585:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c58b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c58e:	c1 e0 0c             	shl    $0xc,%eax
f011c591:	89 c2                	mov    %eax,%edx
f011c593:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c599:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c59c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c59f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c5a2:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c5a5:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c5aa:	01 c8                	add    %ecx,%eax
f011c5ac:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011c5b2:	74 1d                	je     f011c5d1 <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011c5b4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c5b8:	74 17                	je     f011c5d1 <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011c5ba:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c5c1:	83 ec 0c             	sub    $0xc,%esp
f011c5c4:	68 b0 f8 12 f0       	push   $0xf012f8b0
f011c5c9:	e8 bd 49 fe ff       	call   f0100f8b <cprintf>
f011c5ce:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c5d1:	ff 45 d0             	incl   -0x30(%ebp)
f011c5d4:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c5da:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011c5e0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c5e3:	39 c2                	cmp    %eax,%edx
f011c5e5:	77 89                	ja     f011c570 <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011c5e7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c5eb:	74 04                	je     f011c5f1 <test_kheap_virt_addr+0xb36>
f011c5ed:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c5f1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011c5f8:	83 ec 0c             	sub    $0xc,%esp
f011c5fb:	68 d4 f8 12 f0       	push   $0xf012f8d4
f011c600:	e8 86 49 fe ff       	call   f0100f8b <cprintf>
f011c605:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011c608:	83 ec 0c             	sub    $0xc,%esp
f011c60b:	6a 00                	push   $0x0
f011c60d:	e8 4c cd fe ff       	call   f010935e <sbrk>
f011c612:	83 c4 10             	add    $0x10,%esp
f011c615:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011c61a:	77 17                	ja     f011c633 <test_kheap_virt_addr+0xb78>
f011c61c:	83 ec 04             	sub    $0x4,%esp
f011c61f:	68 1b f9 12 f0       	push   $0xf012f91b
f011c624:	68 91 07 00 00       	push   $0x791
f011c629:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011c62e:	e8 06 3d fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c633:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011c63a:	e9 d1 00 00 00       	jmp    f011c710 <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c63f:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011c644:	83 ec 04             	sub    $0x4,%esp
f011c647:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011c64d:	52                   	push   %edx
f011c64e:	ff 75 cc             	pushl  -0x34(%ebp)
f011c651:	50                   	push   %eax
f011c652:	e8 98 bd fe ff       	call   f01083ef <get_page_table>
f011c657:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c65a:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c660:	85 c0                	test   %eax,%eax
f011c662:	75 1e                	jne    f011c682 <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c664:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c66b:	83 ec 04             	sub    $0x4,%esp
f011c66e:	68 a4 f2 12 f0       	push   $0xf012f2a4
f011c673:	68 97 07 00 00       	push   $0x797
f011c678:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011c67d:	e8 b7 3c fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011c682:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c688:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c68b:	c1 ea 0c             	shr    $0xc,%edx
f011c68e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c694:	c1 e2 02             	shl    $0x2,%edx
f011c697:	01 d0                	add    %edx,%eax
f011c699:	8b 00                	mov    (%eax),%eax
f011c69b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c6a0:	89 c2                	mov    %eax,%edx
f011c6a2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011c6a5:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c6aa:	01 d0                	add    %edx,%eax
f011c6ac:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011c6b2:	83 ec 0c             	sub    $0xc,%esp
f011c6b5:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c6bb:	e8 74 d1 fe ff       	call   f0109834 <kheap_virtual_address>
f011c6c0:	83 c4 10             	add    $0x10,%esp
f011c6c3:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011c6c9:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011c6cf:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c6d2:	74 39                	je     f011c70d <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011c6d4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c6d8:	74 33                	je     f011c70d <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011c6da:	ff 75 cc             	pushl  -0x34(%ebp)
f011c6dd:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011c6e3:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c6e9:	68 34 f9 12 f0       	push   $0xf012f934
f011c6ee:	e8 98 48 fe ff       	call   f0100f8b <cprintf>
f011c6f3:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011c6f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c6fd:	83 ec 0c             	sub    $0xc,%esp
f011c700:	68 60 f9 12 f0       	push   $0xf012f960
f011c705:	e8 81 48 fe ff       	call   f0100f8b <cprintf>
f011c70a:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c70d:	ff 45 cc             	incl   -0x34(%ebp)
f011c710:	83 ec 0c             	sub    $0xc,%esp
f011c713:	6a 00                	push   $0x0
f011c715:	e8 44 cc fe ff       	call   f010935e <sbrk>
f011c71a:	83 c4 10             	add    $0x10,%esp
f011c71d:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c720:	0f 87 19 ff ff ff    	ja     f011c63f <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011c726:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c72a:	74 04                	je     f011c730 <test_kheap_virt_addr+0xc75>
f011c72c:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011c730:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011c737:	83 ec 0c             	sub    $0xc,%esp
f011c73a:	68 84 f9 12 f0       	push   $0xf012f984
f011c73f:	e8 47 48 fe ff       	call   f0100f8b <cprintf>
f011c744:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c747:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011c74e:	eb 5a                	jmp    f011c7aa <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011c750:	83 ec 0c             	sub    $0xc,%esp
f011c753:	ff 75 c8             	pushl  -0x38(%ebp)
f011c756:	e8 d9 d0 fe ff       	call   f0109834 <kheap_virtual_address>
f011c75b:	83 c4 10             	add    $0x10,%esp
f011c75e:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011c764:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011c76b:	74 36                	je     f011c7a3 <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011c76d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c771:	74 30                	je     f011c7a3 <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011c773:	83 ec 04             	sub    $0x4,%esp
f011c776:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011c77c:	ff 75 c8             	pushl  -0x38(%ebp)
f011c77f:	68 c3 f9 12 f0       	push   $0xf012f9c3
f011c784:	e8 02 48 fe ff       	call   f0100f8b <cprintf>
f011c789:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011c78c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c793:	83 ec 0c             	sub    $0xc,%esp
f011c796:	68 e0 f9 12 f0       	push   $0xf012f9e0
f011c79b:	e8 eb 47 fe ff       	call   f0100f8b <cprintf>
f011c7a0:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c7a3:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011c7aa:	b8 b0 b7 b0 00       	mov    $0xb0b7b0,%eax
f011c7af:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011c7b2:	72 9c                	jb     f011c750 <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011c7b4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c7b8:	74 04                	je     f011c7be <test_kheap_virt_addr+0xd03>
f011c7ba:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011c7be:	83 ec 08             	sub    $0x8,%esp
f011c7c1:	ff 75 e4             	pushl  -0x1c(%ebp)
f011c7c4:	68 04 fa 12 f0       	push   $0xf012fa04
f011c7c9:	e8 bd 47 fe ff       	call   f0100f8b <cprintf>
f011c7ce:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c7d1:	b8 01 00 00 00       	mov    $0x1,%eax
f011c7d6:	89 f4                	mov    %esi,%esp

}
f011c7d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c7db:	5b                   	pop    %ebx
f011c7dc:	5e                   	pop    %esi
f011c7dd:	5f                   	pop    %edi
f011c7de:	5d                   	pop    %ebp
f011c7df:	c3                   	ret    

f011c7e0 <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011c7e0:	55                   	push   %ebp
f011c7e1:	89 e5                	mov    %esp,%ebp
f011c7e3:	57                   	push   %edi
f011c7e4:	56                   	push   %esi
f011c7e5:	53                   	push   %ebx
f011c7e6:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011c7ec:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011c7f2:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c7f7:	b8 00 00 00 00       	mov    $0x0,%eax
f011c7fc:	89 d7                	mov    %edx,%edi
f011c7fe:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011c800:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011c807:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011c80e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011c815:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f011c81a:	0f b6 c0             	movzbl %al,%eax
f011c81d:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011c820:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011c827:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011c82a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c82d:	39 c2                	cmp    %eax,%edx
f011c82f:	73 02                	jae    f011c833 <test_ksbrk+0x53>
f011c831:	89 c2                	mov    %eax,%edx
f011c833:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f011c838:	0f b6 c0             	movzbl %al,%eax
f011c83b:	c1 e0 04             	shl    $0x4,%eax
f011c83e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011c841:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011c848:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011c84b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011c84e:	39 c8                	cmp    %ecx,%eax
f011c850:	73 02                	jae    f011c854 <test_ksbrk+0x74>
f011c852:	89 c8                	mov    %ecx,%eax
f011c854:	01 d0                	add    %edx,%eax
f011c856:	83 c0 10             	add    $0x10,%eax
f011c859:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011c85e:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011c861:	83 ec 0c             	sub    $0xc,%esp
f011c864:	68 38 fa 12 f0       	push   $0xf012fa38
f011c869:	e8 1d 47 fe ff       	call   f0100f8b <cprintf>
f011c86e:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011c871:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c878:	e8 31 20 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011c87d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c880:	e8 20 80 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c885:	89 45 b0             	mov    %eax,-0x50(%ebp)
		print_blocks_list(freeBlocksList);
f011c888:	83 ec 10             	sub    $0x10,%esp
f011c88b:	89 e0                	mov    %esp,%eax
f011c88d:	89 c2                	mov    %eax,%edx
f011c88f:	bb 10 07 6c f0       	mov    $0xf06c0710,%ebx
f011c894:	b8 04 00 00 00       	mov    $0x4,%eax
f011c899:	89 d7                	mov    %edx,%edi
f011c89b:	89 de                	mov    %ebx,%esi
f011c89d:	89 c1                	mov    %eax,%ecx
f011c89f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011c8a1:	e8 53 3e 00 00       	call   f01206f9 <print_blocks_list>
f011c8a6:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011c8a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c8ac:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c8af:	29 c2                	sub    %eax,%edx
f011c8b1:	89 d0                	mov    %edx,%eax
f011c8b3:	83 ec 0c             	sub    $0xc,%esp
f011c8b6:	50                   	push   %eax
f011c8b7:	e8 d5 cb fe ff       	call   f0109491 <kmalloc>
f011c8bc:	83 c4 10             	add    $0x10,%esp
f011c8bf:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011c8c5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c8c8:	89 c2                	mov    %eax,%edx
f011c8ca:	c1 ea 1f             	shr    $0x1f,%edx
f011c8cd:	01 d0                	add    %edx,%eax
f011c8cf:	d1 f8                	sar    %eax
f011c8d1:	89 c2                	mov    %eax,%edx
f011c8d3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c8d6:	01 d0                	add    %edx,%eax
f011c8d8:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011c8db:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011c8e1:	6a 01                	push   $0x1
f011c8e3:	ff 75 b8             	pushl  -0x48(%ebp)
f011c8e6:	ff 75 ac             	pushl  -0x54(%ebp)
f011c8e9:	50                   	push   %eax
f011c8ea:	e8 db 43 ff ff       	call   f0110cca <check_block>
f011c8ef:	83 c4 10             	add    $0x10,%esp
f011c8f2:	85 c0                	test   %eax,%eax
f011c8f4:	75 17                	jne    f011c90d <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011c8f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8fd:	83 ec 0c             	sub    $0xc,%esp
f011c900:	68 89 fa 12 f0       	push   $0xf012fa89
f011c905:	e8 81 46 fe ff       	call   f0100f8b <cprintf>
f011c90a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c90d:	e8 9c 1f ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011c912:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c915:	74 17                	je     f011c92e <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011c917:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c91e:	83 ec 0c             	sub    $0xc,%esp
f011c921:	68 a0 fa 12 f0       	push   $0xf012faa0
f011c926:	e8 60 46 fe ff       	call   f0100f8b <cprintf>
f011c92b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c92e:	e8 72 7f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c933:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c936:	74 17                	je     f011c94f <test_ksbrk+0x16f>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c938:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c93f:	83 ec 0c             	sub    $0xc,%esp
f011c942:	68 c0 fa 12 f0       	push   $0xf012fac0
f011c947:	e8 3f 46 fe ff       	call   f0100f8b <cprintf>
f011c94c:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011c94f:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f011c954:	0f b6 c0             	movzbl %al,%eax
f011c957:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011c95a:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011c961:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011c964:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011c967:	39 c2                	cmp    %eax,%edx
f011c969:	73 02                	jae    f011c96d <test_ksbrk+0x18d>
f011c96b:	89 c2                	mov    %eax,%edx
f011c96d:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f011c972:	0f b6 c0             	movzbl %al,%eax
f011c975:	c1 e0 04             	shl    $0x4,%eax
f011c978:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011c97b:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011c982:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011c985:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c988:	39 c8                	cmp    %ecx,%eax
f011c98a:	73 02                	jae    f011c98e <test_ksbrk+0x1ae>
f011c98c:	89 c8                	mov    %ecx,%eax
f011c98e:	01 d0                	add    %edx,%eax
f011c990:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011c995:	29 c2                	sub    %eax,%edx
f011c997:	89 d0                	mov    %edx,%eax
f011c999:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c99c:	e8 0d 1f ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011c9a1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c9a4:	e8 fc 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c9a9:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011c9ac:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c9af:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c9b2:	29 c2                	sub    %eax,%edx
f011c9b4:	89 d0                	mov    %edx,%eax
f011c9b6:	83 ec 0c             	sub    $0xc,%esp
f011c9b9:	50                   	push   %eax
f011c9ba:	e8 d2 ca fe ff       	call   f0109491 <kmalloc>
f011c9bf:	83 c4 10             	add    $0x10,%esp
f011c9c2:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011c9c8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c9cb:	89 c2                	mov    %eax,%edx
f011c9cd:	c1 ea 1f             	shr    $0x1f,%edx
f011c9d0:	01 d0                	add    %edx,%eax
f011c9d2:	d1 f8                	sar    %eax
f011c9d4:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011c9da:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c9dd:	01 d0                	add    %edx,%eax
f011c9df:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011c9e2:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011c9e8:	6a 01                	push   $0x1
f011c9ea:	ff 75 b8             	pushl  -0x48(%ebp)
f011c9ed:	ff 75 ac             	pushl  -0x54(%ebp)
f011c9f0:	50                   	push   %eax
f011c9f1:	e8 d4 42 ff ff       	call   f0110cca <check_block>
f011c9f6:	83 c4 10             	add    $0x10,%esp
f011c9f9:	85 c0                	test   %eax,%eax
f011c9fb:	75 17                	jne    f011ca14 <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011c9fd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca04:	83 ec 0c             	sub    $0xc,%esp
f011ca07:	68 2e fb 12 f0       	push   $0xf012fb2e
f011ca0c:	e8 7a 45 fe ff       	call   f0100f8b <cprintf>
f011ca11:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011ca14:	e8 95 1e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011ca19:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ca1c:	74 17                	je     f011ca35 <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011ca1e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca25:	83 ec 0c             	sub    $0xc,%esp
f011ca28:	68 48 fb 12 f0       	push   $0xf012fb48
f011ca2d:	e8 59 45 fe ff       	call   f0100f8b <cprintf>
f011ca32:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011ca35:	e8 6b 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ca3a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ca3d:	74 17                	je     f011ca56 <test_ksbrk+0x276>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ca3f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca46:	83 ec 0c             	sub    $0xc,%esp
f011ca49:	68 68 fb 12 f0       	push   $0xf012fb68
f011ca4e:	e8 38 45 fe ff       	call   f0100f8b <cprintf>
f011ca53:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011ca56:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011ca5d:	e8 4c 1e ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011ca62:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ca65:	e8 3b 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ca6a:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011ca6d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ca70:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ca73:	29 c2                	sub    %eax,%edx
f011ca75:	89 d0                	mov    %edx,%eax
f011ca77:	83 ec 0c             	sub    $0xc,%esp
f011ca7a:	50                   	push   %eax
f011ca7b:	e8 11 ca fe ff       	call   f0109491 <kmalloc>
f011ca80:	83 c4 10             	add    $0x10,%esp
f011ca83:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011ca89:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ca8c:	89 c2                	mov    %eax,%edx
f011ca8e:	c1 ea 1f             	shr    $0x1f,%edx
f011ca91:	01 d0                	add    %edx,%eax
f011ca93:	d1 f8                	sar    %eax
f011ca95:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011ca9a:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011ca9d:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011caa3:	6a 01                	push   $0x1
f011caa5:	ff 75 b8             	pushl  -0x48(%ebp)
f011caa8:	ff 75 ac             	pushl  -0x54(%ebp)
f011caab:	50                   	push   %eax
f011caac:	e8 19 42 ff ff       	call   f0110cca <check_block>
f011cab1:	83 c4 10             	add    $0x10,%esp
f011cab4:	85 c0                	test   %eax,%eax
f011cab6:	75 17                	jne    f011cacf <test_ksbrk+0x2ef>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011cab8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cabf:	83 ec 0c             	sub    $0xc,%esp
f011cac2:	68 d6 fb 12 f0       	push   $0xf012fbd6
f011cac7:	e8 bf 44 fe ff       	call   f0100f8b <cprintf>
f011cacc:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011cacf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cad2:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011cad5:	b8 00 10 00 00       	mov    $0x1000,%eax
f011cada:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011cadd:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011cae0:	6a 00                	push   $0x0
f011cae2:	ff 75 98             	pushl  -0x68(%ebp)
f011cae5:	ff 75 ac             	pushl  -0x54(%ebp)
f011cae8:	ff 75 ac             	pushl  -0x54(%ebp)
f011caeb:	e8 da 41 ff ff       	call   f0110cca <check_block>
f011caf0:	83 c4 10             	add    $0x10,%esp
f011caf3:	85 c0                	test   %eax,%eax
f011caf5:	75 17                	jne    f011cb0e <test_ksbrk+0x32e>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011caf7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cafe:	83 ec 0c             	sub    $0xc,%esp
f011cb01:	68 ed fb 12 f0       	push   $0xf012fbed
f011cb06:	e8 80 44 fe ff       	call   f0100f8b <cprintf>
f011cb0b:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011cb0e:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011cb15:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cb18:	8b 00                	mov    (%eax),%eax
f011cb1a:	83 f8 01             	cmp    $0x1,%eax
f011cb1d:	74 17                	je     f011cb36 <test_ksbrk+0x356>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011cb1f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb26:	83 ec 0c             	sub    $0xc,%esp
f011cb29:	68 04 fc 12 f0       	push   $0xf012fc04
f011cb2e:	e8 58 44 fe ff       	call   f0100f8b <cprintf>
f011cb33:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011cb36:	83 ec 0c             	sub    $0xc,%esp
f011cb39:	6a 00                	push   $0x0
f011cb3b:	e8 1e c8 fe ff       	call   f010935e <sbrk>
f011cb40:	83 c4 10             	add    $0x10,%esp
f011cb43:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011cb46:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011cb4d:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cb50:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011cb53:	74 1d                	je     f011cb72 <test_ksbrk+0x392>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011cb55:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb5c:	83 ec 04             	sub    $0x4,%esp
f011cb5f:	ff 75 90             	pushl  -0x70(%ebp)
f011cb62:	ff 75 8c             	pushl  -0x74(%ebp)
f011cb65:	68 30 fc 12 f0       	push   $0xf012fc30
f011cb6a:	e8 1c 44 fe ff       	call   f0100f8b <cprintf>
f011cb6f:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cb72:	e8 37 1d ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011cb77:	89 c2                	mov    %eax,%edx
f011cb79:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cb7c:	29 d0                	sub    %edx,%eax
f011cb7e:	83 f8 01             	cmp    $0x1,%eax
f011cb81:	74 17                	je     f011cb9a <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011cb83:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb8a:	83 ec 0c             	sub    $0xc,%esp
f011cb8d:	68 64 fc 12 f0       	push   $0xf012fc64
f011cb92:	e8 f4 43 fe ff       	call   f0100f8b <cprintf>
f011cb97:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cb9a:	e8 06 7d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cb9f:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cba2:	74 17                	je     f011cbbb <test_ksbrk+0x3db>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cba4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbab:	83 ec 0c             	sub    $0xc,%esp
f011cbae:	68 84 fc 12 f0       	push   $0xf012fc84
f011cbb3:	e8 d3 43 fe ff       	call   f0100f8b <cprintf>
f011cbb8:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011cbbb:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cbc2:	e8 e7 1c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011cbc7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cbca:	e8 d6 7c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cbcf:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011cbd2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cbd5:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cbd8:	29 c2                	sub    %eax,%edx
f011cbda:	89 d0                	mov    %edx,%eax
f011cbdc:	83 ec 0c             	sub    $0xc,%esp
f011cbdf:	50                   	push   %eax
f011cbe0:	e8 ac c8 fe ff       	call   f0109491 <kmalloc>
f011cbe5:	83 c4 10             	add    $0x10,%esp
f011cbe8:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011cbee:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011cbf5:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011cbfb:	6a 01                	push   $0x1
f011cbfd:	ff 75 b8             	pushl  -0x48(%ebp)
f011cc00:	ff 75 ac             	pushl  -0x54(%ebp)
f011cc03:	50                   	push   %eax
f011cc04:	e8 c1 40 ff ff       	call   f0110cca <check_block>
f011cc09:	83 c4 10             	add    $0x10,%esp
f011cc0c:	85 c0                	test   %eax,%eax
f011cc0e:	75 17                	jne    f011cc27 <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011cc10:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc17:	83 ec 0c             	sub    $0xc,%esp
f011cc1a:	68 f3 fc 12 f0       	push   $0xf012fcf3
f011cc1f:	e8 67 43 fe ff       	call   f0100f8b <cprintf>
f011cc24:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cc27:	e8 82 1c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011cc2c:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cc2f:	74 17                	je     f011cc48 <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011cc31:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc38:	83 ec 0c             	sub    $0xc,%esp
f011cc3b:	68 0c fd 12 f0       	push   $0xf012fd0c
f011cc40:	e8 46 43 fe ff       	call   f0100f8b <cprintf>
f011cc45:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cc48:	e8 58 7c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cc4d:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cc50:	74 17                	je     f011cc69 <test_ksbrk+0x489>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cc52:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc59:	83 ec 0c             	sub    $0xc,%esp
f011cc5c:	68 2c fd 12 f0       	push   $0xf012fd2c
f011cc61:	e8 25 43 fe ff       	call   f0100f8b <cprintf>
f011cc66:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011cc69:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cc6d:	74 04                	je     f011cc73 <test_ksbrk+0x493>
		eval += 25;
f011cc6f:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011cc73:	83 ec 0c             	sub    $0xc,%esp
f011cc76:	68 9c fd 12 f0       	push   $0xf012fd9c
f011cc7b:	e8 0b 43 fe ff       	call   f0100f8b <cprintf>
f011cc80:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011cc83:	83 ec 0c             	sub    $0xc,%esp
f011cc86:	6a 00                	push   $0x0
f011cc88:	e8 d1 c6 fe ff       	call   f010935e <sbrk>
f011cc8d:	83 c4 10             	add    $0x10,%esp
f011cc90:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011cc93:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cc9a:	e8 0f 1c ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011cc9f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cca2:	e8 fe 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cca7:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011ccaa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ccad:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ccb0:	29 c2                	sub    %eax,%edx
f011ccb2:	89 d0                	mov    %edx,%eax
f011ccb4:	83 ec 0c             	sub    $0xc,%esp
f011ccb7:	50                   	push   %eax
f011ccb8:	e8 d4 c7 fe ff       	call   f0109491 <kmalloc>
f011ccbd:	83 c4 10             	add    $0x10,%esp
f011ccc0:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011ccc6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ccc9:	89 c2                	mov    %eax,%edx
f011cccb:	c1 ea 1f             	shr    $0x1f,%edx
f011ccce:	01 d0                	add    %edx,%eax
f011ccd0:	d1 f8                	sar    %eax
f011ccd2:	89 c2                	mov    %eax,%edx
f011ccd4:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ccd7:	01 d0                	add    %edx,%eax
f011ccd9:	83 e8 04             	sub    $0x4,%eax
f011ccdc:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011ccdf:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011cce5:	6a 01                	push   $0x1
f011cce7:	ff 75 b8             	pushl  -0x48(%ebp)
f011ccea:	ff 75 ac             	pushl  -0x54(%ebp)
f011cced:	50                   	push   %eax
f011ccee:	e8 d7 3f ff ff       	call   f0110cca <check_block>
f011ccf3:	83 c4 10             	add    $0x10,%esp
f011ccf6:	85 c0                	test   %eax,%eax
f011ccf8:	75 17                	jne    f011cd11 <test_ksbrk+0x531>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011ccfa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd01:	83 ec 0c             	sub    $0xc,%esp
f011cd04:	68 ff fd 12 f0       	push   $0xf012fdff
f011cd09:	e8 7d 42 fe ff       	call   f0100f8b <cprintf>
f011cd0e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cd11:	e8 98 1b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011cd16:	89 c2                	mov    %eax,%edx
f011cd18:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cd1b:	29 d0                	sub    %edx,%eax
f011cd1d:	83 f8 01             	cmp    $0x1,%eax
f011cd20:	74 17                	je     f011cd39 <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011cd22:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd29:	83 ec 0c             	sub    $0xc,%esp
f011cd2c:	68 18 fe 12 f0       	push   $0xf012fe18
f011cd31:	e8 55 42 fe ff       	call   f0100f8b <cprintf>
f011cd36:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cd39:	e8 67 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cd3e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cd41:	74 17                	je     f011cd5a <test_ksbrk+0x57a>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cd43:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd4a:	83 ec 0c             	sub    $0xc,%esp
f011cd4d:	68 38 fe 12 f0       	push   $0xf012fe38
f011cd52:	e8 34 42 fe ff       	call   f0100f8b <cprintf>
f011cd57:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011cd5a:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cd61:	e8 48 1b ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011cd66:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cd69:	e8 37 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cd6e:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011cd71:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cd74:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cd77:	29 c2                	sub    %eax,%edx
f011cd79:	89 d0                	mov    %edx,%eax
f011cd7b:	83 ec 0c             	sub    $0xc,%esp
f011cd7e:	50                   	push   %eax
f011cd7f:	e8 0d c7 fe ff       	call   f0109491 <kmalloc>
f011cd84:	83 c4 10             	add    $0x10,%esp
f011cd87:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011cd8d:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011cd94:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011cd9a:	6a 01                	push   $0x1
f011cd9c:	ff 75 b8             	pushl  -0x48(%ebp)
f011cd9f:	ff 75 ac             	pushl  -0x54(%ebp)
f011cda2:	50                   	push   %eax
f011cda3:	e8 22 3f ff ff       	call   f0110cca <check_block>
f011cda8:	83 c4 10             	add    $0x10,%esp
f011cdab:	85 c0                	test   %eax,%eax
f011cdad:	75 17                	jne    f011cdc6 <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011cdaf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cdb6:	83 ec 0c             	sub    $0xc,%esp
f011cdb9:	68 a6 fe 12 f0       	push   $0xf012fea6
f011cdbe:	e8 c8 41 fe ff       	call   f0100f8b <cprintf>
f011cdc3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cdc6:	e8 e3 1a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011cdcb:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cdce:	74 17                	je     f011cde7 <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011cdd0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cdd7:	83 ec 0c             	sub    $0xc,%esp
f011cdda:	68 c0 fe 12 f0       	push   $0xf012fec0
f011cddf:	e8 a7 41 fe ff       	call   f0100f8b <cprintf>
f011cde4:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cde7:	e8 b9 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cdec:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cdef:	74 17                	je     f011ce08 <test_ksbrk+0x628>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cdf1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cdf8:	83 ec 0c             	sub    $0xc,%esp
f011cdfb:	68 e0 fe 12 f0       	push   $0xf012fee0
f011ce00:	e8 86 41 fe ff       	call   f0100f8b <cprintf>
f011ce05:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011ce08:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011ce0f:	e8 9a 1a ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011ce14:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ce17:	e8 89 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ce1c:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011ce1f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ce22:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ce25:	29 c2                	sub    %eax,%edx
f011ce27:	89 d0                	mov    %edx,%eax
f011ce29:	83 ec 0c             	sub    $0xc,%esp
f011ce2c:	50                   	push   %eax
f011ce2d:	e8 5f c6 fe ff       	call   f0109491 <kmalloc>
f011ce32:	83 c4 10             	add    $0x10,%esp
f011ce35:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011ce3b:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011ce42:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011ce48:	6a 01                	push   $0x1
f011ce4a:	ff 75 b8             	pushl  -0x48(%ebp)
f011ce4d:	ff 75 ac             	pushl  -0x54(%ebp)
f011ce50:	50                   	push   %eax
f011ce51:	e8 74 3e ff ff       	call   f0110cca <check_block>
f011ce56:	83 c4 10             	add    $0x10,%esp
f011ce59:	85 c0                	test   %eax,%eax
f011ce5b:	75 17                	jne    f011ce74 <test_ksbrk+0x694>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011ce5d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce64:	83 ec 0c             	sub    $0xc,%esp
f011ce67:	68 4e ff 12 f0       	push   $0xf012ff4e
f011ce6c:	e8 1a 41 fe ff       	call   f0100f8b <cprintf>
f011ce71:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011ce74:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ce77:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011ce7a:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011ce81:	6a 00                	push   $0x0
f011ce83:	ff 75 98             	pushl  -0x68(%ebp)
f011ce86:	ff 75 ac             	pushl  -0x54(%ebp)
f011ce89:	ff 75 ac             	pushl  -0x54(%ebp)
f011ce8c:	e8 39 3e ff ff       	call   f0110cca <check_block>
f011ce91:	83 c4 10             	add    $0x10,%esp
f011ce94:	85 c0                	test   %eax,%eax
f011ce96:	75 17                	jne    f011ceaf <test_ksbrk+0x6cf>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011ce98:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce9f:	83 ec 0c             	sub    $0xc,%esp
f011cea2:	68 65 ff 12 f0       	push   $0xf012ff65
f011cea7:	e8 df 40 fe ff       	call   f0100f8b <cprintf>
f011ceac:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011ceaf:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ceb2:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011ceb7:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011ceba:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cebd:	8b 00                	mov    (%eax),%eax
f011cebf:	83 f8 01             	cmp    $0x1,%eax
f011cec2:	74 17                	je     f011cedb <test_ksbrk+0x6fb>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011cec4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cecb:	83 ec 0c             	sub    $0xc,%esp
f011cece:	68 7c ff 12 f0       	push   $0xf012ff7c
f011ced3:	e8 b3 40 fe ff       	call   f0100f8b <cprintf>
f011ced8:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011cedb:	83 ec 0c             	sub    $0xc,%esp
f011cede:	6a 00                	push   $0x0
f011cee0:	e8 79 c4 fe ff       	call   f010935e <sbrk>
f011cee5:	83 c4 10             	add    $0x10,%esp
f011cee8:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011ceeb:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ceee:	05 00 20 00 00       	add    $0x2000,%eax
f011cef3:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011cef6:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cef9:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011cefc:	74 1d                	je     f011cf1b <test_ksbrk+0x73b>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011cefe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf05:	83 ec 04             	sub    $0x4,%esp
f011cf08:	ff 75 90             	pushl  -0x70(%ebp)
f011cf0b:	ff 75 8c             	pushl  -0x74(%ebp)
f011cf0e:	68 a8 ff 12 f0       	push   $0xf012ffa8
f011cf13:	e8 73 40 fe ff       	call   f0100f8b <cprintf>
f011cf18:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cf1b:	e8 8e 19 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011cf20:	89 c2                	mov    %eax,%edx
f011cf22:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cf25:	29 d0                	sub    %edx,%eax
f011cf27:	83 f8 01             	cmp    $0x1,%eax
f011cf2a:	74 17                	je     f011cf43 <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011cf2c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf33:	83 ec 0c             	sub    $0xc,%esp
f011cf36:	68 dc ff 12 f0       	push   $0xf012ffdc
f011cf3b:	e8 4b 40 fe ff       	call   f0100f8b <cprintf>
f011cf40:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cf43:	e8 5d 79 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cf48:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cf4b:	74 17                	je     f011cf64 <test_ksbrk+0x784>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cf4d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf54:	83 ec 0c             	sub    $0xc,%esp
f011cf57:	68 fc ff 12 f0       	push   $0xf012fffc
f011cf5c:	e8 2a 40 fe ff       	call   f0100f8b <cprintf>
f011cf61:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011cf64:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cf68:	74 04                	je     f011cf6e <test_ksbrk+0x78e>
		eval += 25;
f011cf6a:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011cf6e:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011cf75:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011cf7b:	bb 38 03 13 f0       	mov    $0xf0130338,%ebx
f011cf80:	ba 05 00 00 00       	mov    $0x5,%edx
f011cf85:	89 c7                	mov    %eax,%edi
f011cf87:	89 de                	mov    %ebx,%esi
f011cf89:	89 d1                	mov    %edx,%ecx
f011cf8b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011cf8d:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011cf93:	bb 4c 03 13 f0       	mov    $0xf013034c,%ebx
f011cf98:	ba 05 00 00 00       	mov    $0x5,%edx
f011cf9d:	89 c7                	mov    %eax,%edi
f011cf9f:	89 de                	mov    %ebx,%esi
f011cfa1:	89 d1                	mov    %edx,%ecx
f011cfa3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011cfa5:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011cfab:	bb 60 03 13 f0       	mov    $0xf0130360,%ebx
f011cfb0:	ba 05 00 00 00       	mov    $0x5,%edx
f011cfb5:	89 c7                	mov    %eax,%edi
f011cfb7:	89 de                	mov    %ebx,%esi
f011cfb9:	89 d1                	mov    %edx,%ecx
f011cfbb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011cfbd:	83 ec 04             	sub    $0x4,%esp
f011cfc0:	68 00 00 00 f8       	push   $0xf8000000
f011cfc5:	68 00 10 00 00       	push   $0x1000
f011cfca:	68 00 00 00 f6       	push   $0xf6000000
f011cfcf:	e8 73 c2 fe ff       	call   f0109247 <initialize_kheap_dynamic_allocator>
f011cfd4:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011cfd7:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011cfde:	eb 1b                	jmp    f011cffb <test_ksbrk+0x81b>
	{
		unmap_frame(ptr_page_directory, va);
f011cfe0:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011cfe5:	83 ec 08             	sub    $0x8,%esp
f011cfe8:	ff 75 dc             	pushl  -0x24(%ebp)
f011cfeb:	50                   	push   %eax
f011cfec:	e8 ee b7 fe ff       	call   f01087df <unmap_frame>
f011cff1:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011cff4:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011cffb:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011d002:	76 dc                	jbe    f011cfe0 <test_ksbrk+0x800>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011d004:	83 ec 0c             	sub    $0xc,%esp
f011d007:	68 6c 00 13 f0       	push   $0xf013006c
f011d00c:	e8 7a 3f fe ff       	call   f0100f8b <cprintf>
f011d011:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d014:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d01b:	e9 21 01 00 00       	jmp    f011d141 <test_ksbrk+0x961>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d020:	e8 89 18 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011d025:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d028:	e8 78 78 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d02d:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d030:	83 ec 0c             	sub    $0xc,%esp
f011d033:	6a 00                	push   $0x0
f011d035:	e8 24 c3 fe ff       	call   f010935e <sbrk>
f011d03a:	83 c4 10             	add    $0x10,%esp
f011d03d:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d040:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d043:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d04a:	83 ec 0c             	sub    $0xc,%esp
f011d04d:	50                   	push   %eax
f011d04e:	e8 0b c3 fe ff       	call   f010935e <sbrk>
f011d053:	83 c4 10             	add    $0x10,%esp
f011d056:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011d059:	83 ec 0c             	sub    $0xc,%esp
f011d05c:	6a 00                	push   $0x0
f011d05e:	e8 fb c2 fe ff       	call   f010935e <sbrk>
f011d063:	83 c4 10             	add    $0x10,%esp
f011d066:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d069:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d070:	e8 30 78 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d075:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d078:	74 1a                	je     f011d094 <test_ksbrk+0x8b4>
			{
				correct = 0;
f011d07a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d081:	83 ec 08             	sub    $0x8,%esp
f011d084:	ff 75 d8             	pushl  -0x28(%ebp)
f011d087:	68 b0 00 13 f0       	push   $0xf01300b0
f011d08c:	e8 fa 3e fe ff       	call   f0100f8b <cprintf>
f011d091:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011d094:	e8 15 18 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011d099:	89 c2                	mov    %eax,%edx
f011d09b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d09e:	29 d0                	sub    %edx,%eax
f011d0a0:	89 c2                	mov    %eax,%edx
f011d0a2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d0a5:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d0ac:	39 c2                	cmp    %eax,%edx
f011d0ae:	74 1a                	je     f011d0ca <test_ksbrk+0x8ea>
			{
				correct = 0;
f011d0b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011d0b7:	83 ec 08             	sub    $0x8,%esp
f011d0ba:	ff 75 d8             	pushl  -0x28(%ebp)
f011d0bd:	68 20 01 13 f0       	push   $0xf0130120
f011d0c2:	e8 c4 3e fe ff       	call   f0100f8b <cprintf>
f011d0c7:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d0ca:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d0cd:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d0d4:	8b 45 80             	mov    -0x80(%ebp),%eax
f011d0d7:	39 c2                	cmp    %eax,%edx
f011d0d9:	74 25                	je     f011d100 <test_ksbrk+0x920>
			{
				correct = 0;
f011d0db:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d0e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d0e5:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d0ec:	ff 75 80             	pushl  -0x80(%ebp)
f011d0ef:	50                   	push   %eax
f011d0f0:	ff 75 d8             	pushl  -0x28(%ebp)
f011d0f3:	68 40 01 13 f0       	push   $0xf0130140
f011d0f8:	e8 8e 3e fe ff       	call   f0100f8b <cprintf>
f011d0fd:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d100:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d103:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d10a:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d10d:	74 25                	je     f011d134 <test_ksbrk+0x954>
			{
				correct = 0;
f011d10f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d116:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d119:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d120:	ff 75 90             	pushl  -0x70(%ebp)
f011d123:	50                   	push   %eax
f011d124:	ff 75 d8             	pushl  -0x28(%ebp)
f011d127:	68 78 01 13 f0       	push   $0xf0130178
f011d12c:	e8 5a 3e fe ff       	call   f0100f8b <cprintf>
f011d131:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d134:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d138:	74 04                	je     f011d13e <test_ksbrk+0x95e>
				eval += 10;
f011d13a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d13e:	ff 45 d8             	incl   -0x28(%ebp)
f011d141:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d144:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d147:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d14a:	39 c2                	cmp    %eax,%edx
f011d14c:	0f 87 ce fe ff ff    	ja     f011d020 <test_ksbrk+0x840>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011d152:	83 ec 0c             	sub    $0xc,%esp
f011d155:	68 ac 01 13 f0       	push   $0xf01301ac
f011d15a:	e8 2c 3e fe ff       	call   f0100f8b <cprintf>
f011d15f:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d162:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d165:	48                   	dec    %eax
f011d166:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011d169:	e9 18 01 00 00       	jmp    f011d286 <test_ksbrk+0xaa6>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d16e:	e8 3b 17 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011d173:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d176:	e8 2a 77 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d17b:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d17e:	83 ec 0c             	sub    $0xc,%esp
f011d181:	6a 00                	push   $0x0
f011d183:	e8 d6 c1 fe ff       	call   f010935e <sbrk>
f011d188:	83 c4 10             	add    $0x10,%esp
f011d18b:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d18e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d191:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d198:	83 ec 0c             	sub    $0xc,%esp
f011d19b:	50                   	push   %eax
f011d19c:	e8 bd c1 fe ff       	call   f010935e <sbrk>
f011d1a1:	83 c4 10             	add    $0x10,%esp
f011d1a4:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011d1aa:	83 ec 0c             	sub    $0xc,%esp
f011d1ad:	6a 00                	push   $0x0
f011d1af:	e8 aa c1 fe ff       	call   f010935e <sbrk>
f011d1b4:	83 c4 10             	add    $0x10,%esp
f011d1b7:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d1ba:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d1c1:	e8 df 76 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d1c6:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d1c9:	74 1a                	je     f011d1e5 <test_ksbrk+0xa05>
			{
				correct = 0;
f011d1cb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d1d2:	83 ec 08             	sub    $0x8,%esp
f011d1d5:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d1d8:	68 fc 01 13 f0       	push   $0xf01301fc
f011d1dd:	e8 a9 3d fe ff       	call   f0100f8b <cprintf>
f011d1e2:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d1e5:	e8 c4 16 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011d1ea:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d1ed:	74 1a                	je     f011d209 <test_ksbrk+0xa29>
			{
				correct = 0;
f011d1ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011d1f6:	83 ec 08             	sub    $0x8,%esp
f011d1f9:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d1fc:	68 6c 02 13 f0       	push   $0xf013026c
f011d201:	e8 85 3d fe ff       	call   f0100f8b <cprintf>
f011d206:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d209:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d20c:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d213:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d219:	39 c2                	cmp    %eax,%edx
f011d21b:	74 28                	je     f011d245 <test_ksbrk+0xa65>
			{
				correct = 0;
f011d21d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d224:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d227:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d22e:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011d234:	50                   	push   %eax
f011d235:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d238:	68 8c 02 13 f0       	push   $0xf013028c
f011d23d:	e8 49 3d fe ff       	call   f0100f8b <cprintf>
f011d242:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d245:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d248:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d24f:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d252:	74 25                	je     f011d279 <test_ksbrk+0xa99>
			{
				correct = 0;
f011d254:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d25b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d25e:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d265:	ff 75 90             	pushl  -0x70(%ebp)
f011d268:	50                   	push   %eax
f011d269:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d26c:	68 c4 02 13 f0       	push   $0xf01302c4
f011d271:	e8 15 3d fe ff       	call   f0100f8b <cprintf>
f011d276:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d279:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d27d:	74 04                	je     f011d283 <test_ksbrk+0xaa3>
				eval += 10;
f011d27f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d283:	ff 45 d4             	incl   -0x2c(%ebp)
f011d286:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d289:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011d28c:	0f 82 dc fe ff ff    	jb     f011d16e <test_ksbrk+0x98e>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011d292:	83 ec 08             	sub    $0x8,%esp
f011d295:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d298:	68 f8 02 13 f0       	push   $0xf01302f8
f011d29d:	e8 e9 3c fe ff       	call   f0100f8b <cprintf>
f011d2a2:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011d2a5:	83 ec 0c             	sub    $0xc,%esp
f011d2a8:	68 22 03 13 f0       	push   $0xf0130322
f011d2ad:	e8 d9 3c fe ff       	call   f0100f8b <cprintf>
f011d2b2:	83 c4 10             	add    $0x10,%esp
	return 0;
f011d2b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011d2ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d2bd:	5b                   	pop    %ebx
f011d2be:	5e                   	pop    %esi
f011d2bf:	5f                   	pop    %edi
f011d2c0:	5d                   	pop    %ebp
f011d2c1:	c3                   	ret    

f011d2c2 <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011d2c2:	55                   	push   %ebp
f011d2c3:	89 e5                	mov    %esp,%ebp
f011d2c5:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d2c8:	83 ec 04             	sub    $0x4,%esp
f011d2cb:	68 74 03 13 f0       	push   $0xf0130374
f011d2d0:	68 c2 08 00 00       	push   $0x8c2
f011d2d5:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d2da:	e8 5a 30 fe ff       	call   f0100339 <_panic>

f011d2df <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011d2df:	55                   	push   %ebp
f011d2e0:	89 e5                	mov    %esp,%ebp
f011d2e2:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d2e5:	83 ec 04             	sub    $0x4,%esp
f011d2e8:	68 74 03 13 f0       	push   $0xf0130374
f011d2ed:	68 c7 08 00 00       	push   $0x8c7
f011d2f2:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d2f7:	e8 3d 30 fe ff       	call   f0100339 <_panic>

f011d2fc <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011d2fc:	55                   	push   %ebp
f011d2fd:	89 e5                	mov    %esp,%ebp
f011d2ff:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d302:	83 ec 04             	sub    $0x4,%esp
f011d305:	68 74 03 13 f0       	push   $0xf0130374
f011d30a:	68 cc 08 00 00       	push   $0x8cc
f011d30f:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d314:	e8 20 30 fe ff       	call   f0100339 <_panic>

f011d319 <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011d319:	55                   	push   %ebp
f011d31a:	89 e5                	mov    %esp,%ebp
f011d31c:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d31f:	83 ec 04             	sub    $0x4,%esp
f011d322:	68 74 03 13 f0       	push   $0xf0130374
f011d327:	68 d1 08 00 00       	push   $0x8d1
f011d32c:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d331:	e8 03 30 fe ff       	call   f0100339 <_panic>

f011d336 <test_kfree>:
}

int test_kfree()
{
f011d336:	55                   	push   %ebp
f011d337:	89 e5                	mov    %esp,%ebp
f011d339:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d33c:	83 ec 04             	sub    $0x4,%esp
f011d33f:	68 74 03 13 f0       	push   $0xf0130374
f011d344:	68 d6 08 00 00       	push   $0x8d6
f011d349:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d34e:	e8 e6 2f fe ff       	call   f0100339 <_panic>

f011d353 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011d353:	55                   	push   %ebp
f011d354:	89 e5                	mov    %esp,%ebp
f011d356:	57                   	push   %edi
f011d357:	56                   	push   %esi
f011d358:	53                   	push   %ebx
f011d359:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011d35f:	a0 dc fd 17 f0       	mov    0xf017fddc,%al
f011d364:	84 c0                	test   %al,%al
f011d366:	74 56                	je     f011d3be <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011d368:	c6 05 dc fd 17 f0 00 	movb   $0x0,0xf017fddc
		initFreeFrames = sys_calculate_free_frames() ;
f011d36f:	e8 3a 15 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011d374:	a3 c8 b4 b0 f0       	mov    %eax,0xf0b0b4c8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011d379:	e8 27 75 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d37e:	a3 c4 b4 b0 f0       	mov    %eax,0xf0b0b4c4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011d383:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d389:	bb d9 04 13 f0       	mov    $0xf01304d9,%ebx
f011d38e:	ba 11 00 00 00       	mov    $0x11,%edx
f011d393:	89 c7                	mov    %eax,%edi
f011d395:	89 de                	mov    %ebx,%esi
f011d397:	89 d1                	mov    %edx,%ecx
f011d399:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011d39b:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011d3a1:	b9 53 00 00 00       	mov    $0x53,%ecx
f011d3a6:	b0 00                	mov    $0x0,%al
f011d3a8:	89 d7                	mov    %edx,%edi
f011d3aa:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011d3ac:	83 ec 0c             	sub    $0xc,%esp
f011d3af:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d3b5:	50                   	push   %eax
f011d3b6:	e8 40 4b fe ff       	call   f0101efb <execute_command>
f011d3bb:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011d3be:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011d3c5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d3cc:	a1 60 06 6c f0       	mov    0xf06c0660,%eax
f011d3d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d3d4:	eb 2b                	jmp    f011d401 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011d3d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d3d9:	83 c0 20             	add    $0x20,%eax
f011d3dc:	83 ec 08             	sub    $0x8,%esp
f011d3df:	68 84 03 13 f0       	push   $0xf0130384
f011d3e4:	50                   	push   %eax
f011d3e5:	e8 ea 28 00 00       	call   f011fcd4 <strcmp>
f011d3ea:	83 c4 10             	add    $0x10,%esp
f011d3ed:	85 c0                	test   %eax,%eax
f011d3ef:	75 08                	jne    f011d3f9 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011d3f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d3f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011d3f7:	eb 2f                	jmp    f011d428 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d3f9:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f011d3fe:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d401:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d405:	74 08                	je     f011d40f <test_three_creation_functions+0xbc>
f011d407:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d40a:	8b 40 08             	mov    0x8(%eax),%eax
f011d40d:	eb 05                	jmp    f011d414 <test_three_creation_functions+0xc1>
f011d40f:	b8 00 00 00 00       	mov    $0x0,%eax
f011d414:	a3 68 06 6c f0       	mov    %eax,0xf06c0668
f011d419:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f011d41e:	85 c0                	test   %eax,%eax
f011d420:	75 b4                	jne    f011d3d6 <test_three_creation_functions+0x83>
f011d422:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d426:	75 ae                	jne    f011d3d6 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011d428:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d42b:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f011d431:	85 c0                	test   %eax,%eax
f011d433:	74 17                	je     f011d44c <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011d435:	83 ec 04             	sub    $0x4,%esp
f011d438:	68 8c 03 13 f0       	push   $0xf013038c
f011d43d:	68 f7 08 00 00       	push   $0x8f7
f011d442:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d447:	e8 ed 2e fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011d44c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d44f:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011d455:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011d458:	e8 51 14 ff ff       	call   f010e8ae <sys_calculate_free_frames>
f011d45d:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011d460:	e8 40 74 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d465:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d468:	a1 c4 b4 b0 f0       	mov    0xf0b0b4c4,%eax
f011d46d:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011d470:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d473:	74 17                	je     f011d48c <test_three_creation_functions+0x139>
f011d475:	83 ec 04             	sub    $0x4,%esp
f011d478:	68 cc cd 12 f0       	push   $0xf012cdcc
f011d47d:	68 01 09 00 00       	push   $0x901
f011d482:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d487:	e8 ad 2e fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011d48c:	a1 c8 b4 b0 f0       	mov    0xf0b0b4c8,%eax
f011d491:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011d494:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d497:	83 c2 15             	add    $0x15,%edx
f011d49a:	39 d0                	cmp    %edx,%eax
f011d49c:	74 17                	je     f011d4b5 <test_three_creation_functions+0x162>
f011d49e:	83 ec 04             	sub    $0x4,%esp
f011d4a1:	68 dc 03 13 f0       	push   $0xf01303dc
f011d4a6:	68 03 09 00 00       	push   $0x903
f011d4ab:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d4b0:	e8 84 2e fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011d4b5:	83 ec 0c             	sub    $0xc,%esp
f011d4b8:	68 00 10 00 00       	push   $0x1000
f011d4bd:	e8 cf bf fe ff       	call   f0109491 <kmalloc>
f011d4c2:	83 c4 10             	add    $0x10,%esp
f011d4c5:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011d4c8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d4cb:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011d4d0:	74 17                	je     f011d4e9 <test_three_creation_functions+0x196>
f011d4d2:	83 ec 04             	sub    $0x4,%esp
f011d4d5:	68 1c 04 13 f0       	push   $0xf013041c
f011d4da:	68 07 09 00 00       	push   $0x907
f011d4df:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d4e4:	e8 50 2e fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011d4e9:	83 ec 0c             	sub    $0xc,%esp
f011d4ec:	68 8c 04 13 f0       	push   $0xf013048c
f011d4f1:	e8 95 3a fe ff       	call   f0100f8b <cprintf>
f011d4f6:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d4f9:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011d4fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d501:	5b                   	pop    %ebx
f011d502:	5e                   	pop    %esi
f011d503:	5f                   	pop    %edi
f011d504:	5d                   	pop    %ebp
f011d505:	c3                   	ret    

f011d506 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011d506:	55                   	push   %ebp
f011d507:	89 e5                	mov    %esp,%ebp
f011d509:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d50c:	83 ec 04             	sub    $0x4,%esp
f011d50f:	68 74 03 13 f0       	push   $0xf0130374
f011d514:	68 15 09 00 00       	push   $0x915
f011d519:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d51e:	e8 16 2e fe ff       	call   f0100339 <_panic>

f011d523 <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011d523:	55                   	push   %ebp
f011d524:	89 e5                	mov    %esp,%ebp
f011d526:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d529:	83 ec 04             	sub    $0x4,%esp
f011d52c:	68 74 03 13 f0       	push   $0xf0130374
f011d531:	68 1d 09 00 00       	push   $0x91d
f011d536:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d53b:	e8 f9 2d fe ff       	call   f0100339 <_panic>

f011d540 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011d540:	55                   	push   %ebp
f011d541:	89 e5                	mov    %esp,%ebp
f011d543:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d546:	83 ec 04             	sub    $0x4,%esp
f011d549:	68 74 03 13 f0       	push   $0xf0130374
f011d54e:	68 24 09 00 00       	push   $0x924
f011d553:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d558:	e8 dc 2d fe ff       	call   f0100339 <_panic>

f011d55d <test_kfreelast>:

}


int test_kfreelast()
{
f011d55d:	55                   	push   %ebp
f011d55e:	89 e5                	mov    %esp,%ebp
f011d560:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d563:	83 ec 04             	sub    $0x4,%esp
f011d566:	68 74 03 13 f0       	push   $0xf0130374
f011d56b:	68 2b 09 00 00       	push   $0x92b
f011d570:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d575:	e8 bf 2d fe ff       	call   f0100339 <_panic>

f011d57a <test_krealloc>:

}

int test_krealloc() {
f011d57a:	55                   	push   %ebp
f011d57b:	89 e5                	mov    %esp,%ebp
f011d57d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d580:	83 ec 04             	sub    $0x4,%esp
f011d583:	68 74 03 13 f0       	push   $0xf0130374
f011d588:	68 30 09 00 00       	push   $0x930
f011d58d:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d592:	e8 a2 2d fe ff       	call   f0100339 <_panic>

f011d597 <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011d597:	55                   	push   %ebp
f011d598:	89 e5                	mov    %esp,%ebp
f011d59a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d59d:	83 ec 04             	sub    $0x4,%esp
f011d5a0:	68 74 03 13 f0       	push   $0xf0130374
f011d5a5:	68 35 09 00 00       	push   $0x935
f011d5aa:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d5af:	e8 85 2d fe ff       	call   f0100339 <_panic>

f011d5b4 <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011d5b4:	55                   	push   %ebp
f011d5b5:	89 e5                	mov    %esp,%ebp
f011d5b7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d5ba:	83 ec 04             	sub    $0x4,%esp
f011d5bd:	68 74 03 13 f0       	push   $0xf0130374
f011d5c2:	68 3b 09 00 00       	push   $0x93b
f011d5c7:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d5cc:	e8 68 2d fe ff       	call   f0100339 <_panic>

f011d5d1 <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011d5d1:	55                   	push   %ebp
f011d5d2:	89 e5                	mov    %esp,%ebp
f011d5d4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d5d7:	83 ec 04             	sub    $0x4,%esp
f011d5da:	68 74 03 13 f0       	push   $0xf0130374
f011d5df:	68 40 09 00 00       	push   $0x940
f011d5e4:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d5e9:	e8 4b 2d fe ff       	call   f0100339 <_panic>

f011d5ee <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011d5ee:	55                   	push   %ebp
f011d5ef:	89 e5                	mov    %esp,%ebp
f011d5f1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d5f4:	83 ec 04             	sub    $0x4,%esp
f011d5f7:	68 74 03 13 f0       	push   $0xf0130374
f011d5fc:	68 46 09 00 00       	push   $0x946
f011d601:	68 b3 cd 12 f0       	push   $0xf012cdb3
f011d606:	e8 2e 2d fe ff       	call   f0100339 <_panic>

f011d60b <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011d60b:	55                   	push   %ebp
f011d60c:	89 e5                	mov    %esp,%ebp
f011d60e:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d611:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d618:	e9 84 00 00 00       	jmp    f011d6a1 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011d61d:	83 ec 08             	sub    $0x8,%esp
f011d620:	ff 75 f4             	pushl  -0xc(%ebp)
f011d623:	68 40 05 13 f0       	push   $0xf0130540
f011d628:	e8 5e 39 fe ff       	call   f0100f8b <cprintf>
f011d62d:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d630:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011d637:	eb 4c                	jmp    f011d685 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011d639:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d63c:	89 d0                	mov    %edx,%eax
f011d63e:	c1 e0 02             	shl    $0x2,%eax
f011d641:	01 d0                	add    %edx,%eax
f011d643:	c1 e0 03             	shl    $0x3,%eax
f011d646:	89 c2                	mov    %eax,%edx
f011d648:	8b 45 08             	mov    0x8(%ebp),%eax
f011d64b:	01 c2                	add    %eax,%edx
f011d64d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d650:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d653:	85 c0                	test   %eax,%eax
f011d655:	74 36                	je     f011d68d <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011d657:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d65a:	89 d0                	mov    %edx,%eax
f011d65c:	c1 e0 02             	shl    $0x2,%eax
f011d65f:	01 d0                	add    %edx,%eax
f011d661:	c1 e0 03             	shl    $0x3,%eax
f011d664:	89 c2                	mov    %eax,%edx
f011d666:	8b 45 08             	mov    0x8(%ebp),%eax
f011d669:	01 c2                	add    %eax,%edx
f011d66b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d66e:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d671:	83 ec 08             	sub    $0x8,%esp
f011d674:	50                   	push   %eax
f011d675:	68 48 05 13 f0       	push   $0xf0130548
f011d67a:	e8 0c 39 fe ff       	call   f0100f8b <cprintf>
f011d67f:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d682:	ff 45 f0             	incl   -0x10(%ebp)
f011d685:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011d689:	7e ae                	jle    f011d639 <print_order+0x2e>
f011d68b:	eb 01                	jmp    f011d68e <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011d68d:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011d68e:	83 ec 0c             	sub    $0xc,%esp
f011d691:	68 4d 05 13 f0       	push   $0xf013054d
f011d696:	e8 f0 38 fe ff       	call   f0100f8b <cprintf>
f011d69b:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d69e:	ff 45 f4             	incl   -0xc(%ebp)
f011d6a1:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011d6a5:	0f 8e 72 ff ff ff    	jle    f011d61d <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011d6ab:	90                   	nop
f011d6ac:	c9                   	leave  
f011d6ad:	c3                   	ret    

f011d6ae <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011d6ae:	55                   	push   %ebp
f011d6af:	89 e5                	mov    %esp,%ebp
f011d6b1:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011d6b4:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011d6bb:	83 ec 0c             	sub    $0xc,%esp
f011d6be:	68 e0 05 6c f0       	push   $0xf06c05e0
f011d6c3:	e8 52 25 ff ff       	call   f010fc1a <acquire_spinlock>
f011d6c8:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011d6cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011d6d2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d6d9:	8b 55 0c             	mov    0xc(%ebp),%edx
f011d6dc:	8b 45 10             	mov    0x10(%ebp),%eax
f011d6df:	01 d0                	add    %edx,%eax
f011d6e1:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d6e4:	a1 6c 06 6c f0       	mov    0xf06c066c,%eax
f011d6e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d6ec:	a1 64 06 6c f0       	mov    0xf06c0664,%eax
f011d6f1:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011d6f4:	ff 75 e8             	pushl  -0x18(%ebp)
f011d6f7:	ff 75 0c             	pushl  0xc(%ebp)
f011d6fa:	ff 75 08             	pushl  0x8(%ebp)
f011d6fd:	68 50 05 13 f0       	push   $0xf0130550
f011d702:	e8 84 38 fe ff       	call   f0100f8b <cprintf>
f011d707:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d70a:	eb 34                	jmp    f011d740 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011d70c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d70f:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d712:	7d 05                	jge    f011d719 <find_in_range+0x6b>
			{
				i++;
f011d714:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011d717:	eb 1e                	jmp    f011d737 <find_in_range+0x89>
			}
			if (i >= end)
f011d719:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d71c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011d71f:	7d 29                	jge    f011d74a <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011d721:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d724:	8b 40 10             	mov    0x10(%eax),%eax
f011d727:	3b 45 08             	cmp    0x8(%ebp),%eax
f011d72a:	75 08                	jne    f011d734 <find_in_range+0x86>
			{
				ret = i;
f011d72c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d72f:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011d732:	eb 17                	jmp    f011d74b <find_in_range+0x9d>
			}
			i++;
f011d734:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d737:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d73a:	8b 40 0c             	mov    0xc(%eax),%eax
f011d73d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011d740:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d743:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011d746:	7c c4                	jl     f011d70c <find_in_range+0x5e>
f011d748:	eb 01                	jmp    f011d74b <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011d74a:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011d74b:	83 ec 0c             	sub    $0xc,%esp
f011d74e:	68 e0 05 6c f0       	push   $0xf06c05e0
f011d753:	e8 49 25 ff ff       	call   f010fca1 <release_spinlock>
f011d758:	83 c4 10             	add    $0x10,%esp
	return ret;
f011d75b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011d75e:	c9                   	leave  
f011d75f:	c3                   	ret    

f011d760 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011d760:	55                   	push   %ebp
f011d761:	89 e5                	mov    %esp,%ebp
f011d763:	57                   	push   %edi
f011d764:	56                   	push   %esi
f011d765:	53                   	push   %ebx
f011d766:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011d769:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011d76e:	84 c0                	test   %al,%al
f011d770:	0f 84 9b 01 00 00    	je     f011d911 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011d776:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f011d77d:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d780:	bb c8 06 13 f0       	mov    $0xf01306c8,%ebx
f011d785:	ba 05 00 00 00       	mov    $0x5,%edx
f011d78a:	89 c7                	mov    %eax,%edi
f011d78c:	89 de                	mov    %ebx,%esi
f011d78e:	89 d1                	mov    %edx,%ecx
f011d790:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d792:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d799:	e9 44 01 00 00       	jmp    f011d8e2 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011d79e:	6a 00                	push   $0x0
f011d7a0:	6a 00                	push   $0x0
f011d7a2:	68 f4 01 00 00       	push   $0x1f4
f011d7a7:	68 81 05 13 f0       	push   $0xf0130581
f011d7ac:	e8 5c d7 fe ff       	call   f010af0d <env_create>
f011d7b1:	83 c4 10             	add    $0x10,%esp
f011d7b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011d7b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d7ba:	b9 05 00 00 00       	mov    $0x5,%ecx
f011d7bf:	99                   	cltd   
f011d7c0:	f7 f9                	idiv   %ecx
f011d7c2:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011d7c5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d7c8:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d7cc:	83 ec 08             	sub    $0x8,%esp
f011d7cf:	50                   	push   %eax
f011d7d0:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d7d3:	e8 ae 8e fe ff       	call   f0106686 <env_set_nice>
f011d7d8:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011d7db:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d7df:	75 14                	jne    f011d7f5 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011d7e1:	83 ec 04             	sub    $0x4,%esp
f011d7e4:	68 89 05 13 f0       	push   $0xf0130589
f011d7e9:	6a 53                	push   $0x53
f011d7eb:	68 a2 05 13 f0       	push   $0xf01305a2
f011d7f0:	e8 44 2b fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011d7f5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d7f8:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d7fe:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d803:	74 14                	je     f011d819 <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011d805:	83 ec 04             	sub    $0x4,%esp
f011d808:	68 c0 05 13 f0       	push   $0xf01305c0
f011d80d:	6a 55                	push   $0x55
f011d80f:	68 a2 05 13 f0       	push   $0xf01305a2
f011d814:	e8 20 2b fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011d819:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d81c:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d820:	83 c0 0a             	add    $0xa,%eax
f011d823:	83 f8 14             	cmp    $0x14,%eax
f011d826:	0f 87 a5 00 00 00    	ja     f011d8d1 <test_bsd_nice_0+0x171>
f011d82c:	8b 04 85 dc 06 13 f0 	mov    -0xfecf924(,%eax,4),%eax
f011d833:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011d835:	a1 7c 03 6c f0       	mov    0xf06c037c,%eax
f011d83a:	8d 50 01             	lea    0x1(%eax),%edx
f011d83d:	89 15 7c 03 6c f0    	mov    %edx,0xf06c037c
f011d843:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d846:	8b 52 10             	mov    0x10(%edx),%edx
f011d849:	89 14 85 e0 b4 b0 f0 	mov    %edx,-0xf4f4b20(,%eax,4)
				break;
f011d850:	eb 7f                	jmp    f011d8d1 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011d852:	a1 80 03 6c f0       	mov    0xf06c0380,%eax
f011d857:	8d 50 01             	lea    0x1(%eax),%edx
f011d85a:	89 15 80 03 6c f0    	mov    %edx,0xf06c0380
f011d860:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d863:	8b 52 10             	mov    0x10(%edx),%edx
f011d866:	83 c0 0a             	add    $0xa,%eax
f011d869:	89 14 85 e0 b4 b0 f0 	mov    %edx,-0xf4f4b20(,%eax,4)
				break;
f011d870:	eb 5f                	jmp    f011d8d1 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011d872:	a1 84 03 6c f0       	mov    0xf06c0384,%eax
f011d877:	8d 50 01             	lea    0x1(%eax),%edx
f011d87a:	89 15 84 03 6c f0    	mov    %edx,0xf06c0384
f011d880:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d883:	8b 52 10             	mov    0x10(%edx),%edx
f011d886:	83 c0 14             	add    $0x14,%eax
f011d889:	89 14 85 e0 b4 b0 f0 	mov    %edx,-0xf4f4b20(,%eax,4)
				break;
f011d890:	eb 3f                	jmp    f011d8d1 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011d892:	a1 88 03 6c f0       	mov    0xf06c0388,%eax
f011d897:	8d 50 01             	lea    0x1(%eax),%edx
f011d89a:	89 15 88 03 6c f0    	mov    %edx,0xf06c0388
f011d8a0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d8a3:	8b 52 10             	mov    0x10(%edx),%edx
f011d8a6:	83 c0 1e             	add    $0x1e,%eax
f011d8a9:	89 14 85 e0 b4 b0 f0 	mov    %edx,-0xf4f4b20(,%eax,4)
				break;
f011d8b0:	eb 1f                	jmp    f011d8d1 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011d8b2:	a1 8c 03 6c f0       	mov    0xf06c038c,%eax
f011d8b7:	8d 50 01             	lea    0x1(%eax),%edx
f011d8ba:	89 15 8c 03 6c f0    	mov    %edx,0xf06c038c
f011d8c0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d8c3:	8b 52 10             	mov    0x10(%edx),%edx
f011d8c6:	83 c0 28             	add    $0x28,%eax
f011d8c9:	89 14 85 e0 b4 b0 f0 	mov    %edx,-0xf4f4b20(,%eax,4)
				break;
f011d8d0:	90                   	nop
			}
			sched_new_env(env);
f011d8d1:	83 ec 0c             	sub    $0xc,%esp
f011d8d4:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d8d7:	e8 40 7e fe ff       	call   f010571c <sched_new_env>
f011d8dc:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d8df:	ff 45 e4             	incl   -0x1c(%ebp)
f011d8e2:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011d8e6:	0f 8e b2 fe ff ff    	jle    f011d79e <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d8ec:	83 ec 0c             	sub    $0xc,%esp
f011d8ef:	68 f0 05 13 f0       	push   $0xf01305f0
f011d8f4:	e8 92 36 fe ff       	call   f0100f8b <cprintf>
f011d8f9:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d8fc:	83 ec 0c             	sub    $0xc,%esp
f011d8ff:	68 3f 06 13 f0       	push   $0xf013063f
f011d904:	e8 f2 45 fe ff       	call   f0101efb <execute_command>
f011d909:	83 c4 10             	add    $0x10,%esp
f011d90c:	e9 c0 00 00 00       	jmp    f011d9d1 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011d911:	83 ec 0c             	sub    $0xc,%esp
f011d914:	68 46 06 13 f0       	push   $0xf0130646
f011d919:	e8 6d 36 fe ff       	call   f0100f8b <cprintf>
f011d91e:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d921:	e8 2e 85 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011d926:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d92d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011d934:	e9 87 00 00 00       	jmp    f011d9c0 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d939:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d940:	eb 52                	jmp    f011d994 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011d942:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d945:	8b 14 85 7c 03 6c f0 	mov    -0xf93fc84(,%eax,4),%edx
f011d94c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011d94f:	89 c8                	mov    %ecx,%eax
f011d951:	c1 e0 02             	shl    $0x2,%eax
f011d954:	01 c8                	add    %ecx,%eax
f011d956:	01 c0                	add    %eax,%eax
f011d958:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011d95b:	01 c8                	add    %ecx,%eax
f011d95d:	8b 04 85 e0 b4 b0 f0 	mov    -0xf4f4b20(,%eax,4),%eax
f011d964:	83 ec 04             	sub    $0x4,%esp
f011d967:	52                   	push   %edx
f011d968:	ff 75 e0             	pushl  -0x20(%ebp)
f011d96b:	50                   	push   %eax
f011d96c:	e8 3d fd ff ff       	call   f011d6ae <find_in_range>
f011d971:	83 c4 10             	add    $0x10,%esp
f011d974:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011d977:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011d97b:	75 14                	jne    f011d991 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011d97d:	83 ec 04             	sub    $0x4,%esp
f011d980:	68 58 06 13 f0       	push   $0xf0130658
f011d985:	6a 7b                	push   $0x7b
f011d987:	68 a2 05 13 f0       	push   $0xf01305a2
f011d98c:	e8 a8 29 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d991:	ff 45 d8             	incl   -0x28(%ebp)
f011d994:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d997:	89 d0                	mov    %edx,%eax
f011d999:	c1 e0 02             	shl    $0x2,%eax
f011d99c:	01 d0                	add    %edx,%eax
f011d99e:	01 c0                	add    %eax,%eax
f011d9a0:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011d9a3:	01 d0                	add    %edx,%eax
f011d9a5:	8b 04 85 e0 b4 b0 f0 	mov    -0xf4f4b20(,%eax,4),%eax
f011d9ac:	85 c0                	test   %eax,%eax
f011d9ae:	75 92                	jne    f011d942 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011d9b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d9b3:	8b 04 85 7c 03 6c f0 	mov    -0xf93fc84(,%eax,4),%eax
f011d9ba:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d9bd:	ff 45 dc             	incl   -0x24(%ebp)
f011d9c0:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011d9c4:	0f 8e 6f ff ff ff    	jle    f011d939 <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011d9ca:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011d9d1:	83 ec 0c             	sub    $0xc,%esp
f011d9d4:	68 8c 06 13 f0       	push   $0xf013068c
f011d9d9:	e8 ad 35 fe ff       	call   f0100f8b <cprintf>
f011d9de:	83 c4 10             	add    $0x10,%esp
}
f011d9e1:	90                   	nop
f011d9e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d9e5:	5b                   	pop    %ebx
f011d9e6:	5e                   	pop    %esi
f011d9e7:	5f                   	pop    %edi
f011d9e8:	5d                   	pop    %ebp
f011d9e9:	c3                   	ret    

f011d9ea <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011d9ea:	55                   	push   %ebp
f011d9eb:	89 e5                	mov    %esp,%ebp
f011d9ed:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011d9f0:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011d9f5:	84 c0                	test   %al,%al
f011d9f7:	0f 84 50 01 00 00    	je     f011db4d <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011d9fd:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011da04:	6a 00                	push   $0x0
f011da06:	6a 00                	push   $0x0
f011da08:	68 f4 01 00 00       	push   $0x1f4
f011da0d:	68 81 05 13 f0       	push   $0xf0130581
f011da12:	e8 f6 d4 fe ff       	call   f010af0d <env_create>
f011da17:	83 c4 10             	add    $0x10,%esp
f011da1a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011da1d:	6a 00                	push   $0x0
f011da1f:	6a 00                	push   $0x0
f011da21:	68 f4 01 00 00       	push   $0x1f4
f011da26:	68 30 07 13 f0       	push   $0xf0130730
f011da2b:	e8 dd d4 fe ff       	call   f010af0d <env_create>
f011da30:	83 c4 10             	add    $0x10,%esp
f011da33:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011da36:	6a 00                	push   $0x0
f011da38:	6a 00                	push   $0x0
f011da3a:	68 f4 01 00 00       	push   $0x1f4
f011da3f:	68 3d 07 13 f0       	push   $0xf013073d
f011da44:	e8 c4 d4 fe ff       	call   f010af0d <env_create>
f011da49:	83 c4 10             	add    $0x10,%esp
f011da4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011da4f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011da53:	74 0c                	je     f011da61 <test_bsd_nice_1+0x77>
f011da55:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011da59:	74 06                	je     f011da61 <test_bsd_nice_1+0x77>
f011da5b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011da5f:	75 17                	jne    f011da78 <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011da61:	83 ec 04             	sub    $0x4,%esp
f011da64:	68 89 05 13 f0       	push   $0xf0130589
f011da69:	68 8e 00 00 00       	push   $0x8e
f011da6e:	68 a2 05 13 f0       	push   $0xf01305a2
f011da73:	e8 c1 28 fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011da78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011da7b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011da81:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011da86:	75 20                	jne    f011daa8 <test_bsd_nice_1+0xbe>
f011da88:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011da8b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011da91:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011da96:	75 10                	jne    f011daa8 <test_bsd_nice_1+0xbe>
f011da98:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011da9b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011daa1:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011daa6:	74 35                	je     f011dadd <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011daa8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011daab:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011dab1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dab4:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
f011daba:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011dabd:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dac3:	83 ec 08             	sub    $0x8,%esp
f011dac6:	51                   	push   %ecx
f011dac7:	52                   	push   %edx
f011dac8:	50                   	push   %eax
f011dac9:	68 4c 07 13 f0       	push   $0xf013074c
f011dace:	68 90 00 00 00       	push   $0x90
f011dad3:	68 a2 05 13 f0       	push   $0xf01305a2
f011dad8:	e8 5c 28 fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011dadd:	83 ec 0c             	sub    $0xc,%esp
f011dae0:	ff 75 ec             	pushl  -0x14(%ebp)
f011dae3:	e8 34 7c fe ff       	call   f010571c <sched_new_env>
f011dae8:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011daeb:	83 ec 0c             	sub    $0xc,%esp
f011daee:	ff 75 e8             	pushl  -0x18(%ebp)
f011daf1:	e8 26 7c fe ff       	call   f010571c <sched_new_env>
f011daf6:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011daf9:	83 ec 0c             	sub    $0xc,%esp
f011dafc:	ff 75 e4             	pushl  -0x1c(%ebp)
f011daff:	e8 18 7c fe ff       	call   f010571c <sched_new_env>
f011db04:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011db07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011db0a:	8b 40 10             	mov    0x10(%eax),%eax
f011db0d:	a3 e0 b4 b0 f0       	mov    %eax,0xf0b0b4e0
		prog_orders[1][0] = fibEnv->env_id;
f011db12:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011db15:	8b 40 10             	mov    0x10(%eax),%eax
f011db18:	a3 08 b5 b0 f0       	mov    %eax,0xf0b0b508
		prog_orders[2][0] = fibposnEnv->env_id;
f011db1d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011db20:	8b 40 10             	mov    0x10(%eax),%eax
f011db23:	a3 30 b5 b0 f0       	mov    %eax,0xf0b0b530
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011db28:	83 ec 0c             	sub    $0xc,%esp
f011db2b:	68 f0 05 13 f0       	push   $0xf01305f0
f011db30:	e8 56 34 fe ff       	call   f0100f8b <cprintf>
f011db35:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011db38:	83 ec 0c             	sub    $0xc,%esp
f011db3b:	68 3f 06 13 f0       	push   $0xf013063f
f011db40:	e8 b6 43 fe ff       	call   f0101efb <execute_command>
f011db45:	83 c4 10             	add    $0x10,%esp
f011db48:	e9 9e 00 00 00       	jmp    f011dbeb <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011db4d:	83 ec 0c             	sub    $0xc,%esp
f011db50:	68 46 06 13 f0       	push   $0xf0130646
f011db55:	e8 31 34 fe ff       	call   f0100f8b <cprintf>
f011db5a:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011db5d:	e8 f2 82 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011db62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011db69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011db70:	83 ec 0c             	sub    $0xc,%esp
f011db73:	68 e0 05 6c f0       	push   $0xf06c05e0
f011db78:	e8 9d 20 ff ff       	call   f010fc1a <acquire_spinlock>
f011db7d:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011db80:	a1 6c 06 6c f0       	mov    0xf06c066c,%eax
f011db85:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011db88:	a1 64 06 6c f0       	mov    0xf06c0664,%eax
f011db8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011db90:	eb 41                	jmp    f011dbd3 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011db92:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011db95:	89 d0                	mov    %edx,%eax
f011db97:	c1 e0 02             	shl    $0x2,%eax
f011db9a:	01 d0                	add    %edx,%eax
f011db9c:	c1 e0 03             	shl    $0x3,%eax
f011db9f:	05 e0 b4 b0 f0       	add    $0xf0b0b4e0,%eax
f011dba4:	8b 10                	mov    (%eax),%edx
f011dba6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dba9:	8b 40 10             	mov    0x10(%eax),%eax
f011dbac:	39 c2                	cmp    %eax,%edx
f011dbae:	74 17                	je     f011dbc7 <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011dbb0:	83 ec 04             	sub    $0x4,%esp
f011dbb3:	68 58 06 13 f0       	push   $0xf0130658
f011dbb8:	68 ab 00 00 00       	push   $0xab
f011dbbd:	68 a2 05 13 f0       	push   $0xf01305a2
f011dbc2:	e8 72 27 fe ff       	call   f0100339 <_panic>
				i++;
f011dbc7:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011dbca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dbcd:	8b 40 0c             	mov    0xc(%eax),%eax
f011dbd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011dbd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dbd6:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011dbd9:	7c b7                	jl     f011db92 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011dbdb:	83 ec 0c             	sub    $0xc,%esp
f011dbde:	68 e0 05 6c f0       	push   $0xf06c05e0
f011dbe3:	e8 b9 20 ff ff       	call   f010fca1 <release_spinlock>
f011dbe8:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011dbeb:	83 ec 0c             	sub    $0xc,%esp
f011dbee:	68 b8 07 13 f0       	push   $0xf01307b8
f011dbf3:	e8 93 33 fe ff       	call   f0100f8b <cprintf>
f011dbf8:	83 c4 10             	add    $0x10,%esp
}
f011dbfb:	90                   	nop
f011dbfc:	c9                   	leave  
f011dbfd:	c3                   	ret    

f011dbfe <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011dbfe:	55                   	push   %ebp
f011dbff:	89 e5                	mov    %esp,%ebp
f011dc01:	57                   	push   %edi
f011dc02:	56                   	push   %esi
f011dc03:	53                   	push   %ebx
f011dc04:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011dc07:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011dc0c:	84 c0                	test   %al,%al
f011dc0e:	0f 84 ae 01 00 00    	je     f011ddc2 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011dc14:	83 ec 0c             	sub    $0xc,%esp
f011dc17:	6a 01                	push   $0x1
f011dc19:	e8 fe 10 00 00       	call   f011ed1c <chksch>
f011dc1e:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011dc21:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		int nice_values[] = {15, 5, 0, -5, -15};
f011dc28:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011dc2b:	bb 3c 08 13 f0       	mov    $0xf013083c,%ebx
f011dc30:	ba 05 00 00 00       	mov    $0x5,%edx
f011dc35:	89 c7                	mov    %eax,%edi
f011dc37:	89 de                	mov    %ebx,%esi
f011dc39:	89 d1                	mov    %edx,%ecx
f011dc3b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011dc3d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011dc44:	e9 4a 01 00 00       	jmp    f011dd93 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011dc49:	6a 00                	push   $0x0
f011dc4b:	6a 00                	push   $0x0
f011dc4d:	68 10 27 00 00       	push   $0x2710
f011dc52:	68 f4 07 13 f0       	push   $0xf01307f4
f011dc57:	e8 b1 d2 fe ff       	call   f010af0d <env_create>
f011dc5c:	83 c4 10             	add    $0x10,%esp
f011dc5f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011dc62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dc65:	b9 05 00 00 00       	mov    $0x5,%ecx
f011dc6a:	99                   	cltd   
f011dc6b:	f7 f9                	idiv   %ecx
f011dc6d:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011dc70:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dc73:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dc77:	83 ec 08             	sub    $0x8,%esp
f011dc7a:	50                   	push   %eax
f011dc7b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dc7e:	e8 03 8a fe ff       	call   f0106686 <env_set_nice>
f011dc83:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011dc86:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011dc8a:	75 17                	jne    f011dca3 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011dc8c:	83 ec 04             	sub    $0x4,%esp
f011dc8f:	68 89 05 13 f0       	push   $0xf0130589
f011dc94:	68 c1 00 00 00       	push   $0xc1
f011dc99:	68 a2 05 13 f0       	push   $0xf01305a2
f011dc9e:	e8 96 26 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011dca3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011dca6:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dcac:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011dcb1:	74 17                	je     f011dcca <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011dcb3:	83 ec 04             	sub    $0x4,%esp
f011dcb6:	68 c0 05 13 f0       	push   $0xf01305c0
f011dcbb:	68 c3 00 00 00       	push   $0xc3
f011dcc0:	68 a2 05 13 f0       	push   $0xf01305a2
f011dcc5:	e8 6f 26 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011dcca:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dccd:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dcd1:	83 c0 0f             	add    $0xf,%eax
f011dcd4:	83 f8 1e             	cmp    $0x1e,%eax
f011dcd7:	0f 87 a5 00 00 00    	ja     f011dd82 <test_bsd_nice_2+0x184>
f011dcdd:	8b 04 85 50 08 13 f0 	mov    -0xfecf7b0(,%eax,4),%eax
f011dce4:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011dce6:	a1 7c 03 6c f0       	mov    0xf06c037c,%eax
f011dceb:	8d 50 01             	lea    0x1(%eax),%edx
f011dcee:	89 15 7c 03 6c f0    	mov    %edx,0xf06c037c
f011dcf4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dcf7:	8b 52 10             	mov    0x10(%edx),%edx
f011dcfa:	89 14 85 e0 b4 b0 f0 	mov    %edx,-0xf4f4b20(,%eax,4)
				break;
f011dd01:	eb 7f                	jmp    f011dd82 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011dd03:	a1 80 03 6c f0       	mov    0xf06c0380,%eax
f011dd08:	8d 50 01             	lea    0x1(%eax),%edx
f011dd0b:	89 15 80 03 6c f0    	mov    %edx,0xf06c0380
f011dd11:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dd14:	8b 52 10             	mov    0x10(%edx),%edx
f011dd17:	83 c0 0a             	add    $0xa,%eax
f011dd1a:	89 14 85 e0 b4 b0 f0 	mov    %edx,-0xf4f4b20(,%eax,4)
				break;
f011dd21:	eb 5f                	jmp    f011dd82 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011dd23:	a1 84 03 6c f0       	mov    0xf06c0384,%eax
f011dd28:	8d 50 01             	lea    0x1(%eax),%edx
f011dd2b:	89 15 84 03 6c f0    	mov    %edx,0xf06c0384
f011dd31:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dd34:	8b 52 10             	mov    0x10(%edx),%edx
f011dd37:	83 c0 14             	add    $0x14,%eax
f011dd3a:	89 14 85 e0 b4 b0 f0 	mov    %edx,-0xf4f4b20(,%eax,4)
				break;
f011dd41:	eb 3f                	jmp    f011dd82 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011dd43:	a1 88 03 6c f0       	mov    0xf06c0388,%eax
f011dd48:	8d 50 01             	lea    0x1(%eax),%edx
f011dd4b:	89 15 88 03 6c f0    	mov    %edx,0xf06c0388
f011dd51:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dd54:	8b 52 10             	mov    0x10(%edx),%edx
f011dd57:	83 c0 1e             	add    $0x1e,%eax
f011dd5a:	89 14 85 e0 b4 b0 f0 	mov    %edx,-0xf4f4b20(,%eax,4)
				break;
f011dd61:	eb 1f                	jmp    f011dd82 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011dd63:	a1 8c 03 6c f0       	mov    0xf06c038c,%eax
f011dd68:	8d 50 01             	lea    0x1(%eax),%edx
f011dd6b:	89 15 8c 03 6c f0    	mov    %edx,0xf06c038c
f011dd71:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dd74:	8b 52 10             	mov    0x10(%edx),%edx
f011dd77:	83 c0 28             	add    $0x28,%eax
f011dd7a:	89 14 85 e0 b4 b0 f0 	mov    %edx,-0xf4f4b20(,%eax,4)
				break;
f011dd81:	90                   	nop
			}
			sched_new_env(env);
f011dd82:	83 ec 0c             	sub    $0xc,%esp
f011dd85:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dd88:	e8 8f 79 fe ff       	call   f010571c <sched_new_env>
f011dd8d:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011dd90:	ff 45 e4             	incl   -0x1c(%ebp)
f011dd93:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011dd97:	0f 8e ac fe ff ff    	jle    f011dc49 <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011dd9d:	83 ec 0c             	sub    $0xc,%esp
f011dda0:	68 f0 05 13 f0       	push   $0xf01305f0
f011dda5:	e8 e1 31 fe ff       	call   f0100f8b <cprintf>
f011ddaa:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011ddad:	83 ec 0c             	sub    $0xc,%esp
f011ddb0:	68 3f 06 13 f0       	push   $0xf013063f
f011ddb5:	e8 41 41 fe ff       	call   f0101efb <execute_command>
f011ddba:	83 c4 10             	add    $0x10,%esp
f011ddbd:	e9 d0 00 00 00       	jmp    f011de92 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011ddc2:	83 ec 0c             	sub    $0xc,%esp
f011ddc5:	6a 00                	push   $0x0
f011ddc7:	e8 50 0f 00 00       	call   f011ed1c <chksch>
f011ddcc:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011ddcf:	83 ec 0c             	sub    $0xc,%esp
f011ddd2:	68 46 06 13 f0       	push   $0xf0130646
f011ddd7:	e8 af 31 fe ff       	call   f0100f8b <cprintf>
f011dddc:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011dddf:	e8 70 80 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011dde4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011ddeb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011ddf2:	e9 8a 00 00 00       	jmp    f011de81 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011ddf7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011ddfe:	eb 55                	jmp    f011de55 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011de00:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de03:	8b 14 85 7c 03 6c f0 	mov    -0xf93fc84(,%eax,4),%edx
f011de0a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011de0d:	89 c8                	mov    %ecx,%eax
f011de0f:	c1 e0 02             	shl    $0x2,%eax
f011de12:	01 c8                	add    %ecx,%eax
f011de14:	01 c0                	add    %eax,%eax
f011de16:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011de19:	01 c8                	add    %ecx,%eax
f011de1b:	8b 04 85 e0 b4 b0 f0 	mov    -0xf4f4b20(,%eax,4),%eax
f011de22:	83 ec 04             	sub    $0x4,%esp
f011de25:	52                   	push   %edx
f011de26:	ff 75 e0             	pushl  -0x20(%ebp)
f011de29:	50                   	push   %eax
f011de2a:	e8 7f f8 ff ff       	call   f011d6ae <find_in_range>
f011de2f:	83 c4 10             	add    $0x10,%esp
f011de32:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011de35:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011de39:	75 17                	jne    f011de52 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011de3b:	83 ec 04             	sub    $0x4,%esp
f011de3e:	68 58 06 13 f0       	push   $0xf0130658
f011de43:	68 ea 00 00 00       	push   $0xea
f011de48:	68 a2 05 13 f0       	push   $0xf01305a2
f011de4d:	e8 e7 24 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011de52:	ff 45 d8             	incl   -0x28(%ebp)
f011de55:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011de58:	89 d0                	mov    %edx,%eax
f011de5a:	c1 e0 02             	shl    $0x2,%eax
f011de5d:	01 d0                	add    %edx,%eax
f011de5f:	01 c0                	add    %eax,%eax
f011de61:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011de64:	01 d0                	add    %edx,%eax
f011de66:	8b 04 85 e0 b4 b0 f0 	mov    -0xf4f4b20(,%eax,4),%eax
f011de6d:	85 c0                	test   %eax,%eax
f011de6f:	75 8f                	jne    f011de00 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011de71:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de74:	8b 04 85 7c 03 6c f0 	mov    -0xf93fc84(,%eax,4),%eax
f011de7b:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011de7e:	ff 45 dc             	incl   -0x24(%ebp)
f011de81:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011de85:	0f 8e 6c ff ff ff    	jle    f011ddf7 <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011de8b:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011de92:	83 ec 0c             	sub    $0xc,%esp
f011de95:	68 00 08 13 f0       	push   $0xf0130800
f011de9a:	e8 ec 30 fe ff       	call   f0100f8b <cprintf>
f011de9f:	83 c4 10             	add    $0x10,%esp
}
f011dea2:	90                   	nop
f011dea3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011dea6:	5b                   	pop    %ebx
f011dea7:	5e                   	pop    %esi
f011dea8:	5f                   	pop    %edi
f011dea9:	5d                   	pop    %ebp
f011deaa:	c3                   	ret    

f011deab <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011deab:	55                   	push   %ebp
f011deac:	89 e5                	mov    %esp,%ebp
f011deae:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011deb1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011deb4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011deb7:	8b 45 08             	mov    0x8(%ebp),%eax
f011deba:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011debd:	89 10                	mov    %edx,(%eax)
}
f011debf:	8b 45 08             	mov    0x8(%ebp),%eax
f011dec2:	c9                   	leave  
f011dec3:	c2 04 00             	ret    $0x4

f011dec6 <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011dec6:	55                   	push   %ebp
f011dec7:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011dec9:	8b 45 08             	mov    0x8(%ebp),%eax
f011decc:	85 c0                	test   %eax,%eax
f011dece:	78 16                	js     f011dee6 <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011ded0:	8b 45 08             	mov    0x8(%ebp),%eax
f011ded3:	05 00 20 00 00       	add    $0x2000,%eax
f011ded8:	85 c0                	test   %eax,%eax
f011deda:	79 05                	jns    f011dee1 <fix_round+0x1b>
f011dedc:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011dee1:	c1 f8 0e             	sar    $0xe,%eax
f011dee4:	eb 14                	jmp    f011defa <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011dee6:	8b 45 08             	mov    0x8(%ebp),%eax
f011dee9:	2d 00 20 00 00       	sub    $0x2000,%eax
f011deee:	85 c0                	test   %eax,%eax
f011def0:	79 05                	jns    f011def7 <fix_round+0x31>
f011def2:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011def7:	c1 f8 0e             	sar    $0xe,%eax
}
f011defa:	5d                   	pop    %ebp
f011defb:	c3                   	ret    

f011defc <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011defc:	55                   	push   %ebp
f011defd:	89 e5                	mov    %esp,%ebp
f011deff:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011df02:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011df06:	79 16                	jns    f011df1e <fix_scale+0x22>
f011df08:	68 cc 08 13 f0       	push   $0xf01308cc
f011df0d:	68 d3 08 13 f0       	push   $0xf01308d3
f011df12:	6a 5a                	push   $0x5a
f011df14:	68 e8 08 13 f0       	push   $0xf01308e8
f011df19:	e8 1b 24 fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011df1e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011df21:	0f af 45 10          	imul   0x10(%ebp),%eax
f011df25:	89 c2                	mov    %eax,%edx
f011df27:	8b 45 08             	mov    0x8(%ebp),%eax
f011df2a:	83 ec 08             	sub    $0x8,%esp
f011df2d:	52                   	push   %edx
f011df2e:	50                   	push   %eax
f011df2f:	e8 77 ff ff ff       	call   f011deab <__mk_fix>
f011df34:	83 c4 0c             	add    $0xc,%esp
}
f011df37:	8b 45 08             	mov    0x8(%ebp),%eax
f011df3a:	c9                   	leave  
f011df3b:	c2 04 00             	ret    $0x4

f011df3e <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011df3e:	55                   	push   %ebp
f011df3f:	89 e5                	mov    %esp,%ebp
f011df41:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011df44:	83 ec 08             	sub    $0x8,%esp
f011df47:	68 fc 08 13 f0       	push   $0xf01308fc
f011df4c:	68 e0 0d 6c f0       	push   $0xf06c0de0
f011df51:	e8 93 1c ff ff       	call   f010fbe9 <init_spinlock>
f011df56:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011df59:	83 ec 0c             	sub    $0xc,%esp
f011df5c:	68 e0 0d 6c f0       	push   $0xf06c0de0
f011df61:	e8 b4 1c ff ff       	call   f010fc1a <acquire_spinlock>
f011df66:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011df69:	c7 05 c8 04 6c f0 00 	movl   $0x0,0xf06c04c8
f011df70:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011df73:	83 ec 0c             	sub    $0xc,%esp
f011df76:	68 e0 0d 6c f0       	push   $0xf06c0de0
f011df7b:	e8 21 1d ff ff       	call   f010fca1 <release_spinlock>
f011df80:	83 c4 10             	add    $0x10,%esp
}
f011df83:	90                   	nop
f011df84:	c9                   	leave  
f011df85:	c3                   	ret    

f011df86 <inctst>:
void inctst()
{
f011df86:	55                   	push   %ebp
f011df87:	89 e5                	mov    %esp,%ebp
f011df89:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011df8c:	83 ec 0c             	sub    $0xc,%esp
f011df8f:	68 e0 0d 6c f0       	push   $0xf06c0de0
f011df94:	e8 81 1c ff ff       	call   f010fc1a <acquire_spinlock>
f011df99:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011df9c:	a1 c8 04 6c f0       	mov    0xf06c04c8,%eax
f011dfa1:	40                   	inc    %eax
f011dfa2:	a3 c8 04 6c f0       	mov    %eax,0xf06c04c8
	}
	release_spinlock(&tstcntlock);
f011dfa7:	83 ec 0c             	sub    $0xc,%esp
f011dfaa:	68 e0 0d 6c f0       	push   $0xf06c0de0
f011dfaf:	e8 ed 1c ff ff       	call   f010fca1 <release_spinlock>
f011dfb4:	83 c4 10             	add    $0x10,%esp
}
f011dfb7:	90                   	nop
f011dfb8:	c9                   	leave  
f011dfb9:	c3                   	ret    

f011dfba <gettst>:
uint32 gettst()
{
f011dfba:	55                   	push   %ebp
f011dfbb:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011dfbd:	a1 c8 04 6c f0       	mov    0xf06c04c8,%eax
}
f011dfc2:	5d                   	pop    %ebp
f011dfc3:	c3                   	ret    

f011dfc4 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011dfc4:	55                   	push   %ebp
f011dfc5:	89 e5                	mov    %esp,%ebp
f011dfc7:	83 ec 28             	sub    $0x28,%esp
f011dfca:	8b 45 14             	mov    0x14(%ebp),%eax
f011dfcd:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011dfd0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011dfd7:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011dfdb:	83 f8 65             	cmp    $0x65,%eax
f011dfde:	74 5d                	je     f011e03d <tst+0x79>
f011dfe0:	83 f8 65             	cmp    $0x65,%eax
f011dfe3:	7f 0a                	jg     f011dfef <tst+0x2b>
f011dfe5:	83 f8 62             	cmp    $0x62,%eax
f011dfe8:	74 73                	je     f011e05d <tst+0x99>
f011dfea:	e9 91 00 00 00       	jmp    f011e080 <tst+0xbc>
f011dfef:	83 f8 67             	cmp    $0x67,%eax
f011dff2:	74 29                	je     f011e01d <tst+0x59>
f011dff4:	83 f8 6c             	cmp    $0x6c,%eax
f011dff7:	0f 85 83 00 00 00    	jne    f011e080 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011dffd:	8b 45 08             	mov    0x8(%ebp),%eax
f011e000:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e003:	73 09                	jae    f011e00e <tst+0x4a>
			chk = 1;
f011e005:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e00c:	eb 68                	jmp    f011e076 <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011e00e:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e012:	74 62                	je     f011e076 <tst+0xb2>
			chk = 1;
f011e014:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e01b:	eb 59                	jmp    f011e076 <tst+0xb2>
	case 'g':
		if (n > v1)
f011e01d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e020:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e023:	76 09                	jbe    f011e02e <tst+0x6a>
			chk = 1;
f011e025:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e02c:	eb 4b                	jmp    f011e079 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011e02e:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e032:	74 45                	je     f011e079 <tst+0xb5>
			chk = 1;
f011e034:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e03b:	eb 3c                	jmp    f011e079 <tst+0xb5>
	case 'e':
		if (n == v1)
f011e03d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e040:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e043:	75 09                	jne    f011e04e <tst+0x8a>
			chk = 1;
f011e045:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e04c:	eb 2e                	jmp    f011e07c <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011e04e:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e052:	74 28                	je     f011e07c <tst+0xb8>
			chk = 1;
f011e054:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e05b:	eb 1f                	jmp    f011e07c <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011e05d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e060:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e063:	72 1a                	jb     f011e07f <tst+0xbb>
f011e065:	8b 45 08             	mov    0x8(%ebp),%eax
f011e068:	3b 45 10             	cmp    0x10(%ebp),%eax
f011e06b:	77 12                	ja     f011e07f <tst+0xbb>
			chk = 1;
f011e06d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e074:	eb 09                	jmp    f011e07f <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e076:	90                   	nop
f011e077:	eb 07                	jmp    f011e080 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e079:	90                   	nop
f011e07a:	eb 04                	jmp    f011e080 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e07c:	90                   	nop
f011e07d:	eb 01                	jmp    f011e080 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011e07f:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011e080:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e084:	75 14                	jne    f011e09a <tst+0xd6>
f011e086:	83 ec 04             	sub    $0x4,%esp
f011e089:	68 08 09 13 f0       	push   $0xf0130908
f011e08e:	6a 48                	push   $0x48
f011e090:	68 1b 09 13 f0       	push   $0xf013091b
f011e095:	e8 9f 22 fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011e09a:	83 ec 0c             	sub    $0xc,%esp
f011e09d:	68 e0 0d 6c f0       	push   $0xf06c0de0
f011e0a2:	e8 73 1b ff ff       	call   f010fc1a <acquire_spinlock>
f011e0a7:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011e0aa:	a1 c8 04 6c f0       	mov    0xf06c04c8,%eax
f011e0af:	40                   	inc    %eax
f011e0b0:	a3 c8 04 6c f0       	mov    %eax,0xf06c04c8
	}
	release_spinlock(&tstcntlock);
f011e0b5:	83 ec 0c             	sub    $0xc,%esp
f011e0b8:	68 e0 0d 6c f0       	push   $0xf06c0de0
f011e0bd:	e8 df 1b ff ff       	call   f010fca1 <release_spinlock>
f011e0c2:	83 c4 10             	add    $0x10,%esp

	return;
f011e0c5:	90                   	nop
}
f011e0c6:	c9                   	leave  
f011e0c7:	c3                   	ret    

f011e0c8 <chktst>:

void chktst(uint32 n)
{
f011e0c8:	55                   	push   %ebp
f011e0c9:	89 e5                	mov    %esp,%ebp
f011e0cb:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011e0ce:	83 ec 0c             	sub    $0xc,%esp
f011e0d1:	68 e0 0d 6c f0       	push   $0xf06c0de0
f011e0d6:	e8 3f 1b ff ff       	call   f010fc1a <acquire_spinlock>
f011e0db:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011e0de:	a1 c8 04 6c f0       	mov    0xf06c04c8,%eax
f011e0e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011e0e6:	83 ec 0c             	sub    $0xc,%esp
f011e0e9:	68 e0 0d 6c f0       	push   $0xf06c0de0
f011e0ee:	e8 ae 1b ff ff       	call   f010fca1 <release_spinlock>
f011e0f3:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011e0f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e0f9:	3b 45 08             	cmp    0x8(%ebp),%eax
f011e0fc:	75 12                	jne    f011e110 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011e0fe:	83 ec 0c             	sub    $0xc,%esp
f011e101:	68 34 09 13 f0       	push   $0xf0130934
f011e106:	e8 80 2e fe ff       	call   f0100f8b <cprintf>
f011e10b:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011e10e:	eb 14                	jmp    f011e124 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011e110:	83 ec 04             	sub    $0x4,%esp
f011e113:	68 60 09 13 f0       	push   $0xf0130960
f011e118:	6a 5e                	push   $0x5e
f011e11a:	68 1b 09 13 f0       	push   $0xf013091b
f011e11f:	e8 15 22 fe ff       	call   f0100339 <_panic>
}
f011e124:	c9                   	leave  
f011e125:	c3                   	ret    

f011e126 <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011e126:	55                   	push   %ebp
f011e127:	89 e5                	mov    %esp,%ebp
f011e129:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e12c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e130:	77 07                	ja     f011e139 <nearest_pow2_ceil+0x13>
f011e132:	b8 01 00 00 00       	mov    $0x1,%eax
f011e137:	eb 20                	jmp    f011e159 <nearest_pow2_ceil+0x33>
	int power = 2;
f011e139:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e140:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e143:	eb 08                	jmp    f011e14d <nearest_pow2_ceil+0x27>
		power <<= 1;
f011e145:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011e148:	01 c0                	add    %eax,%eax
f011e14a:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011e14d:	d1 6d 08             	shrl   0x8(%ebp)
f011e150:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e154:	75 ef                	jne    f011e145 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011e156:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e159:	c9                   	leave  
f011e15a:	c3                   	ret    

f011e15b <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011e15b:	55                   	push   %ebp
f011e15c:	89 e5                	mov    %esp,%ebp
f011e15e:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e161:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e165:	77 07                	ja     f011e16e <log2_ceil+0x13>
f011e167:	b8 01 00 00 00       	mov    $0x1,%eax
f011e16c:	eb 1b                	jmp    f011e189 <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011e16e:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e175:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e178:	eb 03                	jmp    f011e17d <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011e17a:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011e17d:	d1 6d 08             	shrl   0x8(%ebp)
f011e180:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e184:	75 f4                	jne    f011e17a <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011e186:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e189:	c9                   	leave  
f011e18a:	c3                   	ret    

f011e18b <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011e18b:	55                   	push   %ebp
f011e18c:	89 e5                	mov    %esp,%ebp
f011e18e:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011e191:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011e198:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011e19f:	eb 12                	jmp    f011e1b3 <fixedPt2Str+0x28>
		mulFactor *= 10;
f011e1a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e1a4:	89 d0                	mov    %edx,%eax
f011e1a6:	c1 e0 02             	shl    $0x2,%eax
f011e1a9:	01 d0                	add    %edx,%eax
f011e1ab:	01 c0                	add    %eax,%eax
f011e1ad:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011e1b0:	ff 45 f0             	incl   -0x10(%ebp)
f011e1b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e1b6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e1b9:	7c e6                	jl     f011e1a1 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011e1bb:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011e1be:	83 ec 04             	sub    $0x4,%esp
f011e1c1:	ff 75 f4             	pushl  -0xc(%ebp)
f011e1c4:	ff 75 08             	pushl  0x8(%ebp)
f011e1c7:	50                   	push   %eax
f011e1c8:	e8 2f fd ff ff       	call   f011defc <fix_scale>
f011e1cd:	83 c4 0c             	add    $0xc,%esp
f011e1d0:	83 ec 0c             	sub    $0xc,%esp
f011e1d3:	ff 75 dc             	pushl  -0x24(%ebp)
f011e1d6:	e8 eb fc ff ff       	call   f011dec6 <fix_round>
f011e1db:	83 c4 10             	add    $0x10,%esp
f011e1de:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011e1e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e1e4:	99                   	cltd   
f011e1e5:	f7 7d f4             	idivl  -0xc(%ebp)
f011e1e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011e1eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e1ee:	99                   	cltd   
f011e1ef:	f7 7d f4             	idivl  -0xc(%ebp)
f011e1f2:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011e1f5:	83 ec 08             	sub    $0x8,%esp
f011e1f8:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e1fb:	50                   	push   %eax
f011e1fc:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e1ff:	e8 6a 1e 00 00       	call   f012006e <ltostr>
f011e204:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011e207:	83 ec 08             	sub    $0x8,%esp
f011e20a:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e20d:	50                   	push   %eax
f011e20e:	ff 75 e0             	pushl  -0x20(%ebp)
f011e211:	e8 58 1e 00 00       	call   f012006e <ltostr>
f011e216:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011e219:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011e21c:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e221:	f7 e9                	imul   %ecx
f011e223:	c1 fa 02             	sar    $0x2,%edx
f011e226:	89 c8                	mov    %ecx,%eax
f011e228:	c1 f8 1f             	sar    $0x1f,%eax
f011e22b:	29 c2                	sub    %eax,%edx
f011e22d:	89 d0                	mov    %edx,%eax
f011e22f:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011e232:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011e239:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011e240:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011e246:	eb 31                	jmp    f011e279 <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011e248:	83 ec 04             	sub    $0x4,%esp
f011e24b:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e24e:	50                   	push   %eax
f011e24f:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e252:	50                   	push   %eax
f011e253:	68 7c 09 13 f0       	push   $0xf013097c
f011e258:	e8 ea 1e 00 00       	call   f0120147 <strcconcat>
f011e25d:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011e260:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011e263:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e268:	f7 e9                	imul   %ecx
f011e26a:	c1 fa 02             	sar    $0x2,%edx
f011e26d:	89 c8                	mov    %ecx,%eax
f011e26f:	c1 f8 1f             	sar    $0x1f,%eax
f011e272:	29 c2                	sub    %eax,%edx
f011e274:	89 d0                	mov    %edx,%eax
f011e276:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011e279:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e27c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e27f:	7c c7                	jl     f011e248 <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011e281:	83 ec 04             	sub    $0x4,%esp
f011e284:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e287:	50                   	push   %eax
f011e288:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e28b:	50                   	push   %eax
f011e28c:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e28f:	50                   	push   %eax
f011e290:	e8 b2 1e 00 00       	call   f0120147 <strcconcat>
f011e295:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011e298:	83 ec 04             	sub    $0x4,%esp
f011e29b:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e29e:	50                   	push   %eax
f011e29f:	68 7e 09 13 f0       	push   $0xf013097e
f011e2a4:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e2a7:	50                   	push   %eax
f011e2a8:	e8 9a 1e 00 00       	call   f0120147 <strcconcat>
f011e2ad:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011e2b0:	83 ec 04             	sub    $0x4,%esp
f011e2b3:	ff 75 10             	pushl  0x10(%ebp)
f011e2b6:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e2b9:	50                   	push   %eax
f011e2ba:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e2bd:	50                   	push   %eax
f011e2be:	e8 84 1e 00 00       	call   f0120147 <strcconcat>
f011e2c3:	83 c4 10             	add    $0x10,%esp

}
f011e2c6:	90                   	nop
f011e2c7:	c9                   	leave  
f011e2c8:	c3                   	ret    

f011e2c9 <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011e2c9:	55                   	push   %ebp
f011e2ca:	89 e5                	mov    %esp,%ebp
f011e2cc:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011e2d2:	83 ec 0c             	sub    $0xc,%esp
f011e2d5:	68 80 09 13 f0       	push   $0xf0130980
f011e2da:	e8 e9 18 00 00       	call   f011fbc8 <strlen>
f011e2df:	83 c4 10             	add    $0x10,%esp
f011e2e2:	83 ec 04             	sub    $0x4,%esp
f011e2e5:	50                   	push   %eax
f011e2e6:	68 80 09 13 f0       	push   $0xf0130980
f011e2eb:	ff 75 08             	pushl  0x8(%ebp)
f011e2ee:	e8 19 1a 00 00       	call   f011fd0c <strncmp>
f011e2f3:	83 c4 10             	add    $0x10,%esp
f011e2f6:	85 c0                	test   %eax,%eax
f011e2f8:	0f 85 8a 00 00 00    	jne    f011e388 <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e2fe:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011e301:	50                   	push   %eax
f011e302:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e308:	50                   	push   %eax
f011e309:	68 8e 09 13 f0       	push   $0xf013098e
f011e30e:	ff 75 08             	pushl  0x8(%ebp)
f011e311:	e8 c7 1e 00 00       	call   f01201dd <strsplit>
f011e316:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011e319:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e31f:	83 ec 04             	sub    $0x4,%esp
f011e322:	6a 0a                	push   $0xa
f011e324:	6a 00                	push   $0x0
f011e326:	50                   	push   %eax
f011e327:	e8 fc 1b 00 00       	call   f011ff28 <strtol>
f011e32c:	83 c4 10             	add    $0x10,%esp
f011e32f:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011e332:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011e339:	83 ec 04             	sub    $0x4,%esp
f011e33c:	6a 00                	push   $0x0
f011e33e:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e341:	50                   	push   %eax
f011e342:	ff 75 e0             	pushl  -0x20(%ebp)
f011e345:	e8 91 d6 fe ff       	call   f010b9db <envid2env>
f011e34a:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011e34d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e350:	8b 40 10             	mov    0x10(%eax),%eax
f011e353:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011e356:	74 19                	je     f011e371 <sys_utilities+0xa8>
f011e358:	68 90 09 13 f0       	push   $0xf0130990
f011e35d:	68 d3 08 13 f0       	push   $0xf01308d3
f011e362:	68 a4 00 00 00       	push   $0xa4
f011e367:	68 1b 09 13 f0       	push   $0xf013091b
f011e36c:	e8 c8 1f fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011e371:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e374:	83 ec 08             	sub    $0x8,%esp
f011e377:	ff 75 0c             	pushl  0xc(%ebp)
f011e37a:	50                   	push   %eax
f011e37b:	e8 06 83 fe ff       	call   f0106686 <env_set_nice>
f011e380:	83 c4 10             	add    $0x10,%esp
f011e383:	e9 12 04 00 00       	jmp    f011e79a <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011e388:	83 ec 0c             	sub    $0xc,%esp
f011e38b:	68 a5 09 13 f0       	push   $0xf01309a5
f011e390:	e8 33 18 00 00       	call   f011fbc8 <strlen>
f011e395:	83 c4 10             	add    $0x10,%esp
f011e398:	83 ec 04             	sub    $0x4,%esp
f011e39b:	50                   	push   %eax
f011e39c:	68 a5 09 13 f0       	push   $0xf01309a5
f011e3a1:	ff 75 08             	pushl  0x8(%ebp)
f011e3a4:	e8 63 19 00 00       	call   f011fd0c <strncmp>
f011e3a9:	83 c4 10             	add    $0x10,%esp
f011e3ac:	85 c0                	test   %eax,%eax
f011e3ae:	0f 85 a6 01 00 00    	jne    f011e55a <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011e3b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e3b7:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e3ba:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e3bd:	50                   	push   %eax
f011e3be:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e3c4:	50                   	push   %eax
f011e3c5:	68 8e 09 13 f0       	push   $0xf013098e
f011e3ca:	ff 75 08             	pushl  0x8(%ebp)
f011e3cd:	e8 0b 1e 00 00       	call   f01201dd <strsplit>
f011e3d2:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011e3d5:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e3db:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011e3de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011e3e5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011e3ec:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011e3f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e3f6:	8b 00                	mov    (%eax),%eax
f011e3f8:	85 c0                	test   %eax,%eax
f011e3fa:	79 1c                	jns    f011e418 <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011e3fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011e403:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e406:	8b 00                	mov    (%eax),%eax
f011e408:	f7 d8                	neg    %eax
f011e40a:	89 c2                	mov    %eax,%edx
f011e40c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e40f:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011e411:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011e418:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011e41f:	83 ec 0c             	sub    $0xc,%esp
f011e422:	68 e0 05 6c f0       	push   $0xf06c05e0
f011e427:	e8 ee 17 ff ff       	call   f010fc1a <acquire_spinlock>
f011e42c:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e42f:	a1 6c 06 6c f0       	mov    0xf06c066c,%eax
f011e434:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011e437:	a1 64 06 6c f0       	mov    0xf06c0664,%eax
f011e43c:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e43f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e442:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e445:	eb 6c                	jmp    f011e4b3 <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011e447:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e44a:	83 c0 20             	add    $0x20,%eax
f011e44d:	83 ec 08             	sub    $0x8,%esp
f011e450:	ff 75 d8             	pushl  -0x28(%ebp)
f011e453:	50                   	push   %eax
f011e454:	e8 7b 18 00 00       	call   f011fcd4 <strcmp>
f011e459:	83 c4 10             	add    $0x10,%esp
f011e45c:	85 c0                	test   %eax,%eax
f011e45e:	75 46                	jne    f011e4a6 <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011e460:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e463:	8b 00                	mov    (%eax),%eax
f011e465:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e468:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e46b:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011e46d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e471:	74 14                	je     f011e487 <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011e473:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e476:	8b 40 10             	mov    0x10(%eax),%eax
f011e479:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e47c:	7d 1d                	jge    f011e49b <sys_utilities+0x1d2>
					{
						success = 0;
f011e47e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e485:	eb 32                	jmp    f011e4b9 <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011e487:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e48a:	8b 40 10             	mov    0x10(%eax),%eax
f011e48d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e490:	7e 09                	jle    f011e49b <sys_utilities+0x1d2>
					{
						success = 0;
f011e492:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e499:	eb 1e                	jmp    f011e4b9 <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011e49b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e49e:	8b 40 10             	mov    0x10(%eax),%eax
f011e4a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e4a4:	eb 01                	jmp    f011e4a7 <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011e4a6:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e4a7:	ff 4d e4             	decl   -0x1c(%ebp)
f011e4aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e4ad:	8b 40 0c             	mov    0xc(%eax),%eax
f011e4b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011e4b3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e4b7:	7f 8e                	jg     f011e447 <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e4b9:	83 ec 0c             	sub    $0xc,%esp
f011e4bc:	68 e0 05 6c f0       	push   $0xf06c05e0
f011e4c1:	e8 db 17 ff ff       	call   f010fca1 <release_spinlock>
f011e4c6:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011e4c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e4cc:	8b 00                	mov    (%eax),%eax
f011e4ce:	85 c0                	test   %eax,%eax
f011e4d0:	75 06                	jne    f011e4d8 <sys_utilities+0x20f>
f011e4d2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011e4d6:	75 41                	jne    f011e519 <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011e4d8:	83 ec 0c             	sub    $0xc,%esp
f011e4db:	68 b8 09 13 f0       	push   $0xf01309b8
f011e4e0:	e8 a6 2a fe ff       	call   f0100f8b <cprintf>
f011e4e5:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011e4e8:	83 ec 08             	sub    $0x8,%esp
f011e4eb:	ff 75 d8             	pushl  -0x28(%ebp)
f011e4ee:	68 e8 09 13 f0       	push   $0xf01309e8
f011e4f3:	e8 93 2a fe ff       	call   f0100f8b <cprintf>
f011e4f8:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011e4fb:	83 ec 0c             	sub    $0xc,%esp
f011e4fe:	68 b8 09 13 f0       	push   $0xf01309b8
f011e503:	e8 83 2a fe ff       	call   f0100f8b <cprintf>
f011e508:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011e50b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e50e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011e514:	e9 81 02 00 00       	jmp    f011e79a <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011e519:	83 ec 0c             	sub    $0xc,%esp
f011e51c:	68 08 0a 13 f0       	push   $0xf0130a08
f011e521:	e8 65 2a fe ff       	call   f0100f8b <cprintf>
f011e526:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011e529:	83 ec 08             	sub    $0x8,%esp
f011e52c:	ff 75 d8             	pushl  -0x28(%ebp)
f011e52f:	68 40 0a 13 f0       	push   $0xf0130a40
f011e534:	e8 52 2a fe ff       	call   f0100f8b <cprintf>
f011e539:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011e53c:	83 ec 0c             	sub    $0xc,%esp
f011e53f:	68 08 0a 13 f0       	push   $0xf0130a08
f011e544:	e8 42 2a fe ff       	call   f0100f8b <cprintf>
f011e549:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011e54c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e54f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011e555:	e9 40 02 00 00       	jmp    f011e79a <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011e55a:	83 ec 08             	sub    $0x8,%esp
f011e55d:	68 63 0a 13 f0       	push   $0xf0130a63
f011e562:	ff 75 08             	pushl  0x8(%ebp)
f011e565:	e8 6a 17 00 00       	call   f011fcd4 <strcmp>
f011e56a:	83 c4 10             	add    $0x10,%esp
f011e56d:	85 c0                	test   %eax,%eax
f011e56f:	75 77                	jne    f011e5e8 <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011e571:	a1 e0 fd 17 f0       	mov    0xf017fde0,%eax
f011e576:	85 c0                	test   %eax,%eax
f011e578:	74 34                	je     f011e5ae <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011e57a:	c7 05 e0 fd 17 f0 00 	movl   $0x0,0xf017fde0
f011e581:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011e584:	83 ec 08             	sub    $0x8,%esp
f011e587:	68 6d 0a 13 f0       	push   $0xf0130a6d
f011e58c:	68 c0 b5 b0 f0       	push   $0xf0b0b5c0
f011e591:	e8 44 1a ff ff       	call   f010ffda <init_channel>
f011e596:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011e599:	83 ec 08             	sub    $0x8,%esp
f011e59c:	68 7a 0a 13 f0       	push   $0xf0130a7a
f011e5a1:	68 40 b7 b0 f0       	push   $0xf0b0b740
f011e5a6:	e8 3e 16 ff ff       	call   f010fbe9 <init_spinlock>
f011e5ab:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011e5ae:	83 ec 0c             	sub    $0xc,%esp
f011e5b1:	68 40 b7 b0 f0       	push   $0xf0b0b740
f011e5b6:	e8 5f 16 ff ff       	call   f010fc1a <acquire_spinlock>
f011e5bb:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011e5be:	83 ec 08             	sub    $0x8,%esp
f011e5c1:	68 40 b7 b0 f0       	push   $0xf0b0b740
f011e5c6:	68 c0 b5 b0 f0       	push   $0xf0b0b5c0
f011e5cb:	e8 37 1a ff ff       	call   f0110007 <sleep>
f011e5d0:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011e5d3:	83 ec 0c             	sub    $0xc,%esp
f011e5d6:	68 40 b7 b0 f0       	push   $0xf0b0b740
f011e5db:	e8 c1 16 ff ff       	call   f010fca1 <release_spinlock>
f011e5e0:	83 c4 10             	add    $0x10,%esp
f011e5e3:	e9 b2 01 00 00       	jmp    f011e79a <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011e5e8:	83 ec 08             	sub    $0x8,%esp
f011e5eb:	68 8c 0a 13 f0       	push   $0xf0130a8c
f011e5f0:	ff 75 08             	pushl  0x8(%ebp)
f011e5f3:	e8 dc 16 00 00       	call   f011fcd4 <strcmp>
f011e5f8:	83 c4 10             	add    $0x10,%esp
f011e5fb:	85 c0                	test   %eax,%eax
f011e5fd:	75 15                	jne    f011e614 <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011e5ff:	83 ec 0c             	sub    $0xc,%esp
f011e602:	68 c0 b5 b0 f0       	push   $0xf0b0b5c0
f011e607:	e8 68 1a ff ff       	call   f0110074 <wakeup_one>
f011e60c:	83 c4 10             	add    $0x10,%esp
f011e60f:	e9 86 01 00 00       	jmp    f011e79a <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011e614:	83 ec 08             	sub    $0x8,%esp
f011e617:	68 9a 0a 13 f0       	push   $0xf0130a9a
f011e61c:	ff 75 08             	pushl  0x8(%ebp)
f011e61f:	e8 b0 16 00 00       	call   f011fcd4 <strcmp>
f011e624:	83 c4 10             	add    $0x10,%esp
f011e627:	85 c0                	test   %eax,%eax
f011e629:	75 15                	jne    f011e640 <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011e62b:	83 ec 0c             	sub    $0xc,%esp
f011e62e:	68 c0 b5 b0 f0       	push   $0xf0b0b5c0
f011e633:	e8 c0 1a ff ff       	call   f01100f8 <wakeup_all>
f011e638:	83 c4 10             	add    $0x10,%esp
f011e63b:	e9 5a 01 00 00       	jmp    f011e79a <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011e640:	83 ec 08             	sub    $0x8,%esp
f011e643:	68 a8 0a 13 f0       	push   $0xf0130aa8
f011e648:	ff 75 08             	pushl  0x8(%ebp)
f011e64b:	e8 84 16 00 00       	call   f011fcd4 <strcmp>
f011e650:	83 c4 10             	add    $0x10,%esp
f011e653:	85 c0                	test   %eax,%eax
f011e655:	75 17                	jne    f011e66e <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011e657:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e65a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011e65d:	a1 cc b5 b0 f0       	mov    0xf0b0b5cc,%eax
f011e662:	89 c2                	mov    %eax,%edx
f011e664:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e667:	89 10                	mov    %edx,(%eax)
f011e669:	e9 2c 01 00 00       	jmp    f011e79a <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011e66e:	83 ec 08             	sub    $0x8,%esp
f011e671:	68 bd 0a 13 f0       	push   $0xf0130abd
f011e676:	ff 75 08             	pushl  0x8(%ebp)
f011e679:	e8 56 16 00 00       	call   f011fcd4 <strcmp>
f011e67e:	83 c4 10             	add    $0x10,%esp
f011e681:	85 c0                	test   %eax,%eax
f011e683:	75 1a                	jne    f011e69f <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011e685:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e688:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011e68b:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f011e690:	8b 40 0c             	mov    0xc(%eax),%eax
f011e693:	89 c2                	mov    %eax,%edx
f011e695:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e698:	89 10                	mov    %edx,(%eax)
f011e69a:	e9 fb 00 00 00       	jmp    f011e79a <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011e69f:	83 ec 08             	sub    $0x8,%esp
f011e6a2:	68 d3 0a 13 f0       	push   $0xf0130ad3
f011e6a7:	ff 75 08             	pushl  0x8(%ebp)
f011e6aa:	e8 25 16 00 00       	call   f011fcd4 <strcmp>
f011e6af:	83 c4 10             	add    $0x10,%esp
f011e6b2:	85 c0                	test   %eax,%eax
f011e6b4:	75 3d                	jne    f011e6f3 <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011e6b6:	a1 e4 fd 17 f0       	mov    0xf017fde4,%eax
f011e6bb:	85 c0                	test   %eax,%eax
f011e6bd:	74 1f                	je     f011e6de <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011e6bf:	c7 05 e4 fd 17 f0 00 	movl   $0x0,0xf017fde4
f011e6c6:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011e6c9:	83 ec 08             	sub    $0x8,%esp
f011e6cc:	68 e8 0a 13 f0       	push   $0xf0130ae8
f011e6d1:	68 20 b6 b0 f0       	push   $0xf0b0b620
f011e6d6:	e8 99 17 ff ff       	call   f010fe74 <init_sleeplock>
f011e6db:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011e6de:	83 ec 0c             	sub    $0xc,%esp
f011e6e1:	68 20 b6 b0 f0       	push   $0xf0b0b620
f011e6e6:	e8 4d 18 ff ff       	call   f010ff38 <acquire_sleeplock>
f011e6eb:	83 c4 10             	add    $0x10,%esp
f011e6ee:	e9 a7 00 00 00       	jmp    f011e79a <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011e6f3:	83 ec 08             	sub    $0x8,%esp
f011e6f6:	68 f8 0a 13 f0       	push   $0xf0130af8
f011e6fb:	ff 75 08             	pushl  0x8(%ebp)
f011e6fe:	e8 d1 15 00 00       	call   f011fcd4 <strcmp>
f011e703:	83 c4 10             	add    $0x10,%esp
f011e706:	85 c0                	test   %eax,%eax
f011e708:	75 12                	jne    f011e71c <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011e70a:	83 ec 0c             	sub    $0xc,%esp
f011e70d:	68 20 b6 b0 f0       	push   $0xf0b0b620
f011e712:	e8 7b 18 ff ff       	call   f010ff92 <release_sleeplock>
f011e717:	83 c4 10             	add    $0x10,%esp
f011e71a:	eb 7e                	jmp    f011e79a <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011e71c:	83 ec 08             	sub    $0x8,%esp
f011e71f:	68 0d 0b 13 f0       	push   $0xf0130b0d
f011e724:	ff 75 08             	pushl  0x8(%ebp)
f011e727:	e8 a8 15 00 00       	call   f011fcd4 <strcmp>
f011e72c:	83 c4 10             	add    $0x10,%esp
f011e72f:	85 c0                	test   %eax,%eax
f011e731:	75 14                	jne    f011e747 <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011e733:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e736:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011e739:	a1 a0 b6 b0 f0       	mov    0xf0b0b6a0,%eax
f011e73e:	89 c2                	mov    %eax,%edx
f011e740:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e743:	89 10                	mov    %edx,(%eax)
f011e745:	eb 53                	jmp    f011e79a <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011e747:	83 ec 08             	sub    $0x8,%esp
f011e74a:	68 22 0b 13 f0       	push   $0xf0130b22
f011e74f:	ff 75 08             	pushl  0x8(%ebp)
f011e752:	e8 7d 15 00 00       	call   f011fcd4 <strcmp>
f011e757:	83 c4 10             	add    $0x10,%esp
f011e75a:	85 c0                	test   %eax,%eax
f011e75c:	75 13                	jne    f011e771 <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011e75e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e761:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011e764:	8b 15 20 b6 b0 f0    	mov    0xf0b0b620,%edx
f011e76a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e76d:	89 10                	mov    %edx,(%eax)
f011e76f:	eb 29                	jmp    f011e79a <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011e771:	83 ec 08             	sub    $0x8,%esp
f011e774:	68 33 0b 13 f0       	push   $0xf0130b33
f011e779:	ff 75 08             	pushl  0x8(%ebp)
f011e77c:	e8 53 15 00 00       	call   f011fcd4 <strcmp>
f011e781:	83 c4 10             	add    $0x10,%esp
f011e784:	85 c0                	test   %eax,%eax
f011e786:	75 12                	jne    f011e79a <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011e788:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e78b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011e78e:	a1 24 b7 b0 f0       	mov    0xf0b0b724,%eax
f011e793:	89 c2                	mov    %eax,%edx
f011e795:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e798:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011e79a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e79e:	79 5b                	jns    f011e7fb <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011e7a0:	83 ec 08             	sub    $0x8,%esp
f011e7a3:	68 44 0b 13 f0       	push   $0xf0130b44
f011e7a8:	ff 75 08             	pushl  0x8(%ebp)
f011e7ab:	e8 24 15 00 00       	call   f011fcd4 <strcmp>
f011e7b0:	83 c4 10             	add    $0x10,%esp
f011e7b3:	85 c0                	test   %eax,%eax
f011e7b5:	75 44                	jne    f011e7fb <sys_utilities+0x532>
		{
			switch (value)
f011e7b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e7ba:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011e7bd:	74 07                	je     f011e7c6 <sys_utilities+0x4fd>
f011e7bf:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011e7c2:	74 19                	je     f011e7dd <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011e7c4:	eb 35                	jmp    f011e7fb <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011e7c6:	83 ec 0c             	sub    $0xc,%esp
f011e7c9:	68 54 0b 13 f0       	push   $0xf0130b54
f011e7ce:	e8 b8 27 fe ff       	call   f0100f8b <cprintf>
f011e7d3:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011e7d6:	e8 a4 0d ff ff       	call   f010f57f <setPageReplacmentAlgorithmFIFO>
				break;
f011e7db:	eb 1e                	jmp    f011e7fb <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011e7dd:	83 ec 0c             	sub    $0xc,%esp
f011e7e0:	68 c4 0b 13 f0       	push   $0xf0130bc4
f011e7e5:	e8 a1 27 fe ff       	call   f0100f8b <cprintf>
f011e7ea:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011e7ed:	83 ec 0c             	sub    $0xc,%esp
f011e7f0:	6a 02                	push   $0x2
f011e7f2:	e8 45 0d ff ff       	call   f010f53c <setPageReplacmentAlgorithmLRU>
f011e7f7:	83 c4 10             	add    $0x10,%esp
				break;
f011e7fa:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011e7fb:	90                   	nop
f011e7fc:	c9                   	leave  
f011e7fd:	c3                   	ret    

f011e7fe <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011e7fe:	55                   	push   %ebp
f011e7ff:	89 e5                	mov    %esp,%ebp
f011e801:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011e804:	8b 45 08             	mov    0x8(%ebp),%eax
f011e807:	8b 00                	mov    (%eax),%eax
f011e809:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011e80c:	8b 45 08             	mov    0x8(%ebp),%eax
f011e80f:	8b 00                	mov    (%eax),%eax
f011e811:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011e814:	eb 52                	jmp    f011e868 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011e816:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e819:	8b 00                	mov    (%eax),%eax
f011e81b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011e81e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e821:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e824:	75 12                	jne    f011e838 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011e826:	83 ec 0c             	sub    $0xc,%esp
f011e829:	68 38 0c 13 f0       	push   $0xf0130c38
f011e82e:	e8 58 27 fe ff       	call   f0100f8b <cprintf>
f011e833:	83 c4 10             	add    $0x10,%esp
			break;
f011e836:	eb 3f                	jmp    f011e877 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011e838:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e83c:	74 38                	je     f011e876 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011e83e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e841:	8b 00                	mov    (%eax),%eax
f011e843:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011e846:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e849:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e84c:	75 12                	jne    f011e860 <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011e84e:	83 ec 0c             	sub    $0xc,%esp
f011e851:	68 54 0c 13 f0       	push   $0xf0130c54
f011e856:	e8 30 27 fe ff       	call   f0100f8b <cprintf>
f011e85b:	83 c4 10             	add    $0x10,%esp
			break;
f011e85e:	eb 17                	jmp    f011e877 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011e860:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e863:	8b 00                	mov    (%eax),%eax
f011e865:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011e868:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e86c:	74 09                	je     f011e877 <detect_loop_in_FrameInfo_list+0x79>
f011e86e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e872:	75 a2                	jne    f011e816 <detect_loop_in_FrameInfo_list+0x18>
f011e874:	eb 01                	jmp    f011e877 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011e876:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011e877:	83 ec 0c             	sub    $0xc,%esp
f011e87a:	68 6b 0c 13 f0       	push   $0xf0130c6b
f011e87f:	e8 07 27 fe ff       	call   f0100f8b <cprintf>
f011e884:	83 c4 10             	add    $0x10,%esp
}
f011e887:	90                   	nop
f011e888:	c9                   	leave  
f011e889:	c3                   	ret    

f011e88a <scarce_memory>:

void scarce_memory()
{
f011e88a:	55                   	push   %ebp
f011e88b:	89 e5                	mov    %esp,%ebp
f011e88d:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011e890:	a1 b0 07 6c f0       	mov    0xf06c07b0,%eax
f011e895:	ba 64 00 00 00       	mov    $0x64,%edx
f011e89a:	29 c2                	sub    %eax,%edx
f011e89c:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f011e8a1:	0f af c2             	imul   %edx,%eax
f011e8a4:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e8a9:	f7 e2                	mul    %edx
f011e8ab:	89 d0                	mov    %edx,%eax
f011e8ad:	c1 e8 05             	shr    $0x5,%eax
f011e8b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011e8b3:	a1 b0 07 6c f0       	mov    0xf06c07b0,%eax
f011e8b8:	ba 64 00 00 00       	mov    $0x64,%edx
f011e8bd:	29 c2                	sub    %eax,%edx
f011e8bf:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f011e8c4:	89 d1                	mov    %edx,%ecx
f011e8c6:	0f af c8             	imul   %eax,%ecx
f011e8c9:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e8ce:	f7 e1                	mul    %ecx
f011e8d0:	c1 ea 05             	shr    $0x5,%edx
f011e8d3:	89 d0                	mov    %edx,%eax
f011e8d5:	c1 e0 02             	shl    $0x2,%eax
f011e8d8:	01 d0                	add    %edx,%eax
f011e8da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e8e1:	01 d0                	add    %edx,%eax
f011e8e3:	c1 e0 02             	shl    $0x2,%eax
f011e8e6:	29 c1                	sub    %eax,%ecx
f011e8e8:	89 ca                	mov    %ecx,%edx
f011e8ea:	85 d2                	test   %edx,%edx
f011e8ec:	74 03                	je     f011e8f1 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011e8ee:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011e8f1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011e8f8:	83 ec 0c             	sub    $0xc,%esp
f011e8fb:	68 a0 06 6c f0       	push   $0xf06c06a0
f011e900:	e8 15 13 ff ff       	call   f010fc1a <acquire_spinlock>
f011e905:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011e908:	a1 8c 06 6c f0       	mov    0xf06c068c,%eax
f011e90d:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011e910:	8b 15 78 08 6c f0    	mov    0xf06c0878,%edx
f011e916:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e919:	29 c2                	sub    %eax,%edx
f011e91b:	89 d0                	mov    %edx,%eax
f011e91d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011e920:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e923:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011e926:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011e929:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e930:	eb 12                	jmp    f011e944 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011e932:	83 ec 0c             	sub    $0xc,%esp
f011e935:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011e938:	50                   	push   %eax
f011e939:	e8 74 98 fe ff       	call   f01081b2 <allocate_frame>
f011e93e:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e941:	ff 45 f0             	incl   -0x10(%ebp)
f011e944:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e947:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011e94a:	76 e6                	jbe    f011e932 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011e94c:	83 ec 0c             	sub    $0xc,%esp
f011e94f:	68 a0 06 6c f0       	push   $0xf06c06a0
f011e954:	e8 48 13 ff ff       	call   f010fca1 <release_spinlock>
f011e959:	83 c4 10             	add    $0x10,%esp

}
f011e95c:	90                   	nop
f011e95d:	c9                   	leave  
f011e95e:	c3                   	ret    

f011e95f <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011e95f:	55                   	push   %ebp
f011e960:	89 e5                	mov    %esp,%ebp
f011e962:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011e965:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011e96c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011e973:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011e97a:	e8 0c d0 fe ff       	call   f010b98b <get_cpu_proc>
f011e97f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011e982:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011e986:	75 19                	jne    f011e9a1 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011e988:	68 85 0c 13 f0       	push   $0xf0130c85
f011e98d:	68 d3 08 13 f0       	push   $0xf01308d3
f011e992:	68 79 01 00 00       	push   $0x179
f011e997:	68 1b 09 13 f0       	push   $0xf013091b
f011e99c:	e8 98 19 fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011e9a1:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e9a5:	0f 85 d6 01 00 00    	jne    f011eb81 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011e9ab:	83 ec 0c             	sub    $0xc,%esp
f011e9ae:	68 e0 05 6c f0       	push   $0xf06c05e0
f011e9b3:	e8 62 12 ff ff       	call   f010fc1a <acquire_spinlock>
f011e9b8:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011e9bb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011e9c2:	e9 d2 00 00 00       	jmp    f011ea99 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011e9c7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011e9ce:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f011e9d3:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e9d6:	c1 e2 04             	shl    $0x4,%edx
f011e9d9:	01 d0                	add    %edx,%eax
f011e9db:	8b 00                	mov    (%eax),%eax
f011e9dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e9e0:	eb 7c                	jmp    f011ea5e <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011e9e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e9e5:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e9eb:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011e9ee:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e9f1:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e9f7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e9fa:	0f af c2             	imul   %edx,%eax
f011e9fd:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ea02:	f7 e2                	mul    %edx
f011ea04:	89 d0                	mov    %edx,%eax
f011ea06:	c1 e8 05             	shr    $0x5,%eax
f011ea09:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ea0c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ea0f:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ea15:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ea18:	89 d1                	mov    %edx,%ecx
f011ea1a:	0f af c8             	imul   %eax,%ecx
f011ea1d:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ea22:	f7 e1                	mul    %ecx
f011ea24:	c1 ea 05             	shr    $0x5,%edx
f011ea27:	89 d0                	mov    %edx,%eax
f011ea29:	c1 e0 02             	shl    $0x2,%eax
f011ea2c:	01 d0                	add    %edx,%eax
f011ea2e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ea35:	01 d0                	add    %edx,%eax
f011ea37:	c1 e0 02             	shl    $0x2,%eax
f011ea3a:	29 c1                	sub    %eax,%ecx
f011ea3c:	89 ca                	mov    %ecx,%edx
f011ea3e:	85 d2                	test   %edx,%edx
f011ea40:	74 03                	je     f011ea45 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011ea42:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011ea45:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ea48:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011ea4b:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f011ea50:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ea53:	c1 e2 04             	shl    $0x4,%edx
f011ea56:	01 d0                	add    %edx,%eax
f011ea58:	8b 40 08             	mov    0x8(%eax),%eax
f011ea5b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ea5e:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f011ea63:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ea66:	c1 e2 04             	shl    $0x4,%edx
f011ea69:	01 d0                	add    %edx,%eax
f011ea6b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ea6f:	74 08                	je     f011ea79 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011ea71:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011ea74:	8b 52 08             	mov    0x8(%edx),%edx
f011ea77:	eb 05                	jmp    f011ea7e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011ea79:	ba 00 00 00 00       	mov    $0x0,%edx
f011ea7e:	89 50 08             	mov    %edx,0x8(%eax)
f011ea81:	8b 40 08             	mov    0x8(%eax),%eax
f011ea84:	85 c0                	test   %eax,%eax
f011ea86:	0f 85 56 ff ff ff    	jne    f011e9e2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011ea8c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ea90:	0f 85 4c ff ff ff    	jne    f011e9e2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011ea96:	ff 45 e8             	incl   -0x18(%ebp)
f011ea99:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f011ea9e:	0f b6 c0             	movzbl %al,%eax
f011eaa1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011eaa4:	0f 8f 1d ff ff ff    	jg     f011e9c7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011eaaa:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011eab1:	a1 60 06 6c f0       	mov    0xf06c0660,%eax
f011eab6:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011eab9:	eb 1a                	jmp    f011ead5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011eabb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011eabe:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011eac4:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011eac7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011eaca:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011eacd:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f011ead2:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ead5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011ead9:	74 08                	je     f011eae3 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011eadb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011eade:	8b 40 08             	mov    0x8(%eax),%eax
f011eae1:	eb 05                	jmp    f011eae8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011eae3:	b8 00 00 00 00       	mov    $0x0,%eax
f011eae8:	a3 68 06 6c f0       	mov    %eax,0xf06c0668
f011eaed:	a1 68 06 6c f0       	mov    0xf06c0668,%eax
f011eaf2:	85 c0                	test   %eax,%eax
f011eaf4:	75 c5                	jne    f011eabb <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011eaf6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011eafa:	75 bf                	jne    f011eabb <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011eafc:	83 ec 0c             	sub    $0xc,%esp
f011eaff:	68 e0 05 6c f0       	push   $0xf06c05e0
f011eb04:	e8 98 11 ff ff       	call   f010fca1 <release_spinlock>
f011eb09:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011eb0c:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011eb10:	0f 84 d4 00 00 00    	je     f011ebea <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011eb16:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eb19:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011eb1f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011eb22:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eb25:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eb2b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011eb2e:	0f af c2             	imul   %edx,%eax
f011eb31:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011eb36:	f7 e2                	mul    %edx
f011eb38:	89 d0                	mov    %edx,%eax
f011eb3a:	c1 e8 05             	shr    $0x5,%eax
f011eb3d:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011eb40:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eb43:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eb49:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011eb4c:	89 d1                	mov    %edx,%ecx
f011eb4e:	0f af c8             	imul   %eax,%ecx
f011eb51:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011eb56:	f7 e1                	mul    %ecx
f011eb58:	c1 ea 05             	shr    $0x5,%edx
f011eb5b:	89 d0                	mov    %edx,%eax
f011eb5d:	c1 e0 02             	shl    $0x2,%eax
f011eb60:	01 d0                	add    %edx,%eax
f011eb62:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011eb69:	01 d0                	add    %edx,%eax
f011eb6b:	c1 e0 02             	shl    $0x2,%eax
f011eb6e:	29 c1                	sub    %eax,%ecx
f011eb70:	89 ca                	mov    %ecx,%edx
f011eb72:	85 d2                	test   %edx,%edx
f011eb74:	74 03                	je     f011eb79 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011eb76:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011eb79:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011eb7c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011eb7f:	eb 69                	jmp    f011ebea <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011eb81:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eb84:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011eb8a:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011eb8d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eb90:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eb96:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011eb99:	0f af c2             	imul   %edx,%eax
f011eb9c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011eba1:	f7 e2                	mul    %edx
f011eba3:	89 d0                	mov    %edx,%eax
f011eba5:	c1 e8 05             	shr    $0x5,%eax
f011eba8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ebab:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ebae:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ebb4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ebb7:	89 d1                	mov    %edx,%ecx
f011ebb9:	0f af c8             	imul   %eax,%ecx
f011ebbc:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ebc1:	f7 e1                	mul    %ecx
f011ebc3:	c1 ea 05             	shr    $0x5,%edx
f011ebc6:	89 d0                	mov    %edx,%eax
f011ebc8:	c1 e0 02             	shl    $0x2,%eax
f011ebcb:	01 d0                	add    %edx,%eax
f011ebcd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ebd4:	01 d0                	add    %edx,%eax
f011ebd6:	c1 e0 02             	shl    $0x2,%eax
f011ebd9:	29 c1                	sub    %eax,%ecx
f011ebdb:	89 ca                	mov    %ecx,%edx
f011ebdd:	85 d2                	test   %edx,%edx
f011ebdf:	74 03                	je     f011ebe4 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011ebe1:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011ebe4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ebe7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011ebea:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ebed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ebf0:	01 c2                	add    %eax,%edx
f011ebf2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ebf5:	01 d0                	add    %edx,%eax
}
f011ebf7:	c9                   	leave  
f011ebf8:	c3                   	ret    

f011ebf9 <schenv>:


void schenv()
{
f011ebf9:	55                   	push   %ebp
f011ebfa:	89 e5                	mov    %esp,%ebp
f011ebfc:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011ebff:	c6 05 c0 0d 6c f0 00 	movb   $0x0,0xf06c0dc0
	__ne = NULL;
f011ec06:	c7 05 cc 0a 6c f0 00 	movl   $0x0,0xf06c0acc
f011ec0d:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011ec10:	83 ec 0c             	sub    $0xc,%esp
f011ec13:	68 e0 05 6c f0       	push   $0xf06c05e0
f011ec18:	e8 fd 0f ff ff       	call   f010fc1a <acquire_spinlock>
f011ec1d:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011ec20:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ec27:	eb 3f                	jmp    f011ec68 <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011ec29:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f011ec2e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ec31:	c1 e2 04             	shl    $0x4,%edx
f011ec34:	01 d0                	add    %edx,%eax
f011ec36:	83 ec 0c             	sub    $0xc,%esp
f011ec39:	50                   	push   %eax
f011ec3a:	e8 53 63 fe ff       	call   f0104f92 <queue_size>
f011ec3f:	83 c4 10             	add    $0x10,%esp
f011ec42:	85 c0                	test   %eax,%eax
f011ec44:	74 1f                	je     f011ec65 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011ec46:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f011ec4b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ec4e:	c1 e2 04             	shl    $0x4,%edx
f011ec51:	01 d0                	add    %edx,%eax
f011ec53:	8b 40 04             	mov    0x4(%eax),%eax
f011ec56:	a3 cc 0a 6c f0       	mov    %eax,0xf06c0acc
				__nl = i;
f011ec5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ec5e:	a2 c0 0d 6c f0       	mov    %al,0xf06c0dc0
				break;
f011ec63:	eb 10                	jmp    f011ec75 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011ec65:	ff 45 f4             	incl   -0xc(%ebp)
f011ec68:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f011ec6d:	0f b6 c0             	movzbl %al,%eax
f011ec70:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ec73:	7f b4                	jg     f011ec29 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011ec75:	83 ec 0c             	sub    $0xc,%esp
f011ec78:	68 e0 05 6c f0       	push   $0xf06c05e0
f011ec7d:	e8 1f 10 ff ff       	call   f010fca1 <release_spinlock>
f011ec82:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011ec85:	e8 01 cd fe ff       	call   f010b98b <get_cpu_proc>
f011ec8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011ec8d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ec91:	0f 84 82 00 00 00    	je     f011ed19 <schenv+0x120>
	{
		if (__ne != NULL)
f011ec97:	a1 cc 0a 6c f0       	mov    0xf06c0acc,%eax
f011ec9c:	85 c0                	test   %eax,%eax
f011ec9e:	74 49                	je     f011ece9 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011eca0:	a0 c1 05 6c f0       	mov    0xf06c05c1,%al
f011eca5:	0f b6 c0             	movzbl %al,%eax
f011eca8:	8d 50 01             	lea    0x1(%eax),%edx
f011ecab:	a0 c0 0d 6c f0       	mov    0xf06c0dc0,%al
f011ecb0:	0f b6 c0             	movzbl %al,%eax
f011ecb3:	39 c2                	cmp    %eax,%edx
f011ecb5:	7d 62                	jge    f011ed19 <schenv+0x120>
			{
				__ne = cur_env;
f011ecb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ecba:	a3 cc 0a 6c f0       	mov    %eax,0xf06c0acc
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011ecbf:	a0 c1 05 6c f0       	mov    0xf06c05c1,%al
f011ecc4:	0f b6 c0             	movzbl %al,%eax
f011ecc7:	8a 15 24 0d 6c f0    	mov    0xf06c0d24,%dl
f011eccd:	0f b6 d2             	movzbl %dl,%edx
f011ecd0:	4a                   	dec    %edx
f011ecd1:	39 d0                	cmp    %edx,%eax
f011ecd3:	7d 08                	jge    f011ecdd <schenv+0xe4>
f011ecd5:	a0 c1 05 6c f0       	mov    0xf06c05c1,%al
f011ecda:	40                   	inc    %eax
f011ecdb:	eb 05                	jmp    f011ece2 <schenv+0xe9>
f011ecdd:	a0 c1 05 6c f0       	mov    0xf06c05c1,%al
f011ece2:	a2 c0 0d 6c f0       	mov    %al,0xf06c0dc0
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011ece7:	eb 30                	jmp    f011ed19 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011ece9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ecec:	a3 cc 0a 6c f0       	mov    %eax,0xf06c0acc
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011ecf1:	a0 c1 05 6c f0       	mov    0xf06c05c1,%al
f011ecf6:	0f b6 c0             	movzbl %al,%eax
f011ecf9:	8a 15 24 0d 6c f0    	mov    0xf06c0d24,%dl
f011ecff:	0f b6 d2             	movzbl %dl,%edx
f011ed02:	4a                   	dec    %edx
f011ed03:	39 d0                	cmp    %edx,%eax
f011ed05:	7d 08                	jge    f011ed0f <schenv+0x116>
f011ed07:	a0 c1 05 6c f0       	mov    0xf06c05c1,%al
f011ed0c:	40                   	inc    %eax
f011ed0d:	eb 05                	jmp    f011ed14 <schenv+0x11b>
f011ed0f:	a0 c1 05 6c f0       	mov    0xf06c05c1,%al
f011ed14:	a2 c0 0d 6c f0       	mov    %al,0xf06c0dc0
		}
	}
}
f011ed19:	90                   	nop
f011ed1a:	c9                   	leave  
f011ed1b:	c3                   	ret    

f011ed1c <chksch>:

void chksch(uint8 onoff)
{
f011ed1c:	55                   	push   %ebp
f011ed1d:	89 e5                	mov    %esp,%ebp
f011ed1f:	83 ec 18             	sub    $0x18,%esp
f011ed22:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed25:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011ed28:	e8 e5 79 fe ff       	call   f0106712 <isSchedMethodBSD>
f011ed2d:	85 c0                	test   %eax,%eax
f011ed2f:	74 48                	je     f011ed79 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011ed31:	e8 8a 79 fe ff       	call   f01066c0 <get_load_average>
f011ed36:	a3 48 0d 6c f0       	mov    %eax,0xf06c0d48
f011ed3b:	a1 48 0d 6c f0       	mov    0xf06c0d48,%eax
f011ed40:	a3 7c 08 6c f0       	mov    %eax,0xf06c087c
		acquire_spinlock(&ProcessQueues.qlock);
f011ed45:	83 ec 0c             	sub    $0xc,%esp
f011ed48:	68 e0 05 6c f0       	push   $0xf06c05e0
f011ed4d:	e8 c8 0e ff ff       	call   f010fc1a <acquire_spinlock>
f011ed52:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011ed55:	a1 6c 06 6c f0       	mov    0xf06c066c,%eax
f011ed5a:	a3 20 07 6c f0       	mov    %eax,0xf06c0720
		}
		release_spinlock(&ProcessQueues.qlock);
f011ed5f:	83 ec 0c             	sub    $0xc,%esp
f011ed62:	68 e0 05 6c f0       	push   $0xf06c05e0
f011ed67:	e8 35 0f ff ff       	call   f010fca1 <release_spinlock>
f011ed6c:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011ed6f:	c7 05 dc 0a 6c f0 01 	movl   $0x1,0xf06c0adc
f011ed76:	00 00 00 
	}
	__chkstatus = onoff;
f011ed79:	8a 45 f4             	mov    -0xc(%ebp),%al
f011ed7c:	a2 c8 0a 6c f0       	mov    %al,0xf06c0ac8
}
f011ed81:	90                   	nop
f011ed82:	c9                   	leave  
f011ed83:	c3                   	ret    

f011ed84 <chk1>:
void chk1()
{
f011ed84:	55                   	push   %ebp
f011ed85:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011ed87:	90                   	nop
f011ed88:	5d                   	pop    %ebp
f011ed89:	c3                   	ret    

f011ed8a <chk2>:
void chk2(struct Env* __se)
{
f011ed8a:	55                   	push   %ebp
f011ed8b:	89 e5                	mov    %esp,%ebp
f011ed8d:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011ed90:	a0 c8 0a 6c f0       	mov    0xf06c0ac8,%al
f011ed95:	84 c0                	test   %al,%al
f011ed97:	0f 84 59 03 00 00    	je     f011f0f6 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011ed9d:	e8 70 79 fe ff       	call   f0106712 <isSchedMethodBSD>
f011eda2:	85 c0                	test   %eax,%eax
f011eda4:	0f 84 4d 03 00 00    	je     f011f0f7 <chk2+0x36d>
	{
		__nla = get_load_average();
f011edaa:	e8 11 79 fe ff       	call   f01066c0 <get_load_average>
f011edaf:	a3 b4 07 6c f0       	mov    %eax,0xf06c07b4
		acquire_spinlock(&ProcessQueues.qlock);
f011edb4:	83 ec 0c             	sub    $0xc,%esp
f011edb7:	68 e0 05 6c f0       	push   $0xf06c05e0
f011edbc:	e8 59 0e ff ff       	call   f010fc1a <acquire_spinlock>
f011edc1:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011edc4:	a1 6c 06 6c f0       	mov    0xf06c066c,%eax
f011edc9:	a3 d0 0a 6c f0       	mov    %eax,0xf06c0ad0
		}
		release_spinlock(&ProcessQueues.qlock);
f011edce:	83 ec 0c             	sub    $0xc,%esp
f011edd1:	68 e0 05 6c f0       	push   $0xf06c05e0
f011edd6:	e8 c6 0e ff ff       	call   f010fca1 <release_spinlock>
f011eddb:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011edde:	a1 dc 0a 6c f0       	mov    0xf06c0adc,%eax
f011ede3:	85 c0                	test   %eax,%eax
f011ede5:	74 72                	je     f011ee59 <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011ede7:	83 ec 0c             	sub    $0xc,%esp
f011edea:	68 e0 05 6c f0       	push   $0xf06c05e0
f011edef:	e8 26 0e ff ff       	call   f010fc1a <acquire_spinlock>
f011edf4:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011edf7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011edfb:	0f 95 c0             	setne  %al
f011edfe:	0f b6 c0             	movzbl %al,%eax
f011ee01:	a3 94 0c 6c f0       	mov    %eax,0xf06c0c94
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ee06:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f011ee0b:	0f b6 c0             	movzbl %al,%eax
f011ee0e:	48                   	dec    %eax
f011ee0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ee12:	eb 20                	jmp    f011ee34 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011ee14:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f011ee19:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ee1c:	c1 e2 04             	shl    $0x4,%edx
f011ee1f:	01 d0                	add    %edx,%eax
f011ee21:	8b 40 0c             	mov    0xc(%eax),%eax
f011ee24:	8b 15 94 0c 6c f0    	mov    0xf06c0c94,%edx
f011ee2a:	01 d0                	add    %edx,%eax
f011ee2c:	a3 94 0c 6c f0       	mov    %eax,0xf06c0c94
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ee31:	ff 4d f4             	decl   -0xc(%ebp)
f011ee34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ee38:	79 da                	jns    f011ee14 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011ee3a:	c7 05 dc 0a 6c f0 00 	movl   $0x0,0xf06c0adc
f011ee41:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011ee44:	83 ec 0c             	sub    $0xc,%esp
f011ee47:	68 e0 05 6c f0       	push   $0xf06c05e0
f011ee4c:	e8 50 0e ff ff       	call   f010fca1 <release_spinlock>
f011ee51:	83 c4 10             	add    $0x10,%esp
f011ee54:	e9 91 02 00 00       	jmp    f011f0ea <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011ee59:	8b 15 20 07 6c f0    	mov    0xf06c0720,%edx
f011ee5f:	a1 d0 0a 6c f0       	mov    0xf06c0ad0,%eax
f011ee64:	39 c2                	cmp    %eax,%edx
f011ee66:	74 63                	je     f011eecb <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011ee68:	83 ec 0c             	sub    $0xc,%esp
f011ee6b:	68 e0 05 6c f0       	push   $0xf06c05e0
f011ee70:	e8 a5 0d ff ff       	call   f010fc1a <acquire_spinlock>
f011ee75:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011ee78:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ee7c:	0f 95 c0             	setne  %al
f011ee7f:	0f b6 c0             	movzbl %al,%eax
f011ee82:	a3 94 0c 6c f0       	mov    %eax,0xf06c0c94
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ee87:	a0 24 0d 6c f0       	mov    0xf06c0d24,%al
f011ee8c:	0f b6 c0             	movzbl %al,%eax
f011ee8f:	48                   	dec    %eax
f011ee90:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ee93:	eb 20                	jmp    f011eeb5 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011ee95:	a1 70 06 6c f0       	mov    0xf06c0670,%eax
f011ee9a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011ee9d:	c1 e2 04             	shl    $0x4,%edx
f011eea0:	01 d0                	add    %edx,%eax
f011eea2:	8b 40 0c             	mov    0xc(%eax),%eax
f011eea5:	8b 15 94 0c 6c f0    	mov    0xf06c0c94,%edx
f011eeab:	01 d0                	add    %edx,%eax
f011eead:	a3 94 0c 6c f0       	mov    %eax,0xf06c0c94
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011eeb2:	ff 4d f0             	decl   -0x10(%ebp)
f011eeb5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011eeb9:	79 da                	jns    f011ee95 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011eebb:	83 ec 0c             	sub    $0xc,%esp
f011eebe:	68 e0 05 6c f0       	push   $0xf06c05e0
f011eec3:	e8 d9 0d ff ff       	call   f010fca1 <release_spinlock>
f011eec8:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011eecb:	e8 89 77 fe ff       	call   f0106659 <timer_ticks>
f011eed0:	6a 00                	push   $0x0
f011eed2:	68 e8 03 00 00       	push   $0x3e8
f011eed7:	52                   	push   %edx
f011eed8:	50                   	push   %eax
f011eed9:	e8 ee 31 00 00       	call   f01220cc <__moddi3>
f011eede:	83 c4 10             	add    $0x10,%esp
f011eee1:	09 d0                	or     %edx,%eax
f011eee3:	85 c0                	test   %eax,%eax
f011eee5:	75 32                	jne    f011ef19 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011eee7:	8b 15 7c 08 6c f0    	mov    0xf06c087c,%edx
f011eeed:	a1 b4 07 6c f0       	mov    0xf06c07b4,%eax
f011eef2:	39 c2                	cmp    %eax,%edx
f011eef4:	75 19                	jne    f011ef0f <chk2+0x185>
f011eef6:	68 95 0c 13 f0       	push   $0xf0130c95
f011eefb:	68 d3 08 13 f0       	push   $0xf01308d3
f011ef00:	68 35 02 00 00       	push   $0x235
f011ef05:	68 1b 09 13 f0       	push   $0xf013091b
f011ef0a:	e8 ba 14 fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011ef0f:	a1 b4 07 6c f0       	mov    0xf06c07b4,%eax
f011ef14:	a3 7c 08 6c f0       	mov    %eax,0xf06c087c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011ef19:	e8 3b 77 fe ff       	call   f0106659 <timer_ticks>
f011ef1e:	6a 00                	push   $0x0
f011ef20:	6a 64                	push   $0x64
f011ef22:	52                   	push   %edx
f011ef23:	50                   	push   %eax
f011ef24:	e8 a3 31 00 00       	call   f01220cc <__moddi3>
f011ef29:	83 c4 10             	add    $0x10,%esp
f011ef2c:	09 d0                	or     %edx,%eax
f011ef2e:	85 c0                	test   %eax,%eax
f011ef30:	0f 85 b4 01 00 00    	jne    f011f0ea <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011ef36:	8b 0d 48 0d 6c f0    	mov    0xf06c0d48,%ecx
f011ef3c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ef41:	f7 e9                	imul   %ecx
f011ef43:	c1 fa 05             	sar    $0x5,%edx
f011ef46:	89 c8                	mov    %ecx,%eax
f011ef48:	c1 f8 1f             	sar    $0x1f,%eax
f011ef4b:	29 c2                	sub    %eax,%edx
f011ef4d:	89 d0                	mov    %edx,%eax
f011ef4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011ef52:	8b 0d 48 0d 6c f0    	mov    0xf06c0d48,%ecx
f011ef58:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ef5d:	f7 e9                	imul   %ecx
f011ef5f:	c1 fa 05             	sar    $0x5,%edx
f011ef62:	89 c8                	mov    %ecx,%eax
f011ef64:	c1 f8 1f             	sar    $0x1f,%eax
f011ef67:	29 c2                	sub    %eax,%edx
f011ef69:	89 d0                	mov    %edx,%eax
f011ef6b:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011ef6e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ef71:	89 d0                	mov    %edx,%eax
f011ef73:	c1 e0 02             	shl    $0x2,%eax
f011ef76:	01 d0                	add    %edx,%eax
f011ef78:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ef7f:	01 d0                	add    %edx,%eax
f011ef81:	c1 e0 02             	shl    $0x2,%eax
f011ef84:	29 c1                	sub    %eax,%ecx
f011ef86:	89 c8                	mov    %ecx,%eax
f011ef88:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011ef8b:	8b 0d b4 07 6c f0    	mov    0xf06c07b4,%ecx
f011ef91:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ef96:	f7 e9                	imul   %ecx
f011ef98:	c1 fa 05             	sar    $0x5,%edx
f011ef9b:	89 c8                	mov    %ecx,%eax
f011ef9d:	c1 f8 1f             	sar    $0x1f,%eax
f011efa0:	29 c2                	sub    %eax,%edx
f011efa2:	89 d0                	mov    %edx,%eax
f011efa4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011efa7:	8b 0d b4 07 6c f0    	mov    0xf06c07b4,%ecx
f011efad:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011efb2:	f7 e9                	imul   %ecx
f011efb4:	c1 fa 05             	sar    $0x5,%edx
f011efb7:	89 c8                	mov    %ecx,%eax
f011efb9:	c1 f8 1f             	sar    $0x1f,%eax
f011efbc:	29 c2                	sub    %eax,%edx
f011efbe:	89 d0                	mov    %edx,%eax
f011efc0:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011efc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011efc6:	89 d0                	mov    %edx,%eax
f011efc8:	c1 e0 02             	shl    $0x2,%eax
f011efcb:	01 d0                	add    %edx,%eax
f011efcd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011efd4:	01 d0                	add    %edx,%eax
f011efd6:	c1 e0 02             	shl    $0x2,%eax
f011efd9:	29 c1                	sub    %eax,%ecx
f011efdb:	89 c8                	mov    %ecx,%eax
f011efdd:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011efe0:	8b 15 d0 0a 6c f0    	mov    0xf06c0ad0,%edx
f011efe6:	a1 20 07 6c f0       	mov    0xf06c0720,%eax
f011efeb:	39 c2                	cmp    %eax,%edx
f011efed:	0f 85 ed 00 00 00    	jne    f011f0e0 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011eff3:	a1 94 0c 6c f0       	mov    0xf06c0c94,%eax
f011eff8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011effb:	7e 5b                	jle    f011f058 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011effd:	a1 94 0c 6c f0       	mov    0xf06c0c94,%eax
f011f002:	83 ec 08             	sub    $0x8,%esp
f011f005:	ff 75 e0             	pushl  -0x20(%ebp)
f011f008:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f00b:	ff 75 e8             	pushl  -0x18(%ebp)
f011f00e:	ff 75 ec             	pushl  -0x14(%ebp)
f011f011:	50                   	push   %eax
f011f012:	68 a8 0c 13 f0       	push   $0xf0130ca8
f011f017:	e8 6f 1f fe ff       	call   f0100f8b <cprintf>
f011f01c:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011f01f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f022:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f025:	0f 8f b5 00 00 00    	jg     f011f0e0 <chk2+0x356>
f011f02b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f02e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f031:	75 0c                	jne    f011f03f <chk2+0x2b5>
f011f033:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f036:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f039:	0f 8d a1 00 00 00    	jge    f011f0e0 <chk2+0x356>
f011f03f:	68 f0 0c 13 f0       	push   $0xf0130cf0
f011f044:	68 d3 08 13 f0       	push   $0xf01308d3
f011f049:	68 4a 02 00 00       	push   $0x24a
f011f04e:	68 1b 09 13 f0       	push   $0xf013091b
f011f053:	e8 71 13 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011f058:	a1 94 0c 6c f0       	mov    0xf06c0c94,%eax
f011f05d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f060:	7d 53                	jge    f011f0b5 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f062:	a1 94 0c 6c f0       	mov    0xf06c0c94,%eax
f011f067:	83 ec 08             	sub    $0x8,%esp
f011f06a:	ff 75 e0             	pushl  -0x20(%ebp)
f011f06d:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f070:	ff 75 e8             	pushl  -0x18(%ebp)
f011f073:	ff 75 ec             	pushl  -0x14(%ebp)
f011f076:	50                   	push   %eax
f011f077:	68 30 0d 13 f0       	push   $0xf0130d30
f011f07c:	e8 0a 1f fe ff       	call   f0100f8b <cprintf>
f011f081:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011f084:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f087:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f08a:	7c 54                	jl     f011f0e0 <chk2+0x356>
f011f08c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f08f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f092:	75 08                	jne    f011f09c <chk2+0x312>
f011f094:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f097:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f09a:	7e 44                	jle    f011f0e0 <chk2+0x356>
f011f09c:	68 78 0d 13 f0       	push   $0xf0130d78
f011f0a1:	68 d3 08 13 f0       	push   $0xf01308d3
f011f0a6:	68 50 02 00 00       	push   $0x250
f011f0ab:	68 1b 09 13 f0       	push   $0xf013091b
f011f0b0:	e8 14 13 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011f0b5:	a1 94 0c 6c f0       	mov    0xf06c0c94,%eax
f011f0ba:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f0bd:	75 21                	jne    f011f0e0 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011f0bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f0c2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f0c5:	74 19                	je     f011f0e0 <chk2+0x356>
f011f0c7:	68 b8 0d 13 f0       	push   $0xf0130db8
f011f0cc:	68 d3 08 13 f0       	push   $0xf01308d3
f011f0d1:	68 54 02 00 00       	push   $0x254
f011f0d6:	68 1b 09 13 f0       	push   $0xf013091b
f011f0db:	e8 e9 12 fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011f0e0:	a1 b4 07 6c f0       	mov    0xf06c07b4,%eax
f011f0e5:	a3 48 0d 6c f0       	mov    %eax,0xf06c0d48
			}
		}
		__pnexit = __nnexit;
f011f0ea:	a1 d0 0a 6c f0       	mov    0xf06c0ad0,%eax
f011f0ef:	a3 20 07 6c f0       	mov    %eax,0xf06c0720
f011f0f4:	eb 01                	jmp    f011f0f7 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011f0f6:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011f0f7:	c9                   	leave  
f011f0f8:	c3                   	ret    

f011f0f9 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011f0f9:	55                   	push   %ebp
f011f0fa:	89 e5                	mov    %esp,%ebp
f011f0fc:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f0ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f106:	eb 40                	jmp    f011f148 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011f108:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f10b:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f111:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011f116:	83 ec 08             	sub    $0x8,%esp
f011f119:	52                   	push   %edx
f011f11a:	50                   	push   %eax
f011f11b:	e8 af 01 00 00       	call   f011f2cf <check_va2pa>
f011f120:	83 c4 10             	add    $0x10,%esp
f011f123:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f126:	74 19                	je     f011f141 <check_boot_pgdir+0x48>
f011f128:	68 cc 0d 13 f0       	push   $0xf0130dcc
f011f12d:	68 d3 08 13 f0       	push   $0xf01308d3
f011f132:	68 9b 02 00 00       	push   $0x29b
f011f137:	68 1b 09 13 f0       	push   $0xf013091b
f011f13c:	e8 f8 11 fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f141:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f148:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f14b:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f151:	a1 98 0c 6c f0       	mov    0xf06c0c98,%eax
f011f156:	39 c2                	cmp    %eax,%edx
f011f158:	72 ae                	jb     f011f108 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f15a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f161:	e9 81 00 00 00       	jmp    f011f1e7 <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011f166:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f169:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011f16e:	85 c0                	test   %eax,%eax
f011f170:	74 6d                	je     f011f1df <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011f172:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f175:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011f17b:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011f180:	83 ec 08             	sub    $0x8,%esp
f011f183:	52                   	push   %edx
f011f184:	50                   	push   %eax
f011f185:	e8 45 01 00 00       	call   f011f2cf <check_va2pa>
f011f18a:	83 c4 10             	add    $0x10,%esp
f011f18d:	c7 45 f0 00 70 17 f0 	movl   $0xf0177000,-0x10(%ebp)
f011f194:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011f19b:	77 17                	ja     f011f1b4 <check_boot_pgdir+0xbb>
f011f19d:	ff 75 f0             	pushl  -0x10(%ebp)
f011f1a0:	68 04 0e 13 f0       	push   $0xf0130e04
f011f1a5:	68 a9 02 00 00       	push   $0x2a9
f011f1aa:	68 1b 09 13 f0       	push   $0xf013091b
f011f1af:	e8 85 11 fe ff       	call   f0100339 <_panic>
f011f1b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f1b7:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011f1bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f1c0:	01 ca                	add    %ecx,%edx
f011f1c2:	39 d0                	cmp    %edx,%eax
f011f1c4:	74 1a                	je     f011f1e0 <check_boot_pgdir+0xe7>
f011f1c6:	68 38 0e 13 f0       	push   $0xf0130e38
f011f1cb:	68 d3 08 13 f0       	push   $0xf01308d3
f011f1d0:	68 a9 02 00 00       	push   $0x2a9
f011f1d5:	68 1b 09 13 f0       	push   $0xf013091b
f011f1da:	e8 5a 11 fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011f1df:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f1e0:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f1e7:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011f1ee:	0f 86 72 ff ff ff    	jbe    f011f166 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f1f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f1fb:	e9 af 00 00 00       	jmp    f011f2af <check_boot_pgdir+0x1b6>
		switch (i) {
f011f200:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f203:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f208:	74 11                	je     f011f21b <check_boot_pgdir+0x122>
f011f20a:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f20f:	72 36                	jb     f011f247 <check_boot_pgdir+0x14e>
f011f211:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011f216:	83 f8 02             	cmp    $0x2,%eax
f011f219:	77 2c                	ja     f011f247 <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011f21b:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011f220:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f223:	c1 e2 02             	shl    $0x2,%edx
f011f226:	01 d0                	add    %edx,%eax
f011f228:	8b 00                	mov    (%eax),%eax
f011f22a:	85 c0                	test   %eax,%eax
f011f22c:	75 7a                	jne    f011f2a8 <check_boot_pgdir+0x1af>
f011f22e:	68 be 0e 13 f0       	push   $0xf0130ebe
f011f233:	68 d3 08 13 f0       	push   $0xf01308d3
f011f238:	68 b4 02 00 00       	push   $0x2b4
f011f23d:	68 1b 09 13 f0       	push   $0xf013091b
f011f242:	e8 f2 10 fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011f247:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011f24e:	76 2c                	jbe    f011f27c <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011f250:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011f255:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f258:	c1 e2 02             	shl    $0x2,%edx
f011f25b:	01 d0                	add    %edx,%eax
f011f25d:	8b 00                	mov    (%eax),%eax
f011f25f:	85 c0                	test   %eax,%eax
f011f261:	75 48                	jne    f011f2ab <check_boot_pgdir+0x1b2>
f011f263:	68 be 0e 13 f0       	push   $0xf0130ebe
f011f268:	68 d3 08 13 f0       	push   $0xf01308d3
f011f26d:	68 b8 02 00 00       	push   $0x2b8
f011f272:	68 1b 09 13 f0       	push   $0xf013091b
f011f277:	e8 bd 10 fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011f27c:	a1 9c 0c 6c f0       	mov    0xf06c0c9c,%eax
f011f281:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f284:	c1 e2 02             	shl    $0x2,%edx
f011f287:	01 d0                	add    %edx,%eax
f011f289:	8b 00                	mov    (%eax),%eax
f011f28b:	85 c0                	test   %eax,%eax
f011f28d:	74 1c                	je     f011f2ab <check_boot_pgdir+0x1b2>
f011f28f:	68 d4 0e 13 f0       	push   $0xf0130ed4
f011f294:	68 d3 08 13 f0       	push   $0xf01308d3
f011f299:	68 ba 02 00 00       	push   $0x2ba
f011f29e:	68 1b 09 13 f0       	push   $0xf013091b
f011f2a3:	e8 91 10 fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011f2a8:	90                   	nop
f011f2a9:	eb 01                	jmp    f011f2ac <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011f2ab:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f2ac:	ff 45 f4             	incl   -0xc(%ebp)
f011f2af:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011f2b6:	0f 86 44 ff ff ff    	jbe    f011f200 <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011f2bc:	83 ec 0c             	sub    $0xc,%esp
f011f2bf:	68 f0 0e 13 f0       	push   $0xf0130ef0
f011f2c4:	e8 c2 1c fe ff       	call   f0100f8b <cprintf>
f011f2c9:	83 c4 10             	add    $0x10,%esp
}
f011f2cc:	90                   	nop
f011f2cd:	c9                   	leave  
f011f2ce:	c3                   	ret    

f011f2cf <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011f2cf:	55                   	push   %ebp
f011f2d0:	89 e5                	mov    %esp,%ebp
f011f2d2:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011f2d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f2d8:	c1 e8 16             	shr    $0x16,%eax
f011f2db:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f2e2:	8b 45 08             	mov    0x8(%ebp),%eax
f011f2e5:	01 d0                	add    %edx,%eax
f011f2e7:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011f2ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f2ed:	8b 00                	mov    (%eax),%eax
f011f2ef:	83 e0 01             	and    $0x1,%eax
f011f2f2:	85 c0                	test   %eax,%eax
f011f2f4:	75 0a                	jne    f011f300 <check_va2pa+0x31>
		return ~0;
f011f2f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f2fb:	e9 87 00 00 00       	jmp    f011f387 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011f300:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f303:	8b 00                	mov    (%eax),%eax
f011f305:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011f30a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f30d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f310:	c1 e8 0c             	shr    $0xc,%eax
f011f313:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f316:	a1 78 08 6c f0       	mov    0xf06c0878,%eax
f011f31b:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011f31e:	72 17                	jb     f011f337 <check_va2pa+0x68>
f011f320:	ff 75 f0             	pushl  -0x10(%ebp)
f011f323:	68 14 0f 13 f0       	push   $0xf0130f14
f011f328:	68 d0 02 00 00       	push   $0x2d0
f011f32d:	68 1b 09 13 f0       	push   $0xf013091b
f011f332:	e8 02 10 fe ff       	call   f0100339 <_panic>
f011f337:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f33a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011f33f:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011f342:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f345:	c1 e8 0c             	shr    $0xc,%eax
f011f348:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f34d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f354:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f357:	01 d0                	add    %edx,%eax
f011f359:	8b 00                	mov    (%eax),%eax
f011f35b:	83 e0 01             	and    $0x1,%eax
f011f35e:	85 c0                	test   %eax,%eax
f011f360:	75 07                	jne    f011f369 <check_va2pa+0x9a>
		return ~0;
f011f362:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f367:	eb 1e                	jmp    f011f387 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011f369:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f36c:	c1 e8 0c             	shr    $0xc,%eax
f011f36f:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f374:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f37b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f37e:	01 d0                	add    %edx,%eax
f011f380:	8b 00                	mov    (%eax),%eax
f011f382:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011f387:	c9                   	leave  
f011f388:	c3                   	ret    

f011f389 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011f389:	55                   	push   %ebp
f011f38a:	89 e5                	mov    %esp,%ebp
f011f38c:	53                   	push   %ebx
f011f38d:	83 ec 14             	sub    $0x14,%esp
f011f390:	8b 45 10             	mov    0x10(%ebp),%eax
f011f393:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f396:	8b 45 14             	mov    0x14(%ebp),%eax
f011f399:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011f39c:	8b 45 18             	mov    0x18(%ebp),%eax
f011f39f:	ba 00 00 00 00       	mov    $0x0,%edx
f011f3a4:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f3a7:	77 55                	ja     f011f3fe <printnum+0x75>
f011f3a9:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f3ac:	72 05                	jb     f011f3b3 <printnum+0x2a>
f011f3ae:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011f3b1:	77 4b                	ja     f011f3fe <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011f3b3:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011f3b6:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011f3b9:	8b 45 18             	mov    0x18(%ebp),%eax
f011f3bc:	ba 00 00 00 00       	mov    $0x0,%edx
f011f3c1:	52                   	push   %edx
f011f3c2:	50                   	push   %eax
f011f3c3:	ff 75 f4             	pushl  -0xc(%ebp)
f011f3c6:	ff 75 f0             	pushl  -0x10(%ebp)
f011f3c9:	e8 96 2e 00 00       	call   f0122264 <__udivdi3>
f011f3ce:	83 c4 10             	add    $0x10,%esp
f011f3d1:	83 ec 04             	sub    $0x4,%esp
f011f3d4:	ff 75 20             	pushl  0x20(%ebp)
f011f3d7:	53                   	push   %ebx
f011f3d8:	ff 75 18             	pushl  0x18(%ebp)
f011f3db:	52                   	push   %edx
f011f3dc:	50                   	push   %eax
f011f3dd:	ff 75 0c             	pushl  0xc(%ebp)
f011f3e0:	ff 75 08             	pushl  0x8(%ebp)
f011f3e3:	e8 a1 ff ff ff       	call   f011f389 <printnum>
f011f3e8:	83 c4 20             	add    $0x20,%esp
f011f3eb:	eb 1a                	jmp    f011f407 <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011f3ed:	83 ec 08             	sub    $0x8,%esp
f011f3f0:	ff 75 0c             	pushl  0xc(%ebp)
f011f3f3:	ff 75 20             	pushl  0x20(%ebp)
f011f3f6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f3f9:	ff d0                	call   *%eax
f011f3fb:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011f3fe:	ff 4d 1c             	decl   0x1c(%ebp)
f011f401:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011f405:	7f e6                	jg     f011f3ed <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011f407:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011f40a:	bb 00 00 00 00       	mov    $0x0,%ebx
f011f40f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f412:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f415:	53                   	push   %ebx
f011f416:	51                   	push   %ecx
f011f417:	52                   	push   %edx
f011f418:	50                   	push   %eax
f011f419:	e8 56 2f 00 00       	call   f0122374 <__umoddi3>
f011f41e:	83 c4 10             	add    $0x10,%esp
f011f421:	05 74 11 13 f0       	add    $0xf0131174,%eax
f011f426:	8a 00                	mov    (%eax),%al
f011f428:	0f be c0             	movsbl %al,%eax
f011f42b:	83 ec 08             	sub    $0x8,%esp
f011f42e:	ff 75 0c             	pushl  0xc(%ebp)
f011f431:	50                   	push   %eax
f011f432:	8b 45 08             	mov    0x8(%ebp),%eax
f011f435:	ff d0                	call   *%eax
f011f437:	83 c4 10             	add    $0x10,%esp
}
f011f43a:	90                   	nop
f011f43b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011f43e:	c9                   	leave  
f011f43f:	c3                   	ret    

f011f440 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011f440:	55                   	push   %ebp
f011f441:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f443:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f447:	7e 1c                	jle    f011f465 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011f449:	8b 45 08             	mov    0x8(%ebp),%eax
f011f44c:	8b 00                	mov    (%eax),%eax
f011f44e:	8d 50 08             	lea    0x8(%eax),%edx
f011f451:	8b 45 08             	mov    0x8(%ebp),%eax
f011f454:	89 10                	mov    %edx,(%eax)
f011f456:	8b 45 08             	mov    0x8(%ebp),%eax
f011f459:	8b 00                	mov    (%eax),%eax
f011f45b:	83 e8 08             	sub    $0x8,%eax
f011f45e:	8b 50 04             	mov    0x4(%eax),%edx
f011f461:	8b 00                	mov    (%eax),%eax
f011f463:	eb 40                	jmp    f011f4a5 <getuint+0x65>
	else if (lflag)
f011f465:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f469:	74 1e                	je     f011f489 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011f46b:	8b 45 08             	mov    0x8(%ebp),%eax
f011f46e:	8b 00                	mov    (%eax),%eax
f011f470:	8d 50 04             	lea    0x4(%eax),%edx
f011f473:	8b 45 08             	mov    0x8(%ebp),%eax
f011f476:	89 10                	mov    %edx,(%eax)
f011f478:	8b 45 08             	mov    0x8(%ebp),%eax
f011f47b:	8b 00                	mov    (%eax),%eax
f011f47d:	83 e8 04             	sub    $0x4,%eax
f011f480:	8b 00                	mov    (%eax),%eax
f011f482:	ba 00 00 00 00       	mov    $0x0,%edx
f011f487:	eb 1c                	jmp    f011f4a5 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011f489:	8b 45 08             	mov    0x8(%ebp),%eax
f011f48c:	8b 00                	mov    (%eax),%eax
f011f48e:	8d 50 04             	lea    0x4(%eax),%edx
f011f491:	8b 45 08             	mov    0x8(%ebp),%eax
f011f494:	89 10                	mov    %edx,(%eax)
f011f496:	8b 45 08             	mov    0x8(%ebp),%eax
f011f499:	8b 00                	mov    (%eax),%eax
f011f49b:	83 e8 04             	sub    $0x4,%eax
f011f49e:	8b 00                	mov    (%eax),%eax
f011f4a0:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011f4a5:	5d                   	pop    %ebp
f011f4a6:	c3                   	ret    

f011f4a7 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011f4a7:	55                   	push   %ebp
f011f4a8:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f4aa:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f4ae:	7e 1c                	jle    f011f4cc <getint+0x25>
		return va_arg(*ap, long long);
f011f4b0:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4b3:	8b 00                	mov    (%eax),%eax
f011f4b5:	8d 50 08             	lea    0x8(%eax),%edx
f011f4b8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4bb:	89 10                	mov    %edx,(%eax)
f011f4bd:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4c0:	8b 00                	mov    (%eax),%eax
f011f4c2:	83 e8 08             	sub    $0x8,%eax
f011f4c5:	8b 50 04             	mov    0x4(%eax),%edx
f011f4c8:	8b 00                	mov    (%eax),%eax
f011f4ca:	eb 38                	jmp    f011f504 <getint+0x5d>
	else if (lflag)
f011f4cc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f4d0:	74 1a                	je     f011f4ec <getint+0x45>
		return va_arg(*ap, long);
f011f4d2:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4d5:	8b 00                	mov    (%eax),%eax
f011f4d7:	8d 50 04             	lea    0x4(%eax),%edx
f011f4da:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4dd:	89 10                	mov    %edx,(%eax)
f011f4df:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4e2:	8b 00                	mov    (%eax),%eax
f011f4e4:	83 e8 04             	sub    $0x4,%eax
f011f4e7:	8b 00                	mov    (%eax),%eax
f011f4e9:	99                   	cltd   
f011f4ea:	eb 18                	jmp    f011f504 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011f4ec:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4ef:	8b 00                	mov    (%eax),%eax
f011f4f1:	8d 50 04             	lea    0x4(%eax),%edx
f011f4f4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4f7:	89 10                	mov    %edx,(%eax)
f011f4f9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4fc:	8b 00                	mov    (%eax),%eax
f011f4fe:	83 e8 04             	sub    $0x4,%eax
f011f501:	8b 00                	mov    (%eax),%eax
f011f503:	99                   	cltd   
}
f011f504:	5d                   	pop    %ebp
f011f505:	c3                   	ret    

f011f506 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011f506:	55                   	push   %ebp
f011f507:	89 e5                	mov    %esp,%ebp
f011f509:	56                   	push   %esi
f011f50a:	53                   	push   %ebx
f011f50b:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f50e:	eb 17                	jmp    f011f527 <vprintfmt+0x21>
			if (ch == '\0')
f011f510:	85 db                	test   %ebx,%ebx
f011f512:	0f 84 c1 03 00 00    	je     f011f8d9 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011f518:	83 ec 08             	sub    $0x8,%esp
f011f51b:	ff 75 0c             	pushl  0xc(%ebp)
f011f51e:	53                   	push   %ebx
f011f51f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f522:	ff d0                	call   *%eax
f011f524:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f527:	8b 45 10             	mov    0x10(%ebp),%eax
f011f52a:	8d 50 01             	lea    0x1(%eax),%edx
f011f52d:	89 55 10             	mov    %edx,0x10(%ebp)
f011f530:	8a 00                	mov    (%eax),%al
f011f532:	0f b6 d8             	movzbl %al,%ebx
f011f535:	83 fb 25             	cmp    $0x25,%ebx
f011f538:	75 d6                	jne    f011f510 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011f53a:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011f53e:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011f545:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011f54c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011f553:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011f55a:	8b 45 10             	mov    0x10(%ebp),%eax
f011f55d:	8d 50 01             	lea    0x1(%eax),%edx
f011f560:	89 55 10             	mov    %edx,0x10(%ebp)
f011f563:	8a 00                	mov    (%eax),%al
f011f565:	0f b6 d8             	movzbl %al,%ebx
f011f568:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011f56b:	83 f8 5b             	cmp    $0x5b,%eax
f011f56e:	0f 87 3d 03 00 00    	ja     f011f8b1 <vprintfmt+0x3ab>
f011f574:	8b 04 85 98 11 13 f0 	mov    -0xfecee68(,%eax,4),%eax
f011f57b:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011f57d:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011f581:	eb d7                	jmp    f011f55a <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011f583:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011f587:	eb d1                	jmp    f011f55a <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f589:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011f590:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f593:	89 d0                	mov    %edx,%eax
f011f595:	c1 e0 02             	shl    $0x2,%eax
f011f598:	01 d0                	add    %edx,%eax
f011f59a:	01 c0                	add    %eax,%eax
f011f59c:	01 d8                	add    %ebx,%eax
f011f59e:	83 e8 30             	sub    $0x30,%eax
f011f5a1:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011f5a4:	8b 45 10             	mov    0x10(%ebp),%eax
f011f5a7:	8a 00                	mov    (%eax),%al
f011f5a9:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011f5ac:	83 fb 2f             	cmp    $0x2f,%ebx
f011f5af:	7e 3e                	jle    f011f5ef <vprintfmt+0xe9>
f011f5b1:	83 fb 39             	cmp    $0x39,%ebx
f011f5b4:	7f 39                	jg     f011f5ef <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f5b6:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011f5b9:	eb d5                	jmp    f011f590 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011f5bb:	8b 45 14             	mov    0x14(%ebp),%eax
f011f5be:	83 c0 04             	add    $0x4,%eax
f011f5c1:	89 45 14             	mov    %eax,0x14(%ebp)
f011f5c4:	8b 45 14             	mov    0x14(%ebp),%eax
f011f5c7:	83 e8 04             	sub    $0x4,%eax
f011f5ca:	8b 00                	mov    (%eax),%eax
f011f5cc:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011f5cf:	eb 1f                	jmp    f011f5f0 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011f5d1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f5d5:	79 83                	jns    f011f55a <vprintfmt+0x54>
				width = 0;
f011f5d7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011f5de:	e9 77 ff ff ff       	jmp    f011f55a <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011f5e3:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011f5ea:	e9 6b ff ff ff       	jmp    f011f55a <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011f5ef:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011f5f0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f5f4:	0f 89 60 ff ff ff    	jns    f011f55a <vprintfmt+0x54>
				width = precision, precision = -1;
f011f5fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f5fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f600:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011f607:	e9 4e ff ff ff       	jmp    f011f55a <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011f60c:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011f60f:	e9 46 ff ff ff       	jmp    f011f55a <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011f614:	8b 45 14             	mov    0x14(%ebp),%eax
f011f617:	83 c0 04             	add    $0x4,%eax
f011f61a:	89 45 14             	mov    %eax,0x14(%ebp)
f011f61d:	8b 45 14             	mov    0x14(%ebp),%eax
f011f620:	83 e8 04             	sub    $0x4,%eax
f011f623:	8b 00                	mov    (%eax),%eax
f011f625:	83 ec 08             	sub    $0x8,%esp
f011f628:	ff 75 0c             	pushl  0xc(%ebp)
f011f62b:	50                   	push   %eax
f011f62c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f62f:	ff d0                	call   *%eax
f011f631:	83 c4 10             	add    $0x10,%esp
			break;
f011f634:	e9 9b 02 00 00       	jmp    f011f8d4 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011f639:	8b 45 14             	mov    0x14(%ebp),%eax
f011f63c:	83 c0 04             	add    $0x4,%eax
f011f63f:	89 45 14             	mov    %eax,0x14(%ebp)
f011f642:	8b 45 14             	mov    0x14(%ebp),%eax
f011f645:	83 e8 04             	sub    $0x4,%eax
f011f648:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011f64a:	85 db                	test   %ebx,%ebx
f011f64c:	79 02                	jns    f011f650 <vprintfmt+0x14a>
				err = -err;
f011f64e:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011f650:	83 fb 64             	cmp    $0x64,%ebx
f011f653:	7f 0b                	jg     f011f660 <vprintfmt+0x15a>
f011f655:	8b 34 9d e0 0f 13 f0 	mov    -0xfecf020(,%ebx,4),%esi
f011f65c:	85 f6                	test   %esi,%esi
f011f65e:	75 19                	jne    f011f679 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011f660:	53                   	push   %ebx
f011f661:	68 85 11 13 f0       	push   $0xf0131185
f011f666:	ff 75 0c             	pushl  0xc(%ebp)
f011f669:	ff 75 08             	pushl  0x8(%ebp)
f011f66c:	e8 70 02 00 00       	call   f011f8e1 <printfmt>
f011f671:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011f674:	e9 5b 02 00 00       	jmp    f011f8d4 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011f679:	56                   	push   %esi
f011f67a:	68 8e 11 13 f0       	push   $0xf013118e
f011f67f:	ff 75 0c             	pushl  0xc(%ebp)
f011f682:	ff 75 08             	pushl  0x8(%ebp)
f011f685:	e8 57 02 00 00       	call   f011f8e1 <printfmt>
f011f68a:	83 c4 10             	add    $0x10,%esp
			break;
f011f68d:	e9 42 02 00 00       	jmp    f011f8d4 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011f692:	8b 45 14             	mov    0x14(%ebp),%eax
f011f695:	83 c0 04             	add    $0x4,%eax
f011f698:	89 45 14             	mov    %eax,0x14(%ebp)
f011f69b:	8b 45 14             	mov    0x14(%ebp),%eax
f011f69e:	83 e8 04             	sub    $0x4,%eax
f011f6a1:	8b 30                	mov    (%eax),%esi
f011f6a3:	85 f6                	test   %esi,%esi
f011f6a5:	75 05                	jne    f011f6ac <vprintfmt+0x1a6>
				p = "(null)";
f011f6a7:	be 91 11 13 f0       	mov    $0xf0131191,%esi
			if (width > 0 && padc != '-')
f011f6ac:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f6b0:	7e 6d                	jle    f011f71f <vprintfmt+0x219>
f011f6b2:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011f6b6:	74 67                	je     f011f71f <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011f6b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f6bb:	83 ec 08             	sub    $0x8,%esp
f011f6be:	50                   	push   %eax
f011f6bf:	56                   	push   %esi
f011f6c0:	e8 26 05 00 00       	call   f011fbeb <strnlen>
f011f6c5:	83 c4 10             	add    $0x10,%esp
f011f6c8:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011f6cb:	eb 16                	jmp    f011f6e3 <vprintfmt+0x1dd>
					putch(padc, putdat);
f011f6cd:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011f6d1:	83 ec 08             	sub    $0x8,%esp
f011f6d4:	ff 75 0c             	pushl  0xc(%ebp)
f011f6d7:	50                   	push   %eax
f011f6d8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6db:	ff d0                	call   *%eax
f011f6dd:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011f6e0:	ff 4d e4             	decl   -0x1c(%ebp)
f011f6e3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f6e7:	7f e4                	jg     f011f6cd <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f6e9:	eb 34                	jmp    f011f71f <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011f6eb:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f6ef:	74 1c                	je     f011f70d <vprintfmt+0x207>
f011f6f1:	83 fb 1f             	cmp    $0x1f,%ebx
f011f6f4:	7e 05                	jle    f011f6fb <vprintfmt+0x1f5>
f011f6f6:	83 fb 7e             	cmp    $0x7e,%ebx
f011f6f9:	7e 12                	jle    f011f70d <vprintfmt+0x207>
					putch('?', putdat);
f011f6fb:	83 ec 08             	sub    $0x8,%esp
f011f6fe:	ff 75 0c             	pushl  0xc(%ebp)
f011f701:	6a 3f                	push   $0x3f
f011f703:	8b 45 08             	mov    0x8(%ebp),%eax
f011f706:	ff d0                	call   *%eax
f011f708:	83 c4 10             	add    $0x10,%esp
f011f70b:	eb 0f                	jmp    f011f71c <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011f70d:	83 ec 08             	sub    $0x8,%esp
f011f710:	ff 75 0c             	pushl  0xc(%ebp)
f011f713:	53                   	push   %ebx
f011f714:	8b 45 08             	mov    0x8(%ebp),%eax
f011f717:	ff d0                	call   *%eax
f011f719:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f71c:	ff 4d e4             	decl   -0x1c(%ebp)
f011f71f:	89 f0                	mov    %esi,%eax
f011f721:	8d 70 01             	lea    0x1(%eax),%esi
f011f724:	8a 00                	mov    (%eax),%al
f011f726:	0f be d8             	movsbl %al,%ebx
f011f729:	85 db                	test   %ebx,%ebx
f011f72b:	74 24                	je     f011f751 <vprintfmt+0x24b>
f011f72d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f731:	78 b8                	js     f011f6eb <vprintfmt+0x1e5>
f011f733:	ff 4d e0             	decl   -0x20(%ebp)
f011f736:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f73a:	79 af                	jns    f011f6eb <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f73c:	eb 13                	jmp    f011f751 <vprintfmt+0x24b>
				putch(' ', putdat);
f011f73e:	83 ec 08             	sub    $0x8,%esp
f011f741:	ff 75 0c             	pushl  0xc(%ebp)
f011f744:	6a 20                	push   $0x20
f011f746:	8b 45 08             	mov    0x8(%ebp),%eax
f011f749:	ff d0                	call   *%eax
f011f74b:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f74e:	ff 4d e4             	decl   -0x1c(%ebp)
f011f751:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f755:	7f e7                	jg     f011f73e <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011f757:	e9 78 01 00 00       	jmp    f011f8d4 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011f75c:	83 ec 08             	sub    $0x8,%esp
f011f75f:	ff 75 e8             	pushl  -0x18(%ebp)
f011f762:	8d 45 14             	lea    0x14(%ebp),%eax
f011f765:	50                   	push   %eax
f011f766:	e8 3c fd ff ff       	call   f011f4a7 <getint>
f011f76b:	83 c4 10             	add    $0x10,%esp
f011f76e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f771:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011f774:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f777:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f77a:	85 d2                	test   %edx,%edx
f011f77c:	79 23                	jns    f011f7a1 <vprintfmt+0x29b>
				putch('-', putdat);
f011f77e:	83 ec 08             	sub    $0x8,%esp
f011f781:	ff 75 0c             	pushl  0xc(%ebp)
f011f784:	6a 2d                	push   $0x2d
f011f786:	8b 45 08             	mov    0x8(%ebp),%eax
f011f789:	ff d0                	call   *%eax
f011f78b:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011f78e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f791:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f794:	f7 d8                	neg    %eax
f011f796:	83 d2 00             	adc    $0x0,%edx
f011f799:	f7 da                	neg    %edx
f011f79b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f79e:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011f7a1:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f7a8:	e9 bc 00 00 00       	jmp    f011f869 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011f7ad:	83 ec 08             	sub    $0x8,%esp
f011f7b0:	ff 75 e8             	pushl  -0x18(%ebp)
f011f7b3:	8d 45 14             	lea    0x14(%ebp),%eax
f011f7b6:	50                   	push   %eax
f011f7b7:	e8 84 fc ff ff       	call   f011f440 <getuint>
f011f7bc:	83 c4 10             	add    $0x10,%esp
f011f7bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f7c2:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011f7c5:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f7cc:	e9 98 00 00 00       	jmp    f011f869 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011f7d1:	83 ec 08             	sub    $0x8,%esp
f011f7d4:	ff 75 0c             	pushl  0xc(%ebp)
f011f7d7:	6a 58                	push   $0x58
f011f7d9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7dc:	ff d0                	call   *%eax
f011f7de:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f7e1:	83 ec 08             	sub    $0x8,%esp
f011f7e4:	ff 75 0c             	pushl  0xc(%ebp)
f011f7e7:	6a 58                	push   $0x58
f011f7e9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7ec:	ff d0                	call   *%eax
f011f7ee:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f7f1:	83 ec 08             	sub    $0x8,%esp
f011f7f4:	ff 75 0c             	pushl  0xc(%ebp)
f011f7f7:	6a 58                	push   $0x58
f011f7f9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7fc:	ff d0                	call   *%eax
f011f7fe:	83 c4 10             	add    $0x10,%esp
			break;
f011f801:	e9 ce 00 00 00       	jmp    f011f8d4 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011f806:	83 ec 08             	sub    $0x8,%esp
f011f809:	ff 75 0c             	pushl  0xc(%ebp)
f011f80c:	6a 30                	push   $0x30
f011f80e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f811:	ff d0                	call   *%eax
f011f813:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011f816:	83 ec 08             	sub    $0x8,%esp
f011f819:	ff 75 0c             	pushl  0xc(%ebp)
f011f81c:	6a 78                	push   $0x78
f011f81e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f821:	ff d0                	call   *%eax
f011f823:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011f826:	8b 45 14             	mov    0x14(%ebp),%eax
f011f829:	83 c0 04             	add    $0x4,%eax
f011f82c:	89 45 14             	mov    %eax,0x14(%ebp)
f011f82f:	8b 45 14             	mov    0x14(%ebp),%eax
f011f832:	83 e8 04             	sub    $0x4,%eax
f011f835:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011f837:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f83a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011f841:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011f848:	eb 1f                	jmp    f011f869 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011f84a:	83 ec 08             	sub    $0x8,%esp
f011f84d:	ff 75 e8             	pushl  -0x18(%ebp)
f011f850:	8d 45 14             	lea    0x14(%ebp),%eax
f011f853:	50                   	push   %eax
f011f854:	e8 e7 fb ff ff       	call   f011f440 <getuint>
f011f859:	83 c4 10             	add    $0x10,%esp
f011f85c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f85f:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011f862:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011f869:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011f86d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f870:	83 ec 04             	sub    $0x4,%esp
f011f873:	52                   	push   %edx
f011f874:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f877:	50                   	push   %eax
f011f878:	ff 75 f4             	pushl  -0xc(%ebp)
f011f87b:	ff 75 f0             	pushl  -0x10(%ebp)
f011f87e:	ff 75 0c             	pushl  0xc(%ebp)
f011f881:	ff 75 08             	pushl  0x8(%ebp)
f011f884:	e8 00 fb ff ff       	call   f011f389 <printnum>
f011f889:	83 c4 20             	add    $0x20,%esp
			break;
f011f88c:	eb 46                	jmp    f011f8d4 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011f88e:	83 ec 08             	sub    $0x8,%esp
f011f891:	ff 75 0c             	pushl  0xc(%ebp)
f011f894:	53                   	push   %ebx
f011f895:	8b 45 08             	mov    0x8(%ebp),%eax
f011f898:	ff d0                	call   *%eax
f011f89a:	83 c4 10             	add    $0x10,%esp
			break;
f011f89d:	eb 35                	jmp    f011f8d4 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011f89f:	c6 05 c0 05 6c f0 00 	movb   $0x0,0xf06c05c0
			break;
f011f8a6:	eb 2c                	jmp    f011f8d4 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011f8a8:	c6 05 c0 05 6c f0 01 	movb   $0x1,0xf06c05c0
			break;
f011f8af:	eb 23                	jmp    f011f8d4 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011f8b1:	83 ec 08             	sub    $0x8,%esp
f011f8b4:	ff 75 0c             	pushl  0xc(%ebp)
f011f8b7:	6a 25                	push   $0x25
f011f8b9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8bc:	ff d0                	call   *%eax
f011f8be:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011f8c1:	ff 4d 10             	decl   0x10(%ebp)
f011f8c4:	eb 03                	jmp    f011f8c9 <vprintfmt+0x3c3>
f011f8c6:	ff 4d 10             	decl   0x10(%ebp)
f011f8c9:	8b 45 10             	mov    0x10(%ebp),%eax
f011f8cc:	48                   	dec    %eax
f011f8cd:	8a 00                	mov    (%eax),%al
f011f8cf:	3c 25                	cmp    $0x25,%al
f011f8d1:	75 f3                	jne    f011f8c6 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011f8d3:	90                   	nop
		}
	}
f011f8d4:	e9 35 fc ff ff       	jmp    f011f50e <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011f8d9:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011f8da:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f8dd:	5b                   	pop    %ebx
f011f8de:	5e                   	pop    %esi
f011f8df:	5d                   	pop    %ebp
f011f8e0:	c3                   	ret    

f011f8e1 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011f8e1:	55                   	push   %ebp
f011f8e2:	89 e5                	mov    %esp,%ebp
f011f8e4:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011f8e7:	8d 45 10             	lea    0x10(%ebp),%eax
f011f8ea:	83 c0 04             	add    $0x4,%eax
f011f8ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011f8f0:	8b 45 10             	mov    0x10(%ebp),%eax
f011f8f3:	ff 75 f4             	pushl  -0xc(%ebp)
f011f8f6:	50                   	push   %eax
f011f8f7:	ff 75 0c             	pushl  0xc(%ebp)
f011f8fa:	ff 75 08             	pushl  0x8(%ebp)
f011f8fd:	e8 04 fc ff ff       	call   f011f506 <vprintfmt>
f011f902:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011f905:	90                   	nop
f011f906:	c9                   	leave  
f011f907:	c3                   	ret    

f011f908 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011f908:	55                   	push   %ebp
f011f909:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011f90b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f90e:	8b 40 08             	mov    0x8(%eax),%eax
f011f911:	8d 50 01             	lea    0x1(%eax),%edx
f011f914:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f917:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011f91a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f91d:	8b 10                	mov    (%eax),%edx
f011f91f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f922:	8b 40 04             	mov    0x4(%eax),%eax
f011f925:	39 c2                	cmp    %eax,%edx
f011f927:	73 12                	jae    f011f93b <sprintputch+0x33>
		*b->buf++ = ch;
f011f929:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f92c:	8b 00                	mov    (%eax),%eax
f011f92e:	8d 48 01             	lea    0x1(%eax),%ecx
f011f931:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f934:	89 0a                	mov    %ecx,(%edx)
f011f936:	8b 55 08             	mov    0x8(%ebp),%edx
f011f939:	88 10                	mov    %dl,(%eax)
}
f011f93b:	90                   	nop
f011f93c:	5d                   	pop    %ebp
f011f93d:	c3                   	ret    

f011f93e <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011f93e:	55                   	push   %ebp
f011f93f:	89 e5                	mov    %esp,%ebp
f011f941:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011f944:	8b 45 08             	mov    0x8(%ebp),%eax
f011f947:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f94a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f94d:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f950:	8b 45 08             	mov    0x8(%ebp),%eax
f011f953:	01 d0                	add    %edx,%eax
f011f955:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f958:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011f95f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f963:	74 06                	je     f011f96b <vsnprintf+0x2d>
f011f965:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f969:	7f 07                	jg     f011f972 <vsnprintf+0x34>
		return -E_INVAL;
f011f96b:	b8 03 00 00 00       	mov    $0x3,%eax
f011f970:	eb 20                	jmp    f011f992 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011f972:	ff 75 14             	pushl  0x14(%ebp)
f011f975:	ff 75 10             	pushl  0x10(%ebp)
f011f978:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011f97b:	50                   	push   %eax
f011f97c:	68 08 f9 11 f0       	push   $0xf011f908
f011f981:	e8 80 fb ff ff       	call   f011f506 <vprintfmt>
f011f986:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011f989:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f98c:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011f98f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011f992:	c9                   	leave  
f011f993:	c3                   	ret    

f011f994 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011f994:	55                   	push   %ebp
f011f995:	89 e5                	mov    %esp,%ebp
f011f997:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011f99a:	8d 45 10             	lea    0x10(%ebp),%eax
f011f99d:	83 c0 04             	add    $0x4,%eax
f011f9a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011f9a3:	8b 45 10             	mov    0x10(%ebp),%eax
f011f9a6:	ff 75 f4             	pushl  -0xc(%ebp)
f011f9a9:	50                   	push   %eax
f011f9aa:	ff 75 0c             	pushl  0xc(%ebp)
f011f9ad:	ff 75 08             	pushl  0x8(%ebp)
f011f9b0:	e8 89 ff ff ff       	call   f011f93e <vsnprintf>
f011f9b5:	83 c4 10             	add    $0x10,%esp
f011f9b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011f9bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011f9be:	c9                   	leave  
f011f9bf:	c3                   	ret    

f011f9c0 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011f9c0:	55                   	push   %ebp
f011f9c1:	89 e5                	mov    %esp,%ebp
f011f9c3:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011f9c6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f9ca:	74 13                	je     f011f9df <readline+0x1f>
		cprintf("%s", prompt);
f011f9cc:	83 ec 08             	sub    $0x8,%esp
f011f9cf:	ff 75 08             	pushl  0x8(%ebp)
f011f9d2:	68 08 13 13 f0       	push   $0xf0131308
f011f9d7:	e8 af 15 fe ff       	call   f0100f8b <cprintf>
f011f9dc:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011f9df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011f9e6:	83 ec 0c             	sub    $0xc,%esp
f011f9e9:	6a 00                	push   $0x0
f011f9eb:	e8 a8 14 fe ff       	call   f0100e98 <iscons>
f011f9f0:	83 c4 10             	add    $0x10,%esp
f011f9f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011f9f6:	e8 84 14 fe ff       	call   f0100e7f <getchar>
f011f9fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011f9fe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fa02:	79 22                	jns    f011fa26 <readline+0x66>
			if (c != -E_EOF)
f011fa04:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fa08:	0f 84 ad 00 00 00    	je     f011fabb <readline+0xfb>
				cprintf("read error: %e\n", c);
f011fa0e:	83 ec 08             	sub    $0x8,%esp
f011fa11:	ff 75 ec             	pushl  -0x14(%ebp)
f011fa14:	68 0b 13 13 f0       	push   $0xf013130b
f011fa19:	e8 6d 15 fe ff       	call   f0100f8b <cprintf>
f011fa1e:	83 c4 10             	add    $0x10,%esp
			break;
f011fa21:	e9 95 00 00 00       	jmp    f011fabb <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011fa26:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fa2a:	7e 34                	jle    f011fa60 <readline+0xa0>
f011fa2c:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fa33:	7f 2b                	jg     f011fa60 <readline+0xa0>
			if (echoing)
f011fa35:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fa39:	74 0e                	je     f011fa49 <readline+0x89>
				cputchar(c);
f011fa3b:	83 ec 0c             	sub    $0xc,%esp
f011fa3e:	ff 75 ec             	pushl  -0x14(%ebp)
f011fa41:	e8 22 14 fe ff       	call   f0100e68 <cputchar>
f011fa46:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011fa49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa4c:	8d 50 01             	lea    0x1(%eax),%edx
f011fa4f:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fa52:	89 c2                	mov    %eax,%edx
f011fa54:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa57:	01 d0                	add    %edx,%eax
f011fa59:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fa5c:	88 10                	mov    %dl,(%eax)
f011fa5e:	eb 56                	jmp    f011fab6 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011fa60:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011fa64:	75 1f                	jne    f011fa85 <readline+0xc5>
f011fa66:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fa6a:	7e 19                	jle    f011fa85 <readline+0xc5>
			if (echoing)
f011fa6c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fa70:	74 0e                	je     f011fa80 <readline+0xc0>
				cputchar(c);
f011fa72:	83 ec 0c             	sub    $0xc,%esp
f011fa75:	ff 75 ec             	pushl  -0x14(%ebp)
f011fa78:	e8 eb 13 fe ff       	call   f0100e68 <cputchar>
f011fa7d:	83 c4 10             	add    $0x10,%esp

			i--;
f011fa80:	ff 4d f4             	decl   -0xc(%ebp)
f011fa83:	eb 31                	jmp    f011fab6 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011fa85:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fa89:	74 0a                	je     f011fa95 <readline+0xd5>
f011fa8b:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fa8f:	0f 85 61 ff ff ff    	jne    f011f9f6 <readline+0x36>
			if (echoing)
f011fa95:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fa99:	74 0e                	je     f011faa9 <readline+0xe9>
				cputchar(c);
f011fa9b:	83 ec 0c             	sub    $0xc,%esp
f011fa9e:	ff 75 ec             	pushl  -0x14(%ebp)
f011faa1:	e8 c2 13 fe ff       	call   f0100e68 <cputchar>
f011faa6:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011faa9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011faac:	8b 45 0c             	mov    0xc(%ebp),%eax
f011faaf:	01 d0                	add    %edx,%eax
f011fab1:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011fab4:	eb 06                	jmp    f011fabc <readline+0xfc>
		}
	}
f011fab6:	e9 3b ff ff ff       	jmp    f011f9f6 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011fabb:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011fabc:	90                   	nop
f011fabd:	c9                   	leave  
f011fabe:	c3                   	ret    

f011fabf <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011fabf:	55                   	push   %ebp
f011fac0:	89 e5                	mov    %esp,%ebp
f011fac2:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011fac5:	e8 53 ec fe ff       	call   f010e71d <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011faca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011face:	74 13                	je     f011fae3 <atomic_readline+0x24>
			cprintf("%s", prompt);
f011fad0:	83 ec 08             	sub    $0x8,%esp
f011fad3:	ff 75 08             	pushl  0x8(%ebp)
f011fad6:	68 08 13 13 f0       	push   $0xf0131308
f011fadb:	e8 ab 14 fe ff       	call   f0100f8b <cprintf>
f011fae0:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011fae3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011faea:	83 ec 0c             	sub    $0xc,%esp
f011faed:	6a 00                	push   $0x0
f011faef:	e8 a4 13 fe ff       	call   f0100e98 <iscons>
f011faf4:	83 c4 10             	add    $0x10,%esp
f011faf7:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011fafa:	e8 80 13 fe ff       	call   f0100e7f <getchar>
f011faff:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011fb02:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fb06:	79 22                	jns    f011fb2a <atomic_readline+0x6b>
				if (c != -E_EOF)
f011fb08:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fb0c:	0f 84 ad 00 00 00    	je     f011fbbf <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011fb12:	83 ec 08             	sub    $0x8,%esp
f011fb15:	ff 75 ec             	pushl  -0x14(%ebp)
f011fb18:	68 0b 13 13 f0       	push   $0xf013130b
f011fb1d:	e8 69 14 fe ff       	call   f0100f8b <cprintf>
f011fb22:	83 c4 10             	add    $0x10,%esp
				break;
f011fb25:	e9 95 00 00 00       	jmp    f011fbbf <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011fb2a:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fb2e:	7e 34                	jle    f011fb64 <atomic_readline+0xa5>
f011fb30:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fb37:	7f 2b                	jg     f011fb64 <atomic_readline+0xa5>
				if (echoing)
f011fb39:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fb3d:	74 0e                	je     f011fb4d <atomic_readline+0x8e>
					cputchar(c);
f011fb3f:	83 ec 0c             	sub    $0xc,%esp
f011fb42:	ff 75 ec             	pushl  -0x14(%ebp)
f011fb45:	e8 1e 13 fe ff       	call   f0100e68 <cputchar>
f011fb4a:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011fb4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb50:	8d 50 01             	lea    0x1(%eax),%edx
f011fb53:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fb56:	89 c2                	mov    %eax,%edx
f011fb58:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb5b:	01 d0                	add    %edx,%eax
f011fb5d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fb60:	88 10                	mov    %dl,(%eax)
f011fb62:	eb 56                	jmp    f011fbba <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011fb64:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011fb68:	75 1f                	jne    f011fb89 <atomic_readline+0xca>
f011fb6a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fb6e:	7e 19                	jle    f011fb89 <atomic_readline+0xca>
				if (echoing)
f011fb70:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fb74:	74 0e                	je     f011fb84 <atomic_readline+0xc5>
					cputchar(c);
f011fb76:	83 ec 0c             	sub    $0xc,%esp
f011fb79:	ff 75 ec             	pushl  -0x14(%ebp)
f011fb7c:	e8 e7 12 fe ff       	call   f0100e68 <cputchar>
f011fb81:	83 c4 10             	add    $0x10,%esp
				i--;
f011fb84:	ff 4d f4             	decl   -0xc(%ebp)
f011fb87:	eb 31                	jmp    f011fbba <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011fb89:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fb8d:	74 0a                	je     f011fb99 <atomic_readline+0xda>
f011fb8f:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fb93:	0f 85 61 ff ff ff    	jne    f011fafa <atomic_readline+0x3b>
				if (echoing)
f011fb99:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fb9d:	74 0e                	je     f011fbad <atomic_readline+0xee>
					cputchar(c);
f011fb9f:	83 ec 0c             	sub    $0xc,%esp
f011fba2:	ff 75 ec             	pushl  -0x14(%ebp)
f011fba5:	e8 be 12 fe ff       	call   f0100e68 <cputchar>
f011fbaa:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011fbad:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fbb0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fbb3:	01 d0                	add    %edx,%eax
f011fbb5:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011fbb8:	eb 06                	jmp    f011fbc0 <atomic_readline+0x101>
			}
		}
f011fbba:	e9 3b ff ff ff       	jmp    f011fafa <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011fbbf:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011fbc0:	e8 66 eb fe ff       	call   f010e72b <sys_unlock_cons>
}
f011fbc5:	90                   	nop
f011fbc6:	c9                   	leave  
f011fbc7:	c3                   	ret    

f011fbc8 <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011fbc8:	55                   	push   %ebp
f011fbc9:	89 e5                	mov    %esp,%ebp
f011fbcb:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011fbce:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fbd5:	eb 06                	jmp    f011fbdd <strlen+0x15>
		n++;
f011fbd7:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011fbda:	ff 45 08             	incl   0x8(%ebp)
f011fbdd:	8b 45 08             	mov    0x8(%ebp),%eax
f011fbe0:	8a 00                	mov    (%eax),%al
f011fbe2:	84 c0                	test   %al,%al
f011fbe4:	75 f1                	jne    f011fbd7 <strlen+0xf>
		n++;
	return n;
f011fbe6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fbe9:	c9                   	leave  
f011fbea:	c3                   	ret    

f011fbeb <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011fbeb:	55                   	push   %ebp
f011fbec:	89 e5                	mov    %esp,%ebp
f011fbee:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011fbf1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fbf8:	eb 09                	jmp    f011fc03 <strnlen+0x18>
		n++;
f011fbfa:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011fbfd:	ff 45 08             	incl   0x8(%ebp)
f011fc00:	ff 4d 0c             	decl   0xc(%ebp)
f011fc03:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fc07:	74 09                	je     f011fc12 <strnlen+0x27>
f011fc09:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc0c:	8a 00                	mov    (%eax),%al
f011fc0e:	84 c0                	test   %al,%al
f011fc10:	75 e8                	jne    f011fbfa <strnlen+0xf>
		n++;
	return n;
f011fc12:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fc15:	c9                   	leave  
f011fc16:	c3                   	ret    

f011fc17 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011fc17:	55                   	push   %ebp
f011fc18:	89 e5                	mov    %esp,%ebp
f011fc1a:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011fc1d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc20:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011fc23:	90                   	nop
f011fc24:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc27:	8d 50 01             	lea    0x1(%eax),%edx
f011fc2a:	89 55 08             	mov    %edx,0x8(%ebp)
f011fc2d:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fc30:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fc33:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011fc36:	8a 12                	mov    (%edx),%dl
f011fc38:	88 10                	mov    %dl,(%eax)
f011fc3a:	8a 00                	mov    (%eax),%al
f011fc3c:	84 c0                	test   %al,%al
f011fc3e:	75 e4                	jne    f011fc24 <strcpy+0xd>
		/* do nothing */;
	return ret;
f011fc40:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fc43:	c9                   	leave  
f011fc44:	c3                   	ret    

f011fc45 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011fc45:	55                   	push   %ebp
f011fc46:	89 e5                	mov    %esp,%ebp
f011fc48:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011fc4b:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc4e:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011fc51:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fc58:	eb 1f                	jmp    f011fc79 <strncpy+0x34>
		*dst++ = *src;
f011fc5a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc5d:	8d 50 01             	lea    0x1(%eax),%edx
f011fc60:	89 55 08             	mov    %edx,0x8(%ebp)
f011fc63:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fc66:	8a 12                	mov    (%edx),%dl
f011fc68:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011fc6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fc6d:	8a 00                	mov    (%eax),%al
f011fc6f:	84 c0                	test   %al,%al
f011fc71:	74 03                	je     f011fc76 <strncpy+0x31>
			src++;
f011fc73:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011fc76:	ff 45 fc             	incl   -0x4(%ebp)
f011fc79:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fc7c:	3b 45 10             	cmp    0x10(%ebp),%eax
f011fc7f:	72 d9                	jb     f011fc5a <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011fc81:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011fc84:	c9                   	leave  
f011fc85:	c3                   	ret    

f011fc86 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011fc86:	55                   	push   %ebp
f011fc87:	89 e5                	mov    %esp,%ebp
f011fc89:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011fc8c:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc8f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011fc92:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fc96:	74 30                	je     f011fcc8 <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011fc98:	eb 16                	jmp    f011fcb0 <strlcpy+0x2a>
			*dst++ = *src++;
f011fc9a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc9d:	8d 50 01             	lea    0x1(%eax),%edx
f011fca0:	89 55 08             	mov    %edx,0x8(%ebp)
f011fca3:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fca6:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fca9:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011fcac:	8a 12                	mov    (%edx),%dl
f011fcae:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011fcb0:	ff 4d 10             	decl   0x10(%ebp)
f011fcb3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fcb7:	74 09                	je     f011fcc2 <strlcpy+0x3c>
f011fcb9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcbc:	8a 00                	mov    (%eax),%al
f011fcbe:	84 c0                	test   %al,%al
f011fcc0:	75 d8                	jne    f011fc9a <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011fcc2:	8b 45 08             	mov    0x8(%ebp),%eax
f011fcc5:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011fcc8:	8b 55 08             	mov    0x8(%ebp),%edx
f011fccb:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fcce:	29 c2                	sub    %eax,%edx
f011fcd0:	89 d0                	mov    %edx,%eax
}
f011fcd2:	c9                   	leave  
f011fcd3:	c3                   	ret    

f011fcd4 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011fcd4:	55                   	push   %ebp
f011fcd5:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011fcd7:	eb 06                	jmp    f011fcdf <strcmp+0xb>
		p++, q++;
f011fcd9:	ff 45 08             	incl   0x8(%ebp)
f011fcdc:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011fcdf:	8b 45 08             	mov    0x8(%ebp),%eax
f011fce2:	8a 00                	mov    (%eax),%al
f011fce4:	84 c0                	test   %al,%al
f011fce6:	74 0e                	je     f011fcf6 <strcmp+0x22>
f011fce8:	8b 45 08             	mov    0x8(%ebp),%eax
f011fceb:	8a 10                	mov    (%eax),%dl
f011fced:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcf0:	8a 00                	mov    (%eax),%al
f011fcf2:	38 c2                	cmp    %al,%dl
f011fcf4:	74 e3                	je     f011fcd9 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011fcf6:	8b 45 08             	mov    0x8(%ebp),%eax
f011fcf9:	8a 00                	mov    (%eax),%al
f011fcfb:	0f b6 d0             	movzbl %al,%edx
f011fcfe:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd01:	8a 00                	mov    (%eax),%al
f011fd03:	0f b6 c0             	movzbl %al,%eax
f011fd06:	29 c2                	sub    %eax,%edx
f011fd08:	89 d0                	mov    %edx,%eax
}
f011fd0a:	5d                   	pop    %ebp
f011fd0b:	c3                   	ret    

f011fd0c <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011fd0c:	55                   	push   %ebp
f011fd0d:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011fd0f:	eb 09                	jmp    f011fd1a <strncmp+0xe>
		n--, p++, q++;
f011fd11:	ff 4d 10             	decl   0x10(%ebp)
f011fd14:	ff 45 08             	incl   0x8(%ebp)
f011fd17:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011fd1a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fd1e:	74 17                	je     f011fd37 <strncmp+0x2b>
f011fd20:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd23:	8a 00                	mov    (%eax),%al
f011fd25:	84 c0                	test   %al,%al
f011fd27:	74 0e                	je     f011fd37 <strncmp+0x2b>
f011fd29:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd2c:	8a 10                	mov    (%eax),%dl
f011fd2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd31:	8a 00                	mov    (%eax),%al
f011fd33:	38 c2                	cmp    %al,%dl
f011fd35:	74 da                	je     f011fd11 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011fd37:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fd3b:	75 07                	jne    f011fd44 <strncmp+0x38>
		return 0;
f011fd3d:	b8 00 00 00 00       	mov    $0x0,%eax
f011fd42:	eb 14                	jmp    f011fd58 <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011fd44:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd47:	8a 00                	mov    (%eax),%al
f011fd49:	0f b6 d0             	movzbl %al,%edx
f011fd4c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd4f:	8a 00                	mov    (%eax),%al
f011fd51:	0f b6 c0             	movzbl %al,%eax
f011fd54:	29 c2                	sub    %eax,%edx
f011fd56:	89 d0                	mov    %edx,%eax
}
f011fd58:	5d                   	pop    %ebp
f011fd59:	c3                   	ret    

f011fd5a <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011fd5a:	55                   	push   %ebp
f011fd5b:	89 e5                	mov    %esp,%ebp
f011fd5d:	83 ec 04             	sub    $0x4,%esp
f011fd60:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd63:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011fd66:	eb 12                	jmp    f011fd7a <strchr+0x20>
		if (*s == c)
f011fd68:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd6b:	8a 00                	mov    (%eax),%al
f011fd6d:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011fd70:	75 05                	jne    f011fd77 <strchr+0x1d>
			return (char *) s;
f011fd72:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd75:	eb 11                	jmp    f011fd88 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011fd77:	ff 45 08             	incl   0x8(%ebp)
f011fd7a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd7d:	8a 00                	mov    (%eax),%al
f011fd7f:	84 c0                	test   %al,%al
f011fd81:	75 e5                	jne    f011fd68 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011fd83:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fd88:	c9                   	leave  
f011fd89:	c3                   	ret    

f011fd8a <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011fd8a:	55                   	push   %ebp
f011fd8b:	89 e5                	mov    %esp,%ebp
f011fd8d:	83 ec 04             	sub    $0x4,%esp
f011fd90:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd93:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011fd96:	eb 0d                	jmp    f011fda5 <strfind+0x1b>
		if (*s == c)
f011fd98:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd9b:	8a 00                	mov    (%eax),%al
f011fd9d:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011fda0:	74 0e                	je     f011fdb0 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011fda2:	ff 45 08             	incl   0x8(%ebp)
f011fda5:	8b 45 08             	mov    0x8(%ebp),%eax
f011fda8:	8a 00                	mov    (%eax),%al
f011fdaa:	84 c0                	test   %al,%al
f011fdac:	75 ea                	jne    f011fd98 <strfind+0xe>
f011fdae:	eb 01                	jmp    f011fdb1 <strfind+0x27>
		if (*s == c)
			break;
f011fdb0:	90                   	nop
	return (char *) s;
f011fdb1:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fdb4:	c9                   	leave  
f011fdb5:	c3                   	ret    

f011fdb6 <memset>:


void *
memset(void *v, int c, uint32 n)
{
f011fdb6:	55                   	push   %ebp
f011fdb7:	89 e5                	mov    %esp,%ebp
f011fdb9:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f011fdbc:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdbf:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f011fdc2:	8b 45 10             	mov    0x10(%ebp),%eax
f011fdc5:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f011fdc8:	eb 0e                	jmp    f011fdd8 <memset+0x22>
		*p++ = c;
f011fdca:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fdcd:	8d 50 01             	lea    0x1(%eax),%edx
f011fdd0:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011fdd3:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fdd6:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f011fdd8:	ff 4d f8             	decl   -0x8(%ebp)
f011fddb:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f011fddf:	79 e9                	jns    f011fdca <memset+0x14>
		*p++ = c;

	return v;
f011fde1:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fde4:	c9                   	leave  
f011fde5:	c3                   	ret    

f011fde6 <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011fde6:	55                   	push   %ebp
f011fde7:	89 e5                	mov    %esp,%ebp
f011fde9:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011fdec:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fdef:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011fdf2:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdf5:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f011fdf8:	eb 16                	jmp    f011fe10 <memcpy+0x2a>
		*d++ = *s++;
f011fdfa:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fdfd:	8d 50 01             	lea    0x1(%eax),%edx
f011fe00:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011fe03:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fe06:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fe09:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011fe0c:	8a 12                	mov    (%edx),%dl
f011fe0e:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f011fe10:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe13:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fe16:	89 55 10             	mov    %edx,0x10(%ebp)
f011fe19:	85 c0                	test   %eax,%eax
f011fe1b:	75 dd                	jne    f011fdfa <memcpy+0x14>
		*d++ = *s++;

	return dst;
f011fe1d:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fe20:	c9                   	leave  
f011fe21:	c3                   	ret    

f011fe22 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011fe22:	55                   	push   %ebp
f011fe23:	89 e5                	mov    %esp,%ebp
f011fe25:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011fe28:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe2b:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011fe2e:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe31:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011fe34:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fe37:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011fe3a:	73 50                	jae    f011fe8c <memmove+0x6a>
f011fe3c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fe3f:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe42:	01 d0                	add    %edx,%eax
f011fe44:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011fe47:	76 43                	jbe    f011fe8c <memmove+0x6a>
		s += n;
f011fe49:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe4c:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011fe4f:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe52:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011fe55:	eb 10                	jmp    f011fe67 <memmove+0x45>
			*--d = *--s;
f011fe57:	ff 4d f8             	decl   -0x8(%ebp)
f011fe5a:	ff 4d fc             	decl   -0x4(%ebp)
f011fe5d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fe60:	8a 10                	mov    (%eax),%dl
f011fe62:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fe65:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011fe67:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe6a:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fe6d:	89 55 10             	mov    %edx,0x10(%ebp)
f011fe70:	85 c0                	test   %eax,%eax
f011fe72:	75 e3                	jne    f011fe57 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011fe74:	eb 23                	jmp    f011fe99 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011fe76:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fe79:	8d 50 01             	lea    0x1(%eax),%edx
f011fe7c:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011fe7f:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fe82:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fe85:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011fe88:	8a 12                	mov    (%edx),%dl
f011fe8a:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011fe8c:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe8f:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fe92:	89 55 10             	mov    %edx,0x10(%ebp)
f011fe95:	85 c0                	test   %eax,%eax
f011fe97:	75 dd                	jne    f011fe76 <memmove+0x54>
			*d++ = *s++;

	return dst;
f011fe99:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fe9c:	c9                   	leave  
f011fe9d:	c3                   	ret    

f011fe9e <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011fe9e:	55                   	push   %ebp
f011fe9f:	89 e5                	mov    %esp,%ebp
f011fea1:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011fea4:	8b 45 08             	mov    0x8(%ebp),%eax
f011fea7:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011feaa:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fead:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011feb0:	eb 2a                	jmp    f011fedc <memcmp+0x3e>
		if (*s1 != *s2)
f011feb2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011feb5:	8a 10                	mov    (%eax),%dl
f011feb7:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011feba:	8a 00                	mov    (%eax),%al
f011febc:	38 c2                	cmp    %al,%dl
f011febe:	74 16                	je     f011fed6 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011fec0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fec3:	8a 00                	mov    (%eax),%al
f011fec5:	0f b6 d0             	movzbl %al,%edx
f011fec8:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fecb:	8a 00                	mov    (%eax),%al
f011fecd:	0f b6 c0             	movzbl %al,%eax
f011fed0:	29 c2                	sub    %eax,%edx
f011fed2:	89 d0                	mov    %edx,%eax
f011fed4:	eb 18                	jmp    f011feee <memcmp+0x50>
		s1++, s2++;
f011fed6:	ff 45 fc             	incl   -0x4(%ebp)
f011fed9:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011fedc:	8b 45 10             	mov    0x10(%ebp),%eax
f011fedf:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fee2:	89 55 10             	mov    %edx,0x10(%ebp)
f011fee5:	85 c0                	test   %eax,%eax
f011fee7:	75 c9                	jne    f011feb2 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011fee9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011feee:	c9                   	leave  
f011feef:	c3                   	ret    

f011fef0 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011fef0:	55                   	push   %ebp
f011fef1:	89 e5                	mov    %esp,%ebp
f011fef3:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011fef6:	8b 55 08             	mov    0x8(%ebp),%edx
f011fef9:	8b 45 10             	mov    0x10(%ebp),%eax
f011fefc:	01 d0                	add    %edx,%eax
f011fefe:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011ff01:	eb 15                	jmp    f011ff18 <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011ff03:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff06:	8a 00                	mov    (%eax),%al
f011ff08:	0f b6 d0             	movzbl %al,%edx
f011ff0b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ff0e:	0f b6 c0             	movzbl %al,%eax
f011ff11:	39 c2                	cmp    %eax,%edx
f011ff13:	74 0d                	je     f011ff22 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011ff15:	ff 45 08             	incl   0x8(%ebp)
f011ff18:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff1b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011ff1e:	72 e3                	jb     f011ff03 <memfind+0x13>
f011ff20:	eb 01                	jmp    f011ff23 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011ff22:	90                   	nop
	return (void *) s;
f011ff23:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ff26:	c9                   	leave  
f011ff27:	c3                   	ret    

f011ff28 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011ff28:	55                   	push   %ebp
f011ff29:	89 e5                	mov    %esp,%ebp
f011ff2b:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011ff2e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011ff35:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011ff3c:	eb 03                	jmp    f011ff41 <strtol+0x19>
		s++;
f011ff3e:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011ff41:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff44:	8a 00                	mov    (%eax),%al
f011ff46:	3c 20                	cmp    $0x20,%al
f011ff48:	74 f4                	je     f011ff3e <strtol+0x16>
f011ff4a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff4d:	8a 00                	mov    (%eax),%al
f011ff4f:	3c 09                	cmp    $0x9,%al
f011ff51:	74 eb                	je     f011ff3e <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f011ff53:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff56:	8a 00                	mov    (%eax),%al
f011ff58:	3c 2b                	cmp    $0x2b,%al
f011ff5a:	75 05                	jne    f011ff61 <strtol+0x39>
		s++;
f011ff5c:	ff 45 08             	incl   0x8(%ebp)
f011ff5f:	eb 13                	jmp    f011ff74 <strtol+0x4c>
	else if (*s == '-')
f011ff61:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff64:	8a 00                	mov    (%eax),%al
f011ff66:	3c 2d                	cmp    $0x2d,%al
f011ff68:	75 0a                	jne    f011ff74 <strtol+0x4c>
		s++, neg = 1;
f011ff6a:	ff 45 08             	incl   0x8(%ebp)
f011ff6d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f011ff74:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ff78:	74 06                	je     f011ff80 <strtol+0x58>
f011ff7a:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f011ff7e:	75 20                	jne    f011ffa0 <strtol+0x78>
f011ff80:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff83:	8a 00                	mov    (%eax),%al
f011ff85:	3c 30                	cmp    $0x30,%al
f011ff87:	75 17                	jne    f011ffa0 <strtol+0x78>
f011ff89:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff8c:	40                   	inc    %eax
f011ff8d:	8a 00                	mov    (%eax),%al
f011ff8f:	3c 78                	cmp    $0x78,%al
f011ff91:	75 0d                	jne    f011ffa0 <strtol+0x78>
		s += 2, base = 16;
f011ff93:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f011ff97:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f011ff9e:	eb 28                	jmp    f011ffc8 <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f011ffa0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ffa4:	75 15                	jne    f011ffbb <strtol+0x93>
f011ffa6:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffa9:	8a 00                	mov    (%eax),%al
f011ffab:	3c 30                	cmp    $0x30,%al
f011ffad:	75 0c                	jne    f011ffbb <strtol+0x93>
		s++, base = 8;
f011ffaf:	ff 45 08             	incl   0x8(%ebp)
f011ffb2:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f011ffb9:	eb 0d                	jmp    f011ffc8 <strtol+0xa0>
	else if (base == 0)
f011ffbb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ffbf:	75 07                	jne    f011ffc8 <strtol+0xa0>
		base = 10;
f011ffc1:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f011ffc8:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffcb:	8a 00                	mov    (%eax),%al
f011ffcd:	3c 2f                	cmp    $0x2f,%al
f011ffcf:	7e 19                	jle    f011ffea <strtol+0xc2>
f011ffd1:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffd4:	8a 00                	mov    (%eax),%al
f011ffd6:	3c 39                	cmp    $0x39,%al
f011ffd8:	7f 10                	jg     f011ffea <strtol+0xc2>
			dig = *s - '0';
f011ffda:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffdd:	8a 00                	mov    (%eax),%al
f011ffdf:	0f be c0             	movsbl %al,%eax
f011ffe2:	83 e8 30             	sub    $0x30,%eax
f011ffe5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ffe8:	eb 42                	jmp    f012002c <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f011ffea:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffed:	8a 00                	mov    (%eax),%al
f011ffef:	3c 60                	cmp    $0x60,%al
f011fff1:	7e 19                	jle    f012000c <strtol+0xe4>
f011fff3:	8b 45 08             	mov    0x8(%ebp),%eax
f011fff6:	8a 00                	mov    (%eax),%al
f011fff8:	3c 7a                	cmp    $0x7a,%al
f011fffa:	7f 10                	jg     f012000c <strtol+0xe4>
			dig = *s - 'a' + 10;
f011fffc:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffff:	8a 00                	mov    (%eax),%al
f0120001:	0f be c0             	movsbl %al,%eax
f0120004:	83 e8 57             	sub    $0x57,%eax
f0120007:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012000a:	eb 20                	jmp    f012002c <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f012000c:	8b 45 08             	mov    0x8(%ebp),%eax
f012000f:	8a 00                	mov    (%eax),%al
f0120011:	3c 40                	cmp    $0x40,%al
f0120013:	7e 39                	jle    f012004e <strtol+0x126>
f0120015:	8b 45 08             	mov    0x8(%ebp),%eax
f0120018:	8a 00                	mov    (%eax),%al
f012001a:	3c 5a                	cmp    $0x5a,%al
f012001c:	7f 30                	jg     f012004e <strtol+0x126>
			dig = *s - 'A' + 10;
f012001e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120021:	8a 00                	mov    (%eax),%al
f0120023:	0f be c0             	movsbl %al,%eax
f0120026:	83 e8 37             	sub    $0x37,%eax
f0120029:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f012002c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012002f:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120032:	7d 19                	jge    f012004d <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f0120034:	ff 45 08             	incl   0x8(%ebp)
f0120037:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012003a:	0f af 45 10          	imul   0x10(%ebp),%eax
f012003e:	89 c2                	mov    %eax,%edx
f0120040:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120043:	01 d0                	add    %edx,%eax
f0120045:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f0120048:	e9 7b ff ff ff       	jmp    f011ffc8 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f012004d:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f012004e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120052:	74 08                	je     f012005c <strtol+0x134>
		*endptr = (char *) s;
f0120054:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120057:	8b 55 08             	mov    0x8(%ebp),%edx
f012005a:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f012005c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0120060:	74 07                	je     f0120069 <strtol+0x141>
f0120062:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120065:	f7 d8                	neg    %eax
f0120067:	eb 03                	jmp    f012006c <strtol+0x144>
f0120069:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f012006c:	c9                   	leave  
f012006d:	c3                   	ret    

f012006e <ltostr>:

void
ltostr(long value, char *str)
{
f012006e:	55                   	push   %ebp
f012006f:	89 e5                	mov    %esp,%ebp
f0120071:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f0120074:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f012007b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f0120082:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120086:	79 13                	jns    f012009b <ltostr+0x2d>
	{
		neg = 1;
f0120088:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f012008f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120092:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f0120095:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f0120098:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f012009b:	8b 45 08             	mov    0x8(%ebp),%eax
f012009e:	b9 0a 00 00 00       	mov    $0xa,%ecx
f01200a3:	99                   	cltd   
f01200a4:	f7 f9                	idiv   %ecx
f01200a6:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f01200a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01200ac:	8d 50 01             	lea    0x1(%eax),%edx
f01200af:	89 55 f8             	mov    %edx,-0x8(%ebp)
f01200b2:	89 c2                	mov    %eax,%edx
f01200b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200b7:	01 d0                	add    %edx,%eax
f01200b9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01200bc:	83 c2 30             	add    $0x30,%edx
f01200bf:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f01200c1:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01200c4:	b8 67 66 66 66       	mov    $0x66666667,%eax
f01200c9:	f7 e9                	imul   %ecx
f01200cb:	c1 fa 02             	sar    $0x2,%edx
f01200ce:	89 c8                	mov    %ecx,%eax
f01200d0:	c1 f8 1f             	sar    $0x1f,%eax
f01200d3:	29 c2                	sub    %eax,%edx
f01200d5:	89 d0                	mov    %edx,%eax
f01200d7:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f01200da:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01200de:	75 bb                	jne    f012009b <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f01200e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f01200e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01200ea:	48                   	dec    %eax
f01200eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f01200ee:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01200f2:	74 3d                	je     f0120131 <ltostr+0xc3>
		start = 1 ;
f01200f4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f01200fb:	eb 34                	jmp    f0120131 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f01200fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120100:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120103:	01 d0                	add    %edx,%eax
f0120105:	8a 00                	mov    (%eax),%al
f0120107:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f012010a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012010d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120110:	01 c2                	add    %eax,%edx
f0120112:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0120115:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120118:	01 c8                	add    %ecx,%eax
f012011a:	8a 00                	mov    (%eax),%al
f012011c:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f012011e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120121:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120124:	01 c2                	add    %eax,%edx
f0120126:	8a 45 eb             	mov    -0x15(%ebp),%al
f0120129:	88 02                	mov    %al,(%edx)
		start++ ;
f012012b:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f012012e:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f0120131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120134:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120137:	7c c4                	jl     f01200fd <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f0120139:	8b 55 f8             	mov    -0x8(%ebp),%edx
f012013c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012013f:	01 d0                	add    %edx,%eax
f0120141:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f0120144:	90                   	nop
f0120145:	c9                   	leave  
f0120146:	c3                   	ret    

f0120147 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f0120147:	55                   	push   %ebp
f0120148:	89 e5                	mov    %esp,%ebp
f012014a:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f012014d:	ff 75 08             	pushl  0x8(%ebp)
f0120150:	e8 73 fa ff ff       	call   f011fbc8 <strlen>
f0120155:	83 c4 04             	add    $0x4,%esp
f0120158:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f012015b:	ff 75 0c             	pushl  0xc(%ebp)
f012015e:	e8 65 fa ff ff       	call   f011fbc8 <strlen>
f0120163:	83 c4 04             	add    $0x4,%esp
f0120166:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f0120169:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f0120170:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120177:	eb 17                	jmp    f0120190 <strcconcat+0x49>
		final[s] = str1[s] ;
f0120179:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012017c:	8b 45 10             	mov    0x10(%ebp),%eax
f012017f:	01 c2                	add    %eax,%edx
f0120181:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0120184:	8b 45 08             	mov    0x8(%ebp),%eax
f0120187:	01 c8                	add    %ecx,%eax
f0120189:	8a 00                	mov    (%eax),%al
f012018b:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f012018d:	ff 45 fc             	incl   -0x4(%ebp)
f0120190:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120193:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0120196:	7c e1                	jl     f0120179 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f0120198:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f012019f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f01201a6:	eb 1f                	jmp    f01201c7 <strcconcat+0x80>
		final[s++] = str2[i] ;
f01201a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01201ab:	8d 50 01             	lea    0x1(%eax),%edx
f01201ae:	89 55 fc             	mov    %edx,-0x4(%ebp)
f01201b1:	89 c2                	mov    %eax,%edx
f01201b3:	8b 45 10             	mov    0x10(%ebp),%eax
f01201b6:	01 c2                	add    %eax,%edx
f01201b8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f01201bb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201be:	01 c8                	add    %ecx,%eax
f01201c0:	8a 00                	mov    (%eax),%al
f01201c2:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f01201c4:	ff 45 f8             	incl   -0x8(%ebp)
f01201c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01201ca:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01201cd:	7c d9                	jl     f01201a8 <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f01201cf:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01201d2:	8b 45 10             	mov    0x10(%ebp),%eax
f01201d5:	01 d0                	add    %edx,%eax
f01201d7:	c6 00 00             	movb   $0x0,(%eax)
}
f01201da:	90                   	nop
f01201db:	c9                   	leave  
f01201dc:	c3                   	ret    

f01201dd <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f01201dd:	55                   	push   %ebp
f01201de:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f01201e0:	8b 45 14             	mov    0x14(%ebp),%eax
f01201e3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f01201e9:	8b 45 14             	mov    0x14(%ebp),%eax
f01201ec:	8b 00                	mov    (%eax),%eax
f01201ee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01201f5:	8b 45 10             	mov    0x10(%ebp),%eax
f01201f8:	01 d0                	add    %edx,%eax
f01201fa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0120200:	eb 0c                	jmp    f012020e <strsplit+0x31>
			*string++ = 0;
f0120202:	8b 45 08             	mov    0x8(%ebp),%eax
f0120205:	8d 50 01             	lea    0x1(%eax),%edx
f0120208:	89 55 08             	mov    %edx,0x8(%ebp)
f012020b:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f012020e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120211:	8a 00                	mov    (%eax),%al
f0120213:	84 c0                	test   %al,%al
f0120215:	74 18                	je     f012022f <strsplit+0x52>
f0120217:	8b 45 08             	mov    0x8(%ebp),%eax
f012021a:	8a 00                	mov    (%eax),%al
f012021c:	0f be c0             	movsbl %al,%eax
f012021f:	50                   	push   %eax
f0120220:	ff 75 0c             	pushl  0xc(%ebp)
f0120223:	e8 32 fb ff ff       	call   f011fd5a <strchr>
f0120228:	83 c4 08             	add    $0x8,%esp
f012022b:	85 c0                	test   %eax,%eax
f012022d:	75 d3                	jne    f0120202 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f012022f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120232:	8a 00                	mov    (%eax),%al
f0120234:	84 c0                	test   %al,%al
f0120236:	74 5a                	je     f0120292 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f0120238:	8b 45 14             	mov    0x14(%ebp),%eax
f012023b:	8b 00                	mov    (%eax),%eax
f012023d:	83 f8 0f             	cmp    $0xf,%eax
f0120240:	75 07                	jne    f0120249 <strsplit+0x6c>
		{
			return 0;
f0120242:	b8 00 00 00 00       	mov    $0x0,%eax
f0120247:	eb 66                	jmp    f01202af <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f0120249:	8b 45 14             	mov    0x14(%ebp),%eax
f012024c:	8b 00                	mov    (%eax),%eax
f012024e:	8d 48 01             	lea    0x1(%eax),%ecx
f0120251:	8b 55 14             	mov    0x14(%ebp),%edx
f0120254:	89 0a                	mov    %ecx,(%edx)
f0120256:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f012025d:	8b 45 10             	mov    0x10(%ebp),%eax
f0120260:	01 c2                	add    %eax,%edx
f0120262:	8b 45 08             	mov    0x8(%ebp),%eax
f0120265:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f0120267:	eb 03                	jmp    f012026c <strsplit+0x8f>
			string++;
f0120269:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f012026c:	8b 45 08             	mov    0x8(%ebp),%eax
f012026f:	8a 00                	mov    (%eax),%al
f0120271:	84 c0                	test   %al,%al
f0120273:	74 8b                	je     f0120200 <strsplit+0x23>
f0120275:	8b 45 08             	mov    0x8(%ebp),%eax
f0120278:	8a 00                	mov    (%eax),%al
f012027a:	0f be c0             	movsbl %al,%eax
f012027d:	50                   	push   %eax
f012027e:	ff 75 0c             	pushl  0xc(%ebp)
f0120281:	e8 d4 fa ff ff       	call   f011fd5a <strchr>
f0120286:	83 c4 08             	add    $0x8,%esp
f0120289:	85 c0                	test   %eax,%eax
f012028b:	74 dc                	je     f0120269 <strsplit+0x8c>
			string++;
	}
f012028d:	e9 6e ff ff ff       	jmp    f0120200 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f0120292:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f0120293:	8b 45 14             	mov    0x14(%ebp),%eax
f0120296:	8b 00                	mov    (%eax),%eax
f0120298:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f012029f:	8b 45 10             	mov    0x10(%ebp),%eax
f01202a2:	01 d0                	add    %edx,%eax
f01202a4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f01202aa:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01202af:	c9                   	leave  
f01202b0:	c3                   	ret    

f01202b1 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f01202b1:	55                   	push   %ebp
f01202b2:	89 e5                	mov    %esp,%ebp
f01202b4:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f01202b7:	83 ec 04             	sub    $0x4,%esp
f01202ba:	68 1c 13 13 f0       	push   $0xf013131c
f01202bf:	68 3f 01 00 00       	push   $0x13f
f01202c4:	68 3e 13 13 f0       	push   $0xf013133e
f01202c9:	e8 6b 00 fe ff       	call   f0100339 <_panic>

f01202ce <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f01202ce:	55                   	push   %ebp
f01202cf:	89 e5                	mov    %esp,%ebp
f01202d1:	83 ec 18             	sub    $0x18,%esp
f01202d4:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01202db:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01202de:	89 c2                	mov    %eax,%edx
f01202e0:	ec                   	in     (%dx),%al
f01202e1:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f01202e4:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f01202e7:	0f b6 c0             	movzbl %al,%eax
f01202ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01202ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01202f0:	25 c0 00 00 00       	and    $0xc0,%eax
f01202f5:	83 f8 40             	cmp    $0x40,%eax
f01202f8:	75 10                	jne    f012030a <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f01202fa:	83 ec 0c             	sub    $0xc,%esp
f01202fd:	68 e0 04 6c f0       	push   $0xf06c04e0
f0120302:	e8 6d fd fe ff       	call   f0110074 <wakeup_one>
f0120307:	83 c4 10             	add    $0x10,%esp
	}

}
f012030a:	90                   	nop
f012030b:	c9                   	leave  
f012030c:	c3                   	ret    

f012030d <ide_init>:

void ide_init()
{
f012030d:	55                   	push   %ebp
f012030e:	89 e5                	mov    %esp,%ebp
f0120310:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f0120313:	83 ec 08             	sub    $0x8,%esp
f0120316:	68 ce 02 12 f0       	push   $0xf01202ce
f012031b:	6a 0e                	push   $0xe
f012031d:	e8 02 df fe ff       	call   f010e224 <irq_install_handler>
f0120322:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f0120325:	83 ec 08             	sub    $0x8,%esp
f0120328:	68 4c 13 13 f0       	push   $0xf013134c
f012032d:	68 e0 04 6c f0       	push   $0xf06c04e0
f0120332:	e8 a3 fc fe ff       	call   f010ffda <init_channel>
f0120337:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f012033a:	83 ec 08             	sub    $0x8,%esp
f012033d:	68 59 13 13 f0       	push   $0xf0131359
f0120342:	68 00 0b 6c f0       	push   $0xf06c0b00
f0120347:	e8 9d f8 fe ff       	call   f010fbe9 <init_spinlock>
f012034c:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f012034f:	90                   	nop
f0120350:	c9                   	leave  
f0120351:	c3                   	ret    

f0120352 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f0120352:	55                   	push   %ebp
f0120353:	89 e5                	mov    %esp,%ebp
f0120355:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0120358:	90                   	nop
f0120359:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0120360:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120363:	89 c2                	mov    %eax,%edx
f0120365:	ec                   	in     (%dx),%al
f0120366:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0120369:	8a 45 ef             	mov    -0x11(%ebp),%al
f012036c:	0f b6 c0             	movzbl %al,%eax
f012036f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120372:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120375:	25 c0 00 00 00       	and    $0xc0,%eax
f012037a:	83 f8 40             	cmp    $0x40,%eax
f012037d:	75 da                	jne    f0120359 <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f012037f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120383:	74 24                	je     f01203a9 <ide_wait_ready+0x57>
f0120385:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120388:	83 e0 21             	and    $0x21,%eax
f012038b:	85 c0                	test   %eax,%eax
f012038d:	74 1a                	je     f01203a9 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f012038f:	83 ec 0c             	sub    $0xc,%esp
f0120392:	ff 75 f4             	pushl  -0xc(%ebp)
f0120395:	ff 75 f4             	pushl  -0xc(%ebp)
f0120398:	68 6c 13 13 f0       	push   $0xf013136c
f012039d:	6a 5d                	push   $0x5d
f012039f:	68 8f 13 13 f0       	push   $0xf013138f
f01203a4:	e8 90 ff fd ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f01203a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01203ae:	c9                   	leave  
f01203af:	c3                   	ret    

f01203b0 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f01203b0:	55                   	push   %ebp
f01203b1:	89 e5                	mov    %esp,%ebp
f01203b3:	57                   	push   %edi
f01203b4:	53                   	push   %ebx
f01203b5:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f01203b8:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f01203bf:	76 16                	jbe    f01203d7 <ide_read+0x27>
f01203c1:	68 9a 13 13 f0       	push   $0xf013139a
f01203c6:	68 a7 13 13 f0       	push   $0xf01313a7
f01203cb:	6a 68                	push   $0x68
f01203cd:	68 8f 13 13 f0       	push   $0xf013138f
f01203d2:	e8 62 ff fd ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f01203d7:	83 ec 0c             	sub    $0xc,%esp
f01203da:	6a 00                	push   $0x0
f01203dc:	e8 71 ff ff ff       	call   f0120352 <ide_wait_ready>
f01203e1:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f01203e4:	8b 45 10             	mov    0x10(%ebp),%eax
f01203e7:	0f b6 c0             	movzbl %al,%eax
f01203ea:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f01203f1:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01203f4:	8a 45 d2             	mov    -0x2e(%ebp),%al
f01203f7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01203fa:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f01203fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01203fe:	0f b6 c0             	movzbl %al,%eax
f0120401:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0120408:	88 45 d3             	mov    %al,-0x2d(%ebp)
f012040b:	8a 45 d3             	mov    -0x2d(%ebp),%al
f012040e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120411:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0120412:	8b 45 08             	mov    0x8(%ebp),%eax
f0120415:	c1 e8 08             	shr    $0x8,%eax
f0120418:	0f b6 c0             	movzbl %al,%eax
f012041b:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120422:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120425:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0120428:	8b 55 e8             	mov    -0x18(%ebp),%edx
f012042b:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f012042c:	8b 45 08             	mov    0x8(%ebp),%eax
f012042f:	c1 e8 10             	shr    $0x10,%eax
f0120432:	0f b6 c0             	movzbl %al,%eax
f0120435:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f012043c:	88 45 d5             	mov    %al,-0x2b(%ebp)
f012043f:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120442:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120445:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0120446:	a1 90 03 6c f0       	mov    0xf06c0390,%eax
f012044b:	83 e0 01             	and    $0x1,%eax
f012044e:	c1 e0 04             	shl    $0x4,%eax
f0120451:	88 c2                	mov    %al,%dl
f0120453:	8b 45 08             	mov    0x8(%ebp),%eax
f0120456:	c1 e8 18             	shr    $0x18,%eax
f0120459:	83 e0 0f             	and    $0xf,%eax
f012045c:	09 d0                	or     %edx,%eax
f012045e:	83 c8 e0             	or     $0xffffffe0,%eax
f0120461:	0f b6 c0             	movzbl %al,%eax
f0120464:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f012046b:	88 45 d6             	mov    %al,-0x2a(%ebp)
f012046e:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0120471:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120474:	ee                   	out    %al,(%dx)
f0120475:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f012047c:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f0120480:	8a 45 d7             	mov    -0x29(%ebp),%al
f0120483:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120486:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0120487:	eb 55                	jmp    f01204de <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f0120489:	83 ec 0c             	sub    $0xc,%esp
f012048c:	6a 01                	push   $0x1
f012048e:	e8 bf fe ff ff       	call   f0120352 <ide_wait_ready>
f0120493:	83 c4 10             	add    $0x10,%esp
f0120496:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120499:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012049d:	79 05                	jns    f01204a4 <ide_read+0xf4>
			return r;
f012049f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01204a2:	eb 45                	jmp    f01204e9 <ide_read+0x139>
f01204a4:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f01204ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204ae:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01204b1:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f01204b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01204bb:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f01204be:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01204c1:	89 cb                	mov    %ecx,%ebx
f01204c3:	89 df                	mov    %ebx,%edi
f01204c5:	89 c1                	mov    %eax,%ecx
f01204c7:	fc                   	cld    
f01204c8:	f2 6d                	repnz insl (%dx),%es:(%edi)
f01204ca:	89 c8                	mov    %ecx,%eax
f01204cc:	89 fb                	mov    %edi,%ebx
f01204ce:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f01204d1:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f01204d4:	ff 4d 10             	decl   0x10(%ebp)
f01204d7:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f01204de:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01204e2:	75 a5                	jne    f0120489 <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f01204e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01204e9:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01204ec:	5b                   	pop    %ebx
f01204ed:	5f                   	pop    %edi
f01204ee:	5d                   	pop    %ebp
f01204ef:	c3                   	ret    

f01204f0 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f01204f0:	55                   	push   %ebp
f01204f1:	89 e5                	mov    %esp,%ebp
f01204f3:	56                   	push   %esi
f01204f4:	53                   	push   %ebx
f01204f5:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f01204f8:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f01204ff:	76 19                	jbe    f012051a <ide_write+0x2a>
f0120501:	68 9a 13 13 f0       	push   $0xf013139a
f0120506:	68 a7 13 13 f0       	push   $0xf01313a7
f012050b:	68 82 00 00 00       	push   $0x82
f0120510:	68 8f 13 13 f0       	push   $0xf013138f
f0120515:	e8 1f fe fd ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f012051a:	83 ec 0c             	sub    $0xc,%esp
f012051d:	6a 00                	push   $0x0
f012051f:	e8 2e fe ff ff       	call   f0120352 <ide_wait_ready>
f0120524:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f0120527:	8b 45 10             	mov    0x10(%ebp),%eax
f012052a:	0f b6 c0             	movzbl %al,%eax
f012052d:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0120534:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0120537:	8a 45 d2             	mov    -0x2e(%ebp),%al
f012053a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012053d:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f012053e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120541:	0f b6 c0             	movzbl %al,%eax
f0120544:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f012054b:	88 45 d3             	mov    %al,-0x2d(%ebp)
f012054e:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0120551:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120554:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0120555:	8b 45 08             	mov    0x8(%ebp),%eax
f0120558:	c1 e8 08             	shr    $0x8,%eax
f012055b:	0f b6 c0             	movzbl %al,%eax
f012055e:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120565:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120568:	8a 45 d4             	mov    -0x2c(%ebp),%al
f012056b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f012056e:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f012056f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120572:	c1 e8 10             	shr    $0x10,%eax
f0120575:	0f b6 c0             	movzbl %al,%eax
f0120578:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f012057f:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0120582:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120585:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120588:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0120589:	a1 90 03 6c f0       	mov    0xf06c0390,%eax
f012058e:	83 e0 01             	and    $0x1,%eax
f0120591:	c1 e0 04             	shl    $0x4,%eax
f0120594:	88 c2                	mov    %al,%dl
f0120596:	8b 45 08             	mov    0x8(%ebp),%eax
f0120599:	c1 e8 18             	shr    $0x18,%eax
f012059c:	83 e0 0f             	and    $0xf,%eax
f012059f:	09 d0                	or     %edx,%eax
f01205a1:	83 c8 e0             	or     $0xffffffe0,%eax
f01205a4:	0f b6 c0             	movzbl %al,%eax
f01205a7:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f01205ae:	88 45 d6             	mov    %al,-0x2a(%ebp)
f01205b1:	8a 45 d6             	mov    -0x2a(%ebp),%al
f01205b4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01205b7:	ee                   	out    %al,(%dx)
f01205b8:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f01205bf:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f01205c3:	8a 45 d7             	mov    -0x29(%ebp),%al
f01205c6:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01205c9:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f01205ca:	eb 55                	jmp    f0120621 <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f01205cc:	83 ec 0c             	sub    $0xc,%esp
f01205cf:	6a 01                	push   $0x1
f01205d1:	e8 7c fd ff ff       	call   f0120352 <ide_wait_ready>
f01205d6:	83 c4 10             	add    $0x10,%esp
f01205d9:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01205dc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01205e0:	79 05                	jns    f01205e7 <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f01205e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01205e5:	eb 45                	jmp    f012062c <ide_write+0x13c>
f01205e7:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f01205ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f01205f1:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01205f4:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f01205fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01205fe:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0120601:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120604:	89 cb                	mov    %ecx,%ebx
f0120606:	89 de                	mov    %ebx,%esi
f0120608:	89 c1                	mov    %eax,%ecx
f012060a:	fc                   	cld    
f012060b:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f012060d:	89 c8                	mov    %ecx,%eax
f012060f:	89 f3                	mov    %esi,%ebx
f0120611:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120614:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120617:	ff 4d 10             	decl   0x10(%ebp)
f012061a:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120621:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120625:	75 a5                	jne    f01205cc <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f0120627:	b8 00 00 00 00       	mov    $0x0,%eax
}
f012062c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f012062f:	5b                   	pop    %ebx
f0120630:	5e                   	pop    %esi
f0120631:	5d                   	pop    %ebp
f0120632:	c3                   	ret    

f0120633 <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f0120633:	55                   	push   %ebp
f0120634:	89 e5                	mov    %esp,%ebp
f0120636:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120639:	8b 45 08             	mov    0x8(%ebp),%eax
f012063c:	83 e8 04             	sub    $0x4,%eax
f012063f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f0120642:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120645:	8b 00                	mov    (%eax),%eax
f0120647:	83 e0 fe             	and    $0xfffffffe,%eax
}
f012064a:	c9                   	leave  
f012064b:	c3                   	ret    

f012064c <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f012064c:	55                   	push   %ebp
f012064d:	89 e5                	mov    %esp,%ebp
f012064f:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120652:	8b 45 08             	mov    0x8(%ebp),%eax
f0120655:	83 e8 04             	sub    $0x4,%eax
f0120658:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f012065b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012065e:	8b 00                	mov    (%eax),%eax
f0120660:	83 e0 01             	and    $0x1,%eax
f0120663:	85 c0                	test   %eax,%eax
f0120665:	0f 94 c0             	sete   %al
}
f0120668:	c9                   	leave  
f0120669:	c3                   	ret    

f012066a <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f012066a:	55                   	push   %ebp
f012066b:	89 e5                	mov    %esp,%ebp
f012066d:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f0120670:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f0120677:	8b 45 0c             	mov    0xc(%ebp),%eax
f012067a:	83 f8 02             	cmp    $0x2,%eax
f012067d:	74 2b                	je     f01206aa <alloc_block+0x40>
f012067f:	83 f8 02             	cmp    $0x2,%eax
f0120682:	7f 07                	jg     f012068b <alloc_block+0x21>
f0120684:	83 f8 01             	cmp    $0x1,%eax
f0120687:	74 0e                	je     f0120697 <alloc_block+0x2d>
f0120689:	eb 58                	jmp    f01206e3 <alloc_block+0x79>
f012068b:	83 f8 03             	cmp    $0x3,%eax
f012068e:	74 2d                	je     f01206bd <alloc_block+0x53>
f0120690:	83 f8 04             	cmp    $0x4,%eax
f0120693:	74 3b                	je     f01206d0 <alloc_block+0x66>
f0120695:	eb 4c                	jmp    f01206e3 <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f0120697:	83 ec 0c             	sub    $0xc,%esp
f012069a:	ff 75 08             	pushl  0x8(%ebp)
f012069d:	e8 11 03 00 00       	call   f01209b3 <alloc_block_FF>
f01206a2:	83 c4 10             	add    $0x10,%esp
f01206a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01206a8:	eb 4a                	jmp    f01206f4 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f01206aa:	83 ec 0c             	sub    $0xc,%esp
f01206ad:	ff 75 08             	pushl  0x8(%ebp)
f01206b0:	e8 fa 19 00 00       	call   f01220af <alloc_block_NF>
f01206b5:	83 c4 10             	add    $0x10,%esp
f01206b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01206bb:	eb 37                	jmp    f01206f4 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f01206bd:	83 ec 0c             	sub    $0xc,%esp
f01206c0:	ff 75 08             	pushl  0x8(%ebp)
f01206c3:	e8 a7 07 00 00       	call   f0120e6f <alloc_block_BF>
f01206c8:	83 c4 10             	add    $0x10,%esp
f01206cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01206ce:	eb 24                	jmp    f01206f4 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f01206d0:	83 ec 0c             	sub    $0xc,%esp
f01206d3:	ff 75 08             	pushl  0x8(%ebp)
f01206d6:	e8 b7 19 00 00       	call   f0122092 <alloc_block_WF>
f01206db:	83 c4 10             	add    $0x10,%esp
f01206de:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01206e1:	eb 11                	jmp    f01206f4 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f01206e3:	83 ec 0c             	sub    $0xc,%esp
f01206e6:	68 bc 13 13 f0       	push   $0xf01313bc
f01206eb:	e8 9b 08 fe ff       	call   f0100f8b <cprintf>
f01206f0:	83 c4 10             	add    $0x10,%esp
		break;
f01206f3:	90                   	nop
	}
	return va;
f01206f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01206f7:	c9                   	leave  
f01206f8:	c3                   	ret    

f01206f9 <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f01206f9:	55                   	push   %ebp
f01206fa:	89 e5                	mov    %esp,%ebp
f01206fc:	53                   	push   %ebx
f01206fd:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f0120700:	83 ec 0c             	sub    $0xc,%esp
f0120703:	68 dc 13 13 f0       	push   $0xf01313dc
f0120708:	e8 7e 08 fe ff       	call   f0100f8b <cprintf>
f012070d:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f0120710:	83 ec 0c             	sub    $0xc,%esp
f0120713:	68 07 14 13 f0       	push   $0xf0131407
f0120718:	e8 6e 08 fe ff       	call   f0100f8b <cprintf>
f012071d:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f0120720:	8b 45 08             	mov    0x8(%ebp),%eax
f0120723:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120726:	eb 37                	jmp    f012075f <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0120728:	83 ec 0c             	sub    $0xc,%esp
f012072b:	ff 75 f4             	pushl  -0xc(%ebp)
f012072e:	e8 19 ff ff ff       	call   f012064c <is_free_block>
f0120733:	83 c4 10             	add    $0x10,%esp
f0120736:	0f be d8             	movsbl %al,%ebx
f0120739:	83 ec 0c             	sub    $0xc,%esp
f012073c:	ff 75 f4             	pushl  -0xc(%ebp)
f012073f:	e8 ef fe ff ff       	call   f0120633 <get_block_size>
f0120744:	83 c4 10             	add    $0x10,%esp
f0120747:	83 ec 04             	sub    $0x4,%esp
f012074a:	53                   	push   %ebx
f012074b:	50                   	push   %eax
f012074c:	68 1f 14 13 f0       	push   $0xf013141f
f0120751:	e8 35 08 fe ff       	call   f0100f8b <cprintf>
f0120756:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f0120759:	8b 45 10             	mov    0x10(%ebp),%eax
f012075c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012075f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120763:	74 07                	je     f012076c <print_blocks_list+0x73>
f0120765:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120768:	8b 00                	mov    (%eax),%eax
f012076a:	eb 05                	jmp    f0120771 <print_blocks_list+0x78>
f012076c:	b8 00 00 00 00       	mov    $0x0,%eax
f0120771:	89 45 10             	mov    %eax,0x10(%ebp)
f0120774:	8b 45 10             	mov    0x10(%ebp),%eax
f0120777:	85 c0                	test   %eax,%eax
f0120779:	75 ad                	jne    f0120728 <print_blocks_list+0x2f>
f012077b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012077f:	75 a7                	jne    f0120728 <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f0120781:	83 ec 0c             	sub    $0xc,%esp
f0120784:	68 dc 13 13 f0       	push   $0xf01313dc
f0120789:	e8 fd 07 fe ff       	call   f0100f8b <cprintf>
f012078e:	83 c4 10             	add    $0x10,%esp

}
f0120791:	90                   	nop
f0120792:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0120795:	c9                   	leave  
f0120796:	c3                   	ret    

f0120797 <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f0120797:	55                   	push   %ebp
f0120798:	89 e5                	mov    %esp,%ebp
f012079a:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f012079d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01207a0:	83 e0 01             	and    $0x1,%eax
f01207a3:	85 c0                	test   %eax,%eax
f01207a5:	74 03                	je     f01207aa <initialize_dynamic_allocator+0x13>
f01207a7:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f01207aa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01207ae:	0f 84 c7 01 00 00    	je     f012097b <initialize_dynamic_allocator+0x1e4>
                return ;
            is_initialized = 1;
f01207b4:	c7 05 94 03 6c f0 01 	movl   $0x1,0xf06c0394
f01207bb:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f01207be:	8b 55 08             	mov    0x8(%ebp),%edx
f01207c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01207c4:	01 d0                	add    %edx,%eax
f01207c6:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f01207cb:	0f 87 ad 01 00 00    	ja     f012097e <initialize_dynamic_allocator+0x1e7>
        return;
    if(daStart < USER_HEAP_START)
f01207d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01207d4:	85 c0                	test   %eax,%eax
f01207d6:	0f 89 a5 01 00 00    	jns    f0120981 <initialize_dynamic_allocator+0x1ea>
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
f01207dc:	8b 55 08             	mov    0x8(%ebp),%edx
f01207df:	8b 45 0c             	mov    0xc(%ebp),%eax
f01207e2:	01 d0                	add    %edx,%eax
f01207e4:	83 e8 04             	sub    $0x4,%eax
f01207e7:	a3 34 0d 6c f0       	mov    %eax,0xf06c0d34
     struct BlockElement * element = NULL;
f01207ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f01207f3:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f01207f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01207fb:	e9 87 00 00 00       	jmp    f0120887 <initialize_dynamic_allocator+0xf0>
     {
        LIST_REMOVE(&freeBlocksList,element);
f0120800:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120804:	75 14                	jne    f012081a <initialize_dynamic_allocator+0x83>
f0120806:	83 ec 04             	sub    $0x4,%esp
f0120809:	68 37 14 13 f0       	push   $0xf0131437
f012080e:	6a 79                	push   $0x79
f0120810:	68 55 14 13 f0       	push   $0xf0131455
f0120815:	e8 1f fb fd ff       	call   f0100339 <_panic>
f012081a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012081d:	8b 00                	mov    (%eax),%eax
f012081f:	85 c0                	test   %eax,%eax
f0120821:	74 10                	je     f0120833 <initialize_dynamic_allocator+0x9c>
f0120823:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120826:	8b 00                	mov    (%eax),%eax
f0120828:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012082b:	8b 52 04             	mov    0x4(%edx),%edx
f012082e:	89 50 04             	mov    %edx,0x4(%eax)
f0120831:	eb 0b                	jmp    f012083e <initialize_dynamic_allocator+0xa7>
f0120833:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120836:	8b 40 04             	mov    0x4(%eax),%eax
f0120839:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f012083e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120841:	8b 40 04             	mov    0x4(%eax),%eax
f0120844:	85 c0                	test   %eax,%eax
f0120846:	74 0f                	je     f0120857 <initialize_dynamic_allocator+0xc0>
f0120848:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012084b:	8b 40 04             	mov    0x4(%eax),%eax
f012084e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120851:	8b 12                	mov    (%edx),%edx
f0120853:	89 10                	mov    %edx,(%eax)
f0120855:	eb 0a                	jmp    f0120861 <initialize_dynamic_allocator+0xca>
f0120857:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012085a:	8b 00                	mov    (%eax),%eax
f012085c:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0120861:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120864:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012086a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012086d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120874:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0120879:	48                   	dec    %eax
f012087a:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
        return;
    if(daStart < USER_HEAP_START)
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f012087f:	a1 18 07 6c f0       	mov    0xf06c0718,%eax
f0120884:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120887:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012088b:	74 07                	je     f0120894 <initialize_dynamic_allocator+0xfd>
f012088d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120890:	8b 00                	mov    (%eax),%eax
f0120892:	eb 05                	jmp    f0120899 <initialize_dynamic_allocator+0x102>
f0120894:	b8 00 00 00 00       	mov    $0x0,%eax
f0120899:	a3 18 07 6c f0       	mov    %eax,0xf06c0718
f012089e:	a1 18 07 6c f0       	mov    0xf06c0718,%eax
f01208a3:	85 c0                	test   %eax,%eax
f01208a5:	0f 85 55 ff ff ff    	jne    f0120800 <initialize_dynamic_allocator+0x69>
f01208ab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01208af:	0f 85 4b ff ff ff    	jne    f0120800 <initialize_dynamic_allocator+0x69>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f01208b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01208b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f01208bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01208be:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    end_block = (struct Block_Start_End*) (end_add);
f01208c4:	a1 34 0d 6c f0       	mov    0xf06c0d34,%eax
f01208c9:	a3 70 0b 6c f0       	mov    %eax,0xf06c0b70
    end_block->info = 1;
f01208ce:	a1 70 0b 6c f0       	mov    0xf06c0b70,%eax
f01208d3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f01208d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01208dc:	83 c0 08             	add    $0x8,%eax
f01208df:	89 45 ec             	mov    %eax,-0x14(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f01208e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01208e5:	83 c0 04             	add    $0x4,%eax
f01208e8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01208eb:	83 ea 08             	sub    $0x8,%edx
f01208ee:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f01208f0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01208f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01208f6:	01 d0                	add    %edx,%eax
f01208f8:	83 e8 08             	sub    $0x8,%eax
f01208fb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01208fe:	83 ea 08             	sub    $0x8,%edx
f0120901:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f0120903:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120906:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f012090c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012090f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f0120916:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012091a:	75 17                	jne    f0120933 <initialize_dynamic_allocator+0x19c>
f012091c:	83 ec 04             	sub    $0x4,%esp
f012091f:	68 70 14 13 f0       	push   $0xf0131470
f0120924:	68 90 00 00 00       	push   $0x90
f0120929:	68 55 14 13 f0       	push   $0xf0131455
f012092e:	e8 06 fa fd ff       	call   f0100339 <_panic>
f0120933:	8b 15 10 07 6c f0    	mov    0xf06c0710,%edx
f0120939:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012093c:	89 10                	mov    %edx,(%eax)
f012093e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120941:	8b 00                	mov    (%eax),%eax
f0120943:	85 c0                	test   %eax,%eax
f0120945:	74 0d                	je     f0120954 <initialize_dynamic_allocator+0x1bd>
f0120947:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f012094c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012094f:	89 50 04             	mov    %edx,0x4(%eax)
f0120952:	eb 08                	jmp    f012095c <initialize_dynamic_allocator+0x1c5>
f0120954:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120957:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f012095c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012095f:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0120964:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120967:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012096e:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0120973:	40                   	inc    %eax
f0120974:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
f0120979:	eb 07                	jmp    f0120982 <initialize_dynamic_allocator+0x1eb>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f012097b:	90                   	nop
f012097c:	eb 04                	jmp    f0120982 <initialize_dynamic_allocator+0x1eb>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f012097e:	90                   	nop
f012097f:	eb 01                	jmp    f0120982 <initialize_dynamic_allocator+0x1eb>
    if(daStart < USER_HEAP_START)
        return;
f0120981:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f0120982:	c9                   	leave  
f0120983:	c3                   	ret    

f0120984 <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f0120984:	55                   	push   %ebp
f0120985:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f0120987:	8b 45 10             	mov    0x10(%ebp),%eax
f012098a:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f012098d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120990:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120993:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120996:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f0120998:	8b 45 08             	mov    0x8(%ebp),%eax
f012099b:	83 e8 04             	sub    $0x4,%eax
f012099e:	8b 00                	mov    (%eax),%eax
f01209a0:	83 e0 fe             	and    $0xfffffffe,%eax
f01209a3:	8d 50 f8             	lea    -0x8(%eax),%edx
f01209a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01209a9:	01 c2                	add    %eax,%edx
f01209ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f01209ae:	89 02                	mov    %eax,(%edx)
}
f01209b0:	90                   	nop
f01209b1:	5d                   	pop    %ebp
f01209b2:	c3                   	ret    

f01209b3 <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f01209b3:	55                   	push   %ebp
f01209b4:	89 e5                	mov    %esp,%ebp
f01209b6:	83 ec 58             	sub    $0x58,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f01209b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01209bc:	83 e0 01             	and    $0x1,%eax
f01209bf:	85 c0                	test   %eax,%eax
f01209c1:	74 03                	je     f01209c6 <alloc_block_FF+0x13>
f01209c3:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f01209c6:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f01209ca:	77 07                	ja     f01209d3 <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f01209cc:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f01209d3:	a1 94 03 6c f0       	mov    0xf06c0394,%eax
f01209d8:	85 c0                	test   %eax,%eax
f01209da:	75 73                	jne    f0120a4f <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f01209dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01209df:	83 c0 10             	add    $0x10,%eax
f01209e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f01209e5:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f01209ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01209ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209f2:	01 d0                	add    %edx,%eax
f01209f4:	48                   	dec    %eax
f01209f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01209f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01209fb:	ba 00 00 00 00       	mov    $0x0,%edx
f0120a00:	f7 75 ec             	divl   -0x14(%ebp)
f0120a03:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120a06:	29 d0                	sub    %edx,%eax
f0120a08:	c1 e8 0c             	shr    $0xc,%eax
f0120a0b:	83 ec 0c             	sub    $0xc,%esp
f0120a0e:	50                   	push   %eax
f0120a0f:	e8 4a 89 fe ff       	call   f010935e <sbrk>
f0120a14:	83 c4 10             	add    $0x10,%esp
f0120a17:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120a1a:	83 ec 0c             	sub    $0xc,%esp
f0120a1d:	6a 00                	push   $0x0
f0120a1f:	e8 3a 89 fe ff       	call   f010935e <sbrk>
f0120a24:	83 c4 10             	add    $0x10,%esp
f0120a27:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120a2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120a2d:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0120a30:	83 ec 08             	sub    $0x8,%esp
f0120a33:	50                   	push   %eax
f0120a34:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120a37:	e8 5b fd ff ff       	call   f0120797 <initialize_dynamic_allocator>
f0120a3c:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120a3f:	83 ec 0c             	sub    $0xc,%esp
f0120a42:	68 93 14 13 f0       	push   $0xf0131493
f0120a47:	e8 3f 05 fe ff       	call   f0100f8b <cprintf>
f0120a4c:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f0120a4f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120a53:	75 0a                	jne    f0120a5f <alloc_block_FF+0xac>
	        return NULL;
f0120a55:	b8 00 00 00 00       	mov    $0x0,%eax
f0120a5a:	e9 0e 04 00 00       	jmp    f0120e6d <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
f0120a5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120a66:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f0120a6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120a6e:	e9 f3 02 00 00       	jmp    f0120d66 <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f0120a73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a76:	89 45 bc             	mov    %eax,-0x44(%ebp)
	        uint32 blk_size = get_block_size(va);
f0120a79:	83 ec 0c             	sub    $0xc,%esp
f0120a7c:	ff 75 bc             	pushl  -0x44(%ebp)
f0120a7f:	e8 af fb ff ff       	call   f0120633 <get_block_size>
f0120a84:	83 c4 10             	add    $0x10,%esp
f0120a87:	89 45 b8             	mov    %eax,-0x48(%ebp)

	        if(blk_size >= size + 2 * sizeof(uint32)) {
f0120a8a:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a8d:	83 c0 08             	add    $0x8,%eax
f0120a90:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120a93:	0f 87 c5 02 00 00    	ja     f0120d5e <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120a99:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a9c:	83 c0 18             	add    $0x18,%eax
f0120a9f:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120aa2:	0f 87 19 02 00 00    	ja     f0120cc1 <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f0120aa8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120aab:	2b 45 08             	sub    0x8(%ebp),%eax
f0120aae:	83 e8 08             	sub    $0x8,%eax
f0120ab1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32));
f0120ab4:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ab7:	8d 50 08             	lea    0x8(%eax),%edx
f0120aba:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120abd:	01 d0                	add    %edx,%eax
f0120abf:	89 45 b0             	mov    %eax,-0x50(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f0120ac2:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ac5:	83 c0 08             	add    $0x8,%eax
f0120ac8:	83 ec 04             	sub    $0x4,%esp
f0120acb:	6a 01                	push   $0x1
f0120acd:	50                   	push   %eax
f0120ace:	ff 75 bc             	pushl  -0x44(%ebp)
f0120ad1:	e8 ae fe ff ff       	call   f0120984 <set_block_data>
f0120ad6:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f0120ad9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120adc:	8b 40 04             	mov    0x4(%eax),%eax
f0120adf:	85 c0                	test   %eax,%eax
f0120ae1:	75 68                	jne    f0120b4b <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120ae3:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120ae7:	75 17                	jne    f0120b00 <alloc_block_FF+0x14d>
f0120ae9:	83 ec 04             	sub    $0x4,%esp
f0120aec:	68 70 14 13 f0       	push   $0xf0131470
f0120af1:	68 d7 00 00 00       	push   $0xd7
f0120af6:	68 55 14 13 f0       	push   $0xf0131455
f0120afb:	e8 39 f8 fd ff       	call   f0100339 <_panic>
f0120b00:	8b 15 10 07 6c f0    	mov    0xf06c0710,%edx
f0120b06:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b09:	89 10                	mov    %edx,(%eax)
f0120b0b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b0e:	8b 00                	mov    (%eax),%eax
f0120b10:	85 c0                	test   %eax,%eax
f0120b12:	74 0d                	je     f0120b21 <alloc_block_FF+0x16e>
f0120b14:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f0120b19:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120b1c:	89 50 04             	mov    %edx,0x4(%eax)
f0120b1f:	eb 08                	jmp    f0120b29 <alloc_block_FF+0x176>
f0120b21:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b24:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0120b29:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b2c:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0120b31:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b34:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120b3b:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0120b40:	40                   	inc    %eax
f0120b41:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
f0120b46:	e9 dc 00 00 00       	jmp    f0120c27 <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f0120b4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b4e:	8b 00                	mov    (%eax),%eax
f0120b50:	85 c0                	test   %eax,%eax
f0120b52:	75 65                	jne    f0120bb9 <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120b54:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120b58:	75 17                	jne    f0120b71 <alloc_block_FF+0x1be>
f0120b5a:	83 ec 04             	sub    $0x4,%esp
f0120b5d:	68 a4 14 13 f0       	push   $0xf01314a4
f0120b62:	68 db 00 00 00       	push   $0xdb
f0120b67:	68 55 14 13 f0       	push   $0xf0131455
f0120b6c:	e8 c8 f7 fd ff       	call   f0100339 <_panic>
f0120b71:	8b 15 14 07 6c f0    	mov    0xf06c0714,%edx
f0120b77:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b7a:	89 50 04             	mov    %edx,0x4(%eax)
f0120b7d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b80:	8b 40 04             	mov    0x4(%eax),%eax
f0120b83:	85 c0                	test   %eax,%eax
f0120b85:	74 0c                	je     f0120b93 <alloc_block_FF+0x1e0>
f0120b87:	a1 14 07 6c f0       	mov    0xf06c0714,%eax
f0120b8c:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120b8f:	89 10                	mov    %edx,(%eax)
f0120b91:	eb 08                	jmp    f0120b9b <alloc_block_FF+0x1e8>
f0120b93:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b96:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0120b9b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120b9e:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0120ba3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ba6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120bac:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0120bb1:	40                   	inc    %eax
f0120bb2:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
f0120bb7:	eb 6e                	jmp    f0120c27 <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f0120bb9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120bbd:	74 06                	je     f0120bc5 <alloc_block_FF+0x212>
f0120bbf:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120bc3:	75 17                	jne    f0120bdc <alloc_block_FF+0x229>
f0120bc5:	83 ec 04             	sub    $0x4,%esp
f0120bc8:	68 c8 14 13 f0       	push   $0xf01314c8
f0120bcd:	68 df 00 00 00       	push   $0xdf
f0120bd2:	68 55 14 13 f0       	push   $0xf0131455
f0120bd7:	e8 5d f7 fd ff       	call   f0100339 <_panic>
f0120bdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bdf:	8b 10                	mov    (%eax),%edx
f0120be1:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120be4:	89 10                	mov    %edx,(%eax)
f0120be6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120be9:	8b 00                	mov    (%eax),%eax
f0120beb:	85 c0                	test   %eax,%eax
f0120bed:	74 0b                	je     f0120bfa <alloc_block_FF+0x247>
f0120bef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bf2:	8b 00                	mov    (%eax),%eax
f0120bf4:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120bf7:	89 50 04             	mov    %edx,0x4(%eax)
f0120bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bfd:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120c00:	89 10                	mov    %edx,(%eax)
f0120c02:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c05:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120c08:	89 50 04             	mov    %edx,0x4(%eax)
f0120c0b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c0e:	8b 00                	mov    (%eax),%eax
f0120c10:	85 c0                	test   %eax,%eax
f0120c12:	75 08                	jne    f0120c1c <alloc_block_FF+0x269>
f0120c14:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c17:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0120c1c:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0120c21:	40                   	inc    %eax
f0120c22:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
				}
				LIST_REMOVE(&freeBlocksList, blk);
f0120c27:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120c2b:	75 17                	jne    f0120c44 <alloc_block_FF+0x291>
f0120c2d:	83 ec 04             	sub    $0x4,%esp
f0120c30:	68 37 14 13 f0       	push   $0xf0131437
f0120c35:	68 e1 00 00 00       	push   $0xe1
f0120c3a:	68 55 14 13 f0       	push   $0xf0131455
f0120c3f:	e8 f5 f6 fd ff       	call   f0100339 <_panic>
f0120c44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c47:	8b 00                	mov    (%eax),%eax
f0120c49:	85 c0                	test   %eax,%eax
f0120c4b:	74 10                	je     f0120c5d <alloc_block_FF+0x2aa>
f0120c4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c50:	8b 00                	mov    (%eax),%eax
f0120c52:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120c55:	8b 52 04             	mov    0x4(%edx),%edx
f0120c58:	89 50 04             	mov    %edx,0x4(%eax)
f0120c5b:	eb 0b                	jmp    f0120c68 <alloc_block_FF+0x2b5>
f0120c5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c60:	8b 40 04             	mov    0x4(%eax),%eax
f0120c63:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0120c68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c6b:	8b 40 04             	mov    0x4(%eax),%eax
f0120c6e:	85 c0                	test   %eax,%eax
f0120c70:	74 0f                	je     f0120c81 <alloc_block_FF+0x2ce>
f0120c72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c75:	8b 40 04             	mov    0x4(%eax),%eax
f0120c78:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120c7b:	8b 12                	mov    (%edx),%edx
f0120c7d:	89 10                	mov    %edx,(%eax)
f0120c7f:	eb 0a                	jmp    f0120c8b <alloc_block_FF+0x2d8>
f0120c81:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c84:	8b 00                	mov    (%eax),%eax
f0120c86:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0120c8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c8e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120c94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c97:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120c9e:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0120ca3:	48                   	dec    %eax
f0120ca4:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
				set_block_data(new_block_va, remaining_size, 0);
f0120ca9:	83 ec 04             	sub    $0x4,%esp
f0120cac:	6a 00                	push   $0x0
f0120cae:	ff 75 b4             	pushl  -0x4c(%ebp)
f0120cb1:	ff 75 b0             	pushl  -0x50(%ebp)
f0120cb4:	e8 cb fc ff ff       	call   f0120984 <set_block_data>
f0120cb9:	83 c4 10             	add    $0x10,%esp
f0120cbc:	e9 95 00 00 00       	jmp    f0120d56 <alloc_block_FF+0x3a3>
	            }
	            else
	            {

	            	set_block_data(va, blk_size, 1);
f0120cc1:	83 ec 04             	sub    $0x4,%esp
f0120cc4:	6a 01                	push   $0x1
f0120cc6:	ff 75 b8             	pushl  -0x48(%ebp)
f0120cc9:	ff 75 bc             	pushl  -0x44(%ebp)
f0120ccc:	e8 b3 fc ff ff       	call   f0120984 <set_block_data>
f0120cd1:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f0120cd4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120cd8:	75 17                	jne    f0120cf1 <alloc_block_FF+0x33e>
f0120cda:	83 ec 04             	sub    $0x4,%esp
f0120cdd:	68 37 14 13 f0       	push   $0xf0131437
f0120ce2:	68 e8 00 00 00       	push   $0xe8
f0120ce7:	68 55 14 13 f0       	push   $0xf0131455
f0120cec:	e8 48 f6 fd ff       	call   f0100339 <_panic>
f0120cf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cf4:	8b 00                	mov    (%eax),%eax
f0120cf6:	85 c0                	test   %eax,%eax
f0120cf8:	74 10                	je     f0120d0a <alloc_block_FF+0x357>
f0120cfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cfd:	8b 00                	mov    (%eax),%eax
f0120cff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120d02:	8b 52 04             	mov    0x4(%edx),%edx
f0120d05:	89 50 04             	mov    %edx,0x4(%eax)
f0120d08:	eb 0b                	jmp    f0120d15 <alloc_block_FF+0x362>
f0120d0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d0d:	8b 40 04             	mov    0x4(%eax),%eax
f0120d10:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0120d15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d18:	8b 40 04             	mov    0x4(%eax),%eax
f0120d1b:	85 c0                	test   %eax,%eax
f0120d1d:	74 0f                	je     f0120d2e <alloc_block_FF+0x37b>
f0120d1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d22:	8b 40 04             	mov    0x4(%eax),%eax
f0120d25:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120d28:	8b 12                	mov    (%edx),%edx
f0120d2a:	89 10                	mov    %edx,(%eax)
f0120d2c:	eb 0a                	jmp    f0120d38 <alloc_block_FF+0x385>
f0120d2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d31:	8b 00                	mov    (%eax),%eax
f0120d33:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0120d38:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d3b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120d41:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d44:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120d4b:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0120d50:	48                   	dec    %eax
f0120d51:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
	            }
	            return va;
f0120d56:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120d59:	e9 0f 01 00 00       	jmp    f0120e6d <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120d5e:	a1 18 07 6c f0       	mov    0xf06c0718,%eax
f0120d63:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120d66:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120d6a:	74 07                	je     f0120d73 <alloc_block_FF+0x3c0>
f0120d6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d6f:	8b 00                	mov    (%eax),%eax
f0120d71:	eb 05                	jmp    f0120d78 <alloc_block_FF+0x3c5>
f0120d73:	b8 00 00 00 00       	mov    $0x0,%eax
f0120d78:	a3 18 07 6c f0       	mov    %eax,0xf06c0718
f0120d7d:	a1 18 07 6c f0       	mov    0xf06c0718,%eax
f0120d82:	85 c0                	test   %eax,%eax
f0120d84:	0f 85 e9 fc ff ff    	jne    f0120a73 <alloc_block_FF+0xc0>
f0120d8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120d8e:	0f 85 df fc ff ff    	jne    f0120a73 <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f0120d94:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d97:	83 c0 08             	add    $0x8,%eax
f0120d9a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0120d9d:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f0120da4:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120da7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0120daa:	01 d0                	add    %edx,%eax
f0120dac:	48                   	dec    %eax
f0120dad:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0120db0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120db3:	ba 00 00 00 00       	mov    $0x0,%edx
f0120db8:	f7 75 d8             	divl   -0x28(%ebp)
f0120dbb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120dbe:	29 d0                	sub    %edx,%eax
f0120dc0:	c1 e8 0c             	shr    $0xc,%eax
f0120dc3:	83 ec 0c             	sub    $0xc,%esp
f0120dc6:	50                   	push   %eax
f0120dc7:	e8 92 85 fe ff       	call   f010935e <sbrk>
f0120dcc:	83 c4 10             	add    $0x10,%esp
f0120dcf:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f0120dd2:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f0120dd6:	75 0a                	jne    f0120de2 <alloc_block_FF+0x42f>
			return NULL; // Allocation failed
f0120dd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0120ddd:	e9 8b 00 00 00       	jmp    f0120e6d <alloc_block_FF+0x4ba>
		}
		else {
			end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f0120de2:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f0120de9:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120dec:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120def:	01 d0                	add    %edx,%eax
f0120df1:	48                   	dec    %eax
f0120df2:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0120df5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120df8:	ba 00 00 00 00       	mov    $0x0,%edx
f0120dfd:	f7 75 cc             	divl   -0x34(%ebp)
f0120e00:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120e03:	29 d0                	sub    %edx,%eax
f0120e05:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120e08:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120e0b:	01 d0                	add    %edx,%eax
f0120e0d:	a3 70 0b 6c f0       	mov    %eax,0xf06c0b70
			end_block->info = 1;
f0120e12:	a1 70 0b 6c f0       	mov    0xf06c0b70,%eax
f0120e17:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0120e1d:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0120e24:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120e27:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120e2a:	01 d0                	add    %edx,%eax
f0120e2c:	48                   	dec    %eax
f0120e2d:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0120e30:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120e33:	ba 00 00 00 00       	mov    $0x0,%edx
f0120e38:	f7 75 c4             	divl   -0x3c(%ebp)
f0120e3b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120e3e:	29 d0                	sub    %edx,%eax
f0120e40:	83 ec 04             	sub    $0x4,%esp
f0120e43:	6a 01                	push   $0x1
f0120e45:	50                   	push   %eax
f0120e46:	ff 75 d0             	pushl  -0x30(%ebp)
f0120e49:	e8 36 fb ff ff       	call   f0120984 <set_block_data>
f0120e4e:	83 c4 10             	add    $0x10,%esp
		free_block(new_mem);
f0120e51:	83 ec 0c             	sub    $0xc,%esp
f0120e54:	ff 75 d0             	pushl  -0x30(%ebp)
f0120e57:	e8 1b 0a 00 00       	call   f0121877 <free_block>
f0120e5c:	83 c4 10             	add    $0x10,%esp
		return alloc_block_FF(size);
f0120e5f:	83 ec 0c             	sub    $0xc,%esp
f0120e62:	ff 75 08             	pushl  0x8(%ebp)
f0120e65:	e8 49 fb ff ff       	call   f01209b3 <alloc_block_FF>
f0120e6a:	83 c4 10             	add    $0x10,%esp
		}
		return new_mem;
}
f0120e6d:	c9                   	leave  
f0120e6e:	c3                   	ret    

f0120e6f <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f0120e6f:	55                   	push   %ebp
f0120e70:	89 e5                	mov    %esp,%ebp
f0120e72:	83 ec 68             	sub    $0x68,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120e75:	8b 45 08             	mov    0x8(%ebp),%eax
f0120e78:	83 e0 01             	and    $0x1,%eax
f0120e7b:	85 c0                	test   %eax,%eax
f0120e7d:	74 03                	je     f0120e82 <alloc_block_BF+0x13>
f0120e7f:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120e82:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120e86:	77 07                	ja     f0120e8f <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120e88:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0120e8f:	a1 94 03 6c f0       	mov    0xf06c0394,%eax
f0120e94:	85 c0                	test   %eax,%eax
f0120e96:	75 73                	jne    f0120f0b <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0120e98:	8b 45 08             	mov    0x8(%ebp),%eax
f0120e9b:	83 c0 10             	add    $0x10,%eax
f0120e9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0120ea1:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f0120ea8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120eab:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120eae:	01 d0                	add    %edx,%eax
f0120eb0:	48                   	dec    %eax
f0120eb1:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120eb4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120eb7:	ba 00 00 00 00       	mov    $0x0,%edx
f0120ebc:	f7 75 e0             	divl   -0x20(%ebp)
f0120ebf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120ec2:	29 d0                	sub    %edx,%eax
f0120ec4:	c1 e8 0c             	shr    $0xc,%eax
f0120ec7:	83 ec 0c             	sub    $0xc,%esp
f0120eca:	50                   	push   %eax
f0120ecb:	e8 8e 84 fe ff       	call   f010935e <sbrk>
f0120ed0:	83 c4 10             	add    $0x10,%esp
f0120ed3:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120ed6:	83 ec 0c             	sub    $0xc,%esp
f0120ed9:	6a 00                	push   $0x0
f0120edb:	e8 7e 84 fe ff       	call   f010935e <sbrk>
f0120ee0:	83 c4 10             	add    $0x10,%esp
f0120ee3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120ee6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120ee9:	2b 45 d8             	sub    -0x28(%ebp),%eax
f0120eec:	83 ec 08             	sub    $0x8,%esp
f0120eef:	50                   	push   %eax
f0120ef0:	ff 75 d8             	pushl  -0x28(%ebp)
f0120ef3:	e8 9f f8 ff ff       	call   f0120797 <initialize_dynamic_allocator>
f0120ef8:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120efb:	83 ec 0c             	sub    $0xc,%esp
f0120efe:	68 93 14 13 f0       	push   $0xf0131493
f0120f03:	e8 83 00 fe ff       	call   f0100f8b <cprintf>
f0120f08:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f0120f0b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f0120f12:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f0120f19:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f0120f20:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f0120f27:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f0120f2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120f2f:	e9 1d 01 00 00       	jmp    f0121051 <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f0120f34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f37:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f0120f3a:	83 ec 0c             	sub    $0xc,%esp
f0120f3d:	ff 75 a8             	pushl  -0x58(%ebp)
f0120f40:	e8 ee f6 ff ff       	call   f0120633 <get_block_size>
f0120f45:	83 c4 10             	add    $0x10,%esp
f0120f48:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f0120f4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f4e:	83 c0 08             	add    $0x8,%eax
f0120f51:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120f54:	0f 87 ef 00 00 00    	ja     f0121049 <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120f5a:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f5d:	83 c0 18             	add    $0x18,%eax
f0120f60:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120f63:	77 1d                	ja     f0120f82 <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f0120f65:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120f68:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120f6b:	0f 86 d8 00 00 00    	jbe    f0121049 <alloc_block_BF+0x1da>
				{
					best_va = va;
f0120f71:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0120f74:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f0120f77:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0120f7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0120f7d:	e9 c7 00 00 00       	jmp    f0121049 <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f0120f82:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f85:	83 c0 08             	add    $0x8,%eax
f0120f88:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120f8b:	0f 85 9d 00 00 00    	jne    f012102e <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f0120f91:	83 ec 04             	sub    $0x4,%esp
f0120f94:	6a 01                	push   $0x1
f0120f96:	ff 75 a4             	pushl  -0x5c(%ebp)
f0120f99:	ff 75 a8             	pushl  -0x58(%ebp)
f0120f9c:	e8 e3 f9 ff ff       	call   f0120984 <set_block_data>
f0120fa1:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f0120fa4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120fa8:	75 17                	jne    f0120fc1 <alloc_block_BF+0x152>
f0120faa:	83 ec 04             	sub    $0x4,%esp
f0120fad:	68 37 14 13 f0       	push   $0xf0131437
f0120fb2:	68 2c 01 00 00       	push   $0x12c
f0120fb7:	68 55 14 13 f0       	push   $0xf0131455
f0120fbc:	e8 78 f3 fd ff       	call   f0100339 <_panic>
f0120fc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120fc4:	8b 00                	mov    (%eax),%eax
f0120fc6:	85 c0                	test   %eax,%eax
f0120fc8:	74 10                	je     f0120fda <alloc_block_BF+0x16b>
f0120fca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120fcd:	8b 00                	mov    (%eax),%eax
f0120fcf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120fd2:	8b 52 04             	mov    0x4(%edx),%edx
f0120fd5:	89 50 04             	mov    %edx,0x4(%eax)
f0120fd8:	eb 0b                	jmp    f0120fe5 <alloc_block_BF+0x176>
f0120fda:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120fdd:	8b 40 04             	mov    0x4(%eax),%eax
f0120fe0:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0120fe5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120fe8:	8b 40 04             	mov    0x4(%eax),%eax
f0120feb:	85 c0                	test   %eax,%eax
f0120fed:	74 0f                	je     f0120ffe <alloc_block_BF+0x18f>
f0120fef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ff2:	8b 40 04             	mov    0x4(%eax),%eax
f0120ff5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120ff8:	8b 12                	mov    (%edx),%edx
f0120ffa:	89 10                	mov    %edx,(%eax)
f0120ffc:	eb 0a                	jmp    f0121008 <alloc_block_BF+0x199>
f0120ffe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121001:	8b 00                	mov    (%eax),%eax
f0121003:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0121008:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012100b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121011:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121014:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012101b:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121020:	48                   	dec    %eax
f0121021:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
					return va;
f0121026:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0121029:	e9 24 04 00 00       	jmp    f0121452 <alloc_block_BF+0x5e3>
				}
				else
				{
					if (best_blk_size > blk_size)
f012102e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121031:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121034:	76 13                	jbe    f0121049 <alloc_block_BF+0x1da>
					{
						internal = 1;
f0121036:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f012103d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0121040:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f0121043:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0121046:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f0121049:	a1 18 07 6c f0       	mov    0xf06c0718,%eax
f012104e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121051:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121055:	74 07                	je     f012105e <alloc_block_BF+0x1ef>
f0121057:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012105a:	8b 00                	mov    (%eax),%eax
f012105c:	eb 05                	jmp    f0121063 <alloc_block_BF+0x1f4>
f012105e:	b8 00 00 00 00       	mov    $0x0,%eax
f0121063:	a3 18 07 6c f0       	mov    %eax,0xf06c0718
f0121068:	a1 18 07 6c f0       	mov    0xf06c0718,%eax
f012106d:	85 c0                	test   %eax,%eax
f012106f:	0f 85 bf fe ff ff    	jne    f0120f34 <alloc_block_BF+0xc5>
f0121075:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121079:	0f 85 b5 fe ff ff    	jne    f0120f34 <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f012107f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121083:	0f 84 26 02 00 00    	je     f01212af <alloc_block_BF+0x440>
f0121089:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f012108d:	0f 85 1c 02 00 00    	jne    f01212af <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f0121093:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121096:	2b 45 08             	sub    0x8(%ebp),%eax
f0121099:	83 e8 08             	sub    $0x8,%eax
f012109c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f012109f:	8b 45 08             	mov    0x8(%ebp),%eax
f01210a2:	8d 50 08             	lea    0x8(%eax),%edx
f01210a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01210a8:	01 d0                	add    %edx,%eax
f01210aa:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f01210ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01210b0:	83 c0 08             	add    $0x8,%eax
f01210b3:	83 ec 04             	sub    $0x4,%esp
f01210b6:	6a 01                	push   $0x1
f01210b8:	50                   	push   %eax
f01210b9:	ff 75 f0             	pushl  -0x10(%ebp)
f01210bc:	e8 c3 f8 ff ff       	call   f0120984 <set_block_data>
f01210c1:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f01210c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01210c7:	8b 40 04             	mov    0x4(%eax),%eax
f01210ca:	85 c0                	test   %eax,%eax
f01210cc:	75 68                	jne    f0121136 <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f01210ce:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f01210d2:	75 17                	jne    f01210eb <alloc_block_BF+0x27c>
f01210d4:	83 ec 04             	sub    $0x4,%esp
f01210d7:	68 70 14 13 f0       	push   $0xf0131470
f01210dc:	68 45 01 00 00       	push   $0x145
f01210e1:	68 55 14 13 f0       	push   $0xf0131455
f01210e6:	e8 4e f2 fd ff       	call   f0100339 <_panic>
f01210eb:	8b 15 10 07 6c f0    	mov    0xf06c0710,%edx
f01210f1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01210f4:	89 10                	mov    %edx,(%eax)
f01210f6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01210f9:	8b 00                	mov    (%eax),%eax
f01210fb:	85 c0                	test   %eax,%eax
f01210fd:	74 0d                	je     f012110c <alloc_block_BF+0x29d>
f01210ff:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f0121104:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0121107:	89 50 04             	mov    %edx,0x4(%eax)
f012110a:	eb 08                	jmp    f0121114 <alloc_block_BF+0x2a5>
f012110c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012110f:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121114:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121117:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f012111c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012111f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121126:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f012112b:	40                   	inc    %eax
f012112c:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
f0121131:	e9 dc 00 00 00       	jmp    f0121212 <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f0121136:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121139:	8b 00                	mov    (%eax),%eax
f012113b:	85 c0                	test   %eax,%eax
f012113d:	75 65                	jne    f01211a4 <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f012113f:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121143:	75 17                	jne    f012115c <alloc_block_BF+0x2ed>
f0121145:	83 ec 04             	sub    $0x4,%esp
f0121148:	68 a4 14 13 f0       	push   $0xf01314a4
f012114d:	68 4a 01 00 00       	push   $0x14a
f0121152:	68 55 14 13 f0       	push   $0xf0131455
f0121157:	e8 dd f1 fd ff       	call   f0100339 <_panic>
f012115c:	8b 15 14 07 6c f0    	mov    0xf06c0714,%edx
f0121162:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121165:	89 50 04             	mov    %edx,0x4(%eax)
f0121168:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012116b:	8b 40 04             	mov    0x4(%eax),%eax
f012116e:	85 c0                	test   %eax,%eax
f0121170:	74 0c                	je     f012117e <alloc_block_BF+0x30f>
f0121172:	a1 14 07 6c f0       	mov    0xf06c0714,%eax
f0121177:	8b 55 cc             	mov    -0x34(%ebp),%edx
f012117a:	89 10                	mov    %edx,(%eax)
f012117c:	eb 08                	jmp    f0121186 <alloc_block_BF+0x317>
f012117e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121181:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0121186:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121189:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f012118e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121191:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121197:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f012119c:	40                   	inc    %eax
f012119d:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
f01211a2:	eb 6e                	jmp    f0121212 <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f01211a4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01211a8:	74 06                	je     f01211b0 <alloc_block_BF+0x341>
f01211aa:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f01211ae:	75 17                	jne    f01211c7 <alloc_block_BF+0x358>
f01211b0:	83 ec 04             	sub    $0x4,%esp
f01211b3:	68 c8 14 13 f0       	push   $0xf01314c8
f01211b8:	68 4f 01 00 00       	push   $0x14f
f01211bd:	68 55 14 13 f0       	push   $0xf0131455
f01211c2:	e8 72 f1 fd ff       	call   f0100339 <_panic>
f01211c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01211ca:	8b 10                	mov    (%eax),%edx
f01211cc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211cf:	89 10                	mov    %edx,(%eax)
f01211d1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211d4:	8b 00                	mov    (%eax),%eax
f01211d6:	85 c0                	test   %eax,%eax
f01211d8:	74 0b                	je     f01211e5 <alloc_block_BF+0x376>
f01211da:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01211dd:	8b 00                	mov    (%eax),%eax
f01211df:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01211e2:	89 50 04             	mov    %edx,0x4(%eax)
f01211e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01211e8:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01211eb:	89 10                	mov    %edx,(%eax)
f01211ed:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211f0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01211f3:	89 50 04             	mov    %edx,0x4(%eax)
f01211f6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01211f9:	8b 00                	mov    (%eax),%eax
f01211fb:	85 c0                	test   %eax,%eax
f01211fd:	75 08                	jne    f0121207 <alloc_block_BF+0x398>
f01211ff:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121202:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121207:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f012120c:	40                   	inc    %eax
f012120d:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f0121212:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121216:	75 17                	jne    f012122f <alloc_block_BF+0x3c0>
f0121218:	83 ec 04             	sub    $0x4,%esp
f012121b:	68 37 14 13 f0       	push   $0xf0131437
f0121220:	68 51 01 00 00       	push   $0x151
f0121225:	68 55 14 13 f0       	push   $0xf0131455
f012122a:	e8 0a f1 fd ff       	call   f0100339 <_panic>
f012122f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121232:	8b 00                	mov    (%eax),%eax
f0121234:	85 c0                	test   %eax,%eax
f0121236:	74 10                	je     f0121248 <alloc_block_BF+0x3d9>
f0121238:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012123b:	8b 00                	mov    (%eax),%eax
f012123d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121240:	8b 52 04             	mov    0x4(%edx),%edx
f0121243:	89 50 04             	mov    %edx,0x4(%eax)
f0121246:	eb 0b                	jmp    f0121253 <alloc_block_BF+0x3e4>
f0121248:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012124b:	8b 40 04             	mov    0x4(%eax),%eax
f012124e:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121253:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121256:	8b 40 04             	mov    0x4(%eax),%eax
f0121259:	85 c0                	test   %eax,%eax
f012125b:	74 0f                	je     f012126c <alloc_block_BF+0x3fd>
f012125d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121260:	8b 40 04             	mov    0x4(%eax),%eax
f0121263:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121266:	8b 12                	mov    (%edx),%edx
f0121268:	89 10                	mov    %edx,(%eax)
f012126a:	eb 0a                	jmp    f0121276 <alloc_block_BF+0x407>
f012126c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012126f:	8b 00                	mov    (%eax),%eax
f0121271:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0121276:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121279:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012127f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121282:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121289:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f012128e:	48                   	dec    %eax
f012128f:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
			set_block_data(new_block_va, remaining_size, 0);
f0121294:	83 ec 04             	sub    $0x4,%esp
f0121297:	6a 00                	push   $0x0
f0121299:	ff 75 d0             	pushl  -0x30(%ebp)
f012129c:	ff 75 cc             	pushl  -0x34(%ebp)
f012129f:	e8 e0 f6 ff ff       	call   f0120984 <set_block_data>
f01212a4:	83 c4 10             	add    $0x10,%esp
			return best_va;
f01212a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212aa:	e9 a3 01 00 00       	jmp    f0121452 <alloc_block_BF+0x5e3>
	}
	else if(internal == 1)
f01212af:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01212b3:	0f 85 9d 00 00 00    	jne    f0121356 <alloc_block_BF+0x4e7>
	{
		set_block_data(best_va, best_blk_size, 1);
f01212b9:	83 ec 04             	sub    $0x4,%esp
f01212bc:	6a 01                	push   $0x1
f01212be:	ff 75 ec             	pushl  -0x14(%ebp)
f01212c1:	ff 75 f0             	pushl  -0x10(%ebp)
f01212c4:	e8 bb f6 ff ff       	call   f0120984 <set_block_data>
f01212c9:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f01212cc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01212d0:	75 17                	jne    f01212e9 <alloc_block_BF+0x47a>
f01212d2:	83 ec 04             	sub    $0x4,%esp
f01212d5:	68 37 14 13 f0       	push   $0xf0131437
f01212da:	68 58 01 00 00       	push   $0x158
f01212df:	68 55 14 13 f0       	push   $0xf0131455
f01212e4:	e8 50 f0 fd ff       	call   f0100339 <_panic>
f01212e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212ec:	8b 00                	mov    (%eax),%eax
f01212ee:	85 c0                	test   %eax,%eax
f01212f0:	74 10                	je     f0121302 <alloc_block_BF+0x493>
f01212f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212f5:	8b 00                	mov    (%eax),%eax
f01212f7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01212fa:	8b 52 04             	mov    0x4(%edx),%edx
f01212fd:	89 50 04             	mov    %edx,0x4(%eax)
f0121300:	eb 0b                	jmp    f012130d <alloc_block_BF+0x49e>
f0121302:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121305:	8b 40 04             	mov    0x4(%eax),%eax
f0121308:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f012130d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121310:	8b 40 04             	mov    0x4(%eax),%eax
f0121313:	85 c0                	test   %eax,%eax
f0121315:	74 0f                	je     f0121326 <alloc_block_BF+0x4b7>
f0121317:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012131a:	8b 40 04             	mov    0x4(%eax),%eax
f012131d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121320:	8b 12                	mov    (%edx),%edx
f0121322:	89 10                	mov    %edx,(%eax)
f0121324:	eb 0a                	jmp    f0121330 <alloc_block_BF+0x4c1>
f0121326:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121329:	8b 00                	mov    (%eax),%eax
f012132b:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0121330:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121333:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121339:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012133c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121343:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121348:	48                   	dec    %eax
f0121349:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
		return best_va;
f012134e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121351:	e9 fc 00 00 00       	jmp    f0121452 <alloc_block_BF+0x5e3>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f0121356:	8b 45 08             	mov    0x8(%ebp),%eax
f0121359:	83 c0 08             	add    $0x8,%eax
f012135c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f012135f:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0121366:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121369:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012136c:	01 d0                	add    %edx,%eax
f012136e:	48                   	dec    %eax
f012136f:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0121372:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121375:	ba 00 00 00 00       	mov    $0x0,%edx
f012137a:	f7 75 c4             	divl   -0x3c(%ebp)
f012137d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121380:	29 d0                	sub    %edx,%eax
f0121382:	c1 e8 0c             	shr    $0xc,%eax
f0121385:	83 ec 0c             	sub    $0xc,%esp
f0121388:	50                   	push   %eax
f0121389:	e8 d0 7f fe ff       	call   f010935e <sbrk>
f012138e:	83 c4 10             	add    $0x10,%esp
f0121391:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (new_mem == (void *)-1) {
f0121394:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f0121398:	75 0a                	jne    f01213a4 <alloc_block_BF+0x535>
				return NULL; // Allocation failed
f012139a:	b8 00 00 00 00       	mov    $0x0,%eax
f012139f:	e9 ae 00 00 00       	jmp    f0121452 <alloc_block_BF+0x5e3>
			}
			else {
				end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f01213a4:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f01213ab:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01213ae:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01213b1:	01 d0                	add    %edx,%eax
f01213b3:	48                   	dec    %eax
f01213b4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f01213b7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01213ba:	ba 00 00 00 00       	mov    $0x0,%edx
f01213bf:	f7 75 b8             	divl   -0x48(%ebp)
f01213c2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01213c5:	29 d0                	sub    %edx,%eax
f01213c7:	8d 50 fc             	lea    -0x4(%eax),%edx
f01213ca:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01213cd:	01 d0                	add    %edx,%eax
f01213cf:	a3 70 0b 6c f0       	mov    %eax,0xf06c0b70
				end_block->info = 1;
f01213d4:	a1 70 0b 6c f0       	mov    0xf06c0b70,%eax
f01213d9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				cprintf("251\n");
f01213df:	83 ec 0c             	sub    $0xc,%esp
f01213e2:	68 fc 14 13 f0       	push   $0xf01314fc
f01213e7:	e8 9f fb fd ff       	call   f0100f8b <cprintf>
f01213ec:	83 c4 10             	add    $0x10,%esp
			cprintf("address : %x\n",new_mem);
f01213ef:	83 ec 08             	sub    $0x8,%esp
f01213f2:	ff 75 bc             	pushl  -0x44(%ebp)
f01213f5:	68 01 15 13 f0       	push   $0xf0131501
f01213fa:	e8 8c fb fd ff       	call   f0100f8b <cprintf>
f01213ff:	83 c4 10             	add    $0x10,%esp
			set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0121402:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f0121409:	8b 55 c8             	mov    -0x38(%ebp),%edx
f012140c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012140f:	01 d0                	add    %edx,%eax
f0121411:	48                   	dec    %eax
f0121412:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0121415:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0121418:	ba 00 00 00 00       	mov    $0x0,%edx
f012141d:	f7 75 b0             	divl   -0x50(%ebp)
f0121420:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0121423:	29 d0                	sub    %edx,%eax
f0121425:	83 ec 04             	sub    $0x4,%esp
f0121428:	6a 01                	push   $0x1
f012142a:	50                   	push   %eax
f012142b:	ff 75 bc             	pushl  -0x44(%ebp)
f012142e:	e8 51 f5 ff ff       	call   f0120984 <set_block_data>
f0121433:	83 c4 10             	add    $0x10,%esp
			free_block(new_mem);
f0121436:	83 ec 0c             	sub    $0xc,%esp
f0121439:	ff 75 bc             	pushl  -0x44(%ebp)
f012143c:	e8 36 04 00 00       	call   f0121877 <free_block>
f0121441:	83 c4 10             	add    $0x10,%esp
			return alloc_block_BF(size);
f0121444:	83 ec 0c             	sub    $0xc,%esp
f0121447:	ff 75 08             	pushl  0x8(%ebp)
f012144a:	e8 20 fa ff ff       	call   f0120e6f <alloc_block_BF>
f012144f:	83 c4 10             	add    $0x10,%esp
			}
			return new_mem;
}
f0121452:	c9                   	leave  
f0121453:	c3                   	ret    

f0121454 <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f0121454:	55                   	push   %ebp
f0121455:	89 e5                	mov    %esp,%ebp
f0121457:	53                   	push   %ebx
f0121458:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f012145b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121462:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f0121469:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012146d:	74 1e                	je     f012148d <merging+0x39>
f012146f:	ff 75 08             	pushl  0x8(%ebp)
f0121472:	e8 bc f1 ff ff       	call   f0120633 <get_block_size>
f0121477:	83 c4 04             	add    $0x4,%esp
f012147a:	89 c2                	mov    %eax,%edx
f012147c:	8b 45 08             	mov    0x8(%ebp),%eax
f012147f:	01 d0                	add    %edx,%eax
f0121481:	3b 45 10             	cmp    0x10(%ebp),%eax
f0121484:	75 07                	jne    f012148d <merging+0x39>
		prev_is_free = 1;
f0121486:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f012148d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121491:	74 1e                	je     f01214b1 <merging+0x5d>
f0121493:	ff 75 10             	pushl  0x10(%ebp)
f0121496:	e8 98 f1 ff ff       	call   f0120633 <get_block_size>
f012149b:	83 c4 04             	add    $0x4,%esp
f012149e:	89 c2                	mov    %eax,%edx
f01214a0:	8b 45 10             	mov    0x10(%ebp),%eax
f01214a3:	01 d0                	add    %edx,%eax
f01214a5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01214a8:	75 07                	jne    f01214b1 <merging+0x5d>
		next_is_free = 1;
f01214aa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f01214b1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01214b5:	0f 84 cc 00 00 00    	je     f0121587 <merging+0x133>
f01214bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01214bf:	0f 84 c2 00 00 00    	je     f0121587 <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f01214c5:	ff 75 08             	pushl  0x8(%ebp)
f01214c8:	e8 66 f1 ff ff       	call   f0120633 <get_block_size>
f01214cd:	83 c4 04             	add    $0x4,%esp
f01214d0:	89 c3                	mov    %eax,%ebx
f01214d2:	ff 75 10             	pushl  0x10(%ebp)
f01214d5:	e8 59 f1 ff ff       	call   f0120633 <get_block_size>
f01214da:	83 c4 04             	add    $0x4,%esp
f01214dd:	01 c3                	add    %eax,%ebx
f01214df:	ff 75 0c             	pushl  0xc(%ebp)
f01214e2:	e8 4c f1 ff ff       	call   f0120633 <get_block_size>
f01214e7:	83 c4 04             	add    $0x4,%esp
f01214ea:	01 d8                	add    %ebx,%eax
f01214ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f01214ef:	6a 00                	push   $0x0
f01214f1:	ff 75 ec             	pushl  -0x14(%ebp)
f01214f4:	ff 75 08             	pushl  0x8(%ebp)
f01214f7:	e8 88 f4 ff ff       	call   f0120984 <set_block_data>
f01214fc:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f01214ff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121503:	75 17                	jne    f012151c <merging+0xc8>
f0121505:	83 ec 04             	sub    $0x4,%esp
f0121508:	68 37 14 13 f0       	push   $0xf0131437
f012150d:	68 7d 01 00 00       	push   $0x17d
f0121512:	68 55 14 13 f0       	push   $0xf0131455
f0121517:	e8 1d ee fd ff       	call   f0100339 <_panic>
f012151c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012151f:	8b 00                	mov    (%eax),%eax
f0121521:	85 c0                	test   %eax,%eax
f0121523:	74 10                	je     f0121535 <merging+0xe1>
f0121525:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121528:	8b 00                	mov    (%eax),%eax
f012152a:	8b 55 0c             	mov    0xc(%ebp),%edx
f012152d:	8b 52 04             	mov    0x4(%edx),%edx
f0121530:	89 50 04             	mov    %edx,0x4(%eax)
f0121533:	eb 0b                	jmp    f0121540 <merging+0xec>
f0121535:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121538:	8b 40 04             	mov    0x4(%eax),%eax
f012153b:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121540:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121543:	8b 40 04             	mov    0x4(%eax),%eax
f0121546:	85 c0                	test   %eax,%eax
f0121548:	74 0f                	je     f0121559 <merging+0x105>
f012154a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012154d:	8b 40 04             	mov    0x4(%eax),%eax
f0121550:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121553:	8b 12                	mov    (%edx),%edx
f0121555:	89 10                	mov    %edx,(%eax)
f0121557:	eb 0a                	jmp    f0121563 <merging+0x10f>
f0121559:	8b 45 0c             	mov    0xc(%ebp),%eax
f012155c:	8b 00                	mov    (%eax),%eax
f012155e:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0121563:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121566:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012156c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012156f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121576:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f012157b:	48                   	dec    %eax
f012157c:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f0121581:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0121582:	e9 ea 02 00 00       	jmp    f0121871 <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f0121587:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012158b:	74 3b                	je     f01215c8 <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f012158d:	83 ec 0c             	sub    $0xc,%esp
f0121590:	ff 75 08             	pushl  0x8(%ebp)
f0121593:	e8 9b f0 ff ff       	call   f0120633 <get_block_size>
f0121598:	83 c4 10             	add    $0x10,%esp
f012159b:	89 c3                	mov    %eax,%ebx
f012159d:	83 ec 0c             	sub    $0xc,%esp
f01215a0:	ff 75 10             	pushl  0x10(%ebp)
f01215a3:	e8 8b f0 ff ff       	call   f0120633 <get_block_size>
f01215a8:	83 c4 10             	add    $0x10,%esp
f01215ab:	01 d8                	add    %ebx,%eax
f01215ad:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f01215b0:	83 ec 04             	sub    $0x4,%esp
f01215b3:	6a 00                	push   $0x0
f01215b5:	ff 75 e8             	pushl  -0x18(%ebp)
f01215b8:	ff 75 08             	pushl  0x8(%ebp)
f01215bb:	e8 c4 f3 ff ff       	call   f0120984 <set_block_data>
f01215c0:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01215c3:	e9 a9 02 00 00       	jmp    f0121871 <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f01215c8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01215cc:	0f 84 2d 01 00 00    	je     f01216ff <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f01215d2:	83 ec 0c             	sub    $0xc,%esp
f01215d5:	ff 75 10             	pushl  0x10(%ebp)
f01215d8:	e8 56 f0 ff ff       	call   f0120633 <get_block_size>
f01215dd:	83 c4 10             	add    $0x10,%esp
f01215e0:	89 c3                	mov    %eax,%ebx
f01215e2:	83 ec 0c             	sub    $0xc,%esp
f01215e5:	ff 75 0c             	pushl  0xc(%ebp)
f01215e8:	e8 46 f0 ff ff       	call   f0120633 <get_block_size>
f01215ed:	83 c4 10             	add    $0x10,%esp
f01215f0:	01 d8                	add    %ebx,%eax
f01215f2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f01215f5:	83 ec 04             	sub    $0x4,%esp
f01215f8:	6a 00                	push   $0x0
f01215fa:	ff 75 e4             	pushl  -0x1c(%ebp)
f01215fd:	ff 75 10             	pushl  0x10(%ebp)
f0121600:	e8 7f f3 ff ff       	call   f0120984 <set_block_data>
f0121605:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f0121608:	8b 45 10             	mov    0x10(%ebp),%eax
f012160b:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f012160e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121612:	74 06                	je     f012161a <merging+0x1c6>
f0121614:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0121618:	75 17                	jne    f0121631 <merging+0x1dd>
f012161a:	83 ec 04             	sub    $0x4,%esp
f012161d:	68 10 15 13 f0       	push   $0xf0131510
f0121622:	68 8d 01 00 00       	push   $0x18d
f0121627:	68 55 14 13 f0       	push   $0xf0131455
f012162c:	e8 08 ed fd ff       	call   f0100339 <_panic>
f0121631:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121634:	8b 50 04             	mov    0x4(%eax),%edx
f0121637:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012163a:	89 50 04             	mov    %edx,0x4(%eax)
f012163d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121640:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121643:	89 10                	mov    %edx,(%eax)
f0121645:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121648:	8b 40 04             	mov    0x4(%eax),%eax
f012164b:	85 c0                	test   %eax,%eax
f012164d:	74 0d                	je     f012165c <merging+0x208>
f012164f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121652:	8b 40 04             	mov    0x4(%eax),%eax
f0121655:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121658:	89 10                	mov    %edx,(%eax)
f012165a:	eb 08                	jmp    f0121664 <merging+0x210>
f012165c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012165f:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0121664:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121667:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012166a:	89 50 04             	mov    %edx,0x4(%eax)
f012166d:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121672:	40                   	inc    %eax
f0121673:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
		LIST_REMOVE(&freeBlocksList, next_block);
f0121678:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012167c:	75 17                	jne    f0121695 <merging+0x241>
f012167e:	83 ec 04             	sub    $0x4,%esp
f0121681:	68 37 14 13 f0       	push   $0xf0131437
f0121686:	68 8e 01 00 00       	push   $0x18e
f012168b:	68 55 14 13 f0       	push   $0xf0131455
f0121690:	e8 a4 ec fd ff       	call   f0100339 <_panic>
f0121695:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121698:	8b 00                	mov    (%eax),%eax
f012169a:	85 c0                	test   %eax,%eax
f012169c:	74 10                	je     f01216ae <merging+0x25a>
f012169e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216a1:	8b 00                	mov    (%eax),%eax
f01216a3:	8b 55 0c             	mov    0xc(%ebp),%edx
f01216a6:	8b 52 04             	mov    0x4(%edx),%edx
f01216a9:	89 50 04             	mov    %edx,0x4(%eax)
f01216ac:	eb 0b                	jmp    f01216b9 <merging+0x265>
f01216ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216b1:	8b 40 04             	mov    0x4(%eax),%eax
f01216b4:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f01216b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216bc:	8b 40 04             	mov    0x4(%eax),%eax
f01216bf:	85 c0                	test   %eax,%eax
f01216c1:	74 0f                	je     f01216d2 <merging+0x27e>
f01216c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216c6:	8b 40 04             	mov    0x4(%eax),%eax
f01216c9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01216cc:	8b 12                	mov    (%edx),%edx
f01216ce:	89 10                	mov    %edx,(%eax)
f01216d0:	eb 0a                	jmp    f01216dc <merging+0x288>
f01216d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216d5:	8b 00                	mov    (%eax),%eax
f01216d7:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f01216dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216df:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01216e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216e8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01216ef:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f01216f4:	48                   	dec    %eax
f01216f5:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01216fa:	e9 72 01 00 00       	jmp    f0121871 <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f01216ff:	8b 45 10             	mov    0x10(%ebp),%eax
f0121702:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f0121705:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121709:	74 79                	je     f0121784 <merging+0x330>
f012170b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012170f:	74 73                	je     f0121784 <merging+0x330>
f0121711:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121715:	74 06                	je     f012171d <merging+0x2c9>
f0121717:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012171b:	75 17                	jne    f0121734 <merging+0x2e0>
f012171d:	83 ec 04             	sub    $0x4,%esp
f0121720:	68 c8 14 13 f0       	push   $0xf01314c8
f0121725:	68 94 01 00 00       	push   $0x194
f012172a:	68 55 14 13 f0       	push   $0xf0131455
f012172f:	e8 05 ec fd ff       	call   f0100339 <_panic>
f0121734:	8b 45 08             	mov    0x8(%ebp),%eax
f0121737:	8b 10                	mov    (%eax),%edx
f0121739:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012173c:	89 10                	mov    %edx,(%eax)
f012173e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121741:	8b 00                	mov    (%eax),%eax
f0121743:	85 c0                	test   %eax,%eax
f0121745:	74 0b                	je     f0121752 <merging+0x2fe>
f0121747:	8b 45 08             	mov    0x8(%ebp),%eax
f012174a:	8b 00                	mov    (%eax),%eax
f012174c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012174f:	89 50 04             	mov    %edx,0x4(%eax)
f0121752:	8b 45 08             	mov    0x8(%ebp),%eax
f0121755:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121758:	89 10                	mov    %edx,(%eax)
f012175a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012175d:	8b 55 08             	mov    0x8(%ebp),%edx
f0121760:	89 50 04             	mov    %edx,0x4(%eax)
f0121763:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121766:	8b 00                	mov    (%eax),%eax
f0121768:	85 c0                	test   %eax,%eax
f012176a:	75 08                	jne    f0121774 <merging+0x320>
f012176c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012176f:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121774:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121779:	40                   	inc    %eax
f012177a:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
f012177f:	e9 ce 00 00 00       	jmp    f0121852 <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f0121784:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121788:	74 65                	je     f01217ef <merging+0x39b>
f012178a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012178e:	75 17                	jne    f01217a7 <merging+0x353>
f0121790:	83 ec 04             	sub    $0x4,%esp
f0121793:	68 a4 14 13 f0       	push   $0xf01314a4
f0121798:	68 95 01 00 00       	push   $0x195
f012179d:	68 55 14 13 f0       	push   $0xf0131455
f01217a2:	e8 92 eb fd ff       	call   f0100339 <_panic>
f01217a7:	8b 15 14 07 6c f0    	mov    0xf06c0714,%edx
f01217ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01217b0:	89 50 04             	mov    %edx,0x4(%eax)
f01217b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01217b6:	8b 40 04             	mov    0x4(%eax),%eax
f01217b9:	85 c0                	test   %eax,%eax
f01217bb:	74 0c                	je     f01217c9 <merging+0x375>
f01217bd:	a1 14 07 6c f0       	mov    0xf06c0714,%eax
f01217c2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01217c5:	89 10                	mov    %edx,(%eax)
f01217c7:	eb 08                	jmp    f01217d1 <merging+0x37d>
f01217c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01217cc:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f01217d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01217d4:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f01217d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01217dc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01217e2:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f01217e7:	40                   	inc    %eax
f01217e8:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
f01217ed:	eb 63                	jmp    f0121852 <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f01217ef:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01217f3:	75 17                	jne    f012180c <merging+0x3b8>
f01217f5:	83 ec 04             	sub    $0x4,%esp
f01217f8:	68 70 14 13 f0       	push   $0xf0131470
f01217fd:	68 98 01 00 00       	push   $0x198
f0121802:	68 55 14 13 f0       	push   $0xf0131455
f0121807:	e8 2d eb fd ff       	call   f0100339 <_panic>
f012180c:	8b 15 10 07 6c f0    	mov    0xf06c0710,%edx
f0121812:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121815:	89 10                	mov    %edx,(%eax)
f0121817:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012181a:	8b 00                	mov    (%eax),%eax
f012181c:	85 c0                	test   %eax,%eax
f012181e:	74 0d                	je     f012182d <merging+0x3d9>
f0121820:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f0121825:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121828:	89 50 04             	mov    %edx,0x4(%eax)
f012182b:	eb 08                	jmp    f0121835 <merging+0x3e1>
f012182d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121830:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121835:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121838:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f012183d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121840:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121847:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f012184c:	40                   	inc    %eax
f012184d:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
		}
		set_block_data(va, get_block_size(va), 0);
f0121852:	83 ec 0c             	sub    $0xc,%esp
f0121855:	ff 75 10             	pushl  0x10(%ebp)
f0121858:	e8 d6 ed ff ff       	call   f0120633 <get_block_size>
f012185d:	83 c4 10             	add    $0x10,%esp
f0121860:	83 ec 04             	sub    $0x4,%esp
f0121863:	6a 00                	push   $0x0
f0121865:	50                   	push   %eax
f0121866:	ff 75 10             	pushl  0x10(%ebp)
f0121869:	e8 16 f1 ff ff       	call   f0120984 <set_block_data>
f012186e:	83 c4 10             	add    $0x10,%esp
	}
}
f0121871:	90                   	nop
f0121872:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0121875:	c9                   	leave  
f0121876:	c3                   	ret    

f0121877 <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0121877:	55                   	push   %ebp
f0121878:	89 e5                	mov    %esp,%ebp
f012187a:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f012187d:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f0121882:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f0121885:	a1 14 07 6c f0       	mov    0xf06c0714,%eax
f012188a:	3b 45 08             	cmp    0x8(%ebp),%eax
f012188d:	73 1b                	jae    f01218aa <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f012188f:	a1 14 07 6c f0       	mov    0xf06c0714,%eax
f0121894:	83 ec 04             	sub    $0x4,%esp
f0121897:	ff 75 08             	pushl  0x8(%ebp)
f012189a:	6a 00                	push   $0x0
f012189c:	50                   	push   %eax
f012189d:	e8 b2 fb ff ff       	call   f0121454 <merging>
f01218a2:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01218a5:	e9 8b 00 00 00       	jmp    f0121935 <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f01218aa:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f01218af:	3b 45 08             	cmp    0x8(%ebp),%eax
f01218b2:	76 18                	jbe    f01218cc <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f01218b4:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f01218b9:	83 ec 04             	sub    $0x4,%esp
f01218bc:	ff 75 08             	pushl  0x8(%ebp)
f01218bf:	50                   	push   %eax
f01218c0:	6a 00                	push   $0x0
f01218c2:	e8 8d fb ff ff       	call   f0121454 <merging>
f01218c7:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01218ca:	eb 69                	jmp    f0121935 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f01218cc:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f01218d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01218d4:	eb 39                	jmp    f012190f <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f01218d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01218d9:	3b 45 08             	cmp    0x8(%ebp),%eax
f01218dc:	73 29                	jae    f0121907 <free_block+0x90>
f01218de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01218e1:	8b 00                	mov    (%eax),%eax
f01218e3:	3b 45 08             	cmp    0x8(%ebp),%eax
f01218e6:	76 1f                	jbe    f0121907 <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f01218e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01218eb:	8b 00                	mov    (%eax),%eax
f01218ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f01218f0:	83 ec 04             	sub    $0x4,%esp
f01218f3:	ff 75 08             	pushl  0x8(%ebp)
f01218f6:	ff 75 f0             	pushl  -0x10(%ebp)
f01218f9:	ff 75 f4             	pushl  -0xc(%ebp)
f01218fc:	e8 53 fb ff ff       	call   f0121454 <merging>
f0121901:	83 c4 10             	add    $0x10,%esp
			break;
f0121904:	90                   	nop
		}
	}
}
f0121905:	eb 2e                	jmp    f0121935 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121907:	a1 18 07 6c f0       	mov    0xf06c0718,%eax
f012190c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012190f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121913:	74 07                	je     f012191c <free_block+0xa5>
f0121915:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121918:	8b 00                	mov    (%eax),%eax
f012191a:	eb 05                	jmp    f0121921 <free_block+0xaa>
f012191c:	b8 00 00 00 00       	mov    $0x0,%eax
f0121921:	a3 18 07 6c f0       	mov    %eax,0xf06c0718
f0121926:	a1 18 07 6c f0       	mov    0xf06c0718,%eax
f012192b:	85 c0                	test   %eax,%eax
f012192d:	75 a7                	jne    f01218d6 <free_block+0x5f>
f012192f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121933:	75 a1                	jne    f01218d6 <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121935:	90                   	nop
f0121936:	c9                   	leave  
f0121937:	c3                   	ret    

f0121938 <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f0121938:	55                   	push   %ebp
f0121939:	89 e5                	mov    %esp,%ebp
f012193b:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f012193e:	ff 75 08             	pushl  0x8(%ebp)
f0121941:	e8 ed ec ff ff       	call   f0120633 <get_block_size>
f0121946:	83 c4 04             	add    $0x4,%esp
f0121949:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f012194c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0121953:	eb 17                	jmp    f012196c <copy_data+0x34>
f0121955:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0121958:	8b 45 0c             	mov    0xc(%ebp),%eax
f012195b:	01 c2                	add    %eax,%edx
f012195d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0121960:	8b 45 08             	mov    0x8(%ebp),%eax
f0121963:	01 c8                	add    %ecx,%eax
f0121965:	8a 00                	mov    (%eax),%al
f0121967:	88 02                	mov    %al,(%edx)
f0121969:	ff 45 fc             	incl   -0x4(%ebp)
f012196c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012196f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0121972:	72 e1                	jb     f0121955 <copy_data+0x1d>
}
f0121974:	90                   	nop
f0121975:	c9                   	leave  
f0121976:	c3                   	ret    

f0121977 <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f0121977:	55                   	push   %ebp
f0121978:	89 e5                	mov    %esp,%ebp
f012197a:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f012197d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121981:	75 23                	jne    f01219a6 <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f0121983:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121987:	74 13                	je     f012199c <realloc_block_FF+0x25>
f0121989:	83 ec 0c             	sub    $0xc,%esp
f012198c:	ff 75 0c             	pushl  0xc(%ebp)
f012198f:	e8 1f f0 ff ff       	call   f01209b3 <alloc_block_FF>
f0121994:	83 c4 10             	add    $0x10,%esp
f0121997:	e9 f4 06 00 00       	jmp    f0122090 <realloc_block_FF+0x719>
		return NULL;
f012199c:	b8 00 00 00 00       	mov    $0x0,%eax
f01219a1:	e9 ea 06 00 00       	jmp    f0122090 <realloc_block_FF+0x719>
	}

	if(new_size == 0)
f01219a6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01219aa:	75 18                	jne    f01219c4 <realloc_block_FF+0x4d>
	{
		free_block(va);
f01219ac:	83 ec 0c             	sub    $0xc,%esp
f01219af:	ff 75 08             	pushl  0x8(%ebp)
f01219b2:	e8 c0 fe ff ff       	call   f0121877 <free_block>
f01219b7:	83 c4 10             	add    $0x10,%esp
		return NULL;
f01219ba:	b8 00 00 00 00       	mov    $0x0,%eax
f01219bf:	e9 cc 06 00 00       	jmp    f0122090 <realloc_block_FF+0x719>
	}


	if(new_size < 8) new_size = 8;
f01219c4:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f01219c8:	77 07                	ja     f01219d1 <realloc_block_FF+0x5a>
f01219ca:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f01219d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01219d4:	83 e0 01             	and    $0x1,%eax
f01219d7:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f01219da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01219dd:	83 c0 08             	add    $0x8,%eax
f01219e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f01219e3:	83 ec 0c             	sub    $0xc,%esp
f01219e6:	ff 75 08             	pushl  0x8(%ebp)
f01219e9:	e8 45 ec ff ff       	call   f0120633 <get_block_size>
f01219ee:	83 c4 10             	add    $0x10,%esp
f01219f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f01219f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01219f7:	83 e8 08             	sub    $0x8,%eax
f01219fa:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f01219fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a00:	83 e8 04             	sub    $0x4,%eax
f0121a03:	8b 00                	mov    (%eax),%eax
f0121a05:	83 e0 fe             	and    $0xfffffffe,%eax
f0121a08:	89 c2                	mov    %eax,%edx
f0121a0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a0d:	01 d0                	add    %edx,%eax
f0121a0f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f0121a12:	83 ec 0c             	sub    $0xc,%esp
f0121a15:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121a18:	e8 16 ec ff ff       	call   f0120633 <get_block_size>
f0121a1d:	83 c4 10             	add    $0x10,%esp
f0121a20:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121a23:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121a26:	83 e8 08             	sub    $0x8,%eax
f0121a29:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f0121a2c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a2f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121a32:	75 08                	jne    f0121a3c <realloc_block_FF+0xc5>
	{
		 return va;
f0121a34:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a37:	e9 54 06 00 00       	jmp    f0122090 <realloc_block_FF+0x719>

	}


	if(new_size < cur_size)
f0121a3c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a3f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121a42:	0f 83 e5 03 00 00    	jae    f0121e2d <realloc_block_FF+0x4b6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f0121a48:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121a4b:	2b 45 0c             	sub    0xc(%ebp),%eax
f0121a4e:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f0121a51:	83 ec 0c             	sub    $0xc,%esp
f0121a54:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121a57:	e8 f0 eb ff ff       	call   f012064c <is_free_block>
f0121a5c:	83 c4 10             	add    $0x10,%esp
f0121a5f:	84 c0                	test   %al,%al
f0121a61:	0f 84 3b 01 00 00    	je     f0121ba2 <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f0121a67:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121a6a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121a6d:	01 d0                	add    %edx,%eax
f0121a6f:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f0121a72:	83 ec 04             	sub    $0x4,%esp
f0121a75:	6a 01                	push   $0x1
f0121a77:	ff 75 f0             	pushl  -0x10(%ebp)
f0121a7a:	ff 75 08             	pushl  0x8(%ebp)
f0121a7d:	e8 02 ef ff ff       	call   f0120984 <set_block_data>
f0121a82:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f0121a85:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a88:	83 e8 04             	sub    $0x4,%eax
f0121a8b:	8b 00                	mov    (%eax),%eax
f0121a8d:	83 e0 fe             	and    $0xfffffffe,%eax
f0121a90:	89 c2                	mov    %eax,%edx
f0121a92:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a95:	01 d0                	add    %edx,%eax
f0121a97:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f0121a9a:	83 ec 04             	sub    $0x4,%esp
f0121a9d:	6a 00                	push   $0x0
f0121a9f:	ff 75 cc             	pushl  -0x34(%ebp)
f0121aa2:	ff 75 c8             	pushl  -0x38(%ebp)
f0121aa5:	e8 da ee ff ff       	call   f0120984 <set_block_data>
f0121aaa:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0121aad:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121ab1:	74 06                	je     f0121ab9 <realloc_block_FF+0x142>
f0121ab3:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0121ab7:	75 17                	jne    f0121ad0 <realloc_block_FF+0x159>
f0121ab9:	83 ec 04             	sub    $0x4,%esp
f0121abc:	68 c8 14 13 f0       	push   $0xf01314c8
f0121ac1:	68 f6 01 00 00       	push   $0x1f6
f0121ac6:	68 55 14 13 f0       	push   $0xf0131455
f0121acb:	e8 69 e8 fd ff       	call   f0100339 <_panic>
f0121ad0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ad3:	8b 10                	mov    (%eax),%edx
f0121ad5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121ad8:	89 10                	mov    %edx,(%eax)
f0121ada:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121add:	8b 00                	mov    (%eax),%eax
f0121adf:	85 c0                	test   %eax,%eax
f0121ae1:	74 0b                	je     f0121aee <realloc_block_FF+0x177>
f0121ae3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ae6:	8b 00                	mov    (%eax),%eax
f0121ae8:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121aeb:	89 50 04             	mov    %edx,0x4(%eax)
f0121aee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121af1:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121af4:	89 10                	mov    %edx,(%eax)
f0121af6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121af9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121afc:	89 50 04             	mov    %edx,0x4(%eax)
f0121aff:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121b02:	8b 00                	mov    (%eax),%eax
f0121b04:	85 c0                	test   %eax,%eax
f0121b06:	75 08                	jne    f0121b10 <realloc_block_FF+0x199>
f0121b08:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121b0b:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121b10:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121b15:	40                   	inc    %eax
f0121b16:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0121b1b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121b1f:	75 17                	jne    f0121b38 <realloc_block_FF+0x1c1>
f0121b21:	83 ec 04             	sub    $0x4,%esp
f0121b24:	68 37 14 13 f0       	push   $0xf0131437
f0121b29:	68 f7 01 00 00       	push   $0x1f7
f0121b2e:	68 55 14 13 f0       	push   $0xf0131455
f0121b33:	e8 01 e8 fd ff       	call   f0100339 <_panic>
f0121b38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b3b:	8b 00                	mov    (%eax),%eax
f0121b3d:	85 c0                	test   %eax,%eax
f0121b3f:	74 10                	je     f0121b51 <realloc_block_FF+0x1da>
f0121b41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b44:	8b 00                	mov    (%eax),%eax
f0121b46:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121b49:	8b 52 04             	mov    0x4(%edx),%edx
f0121b4c:	89 50 04             	mov    %edx,0x4(%eax)
f0121b4f:	eb 0b                	jmp    f0121b5c <realloc_block_FF+0x1e5>
f0121b51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b54:	8b 40 04             	mov    0x4(%eax),%eax
f0121b57:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121b5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b5f:	8b 40 04             	mov    0x4(%eax),%eax
f0121b62:	85 c0                	test   %eax,%eax
f0121b64:	74 0f                	je     f0121b75 <realloc_block_FF+0x1fe>
f0121b66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b69:	8b 40 04             	mov    0x4(%eax),%eax
f0121b6c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121b6f:	8b 12                	mov    (%edx),%edx
f0121b71:	89 10                	mov    %edx,(%eax)
f0121b73:	eb 0a                	jmp    f0121b7f <realloc_block_FF+0x208>
f0121b75:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b78:	8b 00                	mov    (%eax),%eax
f0121b7a:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0121b7f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b82:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121b88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121b8b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121b92:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121b97:	48                   	dec    %eax
f0121b98:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
f0121b9d:	e9 83 02 00 00       	jmp    f0121e25 <realloc_block_FF+0x4ae>
		}
		else
		{
			if(remaining_size>=16)
f0121ba2:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f0121ba6:	0f 86 69 02 00 00    	jbe    f0121e15 <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f0121bac:	83 ec 04             	sub    $0x4,%esp
f0121baf:	6a 01                	push   $0x1
f0121bb1:	ff 75 f0             	pushl  -0x10(%ebp)
f0121bb4:	ff 75 08             	pushl  0x8(%ebp)
f0121bb7:	e8 c8 ed ff ff       	call   f0120984 <set_block_data>
f0121bbc:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0121bbf:	8b 45 08             	mov    0x8(%ebp),%eax
f0121bc2:	83 e8 04             	sub    $0x4,%eax
f0121bc5:	8b 00                	mov    (%eax),%eax
f0121bc7:	83 e0 fe             	and    $0xfffffffe,%eax
f0121bca:	89 c2                	mov    %eax,%edx
f0121bcc:	8b 45 08             	mov    0x8(%ebp),%eax
f0121bcf:	01 d0                	add    %edx,%eax
f0121bd1:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f0121bd4:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121bd9:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f0121bdc:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0121be0:	75 68                	jne    f0121c4a <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121be2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121be6:	75 17                	jne    f0121bff <realloc_block_FF+0x288>
f0121be8:	83 ec 04             	sub    $0x4,%esp
f0121beb:	68 70 14 13 f0       	push   $0xf0131470
f0121bf0:	68 06 02 00 00       	push   $0x206
f0121bf5:	68 55 14 13 f0       	push   $0xf0131455
f0121bfa:	e8 3a e7 fd ff       	call   f0100339 <_panic>
f0121bff:	8b 15 10 07 6c f0    	mov    0xf06c0710,%edx
f0121c05:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c08:	89 10                	mov    %edx,(%eax)
f0121c0a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c0d:	8b 00                	mov    (%eax),%eax
f0121c0f:	85 c0                	test   %eax,%eax
f0121c11:	74 0d                	je     f0121c20 <realloc_block_FF+0x2a9>
f0121c13:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f0121c18:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121c1b:	89 50 04             	mov    %edx,0x4(%eax)
f0121c1e:	eb 08                	jmp    f0121c28 <realloc_block_FF+0x2b1>
f0121c20:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c23:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121c28:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c2b:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0121c30:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c33:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121c3a:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121c3f:	40                   	inc    %eax
f0121c40:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
f0121c45:	e9 b0 01 00 00       	jmp    f0121dfa <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f0121c4a:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f0121c4f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121c52:	76 68                	jbe    f0121cbc <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121c54:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121c58:	75 17                	jne    f0121c71 <realloc_block_FF+0x2fa>
f0121c5a:	83 ec 04             	sub    $0x4,%esp
f0121c5d:	68 70 14 13 f0       	push   $0xf0131470
f0121c62:	68 0b 02 00 00       	push   $0x20b
f0121c67:	68 55 14 13 f0       	push   $0xf0131455
f0121c6c:	e8 c8 e6 fd ff       	call   f0100339 <_panic>
f0121c71:	8b 15 10 07 6c f0    	mov    0xf06c0710,%edx
f0121c77:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c7a:	89 10                	mov    %edx,(%eax)
f0121c7c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c7f:	8b 00                	mov    (%eax),%eax
f0121c81:	85 c0                	test   %eax,%eax
f0121c83:	74 0d                	je     f0121c92 <realloc_block_FF+0x31b>
f0121c85:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f0121c8a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121c8d:	89 50 04             	mov    %edx,0x4(%eax)
f0121c90:	eb 08                	jmp    f0121c9a <realloc_block_FF+0x323>
f0121c92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c95:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121c9a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121c9d:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0121ca2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121ca5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121cac:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121cb1:	40                   	inc    %eax
f0121cb2:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
f0121cb7:	e9 3e 01 00 00       	jmp    f0121dfa <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f0121cbc:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f0121cc1:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121cc4:	73 68                	jae    f0121d2e <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121cc6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121cca:	75 17                	jne    f0121ce3 <realloc_block_FF+0x36c>
f0121ccc:	83 ec 04             	sub    $0x4,%esp
f0121ccf:	68 a4 14 13 f0       	push   $0xf01314a4
f0121cd4:	68 10 02 00 00       	push   $0x210
f0121cd9:	68 55 14 13 f0       	push   $0xf0131455
f0121cde:	e8 56 e6 fd ff       	call   f0100339 <_panic>
f0121ce3:	8b 15 14 07 6c f0    	mov    0xf06c0714,%edx
f0121ce9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121cec:	89 50 04             	mov    %edx,0x4(%eax)
f0121cef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121cf2:	8b 40 04             	mov    0x4(%eax),%eax
f0121cf5:	85 c0                	test   %eax,%eax
f0121cf7:	74 0c                	je     f0121d05 <realloc_block_FF+0x38e>
f0121cf9:	a1 14 07 6c f0       	mov    0xf06c0714,%eax
f0121cfe:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121d01:	89 10                	mov    %edx,(%eax)
f0121d03:	eb 08                	jmp    f0121d0d <realloc_block_FF+0x396>
f0121d05:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d08:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0121d0d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d10:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121d15:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d18:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121d1e:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121d23:	40                   	inc    %eax
f0121d24:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
f0121d29:	e9 cc 00 00 00       	jmp    f0121dfa <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f0121d2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f0121d35:	a1 10 07 6c f0       	mov    0xf06c0710,%eax
f0121d3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121d3d:	e9 8a 00 00 00       	jmp    f0121dcc <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f0121d42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121d45:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121d48:	73 7a                	jae    f0121dc4 <realloc_block_FF+0x44d>
f0121d4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121d4d:	8b 00                	mov    (%eax),%eax
f0121d4f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121d52:	73 70                	jae    f0121dc4 <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f0121d54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121d58:	74 06                	je     f0121d60 <realloc_block_FF+0x3e9>
f0121d5a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121d5e:	75 17                	jne    f0121d77 <realloc_block_FF+0x400>
f0121d60:	83 ec 04             	sub    $0x4,%esp
f0121d63:	68 c8 14 13 f0       	push   $0xf01314c8
f0121d68:	68 1a 02 00 00       	push   $0x21a
f0121d6d:	68 55 14 13 f0       	push   $0xf0131455
f0121d72:	e8 c2 e5 fd ff       	call   f0100339 <_panic>
f0121d77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121d7a:	8b 10                	mov    (%eax),%edx
f0121d7c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d7f:	89 10                	mov    %edx,(%eax)
f0121d81:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d84:	8b 00                	mov    (%eax),%eax
f0121d86:	85 c0                	test   %eax,%eax
f0121d88:	74 0b                	je     f0121d95 <realloc_block_FF+0x41e>
f0121d8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121d8d:	8b 00                	mov    (%eax),%eax
f0121d8f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121d92:	89 50 04             	mov    %edx,0x4(%eax)
f0121d95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121d98:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121d9b:	89 10                	mov    %edx,(%eax)
f0121d9d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121da0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121da3:	89 50 04             	mov    %edx,0x4(%eax)
f0121da6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121da9:	8b 00                	mov    (%eax),%eax
f0121dab:	85 c0                	test   %eax,%eax
f0121dad:	75 08                	jne    f0121db7 <realloc_block_FF+0x440>
f0121daf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121db2:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121db7:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121dbc:	40                   	inc    %eax
f0121dbd:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
							break;
f0121dc2:	eb 36                	jmp    f0121dfa <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f0121dc4:	a1 18 07 6c f0       	mov    0xf06c0718,%eax
f0121dc9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121dcc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121dd0:	74 07                	je     f0121dd9 <realloc_block_FF+0x462>
f0121dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121dd5:	8b 00                	mov    (%eax),%eax
f0121dd7:	eb 05                	jmp    f0121dde <realloc_block_FF+0x467>
f0121dd9:	b8 00 00 00 00       	mov    $0x0,%eax
f0121dde:	a3 18 07 6c f0       	mov    %eax,0xf06c0718
f0121de3:	a1 18 07 6c f0       	mov    0xf06c0718,%eax
f0121de8:	85 c0                	test   %eax,%eax
f0121dea:	0f 85 52 ff ff ff    	jne    f0121d42 <realloc_block_FF+0x3cb>
f0121df0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121df4:	0f 85 48 ff ff ff    	jne    f0121d42 <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f0121dfa:	83 ec 04             	sub    $0x4,%esp
f0121dfd:	6a 00                	push   $0x0
f0121dff:	ff 75 d8             	pushl  -0x28(%ebp)
f0121e02:	ff 75 d4             	pushl  -0x2c(%ebp)
f0121e05:	e8 7a eb ff ff       	call   f0120984 <set_block_data>
f0121e0a:	83 c4 10             	add    $0x10,%esp
				return va;
f0121e0d:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e10:	e9 7b 02 00 00       	jmp    f0122090 <realloc_block_FF+0x719>
			}
			cprintf("16\n");
f0121e15:	83 ec 0c             	sub    $0xc,%esp
f0121e18:	68 45 15 13 f0       	push   $0xf0131545
f0121e1d:	e8 69 f1 fd ff       	call   f0100f8b <cprintf>
f0121e22:	83 c4 10             	add    $0x10,%esp
		}
		return va;
f0121e25:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e28:	e9 63 02 00 00       	jmp    f0122090 <realloc_block_FF+0x719>
	}

	if(new_size > cur_size)
f0121e2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121e30:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121e33:	0f 86 4d 02 00 00    	jbe    f0122086 <realloc_block_FF+0x70f>
	{
		if(is_free_block(next_va))
f0121e39:	83 ec 0c             	sub    $0xc,%esp
f0121e3c:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121e3f:	e8 08 e8 ff ff       	call   f012064c <is_free_block>
f0121e44:	83 c4 10             	add    $0x10,%esp
f0121e47:	84 c0                	test   %al,%al
f0121e49:	0f 84 37 02 00 00    	je     f0122086 <realloc_block_FF+0x70f>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f0121e4f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121e52:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0121e55:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f0121e58:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121e5b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0121e5e:	76 38                	jbe    f0121e98 <realloc_block_FF+0x521>
			{
				free_block(va); //set it free
f0121e60:	83 ec 0c             	sub    $0xc,%esp
f0121e63:	ff 75 08             	pushl  0x8(%ebp)
f0121e66:	e8 0c fa ff ff       	call   f0121877 <free_block>
f0121e6b:	83 c4 10             	add    $0x10,%esp
				void *new_va = alloc_block_FF(new_size); //new allocation
f0121e6e:	83 ec 0c             	sub    $0xc,%esp
f0121e71:	ff 75 0c             	pushl  0xc(%ebp)
f0121e74:	e8 3a eb ff ff       	call   f01209b3 <alloc_block_FF>
f0121e79:	83 c4 10             	add    $0x10,%esp
f0121e7c:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f0121e7f:	83 ec 08             	sub    $0x8,%esp
f0121e82:	ff 75 c0             	pushl  -0x40(%ebp)
f0121e85:	ff 75 08             	pushl  0x8(%ebp)
f0121e88:	e8 ab fa ff ff       	call   f0121938 <copy_data>
f0121e8d:	83 c4 10             	add    $0x10,%esp
				return new_va;
f0121e90:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121e93:	e9 f8 01 00 00       	jmp    f0122090 <realloc_block_FF+0x719>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f0121e98:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121e9b:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f0121e9e:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f0121ea1:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f0121ea5:	0f 87 a0 00 00 00    	ja     f0121f4b <realloc_block_FF+0x5d4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f0121eab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121eaf:	75 17                	jne    f0121ec8 <realloc_block_FF+0x551>
f0121eb1:	83 ec 04             	sub    $0x4,%esp
f0121eb4:	68 37 14 13 f0       	push   $0xf0131437
f0121eb9:	68 38 02 00 00       	push   $0x238
f0121ebe:	68 55 14 13 f0       	push   $0xf0131455
f0121ec3:	e8 71 e4 fd ff       	call   f0100339 <_panic>
f0121ec8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ecb:	8b 00                	mov    (%eax),%eax
f0121ecd:	85 c0                	test   %eax,%eax
f0121ecf:	74 10                	je     f0121ee1 <realloc_block_FF+0x56a>
f0121ed1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ed4:	8b 00                	mov    (%eax),%eax
f0121ed6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121ed9:	8b 52 04             	mov    0x4(%edx),%edx
f0121edc:	89 50 04             	mov    %edx,0x4(%eax)
f0121edf:	eb 0b                	jmp    f0121eec <realloc_block_FF+0x575>
f0121ee1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ee4:	8b 40 04             	mov    0x4(%eax),%eax
f0121ee7:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121eec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121eef:	8b 40 04             	mov    0x4(%eax),%eax
f0121ef2:	85 c0                	test   %eax,%eax
f0121ef4:	74 0f                	je     f0121f05 <realloc_block_FF+0x58e>
f0121ef6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ef9:	8b 40 04             	mov    0x4(%eax),%eax
f0121efc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121eff:	8b 12                	mov    (%edx),%edx
f0121f01:	89 10                	mov    %edx,(%eax)
f0121f03:	eb 0a                	jmp    f0121f0f <realloc_block_FF+0x598>
f0121f05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f08:	8b 00                	mov    (%eax),%eax
f0121f0a:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0121f0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f12:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121f18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f1b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121f22:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121f27:	48                   	dec    %eax
f0121f28:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f0121f2d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0121f30:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121f33:	01 d0                	add    %edx,%eax
f0121f35:	83 ec 04             	sub    $0x4,%esp
f0121f38:	6a 01                	push   $0x1
f0121f3a:	50                   	push   %eax
f0121f3b:	ff 75 08             	pushl  0x8(%ebp)
f0121f3e:	e8 41 ea ff ff       	call   f0120984 <set_block_data>
f0121f43:	83 c4 10             	add    $0x10,%esp
f0121f46:	e9 36 01 00 00       	jmp    f0122081 <realloc_block_FF+0x70a>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f0121f4b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0121f4e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121f51:	01 d0                	add    %edx,%eax
f0121f53:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f0121f56:	83 ec 04             	sub    $0x4,%esp
f0121f59:	6a 01                	push   $0x1
f0121f5b:	ff 75 f0             	pushl  -0x10(%ebp)
f0121f5e:	ff 75 08             	pushl  0x8(%ebp)
f0121f61:	e8 1e ea ff ff       	call   f0120984 <set_block_data>
f0121f66:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0121f69:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f6c:	83 e8 04             	sub    $0x4,%eax
f0121f6f:	8b 00                	mov    (%eax),%eax
f0121f71:	83 e0 fe             	and    $0xfffffffe,%eax
f0121f74:	89 c2                	mov    %eax,%edx
f0121f76:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f79:	01 d0                	add    %edx,%eax
f0121f7b:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0121f7e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121f82:	74 06                	je     f0121f8a <realloc_block_FF+0x613>
f0121f84:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f0121f88:	75 17                	jne    f0121fa1 <realloc_block_FF+0x62a>
f0121f8a:	83 ec 04             	sub    $0x4,%esp
f0121f8d:	68 c8 14 13 f0       	push   $0xf01314c8
f0121f92:	68 44 02 00 00       	push   $0x244
f0121f97:	68 55 14 13 f0       	push   $0xf0131455
f0121f9c:	e8 98 e3 fd ff       	call   f0100339 <_panic>
f0121fa1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fa4:	8b 10                	mov    (%eax),%edx
f0121fa6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121fa9:	89 10                	mov    %edx,(%eax)
f0121fab:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121fae:	8b 00                	mov    (%eax),%eax
f0121fb0:	85 c0                	test   %eax,%eax
f0121fb2:	74 0b                	je     f0121fbf <realloc_block_FF+0x648>
f0121fb4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fb7:	8b 00                	mov    (%eax),%eax
f0121fb9:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0121fbc:	89 50 04             	mov    %edx,0x4(%eax)
f0121fbf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fc2:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0121fc5:	89 10                	mov    %edx,(%eax)
f0121fc7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121fca:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121fcd:	89 50 04             	mov    %edx,0x4(%eax)
f0121fd0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121fd3:	8b 00                	mov    (%eax),%eax
f0121fd5:	85 c0                	test   %eax,%eax
f0121fd7:	75 08                	jne    f0121fe1 <realloc_block_FF+0x66a>
f0121fd9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121fdc:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f0121fe1:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0121fe6:	40                   	inc    %eax
f0121fe7:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0121fec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121ff0:	75 17                	jne    f0122009 <realloc_block_FF+0x692>
f0121ff2:	83 ec 04             	sub    $0x4,%esp
f0121ff5:	68 37 14 13 f0       	push   $0xf0131437
f0121ffa:	68 45 02 00 00       	push   $0x245
f0121fff:	68 55 14 13 f0       	push   $0xf0131455
f0122004:	e8 30 e3 fd ff       	call   f0100339 <_panic>
f0122009:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012200c:	8b 00                	mov    (%eax),%eax
f012200e:	85 c0                	test   %eax,%eax
f0122010:	74 10                	je     f0122022 <realloc_block_FF+0x6ab>
f0122012:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122015:	8b 00                	mov    (%eax),%eax
f0122017:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012201a:	8b 52 04             	mov    0x4(%edx),%edx
f012201d:	89 50 04             	mov    %edx,0x4(%eax)
f0122020:	eb 0b                	jmp    f012202d <realloc_block_FF+0x6b6>
f0122022:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122025:	8b 40 04             	mov    0x4(%eax),%eax
f0122028:	a3 14 07 6c f0       	mov    %eax,0xf06c0714
f012202d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122030:	8b 40 04             	mov    0x4(%eax),%eax
f0122033:	85 c0                	test   %eax,%eax
f0122035:	74 0f                	je     f0122046 <realloc_block_FF+0x6cf>
f0122037:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012203a:	8b 40 04             	mov    0x4(%eax),%eax
f012203d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122040:	8b 12                	mov    (%edx),%edx
f0122042:	89 10                	mov    %edx,(%eax)
f0122044:	eb 0a                	jmp    f0122050 <realloc_block_FF+0x6d9>
f0122046:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122049:	8b 00                	mov    (%eax),%eax
f012204b:	a3 10 07 6c f0       	mov    %eax,0xf06c0710
f0122050:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122053:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0122059:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012205c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0122063:	a1 1c 07 6c f0       	mov    0xf06c071c,%eax
f0122068:	48                   	dec    %eax
f0122069:	a3 1c 07 6c f0       	mov    %eax,0xf06c071c
				set_block_data(next_new_va, remaining_size, 0);
f012206e:	83 ec 04             	sub    $0x4,%esp
f0122071:	6a 00                	push   $0x0
f0122073:	ff 75 bc             	pushl  -0x44(%ebp)
f0122076:	ff 75 b8             	pushl  -0x48(%ebp)
f0122079:	e8 06 e9 ff ff       	call   f0120984 <set_block_data>
f012207e:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f0122081:	8b 45 08             	mov    0x8(%ebp),%eax
f0122084:	eb 0a                	jmp    f0122090 <realloc_block_FF+0x719>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f0122086:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f012208d:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0122090:	c9                   	leave  
f0122091:	c3                   	ret    

f0122092 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f0122092:	55                   	push   %ebp
f0122093:	89 e5                	mov    %esp,%ebp
f0122095:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0122098:	83 ec 04             	sub    $0x4,%esp
f012209b:	68 4c 15 13 f0       	push   $0xf013154c
f01220a0:	68 58 02 00 00       	push   $0x258
f01220a5:	68 55 14 13 f0       	push   $0xf0131455
f01220aa:	e8 8a e2 fd ff       	call   f0100339 <_panic>

f01220af <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f01220af:	55                   	push   %ebp
f01220b0:	89 e5                	mov    %esp,%ebp
f01220b2:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f01220b5:	83 ec 04             	sub    $0x4,%esp
f01220b8:	68 74 15 13 f0       	push   $0xf0131574
f01220bd:	68 61 02 00 00       	push   $0x261
f01220c2:	68 55 14 13 f0       	push   $0xf0131455
f01220c7:	e8 6d e2 fd ff       	call   f0100339 <_panic>

f01220cc <__moddi3>:
f01220cc:	55                   	push   %ebp
f01220cd:	57                   	push   %edi
f01220ce:	56                   	push   %esi
f01220cf:	53                   	push   %ebx
f01220d0:	83 ec 2c             	sub    $0x2c,%esp
f01220d3:	8b 74 24 40          	mov    0x40(%esp),%esi
f01220d7:	8b 7c 24 44          	mov    0x44(%esp),%edi
f01220db:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f01220df:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f01220e3:	89 d8                	mov    %ebx,%eax
f01220e5:	85 ff                	test   %edi,%edi
f01220e7:	0f 88 d3 00 00 00    	js     f01221c0 <__moddi3+0xf4>
f01220ed:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f01220f4:	00 
f01220f5:	85 c0                	test   %eax,%eax
f01220f7:	0f 88 ab 00 00 00    	js     f01221a8 <__moddi3+0xdc>
f01220fd:	89 0c 24             	mov    %ecx,(%esp)
f0122100:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f0122104:	89 74 24 10          	mov    %esi,0x10(%esp)
f0122108:	89 fb                	mov    %edi,%ebx
f012210a:	8b 14 24             	mov    (%esp),%edx
f012210d:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0122111:	89 d0                	mov    %edx,%eax
f0122113:	89 54 24 18          	mov    %edx,0x18(%esp)
f0122117:	89 ca                	mov    %ecx,%edx
f0122119:	8b 0c 24             	mov    (%esp),%ecx
f012211c:	89 34 24             	mov    %esi,(%esp)
f012211f:	89 7c 24 14          	mov    %edi,0x14(%esp)
f0122123:	85 d2                	test   %edx,%edx
f0122125:	75 15                	jne    f012213c <__moddi3+0x70>
f0122127:	89 c7                	mov    %eax,%edi
f0122129:	39 d8                	cmp    %ebx,%eax
f012212b:	76 5b                	jbe    f0122188 <__moddi3+0xbc>
f012212d:	89 f0                	mov    %esi,%eax
f012212f:	89 da                	mov    %ebx,%edx
f0122131:	f7 f7                	div    %edi
f0122133:	89 d3                	mov    %edx,%ebx
f0122135:	89 d8                	mov    %ebx,%eax
f0122137:	31 d2                	xor    %edx,%edx
f0122139:	eb 09                	jmp    f0122144 <__moddi3+0x78>
f012213b:	90                   	nop
f012213c:	39 fa                	cmp    %edi,%edx
f012213e:	76 1c                	jbe    f012215c <__moddi3+0x90>
f0122140:	89 f0                	mov    %esi,%eax
f0122142:	89 fa                	mov    %edi,%edx
f0122144:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0122148:	85 c9                	test   %ecx,%ecx
f012214a:	74 07                	je     f0122153 <__moddi3+0x87>
f012214c:	f7 d8                	neg    %eax
f012214e:	83 d2 00             	adc    $0x0,%edx
f0122151:	f7 da                	neg    %edx
f0122153:	83 c4 2c             	add    $0x2c,%esp
f0122156:	5b                   	pop    %ebx
f0122157:	5e                   	pop    %esi
f0122158:	5f                   	pop    %edi
f0122159:	5d                   	pop    %ebp
f012215a:	c3                   	ret    
f012215b:	90                   	nop
f012215c:	0f bd c2             	bsr    %edx,%eax
f012215f:	83 f0 1f             	xor    $0x1f,%eax
f0122162:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0122166:	75 6c                	jne    f01221d4 <__moddi3+0x108>
f0122168:	39 fa                	cmp    %edi,%edx
f012216a:	72 05                	jb     f0122171 <__moddi3+0xa5>
f012216c:	3b 0c 24             	cmp    (%esp),%ecx
f012216f:	77 0e                	ja     f012217f <__moddi3+0xb3>
f0122171:	8b 34 24             	mov    (%esp),%esi
f0122174:	29 ce                	sub    %ecx,%esi
f0122176:	19 d3                	sbb    %edx,%ebx
f0122178:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f012217c:	89 34 24             	mov    %esi,(%esp)
f012217f:	8b 04 24             	mov    (%esp),%eax
f0122182:	8b 54 24 14          	mov    0x14(%esp),%edx
f0122186:	eb bc                	jmp    f0122144 <__moddi3+0x78>
f0122188:	85 c9                	test   %ecx,%ecx
f012218a:	75 0b                	jne    f0122197 <__moddi3+0xcb>
f012218c:	b8 01 00 00 00       	mov    $0x1,%eax
f0122191:	31 d2                	xor    %edx,%edx
f0122193:	f7 f1                	div    %ecx
f0122195:	89 c1                	mov    %eax,%ecx
f0122197:	89 d8                	mov    %ebx,%eax
f0122199:	31 d2                	xor    %edx,%edx
f012219b:	f7 f1                	div    %ecx
f012219d:	8b 04 24             	mov    (%esp),%eax
f01221a0:	f7 f1                	div    %ecx
f01221a2:	89 d3                	mov    %edx,%ebx
f01221a4:	eb 8f                	jmp    f0122135 <__moddi3+0x69>
f01221a6:	66 90                	xchg   %ax,%ax
f01221a8:	89 c8                	mov    %ecx,%eax
f01221aa:	89 da                	mov    %ebx,%edx
f01221ac:	f7 d8                	neg    %eax
f01221ae:	83 d2 00             	adc    $0x0,%edx
f01221b1:	f7 da                	neg    %edx
f01221b3:	89 04 24             	mov    %eax,(%esp)
f01221b6:	89 54 24 04          	mov    %edx,0x4(%esp)
f01221ba:	e9 45 ff ff ff       	jmp    f0122104 <__moddi3+0x38>
f01221bf:	90                   	nop
f01221c0:	f7 de                	neg    %esi
f01221c2:	83 d7 00             	adc    $0x0,%edi
f01221c5:	f7 df                	neg    %edi
f01221c7:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f01221ce:	ff 
f01221cf:	e9 21 ff ff ff       	jmp    f01220f5 <__moddi3+0x29>
f01221d4:	b8 20 00 00 00       	mov    $0x20,%eax
f01221d9:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f01221dd:	29 f8                	sub    %edi,%eax
f01221df:	89 c6                	mov    %eax,%esi
f01221e1:	89 44 24 14          	mov    %eax,0x14(%esp)
f01221e5:	89 f9                	mov    %edi,%ecx
f01221e7:	d3 e2                	shl    %cl,%edx
f01221e9:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f01221ed:	89 e8                	mov    %ebp,%eax
f01221ef:	89 f1                	mov    %esi,%ecx
f01221f1:	d3 e8                	shr    %cl,%eax
f01221f3:	09 d0                	or     %edx,%eax
f01221f5:	89 04 24             	mov    %eax,(%esp)
f01221f8:	89 ea                	mov    %ebp,%edx
f01221fa:	89 f9                	mov    %edi,%ecx
f01221fc:	d3 e2                	shl    %cl,%edx
f01221fe:	89 d7                	mov    %edx,%edi
f0122200:	89 da                	mov    %ebx,%edx
f0122202:	d3 e2                	shl    %cl,%edx
f0122204:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f0122208:	d3 e5                	shl    %cl,%ebp
f012220a:	8b 44 24 10          	mov    0x10(%esp),%eax
f012220e:	89 f1                	mov    %esi,%ecx
f0122210:	d3 e8                	shr    %cl,%eax
f0122212:	09 d0                	or     %edx,%eax
f0122214:	d3 eb                	shr    %cl,%ebx
f0122216:	89 da                	mov    %ebx,%edx
f0122218:	f7 34 24             	divl   (%esp)
f012221b:	89 d3                	mov    %edx,%ebx
f012221d:	f7 e7                	mul    %edi
f012221f:	89 c6                	mov    %eax,%esi
f0122221:	89 d1                	mov    %edx,%ecx
f0122223:	39 d3                	cmp    %edx,%ebx
f0122225:	72 29                	jb     f0122250 <__moddi3+0x184>
f0122227:	74 33                	je     f012225c <__moddi3+0x190>
f0122229:	89 e8                	mov    %ebp,%eax
f012222b:	29 f0                	sub    %esi,%eax
f012222d:	19 cb                	sbb    %ecx,%ebx
f012222f:	89 de                	mov    %ebx,%esi
f0122231:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0122235:	d3 e6                	shl    %cl,%esi
f0122237:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f012223b:	89 f9                	mov    %edi,%ecx
f012223d:	d3 e8                	shr    %cl,%eax
f012223f:	09 c6                	or     %eax,%esi
f0122241:	89 f0                	mov    %esi,%eax
f0122243:	89 f9                	mov    %edi,%ecx
f0122245:	d3 eb                	shr    %cl,%ebx
f0122247:	89 da                	mov    %ebx,%edx
f0122249:	e9 f6 fe ff ff       	jmp    f0122144 <__moddi3+0x78>
f012224e:	66 90                	xchg   %ax,%ax
f0122250:	29 f8                	sub    %edi,%eax
f0122252:	1b 14 24             	sbb    (%esp),%edx
f0122255:	89 d1                	mov    %edx,%ecx
f0122257:	89 c6                	mov    %eax,%esi
f0122259:	eb ce                	jmp    f0122229 <__moddi3+0x15d>
f012225b:	90                   	nop
f012225c:	39 c5                	cmp    %eax,%ebp
f012225e:	72 f0                	jb     f0122250 <__moddi3+0x184>
f0122260:	89 d9                	mov    %ebx,%ecx
f0122262:	eb c5                	jmp    f0122229 <__moddi3+0x15d>

f0122264 <__udivdi3>:
f0122264:	55                   	push   %ebp
f0122265:	57                   	push   %edi
f0122266:	56                   	push   %esi
f0122267:	53                   	push   %ebx
f0122268:	83 ec 1c             	sub    $0x1c,%esp
f012226b:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f012226f:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0122273:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0122277:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f012227b:	89 ca                	mov    %ecx,%edx
f012227d:	89 f8                	mov    %edi,%eax
f012227f:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0122283:	85 f6                	test   %esi,%esi
f0122285:	75 2d                	jne    f01222b4 <__udivdi3+0x50>
f0122287:	39 cf                	cmp    %ecx,%edi
f0122289:	77 65                	ja     f01222f0 <__udivdi3+0x8c>
f012228b:	89 fd                	mov    %edi,%ebp
f012228d:	85 ff                	test   %edi,%edi
f012228f:	75 0b                	jne    f012229c <__udivdi3+0x38>
f0122291:	b8 01 00 00 00       	mov    $0x1,%eax
f0122296:	31 d2                	xor    %edx,%edx
f0122298:	f7 f7                	div    %edi
f012229a:	89 c5                	mov    %eax,%ebp
f012229c:	31 d2                	xor    %edx,%edx
f012229e:	89 c8                	mov    %ecx,%eax
f01222a0:	f7 f5                	div    %ebp
f01222a2:	89 c1                	mov    %eax,%ecx
f01222a4:	89 d8                	mov    %ebx,%eax
f01222a6:	f7 f5                	div    %ebp
f01222a8:	89 cf                	mov    %ecx,%edi
f01222aa:	89 fa                	mov    %edi,%edx
f01222ac:	83 c4 1c             	add    $0x1c,%esp
f01222af:	5b                   	pop    %ebx
f01222b0:	5e                   	pop    %esi
f01222b1:	5f                   	pop    %edi
f01222b2:	5d                   	pop    %ebp
f01222b3:	c3                   	ret    
f01222b4:	39 ce                	cmp    %ecx,%esi
f01222b6:	77 28                	ja     f01222e0 <__udivdi3+0x7c>
f01222b8:	0f bd fe             	bsr    %esi,%edi
f01222bb:	83 f7 1f             	xor    $0x1f,%edi
f01222be:	75 40                	jne    f0122300 <__udivdi3+0x9c>
f01222c0:	39 ce                	cmp    %ecx,%esi
f01222c2:	72 0a                	jb     f01222ce <__udivdi3+0x6a>
f01222c4:	3b 44 24 08          	cmp    0x8(%esp),%eax
f01222c8:	0f 87 9e 00 00 00    	ja     f012236c <__udivdi3+0x108>
f01222ce:	b8 01 00 00 00       	mov    $0x1,%eax
f01222d3:	89 fa                	mov    %edi,%edx
f01222d5:	83 c4 1c             	add    $0x1c,%esp
f01222d8:	5b                   	pop    %ebx
f01222d9:	5e                   	pop    %esi
f01222da:	5f                   	pop    %edi
f01222db:	5d                   	pop    %ebp
f01222dc:	c3                   	ret    
f01222dd:	8d 76 00             	lea    0x0(%esi),%esi
f01222e0:	31 ff                	xor    %edi,%edi
f01222e2:	31 c0                	xor    %eax,%eax
f01222e4:	89 fa                	mov    %edi,%edx
f01222e6:	83 c4 1c             	add    $0x1c,%esp
f01222e9:	5b                   	pop    %ebx
f01222ea:	5e                   	pop    %esi
f01222eb:	5f                   	pop    %edi
f01222ec:	5d                   	pop    %ebp
f01222ed:	c3                   	ret    
f01222ee:	66 90                	xchg   %ax,%ax
f01222f0:	89 d8                	mov    %ebx,%eax
f01222f2:	f7 f7                	div    %edi
f01222f4:	31 ff                	xor    %edi,%edi
f01222f6:	89 fa                	mov    %edi,%edx
f01222f8:	83 c4 1c             	add    $0x1c,%esp
f01222fb:	5b                   	pop    %ebx
f01222fc:	5e                   	pop    %esi
f01222fd:	5f                   	pop    %edi
f01222fe:	5d                   	pop    %ebp
f01222ff:	c3                   	ret    
f0122300:	bd 20 00 00 00       	mov    $0x20,%ebp
f0122305:	89 eb                	mov    %ebp,%ebx
f0122307:	29 fb                	sub    %edi,%ebx
f0122309:	89 f9                	mov    %edi,%ecx
f012230b:	d3 e6                	shl    %cl,%esi
f012230d:	89 c5                	mov    %eax,%ebp
f012230f:	88 d9                	mov    %bl,%cl
f0122311:	d3 ed                	shr    %cl,%ebp
f0122313:	89 e9                	mov    %ebp,%ecx
f0122315:	09 f1                	or     %esi,%ecx
f0122317:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f012231b:	89 f9                	mov    %edi,%ecx
f012231d:	d3 e0                	shl    %cl,%eax
f012231f:	89 c5                	mov    %eax,%ebp
f0122321:	89 d6                	mov    %edx,%esi
f0122323:	88 d9                	mov    %bl,%cl
f0122325:	d3 ee                	shr    %cl,%esi
f0122327:	89 f9                	mov    %edi,%ecx
f0122329:	d3 e2                	shl    %cl,%edx
f012232b:	8b 44 24 08          	mov    0x8(%esp),%eax
f012232f:	88 d9                	mov    %bl,%cl
f0122331:	d3 e8                	shr    %cl,%eax
f0122333:	09 c2                	or     %eax,%edx
f0122335:	89 d0                	mov    %edx,%eax
f0122337:	89 f2                	mov    %esi,%edx
f0122339:	f7 74 24 0c          	divl   0xc(%esp)
f012233d:	89 d6                	mov    %edx,%esi
f012233f:	89 c3                	mov    %eax,%ebx
f0122341:	f7 e5                	mul    %ebp
f0122343:	39 d6                	cmp    %edx,%esi
f0122345:	72 19                	jb     f0122360 <__udivdi3+0xfc>
f0122347:	74 0b                	je     f0122354 <__udivdi3+0xf0>
f0122349:	89 d8                	mov    %ebx,%eax
f012234b:	31 ff                	xor    %edi,%edi
f012234d:	e9 58 ff ff ff       	jmp    f01222aa <__udivdi3+0x46>
f0122352:	66 90                	xchg   %ax,%ax
f0122354:	8b 54 24 08          	mov    0x8(%esp),%edx
f0122358:	89 f9                	mov    %edi,%ecx
f012235a:	d3 e2                	shl    %cl,%edx
f012235c:	39 c2                	cmp    %eax,%edx
f012235e:	73 e9                	jae    f0122349 <__udivdi3+0xe5>
f0122360:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0122363:	31 ff                	xor    %edi,%edi
f0122365:	e9 40 ff ff ff       	jmp    f01222aa <__udivdi3+0x46>
f012236a:	66 90                	xchg   %ax,%ax
f012236c:	31 c0                	xor    %eax,%eax
f012236e:	e9 37 ff ff ff       	jmp    f01222aa <__udivdi3+0x46>
f0122373:	90                   	nop

f0122374 <__umoddi3>:
f0122374:	55                   	push   %ebp
f0122375:	57                   	push   %edi
f0122376:	56                   	push   %esi
f0122377:	53                   	push   %ebx
f0122378:	83 ec 1c             	sub    $0x1c,%esp
f012237b:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f012237f:	8b 74 24 34          	mov    0x34(%esp),%esi
f0122383:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0122387:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f012238b:	89 44 24 0c          	mov    %eax,0xc(%esp)
f012238f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0122393:	89 f3                	mov    %esi,%ebx
f0122395:	89 fa                	mov    %edi,%edx
f0122397:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f012239b:	89 34 24             	mov    %esi,(%esp)
f012239e:	85 c0                	test   %eax,%eax
f01223a0:	75 1a                	jne    f01223bc <__umoddi3+0x48>
f01223a2:	39 f7                	cmp    %esi,%edi
f01223a4:	0f 86 a2 00 00 00    	jbe    f012244c <__umoddi3+0xd8>
f01223aa:	89 c8                	mov    %ecx,%eax
f01223ac:	89 f2                	mov    %esi,%edx
f01223ae:	f7 f7                	div    %edi
f01223b0:	89 d0                	mov    %edx,%eax
f01223b2:	31 d2                	xor    %edx,%edx
f01223b4:	83 c4 1c             	add    $0x1c,%esp
f01223b7:	5b                   	pop    %ebx
f01223b8:	5e                   	pop    %esi
f01223b9:	5f                   	pop    %edi
f01223ba:	5d                   	pop    %ebp
f01223bb:	c3                   	ret    
f01223bc:	39 f0                	cmp    %esi,%eax
f01223be:	0f 87 ac 00 00 00    	ja     f0122470 <__umoddi3+0xfc>
f01223c4:	0f bd e8             	bsr    %eax,%ebp
f01223c7:	83 f5 1f             	xor    $0x1f,%ebp
f01223ca:	0f 84 ac 00 00 00    	je     f012247c <__umoddi3+0x108>
f01223d0:	bf 20 00 00 00       	mov    $0x20,%edi
f01223d5:	29 ef                	sub    %ebp,%edi
f01223d7:	89 fe                	mov    %edi,%esi
f01223d9:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f01223dd:	89 e9                	mov    %ebp,%ecx
f01223df:	d3 e0                	shl    %cl,%eax
f01223e1:	89 d7                	mov    %edx,%edi
f01223e3:	89 f1                	mov    %esi,%ecx
f01223e5:	d3 ef                	shr    %cl,%edi
f01223e7:	09 c7                	or     %eax,%edi
f01223e9:	89 e9                	mov    %ebp,%ecx
f01223eb:	d3 e2                	shl    %cl,%edx
f01223ed:	89 14 24             	mov    %edx,(%esp)
f01223f0:	89 d8                	mov    %ebx,%eax
f01223f2:	d3 e0                	shl    %cl,%eax
f01223f4:	89 c2                	mov    %eax,%edx
f01223f6:	8b 44 24 08          	mov    0x8(%esp),%eax
f01223fa:	d3 e0                	shl    %cl,%eax
f01223fc:	89 44 24 04          	mov    %eax,0x4(%esp)
f0122400:	8b 44 24 08          	mov    0x8(%esp),%eax
f0122404:	89 f1                	mov    %esi,%ecx
f0122406:	d3 e8                	shr    %cl,%eax
f0122408:	09 d0                	or     %edx,%eax
f012240a:	d3 eb                	shr    %cl,%ebx
f012240c:	89 da                	mov    %ebx,%edx
f012240e:	f7 f7                	div    %edi
f0122410:	89 d3                	mov    %edx,%ebx
f0122412:	f7 24 24             	mull   (%esp)
f0122415:	89 c6                	mov    %eax,%esi
f0122417:	89 d1                	mov    %edx,%ecx
f0122419:	39 d3                	cmp    %edx,%ebx
f012241b:	0f 82 87 00 00 00    	jb     f01224a8 <__umoddi3+0x134>
f0122421:	0f 84 91 00 00 00    	je     f01224b8 <__umoddi3+0x144>
f0122427:	8b 54 24 04          	mov    0x4(%esp),%edx
f012242b:	29 f2                	sub    %esi,%edx
f012242d:	19 cb                	sbb    %ecx,%ebx
f012242f:	89 d8                	mov    %ebx,%eax
f0122431:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0122435:	d3 e0                	shl    %cl,%eax
f0122437:	89 e9                	mov    %ebp,%ecx
f0122439:	d3 ea                	shr    %cl,%edx
f012243b:	09 d0                	or     %edx,%eax
f012243d:	89 e9                	mov    %ebp,%ecx
f012243f:	d3 eb                	shr    %cl,%ebx
f0122441:	89 da                	mov    %ebx,%edx
f0122443:	83 c4 1c             	add    $0x1c,%esp
f0122446:	5b                   	pop    %ebx
f0122447:	5e                   	pop    %esi
f0122448:	5f                   	pop    %edi
f0122449:	5d                   	pop    %ebp
f012244a:	c3                   	ret    
f012244b:	90                   	nop
f012244c:	89 fd                	mov    %edi,%ebp
f012244e:	85 ff                	test   %edi,%edi
f0122450:	75 0b                	jne    f012245d <__umoddi3+0xe9>
f0122452:	b8 01 00 00 00       	mov    $0x1,%eax
f0122457:	31 d2                	xor    %edx,%edx
f0122459:	f7 f7                	div    %edi
f012245b:	89 c5                	mov    %eax,%ebp
f012245d:	89 f0                	mov    %esi,%eax
f012245f:	31 d2                	xor    %edx,%edx
f0122461:	f7 f5                	div    %ebp
f0122463:	89 c8                	mov    %ecx,%eax
f0122465:	f7 f5                	div    %ebp
f0122467:	89 d0                	mov    %edx,%eax
f0122469:	e9 44 ff ff ff       	jmp    f01223b2 <__umoddi3+0x3e>
f012246e:	66 90                	xchg   %ax,%ax
f0122470:	89 c8                	mov    %ecx,%eax
f0122472:	89 f2                	mov    %esi,%edx
f0122474:	83 c4 1c             	add    $0x1c,%esp
f0122477:	5b                   	pop    %ebx
f0122478:	5e                   	pop    %esi
f0122479:	5f                   	pop    %edi
f012247a:	5d                   	pop    %ebp
f012247b:	c3                   	ret    
f012247c:	3b 04 24             	cmp    (%esp),%eax
f012247f:	72 06                	jb     f0122487 <__umoddi3+0x113>
f0122481:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0122485:	77 0f                	ja     f0122496 <__umoddi3+0x122>
f0122487:	89 f2                	mov    %esi,%edx
f0122489:	29 f9                	sub    %edi,%ecx
f012248b:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f012248f:	89 14 24             	mov    %edx,(%esp)
f0122492:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0122496:	8b 44 24 04          	mov    0x4(%esp),%eax
f012249a:	8b 14 24             	mov    (%esp),%edx
f012249d:	83 c4 1c             	add    $0x1c,%esp
f01224a0:	5b                   	pop    %ebx
f01224a1:	5e                   	pop    %esi
f01224a2:	5f                   	pop    %edi
f01224a3:	5d                   	pop    %ebp
f01224a4:	c3                   	ret    
f01224a5:	8d 76 00             	lea    0x0(%esi),%esi
f01224a8:	2b 04 24             	sub    (%esp),%eax
f01224ab:	19 fa                	sbb    %edi,%edx
f01224ad:	89 d1                	mov    %edx,%ecx
f01224af:	89 c6                	mov    %eax,%esi
f01224b1:	e9 71 ff ff ff       	jmp    f0122427 <__umoddi3+0xb3>
f01224b6:	66 90                	xchg   %ax,%ax
f01224b8:	39 44 24 04          	cmp    %eax,0x4(%esp)
f01224bc:	72 ea                	jb     f01224a8 <__umoddi3+0x134>
f01224be:	89 d9                	mov    %ebx,%ecx
f01224c0:	e9 62 ff ff ff       	jmp    f0122427 <__umoddi3+0xb3>
