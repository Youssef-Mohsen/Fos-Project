
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 00 18 00 	lgdtl  0x180018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 00 18 f0       	mov    $0xf0180000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 50 49 5a f0 01 	movl   $0x1,0xf05a4950
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 a4 48 5a f0 01 	movl   $0x1,0xf05a48a4
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba 30 74 5c f0       	mov    $0xf05c7430,%edx
f010006a:	b8 50 11 5a f0       	mov    $0xf05a1150,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 50 11 5a f0       	push   $0xf05a1150
f010007e:	e8 77 25 02 00       	call   f01225fa <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 8d 0d 00 00       	call   f0100e18 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 11 02 00 00       	call   f01002a1 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 c0 47 12 f0       	push   $0xf01247c0
f0100098:	e8 cf 0e 00 00       	call   f0100f6c <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 07 48 12 f0       	push   $0xf0124807
f01000a8:	e8 bf 0e 00 00       	call   f0100f6c <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 1b 48 12 f0       	push   $0xf012481b
f01000b8:	e8 af 0e 00 00       	call   f0100f6c <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 2f 48 12 f0       	push   $0xf012482f
f01000c8:	e8 9f 0e 00 00       	call   f0100f6c <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 02 70 00 00       	call   f01070dc <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 3b 48 12 f0       	push   $0xf012483b
f01000e5:	e8 82 0e 00 00       	call   f0100f6c <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 43 48 12 f0       	push   $0xf0124843
f01000f5:	e8 72 0e 00 00       	call   f0100f6c <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 3a 79 00 00       	call   f0107a3c <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 e8 74 00 00       	call   f01075ef <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 b5 7c 00 00       	call   f0107dc1 <initialize_paging>
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010010c:	e8 8b e5 00 00       	call   f010e69c <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100111:	e8 39 ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100116:	e8 24 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010011b:	83 ec 0c             	sub    $0xc,%esp
f010011e:	6a 00                	push   $0x0
f0100120:	e8 74 e6 00 00       	call   f010e799 <enableBuffering>
f0100125:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100128:	83 ec 0c             	sub    $0xc,%esp
f010012b:	6a 00                	push   $0x0
f010012d:	e8 4f e6 00 00       	call   f010e781 <enableModifiedBuffer>
f0100132:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100135:	83 ec 0c             	sub    $0xc,%esp
f0100138:	68 e8 03 00 00       	push   $0x3e8
f010013d:	e8 6f e6 00 00       	call   f010e7b1 <setModifiedBufferLength>
f0100142:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100145:	e8 07 2a 02 00       	call   f0122b51 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f010014a:	83 ec 0c             	sub    $0xc,%esp
f010014d:	68 51 48 12 f0       	push   $0xf0124851
f0100152:	e8 15 0e 00 00       	call   f0100f6c <cprintf>
f0100157:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f010015a:	e8 98 96 00 00       	call   f01097f7 <env_init>
		ts_init();
f010015f:	e8 05 bf 00 00       	call   f010c069 <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100164:	83 ec 0c             	sub    $0xc,%esp
f0100167:	68 3b 48 12 f0       	push   $0xf012483b
f010016c:	e8 fb 0d 00 00       	call   f0100f6c <cprintf>
f0100171:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100174:	83 ec 0c             	sub    $0xc,%esp
f0100177:	68 64 48 12 f0       	push   $0xf0124864
f010017c:	e8 eb 0d 00 00       	call   f0100f6c <cprintf>
f0100181:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f0100184:	e8 3f 6c 00 00       	call   f0106dc8 <pic_init>
		cprintf("*	PIC is initialized\n");
f0100189:	83 ec 0c             	sub    $0xc,%esp
f010018c:	68 8d 48 12 f0       	push   $0xf012488d
f0100191:	e8 d6 0d 00 00       	call   f0100f6c <cprintf>
f0100196:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f0100199:	83 ec 0c             	sub    $0xc,%esp
f010019c:	6a 00                	push   $0x0
f010019e:	e8 17 6e 00 00       	call   f0106fba <irq_clear_mask>
f01001a3:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001a6:	83 ec 0c             	sub    $0xc,%esp
f01001a9:	68 a3 48 12 f0       	push   $0xf01248a3
f01001ae:	e8 b9 0d 00 00       	call   f0100f6c <cprintf>
f01001b3:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001b6:	83 ec 0c             	sub    $0xc,%esp
f01001b9:	6a 01                	push   $0x1
f01001bb:	e8 fa 6d 00 00       	call   f0106fba <irq_clear_mask>
f01001c0:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001c3:	83 ec 0c             	sub    $0xc,%esp
f01001c6:	68 c0 48 12 f0       	push   $0xf01248c0
f01001cb:	e8 9c 0d 00 00       	call   f0100f6c <cprintf>
f01001d0:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001d3:	83 ec 0c             	sub    $0xc,%esp
f01001d6:	6a 04                	push   $0x4
f01001d8:	e8 dd 6d 00 00       	call   f0106fba <irq_clear_mask>
f01001dd:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001e0:	83 ec 0c             	sub    $0xc,%esp
f01001e3:	68 df 48 12 f0       	push   $0xf01248df
f01001e8:	e8 7f 0d 00 00       	call   f0100f6c <cprintf>
f01001ed:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f01001f0:	83 ec 0c             	sub    $0xc,%esp
f01001f3:	68 fc 48 12 f0       	push   $0xf01248fc
f01001f8:	e8 6f 0d 00 00       	call   f0100f6c <cprintf>
f01001fd:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f0100200:	e8 96 49 00 00       	call   f0104b9b <kclock_init>
		sched_init() ;
f0100205:	e8 19 65 00 00       	call   f0106723 <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f010020a:	83 ec 0c             	sub    $0xc,%esp
f010020d:	68 20 49 12 f0       	push   $0xf0124920
f0100212:	e8 55 0d 00 00       	call   f0100f6c <cprintf>
f0100217:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010021a:	89 e0                	mov    %esp,%eax
f010021c:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010021f:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100222:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100225:	b8 00 00 18 f0       	mov    $0xf0180000,%eax
f010022a:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010022d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f0100230:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100235:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100238:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010023b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010023e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100241:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100244:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100246:	89 e0                	mov    %esp,%eax
f0100248:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010024b:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010024e:	83 ec 04             	sub    $0x4,%esp
f0100251:	50                   	push   %eax
f0100252:	ff 75 f4             	pushl  -0xc(%ebp)
f0100255:	68 40 49 12 f0       	push   $0xf0124940
f010025a:	e8 0d 0d 00 00       	call   f0100f6c <cprintf>
f010025f:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100262:	83 ec 0c             	sub    $0xc,%esp
f0100265:	68 64 49 12 f0       	push   $0xf0124964
f010026a:	e8 fd 0c 00 00       	call   f0100f6c <cprintf>
f010026f:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100272:	c7 05 7c 4b 5a f0 00 	movl   $0x0,0xf05a4b7c
f0100279:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010027c:	83 ec 0c             	sub    $0xc,%esp
f010027f:	68 ac 49 12 f0       	push   $0xf01249ac
f0100284:	e8 e3 0c 00 00       	call   f0100f6c <cprintf>
f0100289:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f010028c:	83 ec 0c             	sub    $0xc,%esp
f010028f:	68 d8 49 12 f0       	push   $0xf01249d8
f0100294:	e8 d3 0c 00 00       	call   f0100f6c <cprintf>
f0100299:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f010029c:	e8 02 1b 00 00       	call   f0101da3 <get_into_prompt>

f01002a1 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002a1:	55                   	push   %ebp
f01002a2:	89 e5                	mov    %esp,%ebp
f01002a4:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002a7:	83 ec 0c             	sub    $0xc,%esp
f01002aa:	68 fd 49 12 f0       	push   $0xf01249fd
f01002af:	e8 b8 0c 00 00       	call   f0100f6c <cprintf>
f01002b4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002b7:	83 ec 0c             	sub    $0xc,%esp
f01002ba:	68 04 4a 12 f0       	push   $0xf0124a04
f01002bf:	e8 a8 0c 00 00       	call   f0100f6c <cprintf>
f01002c4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002c7:	83 ec 0c             	sub    $0xc,%esp
f01002ca:	68 4c 4a 12 f0       	push   $0xf0124a4c
f01002cf:	e8 98 0c 00 00       	call   f0100f6c <cprintf>
f01002d4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002d7:	83 ec 0c             	sub    $0xc,%esp
f01002da:	68 94 4a 12 f0       	push   $0xf0124a94
f01002df:	e8 88 0c 00 00       	call   f0100f6c <cprintf>
f01002e4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e7:	83 ec 0c             	sub    $0xc,%esp
f01002ea:	68 4c 4a 12 f0       	push   $0xf0124a4c
f01002ef:	e8 78 0c 00 00       	call   f0100f6c <cprintf>
f01002f4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002f7:	83 ec 0c             	sub    $0xc,%esp
f01002fa:	68 04 4a 12 f0       	push   $0xf0124a04
f01002ff:	e8 68 0c 00 00       	call   f0100f6c <cprintf>
f0100304:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100307:	83 ec 0c             	sub    $0xc,%esp
f010030a:	68 d9 4a 12 f0       	push   $0xf0124ad9
f010030f:	e8 58 0c 00 00       	call   f0100f6c <cprintf>
f0100314:	83 c4 10             	add    $0x10,%esp
}
f0100317:	90                   	nop
f0100318:	c9                   	leave  
f0100319:	c3                   	ret    

f010031a <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f010031a:	55                   	push   %ebp
f010031b:	89 e5                	mov    %esp,%ebp
f010031d:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0100320:	e8 20 a4 00 00       	call   f010a745 <get_cpu_proc>
f0100325:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100328:	8b 45 10             	mov    0x10(%ebp),%eax
f010032b:	a3 60 11 5a f0       	mov    %eax,0xf05a1160

	va_start(ap, fmt);
f0100330:	8d 45 10             	lea    0x10(%ebp),%eax
f0100333:	83 c0 04             	add    $0x4,%eax
f0100336:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100339:	83 ec 04             	sub    $0x4,%esp
f010033c:	ff 75 0c             	pushl  0xc(%ebp)
f010033f:	ff 75 08             	pushl  0x8(%ebp)
f0100342:	68 e0 4a 12 f0       	push   $0xf0124ae0
f0100347:	e8 20 0c 00 00       	call   f0100f6c <cprintf>
f010034c:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010034f:	8b 45 10             	mov    0x10(%ebp),%eax
f0100352:	83 ec 08             	sub    $0x8,%esp
f0100355:	ff 75 f0             	pushl  -0x10(%ebp)
f0100358:	50                   	push   %eax
f0100359:	e8 e5 0b 00 00       	call   f0100f43 <vcprintf>
f010035e:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100361:	83 ec 0c             	sub    $0xc,%esp
f0100364:	68 05 4b 12 f0       	push   $0xf0124b05
f0100369:	e8 fe 0b 00 00       	call   f0100f6c <cprintf>
f010036e:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100371:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100375:	74 10                	je     f0100387 <_panic+0x6d>
f0100377:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010037a:	8b 40 18             	mov    0x18(%eax),%eax
f010037d:	83 f8 02             	cmp    $0x2,%eax
f0100380:	75 05                	jne    f0100387 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f0100382:	e8 7c a3 00 00       	call   f010a703 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100387:	89 e0                	mov    %esp,%eax
f0100389:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010038c:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f010038f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f0100392:	83 ec 08             	sub    $0x8,%esp
f0100395:	ff 75 ec             	pushl  -0x14(%ebp)
f0100398:	68 07 4b 12 f0       	push   $0xf0124b07
f010039d:	e8 ca 0b 00 00       	call   f0100f6c <cprintf>
f01003a2:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003a5:	e8 f9 19 00 00       	call   f0101da3 <get_into_prompt>

f01003aa <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003aa:	55                   	push   %ebp
f01003ab:	89 e5                	mov    %esp,%ebp
f01003ad:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003b0:	8b 45 10             	mov    0x10(%ebp),%eax
f01003b3:	a3 60 11 5a f0       	mov    %eax,0xf05a1160

	va_start(ap, fmt);
f01003b8:	8d 45 10             	lea    0x10(%ebp),%eax
f01003bb:	83 c0 04             	add    $0x4,%eax
f01003be:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003c1:	83 ec 04             	sub    $0x4,%esp
f01003c4:	ff 75 0c             	pushl  0xc(%ebp)
f01003c7:	ff 75 08             	pushl  0x8(%ebp)
f01003ca:	68 11 4b 12 f0       	push   $0xf0124b11
f01003cf:	e8 98 0b 00 00       	call   f0100f6c <cprintf>
f01003d4:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003d7:	8b 45 10             	mov    0x10(%ebp),%eax
f01003da:	83 ec 08             	sub    $0x8,%esp
f01003dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01003e0:	50                   	push   %eax
f01003e1:	e8 5d 0b 00 00       	call   f0100f43 <vcprintf>
f01003e6:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01003e9:	83 ec 0c             	sub    $0xc,%esp
f01003ec:	68 05 4b 12 f0       	push   $0xf0124b05
f01003f1:	e8 76 0b 00 00       	call   f0100f6c <cprintf>
f01003f6:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f01003f9:	e8 97 6d 00 00       	call   f0107195 <pushcli>
	struct cpu *c = mycpu();
f01003fe:	e8 cf 6c 00 00       	call   f01070d2 <mycpu>
f0100403:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100406:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100409:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010040f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100412:	e8 d0 6d 00 00       	call   f01071e7 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100417:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010041b:	74 23                	je     f0100440 <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010041d:	e8 87 60 00 00       	call   f01064a9 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100422:	e8 1e a3 00 00       	call   f010a745 <get_cpu_proc>
f0100427:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f010042a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010042e:	74 10                	je     f0100440 <_panic_all+0x96>
f0100430:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100433:	8b 40 18             	mov    0x18(%eax),%eax
f0100436:	83 f8 02             	cmp    $0x2,%eax
f0100439:	75 05                	jne    f0100440 <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010043b:	e8 c3 a2 00 00       	call   f010a703 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f0100440:	e8 5e 19 00 00       	call   f0101da3 <get_into_prompt>

f0100445 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100445:	55                   	push   %ebp
f0100446:	89 e5                	mov    %esp,%ebp
f0100448:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010044b:	8b 45 10             	mov    0x10(%ebp),%eax
f010044e:	a3 60 11 5a f0       	mov    %eax,0xf05a1160

	va_start(ap, fmt);
f0100453:	8d 45 10             	lea    0x10(%ebp),%eax
f0100456:	83 c0 04             	add    $0x4,%eax
f0100459:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010045c:	83 ec 04             	sub    $0x4,%esp
f010045f:	ff 75 0c             	pushl  0xc(%ebp)
f0100462:	ff 75 08             	pushl  0x8(%ebp)
f0100465:	68 11 4b 12 f0       	push   $0xf0124b11
f010046a:	e8 fd 0a 00 00       	call   f0100f6c <cprintf>
f010046f:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100472:	8b 45 10             	mov    0x10(%ebp),%eax
f0100475:	83 ec 08             	sub    $0x8,%esp
f0100478:	ff 75 f4             	pushl  -0xc(%ebp)
f010047b:	50                   	push   %eax
f010047c:	e8 c2 0a 00 00       	call   f0100f43 <vcprintf>
f0100481:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100484:	83 ec 0c             	sub    $0xc,%esp
f0100487:	68 05 4b 12 f0       	push   $0xf0124b05
f010048c:	e8 db 0a 00 00       	call   f0100f6c <cprintf>
f0100491:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f0100494:	e8 ac a2 00 00       	call   f010a745 <get_cpu_proc>
f0100499:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f010049c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004a0:	74 10                	je     f01004b2 <_panic_into_prompt+0x6d>
f01004a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004a5:	8b 40 18             	mov    0x18(%eax),%eax
f01004a8:	83 f8 02             	cmp    $0x2,%eax
f01004ab:	75 05                	jne    f01004b2 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004ad:	e8 51 a2 00 00       	call   f010a703 <env_exit>
	}

	get_into_prompt();
f01004b2:	e8 ec 18 00 00       	call   f0101da3 <get_into_prompt>

f01004b7 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004b7:	55                   	push   %ebp
f01004b8:	89 e5                	mov    %esp,%ebp
f01004ba:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004bd:	8d 45 10             	lea    0x10(%ebp),%eax
f01004c0:	83 c0 04             	add    $0x4,%eax
f01004c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004c6:	83 ec 04             	sub    $0x4,%esp
f01004c9:	ff 75 0c             	pushl  0xc(%ebp)
f01004cc:	ff 75 08             	pushl  0x8(%ebp)
f01004cf:	68 2a 4b 12 f0       	push   $0xf0124b2a
f01004d4:	e8 93 0a 00 00       	call   f0100f6c <cprintf>
f01004d9:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004dc:	8b 45 10             	mov    0x10(%ebp),%eax
f01004df:	83 ec 08             	sub    $0x8,%esp
f01004e2:	ff 75 f4             	pushl  -0xc(%ebp)
f01004e5:	50                   	push   %eax
f01004e6:	e8 58 0a 00 00       	call   f0100f43 <vcprintf>
f01004eb:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004ee:	83 ec 0c             	sub    $0xc,%esp
f01004f1:	68 05 4b 12 f0       	push   $0xf0124b05
f01004f6:	e8 71 0a 00 00       	call   f0100f6c <cprintf>
f01004fb:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f01004fe:	90                   	nop
f01004ff:	c9                   	leave  
f0100500:	c3                   	ret    

f0100501 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100501:	55                   	push   %ebp
f0100502:	89 e5                	mov    %esp,%ebp
f0100504:	83 ec 10             	sub    $0x10,%esp
f0100507:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010050e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100511:	89 c2                	mov    %eax,%edx
f0100513:	ec                   	in     (%dx),%al
f0100514:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100517:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f010051a:	0f b6 c0             	movzbl %al,%eax
f010051d:	83 e0 01             	and    $0x1,%eax
f0100520:	85 c0                	test   %eax,%eax
f0100522:	75 07                	jne    f010052b <serial_proc_data+0x2a>
		return -1;
f0100524:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100529:	eb 16                	jmp    f0100541 <serial_proc_data+0x40>
f010052b:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100532:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100535:	89 c2                	mov    %eax,%edx
f0100537:	ec                   	in     (%dx),%al
f0100538:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010053b:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010053e:	0f b6 c0             	movzbl %al,%eax
}
f0100541:	c9                   	leave  
f0100542:	c3                   	ret    

f0100543 <serial_intr>:

void
serial_intr(void)
{
f0100543:	55                   	push   %ebp
f0100544:	89 e5                	mov    %esp,%ebp
f0100546:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100549:	a1 84 11 5a f0       	mov    0xf05a1184,%eax
f010054e:	85 c0                	test   %eax,%eax
f0100550:	74 10                	je     f0100562 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100552:	83 ec 0c             	sub    $0xc,%esp
f0100555:	68 01 05 10 f0       	push   $0xf0100501
f010055a:	e8 9d 07 00 00       	call   f0100cfc <cons_intr>
f010055f:	83 c4 10             	add    $0x10,%esp
}
f0100562:	90                   	nop
f0100563:	c9                   	leave  
f0100564:	c3                   	ret    

f0100565 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100565:	55                   	push   %ebp
f0100566:	89 e5                	mov    %esp,%ebp
f0100568:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010056b:	83 ec 0c             	sub    $0xc,%esp
f010056e:	68 48 4b 12 f0       	push   $0xf0124b48
f0100573:	e8 f4 09 00 00       	call   f0100f6c <cprintf>
f0100578:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010057b:	e8 c3 ff ff ff       	call   f0100543 <serial_intr>
}
f0100580:	90                   	nop
f0100581:	c9                   	leave  
f0100582:	c3                   	ret    

f0100583 <serial_init>:

void
serial_init(void)
{
f0100583:	55                   	push   %ebp
f0100584:	89 e5                	mov    %esp,%ebp
f0100586:	83 ec 48             	sub    $0x48,%esp
f0100589:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f0100590:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100594:	8a 45 c6             	mov    -0x3a(%ebp),%al
f0100597:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010059a:	ee                   	out    %al,(%dx)
f010059b:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005a2:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005a6:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005a9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005ac:	ee                   	out    %al,(%dx)
f01005ad:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005b4:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005b8:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005bb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005be:	ee                   	out    %al,(%dx)
f01005bf:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005c6:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005ca:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005cd:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005d0:	ee                   	out    %al,(%dx)
f01005d1:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005d8:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005dc:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005df:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01005e2:	ee                   	out    %al,(%dx)
f01005e3:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f01005ea:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f01005ee:	8a 45 cb             	mov    -0x35(%ebp),%al
f01005f1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01005f4:	ee                   	out    %al,(%dx)
f01005f5:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f01005fc:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f0100600:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100603:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100606:	ee                   	out    %al,(%dx)
f0100607:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010060e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100611:	89 c2                	mov    %eax,%edx
f0100613:	ec                   	in     (%dx),%al
f0100614:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100617:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f010061a:	3c ff                	cmp    $0xff,%al
f010061c:	0f 95 c0             	setne  %al
f010061f:	0f b6 c0             	movzbl %al,%eax
f0100622:	a3 84 11 5a f0       	mov    %eax,0xf05a1184
f0100627:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100631:	89 c2                	mov    %eax,%edx
f0100633:	ec                   	in     (%dx),%al
f0100634:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100637:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010063e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100641:	89 c2                	mov    %eax,%edx
f0100643:	ec                   	in     (%dx),%al
f0100644:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100647:	83 ec 08             	sub    $0x8,%esp
f010064a:	68 65 05 10 f0       	push   $0xf0100565
f010064f:	6a 04                	push   $0x4
f0100651:	e8 17 cd 00 00       	call   f010d36d <irq_install_handler>
f0100656:	83 c4 10             	add    $0x10,%esp

}
f0100659:	90                   	nop
f010065a:	c9                   	leave  
f010065b:	c3                   	ret    

f010065c <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010065c:	55                   	push   %ebp
f010065d:	89 e5                	mov    %esp,%ebp
f010065f:	83 ec 20             	sub    $0x20,%esp
f0100662:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100669:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010066c:	89 c2                	mov    %eax,%edx
f010066e:	ec                   	in     (%dx),%al
f010066f:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100672:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100679:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010067c:	89 c2                	mov    %eax,%edx
f010067e:	ec                   	in     (%dx),%al
f010067f:	88 45 ed             	mov    %al,-0x13(%ebp)
f0100682:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f0100689:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010068c:	89 c2                	mov    %eax,%edx
f010068e:	ec                   	in     (%dx),%al
f010068f:	88 45 ee             	mov    %al,-0x12(%ebp)
f0100692:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f0100699:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010069c:	89 c2                	mov    %eax,%edx
f010069e:	ec                   	in     (%dx),%al
f010069f:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006a2:	90                   	nop
f01006a3:	c9                   	leave  
f01006a4:	c3                   	ret    

f01006a5 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006a5:	55                   	push   %ebp
f01006a6:	89 e5                	mov    %esp,%ebp
f01006a8:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006b2:	eb 08                	jmp    f01006bc <lpt_putc+0x17>
		delay();
f01006b4:	e8 a3 ff ff ff       	call   f010065c <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006b9:	ff 45 fc             	incl   -0x4(%ebp)
f01006bc:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006c6:	89 c2                	mov    %eax,%edx
f01006c8:	ec                   	in     (%dx),%al
f01006c9:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006cc:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006cf:	84 c0                	test   %al,%al
f01006d1:	78 09                	js     f01006dc <lpt_putc+0x37>
f01006d3:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006da:	7e d8                	jle    f01006b4 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01006df:	0f b6 c0             	movzbl %al,%eax
f01006e2:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f01006e9:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01006ec:	8a 45 e8             	mov    -0x18(%ebp),%al
f01006ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01006f2:	ee                   	out    %al,(%dx)
f01006f3:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f01006fa:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f01006fe:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100701:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100704:	ee                   	out    %al,(%dx)
f0100705:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010070c:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f0100710:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100713:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100716:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100717:	90                   	nop
f0100718:	c9                   	leave  
f0100719:	c3                   	ret    

f010071a <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f010071a:	55                   	push   %ebp
f010071b:	89 e5                	mov    %esp,%ebp
f010071d:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f0100720:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100727:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010072a:	66 8b 00             	mov    (%eax),%ax
f010072d:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100731:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100734:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100739:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010073c:	66 8b 00             	mov    (%eax),%ax
f010073f:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100743:	74 13                	je     f0100758 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100745:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010074c:	c7 05 88 11 5a f0 b4 	movl   $0x3b4,0xf05a1188
f0100753:	03 00 00 
f0100756:	eb 14                	jmp    f010076c <cga_init+0x52>
	} else {
		*cp = was;
f0100758:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010075b:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010075f:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100762:	c7 05 88 11 5a f0 d4 	movl   $0x3d4,0xf05a1188
f0100769:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010076c:	a1 88 11 5a f0       	mov    0xf05a1188,%eax
f0100771:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100774:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100778:	8a 45 e0             	mov    -0x20(%ebp),%al
f010077b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010077e:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010077f:	a1 88 11 5a f0       	mov    0xf05a1188,%eax
f0100784:	40                   	inc    %eax
f0100785:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100788:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010078b:	89 c2                	mov    %eax,%edx
f010078d:	ec                   	in     (%dx),%al
f010078e:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f0100791:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100794:	0f b6 c0             	movzbl %al,%eax
f0100797:	c1 e0 08             	shl    $0x8,%eax
f010079a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f010079d:	a1 88 11 5a f0       	mov    0xf05a1188,%eax
f01007a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007a5:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007a9:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007ac:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007af:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007b0:	a1 88 11 5a f0       	mov    0xf05a1188,%eax
f01007b5:	40                   	inc    %eax
f01007b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007bc:	89 c2                	mov    %eax,%edx
f01007be:	ec                   	in     (%dx),%al
f01007bf:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007c2:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007c5:	0f b6 c0             	movzbl %al,%eax
f01007c8:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ce:	a3 8c 11 5a f0       	mov    %eax,0xf05a118c
	crt_pos = pos;
f01007d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007d6:	66 a3 90 11 5a f0    	mov    %ax,0xf05a1190
}
f01007dc:	90                   	nop
f01007dd:	c9                   	leave  
f01007de:	c3                   	ret    

f01007df <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007df:	55                   	push   %ebp
f01007e0:	89 e5                	mov    %esp,%ebp
f01007e2:	53                   	push   %ebx
f01007e3:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f01007e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01007e9:	b0 00                	mov    $0x0,%al
f01007eb:	85 c0                	test   %eax,%eax
f01007ed:	75 07                	jne    f01007f6 <cga_putc+0x17>
		c |= 0x0700;
f01007ef:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f01007f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01007f9:	0f b6 c0             	movzbl %al,%eax
f01007fc:	83 f8 0a             	cmp    $0xa,%eax
f01007ff:	74 77                	je     f0100878 <cga_putc+0x99>
f0100801:	83 f8 0a             	cmp    $0xa,%eax
f0100804:	7f 13                	jg     f0100819 <cga_putc+0x3a>
f0100806:	83 f8 08             	cmp    $0x8,%eax
f0100809:	74 2e                	je     f0100839 <cga_putc+0x5a>
f010080b:	83 f8 09             	cmp    $0x9,%eax
f010080e:	0f 84 a8 00 00 00    	je     f01008bc <cga_putc+0xdd>
f0100814:	e9 22 01 00 00       	jmp    f010093b <cga_putc+0x15c>
f0100819:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010081e:	0f 84 de 00 00 00    	je     f0100902 <cga_putc+0x123>
f0100824:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100829:	0f 84 f1 00 00 00    	je     f0100920 <cga_putc+0x141>
f010082f:	83 f8 0d             	cmp    $0xd,%eax
f0100832:	74 5d                	je     f0100891 <cga_putc+0xb2>
f0100834:	e9 02 01 00 00       	jmp    f010093b <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100839:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f010083f:	66 85 c0             	test   %ax,%ax
f0100842:	0f 84 4f 01 00 00    	je     f0100997 <cga_putc+0x1b8>
			crt_pos--;
f0100848:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f010084e:	48                   	dec    %eax
f010084f:	66 a3 90 11 5a f0    	mov    %ax,0xf05a1190
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100855:	8b 15 8c 11 5a f0    	mov    0xf05a118c,%edx
f010085b:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100861:	0f b7 c0             	movzwl %ax,%eax
f0100864:	01 c0                	add    %eax,%eax
f0100866:	01 c2                	add    %eax,%edx
f0100868:	8b 45 08             	mov    0x8(%ebp),%eax
f010086b:	b0 00                	mov    $0x0,%al
f010086d:	83 c8 20             	or     $0x20,%eax
f0100870:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100873:	e9 1f 01 00 00       	jmp    f0100997 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100878:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f010087e:	83 c0 50             	add    $0x50,%eax
f0100881:	66 a3 90 11 5a f0    	mov    %ax,0xf05a1190
		text_length = 0;
f0100887:	c7 05 80 11 5a f0 00 	movl   $0x0,0xf05a1180
f010088e:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f0100891:	66 8b 0d 90 11 5a f0 	mov    0xf05a1190,%cx
f0100898:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f010089e:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008a3:	ba 00 00 00 00       	mov    $0x0,%edx
f01008a8:	66 f7 f3             	div    %bx
f01008ab:	89 d0                	mov    %edx,%eax
f01008ad:	29 c1                	sub    %eax,%ecx
f01008af:	89 c8                	mov    %ecx,%eax
f01008b1:	66 a3 90 11 5a f0    	mov    %ax,0xf05a1190
		break;
f01008b7:	e9 e5 00 00 00       	jmp    f01009a1 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008bc:	83 ec 0c             	sub    $0xc,%esp
f01008bf:	6a 20                	push   $0x20
f01008c1:	e8 30 05 00 00       	call   f0100df6 <cons_putc>
f01008c6:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008c9:	83 ec 0c             	sub    $0xc,%esp
f01008cc:	6a 20                	push   $0x20
f01008ce:	e8 23 05 00 00       	call   f0100df6 <cons_putc>
f01008d3:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008d6:	83 ec 0c             	sub    $0xc,%esp
f01008d9:	6a 20                	push   $0x20
f01008db:	e8 16 05 00 00       	call   f0100df6 <cons_putc>
f01008e0:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e3:	83 ec 0c             	sub    $0xc,%esp
f01008e6:	6a 20                	push   $0x20
f01008e8:	e8 09 05 00 00       	call   f0100df6 <cons_putc>
f01008ed:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f0:	83 ec 0c             	sub    $0xc,%esp
f01008f3:	6a 20                	push   $0x20
f01008f5:	e8 fc 04 00 00       	call   f0100df6 <cons_putc>
f01008fa:	83 c4 10             	add    $0x10,%esp
		break;
f01008fd:	e9 9f 00 00 00       	jmp    f01009a1 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100902:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100908:	66 85 c0             	test   %ax,%ax
f010090b:	0f 84 89 00 00 00    	je     f010099a <cga_putc+0x1bb>
			crt_pos--;
f0100911:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100917:	48                   	dec    %eax
f0100918:	66 a3 90 11 5a f0    	mov    %ax,0xf05a1190
		break;
f010091e:	eb 7a                	jmp    f010099a <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f0100920:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100926:	66 3d cf 07          	cmp    $0x7cf,%ax
f010092a:	77 71                	ja     f010099d <cga_putc+0x1be>
			crt_pos++;
f010092c:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100932:	40                   	inc    %eax
f0100933:	66 a3 90 11 5a f0    	mov    %ax,0xf05a1190
		break;
f0100939:	eb 62                	jmp    f010099d <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010093b:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100942:	74 5c                	je     f01009a0 <cga_putc+0x1c1>
f0100944:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010094b:	74 53                	je     f01009a0 <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010094d:	8b 0d 8c 11 5a f0    	mov    0xf05a118c,%ecx
f0100953:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100959:	8d 50 01             	lea    0x1(%eax),%edx
f010095c:	66 89 15 90 11 5a f0 	mov    %dx,0xf05a1190
f0100963:	0f b7 c0             	movzwl %ax,%eax
f0100966:	01 c0                	add    %eax,%eax
f0100968:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010096b:	8b 45 08             	mov    0x8(%ebp),%eax
f010096e:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100971:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100977:	0f b7 c0             	movzwl %ax,%eax
f010097a:	8b 15 80 11 5a f0    	mov    0xf05a1180,%edx
f0100980:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100986:	39 d0                	cmp    %edx,%eax
f0100988:	7e 16                	jle    f01009a0 <cga_putc+0x1c1>
				text_length++;
f010098a:	a1 80 11 5a f0       	mov    0xf05a1180,%eax
f010098f:	40                   	inc    %eax
f0100990:	a3 80 11 5a f0       	mov    %eax,0xf05a1180
		}
		break;
f0100995:	eb 09                	jmp    f01009a0 <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f0100997:	90                   	nop
f0100998:	eb 07                	jmp    f01009a1 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f010099a:	90                   	nop
f010099b:	eb 04                	jmp    f01009a1 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f010099d:	90                   	nop
f010099e:	eb 01                	jmp    f01009a1 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009a0:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009a1:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f01009a7:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ab:	76 58                	jbe    f0100a05 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009ad:	a1 8c 11 5a f0       	mov    0xf05a118c,%eax
f01009b2:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009b8:	a1 8c 11 5a f0       	mov    0xf05a118c,%eax
f01009bd:	83 ec 04             	sub    $0x4,%esp
f01009c0:	68 00 0f 00 00       	push   $0xf00
f01009c5:	52                   	push   %edx
f01009c6:	50                   	push   %eax
f01009c7:	e8 5e 1c 02 00       	call   f012262a <memcpy>
f01009cc:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009cf:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009d6:	eb 15                	jmp    f01009ed <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009d8:	8b 15 8c 11 5a f0    	mov    0xf05a118c,%edx
f01009de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01009e1:	01 c0                	add    %eax,%eax
f01009e3:	01 d0                	add    %edx,%eax
f01009e5:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ea:	ff 45 f4             	incl   -0xc(%ebp)
f01009ed:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f01009f4:	7e e2                	jle    f01009d8 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f01009f6:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f01009fc:	83 e8 50             	sub    $0x50,%eax
f01009ff:	66 a3 90 11 5a f0    	mov    %ax,0xf05a1190
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a05:	a1 88 11 5a f0       	mov    0xf05a1188,%eax
f0100a0a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a0d:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a11:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a14:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a17:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a18:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100a1e:	66 c1 e8 08          	shr    $0x8,%ax
f0100a22:	0f b6 c0             	movzbl %al,%eax
f0100a25:	8b 15 88 11 5a f0    	mov    0xf05a1188,%edx
f0100a2b:	42                   	inc    %edx
f0100a2c:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a2f:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a32:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a35:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a38:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a39:	a1 88 11 5a f0       	mov    0xf05a1188,%eax
f0100a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a41:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a45:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a48:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a4b:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a4c:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100a52:	0f b6 c0             	movzbl %al,%eax
f0100a55:	8b 15 88 11 5a f0    	mov    0xf05a1188,%edx
f0100a5b:	42                   	inc    %edx
f0100a5c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a5f:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a62:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a65:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a68:	ee                   	out    %al,(%dx)
}
f0100a69:	90                   	nop
f0100a6a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a6d:	c9                   	leave  
f0100a6e:	c3                   	ret    

f0100a6f <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a6f:	55                   	push   %ebp
f0100a70:	89 e5                	mov    %esp,%ebp
f0100a72:	83 ec 28             	sub    $0x28,%esp
f0100a75:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a7f:	89 c2                	mov    %eax,%edx
f0100a81:	ec                   	in     (%dx),%al
f0100a82:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100a85:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100a88:	0f b6 c0             	movzbl %al,%eax
f0100a8b:	83 e0 01             	and    $0x1,%eax
f0100a8e:	85 c0                	test   %eax,%eax
f0100a90:	75 0a                	jne    f0100a9c <kbd_proc_data+0x2d>
		return -1;
f0100a92:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100a97:	e9 2a 02 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
f0100a9c:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100aa3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100aa6:	89 c2                	mov    %eax,%edx
f0100aa8:	ec                   	in     (%dx),%al
f0100aa9:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100aac:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100aaf:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ab2:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ab6:	75 17                	jne    f0100acf <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ab8:	a1 a8 13 5a f0       	mov    0xf05a13a8,%eax
f0100abd:	83 c8 40             	or     $0x40,%eax
f0100ac0:	a3 a8 13 5a f0       	mov    %eax,0xf05a13a8
		return 0;
f0100ac5:	b8 00 00 00 00       	mov    $0x0,%eax
f0100aca:	e9 f7 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100acf:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100ad2:	84 c0                	test   %al,%al
f0100ad4:	79 44                	jns    f0100b1a <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100ad6:	a1 a8 13 5a f0       	mov    0xf05a13a8,%eax
f0100adb:	83 e0 40             	and    $0x40,%eax
f0100ade:	85 c0                	test   %eax,%eax
f0100ae0:	75 08                	jne    f0100aea <kbd_proc_data+0x7b>
f0100ae2:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100ae5:	83 e0 7f             	and    $0x7f,%eax
f0100ae8:	eb 03                	jmp    f0100aed <kbd_proc_data+0x7e>
f0100aea:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100aed:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100af0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100af4:	8a 80 20 00 18 f0    	mov    -0xfe7ffe0(%eax),%al
f0100afa:	83 c8 40             	or     $0x40,%eax
f0100afd:	0f b6 c0             	movzbl %al,%eax
f0100b00:	f7 d0                	not    %eax
f0100b02:	89 c2                	mov    %eax,%edx
f0100b04:	a1 a8 13 5a f0       	mov    0xf05a13a8,%eax
f0100b09:	21 d0                	and    %edx,%eax
f0100b0b:	a3 a8 13 5a f0       	mov    %eax,0xf05a13a8
		return 0;
f0100b10:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b15:	e9 ac 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b1a:	a1 a8 13 5a f0       	mov    0xf05a13a8,%eax
f0100b1f:	83 e0 40             	and    $0x40,%eax
f0100b22:	85 c0                	test   %eax,%eax
f0100b24:	74 11                	je     f0100b37 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b26:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b2a:	a1 a8 13 5a f0       	mov    0xf05a13a8,%eax
f0100b2f:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b32:	a3 a8 13 5a f0       	mov    %eax,0xf05a13a8
	}

	shift |= shiftcode[data];
f0100b37:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b3b:	8a 80 20 00 18 f0    	mov    -0xfe7ffe0(%eax),%al
f0100b41:	0f b6 d0             	movzbl %al,%edx
f0100b44:	a1 a8 13 5a f0       	mov    0xf05a13a8,%eax
f0100b49:	09 d0                	or     %edx,%eax
f0100b4b:	a3 a8 13 5a f0       	mov    %eax,0xf05a13a8
	shift ^= togglecode[data];
f0100b50:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b54:	8a 80 20 01 18 f0    	mov    -0xfe7fee0(%eax),%al
f0100b5a:	0f b6 d0             	movzbl %al,%edx
f0100b5d:	a1 a8 13 5a f0       	mov    0xf05a13a8,%eax
f0100b62:	31 d0                	xor    %edx,%eax
f0100b64:	a3 a8 13 5a f0       	mov    %eax,0xf05a13a8

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b69:	a1 a8 13 5a f0       	mov    0xf05a13a8,%eax
f0100b6e:	83 e0 03             	and    $0x3,%eax
f0100b71:	8b 14 85 20 05 18 f0 	mov    -0xfe7fae0(,%eax,4),%edx
f0100b78:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b7c:	01 d0                	add    %edx,%eax
f0100b7e:	8a 00                	mov    (%eax),%al
f0100b80:	0f b6 c0             	movzbl %al,%eax
f0100b83:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100b86:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100b8d:	0f 85 9c 00 00 00    	jne    f0100c2f <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100b93:	a1 80 11 5a f0       	mov    0xf05a1180,%eax
f0100b98:	85 c0                	test   %eax,%eax
f0100b9a:	0f 8e 85 00 00 00    	jle    f0100c25 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100ba0:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100ba6:	0f b7 c0             	movzwl %ax,%eax
f0100ba9:	8b 15 80 11 5a f0    	mov    0xf05a1180,%edx
f0100baf:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bb5:	39 d0                	cmp    %edx,%eax
f0100bb7:	75 0a                	jne    f0100bc3 <kbd_proc_data+0x154>
				return 0;
f0100bb9:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bbe:	e9 03 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100bc3:	a1 80 11 5a f0       	mov    0xf05a1180,%eax
f0100bc8:	48                   	dec    %eax
f0100bc9:	a3 80 11 5a f0       	mov    %eax,0xf05a1180
				int crt_pos_Length = crt_pos - 1925;
f0100bce:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100bd4:	0f b7 c0             	movzwl %ax,%eax
f0100bd7:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bdc:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bdf:	66 a1 90 11 5a f0    	mov    0xf05a1190,%ax
f0100be5:	0f b7 c0             	movzwl %ax,%eax
f0100be8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100beb:	eb 26                	jmp    f0100c13 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100bed:	8b 15 8c 11 5a f0    	mov    0xf05a118c,%edx
f0100bf3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100bf6:	01 c0                	add    %eax,%eax
f0100bf8:	01 c2                	add    %eax,%edx
f0100bfa:	a1 8c 11 5a f0       	mov    0xf05a118c,%eax
f0100bff:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c02:	41                   	inc    %ecx
f0100c03:	01 c9                	add    %ecx,%ecx
f0100c05:	01 c8                	add    %ecx,%eax
f0100c07:	66 8b 00             	mov    (%eax),%ax
f0100c0a:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c0d:	ff 45 e8             	incl   -0x18(%ebp)
f0100c10:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c13:	a1 80 11 5a f0       	mov    0xf05a1180,%eax
f0100c18:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c1b:	7e d0                	jle    f0100bed <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c20:	e9 a1 00 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c25:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c2a:	e9 97 00 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c2f:	a1 a8 13 5a f0       	mov    0xf05a13a8,%eax
f0100c34:	83 e0 08             	and    $0x8,%eax
f0100c37:	85 c0                	test   %eax,%eax
f0100c39:	74 22                	je     f0100c5d <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c3b:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c3f:	7e 0c                	jle    f0100c4d <kbd_proc_data+0x1de>
f0100c41:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c45:	7f 06                	jg     f0100c4d <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c47:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c4b:	eb 10                	jmp    f0100c5d <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c4d:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c51:	7e 0a                	jle    f0100c5d <kbd_proc_data+0x1ee>
f0100c53:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c57:	7f 04                	jg     f0100c5d <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c59:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c5d:	a1 a8 13 5a f0       	mov    0xf05a13a8,%eax
f0100c62:	83 f8 10             	cmp    $0x10,%eax
f0100c65:	75 13                	jne    f0100c7a <kbd_proc_data+0x20b>
f0100c67:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c6b:	7e 0d                	jle    f0100c7a <kbd_proc_data+0x20b>
f0100c6d:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c71:	7f 07                	jg     f0100c7a <kbd_proc_data+0x20b>
		return 0;
f0100c73:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c78:	eb 4c                	jmp    f0100cc6 <kbd_proc_data+0x257>
	if (c == 255)
f0100c7a:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100c81:	75 07                	jne    f0100c8a <kbd_proc_data+0x21b>
		return 0;
f0100c83:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c88:	eb 3c                	jmp    f0100cc6 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100c8a:	a1 a8 13 5a f0       	mov    0xf05a13a8,%eax
f0100c8f:	f7 d0                	not    %eax
f0100c91:	83 e0 06             	and    $0x6,%eax
f0100c94:	85 c0                	test   %eax,%eax
f0100c96:	75 2b                	jne    f0100cc3 <kbd_proc_data+0x254>
f0100c98:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100c9f:	75 22                	jne    f0100cc3 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100ca1:	83 ec 0c             	sub    $0xc,%esp
f0100ca4:	68 5b 4b 12 f0       	push   $0xf0124b5b
f0100ca9:	e8 be 02 00 00       	call   f0100f6c <cprintf>
f0100cae:	83 c4 10             	add    $0x10,%esp
f0100cb1:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cb8:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cbc:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cbf:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100cc2:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100cc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100cc6:	c9                   	leave  
f0100cc7:	c3                   	ret    

f0100cc8 <kbd_intr>:

void
kbd_intr(void)
{
f0100cc8:	55                   	push   %ebp
f0100cc9:	89 e5                	mov    %esp,%ebp
f0100ccb:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100cce:	83 ec 0c             	sub    $0xc,%esp
f0100cd1:	68 6f 0a 10 f0       	push   $0xf0100a6f
f0100cd6:	e8 21 00 00 00       	call   f0100cfc <cons_intr>
f0100cdb:	83 c4 10             	add    $0x10,%esp
}
f0100cde:	90                   	nop
f0100cdf:	c9                   	leave  
f0100ce0:	c3                   	ret    

f0100ce1 <kbd_init>:

void
kbd_init(void)
{
f0100ce1:	55                   	push   %ebp
f0100ce2:	89 e5                	mov    %esp,%ebp
f0100ce4:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100ce7:	83 ec 08             	sub    $0x8,%esp
f0100cea:	68 83 0e 10 f0       	push   $0xf0100e83
f0100cef:	6a 01                	push   $0x1
f0100cf1:	e8 77 c6 00 00       	call   f010d36d <irq_install_handler>
f0100cf6:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100cf9:	90                   	nop
f0100cfa:	c9                   	leave  
f0100cfb:	c3                   	ret    

f0100cfc <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100cfc:	55                   	push   %ebp
f0100cfd:	89 e5                	mov    %esp,%ebp
f0100cff:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d02:	eb 35                	jmp    f0100d39 <cons_intr+0x3d>
		if (c == 0)
f0100d04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d08:	75 02                	jne    f0100d0c <cons_intr+0x10>
			continue;
f0100d0a:	eb 2d                	jmp    f0100d39 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d0c:	a1 a4 13 5a f0       	mov    0xf05a13a4,%eax
f0100d11:	8d 50 01             	lea    0x1(%eax),%edx
f0100d14:	89 15 a4 13 5a f0    	mov    %edx,0xf05a13a4
f0100d1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d1d:	88 90 a0 11 5a f0    	mov    %dl,-0xfa5ee60(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d23:	a1 a4 13 5a f0       	mov    0xf05a13a4,%eax
f0100d28:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d2d:	75 0a                	jne    f0100d39 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d2f:	c7 05 a4 13 5a f0 00 	movl   $0x0,0xf05a13a4
f0100d36:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d39:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d3c:	ff d0                	call   *%eax
f0100d3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d41:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d45:	75 bd                	jne    f0100d04 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d47:	90                   	nop
f0100d48:	c9                   	leave  
f0100d49:	c3                   	ret    

f0100d4a <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d4a:	55                   	push   %ebp
f0100d4b:	89 e5                	mov    %esp,%ebp
f0100d4d:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d50:	e8 ee f7 ff ff       	call   f0100543 <serial_intr>
	kbd_intr();
f0100d55:	e8 6e ff ff ff       	call   f0100cc8 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d5a:	8b 15 a0 13 5a f0    	mov    0xf05a13a0,%edx
f0100d60:	a1 a4 13 5a f0       	mov    0xf05a13a4,%eax
f0100d65:	39 c2                	cmp    %eax,%edx
f0100d67:	74 35                	je     f0100d9e <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d69:	a1 a0 13 5a f0       	mov    0xf05a13a0,%eax
f0100d6e:	8d 50 01             	lea    0x1(%eax),%edx
f0100d71:	89 15 a0 13 5a f0    	mov    %edx,0xf05a13a0
f0100d77:	8a 80 a0 11 5a f0    	mov    -0xfa5ee60(%eax),%al
f0100d7d:	0f b6 c0             	movzbl %al,%eax
f0100d80:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100d83:	a1 a0 13 5a f0       	mov    0xf05a13a0,%eax
f0100d88:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d8d:	75 0a                	jne    f0100d99 <cons_getc+0x4f>
			cons.rpos = 0;
f0100d8f:	c7 05 a0 13 5a f0 00 	movl   $0x0,0xf05a13a0
f0100d96:	00 00 00 
		return c;
f0100d99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100d9c:	eb 05                	jmp    f0100da3 <cons_getc+0x59>
	}
	return 0;
f0100d9e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100da3:	c9                   	leave  
f0100da4:	c3                   	ret    

f0100da5 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100da5:	55                   	push   %ebp
f0100da6:	89 e5                	mov    %esp,%ebp
f0100da8:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dab:	8b 15 a0 13 5a f0    	mov    0xf05a13a0,%edx
f0100db1:	a1 a4 13 5a f0       	mov    0xf05a13a4,%eax
f0100db6:	39 c2                	cmp    %eax,%edx
f0100db8:	74 35                	je     f0100def <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dba:	a1 a0 13 5a f0       	mov    0xf05a13a0,%eax
f0100dbf:	8d 50 01             	lea    0x1(%eax),%edx
f0100dc2:	89 15 a0 13 5a f0    	mov    %edx,0xf05a13a0
f0100dc8:	8a 80 a0 11 5a f0    	mov    -0xfa5ee60(%eax),%al
f0100dce:	0f b6 c0             	movzbl %al,%eax
f0100dd1:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100dd4:	a1 a0 13 5a f0       	mov    0xf05a13a0,%eax
f0100dd9:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dde:	75 0a                	jne    f0100dea <cons_getc2+0x45>
			cons.rpos = 0;
f0100de0:	c7 05 a0 13 5a f0 00 	movl   $0x0,0xf05a13a0
f0100de7:	00 00 00 
		return c;
f0100dea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100ded:	eb 05                	jmp    f0100df4 <cons_getc2+0x4f>
	}
	return 0;
f0100def:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100df4:	c9                   	leave  
f0100df5:	c3                   	ret    

f0100df6 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100df6:	55                   	push   %ebp
f0100df7:	89 e5                	mov    %esp,%ebp
f0100df9:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100dfc:	ff 75 08             	pushl  0x8(%ebp)
f0100dff:	e8 a1 f8 ff ff       	call   f01006a5 <lpt_putc>
f0100e04:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e07:	83 ec 0c             	sub    $0xc,%esp
f0100e0a:	ff 75 08             	pushl  0x8(%ebp)
f0100e0d:	e8 cd f9 ff ff       	call   f01007df <cga_putc>
f0100e12:	83 c4 10             	add    $0x10,%esp
}
f0100e15:	90                   	nop
f0100e16:	c9                   	leave  
f0100e17:	c3                   	ret    

f0100e18 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e18:	55                   	push   %ebp
f0100e19:	89 e5                	mov    %esp,%ebp
f0100e1b:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e1e:	e8 f7 f8 ff ff       	call   f010071a <cga_init>
	kbd_init();
f0100e23:	e8 b9 fe ff ff       	call   f0100ce1 <kbd_init>
	serial_init();
f0100e28:	e8 56 f7 ff ff       	call   f0100583 <serial_init>

	if (!serial_exists)
f0100e2d:	a1 84 11 5a f0       	mov    0xf05a1184,%eax
f0100e32:	85 c0                	test   %eax,%eax
f0100e34:	75 10                	jne    f0100e46 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e36:	83 ec 0c             	sub    $0xc,%esp
f0100e39:	68 67 4b 12 f0       	push   $0xf0124b67
f0100e3e:	e8 29 01 00 00       	call   f0100f6c <cprintf>
f0100e43:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e46:	90                   	nop
f0100e47:	c9                   	leave  
f0100e48:	c3                   	ret    

f0100e49 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e49:	55                   	push   %ebp
f0100e4a:	89 e5                	mov    %esp,%ebp
f0100e4c:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e4f:	83 ec 0c             	sub    $0xc,%esp
f0100e52:	ff 75 08             	pushl  0x8(%ebp)
f0100e55:	e8 9c ff ff ff       	call   f0100df6 <cons_putc>
f0100e5a:	83 c4 10             	add    $0x10,%esp
}
f0100e5d:	90                   	nop
f0100e5e:	c9                   	leave  
f0100e5f:	c3                   	ret    

f0100e60 <getchar>:

int
getchar(void)
{
f0100e60:	55                   	push   %ebp
f0100e61:	89 e5                	mov    %esp,%ebp
f0100e63:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e66:	e8 df fe ff ff       	call   f0100d4a <cons_getc>
f0100e6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e72:	74 f2                	je     f0100e66 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e74:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e77:	c9                   	leave  
f0100e78:	c3                   	ret    

f0100e79 <iscons>:

int
iscons(int fdnum)
{
f0100e79:	55                   	push   %ebp
f0100e7a:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e7c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100e81:	5d                   	pop    %ebp
f0100e82:	c3                   	ret    

f0100e83 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100e83:	55                   	push   %ebp
f0100e84:	89 e5                	mov    %esp,%ebp
f0100e86:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100e89:	e8 3a fe ff ff       	call   f0100cc8 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100e8e:	90                   	nop
f0100e8f:	c9                   	leave  
f0100e90:	c3                   	ret    

f0100e91 <cons_lock>:

void cons_lock(void)
{
f0100e91:	55                   	push   %ebp
f0100e92:	89 e5                	mov    %esp,%ebp
f0100e94:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100e97:	e8 c1 3d 00 00       	call   f0104c5d <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100e9c:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100e9d:	e8 a3 98 00 00       	call   f010a745 <get_cpu_proc>
f0100ea2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ea5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ea9:	75 17                	jne    f0100ec2 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eab:	83 ec 04             	sub    $0x4,%esp
f0100eae:	68 84 4b 12 f0       	push   $0xf0124b84
f0100eb3:	68 2d 02 00 00       	push   $0x22d
f0100eb8:	68 ab 4b 12 f0       	push   $0xf0124bab
f0100ebd:	e8 58 f4 ff ff       	call   f010031a <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ec2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ec5:	8b 00                	mov    (%eax),%eax
f0100ec7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100eca:	8b 12                	mov    (%edx),%edx
f0100ecc:	8b 52 38             	mov    0x38(%edx),%edx
f0100ecf:	80 e6 fd             	and    $0xfd,%dh
f0100ed2:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ed5:	90                   	nop
f0100ed6:	c9                   	leave  
f0100ed7:	c3                   	ret    

f0100ed8 <cons_unlock>:

void cons_unlock(void)
{
f0100ed8:	55                   	push   %ebp
f0100ed9:	89 e5                	mov    %esp,%ebp
f0100edb:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100ede:	e8 7a 3d 00 00       	call   f0104c5d <kclock_stop>
f0100ee3:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ee4:	e8 5c 98 00 00       	call   f010a745 <get_cpu_proc>
f0100ee9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100eec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ef0:	75 17                	jne    f0100f09 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100ef2:	83 ec 04             	sub    $0x4,%esp
f0100ef5:	68 c0 4b 12 f0       	push   $0xf0124bc0
f0100efa:	68 46 02 00 00       	push   $0x246
f0100eff:	68 ab 4b 12 f0       	push   $0xf0124bab
f0100f04:	e8 11 f4 ff ff       	call   f010031a <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f0c:	8b 00                	mov    (%eax),%eax
f0100f0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f11:	8b 12                	mov    (%edx),%edx
f0100f13:	8b 52 38             	mov    0x38(%edx),%edx
f0100f16:	80 ce 02             	or     $0x2,%dh
f0100f19:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f1c:	90                   	nop
f0100f1d:	c9                   	leave  
f0100f1e:	c3                   	ret    

f0100f1f <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f1f:	55                   	push   %ebp
f0100f20:	89 e5                	mov    %esp,%ebp
f0100f22:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f25:	83 ec 0c             	sub    $0xc,%esp
f0100f28:	ff 75 08             	pushl  0x8(%ebp)
f0100f2b:	e8 19 ff ff ff       	call   f0100e49 <cputchar>
f0100f30:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f33:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f36:	8b 00                	mov    (%eax),%eax
f0100f38:	8d 50 01             	lea    0x1(%eax),%edx
f0100f3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f3e:	89 10                	mov    %edx,(%eax)
}
f0100f40:	90                   	nop
f0100f41:	c9                   	leave  
f0100f42:	c3                   	ret    

f0100f43 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f43:	55                   	push   %ebp
f0100f44:	89 e5                	mov    %esp,%ebp
f0100f46:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f49:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f50:	ff 75 0c             	pushl  0xc(%ebp)
f0100f53:	ff 75 08             	pushl  0x8(%ebp)
f0100f56:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f59:	50                   	push   %eax
f0100f5a:	68 1f 0f 10 f0       	push   $0xf0100f1f
f0100f5f:	e8 e6 0d 02 00       	call   f0121d4a <vprintfmt>
f0100f64:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f67:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f6a:	c9                   	leave  
f0100f6b:	c3                   	ret    

f0100f6c <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f6c:	55                   	push   %ebp
f0100f6d:	89 e5                	mov    %esp,%ebp
f0100f6f:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f72:	e8 1e 62 00 00       	call   f0107195 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f77:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f80:	83 ec 08             	sub    $0x8,%esp
f0100f83:	ff 75 f4             	pushl  -0xc(%ebp)
f0100f86:	50                   	push   %eax
f0100f87:	e8 b7 ff ff ff       	call   f0100f43 <vcprintf>
f0100f8c:	83 c4 10             	add    $0x10,%esp
f0100f8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100f92:	e8 50 62 00 00       	call   f01071e7 <popcli>

	return cnt;
f0100f97:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100f9a:	c9                   	leave  
f0100f9b:	c3                   	ret    

f0100f9c <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100f9c:	55                   	push   %ebp
f0100f9d:	89 e5                	mov    %esp,%ebp
f0100f9f:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fa2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fa9:	eb 10                	jmp    f0100fbb <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fab:	83 ec 0c             	sub    $0xc,%esp
f0100fae:	6a 08                	push   $0x8
f0100fb0:	e8 94 fe ff ff       	call   f0100e49 <cputchar>
f0100fb5:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fb8:	ff 45 f4             	incl   -0xc(%ebp)
f0100fbb:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fbe:	8b 00                	mov    (%eax),%eax
f0100fc0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fc3:	7f e6                	jg     f0100fab <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fc5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fc8:	c1 e0 0a             	shl    $0xa,%eax
f0100fcb:	05 40 dc 5b f0       	add    $0xf05bdc40,%eax
f0100fd0:	83 ec 0c             	sub    $0xc,%esp
f0100fd3:	50                   	push   %eax
f0100fd4:	e8 33 14 02 00       	call   f012240c <strlen>
f0100fd9:	83 c4 10             	add    $0x10,%esp
f0100fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100fdf:	83 ec 04             	sub    $0x4,%esp
f0100fe2:	68 00 04 00 00       	push   $0x400
f0100fe7:	68 60 2c 5c f0       	push   $0xf05c2c60
f0100fec:	ff 75 10             	pushl  0x10(%ebp)
f0100fef:	e8 36 16 02 00       	call   f012262a <memcpy>
f0100ff4:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0100ff7:	8b 45 08             	mov    0x8(%ebp),%eax
f0100ffa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0101000:	eb 52                	jmp    f0101054 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101002:	8b 45 08             	mov    0x8(%ebp),%eax
f0101005:	8b 00                	mov    (%eax),%eax
f0101007:	8b 55 0c             	mov    0xc(%ebp),%edx
f010100a:	c1 e2 0a             	shl    $0xa,%edx
f010100d:	01 d0                	add    %edx,%eax
f010100f:	05 40 dc 5b f0       	add    $0xf05bdc40,%eax
f0101014:	8a 00                	mov    (%eax),%al
f0101016:	0f be c0             	movsbl %al,%eax
f0101019:	83 ec 0c             	sub    $0xc,%esp
f010101c:	50                   	push   %eax
f010101d:	e8 27 fe ff ff       	call   f0100e49 <cputchar>
f0101022:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101025:	8b 45 08             	mov    0x8(%ebp),%eax
f0101028:	8b 00                	mov    (%eax),%eax
f010102a:	89 c2                	mov    %eax,%edx
f010102c:	8b 45 10             	mov    0x10(%ebp),%eax
f010102f:	01 c2                	add    %eax,%edx
f0101031:	8b 45 08             	mov    0x8(%ebp),%eax
f0101034:	8b 00                	mov    (%eax),%eax
f0101036:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101039:	c1 e1 0a             	shl    $0xa,%ecx
f010103c:	01 c8                	add    %ecx,%eax
f010103e:	05 40 dc 5b f0       	add    $0xf05bdc40,%eax
f0101043:	8a 00                	mov    (%eax),%al
f0101045:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101047:	8b 45 08             	mov    0x8(%ebp),%eax
f010104a:	8b 00                	mov    (%eax),%eax
f010104c:	8d 50 01             	lea    0x1(%eax),%edx
f010104f:	8b 45 08             	mov    0x8(%ebp),%eax
f0101052:	89 10                	mov    %edx,(%eax)
f0101054:	8b 45 08             	mov    0x8(%ebp),%eax
f0101057:	8b 00                	mov    (%eax),%eax
f0101059:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010105c:	7c a4                	jl     f0101002 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010105e:	8b 45 14             	mov    0x14(%ebp),%eax
f0101061:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101064:	89 10                	mov    %edx,(%eax)
}
f0101066:	90                   	nop
f0101067:	c9                   	leave  
f0101068:	c3                   	ret    

f0101069 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101069:	55                   	push   %ebp
f010106a:	89 e5                	mov    %esp,%ebp
f010106c:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010106f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101076:	eb 10                	jmp    f0101088 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101078:	83 ec 0c             	sub    $0xc,%esp
f010107b:	6a 08                	push   $0x8
f010107d:	e8 c7 fd ff ff       	call   f0100e49 <cputchar>
f0101082:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f0101085:	ff 45 f4             	incl   -0xc(%ebp)
f0101088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010108b:	3b 45 08             	cmp    0x8(%ebp),%eax
f010108e:	7c e8                	jl     f0101078 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f0101090:	83 ec 0c             	sub    $0xc,%esp
f0101093:	ff 75 0c             	pushl  0xc(%ebp)
f0101096:	e8 71 13 02 00       	call   f012240c <strlen>
f010109b:	83 c4 10             	add    $0x10,%esp
f010109e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010a1:	83 ec 04             	sub    $0x4,%esp
f01010a4:	68 00 04 00 00       	push   $0x400
f01010a9:	68 60 2c 5c f0       	push   $0xf05c2c60
f01010ae:	ff 75 10             	pushl  0x10(%ebp)
f01010b1:	e8 74 15 02 00       	call   f012262a <memcpy>
f01010b6:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010b9:	8b 45 14             	mov    0x14(%ebp),%eax
f01010bc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010c2:	eb 46                	jmp    f010110a <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010c4:	8b 45 14             	mov    0x14(%ebp),%eax
f01010c7:	8b 00                	mov    (%eax),%eax
f01010c9:	89 c2                	mov    %eax,%edx
f01010cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ce:	01 d0                	add    %edx,%eax
f01010d0:	8a 00                	mov    (%eax),%al
f01010d2:	0f be c0             	movsbl %al,%eax
f01010d5:	83 ec 0c             	sub    $0xc,%esp
f01010d8:	50                   	push   %eax
f01010d9:	e8 6b fd ff ff       	call   f0100e49 <cputchar>
f01010de:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f01010e1:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e4:	8b 00                	mov    (%eax),%eax
f01010e6:	89 c2                	mov    %eax,%edx
f01010e8:	8b 45 10             	mov    0x10(%ebp),%eax
f01010eb:	01 c2                	add    %eax,%edx
f01010ed:	8b 45 14             	mov    0x14(%ebp),%eax
f01010f0:	8b 00                	mov    (%eax),%eax
f01010f2:	89 c1                	mov    %eax,%ecx
f01010f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010f7:	01 c8                	add    %ecx,%eax
f01010f9:	8a 00                	mov    (%eax),%al
f01010fb:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f01010fd:	8b 45 14             	mov    0x14(%ebp),%eax
f0101100:	8b 00                	mov    (%eax),%eax
f0101102:	8d 50 01             	lea    0x1(%eax),%edx
f0101105:	8b 45 14             	mov    0x14(%ebp),%eax
f0101108:	89 10                	mov    %edx,(%eax)
f010110a:	8b 45 14             	mov    0x14(%ebp),%eax
f010110d:	8b 00                	mov    (%eax),%eax
f010110f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101112:	7c b0                	jl     f01010c4 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101114:	8b 45 18             	mov    0x18(%ebp),%eax
f0101117:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010111a:	89 10                	mov    %edx,(%eax)
}
f010111c:	90                   	nop
f010111d:	c9                   	leave  
f010111e:	c3                   	ret    

f010111f <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010111f:	55                   	push   %ebp
f0101120:	89 e5                	mov    %esp,%ebp
f0101122:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101125:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010112c:	eb 21                	jmp    f010114f <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010112e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101131:	c1 e0 0a             	shl    $0xa,%eax
f0101134:	05 40 4c 5a f0       	add    $0xf05a4c40,%eax
f0101139:	83 ec 04             	sub    $0x4,%esp
f010113c:	68 00 04 00 00       	push   $0x400
f0101141:	6a 00                	push   $0x0
f0101143:	50                   	push   %eax
f0101144:	e8 b1 14 02 00       	call   f01225fa <memset>
f0101149:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010114c:	ff 45 f4             	incl   -0xc(%ebp)
f010114f:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101153:	7e d9                	jle    f010112e <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101155:	90                   	nop
f0101156:	c9                   	leave  
f0101157:	c3                   	ret    

f0101158 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101158:	55                   	push   %ebp
f0101159:	89 e5                	mov    %esp,%ebp
f010115b:	57                   	push   %edi
f010115c:	53                   	push   %ebx
f010115d:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101163:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101167:	74 13                	je     f010117c <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101169:	83 ec 08             	sub    $0x8,%esp
f010116c:	ff 75 08             	pushl  0x8(%ebp)
f010116f:	68 ec 4b 12 f0       	push   $0xf0124bec
f0101174:	e8 f3 fd ff ff       	call   f0100f6c <cprintf>
f0101179:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010117c:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101181:	40                   	inc    %eax
f0101182:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f0101185:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f010118c:	00 00 00 
f010118f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101195:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f010119b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011a4:	83 ec 0c             	sub    $0xc,%esp
f01011a7:	6a 00                	push   $0x0
f01011a9:	e8 cb fc ff ff       	call   f0100e79 <iscons>
f01011ae:	83 c4 10             	add    $0x10,%esp
f01011b1:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011b4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011bb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011c2:	e8 99 fc ff ff       	call   f0100e60 <getchar>
f01011c7:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011ca:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011d0:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011d6:	39 c2                	cmp    %eax,%edx
f01011d8:	7e 0c                	jle    f01011e6 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011da:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011e0:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f01011e6:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f01011ea:	79 22                	jns    f010120e <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f01011ec:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f01011f0:	0f 84 94 0a 00 00    	je     f0101c8a <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f01011f6:	83 ec 08             	sub    $0x8,%esp
f01011f9:	ff 75 94             	pushl  -0x6c(%ebp)
f01011fc:	68 ef 4b 12 f0       	push   $0xf0124bef
f0101201:	e8 66 fd ff ff       	call   f0100f6c <cprintf>
f0101206:	83 c4 10             	add    $0x10,%esp
			return;
f0101209:	e9 7c 0a 00 00       	jmp    f0101c8a <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010120e:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101215:	75 2a                	jne    f0101241 <command_prompt_readline+0xe9>
			if (commandidx)
f0101217:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010121b:	74 03                	je     f0101220 <command_prompt_readline+0xc8>
				commandidx--;
f010121d:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101220:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101226:	50                   	push   %eax
f0101227:	ff 75 0c             	pushl  0xc(%ebp)
f010122a:	ff 75 f4             	pushl  -0xc(%ebp)
f010122d:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101233:	50                   	push   %eax
f0101234:	e8 63 fd ff ff       	call   f0100f9c <clearandwritecommand>
f0101239:	83 c4 10             	add    $0x10,%esp
f010123c:	e9 32 0a 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101241:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101248:	75 3b                	jne    f0101285 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f010124a:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f010124f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101252:	7d 03                	jge    f0101257 <command_prompt_readline+0xff>
				commandidx++;
f0101254:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101257:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f010125c:	85 c0                	test   %eax,%eax
f010125e:	0f 88 0f 0a 00 00    	js     f0101c73 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101264:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f010126a:	50                   	push   %eax
f010126b:	ff 75 0c             	pushl  0xc(%ebp)
f010126e:	ff 75 f4             	pushl  -0xc(%ebp)
f0101271:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101277:	50                   	push   %eax
f0101278:	e8 1f fd ff ff       	call   f0100f9c <clearandwritecommand>
f010127d:	83 c4 10             	add    $0x10,%esp
f0101280:	e9 ee 09 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f0101285:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f0101289:	0f 85 6d 07 00 00    	jne    f01019fc <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f010128f:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f0101293:	0f 84 fc 06 00 00    	je     f0101995 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f0101299:	83 ec 08             	sub    $0x8,%esp
f010129c:	6a 64                	push   $0x64
f010129e:	68 40 4c 5a f0       	push   $0xf05a4c40
f01012a3:	e8 77 fe ff ff       	call   f010111f <clear_prefix_list>
f01012a8:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ab:	83 ec 0c             	sub    $0xc,%esp
f01012ae:	ff 75 0c             	pushl  0xc(%ebp)
f01012b1:	e8 56 11 02 00       	call   f012240c <strlen>
f01012b6:	83 c4 10             	add    $0x10,%esp
f01012b9:	85 c0                	test   %eax,%eax
f01012bb:	0f 84 bd 09 00 00    	je     f0101c7e <command_prompt_readline+0xb26>
f01012c1:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012c8:	0f 84 b0 09 00 00    	je     f0101c7e <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012d8:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012de:	83 ec 08             	sub    $0x8,%esp
f01012e1:	ff 75 0c             	pushl  0xc(%ebp)
f01012e4:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01012ea:	50                   	push   %eax
f01012eb:	e8 6b 11 02 00       	call   f012245b <strcpy>
f01012f0:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f01012f3:	83 ec 0c             	sub    $0xc,%esp
f01012f6:	ff 75 0c             	pushl  0xc(%ebp)
f01012f9:	e8 0e 11 02 00       	call   f012240c <strlen>
f01012fe:	83 c4 10             	add    $0x10,%esp
f0101301:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101304:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101307:	8d 50 ff             	lea    -0x1(%eax),%edx
f010130a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010130d:	01 d0                	add    %edx,%eax
f010130f:	8a 00                	mov    (%eax),%al
f0101311:	3c 20                	cmp    $0x20,%al
f0101313:	0f 84 6b 09 00 00    	je     f0101c84 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101319:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010131f:	50                   	push   %eax
f0101320:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101326:	50                   	push   %eax
f0101327:	68 ff 4b 12 f0       	push   $0xf0124bff
f010132c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101332:	50                   	push   %eax
f0101333:	e8 e9 16 02 00       	call   f0122a21 <strsplit>
f0101338:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010133b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101342:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101348:	83 f8 01             	cmp    $0x1,%eax
f010134b:	0f 8e 28 01 00 00    	jle    f0101479 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101351:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101357:	83 ec 08             	sub    $0x8,%esp
f010135a:	68 04 4c 12 f0       	push   $0xf0124c04
f010135f:	50                   	push   %eax
f0101360:	e8 b3 11 02 00       	call   f0122518 <strcmp>
f0101365:	83 c4 10             	add    $0x10,%esp
f0101368:	85 c0                	test   %eax,%eax
f010136a:	74 3c                	je     f01013a8 <command_prompt_readline+0x250>
f010136c:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101372:	83 ec 08             	sub    $0x8,%esp
f0101375:	68 08 4c 12 f0       	push   $0xf0124c08
f010137a:	50                   	push   %eax
f010137b:	e8 98 11 02 00       	call   f0122518 <strcmp>
f0101380:	83 c4 10             	add    $0x10,%esp
f0101383:	85 c0                	test   %eax,%eax
f0101385:	74 21                	je     f01013a8 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f0101387:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f010138d:	83 ec 08             	sub    $0x8,%esp
f0101390:	68 0d 4c 12 f0       	push   $0xf0124c0d
f0101395:	50                   	push   %eax
f0101396:	e8 7d 11 02 00       	call   f0122518 <strcmp>
f010139b:	83 c4 10             	add    $0x10,%esp
f010139e:	85 c0                	test   %eax,%eax
f01013a0:	74 06                	je     f01013a8 <command_prompt_readline+0x250>
						continue;
f01013a2:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013a3:	e9 d6 08 00 00       	jmp    f0101c7e <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013a8:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ae:	83 ec 08             	sub    $0x8,%esp
f01013b1:	68 0d 4c 12 f0       	push   $0xf0124c0d
f01013b6:	50                   	push   %eax
f01013b7:	e8 5c 11 02 00       	call   f0122518 <strcmp>
f01013bc:	83 c4 10             	add    $0x10,%esp
f01013bf:	85 c0                	test   %eax,%eax
f01013c1:	75 09                	jne    f01013cc <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013c3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013ca:	eb 07                	jmp    f01013d3 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013cc:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013d3:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013da:	00 00 00 
f01013dd:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01013e3:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01013e8:	b8 00 00 00 00       	mov    $0x0,%eax
f01013ed:	89 d7                	mov    %edx,%edi
f01013ef:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f01013f1:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01013f7:	48                   	dec    %eax
f01013f8:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f01013ff:	83 ec 0c             	sub    $0xc,%esp
f0101402:	50                   	push   %eax
f0101403:	e8 04 10 02 00       	call   f012240c <strlen>
f0101408:	83 c4 10             	add    $0x10,%esp
f010140b:	8b 55 90             	mov    -0x70(%ebp),%edx
f010140e:	29 c2                	sub    %eax,%edx
f0101410:	89 d0                	mov    %edx,%eax
f0101412:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101415:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010141c:	eb 1d                	jmp    f010143b <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010141e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101421:	8d 50 01             	lea    0x1(%eax),%edx
f0101424:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101427:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f010142a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010142d:	01 ca                	add    %ecx,%edx
f010142f:	8a 12                	mov    (%edx),%dl
f0101431:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101438:	ff 45 d8             	incl   -0x28(%ebp)
f010143b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010143e:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101441:	7c db                	jl     f010141e <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101443:	83 ec 08             	sub    $0x8,%esp
f0101446:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010144c:	50                   	push   %eax
f010144d:	ff 75 0c             	pushl  0xc(%ebp)
f0101450:	e8 06 10 02 00       	call   f012245b <strcpy>
f0101455:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101458:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010145e:	48                   	dec    %eax
f010145f:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101466:	83 ec 08             	sub    $0x8,%esp
f0101469:	50                   	push   %eax
f010146a:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101470:	50                   	push   %eax
f0101471:	e8 e5 0f 02 00       	call   f012245b <strcpy>
f0101476:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101479:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f0101480:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101486:	83 f8 01             	cmp    $0x1,%eax
f0101489:	0f 85 30 01 00 00    	jne    f01015bf <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f010148f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0101496:	e9 0f 01 00 00       	jmp    f01015aa <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f010149b:	83 ec 0c             	sub    $0xc,%esp
f010149e:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014a4:	50                   	push   %eax
f01014a5:	e8 62 0f 02 00       	call   f012240c <strlen>
f01014aa:	83 c4 10             	add    $0x10,%esp
f01014ad:	89 c1                	mov    %eax,%ecx
f01014af:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014b2:	89 d0                	mov    %edx,%eax
f01014b4:	01 c0                	add    %eax,%eax
f01014b6:	01 d0                	add    %edx,%eax
f01014b8:	c1 e0 03             	shl    $0x3,%eax
f01014bb:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01014c0:	8b 00                	mov    (%eax),%eax
f01014c2:	83 ec 04             	sub    $0x4,%esp
f01014c5:	51                   	push   %ecx
f01014c6:	50                   	push   %eax
f01014c7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014cd:	50                   	push   %eax
f01014ce:	e8 7d 10 02 00       	call   f0122550 <strncmp>
f01014d3:	83 c4 10             	add    $0x10,%esp
f01014d6:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014d9:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014dd:	0f 85 c4 00 00 00    	jne    f01015a7 <command_prompt_readline+0x44f>
							it_str = -1;
f01014e3:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f01014ea:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01014f1:	00 00 00 
f01014f4:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01014fa:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01014ff:	b8 00 00 00 00       	mov    $0x0,%eax
f0101504:	89 d7                	mov    %edx,%edi
f0101506:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101508:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010150f:	eb 2d                	jmp    f010153e <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101511:	ff 45 dc             	incl   -0x24(%ebp)
f0101514:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101517:	89 d0                	mov    %edx,%eax
f0101519:	01 c0                	add    %eax,%eax
f010151b:	01 d0                	add    %edx,%eax
f010151d:	c1 e0 03             	shl    $0x3,%eax
f0101520:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0101525:	8b 10                	mov    (%eax),%edx
f0101527:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010152a:	01 d0                	add    %edx,%eax
f010152c:	8a 00                	mov    (%eax),%al
f010152e:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101534:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101537:	01 ca                	add    %ecx,%edx
f0101539:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010153b:	ff 45 cc             	incl   -0x34(%ebp)
f010153e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101541:	89 d0                	mov    %edx,%eax
f0101543:	01 c0                	add    %eax,%eax
f0101545:	01 d0                	add    %edx,%eax
f0101547:	c1 e0 03             	shl    $0x3,%eax
f010154a:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010154f:	8b 00                	mov    (%eax),%eax
f0101551:	83 ec 0c             	sub    $0xc,%esp
f0101554:	50                   	push   %eax
f0101555:	e8 b2 0e 02 00       	call   f012240c <strlen>
f010155a:	83 c4 10             	add    $0x10,%esp
f010155d:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0101560:	7f af                	jg     f0101511 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101562:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101565:	c1 e0 0a             	shl    $0xa,%eax
f0101568:	05 40 4c 5a f0       	add    $0xf05a4c40,%eax
f010156d:	83 ec 04             	sub    $0x4,%esp
f0101570:	68 00 04 00 00       	push   $0x400
f0101575:	6a 00                	push   $0x0
f0101577:	50                   	push   %eax
f0101578:	e8 7d 10 02 00       	call   f01225fa <memset>
f010157d:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101580:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101583:	40                   	inc    %eax
f0101584:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0101587:	c1 e2 0a             	shl    $0xa,%edx
f010158a:	81 c2 40 4c 5a f0    	add    $0xf05a4c40,%edx
f0101590:	83 ec 04             	sub    $0x4,%esp
f0101593:	50                   	push   %eax
f0101594:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010159a:	50                   	push   %eax
f010159b:	52                   	push   %edx
f010159c:	e8 e8 0e 02 00       	call   f0122489 <strncpy>
f01015a1:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015a4:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015a7:	ff 45 d0             	incl   -0x30(%ebp)
f01015aa:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015ad:	a1 48 09 18 f0       	mov    0xf0180948,%eax
f01015b2:	39 c2                	cmp    %eax,%edx
f01015b4:	0f 82 e1 fe ff ff    	jb     f010149b <command_prompt_readline+0x343>
f01015ba:	e9 fe 02 00 00       	jmp    f01018bd <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015bf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015c3:	0f 84 7b 01 00 00    	je     f0101744 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015c9:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015d0:	e9 5c 01 00 00       	jmp    f0101731 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015d5:	83 ec 0c             	sub    $0xc,%esp
f01015d8:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015de:	50                   	push   %eax
f01015df:	e8 28 0e 02 00       	call   f012240c <strlen>
f01015e4:	83 c4 10             	add    $0x10,%esp
f01015e7:	89 c1                	mov    %eax,%ecx
f01015e9:	8b 1d e0 0c 18 f0    	mov    0xf0180ce0,%ebx
f01015ef:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01015f2:	89 d0                	mov    %edx,%eax
f01015f4:	01 c0                	add    %eax,%eax
f01015f6:	01 d0                	add    %edx,%eax
f01015f8:	c1 e0 02             	shl    $0x2,%eax
f01015fb:	01 d8                	add    %ebx,%eax
f01015fd:	8b 00                	mov    (%eax),%eax
f01015ff:	83 ec 04             	sub    $0x4,%esp
f0101602:	51                   	push   %ecx
f0101603:	50                   	push   %eax
f0101604:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010160a:	50                   	push   %eax
f010160b:	e8 40 0f 02 00       	call   f0122550 <strncmp>
f0101610:	83 c4 10             	add    $0x10,%esp
f0101613:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101616:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f010161a:	0f 85 0e 01 00 00    	jne    f010172e <command_prompt_readline+0x5d6>
								it_str = -1;
f0101620:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101627:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010162e:	00 00 00 
f0101631:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101637:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010163c:	b8 00 00 00 00       	mov    $0x0,%eax
f0101641:	89 d7                	mov    %edx,%edi
f0101643:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101645:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010164b:	83 f8 01             	cmp    $0x1,%eax
f010164e:	7e 39                	jle    f0101689 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101650:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101657:	eb 1d                	jmp    f0101676 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101659:	ff 45 dc             	incl   -0x24(%ebp)
f010165c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010165f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101662:	01 d0                	add    %edx,%eax
f0101664:	8a 00                	mov    (%eax),%al
f0101666:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010166c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010166f:	01 ca                	add    %ecx,%edx
f0101671:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101673:	ff 45 c4             	incl   -0x3c(%ebp)
f0101676:	83 ec 0c             	sub    $0xc,%esp
f0101679:	ff 75 0c             	pushl  0xc(%ebp)
f010167c:	e8 8b 0d 02 00       	call   f012240c <strlen>
f0101681:	83 c4 10             	add    $0x10,%esp
f0101684:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0101687:	7f d0                	jg     f0101659 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0101689:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f0101690:	eb 30                	jmp    f01016c2 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f0101692:	ff 45 dc             	incl   -0x24(%ebp)
f0101695:	8b 0d e0 0c 18 f0    	mov    0xf0180ce0,%ecx
f010169b:	8b 55 c8             	mov    -0x38(%ebp),%edx
f010169e:	89 d0                	mov    %edx,%eax
f01016a0:	01 c0                	add    %eax,%eax
f01016a2:	01 d0                	add    %edx,%eax
f01016a4:	c1 e0 02             	shl    $0x2,%eax
f01016a7:	01 c8                	add    %ecx,%eax
f01016a9:	8b 10                	mov    (%eax),%edx
f01016ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016ae:	01 d0                	add    %edx,%eax
f01016b0:	8a 00                	mov    (%eax),%al
f01016b2:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016b8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016bb:	01 ca                	add    %ecx,%edx
f01016bd:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016bf:	ff 45 c0             	incl   -0x40(%ebp)
f01016c2:	8b 0d e0 0c 18 f0    	mov    0xf0180ce0,%ecx
f01016c8:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016cb:	89 d0                	mov    %edx,%eax
f01016cd:	01 c0                	add    %eax,%eax
f01016cf:	01 d0                	add    %edx,%eax
f01016d1:	c1 e0 02             	shl    $0x2,%eax
f01016d4:	01 c8                	add    %ecx,%eax
f01016d6:	8b 00                	mov    (%eax),%eax
f01016d8:	83 ec 0c             	sub    $0xc,%esp
f01016db:	50                   	push   %eax
f01016dc:	e8 2b 0d 02 00       	call   f012240c <strlen>
f01016e1:	83 c4 10             	add    $0x10,%esp
f01016e4:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f01016e7:	7f a9                	jg     f0101692 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f01016e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01016ec:	c1 e0 0a             	shl    $0xa,%eax
f01016ef:	05 40 4c 5a f0       	add    $0xf05a4c40,%eax
f01016f4:	83 ec 04             	sub    $0x4,%esp
f01016f7:	68 00 04 00 00       	push   $0x400
f01016fc:	6a 00                	push   $0x0
f01016fe:	50                   	push   %eax
f01016ff:	e8 f6 0e 02 00       	call   f01225fa <memset>
f0101704:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101707:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010170a:	40                   	inc    %eax
f010170b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010170e:	c1 e2 0a             	shl    $0xa,%edx
f0101711:	81 c2 40 4c 5a f0    	add    $0xf05a4c40,%edx
f0101717:	83 ec 04             	sub    $0x4,%esp
f010171a:	50                   	push   %eax
f010171b:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101721:	50                   	push   %eax
f0101722:	52                   	push   %edx
f0101723:	e8 61 0d 02 00       	call   f0122489 <strncpy>
f0101728:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010172b:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010172e:	ff 45 c8             	incl   -0x38(%ebp)
f0101731:	a1 e4 0c 18 f0       	mov    0xf0180ce4,%eax
f0101736:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101739:	0f 8c 96 fe ff ff    	jl     f01015d5 <command_prompt_readline+0x47d>
f010173f:	e9 79 01 00 00       	jmp    f01018bd <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101744:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101748:	0f 84 6f 01 00 00    	je     f01018bd <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010174e:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101755:	e9 53 01 00 00       	jmp    f01018ad <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f010175a:	83 ec 0c             	sub    $0xc,%esp
f010175d:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101763:	50                   	push   %eax
f0101764:	e8 a3 0c 02 00       	call   f012240c <strlen>
f0101769:	83 c4 10             	add    $0x10,%esp
f010176c:	89 c1                	mov    %eax,%ecx
f010176e:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101771:	89 d0                	mov    %edx,%eax
f0101773:	01 c0                	add    %eax,%eax
f0101775:	01 d0                	add    %edx,%eax
f0101777:	c1 e0 02             	shl    $0x2,%eax
f010177a:	05 00 0d 18 f0       	add    $0xf0180d00,%eax
f010177f:	8b 00                	mov    (%eax),%eax
f0101781:	83 ec 04             	sub    $0x4,%esp
f0101784:	51                   	push   %ecx
f0101785:	50                   	push   %eax
f0101786:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010178c:	50                   	push   %eax
f010178d:	e8 be 0d 02 00       	call   f0122550 <strncmp>
f0101792:	83 c4 10             	add    $0x10,%esp
f0101795:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f0101798:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f010179c:	0f 85 08 01 00 00    	jne    f01018aa <command_prompt_readline+0x752>
								it_str = -1;
f01017a2:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017a9:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017b0:	00 00 00 
f01017b3:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017b9:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017be:	b8 00 00 00 00       	mov    $0x0,%eax
f01017c3:	89 d7                	mov    %edx,%edi
f01017c5:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017c7:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017cd:	83 f8 01             	cmp    $0x1,%eax
f01017d0:	7e 39                	jle    f010180b <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017d2:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017d9:	eb 1d                	jmp    f01017f8 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017db:	ff 45 dc             	incl   -0x24(%ebp)
f01017de:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01017e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01017e4:	01 d0                	add    %edx,%eax
f01017e6:	8a 00                	mov    (%eax),%al
f01017e8:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01017ee:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01017f1:	01 ca                	add    %ecx,%edx
f01017f3:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f5:	ff 45 b8             	incl   -0x48(%ebp)
f01017f8:	83 ec 0c             	sub    $0xc,%esp
f01017fb:	ff 75 0c             	pushl  0xc(%ebp)
f01017fe:	e8 09 0c 02 00       	call   f012240c <strlen>
f0101803:	83 c4 10             	add    $0x10,%esp
f0101806:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101809:	7f d0                	jg     f01017db <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010180b:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101812:	eb 2d                	jmp    f0101841 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101814:	ff 45 dc             	incl   -0x24(%ebp)
f0101817:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010181a:	89 d0                	mov    %edx,%eax
f010181c:	01 c0                	add    %eax,%eax
f010181e:	01 d0                	add    %edx,%eax
f0101820:	c1 e0 02             	shl    $0x2,%eax
f0101823:	05 00 0d 18 f0       	add    $0xf0180d00,%eax
f0101828:	8b 10                	mov    (%eax),%edx
f010182a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010182d:	01 d0                	add    %edx,%eax
f010182f:	8a 00                	mov    (%eax),%al
f0101831:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101837:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010183a:	01 ca                	add    %ecx,%edx
f010183c:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010183e:	ff 45 b4             	incl   -0x4c(%ebp)
f0101841:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101844:	89 d0                	mov    %edx,%eax
f0101846:	01 c0                	add    %eax,%eax
f0101848:	01 d0                	add    %edx,%eax
f010184a:	c1 e0 02             	shl    $0x2,%eax
f010184d:	05 00 0d 18 f0       	add    $0xf0180d00,%eax
f0101852:	8b 00                	mov    (%eax),%eax
f0101854:	83 ec 0c             	sub    $0xc,%esp
f0101857:	50                   	push   %eax
f0101858:	e8 af 0b 02 00       	call   f012240c <strlen>
f010185d:	83 c4 10             	add    $0x10,%esp
f0101860:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101863:	7f af                	jg     f0101814 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101865:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101868:	c1 e0 0a             	shl    $0xa,%eax
f010186b:	05 40 4c 5a f0       	add    $0xf05a4c40,%eax
f0101870:	83 ec 04             	sub    $0x4,%esp
f0101873:	68 00 04 00 00       	push   $0x400
f0101878:	6a 00                	push   $0x0
f010187a:	50                   	push   %eax
f010187b:	e8 7a 0d 02 00       	call   f01225fa <memset>
f0101880:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101883:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101886:	40                   	inc    %eax
f0101887:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010188a:	c1 e2 0a             	shl    $0xa,%edx
f010188d:	81 c2 40 4c 5a f0    	add    $0xf05a4c40,%edx
f0101893:	83 ec 04             	sub    $0x4,%esp
f0101896:	50                   	push   %eax
f0101897:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010189d:	50                   	push   %eax
f010189e:	52                   	push   %edx
f010189f:	e8 e5 0b 02 00       	call   f0122489 <strncpy>
f01018a4:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018a7:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018aa:	ff 45 bc             	incl   -0x44(%ebp)
f01018ad:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018b0:	a1 b4 0d 18 f0       	mov    0xf0180db4,%eax
f01018b5:	39 c2                	cmp    %eax,%edx
f01018b7:	0f 82 9d fe ff ff    	jb     f010175a <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018c3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018c7:	0f 84 a6 03 00 00    	je     f0101c73 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018cd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018da:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f01018e1:	eb 1f                	jmp    f0101902 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f01018e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018e6:	8d 50 01             	lea    0x1(%eax),%edx
f01018e9:	89 55 dc             	mov    %edx,-0x24(%ebp)
f01018ec:	89 c2                	mov    %eax,%edx
f01018ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f01018f1:	01 c2                	add    %eax,%edx
f01018f3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01018f6:	05 40 4c 5a f0       	add    $0xf05a4c40,%eax
f01018fb:	8a 00                	mov    (%eax),%al
f01018fd:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018ff:	ff 45 b0             	incl   -0x50(%ebp)
f0101902:	83 ec 0c             	sub    $0xc,%esp
f0101905:	68 40 4c 5a f0       	push   $0xf05a4c40
f010190a:	e8 fd 0a 02 00       	call   f012240c <strlen>
f010190f:	83 c4 10             	add    $0x10,%esp
f0101912:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101915:	7f cc                	jg     f01018e3 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101917:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010191e:	eb 10                	jmp    f0101930 <command_prompt_readline+0x7d8>
						cputchar('\b');}
f0101920:	83 ec 0c             	sub    $0xc,%esp
f0101923:	6a 08                	push   $0x8
f0101925:	e8 1f f5 ff ff       	call   f0100e49 <cputchar>
f010192a:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010192d:	ff 45 ac             	incl   -0x54(%ebp)
f0101930:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101933:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101936:	7c e8                	jl     f0101920 <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101938:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010193f:	eb 1c                	jmp    f010195d <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101941:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101944:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101947:	01 d0                	add    %edx,%eax
f0101949:	8a 00                	mov    (%eax),%al
f010194b:	0f be c0             	movsbl %al,%eax
f010194e:	83 ec 0c             	sub    $0xc,%esp
f0101951:	50                   	push   %eax
f0101952:	e8 f2 f4 ff ff       	call   f0100e49 <cputchar>
f0101957:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f010195a:	ff 45 a8             	incl   -0x58(%ebp)
f010195d:	83 ec 0c             	sub    $0xc,%esp
f0101960:	ff 75 0c             	pushl  0xc(%ebp)
f0101963:	e8 a4 0a 02 00       	call   f012240c <strlen>
f0101968:	83 c4 10             	add    $0x10,%esp
f010196b:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010196e:	7f d1                	jg     f0101941 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f0101970:	83 ec 0c             	sub    $0xc,%esp
f0101973:	ff 75 0c             	pushl  0xc(%ebp)
f0101976:	e8 91 0a 02 00       	call   f012240c <strlen>
f010197b:	83 c4 10             	add    $0x10,%esp
f010197e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101984:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010198a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101990:	e9 de 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f0101995:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0101999:	0f 8e d4 02 00 00    	jle    f0101c73 <command_prompt_readline+0xb1b>
f010199f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019a2:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ab:	40                   	inc    %eax
f01019ac:	99                   	cltd   
f01019ad:	f7 7d ec             	idivl  -0x14(%ebp)
f01019b0:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019b6:	c1 e0 0a             	shl    $0xa,%eax
f01019b9:	8d 98 40 4c 5a f0    	lea    -0xfa5b3c0(%eax),%ebx
f01019bf:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019c5:	c1 e0 0a             	shl    $0xa,%eax
f01019c8:	05 40 4c 5a f0       	add    $0xf05a4c40,%eax
f01019cd:	83 ec 0c             	sub    $0xc,%esp
f01019d0:	50                   	push   %eax
f01019d1:	e8 36 0a 02 00       	call   f012240c <strlen>
f01019d6:	83 c4 10             	add    $0x10,%esp
f01019d9:	83 ec 0c             	sub    $0xc,%esp
f01019dc:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f01019e2:	52                   	push   %edx
f01019e3:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f01019e9:	52                   	push   %edx
f01019ea:	ff 75 0c             	pushl  0xc(%ebp)
f01019ed:	53                   	push   %ebx
f01019ee:	50                   	push   %eax
f01019ef:	e8 75 f6 ff ff       	call   f0101069 <RoundAutoCompleteCommandWithTheSamePrefix>
f01019f4:	83 c4 20             	add    $0x20,%esp
f01019f7:	e9 77 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f01019fc:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a03:	75 2e                	jne    f0101a33 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a05:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a0b:	85 c0                	test   %eax,%eax
f0101a0d:	0f 8e 60 02 00 00    	jle    f0101c73 <command_prompt_readline+0xb1b>
				i--;
f0101a13:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a19:	48                   	dec    %eax
f0101a1a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a20:	83 ec 0c             	sub    $0xc,%esp
f0101a23:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a26:	e8 1e f4 ff ff       	call   f0100e49 <cputchar>
f0101a2b:	83 c4 10             	add    $0x10,%esp
f0101a2e:	e9 40 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a33:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a3a:	75 34                	jne    f0101a70 <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a3c:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a42:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a48:	39 c2                	cmp    %eax,%edx
f0101a4a:	0f 8d 23 02 00 00    	jge    f0101c73 <command_prompt_readline+0xb1b>
				i++;
f0101a50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a56:	40                   	inc    %eax
f0101a57:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a5d:	83 ec 0c             	sub    $0xc,%esp
f0101a60:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a63:	e8 e1 f3 ff ff       	call   f0100e49 <cputchar>
f0101a68:	83 c4 10             	add    $0x10,%esp
f0101a6b:	e9 03 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a70:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a77:	75 4c                	jne    f0101ac5 <command_prompt_readline+0x96d>
f0101a79:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a7f:	85 c0                	test   %eax,%eax
f0101a81:	7e 42                	jle    f0101ac5 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101a83:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a89:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101a8c:	eb 1a                	jmp    f0101aa8 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101a8e:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101a91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101a94:	01 c2                	add    %eax,%edx
f0101a96:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101a99:	8d 48 01             	lea    0x1(%eax),%ecx
f0101a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101a9f:	01 c8                	add    %ecx,%eax
f0101aa1:	8a 00                	mov    (%eax),%al
f0101aa3:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101aa5:	ff 45 a4             	incl   -0x5c(%ebp)
f0101aa8:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101aae:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ab1:	7e db                	jle    f0101a8e <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ab3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ab9:	48                   	dec    %eax
f0101aba:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101ac0:	e9 ae 01 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ac5:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ac9:	7e 60                	jle    f0101b2b <command_prompt_readline+0x9d3>
f0101acb:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ad1:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101ad6:	7f 53                	jg     f0101b2b <command_prompt_readline+0x9d3>
f0101ad8:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101adf:	74 4a                	je     f0101b2b <command_prompt_readline+0x9d3>
f0101ae1:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101ae8:	74 41                	je     f0101b2b <command_prompt_readline+0x9d3>
			if (echoing)
f0101aea:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101aee:	74 0e                	je     f0101afe <command_prompt_readline+0x9a6>
				cputchar(c);
f0101af0:	83 ec 0c             	sub    $0xc,%esp
f0101af3:	ff 75 94             	pushl  -0x6c(%ebp)
f0101af6:	e8 4e f3 ff ff       	call   f0100e49 <cputchar>
f0101afb:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101afe:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b04:	8d 50 01             	lea    0x1(%eax),%edx
f0101b07:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b0d:	89 c2                	mov    %eax,%edx
f0101b0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b12:	01 d0                	add    %edx,%eax
f0101b14:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b17:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b19:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b1f:	40                   	inc    %eax
f0101b20:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b26:	e9 48 01 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b2b:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b2f:	75 60                	jne    f0101b91 <command_prompt_readline+0xa39>
f0101b31:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b37:	85 c0                	test   %eax,%eax
f0101b39:	7e 56                	jle    f0101b91 <command_prompt_readline+0xa39>

			if (echoing)
f0101b3b:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b3f:	74 0e                	je     f0101b4f <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b41:	83 ec 0c             	sub    $0xc,%esp
f0101b44:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b47:	e8 fd f2 ff ff       	call   f0100e49 <cputchar>
f0101b4c:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b4f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b55:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b58:	eb 1a                	jmp    f0101b74 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b5a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b5d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b60:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b63:	01 c2                	add    %eax,%edx
f0101b65:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b6b:	01 c8                	add    %ecx,%eax
f0101b6d:	8a 00                	mov    (%eax),%al
f0101b6f:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b71:	ff 45 a0             	incl   -0x60(%ebp)
f0101b74:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b7a:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b7d:	7e db                	jle    f0101b5a <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b7f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b85:	48                   	dec    %eax
f0101b86:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101b8c:	e9 e2 00 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101b91:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101b95:	74 0a                	je     f0101ba1 <command_prompt_readline+0xa49>
f0101b97:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101b9b:	0f 85 d2 00 00 00    	jne    f0101c73 <command_prompt_readline+0xb1b>

			if (echoing)
f0101ba1:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101ba5:	74 0e                	je     f0101bb5 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101ba7:	83 ec 0c             	sub    $0xc,%esp
f0101baa:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bad:	e8 97 f2 ff ff       	call   f0100e49 <cputchar>
f0101bb2:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bb5:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bbb:	89 c2                	mov    %eax,%edx
f0101bbd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bc0:	01 d0                	add    %edx,%eax
f0101bc2:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101bc5:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101bca:	83 f8 13             	cmp    $0x13,%eax
f0101bcd:	75 56                	jne    f0101c25 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bcf:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bd6:	eb 2d                	jmp    f0101c05 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bd8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bdb:	40                   	inc    %eax
f0101bdc:	c1 e0 0a             	shl    $0xa,%eax
f0101bdf:	8d 90 40 dc 5b f0    	lea    -0xfa423c0(%eax),%edx
f0101be5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101be8:	c1 e0 0a             	shl    $0xa,%eax
f0101beb:	05 40 dc 5b f0       	add    $0xf05bdc40,%eax
f0101bf0:	83 ec 04             	sub    $0x4,%esp
f0101bf3:	68 00 04 00 00       	push   $0x400
f0101bf8:	52                   	push   %edx
f0101bf9:	50                   	push   %eax
f0101bfa:	e8 2b 0a 02 00       	call   f012262a <memcpy>
f0101bff:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c02:	ff 45 9c             	incl   -0x64(%ebp)
f0101c05:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c09:	7e cd                	jle    f0101bd8 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c0b:	83 ec 04             	sub    $0x4,%esp
f0101c0e:	68 00 04 00 00       	push   $0x400
f0101c13:	ff 75 0c             	pushl  0xc(%ebp)
f0101c16:	68 40 28 5c f0       	push   $0xf05c2840
f0101c1b:	e8 0a 0a 02 00       	call   f012262a <memcpy>
f0101c20:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c23:	eb 68                	jmp    f0101c8d <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c25:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c2a:	c1 e0 0a             	shl    $0xa,%eax
f0101c2d:	05 40 dc 5b f0       	add    $0xf05bdc40,%eax
f0101c32:	83 ec 08             	sub    $0x8,%esp
f0101c35:	ff 75 0c             	pushl  0xc(%ebp)
f0101c38:	50                   	push   %eax
f0101c39:	e8 da 08 02 00       	call   f0122518 <strcmp>
f0101c3e:	83 c4 10             	add    $0x10,%esp
f0101c41:	85 c0                	test   %eax,%eax
f0101c43:	74 48                	je     f0101c8d <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c45:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c4a:	40                   	inc    %eax
f0101c4b:	a3 30 05 18 f0       	mov    %eax,0xf0180530
f0101c50:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c55:	c1 e0 0a             	shl    $0xa,%eax
f0101c58:	05 40 dc 5b f0       	add    $0xf05bdc40,%eax
f0101c5d:	83 ec 04             	sub    $0x4,%esp
f0101c60:	68 00 04 00 00       	push   $0x400
f0101c65:	ff 75 0c             	pushl  0xc(%ebp)
f0101c68:	50                   	push   %eax
f0101c69:	e8 bc 09 02 00       	call   f012262a <memcpy>
f0101c6e:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c71:	eb 1a                	jmp    f0101c8d <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c73:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c76:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c79:	e9 44 f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c7e:	90                   	nop
f0101c7f:	e9 3e f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101c84:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101c85:	e9 38 f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101c8a:	90                   	nop
f0101c8b:	eb 01                	jmp    f0101c8e <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c8d:	90                   	nop

		}
		last_c = c;
	}
}
f0101c8e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101c91:	5b                   	pop    %ebx
f0101c92:	5f                   	pop    %edi
f0101c93:	5d                   	pop    %ebp
f0101c94:	c3                   	ret    

f0101c95 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101c95:	55                   	push   %ebp
f0101c96:	89 e5                	mov    %esp,%ebp
f0101c98:	57                   	push   %edi
f0101c99:	56                   	push   %esi
f0101c9a:	53                   	push   %ebx
f0101c9b:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101ca1:	a1 7c 4b 5a f0       	mov    0xf05a4b7c,%eax
f0101ca6:	85 c0                	test   %eax,%eax
f0101ca8:	0f 84 85 00 00 00    	je     f0101d33 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101cae:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cb4:	bb 17 4c 12 f0       	mov    $0xf0124c17,%ebx
f0101cb9:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cbe:	89 c7                	mov    %eax,%edi
f0101cc0:	89 de                	mov    %ebx,%esi
f0101cc2:	89 d1                	mov    %edx,%ecx
f0101cc4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101cc6:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ccc:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cd1:	b0 00                	mov    $0x0,%al
f0101cd3:	89 d7                	mov    %edx,%edi
f0101cd5:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cd7:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cdd:	bb 17 50 12 f0       	mov    $0xf0125017,%ebx
f0101ce2:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101ce7:	89 c7                	mov    %eax,%edi
f0101ce9:	89 de                	mov    %ebx,%esi
f0101ceb:	89 d1                	mov    %edx,%ecx
f0101ced:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101cef:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101cf5:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cfa:	b0 00                	mov    $0x0,%al
f0101cfc:	89 d7                	mov    %edx,%edi
f0101cfe:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d00:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d06:	bb 17 54 12 f0       	mov    $0xf0125417,%ebx
f0101d0b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d10:	89 c7                	mov    %eax,%edi
f0101d12:	89 de                	mov    %ebx,%esi
f0101d14:	89 d1                	mov    %edx,%ecx
f0101d16:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d18:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d1e:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d23:	b0 00                	mov    $0x0,%al
f0101d25:	89 d7                	mov    %edx,%edi
f0101d27:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d29:	c7 05 7c 4b 5a f0 00 	movl   $0x0,0xf05a4b7c
f0101d30:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d33:	c7 05 0c 4b 5a f0 00 	movl   $0x0,0xf05a4b0c
f0101d3a:	00 00 00 
f0101d3d:	c7 05 10 4b 5a f0 00 	movl   $0x0,0xf05a4b10
f0101d44:	00 00 00 
f0101d47:	c7 05 18 4b 5a f0 00 	movl   $0x0,0xf05a4b18
f0101d4e:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d51:	83 ec 04             	sub    $0x4,%esp
f0101d54:	68 00 04 00 00       	push   $0x400
f0101d59:	6a 00                	push   $0x0
f0101d5b:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d61:	50                   	push   %eax
f0101d62:	e8 93 08 02 00       	call   f01225fa <memset>
f0101d67:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d6a:	83 ec 08             	sub    $0x8,%esp
f0101d6d:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d73:	50                   	push   %eax
f0101d74:	68 11 4c 12 f0       	push   $0xf0124c11
f0101d79:	e8 da f3 ff ff       	call   f0101158 <command_prompt_readline>
f0101d7e:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101d81:	83 ec 0c             	sub    $0xc,%esp
f0101d84:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d8a:	50                   	push   %eax
f0101d8b:	e8 4c 01 00 00       	call   f0101edc <execute_command>
f0101d90:	83 c4 10             	add    $0x10,%esp
f0101d93:	85 c0                	test   %eax,%eax
f0101d95:	78 02                	js     f0101d99 <run_command_prompt+0x104>
				break;
	}
f0101d97:	eb b8                	jmp    f0101d51 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101d99:	90                   	nop
	}
}
f0101d9a:	90                   	nop
f0101d9b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101d9e:	5b                   	pop    %ebx
f0101d9f:	5e                   	pop    %esi
f0101da0:	5f                   	pop    %edi
f0101da1:	5d                   	pop    %ebp
f0101da2:	c3                   	ret    

f0101da3 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101da3:	55                   	push   %ebp
f0101da4:	89 e5                	mov    %esp,%ebp
f0101da6:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101da9:	9c                   	pushf  
f0101daa:	58                   	pop    %eax
f0101dab:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dae:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101db1:	25 00 02 00 00       	and    $0x200,%eax
f0101db6:	85 c0                	test   %eax,%eax
f0101db8:	74 01                	je     f0101dbb <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dba:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dbb:	e8 1e 8c 00 00       	call   f010a9de <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101dc0:	e8 0d 53 00 00       	call   f01070d2 <mycpu>
f0101dc5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101dc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dcb:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101dd2:	00 00 00 
		c->intena = 0;
f0101dd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dd8:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101ddf:	00 00 00 
		c->scheduler = NULL;
f0101de2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101de5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101dec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101def:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101df6:	00 00 00 
		c->proc = NULL;
f0101df9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dfc:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e03:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e06:	89 e0                	mov    %esp,%eax
f0101e08:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e0b:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e0e:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e11:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e14:	8b 40 08             	mov    0x8(%eax),%eax
f0101e17:	05 00 80 00 00       	add    $0x8000,%eax
f0101e1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e22:	8b 40 08             	mov    0x8(%eax),%eax
f0101e25:	05 00 10 00 00       	add    $0x1000,%eax
f0101e2a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e30:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e36:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e38:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e3b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e3e:	73 44                	jae    f0101e84 <get_into_prompt+0xe1>
f0101e40:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e43:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e46:	72 3c                	jb     f0101e84 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e48:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e4b:	a3 20 4c 5a f0       	mov    %eax,0xf05a4c20
			m = cpuStackTop - cur_esp;
f0101e50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e53:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e56:	a3 40 2c 5c f0       	mov    %eax,0xf05c2c40
			while (--m >= 0)
f0101e5b:	eb 11                	jmp    f0101e6e <get_into_prompt+0xcb>
				*p++ = 0;
f0101e5d:	a1 20 4c 5a f0       	mov    0xf05a4c20,%eax
f0101e62:	8d 50 01             	lea    0x1(%eax),%edx
f0101e65:	89 15 20 4c 5a f0    	mov    %edx,0xf05a4c20
f0101e6b:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e6e:	a1 40 2c 5c f0       	mov    0xf05c2c40,%eax
f0101e73:	48                   	dec    %eax
f0101e74:	a3 40 2c 5c f0       	mov    %eax,0xf05c2c40
f0101e79:	a1 40 2c 5c f0       	mov    0xf05c2c40,%eax
f0101e7e:	85 c0                	test   %eax,%eax
f0101e80:	79 db                	jns    f0101e5d <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e82:	eb 3a                	jmp    f0101ebe <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101e84:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101e87:	a3 20 4c 5a f0       	mov    %eax,0xf05a4c20
			m = cpuStackTop - cpuStackBottom;
f0101e8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e8f:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101e92:	a3 40 2c 5c f0       	mov    %eax,0xf05c2c40
			while (--m >= 0)
f0101e97:	eb 11                	jmp    f0101eaa <get_into_prompt+0x107>
				*p++ = 0;
f0101e99:	a1 20 4c 5a f0       	mov    0xf05a4c20,%eax
f0101e9e:	8d 50 01             	lea    0x1(%eax),%edx
f0101ea1:	89 15 20 4c 5a f0    	mov    %edx,0xf05a4c20
f0101ea7:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101eaa:	a1 40 2c 5c f0       	mov    0xf05c2c40,%eax
f0101eaf:	48                   	dec    %eax
f0101eb0:	a3 40 2c 5c f0       	mov    %eax,0xf05c2c40
f0101eb5:	a1 40 2c 5c f0       	mov    0xf05c2c40,%eax
f0101eba:	85 c0                	test   %eax,%eax
f0101ebc:	79 db                	jns    f0101e99 <get_into_prompt+0xf6>
f0101ebe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ec5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ec8:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101eca:	83 ec 0c             	sub    $0xc,%esp
f0101ecd:	6a 00                	push   $0x0
f0101ecf:	e8 c1 fd ff ff       	call   f0101c95 <run_command_prompt>
f0101ed4:	83 c4 10             	add    $0x10,%esp
	}
f0101ed7:	e9 cd fe ff ff       	jmp    f0101da9 <get_into_prompt+0x6>

f0101edc <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101edc:	55                   	push   %ebp
f0101edd:	89 e5                	mov    %esp,%ebp
f0101edf:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101ee2:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101ee5:	50                   	push   %eax
f0101ee6:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101ee9:	50                   	push   %eax
f0101eea:	68 ff 4b 12 f0       	push   $0xf0124bff
f0101eef:	ff 75 08             	pushl  0x8(%ebp)
f0101ef2:	e8 2a 0b 02 00       	call   f0122a21 <strsplit>
f0101ef7:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101efa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101efd:	85 c0                	test   %eax,%eax
f0101eff:	75 0a                	jne    f0101f0b <execute_command+0x2f>
		return 0;
f0101f01:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f06:	e9 a4 02 00 00       	jmp    f01021af <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f0b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f0e:	83 ec 08             	sub    $0x8,%esp
f0101f11:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f14:	52                   	push   %edx
f0101f15:	50                   	push   %eax
f0101f16:	e8 96 02 00 00       	call   f01021b1 <process_command>
f0101f1b:	83 c4 10             	add    $0x10,%esp
f0101f1e:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f21:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f25:	75 19                	jne    f0101f40 <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f27:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f2a:	83 ec 08             	sub    $0x8,%esp
f0101f2d:	50                   	push   %eax
f0101f2e:	68 17 58 12 f0       	push   $0xf0125817
f0101f33:	e8 34 f0 ff ff       	call   f0100f6c <cprintf>
f0101f38:	83 c4 10             	add    $0x10,%esp
f0101f3b:	e9 6a 02 00 00       	jmp    f01021aa <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f40:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f44:	75 4f                	jne    f0101f95 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f46:	a1 18 4b 5a f0       	mov    0xf05a4b18,%eax
f0101f4b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f4e:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f52:	74 17                	je     f0101f6b <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f54:	83 ec 04             	sub    $0x4,%esp
f0101f57:	68 30 58 12 f0       	push   $0xf0125830
f0101f5c:	68 8b 01 00 00       	push   $0x18b
f0101f61:	68 81 58 12 f0       	push   $0xf0125881
f0101f66:	e8 af e3 ff ff       	call   f010031a <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f6b:	a1 0c 4b 5a f0       	mov    0xf05a4b0c,%eax
f0101f70:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f73:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f76:	8b 50 04             	mov    0x4(%eax),%edx
f0101f79:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f7c:	8b 00                	mov    (%eax),%eax
f0101f7e:	83 ec 04             	sub    $0x4,%esp
f0101f81:	52                   	push   %edx
f0101f82:	50                   	push   %eax
f0101f83:	68 9c 58 12 f0       	push   $0xf012589c
f0101f88:	e8 df ef ff ff       	call   f0100f6c <cprintf>
f0101f8d:	83 c4 10             	add    $0x10,%esp
f0101f90:	e9 15 02 00 00       	jmp    f01021aa <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101f95:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101f99:	0f 85 e6 01 00 00    	jne    f0102185 <execute_command+0x2a9>
	{
		int i = 1;
f0101f9f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fa6:	a1 18 4b 5a f0       	mov    0xf05a4b18,%eax
f0101fab:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fae:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fb2:	75 17                	jne    f0101fcb <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fb4:	83 ec 04             	sub    $0x4,%esp
f0101fb7:	68 cc 58 12 f0       	push   $0xf01258cc
f0101fbc:	68 96 01 00 00       	push   $0x196
f0101fc1:	68 81 58 12 f0       	push   $0xf0125881
f0101fc6:	e8 4f e3 ff ff       	call   f010031a <_panic>
		}
		struct Command * cmd = NULL;
f0101fcb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101fd2:	a1 0c 4b 5a f0       	mov    0xf05a4b0c,%eax
f0101fd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101fda:	eb 28                	jmp    f0102004 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101fdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101fdf:	8b 10                	mov    (%eax),%edx
f0101fe1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101fe4:	8d 48 01             	lea    0x1(%eax),%ecx
f0101fe7:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0101fea:	83 ec 04             	sub    $0x4,%esp
f0101fed:	52                   	push   %edx
f0101fee:	50                   	push   %eax
f0101fef:	68 f6 58 12 f0       	push   $0xf01258f6
f0101ff4:	e8 73 ef ff ff       	call   f0100f6c <cprintf>
f0101ff9:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f0101ffc:	a1 14 4b 5a f0       	mov    0xf05a4b14,%eax
f0102001:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102004:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102008:	74 08                	je     f0102012 <execute_command+0x136>
f010200a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010200d:	8b 40 10             	mov    0x10(%eax),%eax
f0102010:	eb 05                	jmp    f0102017 <execute_command+0x13b>
f0102012:	b8 00 00 00 00       	mov    $0x0,%eax
f0102017:	a3 14 4b 5a f0       	mov    %eax,0xf05a4b14
f010201c:	a1 14 4b 5a f0       	mov    0xf05a4b14,%eax
f0102021:	85 c0                	test   %eax,%eax
f0102023:	75 b7                	jne    f0101fdc <execute_command+0x100>
f0102025:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102029:	75 b1                	jne    f0101fdc <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010202b:	83 ec 08             	sub    $0x8,%esp
f010202e:	ff 75 dc             	pushl  -0x24(%ebp)
f0102031:	68 00 59 12 f0       	push   $0xf0125900
f0102036:	e8 31 ef ff ff       	call   f0100f6c <cprintf>
f010203b:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010203e:	e8 1d ee ff ff       	call   f0100e60 <getchar>
f0102043:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102046:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f010204a:	83 ec 0c             	sub    $0xc,%esp
f010204d:	50                   	push   %eax
f010204e:	e8 f6 ed ff ff       	call   f0100e49 <cputchar>
f0102053:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102056:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010205d:	eb 40                	jmp    f010209f <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010205f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102062:	89 d0                	mov    %edx,%eax
f0102064:	c1 e0 02             	shl    $0x2,%eax
f0102067:	01 d0                	add    %edx,%eax
f0102069:	01 c0                	add    %eax,%eax
f010206b:	89 c2                	mov    %eax,%edx
f010206d:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102071:	83 e8 30             	sub    $0x30,%eax
f0102074:	01 d0                	add    %edx,%eax
f0102076:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102079:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010207d:	7e 2c                	jle    f01020ab <execute_command+0x1cf>
f010207f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102082:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0102085:	7f 24                	jg     f01020ab <execute_command+0x1cf>
				break;

			Chose = getchar();
f0102087:	e8 d4 ed ff ff       	call   f0100e60 <getchar>
f010208c:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f010208f:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102093:	83 ec 0c             	sub    $0xc,%esp
f0102096:	50                   	push   %eax
f0102097:	e8 ad ed ff ff       	call   f0100e49 <cputchar>
f010209c:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f010209f:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020a3:	7e 06                	jle    f01020ab <execute_command+0x1cf>
f01020a5:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020a9:	7e b4                	jle    f010205f <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ab:	83 ec 0c             	sub    $0xc,%esp
f01020ae:	6a 0a                	push   $0xa
f01020b0:	e8 94 ed ff ff       	call   f0100e49 <cputchar>
f01020b5:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020b8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020bc:	0f 8e e8 00 00 00    	jle    f01021aa <execute_command+0x2ce>
f01020c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020c5:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020c8:	0f 8f dc 00 00 00    	jg     f01021aa <execute_command+0x2ce>
		{
			int c = 1;
f01020ce:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020d5:	a1 0c 4b 5a f0       	mov    0xf05a4b0c,%eax
f01020da:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020dd:	eb 75                	jmp    f0102154 <execute_command+0x278>
			{
				if (c++ == selection)
f01020df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01020e2:	8d 50 01             	lea    0x1(%eax),%edx
f01020e5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01020e8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01020eb:	75 5f                	jne    f010214c <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f01020ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01020f0:	8b 40 0c             	mov    0xc(%eax),%eax
f01020f3:	85 c0                	test   %eax,%eax
f01020f5:	75 31                	jne    f0102128 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f01020f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01020fa:	8b 00                	mov    (%eax),%eax
f01020fc:	83 ec 08             	sub    $0x8,%esp
f01020ff:	50                   	push   %eax
f0102100:	68 63 59 12 f0       	push   $0xf0125963
f0102105:	e8 62 ee ff ff       	call   f0100f6c <cprintf>
f010210a:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010210d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102110:	8b 40 08             	mov    0x8(%eax),%eax
f0102113:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102116:	83 ec 08             	sub    $0x8,%esp
f0102119:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010211c:	51                   	push   %ecx
f010211d:	52                   	push   %edx
f010211e:	ff d0                	call   *%eax
f0102120:	83 c4 10             	add    $0x10,%esp
f0102123:	e9 87 00 00 00       	jmp    f01021af <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102128:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212b:	8b 50 04             	mov    0x4(%eax),%edx
f010212e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102131:	8b 00                	mov    (%eax),%eax
f0102133:	83 ec 04             	sub    $0x4,%esp
f0102136:	52                   	push   %edx
f0102137:	50                   	push   %eax
f0102138:	68 6c 59 12 f0       	push   $0xf012596c
f010213d:	e8 2a ee ff ff       	call   f0100f6c <cprintf>
f0102142:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102145:	b8 00 00 00 00       	mov    $0x0,%eax
f010214a:	eb 63                	jmp    f01021af <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010214c:	a1 14 4b 5a f0       	mov    0xf05a4b14,%eax
f0102151:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102154:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102158:	74 08                	je     f0102162 <execute_command+0x286>
f010215a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010215d:	8b 40 10             	mov    0x10(%eax),%eax
f0102160:	eb 05                	jmp    f0102167 <execute_command+0x28b>
f0102162:	b8 00 00 00 00       	mov    $0x0,%eax
f0102167:	a3 14 4b 5a f0       	mov    %eax,0xf05a4b14
f010216c:	a1 14 4b 5a f0       	mov    0xf05a4b14,%eax
f0102171:	85 c0                	test   %eax,%eax
f0102173:	0f 85 66 ff ff ff    	jne    f01020df <execute_command+0x203>
f0102179:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010217d:	0f 85 5c ff ff ff    	jne    f01020df <execute_command+0x203>
f0102183:	eb 25                	jmp    f01021aa <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f0102185:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102188:	89 d0                	mov    %edx,%eax
f010218a:	01 c0                	add    %eax,%eax
f010218c:	01 d0                	add    %edx,%eax
f010218e:	c1 e0 03             	shl    $0x3,%eax
f0102191:	05 48 05 18 f0       	add    $0xf0180548,%eax
f0102196:	8b 00                	mov    (%eax),%eax
f0102198:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010219b:	83 ec 08             	sub    $0x8,%esp
f010219e:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021a1:	51                   	push   %ecx
f01021a2:	52                   	push   %edx
f01021a3:	ff d0                	call   *%eax
f01021a5:	83 c4 10             	add    $0x10,%esp
f01021a8:	eb 05                	jmp    f01021af <execute_command+0x2d3>
	}
	return 0;
f01021aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021af:	c9                   	leave  
f01021b0:	c3                   	ret    

f01021b1 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021b1:	55                   	push   %ebp
f01021b2:	89 e5                	mov    %esp,%ebp
f01021b4:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021be:	a1 0c 4b 5a f0       	mov    0xf05a4b0c,%eax
f01021c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021c6:	e9 90 00 00 00       	jmp    f010225b <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021cf:	75 17                	jne    f01021e8 <process_command+0x37>
f01021d1:	83 ec 04             	sub    $0x4,%esp
f01021d4:	68 74 59 12 f0       	push   $0xf0125974
f01021d9:	68 cd 01 00 00       	push   $0x1cd
f01021de:	68 81 58 12 f0       	push   $0xf0125881
f01021e3:	e8 32 e1 ff ff       	call   f010031a <_panic>
f01021e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01021eb:	8b 40 10             	mov    0x10(%eax),%eax
f01021ee:	85 c0                	test   %eax,%eax
f01021f0:	74 11                	je     f0102203 <process_command+0x52>
f01021f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01021f5:	8b 40 10             	mov    0x10(%eax),%eax
f01021f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01021fb:	8b 52 14             	mov    0x14(%edx),%edx
f01021fe:	89 50 14             	mov    %edx,0x14(%eax)
f0102201:	eb 0b                	jmp    f010220e <process_command+0x5d>
f0102203:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102206:	8b 40 14             	mov    0x14(%eax),%eax
f0102209:	a3 10 4b 5a f0       	mov    %eax,0xf05a4b10
f010220e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102211:	8b 40 14             	mov    0x14(%eax),%eax
f0102214:	85 c0                	test   %eax,%eax
f0102216:	74 11                	je     f0102229 <process_command+0x78>
f0102218:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010221b:	8b 40 14             	mov    0x14(%eax),%eax
f010221e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102221:	8b 52 10             	mov    0x10(%edx),%edx
f0102224:	89 50 10             	mov    %edx,0x10(%eax)
f0102227:	eb 0b                	jmp    f0102234 <process_command+0x83>
f0102229:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010222c:	8b 40 10             	mov    0x10(%eax),%eax
f010222f:	a3 0c 4b 5a f0       	mov    %eax,0xf05a4b0c
f0102234:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102237:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010223e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102241:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102248:	a1 18 4b 5a f0       	mov    0xf05a4b18,%eax
f010224d:	48                   	dec    %eax
f010224e:	a3 18 4b 5a f0       	mov    %eax,0xf05a4b18

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102253:	a1 14 4b 5a f0       	mov    0xf05a4b14,%eax
f0102258:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010225b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010225f:	74 08                	je     f0102269 <process_command+0xb8>
f0102261:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102264:	8b 40 10             	mov    0x10(%eax),%eax
f0102267:	eb 05                	jmp    f010226e <process_command+0xbd>
f0102269:	b8 00 00 00 00       	mov    $0x0,%eax
f010226e:	a3 14 4b 5a f0       	mov    %eax,0xf05a4b14
f0102273:	a1 14 4b 5a f0       	mov    0xf05a4b14,%eax
f0102278:	85 c0                	test   %eax,%eax
f010227a:	0f 85 4b ff ff ff    	jne    f01021cb <process_command+0x1a>
f0102280:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0102284:	0f 85 41 ff ff ff    	jne    f01021cb <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f010228a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f0102291:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0102298:	e9 17 02 00 00       	jmp    f01024b4 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f010229d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022a0:	89 d0                	mov    %edx,%eax
f01022a2:	01 c0                	add    %eax,%eax
f01022a4:	01 d0                	add    %edx,%eax
f01022a6:	c1 e0 03             	shl    $0x3,%eax
f01022a9:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01022ae:	8b 10                	mov    (%eax),%edx
f01022b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022b3:	8b 00                	mov    (%eax),%eax
f01022b5:	83 ec 08             	sub    $0x8,%esp
f01022b8:	52                   	push   %edx
f01022b9:	50                   	push   %eax
f01022ba:	e8 59 02 02 00       	call   f0122518 <strcmp>
f01022bf:	83 c4 10             	add    $0x10,%esp
f01022c2:	85 c0                	test   %eax,%eax
f01022c4:	0f 85 f3 00 00 00    	jne    f01023bd <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022ca:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022cd:	89 d0                	mov    %edx,%eax
f01022cf:	01 c0                	add    %eax,%eax
f01022d1:	01 d0                	add    %edx,%eax
f01022d3:	c1 e0 03             	shl    $0x3,%eax
f01022d6:	05 4c 05 18 f0       	add    $0xf018054c,%eax
f01022db:	8b 00                	mov    (%eax),%eax
f01022dd:	8b 55 08             	mov    0x8(%ebp),%edx
f01022e0:	4a                   	dec    %edx
f01022e1:	39 d0                	cmp    %edx,%eax
f01022e3:	0f 84 cc 00 00 00    	je     f01023b5 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c 05 18 f0       	add    $0xf018054c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	83 f8 ff             	cmp    $0xffffffff,%eax
f01022ff:	75 10                	jne    f0102311 <process_command+0x160>
f0102301:	8b 45 08             	mov    0x8(%ebp),%eax
f0102304:	48                   	dec    %eax
f0102305:	85 c0                	test   %eax,%eax
f0102307:	7e 08                	jle    f0102311 <process_command+0x160>
                {
                    return i;
f0102309:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010230c:	e9 c5 01 00 00       	jmp    f01024d6 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102311:	8b 15 0c 4b 5a f0    	mov    0xf05a4b0c,%edx
f0102317:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010231a:	89 c8                	mov    %ecx,%eax
f010231c:	01 c0                	add    %eax,%eax
f010231e:	01 c8                	add    %ecx,%eax
f0102320:	c1 e0 03             	shl    $0x3,%eax
f0102323:	05 50 05 18 f0       	add    $0xf0180550,%eax
f0102328:	89 10                	mov    %edx,(%eax)
f010232a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010232d:	89 d0                	mov    %edx,%eax
f010232f:	01 c0                	add    %eax,%eax
f0102331:	01 d0                	add    %edx,%eax
f0102333:	c1 e0 03             	shl    $0x3,%eax
f0102336:	05 50 05 18 f0       	add    $0xf0180550,%eax
f010233b:	8b 00                	mov    (%eax),%eax
f010233d:	85 c0                	test   %eax,%eax
f010233f:	74 1c                	je     f010235d <process_command+0x1ac>
f0102341:	8b 15 0c 4b 5a f0    	mov    0xf05a4b0c,%edx
f0102347:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010234a:	89 c8                	mov    %ecx,%eax
f010234c:	01 c0                	add    %eax,%eax
f010234e:	01 c8                	add    %ecx,%eax
f0102350:	c1 e0 03             	shl    $0x3,%eax
f0102353:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0102358:	89 42 14             	mov    %eax,0x14(%edx)
f010235b:	eb 16                	jmp    f0102373 <process_command+0x1c2>
f010235d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102360:	89 d0                	mov    %edx,%eax
f0102362:	01 c0                	add    %eax,%eax
f0102364:	01 d0                	add    %edx,%eax
f0102366:	c1 e0 03             	shl    $0x3,%eax
f0102369:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010236e:	a3 10 4b 5a f0       	mov    %eax,0xf05a4b10
f0102373:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102376:	89 d0                	mov    %edx,%eax
f0102378:	01 c0                	add    %eax,%eax
f010237a:	01 d0                	add    %edx,%eax
f010237c:	c1 e0 03             	shl    $0x3,%eax
f010237f:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0102384:	a3 0c 4b 5a f0       	mov    %eax,0xf05a4b0c
f0102389:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010238c:	89 d0                	mov    %edx,%eax
f010238e:	01 c0                	add    %eax,%eax
f0102390:	01 d0                	add    %edx,%eax
f0102392:	c1 e0 03             	shl    $0x3,%eax
f0102395:	05 54 05 18 f0       	add    $0xf0180554,%eax
f010239a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023a0:	a1 18 4b 5a f0       	mov    0xf05a4b18,%eax
f01023a5:	40                   	inc    %eax
f01023a6:	a3 18 4b 5a f0       	mov    %eax,0xf05a4b18
                return CMD_INV_NUM_ARGS;
f01023ab:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023b0:	e9 21 01 00 00       	jmp    f01024d6 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023b8:	e9 19 01 00 00       	jmp    f01024d6 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023c0:	8b 00                	mov    (%eax),%eax
f01023c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023c8:	89 d0                	mov    %edx,%eax
f01023ca:	01 c0                	add    %eax,%eax
f01023cc:	01 d0                	add    %edx,%eax
f01023ce:	c1 e0 03             	shl    $0x3,%eax
f01023d1:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01023d6:	8b 00                	mov    (%eax),%eax
f01023d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023db:	eb 14                	jmp    f01023f1 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023e0:	8a 10                	mov    (%eax),%dl
f01023e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01023e5:	8a 00                	mov    (%eax),%al
f01023e7:	38 c2                	cmp    %al,%dl
f01023e9:	75 03                	jne    f01023ee <process_command+0x23d>
                {
                    ptr1++;
f01023eb:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f01023ee:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023f4:	8a 00                	mov    (%eax),%al
f01023f6:	84 c0                	test   %al,%al
f01023f8:	74 09                	je     f0102403 <process_command+0x252>
f01023fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01023fd:	8a 00                	mov    (%eax),%al
f01023ff:	84 c0                	test   %al,%al
f0102401:	75 da                	jne    f01023dd <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102403:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102406:	8a 00                	mov    (%eax),%al
f0102408:	84 c0                	test   %al,%al
f010240a:	0f 85 a1 00 00 00    	jne    f01024b1 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102410:	8b 15 0c 4b 5a f0    	mov    0xf05a4b0c,%edx
f0102416:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102419:	89 c8                	mov    %ecx,%eax
f010241b:	01 c0                	add    %eax,%eax
f010241d:	01 c8                	add    %ecx,%eax
f010241f:	c1 e0 03             	shl    $0x3,%eax
f0102422:	05 50 05 18 f0       	add    $0xf0180550,%eax
f0102427:	89 10                	mov    %edx,(%eax)
f0102429:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010242c:	89 d0                	mov    %edx,%eax
f010242e:	01 c0                	add    %eax,%eax
f0102430:	01 d0                	add    %edx,%eax
f0102432:	c1 e0 03             	shl    $0x3,%eax
f0102435:	05 50 05 18 f0       	add    $0xf0180550,%eax
f010243a:	8b 00                	mov    (%eax),%eax
f010243c:	85 c0                	test   %eax,%eax
f010243e:	74 1c                	je     f010245c <process_command+0x2ab>
f0102440:	8b 15 0c 4b 5a f0    	mov    0xf05a4b0c,%edx
f0102446:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102449:	89 c8                	mov    %ecx,%eax
f010244b:	01 c0                	add    %eax,%eax
f010244d:	01 c8                	add    %ecx,%eax
f010244f:	c1 e0 03             	shl    $0x3,%eax
f0102452:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0102457:	89 42 14             	mov    %eax,0x14(%edx)
f010245a:	eb 16                	jmp    f0102472 <process_command+0x2c1>
f010245c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010245f:	89 d0                	mov    %edx,%eax
f0102461:	01 c0                	add    %eax,%eax
f0102463:	01 d0                	add    %edx,%eax
f0102465:	c1 e0 03             	shl    $0x3,%eax
f0102468:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010246d:	a3 10 4b 5a f0       	mov    %eax,0xf05a4b10
f0102472:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102475:	89 d0                	mov    %edx,%eax
f0102477:	01 c0                	add    %eax,%eax
f0102479:	01 d0                	add    %edx,%eax
f010247b:	c1 e0 03             	shl    $0x3,%eax
f010247e:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0102483:	a3 0c 4b 5a f0       	mov    %eax,0xf05a4b0c
f0102488:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010248b:	89 d0                	mov    %edx,%eax
f010248d:	01 c0                	add    %eax,%eax
f010248f:	01 d0                	add    %edx,%eax
f0102491:	c1 e0 03             	shl    $0x3,%eax
f0102494:	05 54 05 18 f0       	add    $0xf0180554,%eax
f0102499:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010249f:	a1 18 4b 5a f0       	mov    0xf05a4b18,%eax
f01024a4:	40                   	inc    %eax
f01024a5:	a3 18 4b 5a f0       	mov    %eax,0xf05a4b18
                x=1;
f01024aa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024b1:	ff 45 ec             	incl   -0x14(%ebp)
f01024b4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024b7:	a1 48 09 18 f0       	mov    0xf0180948,%eax
f01024bc:	39 c2                	cmp    %eax,%edx
f01024be:	0f 82 d9 fd ff ff    	jb     f010229d <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024c4:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024c8:	75 07                	jne    f01024d1 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024ca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024cf:	eb 05                	jmp    f01024d6 <process_command+0x325>
    }
    return CMD_INVALID;
f01024d1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024d6:	c9                   	leave  
f01024d7:	c3                   	ret    

f01024d8 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024d8:	55                   	push   %ebp
f01024d9:	89 e5                	mov    %esp,%ebp
f01024db:	c7 05 50 49 5a f0 00 	movl   $0x0,0xf05a4950
f01024e2:	00 00 00 
f01024e5:	90                   	nop
f01024e6:	5d                   	pop    %ebp
f01024e7:	c3                   	ret    

f01024e8 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f01024e8:	55                   	push   %ebp
f01024e9:	89 e5                	mov    %esp,%ebp
f01024eb:	c7 05 50 49 5a f0 01 	movl   $0x1,0xf05a4950
f01024f2:	00 00 00 
f01024f5:	90                   	nop
f01024f6:	5d                   	pop    %ebp
f01024f7:	c3                   	ret    

f01024f8 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f01024f8:	55                   	push   %ebp
f01024f9:	89 e5                	mov    %esp,%ebp
f01024fb:	c7 05 50 49 5a f0 02 	movl   $0x2,0xf05a4950
f0102502:	00 00 00 
f0102505:	90                   	nop
f0102506:	5d                   	pop    %ebp
f0102507:	c3                   	ret    

f0102508 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102508:	55                   	push   %ebp
f0102509:	89 e5                	mov    %esp,%ebp
f010250b:	c7 05 50 49 5a f0 03 	movl   $0x3,0xf05a4950
f0102512:	00 00 00 
f0102515:	90                   	nop
f0102516:	5d                   	pop    %ebp
f0102517:	c3                   	ret    

f0102518 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102518:	55                   	push   %ebp
f0102519:	89 e5                	mov    %esp,%ebp
f010251b:	c7 05 50 49 5a f0 04 	movl   $0x4,0xf05a4950
f0102522:	00 00 00 
f0102525:	90                   	nop
f0102526:	5d                   	pop    %ebp
f0102527:	c3                   	ret    

f0102528 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102528:	55                   	push   %ebp
f0102529:	89 e5                	mov    %esp,%ebp
f010252b:	a1 50 49 5a f0       	mov    0xf05a4950,%eax
f0102530:	85 c0                	test   %eax,%eax
f0102532:	75 04                	jne    f0102538 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102534:	b0 01                	mov    $0x1,%al
f0102536:	eb 02                	jmp    f010253a <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102538:	b0 00                	mov    $0x0,%al
f010253a:	5d                   	pop    %ebp
f010253b:	c3                   	ret    

f010253c <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010253c:	55                   	push   %ebp
f010253d:	89 e5                	mov    %esp,%ebp
f010253f:	a1 50 49 5a f0       	mov    0xf05a4950,%eax
f0102544:	83 f8 01             	cmp    $0x1,%eax
f0102547:	75 04                	jne    f010254d <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102549:	b0 01                	mov    $0x1,%al
f010254b:	eb 02                	jmp    f010254f <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010254d:	b0 00                	mov    $0x0,%al
f010254f:	5d                   	pop    %ebp
f0102550:	c3                   	ret    

f0102551 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102551:	55                   	push   %ebp
f0102552:	89 e5                	mov    %esp,%ebp
f0102554:	a1 50 49 5a f0       	mov    0xf05a4950,%eax
f0102559:	83 f8 02             	cmp    $0x2,%eax
f010255c:	75 04                	jne    f0102562 <isKHeapPlacementStrategyBESTFIT+0x11>
f010255e:	b0 01                	mov    $0x1,%al
f0102560:	eb 02                	jmp    f0102564 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102562:	b0 00                	mov    $0x0,%al
f0102564:	5d                   	pop    %ebp
f0102565:	c3                   	ret    

f0102566 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102566:	55                   	push   %ebp
f0102567:	89 e5                	mov    %esp,%ebp
f0102569:	a1 50 49 5a f0       	mov    0xf05a4950,%eax
f010256e:	83 f8 03             	cmp    $0x3,%eax
f0102571:	75 04                	jne    f0102577 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102573:	b0 01                	mov    $0x1,%al
f0102575:	eb 02                	jmp    f0102579 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102577:	b0 00                	mov    $0x0,%al
f0102579:	5d                   	pop    %ebp
f010257a:	c3                   	ret    

f010257b <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010257b:	55                   	push   %ebp
f010257c:	89 e5                	mov    %esp,%ebp
f010257e:	a1 50 49 5a f0       	mov    0xf05a4950,%eax
f0102583:	83 f8 04             	cmp    $0x4,%eax
f0102586:	75 04                	jne    f010258c <isKHeapPlacementStrategyWORSTFIT+0x11>
f0102588:	b0 01                	mov    $0x1,%al
f010258a:	eb 02                	jmp    f010258e <isKHeapPlacementStrategyWORSTFIT+0x13>
f010258c:	b0 00                	mov    $0x0,%al
f010258e:	5d                   	pop    %ebp
f010258f:	c3                   	ret    

f0102590 <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f0102590:	55                   	push   %ebp
f0102591:	89 e5                	mov    %esp,%ebp
f0102593:	c7 05 a4 48 5a f0 01 	movl   $0x1,0xf05a48a4
f010259a:	00 00 00 
f010259d:	90                   	nop
f010259e:	5d                   	pop    %ebp
f010259f:	c3                   	ret    

f01025a0 <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025a0:	55                   	push   %ebp
f01025a1:	89 e5                	mov    %esp,%ebp
f01025a3:	c7 05 a4 48 5a f0 02 	movl   $0x2,0xf05a48a4
f01025aa:	00 00 00 
f01025ad:	90                   	nop
f01025ae:	5d                   	pop    %ebp
f01025af:	c3                   	ret    

f01025b0 <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025b0:	55                   	push   %ebp
f01025b1:	89 e5                	mov    %esp,%ebp
f01025b3:	c7 05 a4 48 5a f0 03 	movl   $0x3,0xf05a48a4
f01025ba:	00 00 00 
f01025bd:	90                   	nop
f01025be:	5d                   	pop    %ebp
f01025bf:	c3                   	ret    

f01025c0 <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025c0:	55                   	push   %ebp
f01025c1:	89 e5                	mov    %esp,%ebp
f01025c3:	c7 05 a4 48 5a f0 04 	movl   $0x4,0xf05a48a4
f01025ca:	00 00 00 
f01025cd:	90                   	nop
f01025ce:	5d                   	pop    %ebp
f01025cf:	c3                   	ret    

f01025d0 <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025d0:	55                   	push   %ebp
f01025d1:	89 e5                	mov    %esp,%ebp
f01025d3:	a1 a4 48 5a f0       	mov    0xf05a48a4,%eax
f01025d8:	83 f8 01             	cmp    $0x1,%eax
f01025db:	75 04                	jne    f01025e1 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025dd:	b0 01                	mov    $0x1,%al
f01025df:	eb 02                	jmp    f01025e3 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f01025e1:	b0 00                	mov    $0x0,%al
f01025e3:	5d                   	pop    %ebp
f01025e4:	c3                   	ret    

f01025e5 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f01025e5:	55                   	push   %ebp
f01025e6:	89 e5                	mov    %esp,%ebp
f01025e8:	a1 a4 48 5a f0       	mov    0xf05a48a4,%eax
f01025ed:	83 f8 02             	cmp    $0x2,%eax
f01025f0:	75 04                	jne    f01025f6 <isUHeapPlacementStrategyBESTFIT+0x11>
f01025f2:	b0 01                	mov    $0x1,%al
f01025f4:	eb 02                	jmp    f01025f8 <isUHeapPlacementStrategyBESTFIT+0x13>
f01025f6:	b0 00                	mov    $0x0,%al
f01025f8:	5d                   	pop    %ebp
f01025f9:	c3                   	ret    

f01025fa <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f01025fa:	55                   	push   %ebp
f01025fb:	89 e5                	mov    %esp,%ebp
f01025fd:	a1 a4 48 5a f0       	mov    0xf05a48a4,%eax
f0102602:	83 f8 03             	cmp    $0x3,%eax
f0102605:	75 04                	jne    f010260b <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102607:	b0 01                	mov    $0x1,%al
f0102609:	eb 02                	jmp    f010260d <isUHeapPlacementStrategyNEXTFIT+0x13>
f010260b:	b0 00                	mov    $0x0,%al
f010260d:	5d                   	pop    %ebp
f010260e:	c3                   	ret    

f010260f <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010260f:	55                   	push   %ebp
f0102610:	89 e5                	mov    %esp,%ebp
f0102612:	a1 a4 48 5a f0       	mov    0xf05a48a4,%eax
f0102617:	83 f8 04             	cmp    $0x4,%eax
f010261a:	75 04                	jne    f0102620 <isUHeapPlacementStrategyWORSTFIT+0x11>
f010261c:	b0 01                	mov    $0x1,%al
f010261e:	eb 02                	jmp    f0102622 <isUHeapPlacementStrategyWORSTFIT+0x13>
f0102620:	b0 00                	mov    $0x0,%al
f0102622:	5d                   	pop    %ebp
f0102623:	c3                   	ret    

f0102624 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102624:	55                   	push   %ebp
f0102625:	89 e5                	mov    %esp,%ebp
f0102627:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f010262a:	8b 45 08             	mov    0x8(%ebp),%eax
f010262d:	c1 e8 0c             	shr    $0xc,%eax
f0102630:	89 c2                	mov    %eax,%edx
f0102632:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0102637:	39 c2                	cmp    %eax,%edx
f0102639:	72 14                	jb     f010264f <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010263b:	83 ec 04             	sub    $0x4,%esp
f010263e:	68 94 59 12 f0       	push   $0xf0125994
f0102643:	6a 55                	push   $0x55
f0102645:	68 bc 59 12 f0       	push   $0xf01259bc
f010264a:	e8 cb dc ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f010264f:	8b 15 c0 48 5a f0    	mov    0xf05a48c0,%edx
f0102655:	8b 45 08             	mov    0x8(%ebp),%eax
f0102658:	c1 e8 0c             	shr    $0xc,%eax
f010265b:	89 c1                	mov    %eax,%ecx
f010265d:	89 c8                	mov    %ecx,%eax
f010265f:	01 c0                	add    %eax,%eax
f0102661:	01 c8                	add    %ecx,%eax
f0102663:	c1 e0 03             	shl    $0x3,%eax
f0102666:	01 d0                	add    %edx,%eax
}
f0102668:	c9                   	leave  
f0102669:	c3                   	ret    

f010266a <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f010266a:	55                   	push   %ebp
f010266b:	89 e5                	mov    %esp,%ebp
f010266d:	53                   	push   %ebx
f010266e:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102671:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102678:	eb 3b                	jmp    f01026b5 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f010267a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010267d:	89 d0                	mov    %edx,%eax
f010267f:	01 c0                	add    %eax,%eax
f0102681:	01 d0                	add    %edx,%eax
f0102683:	c1 e0 03             	shl    $0x3,%eax
f0102686:	05 44 05 18 f0       	add    $0xf0180544,%eax
f010268b:	8b 10                	mov    (%eax),%edx
f010268d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102690:	89 c8                	mov    %ecx,%eax
f0102692:	01 c0                	add    %eax,%eax
f0102694:	01 c8                	add    %ecx,%eax
f0102696:	c1 e0 03             	shl    $0x3,%eax
f0102699:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010269e:	8b 00                	mov    (%eax),%eax
f01026a0:	83 ec 04             	sub    $0x4,%esp
f01026a3:	52                   	push   %edx
f01026a4:	50                   	push   %eax
f01026a5:	68 3f 62 12 f0       	push   $0xf012623f
f01026aa:	e8 bd e8 ff ff       	call   f0100f6c <cprintf>
f01026af:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026b2:	ff 45 f4             	incl   -0xc(%ebp)
f01026b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026b8:	a1 48 09 18 f0       	mov    0xf0180948,%eax
f01026bd:	39 c2                	cmp    %eax,%edx
f01026bf:	72 b9                	jb     f010267a <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026c1:	83 ec 0c             	sub    $0xc,%esp
f01026c4:	68 48 62 12 f0       	push   $0xf0126248
f01026c9:	e8 9e e8 ff ff       	call   f0100f6c <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026d8:	eb 42                	jmp    f010271c <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026da:	8b 0d e0 0c 18 f0    	mov    0xf0180ce0,%ecx
f01026e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026e3:	89 d0                	mov    %edx,%eax
f01026e5:	01 c0                	add    %eax,%eax
f01026e7:	01 d0                	add    %edx,%eax
f01026e9:	c1 e0 02             	shl    $0x2,%eax
f01026ec:	01 c8                	add    %ecx,%eax
f01026ee:	8b 50 04             	mov    0x4(%eax),%edx
f01026f1:	8b 1d e0 0c 18 f0    	mov    0xf0180ce0,%ebx
f01026f7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026fa:	89 c8                	mov    %ecx,%eax
f01026fc:	01 c0                	add    %eax,%eax
f01026fe:	01 c8                	add    %ecx,%eax
f0102700:	c1 e0 02             	shl    $0x2,%eax
f0102703:	01 d8                	add    %ebx,%eax
f0102705:	8b 00                	mov    (%eax),%eax
f0102707:	83 ec 04             	sub    $0x4,%esp
f010270a:	52                   	push   %edx
f010270b:	50                   	push   %eax
f010270c:	68 5d 62 12 f0       	push   $0xf012625d
f0102711:	e8 56 e8 ff ff       	call   f0100f6c <cprintf>
f0102716:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102719:	ff 45 f4             	incl   -0xc(%ebp)
f010271c:	a1 e4 0c 18 f0       	mov    0xf0180ce4,%eax
f0102721:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102724:	7c b4                	jl     f01026da <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102726:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010272b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010272e:	c9                   	leave  
f010272f:	c3                   	ret    

f0102730 <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f0102730:	55                   	push   %ebp
f0102731:	89 e5                	mov    %esp,%ebp
f0102733:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102736:	83 ec 0c             	sub    $0xc,%esp
f0102739:	68 79 62 12 f0       	push   $0xf0126279
f010273e:	e8 29 e8 ff ff       	call   f0100f6c <cprintf>
f0102743:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102746:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010274b:	83 ec 04             	sub    $0x4,%esp
f010274e:	50                   	push   %eax
f010274f:	68 0c 00 10 f0       	push   $0xf010000c
f0102754:	68 94 62 12 f0       	push   $0xf0126294
f0102759:	e8 0e e8 ff ff       	call   f0100f6c <cprintf>
f010275e:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102761:	b8 a1 47 12 00       	mov    $0x1247a1,%eax
f0102766:	83 ec 04             	sub    $0x4,%esp
f0102769:	50                   	push   %eax
f010276a:	68 a1 47 12 f0       	push   $0xf01247a1
f010276f:	68 d0 62 12 f0       	push   $0xf01262d0
f0102774:	e8 f3 e7 ff ff       	call   f0100f6c <cprintf>
f0102779:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010277c:	b8 50 11 5a 00       	mov    $0x5a1150,%eax
f0102781:	83 ec 04             	sub    $0x4,%esp
f0102784:	50                   	push   %eax
f0102785:	68 50 11 5a f0       	push   $0xf05a1150
f010278a:	68 0c 63 12 f0       	push   $0xf012630c
f010278f:	e8 d8 e7 ff ff       	call   f0100f6c <cprintf>
f0102794:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f0102797:	b8 30 74 5c 00       	mov    $0x5c7430,%eax
f010279c:	83 ec 04             	sub    $0x4,%esp
f010279f:	50                   	push   %eax
f01027a0:	68 30 74 5c f0       	push   $0xf05c7430
f01027a5:	68 54 63 12 f0       	push   $0xf0126354
f01027aa:	e8 bd e7 ff ff       	call   f0100f6c <cprintf>
f01027af:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027b2:	b8 30 74 5c f0       	mov    $0xf05c7430,%eax
f01027b7:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027bd:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027c2:	29 c2                	sub    %eax,%edx
f01027c4:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027c6:	85 c0                	test   %eax,%eax
f01027c8:	79 05                	jns    f01027cf <command_kernel_info+0x9f>
f01027ca:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027cf:	c1 f8 0a             	sar    $0xa,%eax
f01027d2:	83 ec 08             	sub    $0x8,%esp
f01027d5:	50                   	push   %eax
f01027d6:	68 90 63 12 f0       	push   $0xf0126390
f01027db:	e8 8c e7 ff ff       	call   f0100f6c <cprintf>
f01027e0:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f01027e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01027e8:	c9                   	leave  
f01027e9:	c3                   	ret    

f01027ea <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f01027ea:	55                   	push   %ebp
f01027eb:	89 e5                	mov    %esp,%ebp
f01027ed:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f01027f0:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01027f4:	75 37                	jne    f010282d <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f01027f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01027f9:	83 c0 04             	add    $0x4,%eax
f01027fc:	8b 00                	mov    (%eax),%eax
f01027fe:	83 ec 04             	sub    $0x4,%esp
f0102801:	6a 10                	push   $0x10
f0102803:	6a 00                	push   $0x0
f0102805:	50                   	push   %eax
f0102806:	e8 61 ff 01 00       	call   f012276c <strtol>
f010280b:	83 c4 10             	add    $0x10,%esp
f010280e:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102811:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102814:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102817:	8b 45 0c             	mov    0xc(%ebp),%eax
f010281a:	83 c0 08             	add    $0x8,%eax
f010281d:	8b 00                	mov    (%eax),%eax
f010281f:	8a 00                	mov    (%eax),%al
f0102821:	88 c2                	mov    %al,%dl
f0102823:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102826:	88 10                	mov    %dl,(%eax)
f0102828:	e9 b9 00 00 00       	jmp    f01028e6 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010282d:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102831:	0f 85 9f 00 00 00    	jne    f01028d6 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102837:	8b 45 0c             	mov    0xc(%ebp),%eax
f010283a:	83 c0 04             	add    $0x4,%eax
f010283d:	8b 00                	mov    (%eax),%eax
f010283f:	83 ec 04             	sub    $0x4,%esp
f0102842:	6a 0a                	push   $0xa
f0102844:	6a 00                	push   $0x0
f0102846:	50                   	push   %eax
f0102847:	e8 20 ff 01 00       	call   f012276c <strtol>
f010284c:	83 c4 10             	add    $0x10,%esp
f010284f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102852:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102859:	83 ec 04             	sub    $0x4,%esp
f010285c:	6a 00                	push   $0x0
f010285e:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102861:	50                   	push   %eax
f0102862:	ff 75 f4             	pushl  -0xc(%ebp)
f0102865:	e8 2b 7f 00 00       	call   f010a795 <envid2env>
f010286a:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010286d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102870:	83 c0 08             	add    $0x8,%eax
f0102873:	8b 00                	mov    (%eax),%eax
f0102875:	83 ec 04             	sub    $0x4,%esp
f0102878:	6a 10                	push   $0x10
f010287a:	6a 00                	push   $0x0
f010287c:	50                   	push   %eax
f010287d:	e8 ea fe 01 00       	call   f012276c <strtol>
f0102882:	83 c4 10             	add    $0x10,%esp
f0102885:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102888:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010288b:	85 c0                	test   %eax,%eax
f010288d:	75 07                	jne    f0102896 <command_writeusermem+0xac>
f010288f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102894:	eb 55                	jmp    f01028eb <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102896:	0f 20 d8             	mov    %cr3,%eax
f0102899:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f010289c:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f010289f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028a2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028a5:	8b 40 68             	mov    0x68(%eax),%eax
f01028a8:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028ae:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028b4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028ba:	83 c0 0c             	add    $0xc,%eax
f01028bd:	8b 00                	mov    (%eax),%eax
f01028bf:	8a 00                	mov    (%eax),%al
f01028c1:	88 c2                	mov    %al,%dl
f01028c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028c6:	88 10                	mov    %dl,(%eax)
f01028c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028cb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028d1:	0f 22 d8             	mov    %eax,%cr3
f01028d4:	eb 10                	jmp    f01028e6 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028d6:	83 ec 0c             	sub    $0xc,%esp
f01028d9:	68 bc 63 12 f0       	push   $0xf01263bc
f01028de:	e8 89 e6 ff ff       	call   f0100f6c <cprintf>
f01028e3:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01028e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01028eb:	c9                   	leave  
f01028ec:	c3                   	ret    

f01028ed <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f01028ed:	55                   	push   %ebp
f01028ee:	89 e5                	mov    %esp,%ebp
f01028f0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f01028f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028f6:	83 c0 04             	add    $0x4,%eax
f01028f9:	8b 00                	mov    (%eax),%eax
f01028fb:	83 ec 04             	sub    $0x4,%esp
f01028fe:	6a 10                	push   $0x10
f0102900:	6a 00                	push   $0x0
f0102902:	50                   	push   %eax
f0102903:	e8 64 fe 01 00       	call   f012276c <strtol>
f0102908:	83 c4 10             	add    $0x10,%esp
f010290b:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102910:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102913:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f010291a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010291d:	83 c0 08             	add    $0x8,%eax
f0102920:	8b 00                	mov    (%eax),%eax
f0102922:	83 ec 0c             	sub    $0xc,%esp
f0102925:	50                   	push   %eax
f0102926:	e8 e1 fa 01 00       	call   f012240c <strlen>
f010292b:	83 c4 10             	add    $0x10,%esp
f010292e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102931:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102938:	eb 1c                	jmp    f0102956 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f010293a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293d:	83 c0 08             	add    $0x8,%eax
f0102940:	8b 10                	mov    (%eax),%edx
f0102942:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102945:	01 d0                	add    %edx,%eax
f0102947:	8a 00                	mov    (%eax),%al
f0102949:	88 c2                	mov    %al,%dl
f010294b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010294e:	88 10                	mov    %dl,(%eax)
		address++;
f0102950:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102953:	ff 45 f0             	incl   -0x10(%ebp)
f0102956:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102959:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010295c:	7c dc                	jl     f010293a <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010295e:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102963:	c9                   	leave  
f0102964:	c3                   	ret    

f0102965 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102965:	55                   	push   %ebp
f0102966:	89 e5                	mov    %esp,%ebp
f0102968:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010296b:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010296f:	75 42                	jne    f01029b3 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102971:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102974:	83 c0 04             	add    $0x4,%eax
f0102977:	8b 00                	mov    (%eax),%eax
f0102979:	83 ec 04             	sub    $0x4,%esp
f010297c:	6a 10                	push   $0x10
f010297e:	6a 00                	push   $0x0
f0102980:	50                   	push   %eax
f0102981:	e8 e6 fd 01 00       	call   f012276c <strtol>
f0102986:	83 c4 10             	add    $0x10,%esp
f0102989:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f010298c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010298f:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f0102992:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102995:	8a 00                	mov    (%eax),%al
f0102997:	0f b6 c0             	movzbl %al,%eax
f010299a:	83 ec 04             	sub    $0x4,%esp
f010299d:	50                   	push   %eax
f010299e:	ff 75 d8             	pushl  -0x28(%ebp)
f01029a1:	68 e6 63 12 f0       	push   $0xf01263e6
f01029a6:	e8 c1 e5 ff ff       	call   f0100f6c <cprintf>
f01029ab:	83 c4 10             	add    $0x10,%esp
f01029ae:	e9 c4 00 00 00       	jmp    f0102a77 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029b3:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029b7:	0f 85 aa 00 00 00    	jne    f0102a67 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029c0:	83 c0 04             	add    $0x4,%eax
f01029c3:	8b 00                	mov    (%eax),%eax
f01029c5:	83 ec 04             	sub    $0x4,%esp
f01029c8:	6a 0a                	push   $0xa
f01029ca:	6a 00                	push   $0x0
f01029cc:	50                   	push   %eax
f01029cd:	e8 9a fd 01 00       	call   f012276c <strtol>
f01029d2:	83 c4 10             	add    $0x10,%esp
f01029d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029d8:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029df:	83 ec 04             	sub    $0x4,%esp
f01029e2:	6a 00                	push   $0x0
f01029e4:	8d 45 d0             	lea    -0x30(%ebp),%eax
f01029e7:	50                   	push   %eax
f01029e8:	ff 75 f4             	pushl  -0xc(%ebp)
f01029eb:	e8 a5 7d 00 00       	call   f010a795 <envid2env>
f01029f0:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f01029f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029f6:	83 c0 08             	add    $0x8,%eax
f01029f9:	8b 00                	mov    (%eax),%eax
f01029fb:	83 ec 04             	sub    $0x4,%esp
f01029fe:	6a 10                	push   $0x10
f0102a00:	6a 00                	push   $0x0
f0102a02:	50                   	push   %eax
f0102a03:	e8 64 fd 01 00       	call   f012276c <strtol>
f0102a08:	83 c4 10             	add    $0x10,%esp
f0102a0b:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a0e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a11:	85 c0                	test   %eax,%eax
f0102a13:	75 07                	jne    f0102a1c <command_readusermem+0xb7>
f0102a15:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a1a:	eb 60                	jmp    f0102a7c <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a1c:	0f 20 d8             	mov    %cr3,%eax
f0102a1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a22:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a25:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a28:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a2b:	8b 40 68             	mov    0x68(%eax),%eax
f0102a2e:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a31:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a34:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a37:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a40:	8a 00                	mov    (%eax),%al
f0102a42:	0f b6 c0             	movzbl %al,%eax
f0102a45:	83 ec 04             	sub    $0x4,%esp
f0102a48:	50                   	push   %eax
f0102a49:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a4c:	68 e6 63 12 f0       	push   $0xf01263e6
f0102a51:	e8 16 e5 ff ff       	call   f0100f6c <cprintf>
f0102a56:	83 c4 10             	add    $0x10,%esp
f0102a59:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a5c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a5f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a62:	0f 22 d8             	mov    %eax,%cr3
f0102a65:	eb 10                	jmp    f0102a77 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a67:	83 ec 0c             	sub    $0xc,%esp
f0102a6a:	68 00 64 12 f0       	push   $0xf0126400
f0102a6f:	e8 f8 e4 ff ff       	call   f0100f6c <cprintf>
f0102a74:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a77:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a7c:	c9                   	leave  
f0102a7d:	c3                   	ret    

f0102a7e <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a7e:	55                   	push   %ebp
f0102a7f:	89 e5                	mov    %esp,%ebp
f0102a81:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102a84:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a87:	83 c0 04             	add    $0x4,%eax
f0102a8a:	8b 00                	mov    (%eax),%eax
f0102a8c:	83 ec 04             	sub    $0x4,%esp
f0102a8f:	6a 10                	push   $0x10
f0102a91:	6a 00                	push   $0x0
f0102a93:	50                   	push   %eax
f0102a94:	e8 d3 fc 01 00       	call   f012276c <strtol>
f0102a99:	83 c4 10             	add    $0x10,%esp
f0102a9c:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102aa1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102aa4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102aae:	8a 00                	mov    (%eax),%al
f0102ab0:	0f b6 c0             	movzbl %al,%eax
f0102ab3:	83 ec 08             	sub    $0x8,%esp
f0102ab6:	50                   	push   %eax
f0102ab7:	68 2a 64 12 f0       	push   $0xf012642a
f0102abc:	e8 ab e4 ff ff       	call   f0100f6c <cprintf>
f0102ac1:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ac4:	83 ec 0c             	sub    $0xc,%esp
f0102ac7:	68 2d 64 12 f0       	push   $0xf012642d
f0102acc:	e8 9b e4 ff ff       	call   f0100f6c <cprintf>
f0102ad1:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102ad4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ad9:	c9                   	leave  
f0102ada:	c3                   	ret    

f0102adb <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102adb:	55                   	push   %ebp
f0102adc:	89 e5                	mov    %esp,%ebp
f0102ade:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102ae1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ae4:	83 c0 04             	add    $0x4,%eax
f0102ae7:	8b 00                	mov    (%eax),%eax
f0102ae9:	83 ec 04             	sub    $0x4,%esp
f0102aec:	6a 0a                	push   $0xa
f0102aee:	6a 00                	push   $0x0
f0102af0:	50                   	push   %eax
f0102af1:	e8 76 fc 01 00       	call   f012276c <strtol>
f0102af6:	83 c4 10             	add    $0x10,%esp
f0102af9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102afc:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b03:	83 ec 04             	sub    $0x4,%esp
f0102b06:	6a 00                	push   $0x0
f0102b08:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b0b:	50                   	push   %eax
f0102b0c:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b0f:	e8 81 7c 00 00       	call   f010a795 <envid2env>
f0102b14:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b17:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b1a:	83 c0 08             	add    $0x8,%eax
f0102b1d:	8b 00                	mov    (%eax),%eax
f0102b1f:	83 ec 04             	sub    $0x4,%esp
f0102b22:	6a 10                	push   $0x10
f0102b24:	6a 00                	push   $0x0
f0102b26:	50                   	push   %eax
f0102b27:	e8 40 fc 01 00       	call   f012276c <strtol>
f0102b2c:	83 c4 10             	add    $0x10,%esp
f0102b2f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b32:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b35:	83 c0 0c             	add    $0xc,%eax
f0102b38:	8b 00                	mov    (%eax),%eax
f0102b3a:	83 ec 04             	sub    $0x4,%esp
f0102b3d:	6a 0a                	push   $0xa
f0102b3f:	6a 00                	push   $0x0
f0102b41:	50                   	push   %eax
f0102b42:	e8 25 fc 01 00       	call   f012276c <strtol>
f0102b47:	83 c4 10             	add    $0x10,%esp
f0102b4a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b50:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b53:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b56:	85 c0                	test   %eax,%eax
f0102b58:	75 07                	jne    f0102b61 <command_readuserblock+0x86>
f0102b5a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b5f:	eb 65                	jmp    f0102bc6 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b61:	0f 20 d8             	mov    %cr3,%eax
f0102b64:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b67:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b6a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b6d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b70:	8b 40 68             	mov    0x68(%eax),%eax
f0102b73:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b76:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b79:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b7c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102b83:	eb 28                	jmp    f0102bad <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102b85:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102b88:	8a 00                	mov    (%eax),%al
f0102b8a:	0f b6 d0             	movzbl %al,%edx
f0102b8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102b90:	8a 00                	mov    (%eax),%al
f0102b92:	0f b6 c0             	movzbl %al,%eax
f0102b95:	52                   	push   %edx
f0102b96:	50                   	push   %eax
f0102b97:	ff 75 f4             	pushl  -0xc(%ebp)
f0102b9a:	68 2f 64 12 f0       	push   $0xf012642f
f0102b9f:	e8 c8 e3 ff ff       	call   f0100f6c <cprintf>
f0102ba4:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102ba7:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102baa:	ff 45 f0             	incl   -0x10(%ebp)
f0102bad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bb0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bb3:	7c d0                	jl     f0102b85 <command_readuserblock+0xaa>
f0102bb5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bb8:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bbb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bbe:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102bc1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102bc6:	c9                   	leave  
f0102bc7:	c3                   	ret    

f0102bc8 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102bc8:	55                   	push   %ebp
f0102bc9:	89 e5                	mov    %esp,%ebp
f0102bcb:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bce:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bd1:	83 c0 04             	add    $0x4,%eax
f0102bd4:	8b 00                	mov    (%eax),%eax
f0102bd6:	83 ec 04             	sub    $0x4,%esp
f0102bd9:	6a 0a                	push   $0xa
f0102bdb:	6a 00                	push   $0x0
f0102bdd:	50                   	push   %eax
f0102bde:	e8 89 fb 01 00       	call   f012276c <strtol>
f0102be3:	83 c4 10             	add    $0x10,%esp
f0102be6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102be9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102bf0:	83 ec 04             	sub    $0x4,%esp
f0102bf3:	6a 00                	push   $0x0
f0102bf5:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102bf8:	50                   	push   %eax
f0102bf9:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bfc:	e8 94 7b 00 00       	call   f010a795 <envid2env>
f0102c01:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c04:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c07:	85 c0                	test   %eax,%eax
f0102c09:	75 0a                	jne    f0102c15 <command_remove_table+0x4d>
f0102c0b:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c10:	e9 a1 00 00 00       	jmp    f0102cb6 <command_remove_table+0xee>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c15:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c18:	83 c0 08             	add    $0x8,%eax
f0102c1b:	8b 00                	mov    (%eax),%eax
f0102c1d:	83 ec 04             	sub    $0x4,%esp
f0102c20:	6a 10                	push   $0x10
f0102c22:	6a 00                	push   $0x0
f0102c24:	50                   	push   %eax
f0102c25:	e8 42 fb 01 00       	call   f012276c <strtol>
f0102c2a:	83 c4 10             	add    $0x10,%esp
f0102c2d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c33:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c36:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c39:	8b 40 64             	mov    0x64(%eax),%eax
f0102c3c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c3f:	c1 ea 16             	shr    $0x16,%edx
f0102c42:	c1 e2 02             	shl    $0x2,%edx
f0102c45:	01 d0                	add    %edx,%eax
f0102c47:	8b 00                	mov    (%eax),%eax
f0102c49:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree((void*)kheap_virtual_address(table_pa));
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c51:	83 ec 0c             	sub    $0xc,%esp
f0102c54:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c57:	e8 c8 f9 ff ff       	call   f0102624 <to_frame_info>
f0102c5c:	83 c4 10             	add    $0x10,%esp
f0102c5f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102c62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102c65:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102c6b:	83 ec 0c             	sub    $0xc,%esp
f0102c6e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102c71:	e8 83 56 00 00       	call   f01082f9 <free_frame>
f0102c76:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102c79:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c7c:	c1 e8 16             	shr    $0x16,%eax
f0102c7f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102c82:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c85:	8b 40 64             	mov    0x64(%eax),%eax
f0102c88:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102c8b:	c1 e2 02             	shl    $0x2,%edx
f0102c8e:	01 c2                	add    %eax,%edx
f0102c90:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c93:	8b 40 64             	mov    0x64(%eax),%eax
f0102c96:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102c99:	c1 e1 02             	shl    $0x2,%ecx
f0102c9c:	01 c8                	add    %ecx,%eax
f0102c9e:	8b 00                	mov    (%eax),%eax
f0102ca0:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ca3:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102ca5:	0f 20 d8             	mov    %cr3,%eax
f0102ca8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cae:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cb1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cb6:	c9                   	leave  
f0102cb7:	c3                   	ret    

f0102cb8 <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cb8:	55                   	push   %ebp
f0102cb9:	89 e5                	mov    %esp,%ebp
f0102cbb:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102cbe:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102cc2:	7e 06                	jle    f0102cca <command_allocuserpage+0x12>
f0102cc4:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102cc8:	7e 1a                	jle    f0102ce4 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102cca:	83 ec 0c             	sub    $0xc,%esp
f0102ccd:	68 40 64 12 f0       	push   $0xf0126440
f0102cd2:	e8 95 e2 ff ff       	call   f0100f6c <cprintf>
f0102cd7:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102cda:	b8 00 00 00 00       	mov    $0x0,%eax
f0102cdf:	e9 46 01 00 00       	jmp    f0102e2a <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102ce4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ce7:	83 c0 04             	add    $0x4,%eax
f0102cea:	8b 00                	mov    (%eax),%eax
f0102cec:	83 ec 04             	sub    $0x4,%esp
f0102cef:	6a 0a                	push   $0xa
f0102cf1:	6a 00                	push   $0x0
f0102cf3:	50                   	push   %eax
f0102cf4:	e8 73 fa 01 00       	call   f012276c <strtol>
f0102cf9:	83 c4 10             	add    $0x10,%esp
f0102cfc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102cff:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d06:	83 ec 04             	sub    $0x4,%esp
f0102d09:	6a 00                	push   $0x0
f0102d0b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d0e:	50                   	push   %eax
f0102d0f:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d12:	e8 7e 7a 00 00       	call   f010a795 <envid2env>
f0102d17:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d1a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d1d:	85 c0                	test   %eax,%eax
f0102d1f:	75 0a                	jne    f0102d2b <command_allocuserpage+0x73>
f0102d21:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d26:	e9 ff 00 00 00       	jmp    f0102e2a <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d2b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2e:	83 c0 08             	add    $0x8,%eax
f0102d31:	8b 00                	mov    (%eax),%eax
f0102d33:	83 ec 04             	sub    $0x4,%esp
f0102d36:	6a 10                	push   $0x10
f0102d38:	6a 00                	push   $0x0
f0102d3a:	50                   	push   %eax
f0102d3b:	e8 2c fa 01 00       	call   f012276c <strtol>
f0102d40:	83 c4 10             	add    $0x10,%esp
f0102d43:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d46:	83 ec 0c             	sub    $0xc,%esp
f0102d49:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d4c:	50                   	push   %eax
f0102d4d:	e8 53 54 00 00       	call   f01081a5 <allocate_frame>
f0102d52:	83 c4 10             	add    $0x10,%esp
f0102d55:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d58:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102d5c:	75 1a                	jne    f0102d78 <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102d5e:	83 ec 0c             	sub    $0xc,%esp
f0102d61:	68 6a 64 12 f0       	push   $0xf012646a
f0102d66:	e8 01 e2 ff ff       	call   f0100f6c <cprintf>
f0102d6b:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d6e:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d73:	e9 b2 00 00 00       	jmp    f0102e2a <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102d78:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102d7c:	75 1d                	jne    f0102d9b <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102d7e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102d81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d84:	8b 40 64             	mov    0x64(%eax),%eax
f0102d87:	6a 06                	push   $0x6
f0102d89:	ff 75 ec             	pushl  -0x14(%ebp)
f0102d8c:	52                   	push   %edx
f0102d8d:	50                   	push   %eax
f0102d8e:	e8 28 58 00 00       	call   f01085bb <map_frame>
f0102d93:	83 c4 10             	add    $0x10,%esp
f0102d96:	e9 8a 00 00 00       	jmp    f0102e25 <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102d9b:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d9f:	0f 85 80 00 00 00    	jne    f0102e25 <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102da5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102da8:	83 c0 0c             	add    $0xc,%eax
f0102dab:	8b 00                	mov    (%eax),%eax
f0102dad:	8a 00                	mov    (%eax),%al
f0102daf:	3c 72                	cmp    $0x72,%al
f0102db1:	74 0e                	je     f0102dc1 <command_allocuserpage+0x109>
f0102db3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102db6:	83 c0 0c             	add    $0xc,%eax
f0102db9:	8b 00                	mov    (%eax),%eax
f0102dbb:	8a 00                	mov    (%eax),%al
f0102dbd:	3c 52                	cmp    $0x52,%al
f0102dbf:	75 09                	jne    f0102dca <command_allocuserpage+0x112>
			rw = 0 ;
f0102dc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102dc8:	eb 3c                	jmp    f0102e06 <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102dca:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dcd:	83 c0 0c             	add    $0xc,%eax
f0102dd0:	8b 00                	mov    (%eax),%eax
f0102dd2:	8a 00                	mov    (%eax),%al
f0102dd4:	3c 77                	cmp    $0x77,%al
f0102dd6:	74 0e                	je     f0102de6 <command_allocuserpage+0x12e>
f0102dd8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ddb:	83 c0 0c             	add    $0xc,%eax
f0102dde:	8b 00                	mov    (%eax),%eax
f0102de0:	8a 00                	mov    (%eax),%al
f0102de2:	3c 57                	cmp    $0x57,%al
f0102de4:	75 09                	jne    f0102def <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102de6:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102ded:	eb 17                	jmp    f0102e06 <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102def:	83 ec 0c             	sub    $0xc,%esp
f0102df2:	68 84 64 12 f0       	push   $0xf0126484
f0102df7:	e8 70 e1 ff ff       	call   f0100f6c <cprintf>
f0102dfc:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102dff:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e09:	83 c8 04             	or     $0x4,%eax
f0102e0c:	89 c1                	mov    %eax,%ecx
f0102e0e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e11:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e14:	8b 40 64             	mov    0x64(%eax),%eax
f0102e17:	51                   	push   %ecx
f0102e18:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e1b:	52                   	push   %edx
f0102e1c:	50                   	push   %eax
f0102e1d:	e8 99 57 00 00       	call   f01085bb <map_frame>
f0102e22:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e25:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e2a:	c9                   	leave  
f0102e2b:	c3                   	ret    

f0102e2c <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e2c:	55                   	push   %ebp
f0102e2d:	89 e5                	mov    %esp,%ebp
f0102e2f:	56                   	push   %esi
f0102e30:	53                   	push   %ebx
f0102e31:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e34:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e37:	83 ec 0c             	sub    $0xc,%esp
f0102e3a:	50                   	push   %eax
f0102e3b:	e8 33 5a 00 00       	call   f0108873 <calculate_available_frames>
f0102e40:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e43:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e46:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e49:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e4c:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e4f:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e52:	01 de                	add    %ebx,%esi
f0102e54:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e57:	01 f3                	add    %esi,%ebx
f0102e59:	83 ec 0c             	sub    $0xc,%esp
f0102e5c:	51                   	push   %ecx
f0102e5d:	52                   	push   %edx
f0102e5e:	50                   	push   %eax
f0102e5f:	53                   	push   %ebx
f0102e60:	68 c8 64 12 f0       	push   $0xf01264c8
f0102e65:	e8 02 e1 ff ff       	call   f0100f6c <cprintf>
f0102e6a:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102e6d:	a1 70 4a 5a f0       	mov    0xf05a4a70,%eax
f0102e72:	83 ec 08             	sub    $0x8,%esp
f0102e75:	50                   	push   %eax
f0102e76:	68 20 65 12 f0       	push   $0xf0126520
f0102e7b:	e8 ec e0 ff ff       	call   f0100f6c <cprintf>
f0102e80:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102e83:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e88:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102e8b:	5b                   	pop    %ebx
f0102e8c:	5e                   	pop    %esi
f0102e8d:	5d                   	pop    %ebp
f0102e8e:	c3                   	ret    

f0102e8f <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102e8f:	55                   	push   %ebp
f0102e90:	89 e5                	mov    %esp,%ebp
f0102e92:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102e95:	c7 45 ec 88 13 00 00 	movl   $0x1388,-0x14(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102e9c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ea3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eaa:	c7 45 e8 9c ff ff ff 	movl   $0xffffff9c,-0x18(%ebp)
//			assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
//		}
	}
#else
	{
		switch (number_of_arguments)
f0102eb1:	8b 45 08             	mov    0x8(%ebp),%eax
f0102eb4:	83 f8 02             	cmp    $0x2,%eax
f0102eb7:	74 3c                	je     f0102ef5 <CreateEnv+0x66>
f0102eb9:	83 f8 03             	cmp    $0x3,%eax
f0102ebc:	75 1d                	jne    f0102edb <CreateEnv+0x4c>
		{
		case 3:
			percent_WS_pages_to_remove = strtol(arguments[2], NULL, 10);
f0102ebe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ec1:	83 c0 08             	add    $0x8,%eax
f0102ec4:	8b 00                	mov    (%eax),%eax
f0102ec6:	83 ec 04             	sub    $0x4,%esp
f0102ec9:	6a 0a                	push   $0xa
f0102ecb:	6a 00                	push   $0x0
f0102ecd:	50                   	push   %eax
f0102ece:	e8 99 f8 01 00       	call   f012276c <strtol>
f0102ed3:	83 c4 10             	add    $0x10,%esp
f0102ed6:	89 45 f0             	mov    %eax,-0x10(%ebp)
			break;
f0102ed9:	eb 1b                	jmp    f0102ef6 <CreateEnv+0x67>
		case 2:
			break;
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0102edb:	83 ec 0c             	sub    $0xc,%esp
f0102ede:	68 5c 65 12 f0       	push   $0xf012655c
f0102ee3:	e8 84 e0 ff ff       	call   f0100f6c <cprintf>
f0102ee8:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0102eeb:	b8 00 00 00 00       	mov    $0x0,%eax
f0102ef0:	e9 a7 00 00 00       	jmp    f0102f9c <CreateEnv+0x10d>
		{
		case 3:
			percent_WS_pages_to_remove = strtol(arguments[2], NULL, 10);
			break;
		case 2:
			break;
f0102ef5:	90                   	nop
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
			return NULL;

			break;
		}
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102ef6:	83 ec 0c             	sub    $0xc,%esp
f0102ef9:	6a 02                	push   $0x2
f0102efb:	e8 e4 b7 00 00       	call   f010e6e4 <isPageReplacmentAlgorithmLRU>
f0102f00:	83 c4 10             	add    $0x10,%esp
f0102f03:	85 c0                	test   %eax,%eax
f0102f05:	74 07                	je     f0102f0e <CreateEnv+0x7f>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
f0102f07:	c7 45 f4 f4 01 00 00 	movl   $0x1f4,-0xc(%ebp)
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0102f0e:	83 7d f0 64          	cmpl   $0x64,-0x10(%ebp)
f0102f12:	76 19                	jbe    f0102f2d <CreateEnv+0x9e>
f0102f14:	68 cc 65 12 f0       	push   $0xf01265cc
f0102f19:	68 11 66 12 f0       	push   $0xf0126611
f0102f1e:	68 c0 01 00 00       	push   $0x1c0
f0102f23:	68 26 66 12 f0       	push   $0xf0126626
f0102f28:	e8 ed d3 ff ff       	call   f010031a <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0102f2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f30:	83 c0 04             	add    $0x4,%eax
f0102f33:	8b 00                	mov    (%eax),%eax
f0102f35:	ff 75 f0             	pushl  -0x10(%ebp)
f0102f38:	ff 75 f4             	pushl  -0xc(%ebp)
f0102f3b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102f3e:	50                   	push   %eax
f0102f3f:	e8 01 6b 00 00       	call   f0109a45 <env_create>
f0102f44:	83 c4 10             	add    $0x10,%esp
f0102f47:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f0102f4a:	83 7d e8 9c          	cmpl   $0xffffff9c,-0x18(%ebp)
f0102f4e:	74 49                	je     f0102f99 <CreateEnv+0x10a>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0102f50:	83 ec 08             	sub    $0x8,%esp
f0102f53:	ff 75 e8             	pushl  -0x18(%ebp)
f0102f56:	68 3a 66 12 f0       	push   $0xf012663a
f0102f5b:	e8 0c e0 ff ff       	call   f0100f6c <cprintf>
f0102f60:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0102f63:	83 7d e8 ec          	cmpl   $0xffffffec,-0x18(%ebp)
f0102f67:	7c 06                	jl     f0102f6f <CreateEnv+0xe0>
f0102f69:	83 7d e8 14          	cmpl   $0x14,-0x18(%ebp)
f0102f6d:	7e 19                	jle    f0102f88 <CreateEnv+0xf9>
f0102f6f:	68 4c 66 12 f0       	push   $0xf012664c
f0102f74:	68 11 66 12 f0       	push   $0xf0126611
f0102f79:	68 c5 01 00 00       	push   $0x1c5
f0102f7e:	68 26 66 12 f0       	push   $0xf0126626
f0102f83:	e8 92 d3 ff ff       	call   f010031a <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0102f88:	83 ec 08             	sub    $0x8,%esp
f0102f8b:	ff 75 e8             	pushl  -0x18(%ebp)
f0102f8e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102f91:	e8 e6 36 00 00       	call   f010667c <env_set_nice>
f0102f96:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f0102f99:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0102f9c:	c9                   	leave  
f0102f9d:	c3                   	ret    

f0102f9e <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0102f9e:	55                   	push   %ebp
f0102f9f:	89 e5                	mov    %esp,%ebp
f0102fa1:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0102fa4:	83 ec 08             	sub    $0x8,%esp
f0102fa7:	ff 75 0c             	pushl  0xc(%ebp)
f0102faa:	ff 75 08             	pushl  0x8(%ebp)
f0102fad:	e8 dd fe ff ff       	call   f0102e8f <CreateEnv>
f0102fb2:	83 c4 10             	add    $0x10,%esp
f0102fb5:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f0102fb8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0102fbc:	75 07                	jne    f0102fc5 <command_run_program+0x27>
f0102fbe:	b8 00 00 00 00       	mov    $0x0,%eax
f0102fc3:	eb 46                	jmp    f010300b <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0102fc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102fc8:	8b 40 10             	mov    0x10(%eax),%eax
f0102fcb:	83 ec 08             	sub    $0x8,%esp
f0102fce:	50                   	push   %eax
f0102fcf:	68 7c 66 12 f0       	push   $0xf012667c
f0102fd4:	e8 93 df ff ff       	call   f0100f6c <cprintf>
f0102fd9:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0102fdc:	83 ec 0c             	sub    $0xc,%esp
f0102fdf:	ff 75 f4             	pushl  -0xc(%ebp)
f0102fe2:	e8 93 26 00 00       	call   f010567a <sched_new_env>
f0102fe7:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f0102fea:	c7 05 70 4a 5a f0 00 	movl   $0x0,0xf05a4a70
f0102ff1:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0102ff4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ff7:	8b 40 10             	mov    0x10(%eax),%eax
f0102ffa:	83 ec 0c             	sub    $0xc,%esp
f0102ffd:	50                   	push   %eax
f0102ffe:	e8 cd 26 00 00       	call   f01056d0 <sched_run_env>
f0103003:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103006:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010300b:	c9                   	leave  
f010300c:	c3                   	ret    

f010300d <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f010300d:	55                   	push   %ebp
f010300e:	89 e5                	mov    %esp,%ebp
f0103010:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103013:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103016:	83 c0 04             	add    $0x4,%eax
f0103019:	8b 00                	mov    (%eax),%eax
f010301b:	83 ec 04             	sub    $0x4,%esp
f010301e:	6a 0a                	push   $0xa
f0103020:	6a 00                	push   $0x0
f0103022:	50                   	push   %eax
f0103023:	e8 44 f7 01 00       	call   f012276c <strtol>
f0103028:	83 c4 10             	add    $0x10,%esp
f010302b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f010302e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103031:	83 ec 0c             	sub    $0xc,%esp
f0103034:	50                   	push   %eax
f0103035:	e8 fe 29 00 00       	call   f0105a38 <sched_kill_env>
f010303a:	83 c4 10             	add    $0x10,%esp

	return 0;
f010303d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103042:	c9                   	leave  
f0103043:	c3                   	ret    

f0103044 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f0103044:	55                   	push   %ebp
f0103045:	89 e5                	mov    %esp,%ebp
f0103047:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f010304a:	83 ec 08             	sub    $0x8,%esp
f010304d:	ff 75 0c             	pushl  0xc(%ebp)
f0103050:	ff 75 08             	pushl  0x8(%ebp)
f0103053:	e8 37 fe ff ff       	call   f0102e8f <CreateEnv>
f0103058:	83 c4 10             	add    $0x10,%esp
f010305b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f010305e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103062:	75 07                	jne    f010306b <commnad_load_env+0x27>
		return 0 ;
f0103064:	b8 00 00 00 00       	mov    $0x0,%eax
f0103069:	eb 2a                	jmp    f0103095 <commnad_load_env+0x51>

	sched_new_env(env) ;
f010306b:	83 ec 0c             	sub    $0xc,%esp
f010306e:	ff 75 f4             	pushl  -0xc(%ebp)
f0103071:	e8 04 26 00 00       	call   f010567a <sched_new_env>
f0103076:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103079:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010307c:	8b 40 10             	mov    0x10(%eax),%eax
f010307f:	83 ec 08             	sub    $0x8,%esp
f0103082:	50                   	push   %eax
f0103083:	68 7c 66 12 f0       	push   $0xf012667c
f0103088:	e8 df de ff ff       	call   f0100f6c <cprintf>
f010308d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103090:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103095:	c9                   	leave  
f0103096:	c3                   	ret    

f0103097 <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f0103097:	55                   	push   %ebp
f0103098:	89 e5                	mov    %esp,%ebp
f010309a:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f010309d:	c7 05 70 4a 5a f0 00 	movl   $0x0,0xf05a4a70
f01030a4:	00 00 00 
	sched_run_all();
f01030a7:	e8 7b 2f 00 00       	call   f0106027 <sched_run_all>

	return 0 ;
f01030ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01030b1:	c9                   	leave  
f01030b2:	c3                   	ret    

f01030b3 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f01030b3:	55                   	push   %ebp
f01030b4:	89 e5                	mov    %esp,%ebp
f01030b6:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f01030b9:	e8 38 2d 00 00       	call   f0105df6 <sched_print_all>

	return 0 ;
f01030be:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01030c3:	c9                   	leave  
f01030c4:	c3                   	ret    

f01030c5 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f01030c5:	55                   	push   %ebp
f01030c6:	89 e5                	mov    %esp,%ebp
f01030c8:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f01030cb:	e8 ec 2f 00 00       	call   f01060bc <sched_kill_all>

	return 0 ;
f01030d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01030d5:	c9                   	leave  
f01030d6:	c3                   	ret    

f01030d7 <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f01030d7:	55                   	push   %ebp
f01030d8:	89 e5                	mov    %esp,%ebp
f01030da:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f01030dd:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01030e1:	7f 1a                	jg     f01030fd <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f01030e3:	83 ec 0c             	sub    $0xc,%esp
f01030e6:	68 94 66 12 f0       	push   $0xf0126694
f01030eb:	e8 7c de ff ff       	call   f0100f6c <cprintf>
f01030f0:	83 c4 10             	add    $0x10,%esp
		return 0;
f01030f3:	b8 00 00 00 00       	mov    $0x0,%eax
f01030f8:	e9 83 00 00 00       	jmp    f0103180 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f01030fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103100:	83 c0 04             	add    $0x4,%eax
f0103103:	8b 00                	mov    (%eax),%eax
f0103105:	83 ec 04             	sub    $0x4,%esp
f0103108:	6a 0a                	push   $0xa
f010310a:	6a 00                	push   $0x0
f010310c:	50                   	push   %eax
f010310d:	e8 5a f6 01 00       	call   f012276c <strtol>
f0103112:	83 c4 10             	add    $0x10,%esp
f0103115:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f0103118:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010311c:	75 20                	jne    f010313e <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f010311e:	83 ec 0c             	sub    $0xc,%esp
f0103121:	ff 75 f4             	pushl  -0xc(%ebp)
f0103124:	e8 30 b5 00 00       	call   f010e659 <setPageReplacmentAlgorithmLRU>
f0103129:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f010312c:	83 ec 0c             	sub    $0xc,%esp
f010312f:	68 f4 66 12 f0       	push   $0xf01266f4
f0103134:	e8 33 de ff ff       	call   f0100f6c <cprintf>
f0103139:	83 c4 10             	add    $0x10,%esp
f010313c:	eb 3d                	jmp    f010317b <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f010313e:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0103142:	75 20                	jne    f0103164 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103144:	83 ec 0c             	sub    $0xc,%esp
f0103147:	ff 75 f4             	pushl  -0xc(%ebp)
f010314a:	e8 0a b5 00 00       	call   f010e659 <setPageReplacmentAlgorithmLRU>
f010314f:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f0103152:	83 ec 0c             	sub    $0xc,%esp
f0103155:	68 38 67 12 f0       	push   $0xf0126738
f010315a:	e8 0d de ff ff       	call   f0100f6c <cprintf>
f010315f:	83 c4 10             	add    $0x10,%esp
f0103162:	eb 17                	jmp    f010317b <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103164:	83 ec 0c             	sub    $0xc,%esp
f0103167:	68 78 67 12 f0       	push   $0xf0126778
f010316c:	e8 fb dd ff ff       	call   f0100f6c <cprintf>
f0103171:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103174:	b8 00 00 00 00       	mov    $0x0,%eax
f0103179:	eb 05                	jmp    f0103180 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f010317b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103180:	c9                   	leave  
f0103181:	c3                   	ret    

f0103182 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103182:	55                   	push   %ebp
f0103183:	89 e5                	mov    %esp,%ebp
f0103185:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f0103188:	8b 45 0c             	mov    0xc(%ebp),%eax
f010318b:	83 c0 04             	add    $0x4,%eax
f010318e:	8b 00                	mov    (%eax),%eax
f0103190:	83 ec 04             	sub    $0x4,%esp
f0103193:	6a 0a                	push   $0xa
f0103195:	6a 00                	push   $0x0
f0103197:	50                   	push   %eax
f0103198:	e8 cf f5 01 00       	call   f012276c <strtol>
f010319d:	83 c4 10             	add    $0x10,%esp
f01031a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f01031a3:	83 ec 0c             	sub    $0xc,%esp
f01031a6:	ff 75 f4             	pushl  -0xc(%ebp)
f01031a9:	e8 1e b5 00 00       	call   f010e6cc <setPageReplacmentAlgorithmNchanceCLOCK>
f01031ae:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f01031b1:	83 ec 0c             	sub    $0xc,%esp
f01031b4:	68 cc 67 12 f0       	push   $0xf01267cc
f01031b9:	e8 ae dd ff ff       	call   f0100f6c <cprintf>
f01031be:	83 c4 10             	add    $0x10,%esp
	return 0;
f01031c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031c6:	c9                   	leave  
f01031c7:	c3                   	ret    

f01031c8 <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f01031c8:	55                   	push   %ebp
f01031c9:	89 e5                	mov    %esp,%ebp
f01031cb:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f01031ce:	e8 b9 b4 00 00       	call   f010e68c <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f01031d3:	83 ec 0c             	sub    $0xc,%esp
f01031d6:	68 00 68 12 f0       	push   $0xf0126800
f01031db:	e8 8c dd ff ff       	call   f0100f6c <cprintf>
f01031e0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01031e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031e8:	c9                   	leave  
f01031e9:	c3                   	ret    

f01031ea <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f01031ea:	55                   	push   %ebp
f01031eb:	89 e5                	mov    %esp,%ebp
f01031ed:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f01031f0:	e8 a7 b4 00 00       	call   f010e69c <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f01031f5:	83 ec 0c             	sub    $0xc,%esp
f01031f8:	68 2c 68 12 f0       	push   $0xf012682c
f01031fd:	e8 6a dd ff ff       	call   f0100f6c <cprintf>
f0103202:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103205:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010320a:	c9                   	leave  
f010320b:	c3                   	ret    

f010320c <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f010320c:	55                   	push   %ebp
f010320d:	89 e5                	mov    %esp,%ebp
f010320f:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f0103212:	e8 95 b4 00 00       	call   f010e6ac <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f0103217:	83 ec 0c             	sub    $0xc,%esp
f010321a:	68 54 68 12 f0       	push   $0xf0126854
f010321f:	e8 48 dd ff ff       	call   f0100f6c <cprintf>
f0103224:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103227:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010322c:	c9                   	leave  
f010322d:	c3                   	ret    

f010322e <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f010322e:	55                   	push   %ebp
f010322f:	89 e5                	mov    %esp,%ebp
f0103231:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f0103234:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103237:	83 c0 04             	add    $0x4,%eax
f010323a:	8b 00                	mov    (%eax),%eax
f010323c:	83 ec 04             	sub    $0x4,%esp
f010323f:	6a 0a                	push   $0xa
f0103241:	6a 00                	push   $0x0
f0103243:	50                   	push   %eax
f0103244:	e8 23 f5 01 00       	call   f012276c <strtol>
f0103249:	83 c4 10             	add    $0x10,%esp
f010324c:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f010324f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103253:	83 ec 0c             	sub    $0xc,%esp
f0103256:	50                   	push   %eax
f0103257:	e8 4e 37 00 00       	call   f01069aa <sched_init_RR>
f010325c:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f010325f:	a0 84 47 5a f0       	mov    0xf05a4784,%al
f0103264:	0f b6 c0             	movzbl %al,%eax
f0103267:	83 ec 08             	sub    $0x8,%esp
f010326a:	50                   	push   %eax
f010326b:	68 88 68 12 f0       	push   $0xf0126888
f0103270:	e8 f7 dc ff ff       	call   f0100f6c <cprintf>
f0103275:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103278:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010327d:	c9                   	leave  
f010327e:	c3                   	ret    

f010327f <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f010327f:	55                   	push   %ebp
f0103280:	89 e5                	mov    %esp,%ebp
f0103282:	53                   	push   %ebx
f0103283:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103286:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103289:	83 c0 04             	add    $0x4,%eax
f010328c:	8b 00                	mov    (%eax),%eax
f010328e:	83 ec 04             	sub    $0x4,%esp
f0103291:	6a 0a                	push   $0xa
f0103293:	6a 00                	push   $0x0
f0103295:	50                   	push   %eax
f0103296:	e8 d1 f4 01 00       	call   f012276c <strtol>
f010329b:	83 c4 10             	add    $0x10,%esp
f010329e:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f01032a1:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f01032a8:	eb 2e                	jmp    f01032d8 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f01032aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01032ad:	8d 58 fe             	lea    -0x2(%eax),%ebx
f01032b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01032b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01032ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032bd:	01 d0                	add    %edx,%eax
f01032bf:	8b 00                	mov    (%eax),%eax
f01032c1:	83 ec 04             	sub    $0x4,%esp
f01032c4:	6a 0a                	push   $0xa
f01032c6:	6a 00                	push   $0x0
f01032c8:	50                   	push   %eax
f01032c9:	e8 9e f4 01 00       	call   f012276c <strtol>
f01032ce:	83 c4 10             	add    $0x10,%esp
f01032d1:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f01032d5:	ff 45 f4             	incl   -0xc(%ebp)
f01032d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01032db:	3b 45 08             	cmp    0x8(%ebp),%eax
f01032de:	7c ca                	jl     f01032aa <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f01032e0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f01032e4:	83 ec 08             	sub    $0x8,%esp
f01032e7:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f01032ea:	52                   	push   %edx
f01032eb:	50                   	push   %eax
f01032ec:	e8 32 37 00 00       	call   f0106a23 <sched_init_MLFQ>
f01032f1:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f01032f4:	83 ec 0c             	sub    $0xc,%esp
f01032f7:	68 c0 68 12 f0       	push   $0xf01268c0
f01032fc:	e8 6b dc ff ff       	call   f0100f6c <cprintf>
f0103301:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f0103304:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010330b:	eb 21                	jmp    f010332e <command_sch_MLFQ+0xaf>
	{
		cprintf("%d   ", quantums[i]) ;
f010330d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103310:	05 84 47 5a f0       	add    $0xf05a4784,%eax
f0103315:	8a 00                	mov    (%eax),%al
f0103317:	0f b6 c0             	movzbl %al,%eax
f010331a:	83 ec 08             	sub    $0x8,%esp
f010331d:	50                   	push   %eax
f010331e:	68 ed 68 12 f0       	push   $0xf01268ed
f0103323:	e8 44 dc ff ff       	call   f0100f6c <cprintf>
f0103328:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f010332b:	ff 45 f0             	incl   -0x10(%ebp)
f010332e:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f0103333:	0f b6 c0             	movzbl %al,%eax
f0103336:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103339:	7f d2                	jg     f010330d <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f010333b:	83 ec 0c             	sub    $0xc,%esp
f010333e:	68 2d 64 12 f0       	push   $0xf012642d
f0103343:	e8 24 dc ff ff       	call   f0100f6c <cprintf>
f0103348:	83 c4 10             	add    $0x10,%esp
	return 0;
f010334b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103350:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103353:	c9                   	leave  
f0103354:	c3                   	ret    

f0103355 <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f0103355:	55                   	push   %ebp
f0103356:	89 e5                	mov    %esp,%ebp
f0103358:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010335b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010335e:	83 c0 04             	add    $0x4,%eax
f0103361:	8b 00                	mov    (%eax),%eax
f0103363:	83 ec 04             	sub    $0x4,%esp
f0103366:	6a 0a                	push   $0xa
f0103368:	6a 00                	push   $0x0
f010336a:	50                   	push   %eax
f010336b:	e8 fc f3 01 00       	call   f012276c <strtol>
f0103370:	83 c4 10             	add    $0x10,%esp
f0103373:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f0103376:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103379:	83 c0 08             	add    $0x8,%eax
f010337c:	8b 00                	mov    (%eax),%eax
f010337e:	83 ec 04             	sub    $0x4,%esp
f0103381:	6a 0a                	push   $0xa
f0103383:	6a 00                	push   $0x0
f0103385:	50                   	push   %eax
f0103386:	e8 e1 f3 01 00       	call   f012276c <strtol>
f010338b:	83 c4 10             	add    $0x10,%esp
f010338e:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0103391:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103395:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103399:	83 ec 08             	sub    $0x8,%esp
f010339c:	52                   	push   %edx
f010339d:	50                   	push   %eax
f010339e:	e8 a8 36 00 00       	call   f0106a4b <sched_init_BSD>
f01033a3:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f01033a6:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f01033aa:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033ae:	83 ec 04             	sub    $0x4,%esp
f01033b1:	52                   	push   %edx
f01033b2:	50                   	push   %eax
f01033b3:	68 f4 68 12 f0       	push   $0xf01268f4
f01033b8:	e8 af db ff ff       	call   f0100f6c <cprintf>
f01033bd:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01033c0:	83 ec 0c             	sub    $0xc,%esp
f01033c3:	68 2d 64 12 f0       	push   $0xf012642d
f01033c8:	e8 9f db ff ff       	call   f0100f6c <cprintf>
f01033cd:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033d5:	c9                   	leave  
f01033d6:	c3                   	ret    

f01033d7 <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f01033d7:	55                   	push   %ebp
f01033d8:	89 e5                	mov    %esp,%ebp
f01033da:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f01033dd:	e8 0b 33 00 00       	call   f01066ed <isSchedMethodMLFQ>
f01033e2:	85 c0                	test   %eax,%eax
f01033e4:	74 59                	je     f010343f <command_print_sch_method+0x68>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f01033e6:	83 ec 0c             	sub    $0xc,%esp
f01033e9:	68 30 69 12 f0       	push   $0xf0126930
f01033ee:	e8 79 db ff ff       	call   f0100f6c <cprintf>
f01033f3:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01033f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01033fd:	eb 21                	jmp    f0103420 <command_print_sch_method+0x49>
		{
			cprintf("%d   ", quantums[i]) ;
f01033ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103402:	05 84 47 5a f0       	add    $0xf05a4784,%eax
f0103407:	8a 00                	mov    (%eax),%al
f0103409:	0f b6 c0             	movzbl %al,%eax
f010340c:	83 ec 08             	sub    $0x8,%esp
f010340f:	50                   	push   %eax
f0103410:	68 ed 68 12 f0       	push   $0xf01268ed
f0103415:	e8 52 db ff ff       	call   f0100f6c <cprintf>
f010341a:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010341d:	ff 45 f4             	incl   -0xc(%ebp)
f0103420:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f0103425:	0f b6 c0             	movzbl %al,%eax
f0103428:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010342b:	7f d2                	jg     f01033ff <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f010342d:	83 ec 0c             	sub    $0xc,%esp
f0103430:	68 2d 64 12 f0       	push   $0xf012642d
f0103435:	e8 32 db ff ff       	call   f0100f6c <cprintf>
f010343a:	83 c4 10             	add    $0x10,%esp
f010343d:	eb 61                	jmp    f01034a0 <command_print_sch_method+0xc9>
	}
	else if (isSchedMethodRR())
f010343f:	e8 8f 32 00 00       	call   f01066d3 <isSchedMethodRR>
f0103444:	85 c0                	test   %eax,%eax
f0103446:	74 1b                	je     f0103463 <command_print_sch_method+0x8c>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f0103448:	a0 84 47 5a f0       	mov    0xf05a4784,%al
f010344d:	0f b6 c0             	movzbl %al,%eax
f0103450:	83 ec 08             	sub    $0x8,%esp
f0103453:	50                   	push   %eax
f0103454:	68 64 69 12 f0       	push   $0xf0126964
f0103459:	e8 0e db ff ff       	call   f0100f6c <cprintf>
f010345e:	83 c4 10             	add    $0x10,%esp
f0103461:	eb 3d                	jmp    f01034a0 <command_print_sch_method+0xc9>
	}
	else if (isSchedMethodBSD())
f0103463:	e8 a0 32 00 00       	call   f0106708 <isSchedMethodBSD>
f0103468:	85 c0                	test   %eax,%eax
f010346a:	74 24                	je     f0103490 <command_print_sch_method+0xb9>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f010346c:	a0 84 47 5a f0       	mov    0xf05a4784,%al
f0103471:	0f b6 d0             	movzbl %al,%edx
f0103474:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f0103479:	0f b6 c0             	movzbl %al,%eax
f010347c:	83 ec 04             	sub    $0x4,%esp
f010347f:	52                   	push   %edx
f0103480:	50                   	push   %eax
f0103481:	68 f4 68 12 f0       	push   $0xf01268f4
f0103486:	e8 e1 da ff ff       	call   f0100f6c <cprintf>
f010348b:	83 c4 10             	add    $0x10,%esp
f010348e:	eb 10                	jmp    f01034a0 <command_print_sch_method+0xc9>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f0103490:	83 ec 0c             	sub    $0xc,%esp
f0103493:	68 a0 69 12 f0       	push   $0xf01269a0
f0103498:	e8 cf da ff ff       	call   f0100f6c <cprintf>
f010349d:	83 c4 10             	add    $0x10,%esp

	return 0;
f01034a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034a5:	c9                   	leave  
f01034a6:	c3                   	ret    

f01034a7 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01034a7:	55                   	push   %ebp
f01034a8:	89 e5                	mov    %esp,%ebp
f01034aa:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01034ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01034b0:	83 c0 04             	add    $0x4,%eax
f01034b3:	8b 00                	mov    (%eax),%eax
f01034b5:	83 ec 04             	sub    $0x4,%esp
f01034b8:	6a 0a                	push   $0xa
f01034ba:	6a 00                	push   $0x0
f01034bc:	50                   	push   %eax
f01034bd:	e8 aa f2 01 00       	call   f012276c <strtol>
f01034c2:	83 c4 10             	add    $0x10,%esp
f01034c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f01034c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01034cb:	0f b6 c0             	movzbl %al,%eax
f01034ce:	83 ec 0c             	sub    $0xc,%esp
f01034d1:	50                   	push   %eax
f01034d2:	e8 92 e0 01 00       	call   f0121569 <chksch>
f01034d7:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f01034da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01034de:	75 12                	jne    f01034f2 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f01034e0:	83 ec 0c             	sub    $0xc,%esp
f01034e3:	68 c8 69 12 f0       	push   $0xf01269c8
f01034e8:	e8 7f da ff ff       	call   f0100f6c <cprintf>
f01034ed:	83 c4 10             	add    $0x10,%esp
f01034f0:	eb 16                	jmp    f0103508 <command_sch_test+0x61>
	else if (status == 1)
f01034f2:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01034f6:	75 10                	jne    f0103508 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f01034f8:	83 ec 0c             	sub    $0xc,%esp
f01034fb:	68 f0 69 12 f0       	push   $0xf01269f0
f0103500:	e8 67 da ff ff       	call   f0100f6c <cprintf>
f0103505:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103508:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010350d:	c9                   	leave  
f010350e:	c3                   	ret    

f010350f <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f010350f:	55                   	push   %ebp
f0103510:	89 e5                	mov    %esp,%ebp
f0103512:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f0103515:	e8 e0 b1 00 00       	call   f010e6fa <isPageReplacmentAlgorithmCLOCK>
f010351a:	85 c0                	test   %eax,%eax
f010351c:	74 15                	je     f0103533 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f010351e:	83 ec 0c             	sub    $0xc,%esp
f0103521:	68 14 6a 12 f0       	push   $0xf0126a14
f0103526:	e8 41 da ff ff       	call   f0100f6c <cprintf>
f010352b:	83 c4 10             	add    $0x10,%esp
f010352e:	e9 8c 00 00 00       	jmp    f01035bf <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0103533:	83 ec 0c             	sub    $0xc,%esp
f0103536:	6a 01                	push   $0x1
f0103538:	e8 a7 b1 00 00       	call   f010e6e4 <isPageReplacmentAlgorithmLRU>
f010353d:	83 c4 10             	add    $0x10,%esp
f0103540:	85 c0                	test   %eax,%eax
f0103542:	74 12                	je     f0103556 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f0103544:	83 ec 0c             	sub    $0xc,%esp
f0103547:	68 3c 6a 12 f0       	push   $0xf0126a3c
f010354c:	e8 1b da ff ff       	call   f0100f6c <cprintf>
f0103551:	83 c4 10             	add    $0x10,%esp
f0103554:	eb 69                	jmp    f01035bf <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103556:	83 ec 0c             	sub    $0xc,%esp
f0103559:	6a 02                	push   $0x2
f010355b:	e8 84 b1 00 00       	call   f010e6e4 <isPageReplacmentAlgorithmLRU>
f0103560:	83 c4 10             	add    $0x10,%esp
f0103563:	85 c0                	test   %eax,%eax
f0103565:	74 12                	je     f0103579 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103567:	83 ec 0c             	sub    $0xc,%esp
f010356a:	68 7c 6a 12 f0       	push   $0xf0126a7c
f010356f:	e8 f8 d9 ff ff       	call   f0100f6c <cprintf>
f0103574:	83 c4 10             	add    $0x10,%esp
f0103577:	eb 46                	jmp    f01035bf <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f0103579:	e8 97 b1 00 00       	call   f010e715 <isPageReplacmentAlgorithmFIFO>
f010357e:	85 c0                	test   %eax,%eax
f0103580:	74 12                	je     f0103594 <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f0103582:	83 ec 0c             	sub    $0xc,%esp
f0103585:	68 b8 6a 12 f0       	push   $0xf0126ab8
f010358a:	e8 dd d9 ff ff       	call   f0100f6c <cprintf>
f010358f:	83 c4 10             	add    $0x10,%esp
f0103592:	eb 2b                	jmp    f01035bf <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f0103594:	e8 97 b1 00 00       	call   f010e730 <isPageReplacmentAlgorithmModifiedCLOCK>
f0103599:	85 c0                	test   %eax,%eax
f010359b:	74 12                	je     f01035af <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f010359d:	83 ec 0c             	sub    $0xc,%esp
f01035a0:	68 dc 6a 12 f0       	push   $0xf0126adc
f01035a5:	e8 c2 d9 ff ff       	call   f0100f6c <cprintf>
f01035aa:	83 c4 10             	add    $0x10,%esp
f01035ad:	eb 10                	jmp    f01035bf <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f01035af:	83 ec 0c             	sub    $0xc,%esp
f01035b2:	68 0c 6b 12 f0       	push   $0xf0126b0c
f01035b7:	e8 b0 d9 ff ff       	call   f0100f6c <cprintf>
f01035bc:	83 c4 10             	add    $0x10,%esp

	return 0;
f01035bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035c4:	c9                   	leave  
f01035c5:	c3                   	ret    

f01035c6 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01035c6:	55                   	push   %ebp
f01035c7:	89 e5                	mov    %esp,%ebp
f01035c9:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f01035cc:	e8 bf ef ff ff       	call   f0102590 <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f01035d1:	83 ec 0c             	sub    $0xc,%esp
f01035d4:	68 38 6b 12 f0       	push   $0xf0126b38
f01035d9:	e8 8e d9 ff ff       	call   f0100f6c <cprintf>
f01035de:	83 c4 10             	add    $0x10,%esp
	return 0;
f01035e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035e6:	c9                   	leave  
f01035e7:	c3                   	ret    

f01035e8 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01035e8:	55                   	push   %ebp
f01035e9:	89 e5                	mov    %esp,%ebp
f01035eb:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f01035ee:	e8 ad ef ff ff       	call   f01025a0 <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01035f3:	83 ec 0c             	sub    $0xc,%esp
f01035f6:	68 68 6b 12 f0       	push   $0xf0126b68
f01035fb:	e8 6c d9 ff ff       	call   f0100f6c <cprintf>
f0103600:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103603:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103608:	c9                   	leave  
f0103609:	c3                   	ret    

f010360a <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f010360a:	55                   	push   %ebp
f010360b:	89 e5                	mov    %esp,%ebp
f010360d:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f0103610:	e8 9b ef ff ff       	call   f01025b0 <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f0103615:	83 ec 0c             	sub    $0xc,%esp
f0103618:	68 98 6b 12 f0       	push   $0xf0126b98
f010361d:	e8 4a d9 ff ff       	call   f0100f6c <cprintf>
f0103622:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103625:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010362a:	c9                   	leave  
f010362b:	c3                   	ret    

f010362c <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010362c:	55                   	push   %ebp
f010362d:	89 e5                	mov    %esp,%ebp
f010362f:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f0103632:	e8 89 ef ff ff       	call   f01025c0 <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f0103637:	83 ec 0c             	sub    $0xc,%esp
f010363a:	68 c8 6b 12 f0       	push   $0xf0126bc8
f010363f:	e8 28 d9 ff ff       	call   f0100f6c <cprintf>
f0103644:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103647:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010364c:	c9                   	leave  
f010364d:	c3                   	ret    

f010364e <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f010364e:	55                   	push   %ebp
f010364f:	89 e5                	mov    %esp,%ebp
f0103651:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0103654:	e8 77 ef ff ff       	call   f01025d0 <isUHeapPlacementStrategyFIRSTFIT>
f0103659:	84 c0                	test   %al,%al
f010365b:	74 12                	je     f010366f <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f010365d:	83 ec 0c             	sub    $0xc,%esp
f0103660:	68 f8 6b 12 f0       	push   $0xf0126bf8
f0103665:	e8 02 d9 ff ff       	call   f0100f6c <cprintf>
f010366a:	83 c4 10             	add    $0x10,%esp
f010366d:	eb 61                	jmp    f01036d0 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010366f:	e8 71 ef ff ff       	call   f01025e5 <isUHeapPlacementStrategyBESTFIT>
f0103674:	84 c0                	test   %al,%al
f0103676:	74 12                	je     f010368a <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103678:	83 ec 0c             	sub    $0xc,%esp
f010367b:	68 24 6c 12 f0       	push   $0xf0126c24
f0103680:	e8 e7 d8 ff ff       	call   f0100f6c <cprintf>
f0103685:	83 c4 10             	add    $0x10,%esp
f0103688:	eb 46                	jmp    f01036d0 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f010368a:	e8 6b ef ff ff       	call   f01025fa <isUHeapPlacementStrategyNEXTFIT>
f010368f:	84 c0                	test   %al,%al
f0103691:	74 12                	je     f01036a5 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103693:	83 ec 0c             	sub    $0xc,%esp
f0103696:	68 50 6c 12 f0       	push   $0xf0126c50
f010369b:	e8 cc d8 ff ff       	call   f0100f6c <cprintf>
f01036a0:	83 c4 10             	add    $0x10,%esp
f01036a3:	eb 2b                	jmp    f01036d0 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f01036a5:	e8 65 ef ff ff       	call   f010260f <isUHeapPlacementStrategyWORSTFIT>
f01036aa:	84 c0                	test   %al,%al
f01036ac:	74 12                	je     f01036c0 <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f01036ae:	83 ec 0c             	sub    $0xc,%esp
f01036b1:	68 7c 6c 12 f0       	push   $0xf0126c7c
f01036b6:	e8 b1 d8 ff ff       	call   f0100f6c <cprintf>
f01036bb:	83 c4 10             	add    $0x10,%esp
f01036be:	eb 10                	jmp    f01036d0 <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f01036c0:	83 ec 0c             	sub    $0xc,%esp
f01036c3:	68 a8 6c 12 f0       	push   $0xf0126ca8
f01036c8:	e8 9f d8 ff ff       	call   f0100f6c <cprintf>
f01036cd:	83 c4 10             	add    $0x10,%esp

	return 0;
f01036d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036d5:	c9                   	leave  
f01036d6:	c3                   	ret    

f01036d7 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f01036d7:	55                   	push   %ebp
f01036d8:	89 e5                	mov    %esp,%ebp
f01036da:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f01036dd:	e8 f6 ed ff ff       	call   f01024d8 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01036e2:	83 ec 0c             	sub    $0xc,%esp
f01036e5:	68 d4 6c 12 f0       	push   $0xf0126cd4
f01036ea:	e8 7d d8 ff ff       	call   f0100f6c <cprintf>
f01036ef:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036f7:	c9                   	leave  
f01036f8:	c3                   	ret    

f01036f9 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01036f9:	55                   	push   %ebp
f01036fa:	89 e5                	mov    %esp,%ebp
f01036fc:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f01036ff:	e8 e4 ed ff ff       	call   f01024e8 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103704:	83 ec 0c             	sub    $0xc,%esp
f0103707:	68 d4 6c 12 f0       	push   $0xf0126cd4
f010370c:	e8 5b d8 ff ff       	call   f0100f6c <cprintf>
f0103711:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103714:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103719:	c9                   	leave  
f010371a:	c3                   	ret    

f010371b <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f010371b:	55                   	push   %ebp
f010371c:	89 e5                	mov    %esp,%ebp
f010371e:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f0103721:	e8 d2 ed ff ff       	call   f01024f8 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f0103726:	83 ec 0c             	sub    $0xc,%esp
f0103729:	68 08 6d 12 f0       	push   $0xf0126d08
f010372e:	e8 39 d8 ff ff       	call   f0100f6c <cprintf>
f0103733:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103736:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010373b:	c9                   	leave  
f010373c:	c3                   	ret    

f010373d <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f010373d:	55                   	push   %ebp
f010373e:	89 e5                	mov    %esp,%ebp
f0103740:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f0103743:	e8 c0 ed ff ff       	call   f0102508 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f0103748:	83 ec 0c             	sub    $0xc,%esp
f010374b:	68 38 6d 12 f0       	push   $0xf0126d38
f0103750:	e8 17 d8 ff ff       	call   f0100f6c <cprintf>
f0103755:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103758:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010375d:	c9                   	leave  
f010375e:	c3                   	ret    

f010375f <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010375f:	55                   	push   %ebp
f0103760:	89 e5                	mov    %esp,%ebp
f0103762:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103765:	e8 ae ed ff ff       	call   f0102518 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f010376a:	83 ec 0c             	sub    $0xc,%esp
f010376d:	68 68 6d 12 f0       	push   $0xf0126d68
f0103772:	e8 f5 d7 ff ff       	call   f0100f6c <cprintf>
f0103777:	83 c4 10             	add    $0x10,%esp
	return 0;
f010377a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010377f:	c9                   	leave  
f0103780:	c3                   	ret    

f0103781 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103781:	55                   	push   %ebp
f0103782:	89 e5                	mov    %esp,%ebp
f0103784:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103787:	e8 9c ed ff ff       	call   f0102528 <isKHeapPlacementStrategyCONTALLOC>
f010378c:	84 c0                	test   %al,%al
f010378e:	74 12                	je     f01037a2 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f0103790:	83 ec 0c             	sub    $0xc,%esp
f0103793:	68 9c 6d 12 f0       	push   $0xf0126d9c
f0103798:	e8 cf d7 ff ff       	call   f0100f6c <cprintf>
f010379d:	83 c4 10             	add    $0x10,%esp
f01037a0:	eb 7c                	jmp    f010381e <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f01037a2:	e8 95 ed ff ff       	call   f010253c <isKHeapPlacementStrategyFIRSTFIT>
f01037a7:	84 c0                	test   %al,%al
f01037a9:	74 12                	je     f01037bd <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f01037ab:	83 ec 0c             	sub    $0xc,%esp
f01037ae:	68 d8 6d 12 f0       	push   $0xf0126dd8
f01037b3:	e8 b4 d7 ff ff       	call   f0100f6c <cprintf>
f01037b8:	83 c4 10             	add    $0x10,%esp
f01037bb:	eb 61                	jmp    f010381e <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f01037bd:	e8 8f ed ff ff       	call   f0102551 <isKHeapPlacementStrategyBESTFIT>
f01037c2:	84 c0                	test   %al,%al
f01037c4:	74 12                	je     f01037d8 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f01037c6:	83 ec 0c             	sub    $0xc,%esp
f01037c9:	68 08 6e 12 f0       	push   $0xf0126e08
f01037ce:	e8 99 d7 ff ff       	call   f0100f6c <cprintf>
f01037d3:	83 c4 10             	add    $0x10,%esp
f01037d6:	eb 46                	jmp    f010381e <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f01037d8:	e8 89 ed ff ff       	call   f0102566 <isKHeapPlacementStrategyNEXTFIT>
f01037dd:	84 c0                	test   %al,%al
f01037df:	74 12                	je     f01037f3 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f01037e1:	83 ec 0c             	sub    $0xc,%esp
f01037e4:	68 34 6e 12 f0       	push   $0xf0126e34
f01037e9:	e8 7e d7 ff ff       	call   f0100f6c <cprintf>
f01037ee:	83 c4 10             	add    $0x10,%esp
f01037f1:	eb 2b                	jmp    f010381e <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f01037f3:	e8 83 ed ff ff       	call   f010257b <isKHeapPlacementStrategyWORSTFIT>
f01037f8:	84 c0                	test   %al,%al
f01037fa:	74 12                	je     f010380e <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01037fc:	83 ec 0c             	sub    $0xc,%esp
f01037ff:	68 60 6e 12 f0       	push   $0xf0126e60
f0103804:	e8 63 d7 ff ff       	call   f0100f6c <cprintf>
f0103809:	83 c4 10             	add    $0x10,%esp
f010380c:	eb 10                	jmp    f010381e <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f010380e:	83 ec 0c             	sub    $0xc,%esp
f0103811:	68 90 6e 12 f0       	push   $0xf0126e90
f0103816:	e8 51 d7 ff ff       	call   f0100f6c <cprintf>
f010381b:	83 c4 10             	add    $0x10,%esp

	return 0;
f010381e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103823:	c9                   	leave  
f0103824:	c3                   	ret    

f0103825 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103825:	55                   	push   %ebp
f0103826:	89 e5                	mov    %esp,%ebp
f0103828:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f010382b:	e8 77 af 00 00       	call   f010e7a7 <isBufferingEnabled>
f0103830:	84 c0                	test   %al,%al
f0103832:	75 12                	jne    f0103846 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103834:	83 ec 0c             	sub    $0xc,%esp
f0103837:	68 c0 6e 12 f0       	push   $0xf0126ec0
f010383c:	e8 2b d7 ff ff       	call   f0100f6c <cprintf>
f0103841:	83 c4 10             	add    $0x10,%esp
f0103844:	eb 1d                	jmp    f0103863 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0103846:	83 ec 0c             	sub    $0xc,%esp
f0103849:	6a 00                	push   $0x0
f010384b:	e8 31 af 00 00       	call   f010e781 <enableModifiedBuffer>
f0103850:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103853:	83 ec 0c             	sub    $0xc,%esp
f0103856:	68 fc 6e 12 f0       	push   $0xf0126efc
f010385b:	e8 0c d7 ff ff       	call   f0100f6c <cprintf>
f0103860:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103863:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103868:	c9                   	leave  
f0103869:	c3                   	ret    

f010386a <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f010386a:	55                   	push   %ebp
f010386b:	89 e5                	mov    %esp,%ebp
f010386d:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103870:	e8 32 af 00 00       	call   f010e7a7 <isBufferingEnabled>
f0103875:	84 c0                	test   %al,%al
f0103877:	75 12                	jne    f010388b <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103879:	83 ec 0c             	sub    $0xc,%esp
f010387c:	68 c0 6e 12 f0       	push   $0xf0126ec0
f0103881:	e8 e6 d6 ff ff       	call   f0100f6c <cprintf>
f0103886:	83 c4 10             	add    $0x10,%esp
f0103889:	eb 1d                	jmp    f01038a8 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f010388b:	83 ec 0c             	sub    $0xc,%esp
f010388e:	6a 01                	push   $0x1
f0103890:	e8 ec ae 00 00       	call   f010e781 <enableModifiedBuffer>
f0103895:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103898:	83 ec 0c             	sub    $0xc,%esp
f010389b:	68 20 6f 12 f0       	push   $0xf0126f20
f01038a0:	e8 c7 d6 ff ff       	call   f0100f6c <cprintf>
f01038a5:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01038a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038ad:	c9                   	leave  
f01038ae:	c3                   	ret    

f01038af <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f01038af:	55                   	push   %ebp
f01038b0:	89 e5                	mov    %esp,%ebp
f01038b2:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f01038b5:	83 ec 0c             	sub    $0xc,%esp
f01038b8:	6a 00                	push   $0x0
f01038ba:	e8 da ae 00 00       	call   f010e799 <enableBuffering>
f01038bf:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f01038c2:	83 ec 0c             	sub    $0xc,%esp
f01038c5:	6a 00                	push   $0x0
f01038c7:	e8 b5 ae 00 00       	call   f010e781 <enableModifiedBuffer>
f01038cc:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f01038cf:	83 ec 0c             	sub    $0xc,%esp
f01038d2:	68 40 6f 12 f0       	push   $0xf0126f40
f01038d7:	e8 90 d6 ff ff       	call   f0100f6c <cprintf>
f01038dc:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038df:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038e4:	c9                   	leave  
f01038e5:	c3                   	ret    

f01038e6 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f01038e6:	55                   	push   %ebp
f01038e7:	89 e5                	mov    %esp,%ebp
f01038e9:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f01038ec:	83 ec 0c             	sub    $0xc,%esp
f01038ef:	6a 01                	push   $0x1
f01038f1:	e8 a3 ae 00 00       	call   f010e799 <enableBuffering>
f01038f6:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f01038f9:	83 ec 0c             	sub    $0xc,%esp
f01038fc:	6a 01                	push   $0x1
f01038fe:	e8 7e ae 00 00       	call   f010e781 <enableModifiedBuffer>
f0103903:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103906:	e8 b4 ae 00 00       	call   f010e7bf <getModifiedBufferLength>
f010390b:	85 c0                	test   %eax,%eax
f010390d:	75 59                	jne    f0103968 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f010390f:	83 ec 0c             	sub    $0xc,%esp
f0103912:	68 5c 6f 12 f0       	push   $0xf0126f5c
f0103917:	e8 50 d6 ff ff       	call   f0100f6c <cprintf>
f010391c:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f010391f:	83 ec 08             	sub    $0x8,%esp
f0103922:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103925:	50                   	push   %eax
f0103926:	68 8c 6f 12 f0       	push   $0xf0126f8c
f010392b:	e8 d4 e8 01 00       	call   f0122204 <readline>
f0103930:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103933:	83 ec 04             	sub    $0x4,%esp
f0103936:	6a 0a                	push   $0xa
f0103938:	6a 00                	push   $0x0
f010393a:	8d 45 94             	lea    -0x6c(%ebp),%eax
f010393d:	50                   	push   %eax
f010393e:	e8 29 ee 01 00       	call   f012276c <strtol>
f0103943:	83 c4 10             	add    $0x10,%esp
f0103946:	83 ec 0c             	sub    $0xc,%esp
f0103949:	50                   	push   %eax
f010394a:	e8 62 ae 00 00       	call   f010e7b1 <setModifiedBufferLength>
f010394f:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103952:	e8 68 ae 00 00       	call   f010e7bf <getModifiedBufferLength>
f0103957:	83 ec 08             	sub    $0x8,%esp
f010395a:	50                   	push   %eax
f010395b:	68 b8 6f 12 f0       	push   $0xf0126fb8
f0103960:	e8 07 d6 ff ff       	call   f0100f6c <cprintf>
f0103965:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103968:	83 ec 0c             	sub    $0xc,%esp
f010396b:	68 dd 6f 12 f0       	push   $0xf0126fdd
f0103970:	e8 f7 d5 ff ff       	call   f0100f6c <cprintf>
f0103975:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103978:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010397d:	c9                   	leave  
f010397e:	c3                   	ret    

f010397f <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f010397f:	55                   	push   %ebp
f0103980:	89 e5                	mov    %esp,%ebp
f0103982:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103985:	e8 1d ae 00 00       	call   f010e7a7 <isBufferingEnabled>
f010398a:	84 c0                	test   %al,%al
f010398c:	75 12                	jne    f01039a0 <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f010398e:	83 ec 0c             	sub    $0xc,%esp
f0103991:	68 f8 6f 12 f0       	push   $0xf0126ff8
f0103996:	e8 d1 d5 ff ff       	call   f0100f6c <cprintf>
f010399b:	83 c4 10             	add    $0x10,%esp
f010399e:	eb 19                	jmp    f01039b9 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f01039a0:	e8 ea ad 00 00       	call   f010e78f <isModifiedBufferEnabled>
f01039a5:	84 c0                	test   %al,%al
f01039a7:	75 10                	jne    f01039b9 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f01039a9:	83 ec 0c             	sub    $0xc,%esp
f01039ac:	68 48 70 12 f0       	push   $0xf0127048
f01039b1:	e8 b6 d5 ff ff       	call   f0100f6c <cprintf>
f01039b6:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f01039b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01039bc:	83 c0 04             	add    $0x4,%eax
f01039bf:	8b 00                	mov    (%eax),%eax
f01039c1:	83 ec 04             	sub    $0x4,%esp
f01039c4:	6a 0a                	push   $0xa
f01039c6:	6a 00                	push   $0x0
f01039c8:	50                   	push   %eax
f01039c9:	e8 9e ed 01 00       	call   f012276c <strtol>
f01039ce:	83 c4 10             	add    $0x10,%esp
f01039d1:	83 ec 0c             	sub    $0xc,%esp
f01039d4:	50                   	push   %eax
f01039d5:	e8 d7 ad 00 00       	call   f010e7b1 <setModifiedBufferLength>
f01039da:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f01039dd:	e8 dd ad 00 00       	call   f010e7bf <getModifiedBufferLength>
f01039e2:	83 ec 08             	sub    $0x8,%esp
f01039e5:	50                   	push   %eax
f01039e6:	68 b8 6f 12 f0       	push   $0xf0126fb8
f01039eb:	e8 7c d5 ff ff       	call   f0100f6c <cprintf>
f01039f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039f8:	c9                   	leave  
f01039f9:	c3                   	ret    

f01039fa <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f01039fa:	55                   	push   %ebp
f01039fb:	89 e5                	mov    %esp,%ebp
f01039fd:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a00:	e8 a2 ad 00 00       	call   f010e7a7 <isBufferingEnabled>
f0103a05:	84 c0                	test   %al,%al
f0103a07:	75 12                	jne    f0103a1b <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103a09:	83 ec 0c             	sub    $0xc,%esp
f0103a0c:	68 f8 6f 12 f0       	push   $0xf0126ff8
f0103a11:	e8 56 d5 ff ff       	call   f0100f6c <cprintf>
f0103a16:	83 c4 10             	add    $0x10,%esp
f0103a19:	eb 19                	jmp    f0103a34 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103a1b:	e8 6f ad 00 00       	call   f010e78f <isModifiedBufferEnabled>
f0103a20:	84 c0                	test   %al,%al
f0103a22:	75 10                	jne    f0103a34 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103a24:	83 ec 0c             	sub    $0xc,%esp
f0103a27:	68 48 70 12 f0       	push   $0xf0127048
f0103a2c:	e8 3b d5 ff ff       	call   f0100f6c <cprintf>
f0103a31:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103a34:	e8 86 ad 00 00       	call   f010e7bf <getModifiedBufferLength>
f0103a39:	83 ec 08             	sub    $0x8,%esp
f0103a3c:	50                   	push   %eax
f0103a3d:	68 8e 70 12 f0       	push   $0xf012708e
f0103a42:	e8 25 d5 ff ff       	call   f0100f6c <cprintf>
f0103a47:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a4a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a4f:	c9                   	leave  
f0103a50:	c3                   	ret    

f0103a51 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103a51:	55                   	push   %ebp
f0103a52:	89 e5                	mov    %esp,%ebp
f0103a54:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103a57:	83 ec 08             	sub    $0x8,%esp
f0103a5a:	ff 75 0c             	pushl  0xc(%ebp)
f0103a5d:	ff 75 08             	pushl  0x8(%ebp)
f0103a60:	e8 1a b5 00 00       	call   f010ef7f <tst_handler>
f0103a65:	83 c4 10             	add    $0x10,%esp
}
f0103a68:	c9                   	leave  
f0103a69:	c3                   	ret    

f0103a6a <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103a6a:	55                   	push   %ebp
f0103a6b:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0103a6d:	8b 45 08             	mov    0x8(%ebp),%eax
f0103a70:	8b 15 c0 48 5a f0    	mov    0xf05a48c0,%edx
f0103a76:	29 d0                	sub    %edx,%eax
f0103a78:	c1 f8 03             	sar    $0x3,%eax
f0103a7b:	89 c2                	mov    %eax,%edx
f0103a7d:	89 d0                	mov    %edx,%eax
f0103a7f:	c1 e0 02             	shl    $0x2,%eax
f0103a82:	01 d0                	add    %edx,%eax
f0103a84:	c1 e0 02             	shl    $0x2,%eax
f0103a87:	01 d0                	add    %edx,%eax
f0103a89:	c1 e0 02             	shl    $0x2,%eax
f0103a8c:	01 d0                	add    %edx,%eax
f0103a8e:	89 c1                	mov    %eax,%ecx
f0103a90:	c1 e1 08             	shl    $0x8,%ecx
f0103a93:	01 c8                	add    %ecx,%eax
f0103a95:	89 c1                	mov    %eax,%ecx
f0103a97:	c1 e1 10             	shl    $0x10,%ecx
f0103a9a:	01 c8                	add    %ecx,%eax
f0103a9c:	01 c0                	add    %eax,%eax
f0103a9e:	01 d0                	add    %edx,%eax
}
f0103aa0:	5d                   	pop    %ebp
f0103aa1:	c3                   	ret    

f0103aa2 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0103aa2:	55                   	push   %ebp
f0103aa3:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0103aa5:	ff 75 08             	pushl  0x8(%ebp)
f0103aa8:	e8 bd ff ff ff       	call   f0103a6a <to_frame_number>
f0103aad:	83 c4 04             	add    $0x4,%esp
f0103ab0:	c1 e0 0c             	shl    $0xc,%eax
}
f0103ab3:	c9                   	leave  
f0103ab4:	c3                   	ret    

f0103ab5 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0103ab5:	55                   	push   %ebp
f0103ab6:	89 e5                	mov    %esp,%ebp
f0103ab8:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0103abb:	8b 45 08             	mov    0x8(%ebp),%eax
f0103abe:	c1 e8 0c             	shr    $0xc,%eax
f0103ac1:	89 c2                	mov    %eax,%edx
f0103ac3:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0103ac8:	39 c2                	cmp    %eax,%edx
f0103aca:	72 14                	jb     f0103ae0 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0103acc:	83 ec 04             	sub    $0x4,%esp
f0103acf:	68 ac 70 12 f0       	push   $0xf01270ac
f0103ad4:	6a 55                	push   $0x55
f0103ad6:	68 d4 70 12 f0       	push   $0xf01270d4
f0103adb:	e8 3a c8 ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f0103ae0:	8b 15 c0 48 5a f0    	mov    0xf05a48c0,%edx
f0103ae6:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ae9:	c1 e8 0c             	shr    $0xc,%eax
f0103aec:	89 c1                	mov    %eax,%ecx
f0103aee:	89 c8                	mov    %ecx,%eax
f0103af0:	01 c0                	add    %eax,%eax
f0103af2:	01 c8                	add    %ecx,%eax
f0103af4:	c1 e0 03             	shl    $0x3,%eax
f0103af7:	01 d0                	add    %edx,%eax
}
f0103af9:	c9                   	leave  
f0103afa:	c3                   	ret    

f0103afb <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103afb:	55                   	push   %ebp
f0103afc:	89 e5                	mov    %esp,%ebp
f0103afe:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103b01:	8b 45 08             	mov    0x8(%ebp),%eax
f0103b04:	05 00 14 00 00       	add    $0x1400,%eax
f0103b09:	c1 e0 03             	shl    $0x3,%eax
f0103b0c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103b0f:	83 ec 04             	sub    $0x4,%esp
f0103b12:	6a 08                	push   $0x8
f0103b14:	ff 75 0c             	pushl  0xc(%ebp)
f0103b17:	ff 75 f4             	pushl  -0xc(%ebp)
f0103b1a:	e8 d5 f0 01 00       	call   f0122bf4 <ide_read>
f0103b1f:	83 c4 10             	add    $0x10,%esp
f0103b22:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103b25:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103b28:	c9                   	leave  
f0103b29:	c3                   	ret    

f0103b2a <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103b2a:	55                   	push   %ebp
f0103b2b:	89 e5                	mov    %esp,%ebp
f0103b2d:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103b30:	8b 45 08             	mov    0x8(%ebp),%eax
f0103b33:	05 00 14 00 00       	add    $0x1400,%eax
f0103b38:	c1 e0 03             	shl    $0x3,%eax
f0103b3b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103b3e:	83 ec 04             	sub    $0x4,%esp
f0103b41:	6a 08                	push   $0x8
f0103b43:	ff 75 0c             	pushl  0xc(%ebp)
f0103b46:	ff 75 f4             	pushl  -0xc(%ebp)
f0103b49:	e8 e6 f1 01 00       	call   f0122d34 <ide_write>
f0103b4e:	83 c4 10             	add    $0x10,%esp
f0103b51:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103b54:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103b58:	74 14                	je     f0103b6e <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103b5a:	83 ec 04             	sub    $0x4,%esp
f0103b5d:	68 f6 70 12 f0       	push   $0xf01270f6
f0103b62:	6a 2f                	push   $0x2f
f0103b64:	68 0d 71 12 f0       	push   $0xf012710d
f0103b69:	e8 ac c7 ff ff       	call   f010031a <_panic>
	return success;
f0103b6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103b71:	c9                   	leave  
f0103b72:	c3                   	ret    

f0103b73 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103b73:	55                   	push   %ebp
f0103b74:	89 e5                	mov    %esp,%ebp
f0103b76:	53                   	push   %ebx
f0103b77:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103b7a:	c7 05 80 4a 5a f0 00 	movl   $0x0,0xf05a4a80
f0103b81:	00 00 00 
f0103b84:	c7 05 84 4a 5a f0 00 	movl   $0x0,0xf05a4a84
f0103b8b:	00 00 00 
f0103b8e:	c7 05 8c 4a 5a f0 00 	movl   $0x0,0xf05a4a8c
f0103b95:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103b98:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103b9f:	e9 e8 00 00 00       	jmp    f0103c8c <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103ba4:	8b 0d 60 1c 5a f0    	mov    0xf05a1c60,%ecx
f0103baa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103bad:	89 d0                	mov    %edx,%eax
f0103baf:	01 c0                	add    %eax,%eax
f0103bb1:	01 d0                	add    %edx,%eax
f0103bb3:	c1 e0 03             	shl    $0x3,%eax
f0103bb6:	01 c8                	add    %ecx,%eax
f0103bb8:	83 ec 0c             	sub    $0xc,%esp
f0103bbb:	50                   	push   %eax
f0103bbc:	e8 c9 45 00 00       	call   f010818a <initialize_frame_info>
f0103bc1:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103bc4:	8b 0d 60 1c 5a f0    	mov    0xf05a1c60,%ecx
f0103bca:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103bcd:	89 d0                	mov    %edx,%eax
f0103bcf:	01 c0                	add    %eax,%eax
f0103bd1:	01 d0                	add    %edx,%eax
f0103bd3:	c1 e0 03             	shl    $0x3,%eax
f0103bd6:	01 c8                	add    %ecx,%eax
f0103bd8:	85 c0                	test   %eax,%eax
f0103bda:	75 14                	jne    f0103bf0 <initialize_disk_page_file+0x7d>
f0103bdc:	83 ec 04             	sub    $0x4,%esp
f0103bdf:	68 2c 71 12 f0       	push   $0xf012712c
f0103be4:	6a 56                	push   $0x56
f0103be6:	68 0d 71 12 f0       	push   $0xf012710d
f0103beb:	e8 2a c7 ff ff       	call   f010031a <_panic>
f0103bf0:	8b 0d 60 1c 5a f0    	mov    0xf05a1c60,%ecx
f0103bf6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103bf9:	89 d0                	mov    %edx,%eax
f0103bfb:	01 c0                	add    %eax,%eax
f0103bfd:	01 d0                	add    %edx,%eax
f0103bff:	c1 e0 03             	shl    $0x3,%eax
f0103c02:	01 c8                	add    %ecx,%eax
f0103c04:	8b 15 80 4a 5a f0    	mov    0xf05a4a80,%edx
f0103c0a:	89 10                	mov    %edx,(%eax)
f0103c0c:	8b 00                	mov    (%eax),%eax
f0103c0e:	85 c0                	test   %eax,%eax
f0103c10:	74 1f                	je     f0103c31 <initialize_disk_page_file+0xbe>
f0103c12:	8b 15 80 4a 5a f0    	mov    0xf05a4a80,%edx
f0103c18:	8b 1d 60 1c 5a f0    	mov    0xf05a1c60,%ebx
f0103c1e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103c21:	89 c8                	mov    %ecx,%eax
f0103c23:	01 c0                	add    %eax,%eax
f0103c25:	01 c8                	add    %ecx,%eax
f0103c27:	c1 e0 03             	shl    $0x3,%eax
f0103c2a:	01 d8                	add    %ebx,%eax
f0103c2c:	89 42 04             	mov    %eax,0x4(%edx)
f0103c2f:	eb 19                	jmp    f0103c4a <initialize_disk_page_file+0xd7>
f0103c31:	8b 0d 60 1c 5a f0    	mov    0xf05a1c60,%ecx
f0103c37:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103c3a:	89 d0                	mov    %edx,%eax
f0103c3c:	01 c0                	add    %eax,%eax
f0103c3e:	01 d0                	add    %edx,%eax
f0103c40:	c1 e0 03             	shl    $0x3,%eax
f0103c43:	01 c8                	add    %ecx,%eax
f0103c45:	a3 84 4a 5a f0       	mov    %eax,0xf05a4a84
f0103c4a:	8b 0d 60 1c 5a f0    	mov    0xf05a1c60,%ecx
f0103c50:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103c53:	89 d0                	mov    %edx,%eax
f0103c55:	01 c0                	add    %eax,%eax
f0103c57:	01 d0                	add    %edx,%eax
f0103c59:	c1 e0 03             	shl    $0x3,%eax
f0103c5c:	01 c8                	add    %ecx,%eax
f0103c5e:	a3 80 4a 5a f0       	mov    %eax,0xf05a4a80
f0103c63:	8b 0d 60 1c 5a f0    	mov    0xf05a1c60,%ecx
f0103c69:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103c6c:	89 d0                	mov    %edx,%eax
f0103c6e:	01 c0                	add    %eax,%eax
f0103c70:	01 d0                	add    %edx,%eax
f0103c72:	c1 e0 03             	shl    $0x3,%eax
f0103c75:	01 c8                	add    %ecx,%eax
f0103c77:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103c7e:	a1 8c 4a 5a f0       	mov    0xf05a4a8c,%eax
f0103c83:	40                   	inc    %eax
f0103c84:	a3 8c 4a 5a f0       	mov    %eax,0xf05a4a8c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103c89:	ff 45 f4             	incl   -0xc(%ebp)
f0103c8c:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103c93:	0f 8e 0b ff ff ff    	jle    f0103ba4 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103c99:	90                   	nop
f0103c9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103c9d:	c9                   	leave  
f0103c9e:	c3                   	ret    

f0103c9f <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103c9f:	55                   	push   %ebp
f0103ca0:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103ca2:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ca5:	8b 15 60 1c 5a f0    	mov    0xf05a1c60,%edx
f0103cab:	29 d0                	sub    %edx,%eax
f0103cad:	c1 f8 03             	sar    $0x3,%eax
f0103cb0:	89 c2                	mov    %eax,%edx
f0103cb2:	89 d0                	mov    %edx,%eax
f0103cb4:	c1 e0 02             	shl    $0x2,%eax
f0103cb7:	01 d0                	add    %edx,%eax
f0103cb9:	c1 e0 02             	shl    $0x2,%eax
f0103cbc:	01 d0                	add    %edx,%eax
f0103cbe:	c1 e0 02             	shl    $0x2,%eax
f0103cc1:	01 d0                	add    %edx,%eax
f0103cc3:	89 c1                	mov    %eax,%ecx
f0103cc5:	c1 e1 08             	shl    $0x8,%ecx
f0103cc8:	01 c8                	add    %ecx,%eax
f0103cca:	89 c1                	mov    %eax,%ecx
f0103ccc:	c1 e1 10             	shl    $0x10,%ecx
f0103ccf:	01 c8                	add    %ecx,%eax
f0103cd1:	01 c0                	add    %eax,%eax
f0103cd3:	01 d0                	add    %edx,%eax
}
f0103cd5:	5d                   	pop    %ebp
f0103cd6:	c3                   	ret    

f0103cd7 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103cd7:	55                   	push   %ebp
f0103cd8:	89 e5                	mov    %esp,%ebp
f0103cda:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103cdd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ce4:	83 ec 0c             	sub    $0xc,%esp
f0103ce7:	68 90 4a 5a f0       	push   $0xf05a4a90
f0103cec:	e8 04 ae 00 00       	call   f010eaf5 <acquire_spinlock>
f0103cf1:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103cf4:	a1 80 4a 5a f0       	mov    0xf05a4a80,%eax
f0103cf9:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103cfc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103d00:	75 0c                	jne    f0103d0e <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103d02:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103d09:	e9 a2 00 00 00       	jmp    f0103db0 <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103d0e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103d12:	75 14                	jne    f0103d28 <allocate_disk_frame+0x51>
f0103d14:	83 ec 04             	sub    $0x4,%esp
f0103d17:	68 4f 71 12 f0       	push   $0xf012714f
f0103d1c:	6a 7b                	push   $0x7b
f0103d1e:	68 0d 71 12 f0       	push   $0xf012710d
f0103d23:	e8 f2 c5 ff ff       	call   f010031a <_panic>
f0103d28:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d2b:	8b 00                	mov    (%eax),%eax
f0103d2d:	85 c0                	test   %eax,%eax
f0103d2f:	74 10                	je     f0103d41 <allocate_disk_frame+0x6a>
f0103d31:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d34:	8b 00                	mov    (%eax),%eax
f0103d36:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103d39:	8b 52 04             	mov    0x4(%edx),%edx
f0103d3c:	89 50 04             	mov    %edx,0x4(%eax)
f0103d3f:	eb 0b                	jmp    f0103d4c <allocate_disk_frame+0x75>
f0103d41:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d44:	8b 40 04             	mov    0x4(%eax),%eax
f0103d47:	a3 84 4a 5a f0       	mov    %eax,0xf05a4a84
f0103d4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d4f:	8b 40 04             	mov    0x4(%eax),%eax
f0103d52:	85 c0                	test   %eax,%eax
f0103d54:	74 0f                	je     f0103d65 <allocate_disk_frame+0x8e>
f0103d56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d59:	8b 40 04             	mov    0x4(%eax),%eax
f0103d5c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103d5f:	8b 12                	mov    (%edx),%edx
f0103d61:	89 10                	mov    %edx,(%eax)
f0103d63:	eb 0a                	jmp    f0103d6f <allocate_disk_frame+0x98>
f0103d65:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d68:	8b 00                	mov    (%eax),%eax
f0103d6a:	a3 80 4a 5a f0       	mov    %eax,0xf05a4a80
f0103d6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d72:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103d78:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d7b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103d82:	a1 8c 4a 5a f0       	mov    0xf05a4a8c,%eax
f0103d87:	48                   	dec    %eax
f0103d88:	a3 8c 4a 5a f0       	mov    %eax,0xf05a4a8c
			initialize_frame_info(ptr_frame_info);
f0103d8d:	83 ec 0c             	sub    $0xc,%esp
f0103d90:	ff 75 f0             	pushl  -0x10(%ebp)
f0103d93:	e8 f2 43 00 00       	call   f010818a <initialize_frame_info>
f0103d98:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103d9b:	83 ec 0c             	sub    $0xc,%esp
f0103d9e:	ff 75 f0             	pushl  -0x10(%ebp)
f0103da1:	e8 f9 fe ff ff       	call   f0103c9f <to_disk_frame_number>
f0103da6:	83 c4 10             	add    $0x10,%esp
f0103da9:	89 c2                	mov    %eax,%edx
f0103dab:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dae:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103db0:	83 ec 0c             	sub    $0xc,%esp
f0103db3:	68 90 4a 5a f0       	push   $0xf05a4a90
f0103db8:	e8 bf ad 00 00       	call   f010eb7c <release_spinlock>
f0103dbd:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103dc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103dc3:	c9                   	leave  
f0103dc4:	c3                   	ret    

f0103dc5 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103dc5:	55                   	push   %ebp
f0103dc6:	89 e5                	mov    %esp,%ebp
f0103dc8:	53                   	push   %ebx
f0103dc9:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103dcc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103dd0:	0f 84 ea 00 00 00    	je     f0103ec0 <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103dd6:	83 ec 0c             	sub    $0xc,%esp
f0103dd9:	68 90 4a 5a f0       	push   $0xf05a4a90
f0103dde:	e8 12 ad 00 00       	call   f010eaf5 <acquire_spinlock>
f0103de3:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103de6:	8b 0d 60 1c 5a f0    	mov    0xf05a1c60,%ecx
f0103dec:	8b 55 08             	mov    0x8(%ebp),%edx
f0103def:	89 d0                	mov    %edx,%eax
f0103df1:	01 c0                	add    %eax,%eax
f0103df3:	01 d0                	add    %edx,%eax
f0103df5:	c1 e0 03             	shl    $0x3,%eax
f0103df8:	01 c8                	add    %ecx,%eax
f0103dfa:	85 c0                	test   %eax,%eax
f0103dfc:	75 17                	jne    f0103e15 <free_disk_frame+0x50>
f0103dfe:	83 ec 04             	sub    $0x4,%esp
f0103e01:	68 2c 71 12 f0       	push   $0xf012712c
f0103e06:	68 8e 00 00 00       	push   $0x8e
f0103e0b:	68 0d 71 12 f0       	push   $0xf012710d
f0103e10:	e8 05 c5 ff ff       	call   f010031a <_panic>
f0103e15:	8b 0d 60 1c 5a f0    	mov    0xf05a1c60,%ecx
f0103e1b:	8b 55 08             	mov    0x8(%ebp),%edx
f0103e1e:	89 d0                	mov    %edx,%eax
f0103e20:	01 c0                	add    %eax,%eax
f0103e22:	01 d0                	add    %edx,%eax
f0103e24:	c1 e0 03             	shl    $0x3,%eax
f0103e27:	01 c8                	add    %ecx,%eax
f0103e29:	8b 15 80 4a 5a f0    	mov    0xf05a4a80,%edx
f0103e2f:	89 10                	mov    %edx,(%eax)
f0103e31:	8b 00                	mov    (%eax),%eax
f0103e33:	85 c0                	test   %eax,%eax
f0103e35:	74 1f                	je     f0103e56 <free_disk_frame+0x91>
f0103e37:	8b 15 80 4a 5a f0    	mov    0xf05a4a80,%edx
f0103e3d:	8b 1d 60 1c 5a f0    	mov    0xf05a1c60,%ebx
f0103e43:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103e46:	89 c8                	mov    %ecx,%eax
f0103e48:	01 c0                	add    %eax,%eax
f0103e4a:	01 c8                	add    %ecx,%eax
f0103e4c:	c1 e0 03             	shl    $0x3,%eax
f0103e4f:	01 d8                	add    %ebx,%eax
f0103e51:	89 42 04             	mov    %eax,0x4(%edx)
f0103e54:	eb 19                	jmp    f0103e6f <free_disk_frame+0xaa>
f0103e56:	8b 0d 60 1c 5a f0    	mov    0xf05a1c60,%ecx
f0103e5c:	8b 55 08             	mov    0x8(%ebp),%edx
f0103e5f:	89 d0                	mov    %edx,%eax
f0103e61:	01 c0                	add    %eax,%eax
f0103e63:	01 d0                	add    %edx,%eax
f0103e65:	c1 e0 03             	shl    $0x3,%eax
f0103e68:	01 c8                	add    %ecx,%eax
f0103e6a:	a3 84 4a 5a f0       	mov    %eax,0xf05a4a84
f0103e6f:	8b 0d 60 1c 5a f0    	mov    0xf05a1c60,%ecx
f0103e75:	8b 55 08             	mov    0x8(%ebp),%edx
f0103e78:	89 d0                	mov    %edx,%eax
f0103e7a:	01 c0                	add    %eax,%eax
f0103e7c:	01 d0                	add    %edx,%eax
f0103e7e:	c1 e0 03             	shl    $0x3,%eax
f0103e81:	01 c8                	add    %ecx,%eax
f0103e83:	a3 80 4a 5a f0       	mov    %eax,0xf05a4a80
f0103e88:	8b 0d 60 1c 5a f0    	mov    0xf05a1c60,%ecx
f0103e8e:	8b 55 08             	mov    0x8(%ebp),%edx
f0103e91:	89 d0                	mov    %edx,%eax
f0103e93:	01 c0                	add    %eax,%eax
f0103e95:	01 d0                	add    %edx,%eax
f0103e97:	c1 e0 03             	shl    $0x3,%eax
f0103e9a:	01 c8                	add    %ecx,%eax
f0103e9c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ea3:	a1 8c 4a 5a f0       	mov    0xf05a4a8c,%eax
f0103ea8:	40                   	inc    %eax
f0103ea9:	a3 8c 4a 5a f0       	mov    %eax,0xf05a4a8c
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103eae:	83 ec 0c             	sub    $0xc,%esp
f0103eb1:	68 90 4a 5a f0       	push   $0xf05a4a90
f0103eb6:	e8 c1 ac 00 00       	call   f010eb7c <release_spinlock>
f0103ebb:	83 c4 10             	add    $0x10,%esp
f0103ebe:	eb 01                	jmp    f0103ec1 <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103ec0:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103ec1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103ec4:	c9                   	leave  
f0103ec5:	c3                   	ret    

f0103ec6 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103ec6:	55                   	push   %ebp
f0103ec7:	89 e5                	mov    %esp,%ebp
f0103ec9:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103ecc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103ecf:	c1 e8 16             	shr    $0x16,%eax
f0103ed2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103ed9:	8b 45 08             	mov    0x8(%ebp),%eax
f0103edc:	01 d0                	add    %edx,%eax
f0103ede:	8b 00                	mov    (%eax),%eax
f0103ee0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0103ee3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103ee6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103eeb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0103eee:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103ef1:	c1 e8 0c             	shr    $0xc,%eax
f0103ef4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103ef7:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0103efc:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0103eff:	72 17                	jb     f0103f18 <get_disk_page_table+0x52>
f0103f01:	ff 75 f0             	pushl  -0x10(%ebp)
f0103f04:	68 70 71 12 f0       	push   $0xf0127170
f0103f09:	68 9d 00 00 00       	push   $0x9d
f0103f0e:	68 0d 71 12 f0       	push   $0xf012710d
f0103f13:	e8 02 c4 ff ff       	call   f010031a <_panic>
f0103f18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103f1b:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103f20:	89 c2                	mov    %eax,%edx
f0103f22:	8b 45 14             	mov    0x14(%ebp),%eax
f0103f25:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f0103f27:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103f2b:	0f 85 b7 00 00 00    	jne    f0103fe8 <get_disk_page_table+0x122>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0103f31:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0103f35:	0f 84 9d 00 00 00    	je     f0103fd8 <get_disk_page_table+0x112>
						,PERM_PRESENT);
			}
#else
			{
				struct FrameInfo* ptr_frame_info;
				allocate_frame(&ptr_frame_info) ;
f0103f3b:	83 ec 0c             	sub    $0xc,%esp
f0103f3e:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0103f41:	50                   	push   %eax
f0103f42:	e8 5e 42 00 00       	call   f01081a5 <allocate_frame>
f0103f47:	83 c4 10             	add    $0x10,%esp

				//LOG_STATMENT(cprintf("created table"));
				uint32 phys_page_table = to_physical_address(ptr_frame_info);
f0103f4a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103f4d:	83 ec 0c             	sub    $0xc,%esp
f0103f50:	50                   	push   %eax
f0103f51:	e8 4c fb ff ff       	call   f0103aa2 <to_physical_address>
f0103f56:	83 c4 10             	add    $0x10,%esp
f0103f59:	89 45 e8             	mov    %eax,-0x18(%ebp)
				*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f0103f5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0103f5f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0103f62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103f65:	c1 e8 0c             	shr    $0xc,%eax
f0103f68:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0103f6b:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0103f70:	39 45 e0             	cmp    %eax,-0x20(%ebp)
f0103f73:	72 17                	jb     f0103f8c <get_disk_page_table+0xc6>
f0103f75:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103f78:	68 70 71 12 f0       	push   $0xf0127170
f0103f7d:	68 b9 00 00 00       	push   $0xb9
f0103f82:	68 0d 71 12 f0       	push   $0xf012710d
f0103f87:	e8 8e c3 ff ff       	call   f010031a <_panic>
f0103f8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103f8f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103f94:	89 c2                	mov    %eax,%edx
f0103f96:	8b 45 14             	mov    0x14(%ebp),%eax
f0103f99:	89 10                	mov    %edx,(%eax)
				ptr_frame_info->references = 1;
f0103f9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103f9e:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
f0103fa4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fa7:	c1 e8 16             	shr    $0x16,%eax
f0103faa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103fb1:	8b 45 08             	mov    0x8(%ebp),%eax
f0103fb4:	01 d0                	add    %edx,%eax
f0103fb6:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0103fb9:	83 ca 01             	or     $0x1,%edx
f0103fbc:	89 10                	mov    %edx,(%eax)
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f0103fbe:	8b 45 14             	mov    0x14(%ebp),%eax
f0103fc1:	8b 00                	mov    (%eax),%eax
f0103fc3:	83 ec 04             	sub    $0x4,%esp
f0103fc6:	68 00 10 00 00       	push   $0x1000
f0103fcb:	6a 00                	push   $0x0
f0103fcd:	50                   	push   %eax
f0103fce:	e8 27 e6 01 00       	call   f01225fa <memset>
f0103fd3:	83 c4 10             	add    $0x10,%esp
f0103fd6:	eb 10                	jmp    f0103fe8 <get_disk_page_table+0x122>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f0103fd8:	8b 45 14             	mov    0x14(%ebp),%eax
f0103fdb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f0103fe1:	b8 00 00 00 00       	mov    $0x0,%eax
f0103fe6:	eb 05                	jmp    f0103fed <get_disk_page_table+0x127>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f0103fe8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103fed:	c9                   	leave  
f0103fee:	c3                   	ret    

f0103fef <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0103fef:	55                   	push   %ebp
f0103ff0:	89 e5                	mov    %esp,%ebp
f0103ff2:	83 ec 28             	sub    $0x28,%esp
f0103ff5:	8b 45 10             	mov    0x10(%ebp),%eax
f0103ff8:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f0103ffb:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0103fff:	74 72                	je     f0104073 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104001:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104008:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010400b:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104010:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104013:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104016:	ba 00 00 00 00       	mov    $0x0,%edx
f010401b:	f7 75 f4             	divl   -0xc(%ebp)
f010401e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104021:	29 d0                	sub    %edx,%eax
f0104023:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104026:	73 2f                	jae    f0104057 <pf_add_empty_env_page+0x68>
f0104028:	8b 45 08             	mov    0x8(%ebp),%eax
f010402b:	8b 50 6c             	mov    0x6c(%eax),%edx
f010402e:	b8 00 00 00 00       	mov    $0x0,%eax
f0104033:	29 d0                	sub    %edx,%eax
f0104035:	c1 e0 0c             	shl    $0xc,%eax
f0104038:	2d 00 20 40 11       	sub    $0x11402000,%eax
f010403d:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104040:	76 15                	jbe    f0104057 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104042:	8b 45 08             	mov    0x8(%ebp),%eax
f0104045:	8b 80 64 da 01 00    	mov    0x1da64(%eax),%eax
f010404b:	8d 50 01             	lea    0x1(%eax),%edx
f010404e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104051:	89 90 64 da 01 00    	mov    %edx,0x1da64(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104057:	a1 54 49 5a f0       	mov    0xf05a4954,%eax
f010405c:	83 ec 04             	sub    $0x4,%esp
f010405f:	50                   	push   %eax
f0104060:	ff 75 0c             	pushl  0xc(%ebp)
f0104063:	ff 75 08             	pushl  0x8(%ebp)
f0104066:	e8 b2 00 00 00       	call   f010411d <pf_add_env_page>
f010406b:	83 c4 10             	add    $0x10,%esp
f010406e:	e9 a8 00 00 00       	jmp    f010411b <pf_add_empty_env_page+0x12c>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104073:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010407a:	76 19                	jbe    f0104095 <pf_add_empty_env_page+0xa6>
f010407c:	68 a0 71 12 f0       	push   $0xf01271a0
f0104081:	68 c6 71 12 f0       	push   $0xf01271c6
f0104086:	68 dc 00 00 00       	push   $0xdc
f010408b:	68 0d 71 12 f0       	push   $0xf012710d
f0104090:	e8 85 c2 ff ff       	call   f010031a <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104095:	8b 45 08             	mov    0x8(%ebp),%eax
f0104098:	83 c0 74             	add    $0x74,%eax
f010409b:	83 ec 08             	sub    $0x8,%esp
f010409e:	50                   	push   %eax
f010409f:	ff 75 08             	pushl  0x8(%ebp)
f01040a2:	e8 ce 05 00 00       	call   f0104675 <get_disk_page_directory>
f01040a7:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01040aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01040ad:	8b 40 74             	mov    0x74(%eax),%eax
f01040b0:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01040b3:	52                   	push   %edx
f01040b4:	6a 01                	push   $0x1
f01040b6:	ff 75 0c             	pushl  0xc(%ebp)
f01040b9:	50                   	push   %eax
f01040ba:	e8 07 fe ff ff       	call   f0103ec6 <get_disk_page_table>
f01040bf:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01040c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01040c5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01040c8:	c1 ea 0c             	shr    $0xc,%edx
f01040cb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01040d1:	c1 e2 02             	shl    $0x2,%edx
f01040d4:	01 d0                	add    %edx,%eax
f01040d6:	8b 00                	mov    (%eax),%eax
f01040d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01040db:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01040de:	85 c0                	test   %eax,%eax
f01040e0:	75 34                	jne    f0104116 <pf_add_empty_env_page+0x127>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01040e2:	83 ec 0c             	sub    $0xc,%esp
f01040e5:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01040e8:	50                   	push   %eax
f01040e9:	e8 e9 fb ff ff       	call   f0103cd7 <allocate_disk_frame>
f01040ee:	83 c4 10             	add    $0x10,%esp
f01040f1:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01040f4:	75 07                	jne    f01040fd <pf_add_empty_env_page+0x10e>
f01040f6:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01040fb:	eb 1e                	jmp    f010411b <pf_add_empty_env_page+0x12c>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01040fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104100:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104103:	c1 ea 0c             	shr    $0xc,%edx
f0104106:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010410c:	c1 e2 02             	shl    $0x2,%edx
f010410f:	01 c2                	add    %eax,%edx
f0104111:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104114:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f0104116:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010411b:	c9                   	leave  
f010411c:	c3                   	ret    

f010411d <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f010411d:	55                   	push   %ebp
f010411e:	89 e5                	mov    %esp,%ebp
f0104120:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104123:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010412a:	76 19                	jbe    f0104145 <pf_add_env_page+0x28>
f010412c:	68 a0 71 12 f0       	push   $0xf01271a0
f0104131:	68 c6 71 12 f0       	push   $0xf01271c6
f0104136:	68 f1 00 00 00       	push   $0xf1
f010413b:	68 0d 71 12 f0       	push   $0xf012710d
f0104140:	e8 d5 c1 ff ff       	call   f010031a <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104145:	8b 45 08             	mov    0x8(%ebp),%eax
f0104148:	83 c0 74             	add    $0x74,%eax
f010414b:	83 ec 08             	sub    $0x8,%esp
f010414e:	50                   	push   %eax
f010414f:	ff 75 08             	pushl  0x8(%ebp)
f0104152:	e8 1e 05 00 00       	call   f0104675 <get_disk_page_directory>
f0104157:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010415a:	8b 45 08             	mov    0x8(%ebp),%eax
f010415d:	8b 40 74             	mov    0x74(%eax),%eax
f0104160:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0104163:	52                   	push   %edx
f0104164:	6a 01                	push   $0x1
f0104166:	ff 75 0c             	pushl  0xc(%ebp)
f0104169:	50                   	push   %eax
f010416a:	e8 57 fd ff ff       	call   f0103ec6 <get_disk_page_table>
f010416f:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104172:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104175:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104178:	c1 ea 0c             	shr    $0xc,%edx
f010417b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104181:	c1 e2 02             	shl    $0x2,%edx
f0104184:	01 d0                	add    %edx,%eax
f0104186:	8b 00                	mov    (%eax),%eax
f0104188:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f010418b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010418e:	85 c0                	test   %eax,%eax
f0104190:	75 34                	jne    f01041c6 <pf_add_env_page+0xa9>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0104192:	83 ec 0c             	sub    $0xc,%esp
f0104195:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0104198:	50                   	push   %eax
f0104199:	e8 39 fb ff ff       	call   f0103cd7 <allocate_disk_frame>
f010419e:	83 c4 10             	add    $0x10,%esp
f01041a1:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01041a4:	75 07                	jne    f01041ad <pf_add_env_page+0x90>
f01041a6:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01041ab:	eb 31                	jmp    f01041de <pf_add_env_page+0xc1>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01041ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041b0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041b3:	c1 ea 0c             	shr    $0xc,%edx
f01041b6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041bc:	c1 e2 02             	shl    $0x2,%edx
f01041bf:	01 c2                	add    %eax,%edx
f01041c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041c4:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01041c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041c9:	83 ec 08             	sub    $0x8,%esp
f01041cc:	ff 75 10             	pushl  0x10(%ebp)
f01041cf:	50                   	push   %eax
f01041d0:	e8 55 f9 ff ff       	call   f0103b2a <write_disk_page>
f01041d5:	83 c4 10             	add    $0x10,%esp
f01041d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01041db:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01041de:	c9                   	leave  
f01041df:	c3                   	ret    

f01041e0 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01041e0:	55                   	push   %ebp
f01041e1:	89 e5                	mov    %esp,%ebp
f01041e3:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01041e6:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01041ed:	76 19                	jbe    f0104208 <pf_update_env_page+0x28>
f01041ef:	68 a0 71 12 f0       	push   $0xf01271a0
f01041f4:	68 c6 71 12 f0       	push   $0xf01271c6
f01041f9:	68 13 01 00 00       	push   $0x113
f01041fe:	68 0d 71 12 f0       	push   $0xf012710d
f0104203:	e8 12 c1 ff ff       	call   f010031a <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104208:	8b 45 08             	mov    0x8(%ebp),%eax
f010420b:	83 c0 74             	add    $0x74,%eax
f010420e:	83 ec 08             	sub    $0x8,%esp
f0104211:	50                   	push   %eax
f0104212:	ff 75 08             	pushl  0x8(%ebp)
f0104215:	e8 5b 04 00 00       	call   f0104675 <get_disk_page_directory>
f010421a:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f010421d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104220:	8b 40 74             	mov    0x74(%eax),%eax
f0104223:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0104226:	52                   	push   %edx
f0104227:	6a 00                	push   $0x0
f0104229:	ff 75 0c             	pushl  0xc(%ebp)
f010422c:	50                   	push   %eax
f010422d:	e8 94 fc ff ff       	call   f0103ec6 <get_disk_page_table>
f0104232:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f0104235:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0104238:	85 c0                	test   %eax,%eax
f010423a:	74 29                	je     f0104265 <pf_update_env_page+0x85>
f010423c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010423f:	85 c0                	test   %eax,%eax
f0104241:	0f 84 c5 00 00 00    	je     f010430c <pf_update_env_page+0x12c>
f0104247:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010424a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010424d:	c1 ea 0c             	shr    $0xc,%edx
f0104250:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104256:	c1 e2 02             	shl    $0x2,%edx
f0104259:	01 d0                	add    %edx,%eax
f010425b:	8b 00                	mov    (%eax),%eax
f010425d:	85 c0                	test   %eax,%eax
f010425f:	0f 85 a7 00 00 00    	jne    f010430c <pf_update_env_page+0x12c>
	{

		uint32 VA = (uint32)virtual_address ;
f0104265:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104268:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f010426b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010426e:	85 c0                	test   %eax,%eax
f0104270:	79 09                	jns    f010427b <pf_update_env_page+0x9b>
f0104272:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f0104279:	76 30                	jbe    f01042ab <pf_update_env_page+0xcb>
f010427b:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0104282:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104285:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010428a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010428d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104290:	ba 00 00 00 00       	mov    $0x0,%edx
f0104295:	f7 75 f0             	divl   -0x10(%ebp)
f0104298:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010429b:	29 d0                	sub    %edx,%eax
f010429d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01042a0:	77 53                	ja     f01042f5 <pf_update_env_page+0x115>
f01042a2:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f01042a9:	77 4a                	ja     f01042f5 <pf_update_env_page+0x115>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f01042ab:	83 ec 04             	sub    $0x4,%esp
f01042ae:	6a 00                	push   $0x0
f01042b0:	ff 75 f4             	pushl  -0xc(%ebp)
f01042b3:	ff 75 08             	pushl  0x8(%ebp)
f01042b6:	e8 34 fd ff ff       	call   f0103fef <pf_add_empty_env_page>
f01042bb:	83 c4 10             	add    $0x10,%esp
f01042be:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01042c1:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f01042c5:	75 17                	jne    f01042de <pf_update_env_page+0xfe>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01042c7:	83 ec 04             	sub    $0x4,%esp
f01042ca:	68 dc 71 12 f0       	push   $0xf01271dc
f01042cf:	68 43 01 00 00       	push   $0x143
f01042d4:	68 0d 71 12 f0       	push   $0xf012710d
f01042d9:	e8 3c c0 ff ff       	call   f010031a <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01042de:	8b 45 08             	mov    0x8(%ebp),%eax
f01042e1:	8b 80 64 da 01 00    	mov    0x1da64(%eax),%eax
f01042e7:	8d 50 01             	lea    0x1(%eax),%edx
f01042ea:	8b 45 08             	mov    0x8(%ebp),%eax
f01042ed:	89 90 64 da 01 00    	mov    %edx,0x1da64(%eax)
f01042f3:	eb 17                	jmp    f010430c <pf_update_env_page+0x12c>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f01042f5:	83 ec 04             	sub    $0x4,%esp
f01042f8:	68 28 72 12 f0       	push   $0xf0127228
f01042fd:	68 4c 01 00 00       	push   $0x14c
f0104302:	68 0d 71 12 f0       	push   $0xf012710d
f0104307:	e8 0e c0 ff ff       	call   f010031a <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f010430c:	8b 45 08             	mov    0x8(%ebp),%eax
f010430f:	8b 40 74             	mov    0x74(%eax),%eax
f0104312:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0104315:	52                   	push   %edx
f0104316:	6a 00                	push   $0x0
f0104318:	ff 75 0c             	pushl  0xc(%ebp)
f010431b:	50                   	push   %eax
f010431c:	e8 a5 fb ff ff       	call   f0103ec6 <get_disk_page_table>
f0104321:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104324:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0104327:	8b 55 0c             	mov    0xc(%ebp),%edx
f010432a:	c1 ea 0c             	shr    $0xc,%edx
f010432d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104333:	c1 e2 02             	shl    $0x2,%edx
f0104336:	01 d0                	add    %edx,%eax
f0104338:	8b 00                	mov    (%eax),%eax
f010433a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//cprintf("[%s] updating page\n",ptr_env->prog_name);
	}
#else
	{
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
f010433d:	83 ec 0c             	sub    $0xc,%esp
f0104340:	ff 75 10             	pushl  0x10(%ebp)
f0104343:	e8 5a f7 ff ff       	call   f0103aa2 <to_physical_address>
f0104348:	83 c4 10             	add    $0x10,%esp
f010434b:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010434e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104351:	c1 e8 0c             	shr    $0xc,%eax
f0104354:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0104357:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f010435c:	39 45 dc             	cmp    %eax,-0x24(%ebp)
f010435f:	72 17                	jb     f0104378 <pf_update_env_page+0x198>
f0104361:	ff 75 e0             	pushl  -0x20(%ebp)
f0104364:	68 70 71 12 f0       	push   $0xf0127170
f0104369:	68 68 01 00 00       	push   $0x168
f010436e:	68 0d 71 12 f0       	push   $0xf012710d
f0104373:	e8 a2 bf ff ff       	call   f010031a <_panic>
f0104378:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010437b:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104380:	83 ec 08             	sub    $0x8,%esp
f0104383:	50                   	push   %eax
f0104384:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104387:	e8 9e f7 ff ff       	call   f0103b2a <write_disk_page>
f010438c:	83 c4 10             	add    $0x10,%esp
f010438f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f0104392:	8b 45 08             	mov    0x8(%ebp),%eax
f0104395:	8b 80 60 da 01 00    	mov    0x1da60(%eax),%eax
f010439b:	8d 50 01             	lea    0x1(%eax),%edx
f010439e:	8b 45 08             	mov    0x8(%ebp),%eax
f01043a1:	89 90 60 da 01 00    	mov    %edx,0x1da60(%eax)
	//======================

	return ret;
f01043a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01043aa:	c9                   	leave  
f01043ab:	c3                   	ret    

f01043ac <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01043ac:	55                   	push   %ebp
f01043ad:	89 e5                	mov    %esp,%ebp
f01043af:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01043b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01043b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01043bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01043c0:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01043c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01043c6:	8b 40 74             	mov    0x74(%eax),%eax
f01043c9:	85 c0                	test   %eax,%eax
f01043cb:	75 0a                	jne    f01043d7 <pf_read_env_page+0x2b>
f01043cd:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01043d2:	e9 90 00 00 00       	jmp    f0104467 <pf_read_env_page+0xbb>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f01043d7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01043da:	8b 45 08             	mov    0x8(%ebp),%eax
f01043dd:	8b 40 74             	mov    0x74(%eax),%eax
f01043e0:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f01043e3:	51                   	push   %ecx
f01043e4:	6a 00                	push   $0x0
f01043e6:	52                   	push   %edx
f01043e7:	50                   	push   %eax
f01043e8:	e8 d9 fa ff ff       	call   f0103ec6 <get_disk_page_table>
f01043ed:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01043f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01043f3:	85 c0                	test   %eax,%eax
f01043f5:	75 07                	jne    f01043fe <pf_read_env_page+0x52>
f01043f7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01043fc:	eb 69                	jmp    f0104467 <pf_read_env_page+0xbb>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01043fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104401:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104404:	c1 ea 0c             	shr    $0xc,%edx
f0104407:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010440d:	c1 e2 02             	shl    $0x2,%edx
f0104410:	01 d0                	add    %edx,%eax
f0104412:	8b 00                	mov    (%eax),%eax
f0104414:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104417:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010441b:	75 07                	jne    f0104424 <pf_read_env_page+0x78>
f010441d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104422:	eb 43                	jmp    f0104467 <pf_read_env_page+0xbb>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f0104424:	83 ec 08             	sub    $0x8,%esp
f0104427:	ff 75 0c             	pushl  0xc(%ebp)
f010442a:	ff 75 f0             	pushl  -0x10(%ebp)
f010442d:	e8 c9 f6 ff ff       	call   f0103afb <read_disk_page>
f0104432:	83 c4 10             	add    $0x10,%esp
f0104435:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104438:	8b 55 0c             	mov    0xc(%ebp),%edx
f010443b:	8b 45 08             	mov    0x8(%ebp),%eax
f010443e:	8b 40 64             	mov    0x64(%eax),%eax
f0104441:	6a 40                	push   $0x40
f0104443:	6a 00                	push   $0x0
f0104445:	52                   	push   %edx
f0104446:	50                   	push   %eax
f0104447:	e8 b1 46 00 00       	call   f0108afd <pt_set_page_permissions>
f010444c:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010444f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104452:	8b 80 5c da 01 00    	mov    0x1da5c(%eax),%eax
f0104458:	8d 50 01             	lea    0x1(%eax),%edx
f010445b:	8b 45 08             	mov    0x8(%ebp),%eax
f010445e:	89 90 5c da 01 00    	mov    %edx,0x1da5c(%eax)
	//======================

	return disk_read_error;
f0104464:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104467:	c9                   	leave  
f0104468:	c3                   	ret    

f0104469 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0104469:	55                   	push   %ebp
f010446a:	89 e5                	mov    %esp,%ebp
f010446c:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010446f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104472:	8b 40 74             	mov    0x74(%eax),%eax
f0104475:	85 c0                	test   %eax,%eax
f0104477:	74 62                	je     f01044db <pf_remove_env_page+0x72>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104479:	8b 45 08             	mov    0x8(%ebp),%eax
f010447c:	8b 40 74             	mov    0x74(%eax),%eax
f010447f:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0104482:	52                   	push   %edx
f0104483:	6a 00                	push   $0x0
f0104485:	ff 75 0c             	pushl  0xc(%ebp)
f0104488:	50                   	push   %eax
f0104489:	e8 38 fa ff ff       	call   f0103ec6 <get_disk_page_table>
f010448e:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f0104491:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104494:	85 c0                	test   %eax,%eax
f0104496:	74 46                	je     f01044de <pf_remove_env_page+0x75>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104498:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010449b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010449e:	c1 ea 0c             	shr    $0xc,%edx
f01044a1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01044a7:	c1 e2 02             	shl    $0x2,%edx
f01044aa:	01 d0                	add    %edx,%eax
f01044ac:	8b 00                	mov    (%eax),%eax
f01044ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01044b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01044b4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01044b7:	c1 ea 0c             	shr    $0xc,%edx
f01044ba:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01044c0:	c1 e2 02             	shl    $0x2,%edx
f01044c3:	01 d0                	add    %edx,%eax
f01044c5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01044cb:	83 ec 0c             	sub    $0xc,%esp
f01044ce:	ff 75 f4             	pushl  -0xc(%ebp)
f01044d1:	e8 ef f8 ff ff       	call   f0103dc5 <free_disk_frame>
f01044d6:	83 c4 10             	add    $0x10,%esp
f01044d9:	eb 04                	jmp    f01044df <pf_remove_env_page+0x76>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01044db:	90                   	nop
f01044dc:	eb 01                	jmp    f01044df <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f01044de:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f01044df:	c9                   	leave  
f01044e0:	c3                   	ret    

f01044e1 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f01044e1:	55                   	push   %ebp
f01044e2:	89 e5                	mov    %esp,%ebp
f01044e4:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01044e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01044ee:	e9 ee 00 00 00       	jmp    f01045e1 <pf_free_env+0x100>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f01044f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01044f6:	8b 40 74             	mov    0x74(%eax),%eax
f01044f9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01044fc:	c1 e2 02             	shl    $0x2,%edx
f01044ff:	01 d0                	add    %edx,%eax
f0104501:	8b 00                	mov    (%eax),%eax
f0104503:	83 e0 01             	and    $0x1,%eax
f0104506:	85 c0                	test   %eax,%eax
f0104508:	0f 84 cf 00 00 00    	je     f01045dd <pf_free_env+0xfc>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f010450e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104511:	8b 40 74             	mov    0x74(%eax),%eax
f0104514:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104517:	c1 e2 02             	shl    $0x2,%edx
f010451a:	01 d0                	add    %edx,%eax
f010451c:	8b 00                	mov    (%eax),%eax
f010451e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104523:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			pt = (uint32*) kheap_virtual_address(pa);
		}
#else
		{
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
f0104526:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104529:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010452c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010452f:	c1 e8 0c             	shr    $0xc,%eax
f0104532:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0104535:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f010453a:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010453d:	72 17                	jb     f0104556 <pf_free_env+0x75>
f010453f:	ff 75 e8             	pushl  -0x18(%ebp)
f0104542:	68 70 71 12 f0       	push   $0xf0127170
f0104547:	68 c8 01 00 00       	push   $0x1c8
f010454c:	68 0d 71 12 f0       	push   $0xf012710d
f0104551:	e8 c4 bd ff ff       	call   f010031a <_panic>
f0104556:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104559:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010455e:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0104561:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104568:	eb 3a                	jmp    f01045a4 <pf_free_env+0xc3>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f010456a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010456d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104574:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104577:	01 d0                	add    %edx,%eax
f0104579:	8b 00                	mov    (%eax),%eax
f010457b:	89 45 dc             	mov    %eax,-0x24(%ebp)
			pt[pteno] = 0;
f010457e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104581:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104588:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010458b:	01 d0                	add    %edx,%eax
f010458d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f0104593:	83 ec 0c             	sub    $0xc,%esp
f0104596:	ff 75 dc             	pushl  -0x24(%ebp)
f0104599:	e8 27 f8 ff ff       	call   f0103dc5 <free_disk_frame>
f010459e:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01045a1:	ff 45 f0             	incl   -0x10(%ebp)
f01045a4:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01045ab:	76 bd                	jbe    f010456a <pf_free_env+0x89>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01045ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01045b0:	8b 40 74             	mov    0x74(%eax),%eax
f01045b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01045b6:	c1 e2 02             	shl    $0x2,%edx
f01045b9:	01 d0                	add    %edx,%eax
f01045bb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		{
			kfree(pt);
		}
#else
		{
			decrement_references(to_frame_info(pa));
f01045c1:	83 ec 0c             	sub    $0xc,%esp
f01045c4:	ff 75 ec             	pushl  -0x14(%ebp)
f01045c7:	e8 e9 f4 ff ff       	call   f0103ab5 <to_frame_info>
f01045cc:	83 c4 10             	add    $0x10,%esp
f01045cf:	83 ec 0c             	sub    $0xc,%esp
f01045d2:	50                   	push   %eax
f01045d3:	e8 da 3d 00 00       	call   f01083b2 <decrement_references>
f01045d8:	83 c4 10             	add    $0x10,%esp
f01045db:	eb 01                	jmp    f01045de <pf_free_env+0xfd>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01045dd:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01045de:	ff 45 f4             	incl   -0xc(%ebp)
f01045e1:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01045e8:	0f 86 05 ff ff ff    	jbe    f01044f3 <pf_free_env+0x12>
	{
		kfree(ptr_env->disk_env_pgdir);
	}
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
f01045ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01045f1:	8b 40 78             	mov    0x78(%eax),%eax
f01045f4:	83 ec 0c             	sub    $0xc,%esp
f01045f7:	50                   	push   %eax
f01045f8:	e8 b8 f4 ff ff       	call   f0103ab5 <to_frame_info>
f01045fd:	83 c4 10             	add    $0x10,%esp
f0104600:	83 ec 0c             	sub    $0xc,%esp
f0104603:	50                   	push   %eax
f0104604:	e8 a9 3d 00 00       	call   f01083b2 <decrement_references>
f0104609:	83 c4 10             	add    $0x10,%esp
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f010460c:	8b 45 08             	mov    0x8(%ebp),%eax
f010460f:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f0104616:	8b 45 08             	mov    0x8(%ebp),%eax
f0104619:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104620:	8b 45 08             	mov    0x8(%ebp),%eax
f0104623:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104626:	85 c0                	test   %eax,%eax
f0104628:	74 48                	je     f0104672 <pf_free_env+0x191>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010462a:	83 ec 0c             	sub    $0xc,%esp
f010462d:	ff 75 08             	pushl  0x8(%ebp)
f0104630:	e8 dd 03 00 00       	call   f0104a12 <__pf_remove_env_all_tables>
f0104635:	83 c4 10             	add    $0x10,%esp
	{
		kfree(ptr_env->disk_env_tabledir);
	}
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
f0104638:	8b 45 08             	mov    0x8(%ebp),%eax
f010463b:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104641:	83 ec 0c             	sub    $0xc,%esp
f0104644:	50                   	push   %eax
f0104645:	e8 6b f4 ff ff       	call   f0103ab5 <to_frame_info>
f010464a:	83 c4 10             	add    $0x10,%esp
f010464d:	83 ec 0c             	sub    $0xc,%esp
f0104650:	50                   	push   %eax
f0104651:	e8 5c 3d 00 00       	call   f01083b2 <decrement_references>
f0104656:	83 c4 10             	add    $0x10,%esp
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104659:	8b 45 08             	mov    0x8(%ebp),%eax
f010465c:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f0104663:	8b 45 08             	mov    0x8(%ebp),%eax
f0104666:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010466d:	00 00 00 
f0104670:	eb 01                	jmp    f0104673 <pf_free_env+0x192>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f0104672:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f0104673:	c9                   	leave  
f0104674:	c3                   	ret    

f0104675 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0104675:	55                   	push   %ebp
f0104676:	89 e5                	mov    %esp,%ebp
f0104678:	83 ec 18             	sub    $0x18,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f010467b:	8b 45 08             	mov    0x8(%ebp),%eax
f010467e:	8b 50 74             	mov    0x74(%eax),%edx
f0104681:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104684:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104686:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104689:	8b 00                	mov    (%eax),%eax
f010468b:	85 c0                	test   %eax,%eax
f010468d:	0f 85 aa 00 00 00    	jne    f010473d <get_disk_page_directory+0xc8>
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
		}
#else
		{
			int r;
			struct FrameInfo *p = NULL;
f0104693:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

			if ((r = allocate_frame(&p)) < 0)
f010469a:	83 ec 0c             	sub    $0xc,%esp
f010469d:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01046a0:	50                   	push   %eax
f01046a1:	e8 ff 3a 00 00       	call   f01081a5 <allocate_frame>
f01046a6:	83 c4 10             	add    $0x10,%esp
f01046a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01046ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01046b0:	79 08                	jns    f01046ba <get_disk_page_directory+0x45>
				return r;
f01046b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01046b5:	e9 88 00 00 00       	jmp    f0104742 <get_disk_page_directory+0xcd>
			p->references = 1;
f01046ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01046bd:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

			//[4] initialize the new environment by the virtual address of the page directory
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f01046c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01046c6:	83 ec 0c             	sub    $0xc,%esp
f01046c9:	50                   	push   %eax
f01046ca:	e8 d3 f3 ff ff       	call   f0103aa2 <to_physical_address>
f01046cf:	83 c4 10             	add    $0x10,%esp
f01046d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01046d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01046d8:	c1 e8 0c             	shr    $0xc,%eax
f01046db:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01046de:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f01046e3:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01046e6:	72 17                	jb     f01046ff <get_disk_page_directory+0x8a>
f01046e8:	ff 75 f0             	pushl  -0x10(%ebp)
f01046eb:	68 70 71 12 f0       	push   $0xf0127170
f01046f0:	68 20 02 00 00       	push   $0x220
f01046f5:	68 0d 71 12 f0       	push   $0xf012710d
f01046fa:	e8 1b bc ff ff       	call   f010031a <_panic>
f01046ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104702:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104707:	89 c2                	mov    %eax,%edx
f0104709:	8b 45 0c             	mov    0xc(%ebp),%eax
f010470c:	89 10                	mov    %edx,(%eax)
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
f010470e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104711:	83 ec 0c             	sub    $0xc,%esp
f0104714:	50                   	push   %eax
f0104715:	e8 88 f3 ff ff       	call   f0103aa2 <to_physical_address>
f010471a:	83 c4 10             	add    $0x10,%esp
f010471d:	89 c2                	mov    %eax,%edx
f010471f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104722:	89 50 78             	mov    %edx,0x78(%eax)
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f0104725:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104728:	8b 00                	mov    (%eax),%eax
f010472a:	83 ec 04             	sub    $0x4,%esp
f010472d:	68 00 10 00 00       	push   $0x1000
f0104732:	6a 00                	push   $0x0
f0104734:	50                   	push   %eax
f0104735:	e8 c0 de 01 00       	call   f01225fa <memset>
f010473a:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f010473d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104742:	c9                   	leave  
f0104743:	c3                   	ret    

f0104744 <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f0104744:	55                   	push   %ebp
f0104745:	89 e5                	mov    %esp,%ebp
f0104747:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f010474a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104751:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104758:	e9 a6 00 00 00       	jmp    f0104803 <pf_calculate_allocated_pages+0xbf>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f010475d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104760:	8b 40 74             	mov    0x74(%eax),%eax
f0104763:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104766:	c1 e2 02             	shl    $0x2,%edx
f0104769:	01 d0                	add    %edx,%eax
f010476b:	8b 00                	mov    (%eax),%eax
f010476d:	83 e0 01             	and    $0x1,%eax
f0104770:	85 c0                	test   %eax,%eax
f0104772:	0f 84 87 00 00 00    	je     f01047ff <pf_calculate_allocated_pages+0xbb>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f0104778:	8b 45 08             	mov    0x8(%ebp),%eax
f010477b:	8b 40 74             	mov    0x74(%eax),%eax
f010477e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104781:	c1 e2 02             	shl    $0x2,%edx
f0104784:	01 d0                	add    %edx,%eax
f0104786:	8b 00                	mov    (%eax),%eax
f0104788:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010478d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		{
			pt = (uint32*) kheap_virtual_address(pa);
		}
#else
		{
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
f0104790:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104793:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0104796:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104799:	c1 e8 0c             	shr    $0xc,%eax
f010479c:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010479f:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f01047a4:	39 45 e0             	cmp    %eax,-0x20(%ebp)
f01047a7:	72 17                	jb     f01047c0 <pf_calculate_allocated_pages+0x7c>
f01047a9:	ff 75 e4             	pushl  -0x1c(%ebp)
f01047ac:	68 70 71 12 f0       	push   $0xf0127170
f01047b1:	68 40 02 00 00       	push   $0x240
f01047b6:	68 0d 71 12 f0       	push   $0xf012710d
f01047bb:	e8 5a bb ff ff       	call   f010031a <_panic>
f01047c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01047c3:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01047c8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f01047cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01047d2:	eb 20                	jmp    f01047f4 <pf_calculate_allocated_pages+0xb0>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f01047d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01047d7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01047de:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01047e1:	01 d0                	add    %edx,%eax
f01047e3:	8b 00                	mov    (%eax),%eax
f01047e5:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if(dfn != 0)
f01047e8:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01047ec:	74 03                	je     f01047f1 <pf_calculate_allocated_pages+0xad>
				counter ++;
f01047ee:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f01047f1:	ff 45 ec             	incl   -0x14(%ebp)
f01047f4:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f01047fb:	76 d7                	jbe    f01047d4 <pf_calculate_allocated_pages+0x90>
f01047fd:	eb 01                	jmp    f0104800 <pf_calculate_allocated_pages+0xbc>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f01047ff:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104800:	ff 45 f4             	incl   -0xc(%ebp)
f0104803:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010480a:	0f 86 4d ff ff ff    	jbe    f010475d <pf_calculate_allocated_pages+0x19>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0104810:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104813:	c9                   	leave  
f0104814:	c3                   	ret    

f0104815 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0104815:	55                   	push   %ebp
f0104816:	89 e5                	mov    %esp,%ebp
f0104818:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f010481b:	83 ec 0c             	sub    $0xc,%esp
f010481e:	68 90 4a 5a f0       	push   $0xf05a4a90
f0104823:	e8 cd a2 00 00       	call   f010eaf5 <acquire_spinlock>
f0104828:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f010482b:	a1 8c 4a 5a f0       	mov    0xf05a4a8c,%eax
f0104830:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0104833:	83 ec 0c             	sub    $0xc,%esp
f0104836:	68 90 4a 5a f0       	push   $0xf05a4a90
f010483b:	e8 3c a3 00 00       	call   f010eb7c <release_spinlock>
f0104840:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0104843:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f0104846:	c9                   	leave  
f0104847:	c3                   	ret    

f0104848 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f0104848:	55                   	push   %ebp
f0104849:	89 e5                	mov    %esp,%ebp
f010484b:	83 ec 18             	sub    $0x18,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f010484e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104851:	8b 50 7c             	mov    0x7c(%eax),%edx
f0104854:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104857:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f0104859:	8b 45 0c             	mov    0xc(%ebp),%eax
f010485c:	8b 00                	mov    (%eax),%eax
f010485e:	85 c0                	test   %eax,%eax
f0104860:	0f 85 ad 00 00 00    	jne    f0104913 <get_disk_table_directory+0xcb>
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
		}
#else
		{
			int r;
			struct FrameInfo *p = NULL;
f0104866:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

			if ((r = allocate_frame(&p)) < 0)
f010486d:	83 ec 0c             	sub    $0xc,%esp
f0104870:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0104873:	50                   	push   %eax
f0104874:	e8 2c 39 00 00       	call   f01081a5 <allocate_frame>
f0104879:	83 c4 10             	add    $0x10,%esp
f010487c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010487f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104883:	79 08                	jns    f010488d <get_disk_table_directory+0x45>
				return r;
f0104885:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104888:	e9 8b 00 00 00       	jmp    f0104918 <get_disk_table_directory+0xd0>
			p->references = 1;
f010488d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104890:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

			//[4] initialize the new environment by the virtual address of the page directory
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f0104896:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104899:	83 ec 0c             	sub    $0xc,%esp
f010489c:	50                   	push   %eax
f010489d:	e8 00 f2 ff ff       	call   f0103aa2 <to_physical_address>
f01048a2:	83 c4 10             	add    $0x10,%esp
f01048a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01048a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01048ab:	c1 e8 0c             	shr    $0xc,%eax
f01048ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01048b1:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f01048b6:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01048b9:	72 17                	jb     f01048d2 <get_disk_table_directory+0x8a>
f01048bb:	ff 75 f0             	pushl  -0x10(%ebp)
f01048be:	68 70 71 12 f0       	push   $0xf0127170
f01048c3:	68 83 02 00 00       	push   $0x283
f01048c8:	68 0d 71 12 f0       	push   $0xf012710d
f01048cd:	e8 48 ba ff ff       	call   f010031a <_panic>
f01048d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01048d5:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01048da:	89 c2                	mov    %eax,%edx
f01048dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048df:	89 10                	mov    %edx,(%eax)
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
f01048e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01048e4:	83 ec 0c             	sub    $0xc,%esp
f01048e7:	50                   	push   %eax
f01048e8:	e8 b5 f1 ff ff       	call   f0103aa2 <to_physical_address>
f01048ed:	83 c4 10             	add    $0x10,%esp
f01048f0:	89 c2                	mov    %eax,%edx
f01048f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01048f5:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f01048fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048fe:	8b 00                	mov    (%eax),%eax
f0104900:	83 ec 04             	sub    $0x4,%esp
f0104903:	68 00 10 00 00       	push   $0x1000
f0104908:	6a 00                	push   $0x0
f010490a:	50                   	push   %eax
f010490b:	e8 ea dc 01 00       	call   f01225fa <memset>
f0104910:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104913:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104918:	c9                   	leave  
f0104919:	c3                   	ret    

f010491a <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f010491a:	55                   	push   %ebp
f010491b:	89 e5                	mov    %esp,%ebp
f010491d:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f0104920:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104927:	76 19                	jbe    f0104942 <__pf_write_env_table+0x28>
f0104929:	68 a0 71 12 f0       	push   $0xf01271a0
f010492e:	68 c6 71 12 f0       	push   $0xf01271c6
f0104933:	68 91 02 00 00       	push   $0x291
f0104938:	68 0d 71 12 f0       	push   $0xf012710d
f010493d:	e8 d8 b9 ff ff       	call   f010031a <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f0104942:	8b 45 08             	mov    0x8(%ebp),%eax
f0104945:	83 c0 7c             	add    $0x7c,%eax
f0104948:	83 ec 08             	sub    $0x8,%esp
f010494b:	50                   	push   %eax
f010494c:	ff 75 08             	pushl  0x8(%ebp)
f010494f:	e8 f4 fe ff ff       	call   f0104848 <get_disk_table_directory>
f0104954:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104957:	8b 45 08             	mov    0x8(%ebp),%eax
f010495a:	8b 40 7c             	mov    0x7c(%eax),%eax
f010495d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104960:	c1 ea 16             	shr    $0x16,%edx
f0104963:	c1 e2 02             	shl    $0x2,%edx
f0104966:	01 d0                	add    %edx,%eax
f0104968:	8b 00                	mov    (%eax),%eax
f010496a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f010496d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104970:	85 c0                	test   %eax,%eax
f0104972:	75 31                	jne    f01049a5 <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0104974:	83 ec 0c             	sub    $0xc,%esp
f0104977:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010497a:	50                   	push   %eax
f010497b:	e8 57 f3 ff ff       	call   f0103cd7 <allocate_disk_frame>
f0104980:	83 c4 10             	add    $0x10,%esp
f0104983:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104986:	75 07                	jne    f010498f <__pf_write_env_table+0x75>
f0104988:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010498d:	eb 2e                	jmp    f01049bd <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f010498f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104992:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104995:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104998:	c1 ea 16             	shr    $0x16,%edx
f010499b:	c1 e2 02             	shl    $0x2,%edx
f010499e:	01 c2                	add    %eax,%edx
f01049a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049a3:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01049a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049a8:	83 ec 08             	sub    $0x8,%esp
f01049ab:	ff 75 10             	pushl  0x10(%ebp)
f01049ae:	50                   	push   %eax
f01049af:	e8 76 f1 ff ff       	call   f0103b2a <write_disk_page>
f01049b4:	83 c4 10             	add    $0x10,%esp
f01049b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01049ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01049bd:	c9                   	leave  
f01049be:	c3                   	ret    

f01049bf <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f01049bf:	55                   	push   %ebp
f01049c0:	89 e5                	mov    %esp,%ebp
f01049c2:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f01049c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01049c8:	8b 40 7c             	mov    0x7c(%eax),%eax
f01049cb:	85 c0                	test   %eax,%eax
f01049cd:	75 07                	jne    f01049d6 <__pf_read_env_table+0x17>
f01049cf:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f01049d4:	eb 3a                	jmp    f0104a10 <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f01049d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01049d9:	8b 40 7c             	mov    0x7c(%eax),%eax
f01049dc:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049df:	c1 ea 16             	shr    $0x16,%edx
f01049e2:	c1 e2 02             	shl    $0x2,%edx
f01049e5:	01 d0                	add    %edx,%eax
f01049e7:	8b 00                	mov    (%eax),%eax
f01049e9:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f01049ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01049f0:	75 07                	jne    f01049f9 <__pf_read_env_table+0x3a>
f01049f2:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f01049f7:	eb 17                	jmp    f0104a10 <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f01049f9:	83 ec 08             	sub    $0x8,%esp
f01049fc:	ff 75 10             	pushl  0x10(%ebp)
f01049ff:	ff 75 f4             	pushl  -0xc(%ebp)
f0104a02:	e8 f4 f0 ff ff       	call   f0103afb <read_disk_page>
f0104a07:	83 c4 10             	add    $0x10,%esp
f0104a0a:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104a0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a10:	c9                   	leave  
f0104a11:	c3                   	ret    

f0104a12 <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104a12:	55                   	push   %ebp
f0104a13:	89 e5                	mov    %esp,%ebp
f0104a15:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a18:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a1b:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a1e:	85 c0                	test   %eax,%eax
f0104a20:	74 4c                	je     f0104a6e <__pf_remove_env_all_tables+0x5c>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a29:	eb 38                	jmp    f0104a63 <__pf_remove_env_all_tables+0x51>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104a2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a2e:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a34:	c1 e2 02             	shl    $0x2,%edx
f0104a37:	01 d0                	add    %edx,%eax
f0104a39:	8b 00                	mov    (%eax),%eax
f0104a3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104a3e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a41:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a44:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a47:	c1 e2 02             	shl    $0x2,%edx
f0104a4a:	01 d0                	add    %edx,%eax
f0104a4c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104a52:	83 ec 0c             	sub    $0xc,%esp
f0104a55:	ff 75 f0             	pushl  -0x10(%ebp)
f0104a58:	e8 68 f3 ff ff       	call   f0103dc5 <free_disk_frame>
f0104a5d:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a60:	ff 45 f4             	incl   -0xc(%ebp)
f0104a63:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104a6a:	76 bf                	jbe    f0104a2b <__pf_remove_env_all_tables+0x19>
f0104a6c:	eb 01                	jmp    f0104a6f <__pf_remove_env_all_tables+0x5d>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a6e:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104a6f:	c9                   	leave  
f0104a70:	c3                   	ret    

f0104a71 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104a71:	55                   	push   %ebp
f0104a72:	89 e5                	mov    %esp,%ebp
f0104a74:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104a77:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104a7b:	75 10                	jne    f0104a8d <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104a7d:	83 ec 0c             	sub    $0xc,%esp
f0104a80:	68 a4 72 12 f0       	push   $0xf01272a4
f0104a85:	e8 e2 c4 ff ff       	call   f0100f6c <cprintf>
f0104a8a:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a8d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a90:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a93:	85 c0                	test   %eax,%eax
f0104a95:	74 3d                	je     f0104ad4 <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a97:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a9a:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a9d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104aa0:	c1 ea 16             	shr    $0x16,%edx
f0104aa3:	c1 e2 02             	shl    $0x2,%edx
f0104aa6:	01 d0                	add    %edx,%eax
f0104aa8:	8b 00                	mov    (%eax),%eax
f0104aaa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104aad:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ab0:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104ab3:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104ab6:	c1 ea 16             	shr    $0x16,%edx
f0104ab9:	c1 e2 02             	shl    $0x2,%edx
f0104abc:	01 d0                	add    %edx,%eax
f0104abe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104ac4:	83 ec 0c             	sub    $0xc,%esp
f0104ac7:	ff 75 f4             	pushl  -0xc(%ebp)
f0104aca:	e8 f6 f2 ff ff       	call   f0103dc5 <free_disk_frame>
f0104acf:	83 c4 10             	add    $0x10,%esp
f0104ad2:	eb 01                	jmp    f0104ad5 <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ad4:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104ad5:	c9                   	leave  
f0104ad6:	c3                   	ret    

f0104ad7 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104ad7:	55                   	push   %ebp
f0104ad8:	89 e5                	mov    %esp,%ebp
f0104ada:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104add:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104ae4:	eb 1f                	jmp    f0104b05 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104ae6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104ae9:	83 ec 04             	sub    $0x4,%esp
f0104aec:	6a 08                	push   $0x8
f0104aee:	ff 75 08             	pushl  0x8(%ebp)
f0104af1:	50                   	push   %eax
f0104af2:	e8 3d e2 01 00       	call   f0122d34 <ide_write>
f0104af7:	83 c4 10             	add    $0x10,%esp
f0104afa:	85 c0                	test   %eax,%eax
f0104afc:	75 12                	jne    f0104b10 <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104afe:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104b05:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104b0c:	7e d8                	jle    f0104ae6 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b0e:	eb 01                	jmp    f0104b11 <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104b10:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b11:	90                   	nop
f0104b12:	c9                   	leave  
f0104b13:	c3                   	ret    

f0104b14 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104b14:	55                   	push   %ebp
  pushl %eax
f0104b15:	50                   	push   %eax
  pushl %ebx
f0104b16:	53                   	push   %ebx
  pushl %ecx
f0104b17:	51                   	push   %ecx
  pushl %edx
f0104b18:	52                   	push   %edx
  pushl %esi
f0104b19:	56                   	push   %esi
  pushl %edi
f0104b1a:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104b1b:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104b1f:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104b23:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104b25:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104b27:	5f                   	pop    %edi
  popl %esi
f0104b28:	5e                   	pop    %esi
  popl %edx
f0104b29:	5a                   	pop    %edx
  popl %ecx
f0104b2a:	59                   	pop    %ecx
  popl %ebx
f0104b2b:	5b                   	pop    %ebx
  popl %eax
f0104b2c:	58                   	pop    %eax
  popl %ebp
f0104b2d:	5d                   	pop    %ebp
  ret
f0104b2e:	c3                   	ret    

f0104b2f <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104b2f:	55                   	push   %ebp
f0104b30:	89 e5                	mov    %esp,%ebp
f0104b32:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b35:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b38:	0f b6 c0             	movzbl %al,%eax
f0104b3b:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b42:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104b45:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104b48:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104b4b:	ee                   	out    %al,(%dx)
f0104b4c:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104b53:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104b56:	89 c2                	mov    %eax,%edx
f0104b58:	ec                   	in     (%dx),%al
f0104b59:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104b5c:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104b5f:	0f b6 c0             	movzbl %al,%eax
}
f0104b62:	c9                   	leave  
f0104b63:	c3                   	ret    

f0104b64 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104b64:	55                   	push   %ebp
f0104b65:	89 e5                	mov    %esp,%ebp
f0104b67:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b6a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b6d:	0f b6 c0             	movzbl %al,%eax
f0104b70:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b77:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104b7a:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104b7d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104b80:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104b81:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b84:	0f b6 c0             	movzbl %al,%eax
f0104b87:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104b8e:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104b91:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104b94:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104b97:	ee                   	out    %al,(%dx)
}
f0104b98:	90                   	nop
f0104b99:	c9                   	leave  
f0104b9a:	c3                   	ret    

f0104b9b <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104b9b:	55                   	push   %ebp
f0104b9c:	89 e5                	mov    %esp,%ebp
f0104b9e:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104ba1:	c7 05 68 4a 5a f0 00 	movl   $0x0,0xf05a4a68
f0104ba8:	00 00 00 
f0104bab:	c7 05 6c 4a 5a f0 00 	movl   $0x0,0xf05a4a6c
f0104bb2:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104bb5:	83 ec 08             	sub    $0x8,%esp
f0104bb8:	68 89 6b 10 f0       	push   $0xf0106b89
f0104bbd:	6a 00                	push   $0x0
f0104bbf:	e8 a9 87 00 00       	call   f010d36d <irq_install_handler>
f0104bc4:	83 c4 10             	add    $0x10,%esp
}
f0104bc7:	90                   	nop
f0104bc8:	c9                   	leave  
f0104bc9:	c3                   	ret    

f0104bca <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104bca:	55                   	push   %ebp
f0104bcb:	89 e5                	mov    %esp,%ebp
f0104bcd:	53                   	push   %ebx
f0104bce:	83 ec 24             	sub    $0x24,%esp
f0104bd1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bd4:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104bd7:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104bde:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104be2:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104be5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104be8:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104be9:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104bed:	77 48                	ja     f0104c37 <kclock_start+0x6d>
f0104bef:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104bf6:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104bfa:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104bfd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c00:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104c01:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c05:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104c0a:	99                   	cltd   
f0104c0b:	f7 fb                	idiv   %ebx
f0104c0d:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104c13:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c17:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104c1c:	99                   	cltd   
f0104c1d:	f7 fb                	idiv   %ebx
f0104c1f:	89 c3                	mov    %eax,%ebx
f0104c21:	89 c8                	mov    %ecx,%eax
f0104c23:	99                   	cltd   
f0104c24:	f7 fb                	idiv   %ebx
f0104c26:	0f b7 c0             	movzwl %ax,%eax
f0104c29:	83 ec 0c             	sub    $0xc,%esp
f0104c2c:	50                   	push   %eax
f0104c2d:	e8 b3 01 00 00       	call   f0104de5 <kclock_write_cnt0_LSB_first>
f0104c32:	83 c4 10             	add    $0x10,%esp
f0104c35:	eb 13                	jmp    f0104c4a <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104c37:	6a 35                	push   $0x35
f0104c39:	68 c8 72 12 f0       	push   $0xf01272c8
f0104c3e:	6a 41                	push   $0x41
f0104c40:	68 24 73 12 f0       	push   $0xf0127324
f0104c45:	e8 d0 b6 ff ff       	call   f010031a <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104c4a:	83 ec 0c             	sub    $0xc,%esp
f0104c4d:	6a 00                	push   $0x0
f0104c4f:	e8 66 23 00 00       	call   f0106fba <irq_clear_mask>
f0104c54:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104c57:	90                   	nop
f0104c58:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104c5b:	c9                   	leave  
f0104c5c:	c3                   	ret    

f0104c5d <kclock_stop>:

void
kclock_stop(void)
{
f0104c5d:	55                   	push   %ebp
f0104c5e:	89 e5                	mov    %esp,%ebp
f0104c60:	83 ec 18             	sub    $0x18,%esp
f0104c63:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c6a:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104c6e:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104c71:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c74:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104c75:	83 ec 0c             	sub    $0xc,%esp
f0104c78:	6a 00                	push   $0x0
f0104c7a:	e8 c6 22 00 00       	call   f0106f45 <irq_set_mask>
f0104c7f:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104c82:	90                   	nop
f0104c83:	c9                   	leave  
f0104c84:	c3                   	ret    

f0104c85 <kclock_resume>:

void
kclock_resume(void)
{
f0104c85:	55                   	push   %ebp
f0104c86:	89 e5                	mov    %esp,%ebp
f0104c88:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104c8b:	e8 f5 01 00 00       	call   f0104e85 <kclock_read_cnt0_latch>
f0104c90:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104c94:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104c99:	77 06                	ja     f0104ca1 <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104c9b:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104ca1:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104ca5:	83 e0 01             	and    $0x1,%eax
f0104ca8:	66 85 c0             	test   %ax,%ax
f0104cab:	74 09                	je     f0104cb6 <kclock_resume+0x31>
		cnt0++;
f0104cad:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104cb1:	40                   	inc    %eax
f0104cb2:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104cb6:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104cbd:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104cc1:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104cc4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104cc7:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104cc8:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104ccc:	83 ec 0c             	sub    $0xc,%esp
f0104ccf:	50                   	push   %eax
f0104cd0:	e8 10 01 00 00       	call   f0104de5 <kclock_write_cnt0_LSB_first>
f0104cd5:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104cd8:	83 ec 0c             	sub    $0xc,%esp
f0104cdb:	6a 00                	push   $0x0
f0104cdd:	e8 d8 22 00 00       	call   f0106fba <irq_clear_mask>
f0104ce2:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104ce5:	90                   	nop
f0104ce6:	c9                   	leave  
f0104ce7:	c3                   	ret    

f0104ce8 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104ce8:	55                   	push   %ebp
f0104ce9:	89 e5                	mov    %esp,%ebp
f0104ceb:	83 ec 28             	sub    $0x28,%esp
f0104cee:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cf1:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104cf4:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104cfb:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104cff:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104d02:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d05:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d06:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104d0a:	83 ec 0c             	sub    $0xc,%esp
f0104d0d:	50                   	push   %eax
f0104d0e:	e8 d2 00 00 00       	call   f0104de5 <kclock_write_cnt0_LSB_first>
f0104d13:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d16:	83 ec 0c             	sub    $0xc,%esp
f0104d19:	6a 00                	push   $0x0
f0104d1b:	e8 9a 22 00 00       	call   f0106fba <irq_clear_mask>
f0104d20:	83 c4 10             	add    $0x10,%esp
}
f0104d23:	90                   	nop
f0104d24:	c9                   	leave  
f0104d25:	c3                   	ret    

f0104d26 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104d26:	55                   	push   %ebp
f0104d27:	89 e5                	mov    %esp,%ebp
f0104d29:	56                   	push   %esi
f0104d2a:	53                   	push   %ebx
f0104d2b:	83 ec 20             	sub    $0x20,%esp
f0104d2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d31:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104d34:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104d38:	0f 87 8a 00 00 00    	ja     f0104dc8 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104d3e:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d42:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104d47:	99                   	cltd   
f0104d48:	f7 fe                	idiv   %esi
f0104d4a:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104d50:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104d54:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104d59:	99                   	cltd   
f0104d5a:	f7 fb                	idiv   %ebx
f0104d5c:	89 c6                	mov    %eax,%esi
f0104d5e:	89 c8                	mov    %ecx,%eax
f0104d60:	99                   	cltd   
f0104d61:	f7 fe                	idiv   %esi
f0104d63:	89 c3                	mov    %eax,%ebx
f0104d65:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104d69:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104d6e:	99                   	cltd   
f0104d6f:	f7 f9                	idiv   %ecx
f0104d71:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104d77:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d7b:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104d80:	99                   	cltd   
f0104d81:	f7 fe                	idiv   %esi
f0104d83:	89 c6                	mov    %eax,%esi
f0104d85:	89 c8                	mov    %ecx,%eax
f0104d87:	99                   	cltd   
f0104d88:	f7 fe                	idiv   %esi
f0104d8a:	25 01 00 00 80       	and    $0x80000001,%eax
f0104d8f:	85 c0                	test   %eax,%eax
f0104d91:	79 05                	jns    f0104d98 <kclock_set_quantum+0x72>
f0104d93:	48                   	dec    %eax
f0104d94:	83 c8 fe             	or     $0xfffffffe,%eax
f0104d97:	40                   	inc    %eax
f0104d98:	01 d8                	add    %ebx,%eax
f0104d9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104d9d:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104da4:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104da8:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104dab:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104dae:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104daf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104db2:	0f b7 c0             	movzwl %ax,%eax
f0104db5:	83 ec 0c             	sub    $0xc,%esp
f0104db8:	50                   	push   %eax
f0104db9:	e8 27 00 00 00       	call   f0104de5 <kclock_write_cnt0_LSB_first>
f0104dbe:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104dc1:	e8 97 fe ff ff       	call   f0104c5d <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104dc6:	eb 16                	jmp    f0104dde <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104dc8:	6a 35                	push   $0x35
f0104dca:	68 c8 72 12 f0       	push   $0xf01272c8
f0104dcf:	68 ea 00 00 00       	push   $0xea
f0104dd4:	68 24 73 12 f0       	push   $0xf0127324
f0104dd9:	e8 3c b5 ff ff       	call   f010031a <_panic>
	}
}
f0104dde:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104de1:	5b                   	pop    %ebx
f0104de2:	5e                   	pop    %esi
f0104de3:	5d                   	pop    %ebp
f0104de4:	c3                   	ret    

f0104de5 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104de5:	55                   	push   %ebp
f0104de6:	89 e5                	mov    %esp,%ebp
f0104de8:	83 ec 28             	sub    $0x28,%esp
f0104deb:	8b 45 08             	mov    0x8(%ebp),%eax
f0104dee:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104df2:	e8 9e 23 00 00       	call   f0107195 <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104df7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104dfa:	0f b6 c0             	movzbl %al,%eax
f0104dfd:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104e04:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104e07:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e0a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e0d:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104e0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e11:	66 c1 e8 08          	shr    $0x8,%ax
f0104e15:	0f b6 c0             	movzbl %al,%eax
f0104e18:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104e1f:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104e22:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e25:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e28:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104e29:	e8 b9 23 00 00       	call   f01071e7 <popcli>

}
f0104e2e:	90                   	nop
f0104e2f:	c9                   	leave  
f0104e30:	c3                   	ret    

f0104e31 <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104e31:	55                   	push   %ebp
f0104e32:	89 e5                	mov    %esp,%ebp
f0104e34:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104e37:	e8 59 23 00 00       	call   f0107195 <pushcli>
f0104e3c:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104e43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e46:	89 c2                	mov    %eax,%edx
f0104e48:	ec                   	in     (%dx),%al
f0104e49:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104e4c:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104e4f:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104e52:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104e59:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104e5c:	89 c2                	mov    %eax,%edx
f0104e5e:	ec                   	in     (%dx),%al
f0104e5f:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104e62:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104e65:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104e68:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104e6c:	c1 e0 08             	shl    $0x8,%eax
f0104e6f:	89 c2                	mov    %eax,%edx
f0104e71:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104e75:	09 d0                	or     %edx,%eax
f0104e77:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104e7b:	e8 67 23 00 00       	call   f01071e7 <popcli>
	return cnt0 ;
f0104e80:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104e83:	c9                   	leave  
f0104e84:	c3                   	ret    

f0104e85 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104e85:	55                   	push   %ebp
f0104e86:	89 e5                	mov    %esp,%ebp
f0104e88:	83 ec 30             	sub    $0x30,%esp
f0104e8b:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104e92:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104e95:	89 c2                	mov    %eax,%edx
f0104e97:	ec                   	in     (%dx),%al
f0104e98:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104e9b:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104e9e:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104ea1:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104ea8:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104eac:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104eaf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104eb2:	ee                   	out    %al,(%dx)
f0104eb3:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eba:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104ebd:	89 c2                	mov    %eax,%edx
f0104ebf:	ec                   	in     (%dx),%al
f0104ec0:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104ec3:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104ec6:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104ec9:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ed0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104ed3:	89 c2                	mov    %eax,%edx
f0104ed5:	ec                   	in     (%dx),%al
f0104ed6:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104ed9:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104edc:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104edf:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104ee3:	c1 e0 08             	shl    $0x8,%eax
f0104ee6:	89 c2                	mov    %eax,%edx
f0104ee8:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104eec:	09 d0                	or     %edx,%eax
f0104eee:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104ef2:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104ef6:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104efd:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f00:	8a 45 df             	mov    -0x21(%ebp),%al
f0104f03:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104f06:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104f07:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104f0a:	c9                   	leave  
f0104f0b:	c3                   	ret    

f0104f0c <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104f0c:	55                   	push   %ebp
f0104f0d:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f0f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f13:	74 1d                	je     f0104f32 <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104f15:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f18:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f21:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f28:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f2b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104f32:	90                   	nop
f0104f33:	5d                   	pop    %ebp
f0104f34:	c3                   	ret    

f0104f35 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104f35:	55                   	push   %ebp
f0104f36:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f38:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f3c:	74 08                	je     f0104f46 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104f3e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f41:	8b 40 0c             	mov    0xc(%eax),%eax
f0104f44:	eb 05                	jmp    f0104f4b <queue_size+0x16>
	}
	else
	{
		return 0;
f0104f46:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104f4b:	5d                   	pop    %ebp
f0104f4c:	c3                   	ret    

f0104f4d <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104f4d:	55                   	push   %ebp
f0104f4e:	89 e5                	mov    %esp,%ebp
f0104f50:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104f53:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f57:	75 16                	jne    f0104f6f <enqueue+0x22>
f0104f59:	68 38 73 12 f0       	push   $0xf0127338
f0104f5e:	68 46 73 12 f0       	push   $0xf0127346
f0104f63:	6a 34                	push   $0x34
f0104f65:	68 5b 73 12 f0       	push   $0xf012735b
f0104f6a:	e8 ab b3 ff ff       	call   f010031a <_panic>
	if(env != NULL)
f0104f6f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104f73:	74 66                	je     f0104fdb <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104f75:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104f79:	75 14                	jne    f0104f8f <enqueue+0x42>
f0104f7b:	83 ec 04             	sub    $0x4,%esp
f0104f7e:	68 74 73 12 f0       	push   $0xf0127374
f0104f83:	6a 37                	push   $0x37
f0104f85:	68 5b 73 12 f0       	push   $0xf012735b
f0104f8a:	e8 8b b3 ff ff       	call   f010031a <_panic>
f0104f8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f92:	8b 10                	mov    (%eax),%edx
f0104f94:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104f97:	89 50 08             	mov    %edx,0x8(%eax)
f0104f9a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104f9d:	8b 40 08             	mov    0x8(%eax),%eax
f0104fa0:	85 c0                	test   %eax,%eax
f0104fa2:	74 0d                	je     f0104fb1 <enqueue+0x64>
f0104fa4:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fa7:	8b 00                	mov    (%eax),%eax
f0104fa9:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104fac:	89 50 0c             	mov    %edx,0xc(%eax)
f0104faf:	eb 09                	jmp    f0104fba <enqueue+0x6d>
f0104fb1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fb4:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104fb7:	89 50 04             	mov    %edx,0x4(%eax)
f0104fba:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fbd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104fc0:	89 10                	mov    %edx,(%eax)
f0104fc2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104fc5:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0104fcc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fcf:	8b 40 0c             	mov    0xc(%eax),%eax
f0104fd2:	8d 50 01             	lea    0x1(%eax),%edx
f0104fd5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fd8:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0104fdb:	90                   	nop
f0104fdc:	c9                   	leave  
f0104fdd:	c3                   	ret    

f0104fde <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f0104fde:	55                   	push   %ebp
f0104fdf:	89 e5                	mov    %esp,%ebp
f0104fe1:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0104fe4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fe8:	75 0a                	jne    f0104ff4 <dequeue+0x16>
f0104fea:	b8 00 00 00 00       	mov    $0x0,%eax
f0104fef:	e9 a0 00 00 00       	jmp    f0105094 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0104ff4:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ff7:	8b 40 04             	mov    0x4(%eax),%eax
f0104ffa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f0104ffd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105001:	0f 84 8a 00 00 00    	je     f0105091 <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105007:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010500b:	75 14                	jne    f0105021 <dequeue+0x43>
f010500d:	83 ec 04             	sub    $0x4,%esp
f0105010:	68 97 73 12 f0       	push   $0xf0127397
f0105015:	6a 44                	push   $0x44
f0105017:	68 5b 73 12 f0       	push   $0xf012735b
f010501c:	e8 f9 b2 ff ff       	call   f010031a <_panic>
f0105021:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105024:	8b 40 08             	mov    0x8(%eax),%eax
f0105027:	85 c0                	test   %eax,%eax
f0105029:	74 11                	je     f010503c <dequeue+0x5e>
f010502b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010502e:	8b 40 08             	mov    0x8(%eax),%eax
f0105031:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105034:	8b 52 0c             	mov    0xc(%edx),%edx
f0105037:	89 50 0c             	mov    %edx,0xc(%eax)
f010503a:	eb 0c                	jmp    f0105048 <dequeue+0x6a>
f010503c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010503f:	8b 50 0c             	mov    0xc(%eax),%edx
f0105042:	8b 45 08             	mov    0x8(%ebp),%eax
f0105045:	89 50 04             	mov    %edx,0x4(%eax)
f0105048:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010504b:	8b 40 0c             	mov    0xc(%eax),%eax
f010504e:	85 c0                	test   %eax,%eax
f0105050:	74 11                	je     f0105063 <dequeue+0x85>
f0105052:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105055:	8b 40 0c             	mov    0xc(%eax),%eax
f0105058:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010505b:	8b 52 08             	mov    0x8(%edx),%edx
f010505e:	89 50 08             	mov    %edx,0x8(%eax)
f0105061:	eb 0b                	jmp    f010506e <dequeue+0x90>
f0105063:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105066:	8b 50 08             	mov    0x8(%eax),%edx
f0105069:	8b 45 08             	mov    0x8(%ebp),%eax
f010506c:	89 10                	mov    %edx,(%eax)
f010506e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105071:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105078:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010507b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105082:	8b 45 08             	mov    0x8(%ebp),%eax
f0105085:	8b 40 0c             	mov    0xc(%eax),%eax
f0105088:	8d 50 ff             	lea    -0x1(%eax),%edx
f010508b:	8b 45 08             	mov    0x8(%ebp),%eax
f010508e:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f0105091:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0105094:	c9                   	leave  
f0105095:	c3                   	ret    

f0105096 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f0105096:	55                   	push   %ebp
f0105097:	89 e5                	mov    %esp,%ebp
f0105099:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f010509c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01050a0:	75 16                	jne    f01050b8 <remove_from_queue+0x22>
f01050a2:	68 38 73 12 f0       	push   $0xf0127338
f01050a7:	68 46 73 12 f0       	push   $0xf0127346
f01050ac:	6a 4e                	push   $0x4e
f01050ae:	68 5b 73 12 f0       	push   $0xf012735b
f01050b3:	e8 62 b2 ff ff       	call   f010031a <_panic>

	if (e != NULL)
f01050b8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01050bc:	0f 84 8a 00 00 00    	je     f010514c <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f01050c2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01050c6:	75 14                	jne    f01050dc <remove_from_queue+0x46>
f01050c8:	83 ec 04             	sub    $0x4,%esp
f01050cb:	68 97 73 12 f0       	push   $0xf0127397
f01050d0:	6a 52                	push   $0x52
f01050d2:	68 5b 73 12 f0       	push   $0xf012735b
f01050d7:	e8 3e b2 ff ff       	call   f010031a <_panic>
f01050dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01050df:	8b 40 08             	mov    0x8(%eax),%eax
f01050e2:	85 c0                	test   %eax,%eax
f01050e4:	74 11                	je     f01050f7 <remove_from_queue+0x61>
f01050e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01050e9:	8b 40 08             	mov    0x8(%eax),%eax
f01050ec:	8b 55 0c             	mov    0xc(%ebp),%edx
f01050ef:	8b 52 0c             	mov    0xc(%edx),%edx
f01050f2:	89 50 0c             	mov    %edx,0xc(%eax)
f01050f5:	eb 0c                	jmp    f0105103 <remove_from_queue+0x6d>
f01050f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01050fa:	8b 50 0c             	mov    0xc(%eax),%edx
f01050fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0105100:	89 50 04             	mov    %edx,0x4(%eax)
f0105103:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105106:	8b 40 0c             	mov    0xc(%eax),%eax
f0105109:	85 c0                	test   %eax,%eax
f010510b:	74 11                	je     f010511e <remove_from_queue+0x88>
f010510d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105110:	8b 40 0c             	mov    0xc(%eax),%eax
f0105113:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105116:	8b 52 08             	mov    0x8(%edx),%edx
f0105119:	89 50 08             	mov    %edx,0x8(%eax)
f010511c:	eb 0b                	jmp    f0105129 <remove_from_queue+0x93>
f010511e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105121:	8b 50 08             	mov    0x8(%eax),%edx
f0105124:	8b 45 08             	mov    0x8(%ebp),%eax
f0105127:	89 10                	mov    %edx,(%eax)
f0105129:	8b 45 0c             	mov    0xc(%ebp),%eax
f010512c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105133:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105136:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010513d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105140:	8b 40 0c             	mov    0xc(%eax),%eax
f0105143:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105146:	8b 45 08             	mov    0x8(%ebp),%eax
f0105149:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f010514c:	90                   	nop
f010514d:	c9                   	leave  
f010514e:	c3                   	ret    

f010514f <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f010514f:	55                   	push   %ebp
f0105150:	89 e5                	mov    %esp,%ebp
f0105152:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f0105155:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105159:	75 07                	jne    f0105162 <find_env_in_queue+0x13>
f010515b:	b8 00 00 00 00       	mov    $0x0,%eax
f0105160:	eb 58                	jmp    f01051ba <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f0105162:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f0105169:	8b 45 08             	mov    0x8(%ebp),%eax
f010516c:	8b 00                	mov    (%eax),%eax
f010516e:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0105171:	eb 19                	jmp    f010518c <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f0105173:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0105176:	8b 40 10             	mov    0x10(%eax),%eax
f0105179:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010517c:	75 05                	jne    f0105183 <find_env_in_queue+0x34>
		{
			return ptr_env;
f010517e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0105181:	eb 37                	jmp    f01051ba <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f0105183:	8b 45 08             	mov    0x8(%ebp),%eax
f0105186:	8b 40 08             	mov    0x8(%eax),%eax
f0105189:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010518c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0105190:	74 08                	je     f010519a <find_env_in_queue+0x4b>
f0105192:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0105195:	8b 40 08             	mov    0x8(%eax),%eax
f0105198:	eb 05                	jmp    f010519f <find_env_in_queue+0x50>
f010519a:	b8 00 00 00 00       	mov    $0x0,%eax
f010519f:	8b 55 08             	mov    0x8(%ebp),%edx
f01051a2:	89 42 08             	mov    %eax,0x8(%edx)
f01051a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01051a8:	8b 40 08             	mov    0x8(%eax),%eax
f01051ab:	85 c0                	test   %eax,%eax
f01051ad:	75 c4                	jne    f0105173 <find_env_in_queue+0x24>
f01051af:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051b3:	75 be                	jne    f0105173 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f01051b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01051ba:	c9                   	leave  
f01051bb:	c3                   	ret    

f01051bc <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f01051bc:	55                   	push   %ebp
f01051bd:	89 e5                	mov    %esp,%ebp
			kfree(quantums);
	}
	release_spinlock(&ProcessQueues.qlock);

#endif
}
f01051bf:	90                   	nop
f01051c0:	5d                   	pop    %ebp
f01051c1:	c3                   	ret    

f01051c2 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f01051c2:	55                   	push   %ebp
f01051c3:	89 e5                	mov    %esp,%ebp
f01051c5:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01051c8:	83 ec 0c             	sub    $0xc,%esp
f01051cb:	68 00 1e 5a f0       	push   $0xf05a1e00
f01051d0:	e8 39 9b 00 00       	call   f010ed0e <holding_spinlock>
f01051d5:	83 c4 10             	add    $0x10,%esp
f01051d8:	85 c0                	test   %eax,%eax
f01051da:	75 17                	jne    f01051f3 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01051dc:	83 ec 04             	sub    $0x4,%esp
f01051df:	68 b8 73 12 f0       	push   $0xf01273b8
f01051e4:	68 85 00 00 00       	push   $0x85
f01051e9:	68 5b 73 12 f0       	push   $0xf012735b
f01051ee:	e8 27 b1 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01051f3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051f7:	75 19                	jne    f0105212 <sched_insert_ready0+0x50>
f01051f9:	68 f9 73 12 f0       	push   $0xf01273f9
f01051fe:	68 46 73 12 f0       	push   $0xf0127346
f0105203:	68 88 00 00 00       	push   $0x88
f0105208:	68 5b 73 12 f0       	push   $0xf012735b
f010520d:	e8 08 b1 ff ff       	call   f010031a <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0105212:	8b 45 08             	mov    0x8(%ebp),%eax
f0105215:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f010521c:	83 ec 08             	sub    $0x8,%esp
f010521f:	ff 75 08             	pushl  0x8(%ebp)
f0105222:	68 90 1e 5a f0       	push   $0xf05a1e90
f0105227:	e8 21 fd ff ff       	call   f0104f4d <enqueue>
f010522c:	83 c4 10             	add    $0x10,%esp
	}
}
f010522f:	90                   	nop
f0105230:	c9                   	leave  
f0105231:	c3                   	ret    

f0105232 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0105232:	55                   	push   %ebp
f0105233:	89 e5                	mov    %esp,%ebp
f0105235:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105238:	83 ec 0c             	sub    $0xc,%esp
f010523b:	68 00 1e 5a f0       	push   $0xf05a1e00
f0105240:	e8 c9 9a 00 00       	call   f010ed0e <holding_spinlock>
f0105245:	83 c4 10             	add    $0x10,%esp
f0105248:	85 c0                	test   %eax,%eax
f010524a:	75 17                	jne    f0105263 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010524c:	83 ec 04             	sub    $0x4,%esp
f010524f:	68 b8 73 12 f0       	push   $0xf01273b8
f0105254:	68 97 00 00 00       	push   $0x97
f0105259:	68 5b 73 12 f0       	push   $0xf012735b
f010525e:	e8 b7 b0 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105263:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105267:	74 0b                	je     f0105274 <sched_remove_ready+0x42>
f0105269:	8b 45 08             	mov    0x8(%ebp),%eax
f010526c:	8b 40 18             	mov    0x18(%eax),%eax
f010526f:	83 f8 01             	cmp    $0x1,%eax
f0105272:	74 19                	je     f010528d <sched_remove_ready+0x5b>
f0105274:	68 08 74 12 f0       	push   $0xf0127408
f0105279:	68 46 73 12 f0       	push   $0xf0127346
f010527e:	68 9a 00 00 00       	push   $0x9a
f0105283:	68 5b 73 12 f0       	push   $0xf012735b
f0105288:	e8 8d b0 ff ff       	call   f010031a <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010528d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105294:	e9 f7 00 00 00       	jmp    f0105390 <sched_remove_ready+0x15e>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f0105299:	8b 45 08             	mov    0x8(%ebp),%eax
f010529c:	8b 40 10             	mov    0x10(%eax),%eax
f010529f:	89 c2                	mov    %eax,%edx
f01052a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052a4:	83 c0 09             	add    $0x9,%eax
f01052a7:	c1 e0 04             	shl    $0x4,%eax
f01052aa:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f01052af:	83 ec 08             	sub    $0x8,%esp
f01052b2:	52                   	push   %edx
f01052b3:	50                   	push   %eax
f01052b4:	e8 96 fe ff ff       	call   f010514f <find_env_in_queue>
f01052b9:	83 c4 10             	add    $0x10,%esp
f01052bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f01052bf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01052c3:	0f 84 c4 00 00 00    	je     f010538d <sched_remove_ready+0x15b>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f01052c9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052cd:	75 17                	jne    f01052e6 <sched_remove_ready+0xb4>
f01052cf:	83 ec 04             	sub    $0x4,%esp
f01052d2:	68 97 73 12 f0       	push   $0xf0127397
f01052d7:	68 a1 00 00 00       	push   $0xa1
f01052dc:	68 5b 73 12 f0       	push   $0xf012735b
f01052e1:	e8 34 b0 ff ff       	call   f010031a <_panic>
f01052e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01052e9:	8b 40 08             	mov    0x8(%eax),%eax
f01052ec:	85 c0                	test   %eax,%eax
f01052ee:	74 11                	je     f0105301 <sched_remove_ready+0xcf>
f01052f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01052f3:	8b 40 08             	mov    0x8(%eax),%eax
f01052f6:	8b 55 08             	mov    0x8(%ebp),%edx
f01052f9:	8b 52 0c             	mov    0xc(%edx),%edx
f01052fc:	89 50 0c             	mov    %edx,0xc(%eax)
f01052ff:	eb 17                	jmp    f0105318 <sched_remove_ready+0xe6>
f0105301:	8b 45 08             	mov    0x8(%ebp),%eax
f0105304:	8b 40 0c             	mov    0xc(%eax),%eax
f0105307:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010530a:	83 c2 09             	add    $0x9,%edx
f010530d:	c1 e2 04             	shl    $0x4,%edx
f0105310:	81 c2 04 1e 5a f0    	add    $0xf05a1e04,%edx
f0105316:	89 02                	mov    %eax,(%edx)
f0105318:	8b 45 08             	mov    0x8(%ebp),%eax
f010531b:	8b 40 0c             	mov    0xc(%eax),%eax
f010531e:	85 c0                	test   %eax,%eax
f0105320:	74 11                	je     f0105333 <sched_remove_ready+0x101>
f0105322:	8b 45 08             	mov    0x8(%ebp),%eax
f0105325:	8b 40 0c             	mov    0xc(%eax),%eax
f0105328:	8b 55 08             	mov    0x8(%ebp),%edx
f010532b:	8b 52 08             	mov    0x8(%edx),%edx
f010532e:	89 50 08             	mov    %edx,0x8(%eax)
f0105331:	eb 17                	jmp    f010534a <sched_remove_ready+0x118>
f0105333:	8b 45 08             	mov    0x8(%ebp),%eax
f0105336:	8b 40 08             	mov    0x8(%eax),%eax
f0105339:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010533c:	83 c2 09             	add    $0x9,%edx
f010533f:	c1 e2 04             	shl    $0x4,%edx
f0105342:	81 c2 00 1e 5a f0    	add    $0xf05a1e00,%edx
f0105348:	89 02                	mov    %eax,(%edx)
f010534a:	8b 45 08             	mov    0x8(%ebp),%eax
f010534d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105354:	8b 45 08             	mov    0x8(%ebp),%eax
f0105357:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010535e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105361:	83 c0 09             	add    $0x9,%eax
f0105364:	c1 e0 04             	shl    $0x4,%eax
f0105367:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f010536c:	8b 00                	mov    (%eax),%eax
f010536e:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105371:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105374:	83 c0 09             	add    $0x9,%eax
f0105377:	c1 e0 04             	shl    $0x4,%eax
f010537a:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f010537f:	89 10                	mov    %edx,(%eax)
				env->env_status = ENV_UNKNOWN;
f0105381:	8b 45 08             	mov    0x8(%ebp),%eax
f0105384:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f010538b:	eb 14                	jmp    f01053a1 <sched_remove_ready+0x16f>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010538d:	ff 45 f4             	incl   -0xc(%ebp)
f0105390:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f0105395:	0f b6 c0             	movzbl %al,%eax
f0105398:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010539b:	0f 8f f8 fe ff ff    	jg     f0105299 <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01053a1:	c9                   	leave  
f01053a2:	c3                   	ret    

f01053a3 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01053a3:	55                   	push   %ebp
f01053a4:	89 e5                	mov    %esp,%ebp
f01053a6:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01053a9:	83 ec 0c             	sub    $0xc,%esp
f01053ac:	68 00 1e 5a f0       	push   $0xf05a1e00
f01053b1:	e8 58 99 00 00       	call   f010ed0e <holding_spinlock>
f01053b6:	83 c4 10             	add    $0x10,%esp
f01053b9:	85 c0                	test   %eax,%eax
f01053bb:	75 17                	jne    f01053d4 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01053bd:	83 ec 04             	sub    $0x4,%esp
f01053c0:	68 b8 73 12 f0       	push   $0xf01273b8
f01053c5:	68 b0 00 00 00       	push   $0xb0
f01053ca:	68 5b 73 12 f0       	push   $0xf012735b
f01053cf:	e8 46 af ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01053d4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01053d8:	75 19                	jne    f01053f3 <sched_insert_new+0x50>
f01053da:	68 f9 73 12 f0       	push   $0xf01273f9
f01053df:	68 46 73 12 f0       	push   $0xf0127346
f01053e4:	68 b3 00 00 00       	push   $0xb3
f01053e9:	68 5b 73 12 f0       	push   $0xf012735b
f01053ee:	e8 27 af ff ff       	call   f010031a <_panic>
	{
		env->env_status = ENV_NEW ;
f01053f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f6:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f01053fd:	83 ec 08             	sub    $0x8,%esp
f0105400:	ff 75 08             	pushl  0x8(%ebp)
f0105403:	68 70 1e 5a f0       	push   $0xf05a1e70
f0105408:	e8 40 fb ff ff       	call   f0104f4d <enqueue>
f010540d:	83 c4 10             	add    $0x10,%esp
	}
}
f0105410:	90                   	nop
f0105411:	c9                   	leave  
f0105412:	c3                   	ret    

f0105413 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f0105413:	55                   	push   %ebp
f0105414:	89 e5                	mov    %esp,%ebp
f0105416:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105419:	83 ec 0c             	sub    $0xc,%esp
f010541c:	68 00 1e 5a f0       	push   $0xf05a1e00
f0105421:	e8 e8 98 00 00       	call   f010ed0e <holding_spinlock>
f0105426:	83 c4 10             	add    $0x10,%esp
f0105429:	85 c0                	test   %eax,%eax
f010542b:	75 17                	jne    f0105444 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010542d:	83 ec 04             	sub    $0x4,%esp
f0105430:	68 b8 73 12 f0       	push   $0xf01273b8
f0105435:	68 c1 00 00 00       	push   $0xc1
f010543a:	68 5b 73 12 f0       	push   $0xf012735b
f010543f:	e8 d6 ae ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0105444:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105448:	74 0b                	je     f0105455 <sched_remove_new+0x42>
f010544a:	8b 45 08             	mov    0x8(%ebp),%eax
f010544d:	8b 40 18             	mov    0x18(%eax),%eax
f0105450:	83 f8 04             	cmp    $0x4,%eax
f0105453:	74 19                	je     f010546e <sched_remove_new+0x5b>
f0105455:	68 34 74 12 f0       	push   $0xf0127434
f010545a:	68 46 73 12 f0       	push   $0xf0127346
f010545f:	68 c4 00 00 00       	push   $0xc4
f0105464:	68 5b 73 12 f0       	push   $0xf012735b
f0105469:	e8 ac ae ff ff       	call   f010031a <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f010546e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105472:	75 17                	jne    f010548b <sched_remove_new+0x78>
f0105474:	83 ec 04             	sub    $0x4,%esp
f0105477:	68 97 73 12 f0       	push   $0xf0127397
f010547c:	68 c6 00 00 00       	push   $0xc6
f0105481:	68 5b 73 12 f0       	push   $0xf012735b
f0105486:	e8 8f ae ff ff       	call   f010031a <_panic>
f010548b:	8b 45 08             	mov    0x8(%ebp),%eax
f010548e:	8b 40 08             	mov    0x8(%eax),%eax
f0105491:	85 c0                	test   %eax,%eax
f0105493:	74 11                	je     f01054a6 <sched_remove_new+0x93>
f0105495:	8b 45 08             	mov    0x8(%ebp),%eax
f0105498:	8b 40 08             	mov    0x8(%eax),%eax
f010549b:	8b 55 08             	mov    0x8(%ebp),%edx
f010549e:	8b 52 0c             	mov    0xc(%edx),%edx
f01054a1:	89 50 0c             	mov    %edx,0xc(%eax)
f01054a4:	eb 0b                	jmp    f01054b1 <sched_remove_new+0x9e>
f01054a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01054a9:	8b 40 0c             	mov    0xc(%eax),%eax
f01054ac:	a3 74 1e 5a f0       	mov    %eax,0xf05a1e74
f01054b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01054b4:	8b 40 0c             	mov    0xc(%eax),%eax
f01054b7:	85 c0                	test   %eax,%eax
f01054b9:	74 11                	je     f01054cc <sched_remove_new+0xb9>
f01054bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01054be:	8b 40 0c             	mov    0xc(%eax),%eax
f01054c1:	8b 55 08             	mov    0x8(%ebp),%edx
f01054c4:	8b 52 08             	mov    0x8(%edx),%edx
f01054c7:	89 50 08             	mov    %edx,0x8(%eax)
f01054ca:	eb 0b                	jmp    f01054d7 <sched_remove_new+0xc4>
f01054cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01054cf:	8b 40 08             	mov    0x8(%eax),%eax
f01054d2:	a3 70 1e 5a f0       	mov    %eax,0xf05a1e70
f01054d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01054da:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01054e1:	8b 45 08             	mov    0x8(%ebp),%eax
f01054e4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01054eb:	a1 7c 1e 5a f0       	mov    0xf05a1e7c,%eax
f01054f0:	48                   	dec    %eax
f01054f1:	a3 7c 1e 5a f0       	mov    %eax,0xf05a1e7c
		env->env_status = ENV_UNKNOWN;
f01054f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01054f9:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105500:	90                   	nop
f0105501:	c9                   	leave  
f0105502:	c3                   	ret    

f0105503 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f0105503:	55                   	push   %ebp
f0105504:	89 e5                	mov    %esp,%ebp
f0105506:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105509:	83 ec 0c             	sub    $0xc,%esp
f010550c:	68 00 1e 5a f0       	push   $0xf05a1e00
f0105511:	e8 f8 97 00 00       	call   f010ed0e <holding_spinlock>
f0105516:	83 c4 10             	add    $0x10,%esp
f0105519:	85 c0                	test   %eax,%eax
f010551b:	75 17                	jne    f0105534 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010551d:	83 ec 04             	sub    $0x4,%esp
f0105520:	68 b8 73 12 f0       	push   $0xf01273b8
f0105525:	68 d2 00 00 00       	push   $0xd2
f010552a:	68 5b 73 12 f0       	push   $0xf012735b
f010552f:	e8 e6 ad ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105534:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105538:	75 19                	jne    f0105553 <sched_insert_exit+0x50>
f010553a:	68 f9 73 12 f0       	push   $0xf01273f9
f010553f:	68 46 73 12 f0       	push   $0xf0127346
f0105544:	68 d5 00 00 00       	push   $0xd5
f0105549:	68 5b 73 12 f0       	push   $0xf012735b
f010554e:	e8 c7 ad ff ff       	call   f010031a <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f0105553:	e8 4f 92 00 00       	call   f010e7a7 <isBufferingEnabled>
f0105558:	84 c0                	test   %al,%al
f010555a:	74 0e                	je     f010556a <sched_insert_exit+0x67>
f010555c:	83 ec 0c             	sub    $0xc,%esp
f010555f:	ff 75 08             	pushl  0x8(%ebp)
f0105562:	e8 ef 67 00 00       	call   f010bd56 <cleanup_buffers>
f0105567:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f010556a:	8b 45 08             	mov    0x8(%ebp),%eax
f010556d:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105574:	83 ec 08             	sub    $0x8,%esp
f0105577:	ff 75 08             	pushl  0x8(%ebp)
f010557a:	68 80 1e 5a f0       	push   $0xf05a1e80
f010557f:	e8 c9 f9 ff ff       	call   f0104f4d <enqueue>
f0105584:	83 c4 10             	add    $0x10,%esp
	}
}
f0105587:	90                   	nop
f0105588:	c9                   	leave  
f0105589:	c3                   	ret    

f010558a <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f010558a:	55                   	push   %ebp
f010558b:	89 e5                	mov    %esp,%ebp
f010558d:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105590:	83 ec 0c             	sub    $0xc,%esp
f0105593:	68 00 1e 5a f0       	push   $0xf05a1e00
f0105598:	e8 71 97 00 00       	call   f010ed0e <holding_spinlock>
f010559d:	83 c4 10             	add    $0x10,%esp
f01055a0:	85 c0                	test   %eax,%eax
f01055a2:	75 17                	jne    f01055bb <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01055a4:	83 ec 04             	sub    $0x4,%esp
f01055a7:	68 b8 73 12 f0       	push   $0xf01273b8
f01055ac:	68 e3 00 00 00       	push   $0xe3
f01055b1:	68 5b 73 12 f0       	push   $0xf012735b
f01055b6:	e8 5f ad ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01055bb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055bf:	74 0b                	je     f01055cc <sched_remove_exit+0x42>
f01055c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01055c4:	8b 40 18             	mov    0x18(%eax),%eax
f01055c7:	83 f8 05             	cmp    $0x5,%eax
f01055ca:	74 19                	je     f01055e5 <sched_remove_exit+0x5b>
f01055cc:	68 60 74 12 f0       	push   $0xf0127460
f01055d1:	68 46 73 12 f0       	push   $0xf0127346
f01055d6:	68 e6 00 00 00       	push   $0xe6
f01055db:	68 5b 73 12 f0       	push   $0xf012735b
f01055e0:	e8 35 ad ff ff       	call   f010031a <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f01055e5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055e9:	75 17                	jne    f0105602 <sched_remove_exit+0x78>
f01055eb:	83 ec 04             	sub    $0x4,%esp
f01055ee:	68 97 73 12 f0       	push   $0xf0127397
f01055f3:	68 e8 00 00 00       	push   $0xe8
f01055f8:	68 5b 73 12 f0       	push   $0xf012735b
f01055fd:	e8 18 ad ff ff       	call   f010031a <_panic>
f0105602:	8b 45 08             	mov    0x8(%ebp),%eax
f0105605:	8b 40 08             	mov    0x8(%eax),%eax
f0105608:	85 c0                	test   %eax,%eax
f010560a:	74 11                	je     f010561d <sched_remove_exit+0x93>
f010560c:	8b 45 08             	mov    0x8(%ebp),%eax
f010560f:	8b 40 08             	mov    0x8(%eax),%eax
f0105612:	8b 55 08             	mov    0x8(%ebp),%edx
f0105615:	8b 52 0c             	mov    0xc(%edx),%edx
f0105618:	89 50 0c             	mov    %edx,0xc(%eax)
f010561b:	eb 0b                	jmp    f0105628 <sched_remove_exit+0x9e>
f010561d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105620:	8b 40 0c             	mov    0xc(%eax),%eax
f0105623:	a3 84 1e 5a f0       	mov    %eax,0xf05a1e84
f0105628:	8b 45 08             	mov    0x8(%ebp),%eax
f010562b:	8b 40 0c             	mov    0xc(%eax),%eax
f010562e:	85 c0                	test   %eax,%eax
f0105630:	74 11                	je     f0105643 <sched_remove_exit+0xb9>
f0105632:	8b 45 08             	mov    0x8(%ebp),%eax
f0105635:	8b 40 0c             	mov    0xc(%eax),%eax
f0105638:	8b 55 08             	mov    0x8(%ebp),%edx
f010563b:	8b 52 08             	mov    0x8(%edx),%edx
f010563e:	89 50 08             	mov    %edx,0x8(%eax)
f0105641:	eb 0b                	jmp    f010564e <sched_remove_exit+0xc4>
f0105643:	8b 45 08             	mov    0x8(%ebp),%eax
f0105646:	8b 40 08             	mov    0x8(%eax),%eax
f0105649:	a3 80 1e 5a f0       	mov    %eax,0xf05a1e80
f010564e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105651:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105658:	8b 45 08             	mov    0x8(%ebp),%eax
f010565b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105662:	a1 8c 1e 5a f0       	mov    0xf05a1e8c,%eax
f0105667:	48                   	dec    %eax
f0105668:	a3 8c 1e 5a f0       	mov    %eax,0xf05a1e8c
		env->env_status = ENV_UNKNOWN;
f010566d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105670:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105677:	90                   	nop
f0105678:	c9                   	leave  
f0105679:	c3                   	ret    

f010567a <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f010567a:	55                   	push   %ebp
f010567b:	89 e5                	mov    %esp,%ebp
f010567d:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105680:	83 ec 0c             	sub    $0xc,%esp
f0105683:	68 00 1e 5a f0       	push   $0xf05a1e00
f0105688:	e8 68 94 00 00       	call   f010eaf5 <acquire_spinlock>
f010568d:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f0105690:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105694:	75 19                	jne    f01056af <sched_new_env+0x35>
f0105696:	68 8b 74 12 f0       	push   $0xf012748b
f010569b:	68 46 73 12 f0       	push   $0xf0127346
f01056a0:	68 f6 00 00 00       	push   $0xf6
f01056a5:	68 5b 73 12 f0       	push   $0xf012735b
f01056aa:	e8 6b ac ff ff       	call   f010031a <_panic>
	{
		sched_insert_new(e);
f01056af:	83 ec 0c             	sub    $0xc,%esp
f01056b2:	ff 75 08             	pushl  0x8(%ebp)
f01056b5:	e8 e9 fc ff ff       	call   f01053a3 <sched_insert_new>
f01056ba:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01056bd:	83 ec 0c             	sub    $0xc,%esp
f01056c0:	68 00 1e 5a f0       	push   $0xf05a1e00
f01056c5:	e8 b2 94 00 00       	call   f010eb7c <release_spinlock>
f01056ca:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01056cd:	90                   	nop
f01056ce:	c9                   	leave  
f01056cf:	c3                   	ret    

f01056d0 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f01056d0:	55                   	push   %ebp
f01056d1:	89 e5                	mov    %esp,%ebp
f01056d3:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01056d6:	83 ec 0c             	sub    $0xc,%esp
f01056d9:	68 00 1e 5a f0       	push   $0xf05a1e00
f01056de:	e8 12 94 00 00       	call   f010eaf5 <acquire_spinlock>
f01056e3:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01056e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01056ed:	a1 70 1e 5a f0       	mov    0xf05a1e70,%eax
f01056f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01056f5:	eb 53                	jmp    f010574a <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f01056f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01056fa:	8b 40 10             	mov    0x10(%eax),%eax
f01056fd:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105700:	75 40                	jne    f0105742 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f0105702:	83 ec 0c             	sub    $0xc,%esp
f0105705:	ff 75 f4             	pushl  -0xc(%ebp)
f0105708:	e8 06 fd ff ff       	call   f0105413 <sched_remove_new>
f010570d:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f0105710:	83 ec 0c             	sub    $0xc,%esp
f0105713:	ff 75 f4             	pushl  -0xc(%ebp)
f0105716:	e8 a7 fa ff ff       	call   f01051c2 <sched_insert_ready0>
f010571b:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f010571e:	e8 af 19 00 00       	call   f01070d2 <mycpu>
f0105723:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105729:	85 c0                	test   %eax,%eax
f010572b:	75 46                	jne    f0105773 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010572d:	83 ec 0c             	sub    $0xc,%esp
f0105730:	68 00 1e 5a f0       	push   $0xf05a1e00
f0105735:	e8 42 94 00 00       	call   f010eb7c <release_spinlock>
f010573a:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f010573d:	e8 45 10 00 00       	call   f0106787 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105742:	a1 78 1e 5a f0       	mov    0xf05a1e78,%eax
f0105747:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010574a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010574e:	74 08                	je     f0105758 <sched_run_env+0x88>
f0105750:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105753:	8b 40 08             	mov    0x8(%eax),%eax
f0105756:	eb 05                	jmp    f010575d <sched_run_env+0x8d>
f0105758:	b8 00 00 00 00       	mov    $0x0,%eax
f010575d:	a3 78 1e 5a f0       	mov    %eax,0xf05a1e78
f0105762:	a1 78 1e 5a f0       	mov    0xf05a1e78,%eax
f0105767:	85 c0                	test   %eax,%eax
f0105769:	75 8c                	jne    f01056f7 <sched_run_env+0x27>
f010576b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010576f:	75 86                	jne    f01056f7 <sched_run_env+0x27>
f0105771:	eb 01                	jmp    f0105774 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105773:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105774:	83 ec 0c             	sub    $0xc,%esp
f0105777:	68 00 1e 5a f0       	push   $0xf05a1e00
f010577c:	e8 fb 93 00 00       	call   f010eb7c <release_spinlock>
f0105781:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105784:	90                   	nop
f0105785:	c9                   	leave  
f0105786:	c3                   	ret    

f0105787 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105787:	55                   	push   %ebp
f0105788:	89 e5                	mov    %esp,%ebp
f010578a:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f010578d:	83 ec 0c             	sub    $0xc,%esp
f0105790:	68 00 1e 5a f0       	push   $0xf05a1e00
f0105795:	e8 74 95 00 00       	call   f010ed0e <holding_spinlock>
f010579a:	83 c4 10             	add    $0x10,%esp
f010579d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f01057a0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01057a4:	75 10                	jne    f01057b6 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f01057a6:	83 ec 0c             	sub    $0xc,%esp
f01057a9:	68 00 1e 5a f0       	push   $0xf05a1e00
f01057ae:	e8 42 93 00 00       	call   f010eaf5 <acquire_spinlock>
f01057b3:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f01057b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f01057bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f01057c4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01057c8:	75 59                	jne    f0105823 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057ca:	a1 70 1e 5a f0       	mov    0xf05a1e70,%eax
f01057cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057d2:	eb 28                	jmp    f01057fc <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f01057d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057d7:	8b 40 10             	mov    0x10(%eax),%eax
f01057da:	3b 45 08             	cmp    0x8(%ebp),%eax
f01057dd:	75 15                	jne    f01057f4 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f01057df:	83 ec 0c             	sub    $0xc,%esp
f01057e2:	ff 75 f4             	pushl  -0xc(%ebp)
f01057e5:	e8 29 fc ff ff       	call   f0105413 <sched_remove_new>
f01057ea:	83 c4 10             	add    $0x10,%esp
				found = 1;
f01057ed:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057f4:	a1 78 1e 5a f0       	mov    0xf05a1e78,%eax
f01057f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057fc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105800:	74 08                	je     f010580a <sched_exit_env+0x83>
f0105802:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105805:	8b 40 08             	mov    0x8(%eax),%eax
f0105808:	eb 05                	jmp    f010580f <sched_exit_env+0x88>
f010580a:	b8 00 00 00 00       	mov    $0x0,%eax
f010580f:	a3 78 1e 5a f0       	mov    %eax,0xf05a1e78
f0105814:	a1 78 1e 5a f0       	mov    0xf05a1e78,%eax
f0105819:	85 c0                	test   %eax,%eax
f010581b:	75 b7                	jne    f01057d4 <sched_exit_env+0x4d>
f010581d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105821:	75 b1                	jne    f01057d4 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f0105823:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105827:	0f 85 89 01 00 00    	jne    f01059b6 <sched_exit_env+0x22f>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010582d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105834:	e9 69 01 00 00       	jmp    f01059a2 <sched_exit_env+0x21b>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105839:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010583c:	83 c0 09             	add    $0x9,%eax
f010583f:	c1 e0 04             	shl    $0x4,%eax
f0105842:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f0105847:	8b 00                	mov    (%eax),%eax
f0105849:	85 c0                	test   %eax,%eax
f010584b:	0f 84 48 01 00 00    	je     f0105999 <sched_exit_env+0x212>
			{
				ptr_env=NULL;
f0105851:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105858:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010585b:	83 c0 09             	add    $0x9,%eax
f010585e:	c1 e0 04             	shl    $0x4,%eax
f0105861:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f0105866:	8b 00                	mov    (%eax),%eax
f0105868:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010586b:	e9 e3 00 00 00       	jmp    f0105953 <sched_exit_env+0x1cc>
				{
					if(ptr_env->env_id == envId)
f0105870:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105873:	8b 40 10             	mov    0x10(%eax),%eax
f0105876:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105879:	0f 85 c1 00 00 00    	jne    f0105940 <sched_exit_env+0x1b9>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010587f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105883:	75 17                	jne    f010589c <sched_exit_env+0x115>
f0105885:	83 ec 04             	sub    $0x4,%esp
f0105888:	68 97 73 12 f0       	push   $0xf0127397
f010588d:	68 44 01 00 00       	push   $0x144
f0105892:	68 5b 73 12 f0       	push   $0xf012735b
f0105897:	e8 7e aa ff ff       	call   f010031a <_panic>
f010589c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010589f:	8b 40 08             	mov    0x8(%eax),%eax
f01058a2:	85 c0                	test   %eax,%eax
f01058a4:	74 11                	je     f01058b7 <sched_exit_env+0x130>
f01058a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058a9:	8b 40 08             	mov    0x8(%eax),%eax
f01058ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058af:	8b 52 0c             	mov    0xc(%edx),%edx
f01058b2:	89 50 0c             	mov    %edx,0xc(%eax)
f01058b5:	eb 17                	jmp    f01058ce <sched_exit_env+0x147>
f01058b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058ba:	8b 40 0c             	mov    0xc(%eax),%eax
f01058bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058c0:	83 c2 09             	add    $0x9,%edx
f01058c3:	c1 e2 04             	shl    $0x4,%edx
f01058c6:	81 c2 04 1e 5a f0    	add    $0xf05a1e04,%edx
f01058cc:	89 02                	mov    %eax,(%edx)
f01058ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058d1:	8b 40 0c             	mov    0xc(%eax),%eax
f01058d4:	85 c0                	test   %eax,%eax
f01058d6:	74 11                	je     f01058e9 <sched_exit_env+0x162>
f01058d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058db:	8b 40 0c             	mov    0xc(%eax),%eax
f01058de:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058e1:	8b 52 08             	mov    0x8(%edx),%edx
f01058e4:	89 50 08             	mov    %edx,0x8(%eax)
f01058e7:	eb 17                	jmp    f0105900 <sched_exit_env+0x179>
f01058e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058ec:	8b 40 08             	mov    0x8(%eax),%eax
f01058ef:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058f2:	83 c2 09             	add    $0x9,%edx
f01058f5:	c1 e2 04             	shl    $0x4,%edx
f01058f8:	81 c2 00 1e 5a f0    	add    $0xf05a1e00,%edx
f01058fe:	89 02                	mov    %eax,(%edx)
f0105900:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105903:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010590a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010590d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105914:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105917:	83 c0 09             	add    $0x9,%eax
f010591a:	c1 e0 04             	shl    $0x4,%eax
f010591d:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f0105922:	8b 00                	mov    (%eax),%eax
f0105924:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105927:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010592a:	83 c0 09             	add    $0x9,%eax
f010592d:	c1 e0 04             	shl    $0x4,%eax
f0105930:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f0105935:	89 10                	mov    %edx,(%eax)
						found = 1;
f0105937:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f010593e:	eb 59                	jmp    f0105999 <sched_exit_env+0x212>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105940:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105943:	83 c0 09             	add    $0x9,%eax
f0105946:	c1 e0 04             	shl    $0x4,%eax
f0105949:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f010594e:	8b 00                	mov    (%eax),%eax
f0105950:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105953:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105957:	74 08                	je     f0105961 <sched_exit_env+0x1da>
f0105959:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010595c:	8b 40 08             	mov    0x8(%eax),%eax
f010595f:	eb 05                	jmp    f0105966 <sched_exit_env+0x1df>
f0105961:	b8 00 00 00 00       	mov    $0x0,%eax
f0105966:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105969:	83 c2 09             	add    $0x9,%edx
f010596c:	c1 e2 04             	shl    $0x4,%edx
f010596f:	81 c2 08 1e 5a f0    	add    $0xf05a1e08,%edx
f0105975:	89 02                	mov    %eax,(%edx)
f0105977:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010597a:	83 c0 09             	add    $0x9,%eax
f010597d:	c1 e0 04             	shl    $0x4,%eax
f0105980:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f0105985:	8b 00                	mov    (%eax),%eax
f0105987:	85 c0                	test   %eax,%eax
f0105989:	0f 85 e1 fe ff ff    	jne    f0105870 <sched_exit_env+0xe9>
f010598f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105993:	0f 85 d7 fe ff ff    	jne    f0105870 <sched_exit_env+0xe9>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105999:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010599d:	75 16                	jne    f01059b5 <sched_exit_env+0x22e>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010599f:	ff 45 ec             	incl   -0x14(%ebp)
f01059a2:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f01059a7:	0f b6 c0             	movzbl %al,%eax
f01059aa:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01059ad:	0f 8f 86 fe ff ff    	jg     f0105839 <sched_exit_env+0xb2>
f01059b3:	eb 01                	jmp    f01059b6 <sched_exit_env+0x22f>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01059b5:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f01059b6:	e8 8a 4d 00 00       	call   f010a745 <get_cpu_proc>
f01059bb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01059be:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01059c2:	75 19                	jne    f01059dd <sched_exit_env+0x256>
f01059c4:	68 93 74 12 f0       	push   $0xf0127493
f01059c9:	68 46 73 12 f0       	push   $0xf0127346
f01059ce:	68 4e 01 00 00       	push   $0x14e
f01059d3:	68 5b 73 12 f0       	push   $0xf012735b
f01059d8:	e8 3d a9 ff ff       	call   f010031a <_panic>
	if (!found)
f01059dd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01059e1:	75 18                	jne    f01059fb <sched_exit_env+0x274>
	{
		if (cur_env->env_id == envId)
f01059e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01059e6:	8b 40 10             	mov    0x10(%eax),%eax
f01059e9:	3b 45 08             	cmp    0x8(%ebp),%eax
f01059ec:	75 0d                	jne    f01059fb <sched_exit_env+0x274>
		{
			ptr_env = cur_env;
f01059ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01059f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f01059f4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f01059fb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01059ff:	74 1e                	je     f0105a1f <sched_exit_env+0x298>
	{
		sched_insert_exit(ptr_env);
f0105a01:	83 ec 0c             	sub    $0xc,%esp
f0105a04:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a07:	e8 f7 fa ff ff       	call   f0105503 <sched_insert_exit>
f0105a0c:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105a0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a12:	8b 40 10             	mov    0x10(%eax),%eax
f0105a15:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a18:	75 05                	jne    f0105a1f <sched_exit_env+0x298>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105a1a:	e8 b3 4e 00 00       	call   f010a8d2 <sched>
		}
	}
	if (!lock_already_held)
f0105a1f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105a23:	75 10                	jne    f0105a35 <sched_exit_env+0x2ae>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105a25:	83 ec 0c             	sub    $0xc,%esp
f0105a28:	68 00 1e 5a f0       	push   $0xf05a1e00
f0105a2d:	e8 4a 91 00 00       	call   f010eb7c <release_spinlock>
f0105a32:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105a35:	90                   	nop
f0105a36:	c9                   	leave  
f0105a37:	c3                   	ret    

f0105a38 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105a38:	55                   	push   %ebp
f0105a39:	89 e5                	mov    %esp,%ebp
f0105a3b:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a3e:	83 ec 0c             	sub    $0xc,%esp
f0105a41:	68 00 1e 5a f0       	push   $0xf05a1e00
f0105a46:	e8 aa 90 00 00       	call   f010eaf5 <acquire_spinlock>
f0105a4b:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105a4e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105a55:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105a5c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a60:	75 79                	jne    f0105adb <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105a62:	a1 70 1e 5a f0       	mov    0xf05a1e70,%eax
f0105a67:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a6a:	eb 48                	jmp    f0105ab4 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105a6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a6f:	8b 40 10             	mov    0x10(%eax),%eax
f0105a72:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a75:	75 35                	jne    f0105aac <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105a77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a7a:	8d 50 20             	lea    0x20(%eax),%edx
f0105a7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a80:	8b 40 10             	mov    0x10(%eax),%eax
f0105a83:	83 ec 04             	sub    $0x4,%esp
f0105a86:	52                   	push   %edx
f0105a87:	50                   	push   %eax
f0105a88:	68 a4 74 12 f0       	push   $0xf01274a4
f0105a8d:	e8 da b4 ff ff       	call   f0100f6c <cprintf>
f0105a92:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105a95:	83 ec 0c             	sub    $0xc,%esp
f0105a98:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a9b:	e8 73 f9 ff ff       	call   f0105413 <sched_remove_new>
f0105aa0:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105aa3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105aaa:	eb 2f                	jmp    f0105adb <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105aac:	a1 78 1e 5a f0       	mov    0xf05a1e78,%eax
f0105ab1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ab4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ab8:	74 08                	je     f0105ac2 <sched_kill_env+0x8a>
f0105aba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105abd:	8b 40 08             	mov    0x8(%eax),%eax
f0105ac0:	eb 05                	jmp    f0105ac7 <sched_kill_env+0x8f>
f0105ac2:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ac7:	a3 78 1e 5a f0       	mov    %eax,0xf05a1e78
f0105acc:	a1 78 1e 5a f0       	mov    0xf05a1e78,%eax
f0105ad1:	85 c0                	test   %eax,%eax
f0105ad3:	75 97                	jne    f0105a6c <sched_kill_env+0x34>
f0105ad5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ad9:	75 91                	jne    f0105a6c <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105adb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105adf:	0f 85 a7 01 00 00    	jne    f0105c8c <sched_kill_env+0x254>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105ae5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105aec:	e9 87 01 00 00       	jmp    f0105c78 <sched_kill_env+0x240>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105af1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105af4:	83 c0 09             	add    $0x9,%eax
f0105af7:	c1 e0 04             	shl    $0x4,%eax
f0105afa:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f0105aff:	8b 00                	mov    (%eax),%eax
f0105b01:	85 c0                	test   %eax,%eax
f0105b03:	0f 84 66 01 00 00    	je     f0105c6f <sched_kill_env+0x237>
			{
				ptr_env=NULL;
f0105b09:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b10:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105b13:	83 c0 09             	add    $0x9,%eax
f0105b16:	c1 e0 04             	shl    $0x4,%eax
f0105b19:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f0105b1e:	8b 00                	mov    (%eax),%eax
f0105b20:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b23:	e9 01 01 00 00       	jmp    f0105c29 <sched_kill_env+0x1f1>
				{
					if(ptr_env->env_id == envId)
f0105b28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b2b:	8b 40 10             	mov    0x10(%eax),%eax
f0105b2e:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105b31:	0f 85 df 00 00 00    	jne    f0105c16 <sched_kill_env+0x1de>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105b37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b3a:	8d 50 20             	lea    0x20(%eax),%edx
f0105b3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b40:	8b 40 10             	mov    0x10(%eax),%eax
f0105b43:	ff 75 ec             	pushl  -0x14(%ebp)
f0105b46:	52                   	push   %edx
f0105b47:	50                   	push   %eax
f0105b48:	68 cc 74 12 f0       	push   $0xf01274cc
f0105b4d:	e8 1a b4 ff ff       	call   f0100f6c <cprintf>
f0105b52:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105b55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b59:	75 17                	jne    f0105b72 <sched_kill_env+0x13a>
f0105b5b:	83 ec 04             	sub    $0x4,%esp
f0105b5e:	68 97 73 12 f0       	push   $0xf0127397
f0105b63:	68 91 01 00 00       	push   $0x191
f0105b68:	68 5b 73 12 f0       	push   $0xf012735b
f0105b6d:	e8 a8 a7 ff ff       	call   f010031a <_panic>
f0105b72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b75:	8b 40 08             	mov    0x8(%eax),%eax
f0105b78:	85 c0                	test   %eax,%eax
f0105b7a:	74 11                	je     f0105b8d <sched_kill_env+0x155>
f0105b7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b7f:	8b 40 08             	mov    0x8(%eax),%eax
f0105b82:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105b85:	8b 52 0c             	mov    0xc(%edx),%edx
f0105b88:	89 50 0c             	mov    %edx,0xc(%eax)
f0105b8b:	eb 17                	jmp    f0105ba4 <sched_kill_env+0x16c>
f0105b8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b90:	8b 40 0c             	mov    0xc(%eax),%eax
f0105b93:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b96:	83 c2 09             	add    $0x9,%edx
f0105b99:	c1 e2 04             	shl    $0x4,%edx
f0105b9c:	81 c2 04 1e 5a f0    	add    $0xf05a1e04,%edx
f0105ba2:	89 02                	mov    %eax,(%edx)
f0105ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba7:	8b 40 0c             	mov    0xc(%eax),%eax
f0105baa:	85 c0                	test   %eax,%eax
f0105bac:	74 11                	je     f0105bbf <sched_kill_env+0x187>
f0105bae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb1:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bb4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105bb7:	8b 52 08             	mov    0x8(%edx),%edx
f0105bba:	89 50 08             	mov    %edx,0x8(%eax)
f0105bbd:	eb 17                	jmp    f0105bd6 <sched_kill_env+0x19e>
f0105bbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bc2:	8b 40 08             	mov    0x8(%eax),%eax
f0105bc5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bc8:	83 c2 09             	add    $0x9,%edx
f0105bcb:	c1 e2 04             	shl    $0x4,%edx
f0105bce:	81 c2 00 1e 5a f0    	add    $0xf05a1e00,%edx
f0105bd4:	89 02                	mov    %eax,(%edx)
f0105bd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bd9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105be0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105be3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105bea:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105bed:	83 c0 09             	add    $0x9,%eax
f0105bf0:	c1 e0 04             	shl    $0x4,%eax
f0105bf3:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f0105bf8:	8b 00                	mov    (%eax),%eax
f0105bfa:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105bfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105c00:	83 c0 09             	add    $0x9,%eax
f0105c03:	c1 e0 04             	shl    $0x4,%eax
f0105c06:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f0105c0b:	89 10                	mov    %edx,(%eax)
						found = 1;
f0105c0d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c14:	eb 59                	jmp    f0105c6f <sched_kill_env+0x237>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c16:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105c19:	83 c0 09             	add    $0x9,%eax
f0105c1c:	c1 e0 04             	shl    $0x4,%eax
f0105c1f:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f0105c24:	8b 00                	mov    (%eax),%eax
f0105c26:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c29:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c2d:	74 08                	je     f0105c37 <sched_kill_env+0x1ff>
f0105c2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c32:	8b 40 08             	mov    0x8(%eax),%eax
f0105c35:	eb 05                	jmp    f0105c3c <sched_kill_env+0x204>
f0105c37:	b8 00 00 00 00       	mov    $0x0,%eax
f0105c3c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c3f:	83 c2 09             	add    $0x9,%edx
f0105c42:	c1 e2 04             	shl    $0x4,%edx
f0105c45:	81 c2 08 1e 5a f0    	add    $0xf05a1e08,%edx
f0105c4b:	89 02                	mov    %eax,(%edx)
f0105c4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105c50:	83 c0 09             	add    $0x9,%eax
f0105c53:	c1 e0 04             	shl    $0x4,%eax
f0105c56:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f0105c5b:	8b 00                	mov    (%eax),%eax
f0105c5d:	85 c0                	test   %eax,%eax
f0105c5f:	0f 85 c3 fe ff ff    	jne    f0105b28 <sched_kill_env+0xf0>
f0105c65:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c69:	0f 85 b9 fe ff ff    	jne    f0105b28 <sched_kill_env+0xf0>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105c6f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105c73:	75 16                	jne    f0105c8b <sched_kill_env+0x253>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105c75:	ff 45 ec             	incl   -0x14(%ebp)
f0105c78:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f0105c7d:	0f b6 c0             	movzbl %al,%eax
f0105c80:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105c83:	0f 8f 68 fe ff ff    	jg     f0105af1 <sched_kill_env+0xb9>
f0105c89:	eb 01                	jmp    f0105c8c <sched_kill_env+0x254>
						break;
					}
				}
			}
			if (found)
				break;
f0105c8b:	90                   	nop
		}
	}
	if (!found)
f0105c8c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105c90:	0f 85 80 00 00 00    	jne    f0105d16 <sched_kill_env+0x2de>
	{
		ptr_env=NULL;
f0105c96:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105c9d:	a1 80 1e 5a f0       	mov    0xf05a1e80,%eax
f0105ca2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ca5:	eb 48                	jmp    f0105cef <sched_kill_env+0x2b7>
		{
			if(ptr_env->env_id == envId)
f0105ca7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105caa:	8b 40 10             	mov    0x10(%eax),%eax
f0105cad:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105cb0:	75 35                	jne    f0105ce7 <sched_kill_env+0x2af>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105cb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105cb5:	8d 50 20             	lea    0x20(%eax),%edx
f0105cb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105cbb:	8b 40 10             	mov    0x10(%eax),%eax
f0105cbe:	83 ec 04             	sub    $0x4,%esp
f0105cc1:	52                   	push   %edx
f0105cc2:	50                   	push   %eax
f0105cc3:	68 f8 74 12 f0       	push   $0xf01274f8
f0105cc8:	e8 9f b2 ff ff       	call   f0100f6c <cprintf>
f0105ccd:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105cd0:	83 ec 0c             	sub    $0xc,%esp
f0105cd3:	ff 75 f4             	pushl  -0xc(%ebp)
f0105cd6:	e8 af f8 ff ff       	call   f010558a <sched_remove_exit>
f0105cdb:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105cde:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105ce5:	eb 2f                	jmp    f0105d16 <sched_kill_env+0x2de>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105ce7:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f0105cec:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105cef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105cf3:	74 08                	je     f0105cfd <sched_kill_env+0x2c5>
f0105cf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105cf8:	8b 40 08             	mov    0x8(%eax),%eax
f0105cfb:	eb 05                	jmp    f0105d02 <sched_kill_env+0x2ca>
f0105cfd:	b8 00 00 00 00       	mov    $0x0,%eax
f0105d02:	a3 88 1e 5a f0       	mov    %eax,0xf05a1e88
f0105d07:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f0105d0c:	85 c0                	test   %eax,%eax
f0105d0e:	75 97                	jne    f0105ca7 <sched_kill_env+0x26f>
f0105d10:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d14:	75 91                	jne    f0105ca7 <sched_kill_env+0x26f>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d16:	83 ec 0c             	sub    $0xc,%esp
f0105d19:	68 00 1e 5a f0       	push   $0xf05a1e00
f0105d1e:	e8 59 8e 00 00       	call   f010eb7c <release_spinlock>
f0105d23:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105d26:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d2a:	74 23                	je     f0105d4f <sched_kill_env+0x317>
	{
		env_free(ptr_env);
f0105d2c:	83 ec 0c             	sub    $0xc,%esp
f0105d2f:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d32:	e8 c6 49 00 00       	call   f010a6fd <env_free>
f0105d37:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105d3a:	83 ec 0c             	sub    $0xc,%esp
f0105d3d:	68 1e 75 12 f0       	push   $0xf012751e
f0105d42:	e8 25 b2 ff ff       	call   f0100f6c <cprintf>
f0105d47:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105d4a:	e9 a4 00 00 00       	jmp    f0105df3 <sched_kill_env+0x3bb>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105d4f:	e8 f1 49 00 00       	call   f010a745 <get_cpu_proc>
f0105d54:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105d57:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105d5b:	75 19                	jne    f0105d76 <sched_kill_env+0x33e>
f0105d5d:	68 93 74 12 f0       	push   $0xf0127493
f0105d62:	68 46 73 12 f0       	push   $0xf0127346
f0105d67:	68 b3 01 00 00       	push   $0x1b3
f0105d6c:	68 5b 73 12 f0       	push   $0xf012735b
f0105d71:	e8 a4 a5 ff ff       	call   f010031a <_panic>

		if (cur_env->env_id == envId)
f0105d76:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105d79:	8b 40 10             	mov    0x10(%eax),%eax
f0105d7c:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d7f:	75 72                	jne    f0105df3 <sched_kill_env+0x3bb>
		{
			ptr_env = cur_env;
f0105d81:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105d84:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105d87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d8a:	8b 40 18             	mov    0x18(%eax),%eax
f0105d8d:	83 f8 02             	cmp    $0x2,%eax
f0105d90:	74 19                	je     f0105dab <sched_kill_env+0x373>
f0105d92:	68 24 75 12 f0       	push   $0xf0127524
f0105d97:	68 46 73 12 f0       	push   $0xf0127346
f0105d9c:	68 b8 01 00 00       	push   $0x1b8
f0105da1:	68 5b 73 12 f0       	push   $0xf012735b
f0105da6:	e8 6f a5 ff ff       	call   f010031a <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105dab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105dae:	8d 50 20             	lea    0x20(%eax),%edx
f0105db1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105db4:	8b 40 10             	mov    0x10(%eax),%eax
f0105db7:	83 ec 04             	sub    $0x4,%esp
f0105dba:	52                   	push   %edx
f0105dbb:	50                   	push   %eax
f0105dbc:	68 48 75 12 f0       	push   $0xf0127548
f0105dc1:	e8 a6 b1 ff ff       	call   f0100f6c <cprintf>
f0105dc6:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105dc9:	83 ec 0c             	sub    $0xc,%esp
f0105dcc:	ff 75 f4             	pushl  -0xc(%ebp)
f0105dcf:	e8 29 49 00 00       	call   f010a6fd <env_free>
f0105dd4:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105dd7:	83 ec 0c             	sub    $0xc,%esp
f0105dda:	68 1e 75 12 f0       	push   $0xf012751e
f0105ddf:	e8 88 b1 ff ff       	call   f0100f6c <cprintf>
f0105de4:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105de7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105dee:	e8 df 4a 00 00       	call   f010a8d2 <sched>
		}
	}

}
f0105df3:	90                   	nop
f0105df4:	c9                   	leave  
f0105df5:	c3                   	ret    

f0105df6 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105df6:	55                   	push   %ebp
f0105df7:	89 e5                	mov    %esp,%ebp
f0105df9:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105dfc:	83 ec 0c             	sub    $0xc,%esp
f0105dff:	68 00 1e 5a f0       	push   $0xf05a1e00
f0105e04:	e8 ec 8c 00 00       	call   f010eaf5 <acquire_spinlock>
f0105e09:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e0c:	a1 70 1e 5a f0       	mov    0xf05a1e70,%eax
f0105e11:	85 c0                	test   %eax,%eax
f0105e13:	74 69                	je     f0105e7e <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105e15:	83 ec 0c             	sub    $0xc,%esp
f0105e18:	68 74 75 12 f0       	push   $0xf0127574
f0105e1d:	e8 4a b1 ff ff       	call   f0100f6c <cprintf>
f0105e22:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e25:	a1 70 1e 5a f0       	mov    0xf05a1e70,%eax
f0105e2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e2d:	eb 26                	jmp    f0105e55 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105e2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e32:	8d 50 20             	lea    0x20(%eax),%edx
f0105e35:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e38:	8b 40 10             	mov    0x10(%eax),%eax
f0105e3b:	83 ec 04             	sub    $0x4,%esp
f0105e3e:	52                   	push   %edx
f0105e3f:	50                   	push   %eax
f0105e40:	68 96 75 12 f0       	push   $0xf0127596
f0105e45:	e8 22 b1 ff ff       	call   f0100f6c <cprintf>
f0105e4a:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e4d:	a1 78 1e 5a f0       	mov    0xf05a1e78,%eax
f0105e52:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e59:	74 08                	je     f0105e63 <sched_print_all+0x6d>
f0105e5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e5e:	8b 40 08             	mov    0x8(%eax),%eax
f0105e61:	eb 05                	jmp    f0105e68 <sched_print_all+0x72>
f0105e63:	b8 00 00 00 00       	mov    $0x0,%eax
f0105e68:	a3 78 1e 5a f0       	mov    %eax,0xf05a1e78
f0105e6d:	a1 78 1e 5a f0       	mov    0xf05a1e78,%eax
f0105e72:	85 c0                	test   %eax,%eax
f0105e74:	75 b9                	jne    f0105e2f <sched_print_all+0x39>
f0105e76:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e7a:	75 b3                	jne    f0105e2f <sched_print_all+0x39>
f0105e7c:	eb 10                	jmp    f0105e8e <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105e7e:	83 ec 0c             	sub    $0xc,%esp
f0105e81:	68 a0 75 12 f0       	push   $0xf01275a0
f0105e86:	e8 e1 b0 ff ff       	call   f0100f6c <cprintf>
f0105e8b:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105e8e:	83 ec 0c             	sub    $0xc,%esp
f0105e91:	68 bc 75 12 f0       	push   $0xf01275bc
f0105e96:	e8 d1 b0 ff ff       	call   f0100f6c <cprintf>
f0105e9b:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105e9e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105ea5:	e9 d7 00 00 00       	jmp    f0105f81 <sched_print_all+0x18b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105eaa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105ead:	83 c0 09             	add    $0x9,%eax
f0105eb0:	c1 e0 04             	shl    $0x4,%eax
f0105eb3:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f0105eb8:	8b 00                	mov    (%eax),%eax
f0105eba:	85 c0                	test   %eax,%eax
f0105ebc:	0f 84 99 00 00 00    	je     f0105f5b <sched_print_all+0x165>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105ec2:	83 ec 08             	sub    $0x8,%esp
f0105ec5:	ff 75 f0             	pushl  -0x10(%ebp)
f0105ec8:	68 f0 75 12 f0       	push   $0xf01275f0
f0105ecd:	e8 9a b0 ff ff       	call   f0100f6c <cprintf>
f0105ed2:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105ed5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105ed8:	83 c0 09             	add    $0x9,%eax
f0105edb:	c1 e0 04             	shl    $0x4,%eax
f0105ede:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f0105ee3:	8b 00                	mov    (%eax),%eax
f0105ee5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ee8:	eb 31                	jmp    f0105f1b <sched_print_all+0x125>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105eea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105eed:	8d 50 20             	lea    0x20(%eax),%edx
f0105ef0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ef3:	8b 40 10             	mov    0x10(%eax),%eax
f0105ef6:	83 ec 04             	sub    $0x4,%esp
f0105ef9:	52                   	push   %edx
f0105efa:	50                   	push   %eax
f0105efb:	68 96 75 12 f0       	push   $0xf0127596
f0105f00:	e8 67 b0 ff ff       	call   f0100f6c <cprintf>
f0105f05:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f08:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105f0b:	83 c0 09             	add    $0x9,%eax
f0105f0e:	c1 e0 04             	shl    $0x4,%eax
f0105f11:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f0105f16:	8b 00                	mov    (%eax),%eax
f0105f18:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f1b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f1f:	74 08                	je     f0105f29 <sched_print_all+0x133>
f0105f21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f24:	8b 40 08             	mov    0x8(%eax),%eax
f0105f27:	eb 05                	jmp    f0105f2e <sched_print_all+0x138>
f0105f29:	b8 00 00 00 00       	mov    $0x0,%eax
f0105f2e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f31:	83 c2 09             	add    $0x9,%edx
f0105f34:	c1 e2 04             	shl    $0x4,%edx
f0105f37:	81 c2 08 1e 5a f0    	add    $0xf05a1e08,%edx
f0105f3d:	89 02                	mov    %eax,(%edx)
f0105f3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105f42:	83 c0 09             	add    $0x9,%eax
f0105f45:	c1 e0 04             	shl    $0x4,%eax
f0105f48:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f0105f4d:	8b 00                	mov    (%eax),%eax
f0105f4f:	85 c0                	test   %eax,%eax
f0105f51:	75 97                	jne    f0105eea <sched_print_all+0xf4>
f0105f53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f57:	75 91                	jne    f0105eea <sched_print_all+0xf4>
f0105f59:	eb 13                	jmp    f0105f6e <sched_print_all+0x178>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105f5b:	83 ec 08             	sub    $0x8,%esp
f0105f5e:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f61:	68 18 76 12 f0       	push   $0xf0127618
f0105f66:	e8 01 b0 ff ff       	call   f0100f6c <cprintf>
f0105f6b:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105f6e:	83 ec 0c             	sub    $0xc,%esp
f0105f71:	68 bc 75 12 f0       	push   $0xf01275bc
f0105f76:	e8 f1 af ff ff       	call   f0100f6c <cprintf>
f0105f7b:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105f7e:	ff 45 f0             	incl   -0x10(%ebp)
f0105f81:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f0105f86:	0f b6 c0             	movzbl %al,%eax
f0105f89:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105f8c:	0f 8f 18 ff ff ff    	jg     f0105eaa <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105f92:	a1 80 1e 5a f0       	mov    0xf05a1e80,%eax
f0105f97:	85 c0                	test   %eax,%eax
f0105f99:	74 69                	je     f0106004 <sched_print_all+0x20e>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105f9b:	83 ec 0c             	sub    $0xc,%esp
f0105f9e:	68 3c 76 12 f0       	push   $0xf012763c
f0105fa3:	e8 c4 af ff ff       	call   f0100f6c <cprintf>
f0105fa8:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105fab:	a1 80 1e 5a f0       	mov    0xf05a1e80,%eax
f0105fb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105fb3:	eb 26                	jmp    f0105fdb <sched_print_all+0x1e5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105fb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fb8:	8d 50 20             	lea    0x20(%eax),%edx
f0105fbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fbe:	8b 40 10             	mov    0x10(%eax),%eax
f0105fc1:	83 ec 04             	sub    $0x4,%esp
f0105fc4:	52                   	push   %edx
f0105fc5:	50                   	push   %eax
f0105fc6:	68 96 75 12 f0       	push   $0xf0127596
f0105fcb:	e8 9c af ff ff       	call   f0100f6c <cprintf>
f0105fd0:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105fd3:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f0105fd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105fdb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fdf:	74 08                	je     f0105fe9 <sched_print_all+0x1f3>
f0105fe1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fe4:	8b 40 08             	mov    0x8(%eax),%eax
f0105fe7:	eb 05                	jmp    f0105fee <sched_print_all+0x1f8>
f0105fe9:	b8 00 00 00 00       	mov    $0x0,%eax
f0105fee:	a3 88 1e 5a f0       	mov    %eax,0xf05a1e88
f0105ff3:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f0105ff8:	85 c0                	test   %eax,%eax
f0105ffa:	75 b9                	jne    f0105fb5 <sched_print_all+0x1bf>
f0105ffc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106000:	75 b3                	jne    f0105fb5 <sched_print_all+0x1bf>
f0106002:	eb 10                	jmp    f0106014 <sched_print_all+0x21e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106004:	83 ec 0c             	sub    $0xc,%esp
f0106007:	68 5e 76 12 f0       	push   $0xf012765e
f010600c:	e8 5b af ff ff       	call   f0100f6c <cprintf>
f0106011:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106014:	83 ec 0c             	sub    $0xc,%esp
f0106017:	68 00 1e 5a f0       	push   $0xf05a1e00
f010601c:	e8 5b 8b 00 00       	call   f010eb7c <release_spinlock>
f0106021:	83 c4 10             	add    $0x10,%esp
}
f0106024:	90                   	nop
f0106025:	c9                   	leave  
f0106026:	c3                   	ret    

f0106027 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106027:	55                   	push   %ebp
f0106028:	89 e5                	mov    %esp,%ebp
f010602a:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010602d:	83 ec 0c             	sub    $0xc,%esp
f0106030:	68 00 1e 5a f0       	push   $0xf05a1e00
f0106035:	e8 bb 8a 00 00       	call   f010eaf5 <acquire_spinlock>
f010603a:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010603d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0106044:	a1 7c 1e 5a f0       	mov    0xf05a1e7c,%eax
f0106049:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010604c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0106053:	eb 24                	jmp    f0106079 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f0106055:	83 ec 0c             	sub    $0xc,%esp
f0106058:	68 70 1e 5a f0       	push   $0xf05a1e70
f010605d:	e8 7c ef ff ff       	call   f0104fde <dequeue>
f0106062:	83 c4 10             	add    $0x10,%esp
f0106065:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f0106068:	83 ec 0c             	sub    $0xc,%esp
f010606b:	ff 75 f0             	pushl  -0x10(%ebp)
f010606e:	e8 4f f1 ff ff       	call   f01051c2 <sched_insert_ready0>
f0106073:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f0106076:	ff 45 f4             	incl   -0xc(%ebp)
f0106079:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010607c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010607f:	7c d4                	jl     f0106055 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106081:	83 ec 0c             	sub    $0xc,%esp
f0106084:	68 00 1e 5a f0       	push   $0xf05a1e00
f0106089:	e8 ee 8a 00 00       	call   f010eb7c <release_spinlock>
f010608e:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f0106091:	e8 3c 10 00 00       	call   f01070d2 <mycpu>
f0106096:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010609c:	85 c0                	test   %eax,%eax
f010609e:	75 05                	jne    f01060a5 <sched_run_all+0x7e>
		fos_scheduler();
f01060a0:	e8 e2 06 00 00       	call   f0106787 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f01060a5:	83 ec 04             	sub    $0x4,%esp
f01060a8:	68 7c 76 12 f0       	push   $0xf012767c
f01060ad:	68 15 02 00 00       	push   $0x215
f01060b2:	68 5b 73 12 f0       	push   $0xf012735b
f01060b7:	e8 5e a2 ff ff       	call   f010031a <_panic>

f01060bc <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f01060bc:	55                   	push   %ebp
f01060bd:	89 e5                	mov    %esp,%ebp
f01060bf:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060c2:	83 ec 0c             	sub    $0xc,%esp
f01060c5:	68 00 1e 5a f0       	push   $0xf05a1e00
f01060ca:	e8 26 8a 00 00       	call   f010eaf5 <acquire_spinlock>
f01060cf:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01060d2:	a1 70 1e 5a f0       	mov    0xf05a1e70,%eax
f01060d7:	85 c0                	test   %eax,%eax
f01060d9:	0f 84 95 00 00 00    	je     f0106174 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f01060df:	83 ec 0c             	sub    $0xc,%esp
f01060e2:	68 b8 76 12 f0       	push   $0xf01276b8
f01060e7:	e8 80 ae ff ff       	call   f0100f6c <cprintf>
f01060ec:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01060ef:	a1 70 1e 5a f0       	mov    0xf05a1e70,%eax
f01060f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01060f7:	eb 52                	jmp    f010614b <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01060f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060fc:	8d 50 20             	lea    0x20(%eax),%edx
f01060ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106102:	8b 40 10             	mov    0x10(%eax),%eax
f0106105:	83 ec 04             	sub    $0x4,%esp
f0106108:	52                   	push   %edx
f0106109:	50                   	push   %eax
f010610a:	68 e4 76 12 f0       	push   $0xf01276e4
f010610f:	e8 58 ae ff ff       	call   f0100f6c <cprintf>
f0106114:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0106117:	83 ec 0c             	sub    $0xc,%esp
f010611a:	ff 75 f4             	pushl  -0xc(%ebp)
f010611d:	e8 f1 f2 ff ff       	call   f0105413 <sched_remove_new>
f0106122:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106125:	83 ec 0c             	sub    $0xc,%esp
f0106128:	ff 75 f4             	pushl  -0xc(%ebp)
f010612b:	e8 cd 45 00 00       	call   f010a6fd <env_free>
f0106130:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106133:	83 ec 0c             	sub    $0xc,%esp
f0106136:	68 1e 75 12 f0       	push   $0xf012751e
f010613b:	e8 2c ae ff ff       	call   f0100f6c <cprintf>
f0106140:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106143:	a1 78 1e 5a f0       	mov    0xf05a1e78,%eax
f0106148:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010614b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010614f:	74 08                	je     f0106159 <sched_kill_all+0x9d>
f0106151:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106154:	8b 40 08             	mov    0x8(%eax),%eax
f0106157:	eb 05                	jmp    f010615e <sched_kill_all+0xa2>
f0106159:	b8 00 00 00 00       	mov    $0x0,%eax
f010615e:	a3 78 1e 5a f0       	mov    %eax,0xf05a1e78
f0106163:	a1 78 1e 5a f0       	mov    0xf05a1e78,%eax
f0106168:	85 c0                	test   %eax,%eax
f010616a:	75 8d                	jne    f01060f9 <sched_kill_all+0x3d>
f010616c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106170:	75 87                	jne    f01060f9 <sched_kill_all+0x3d>
f0106172:	eb 10                	jmp    f0106184 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f0106174:	83 ec 0c             	sub    $0xc,%esp
f0106177:	68 f7 76 12 f0       	push   $0xf01276f7
f010617c:	e8 eb ad ff ff       	call   f0100f6c <cprintf>
f0106181:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106184:	83 ec 0c             	sub    $0xc,%esp
f0106187:	68 bc 75 12 f0       	push   $0xf01275bc
f010618c:	e8 db ad ff ff       	call   f0100f6c <cprintf>
f0106191:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106194:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010619b:	e9 b8 01 00 00       	jmp    f0106358 <sched_kill_all+0x29c>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01061a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01061a3:	83 c0 09             	add    $0x9,%eax
f01061a6:	c1 e0 04             	shl    $0x4,%eax
f01061a9:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f01061ae:	8b 00                	mov    (%eax),%eax
f01061b0:	85 c0                	test   %eax,%eax
f01061b2:	0f 84 7a 01 00 00    	je     f0106332 <sched_kill_all+0x276>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f01061b8:	83 ec 08             	sub    $0x8,%esp
f01061bb:	ff 75 f0             	pushl  -0x10(%ebp)
f01061be:	68 14 77 12 f0       	push   $0xf0127714
f01061c3:	e8 a4 ad ff ff       	call   f0100f6c <cprintf>
f01061c8:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01061cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01061ce:	83 c0 09             	add    $0x9,%eax
f01061d1:	c1 e0 04             	shl    $0x4,%eax
f01061d4:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f01061d9:	8b 00                	mov    (%eax),%eax
f01061db:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01061de:	e9 07 01 00 00       	jmp    f01062ea <sched_kill_all+0x22e>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01061e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061e6:	8d 50 20             	lea    0x20(%eax),%edx
f01061e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061ec:	8b 40 10             	mov    0x10(%eax),%eax
f01061ef:	83 ec 04             	sub    $0x4,%esp
f01061f2:	52                   	push   %edx
f01061f3:	50                   	push   %eax
f01061f4:	68 e4 76 12 f0       	push   $0xf01276e4
f01061f9:	e8 6e ad ff ff       	call   f0100f6c <cprintf>
f01061fe:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106201:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106205:	75 17                	jne    f010621e <sched_kill_all+0x162>
f0106207:	83 ec 04             	sub    $0x4,%esp
f010620a:	68 97 73 12 f0       	push   $0xf0127397
f010620f:	68 37 02 00 00       	push   $0x237
f0106214:	68 5b 73 12 f0       	push   $0xf012735b
f0106219:	e8 fc a0 ff ff       	call   f010031a <_panic>
f010621e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106221:	8b 40 08             	mov    0x8(%eax),%eax
f0106224:	85 c0                	test   %eax,%eax
f0106226:	74 11                	je     f0106239 <sched_kill_all+0x17d>
f0106228:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010622b:	8b 40 08             	mov    0x8(%eax),%eax
f010622e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106231:	8b 52 0c             	mov    0xc(%edx),%edx
f0106234:	89 50 0c             	mov    %edx,0xc(%eax)
f0106237:	eb 17                	jmp    f0106250 <sched_kill_all+0x194>
f0106239:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010623c:	8b 40 0c             	mov    0xc(%eax),%eax
f010623f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106242:	83 c2 09             	add    $0x9,%edx
f0106245:	c1 e2 04             	shl    $0x4,%edx
f0106248:	81 c2 04 1e 5a f0    	add    $0xf05a1e04,%edx
f010624e:	89 02                	mov    %eax,(%edx)
f0106250:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106253:	8b 40 0c             	mov    0xc(%eax),%eax
f0106256:	85 c0                	test   %eax,%eax
f0106258:	74 11                	je     f010626b <sched_kill_all+0x1af>
f010625a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010625d:	8b 40 0c             	mov    0xc(%eax),%eax
f0106260:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106263:	8b 52 08             	mov    0x8(%edx),%edx
f0106266:	89 50 08             	mov    %edx,0x8(%eax)
f0106269:	eb 17                	jmp    f0106282 <sched_kill_all+0x1c6>
f010626b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010626e:	8b 40 08             	mov    0x8(%eax),%eax
f0106271:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106274:	83 c2 09             	add    $0x9,%edx
f0106277:	c1 e2 04             	shl    $0x4,%edx
f010627a:	81 c2 00 1e 5a f0    	add    $0xf05a1e00,%edx
f0106280:	89 02                	mov    %eax,(%edx)
f0106282:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106285:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010628c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010628f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106296:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106299:	83 c0 09             	add    $0x9,%eax
f010629c:	c1 e0 04             	shl    $0x4,%eax
f010629f:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f01062a4:	8b 00                	mov    (%eax),%eax
f01062a6:	8d 50 ff             	lea    -0x1(%eax),%edx
f01062a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01062ac:	83 c0 09             	add    $0x9,%eax
f01062af:	c1 e0 04             	shl    $0x4,%eax
f01062b2:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f01062b7:	89 10                	mov    %edx,(%eax)
				env_free(ptr_env);
f01062b9:	83 ec 0c             	sub    $0xc,%esp
f01062bc:	ff 75 f4             	pushl  -0xc(%ebp)
f01062bf:	e8 39 44 00 00       	call   f010a6fd <env_free>
f01062c4:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f01062c7:	83 ec 0c             	sub    $0xc,%esp
f01062ca:	68 1e 75 12 f0       	push   $0xf012751e
f01062cf:	e8 98 ac ff ff       	call   f0100f6c <cprintf>
f01062d4:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01062d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01062da:	83 c0 09             	add    $0x9,%eax
f01062dd:	c1 e0 04             	shl    $0x4,%eax
f01062e0:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f01062e5:	8b 00                	mov    (%eax),%eax
f01062e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01062ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01062ee:	74 08                	je     f01062f8 <sched_kill_all+0x23c>
f01062f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062f3:	8b 40 08             	mov    0x8(%eax),%eax
f01062f6:	eb 05                	jmp    f01062fd <sched_kill_all+0x241>
f01062f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01062fd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106300:	83 c2 09             	add    $0x9,%edx
f0106303:	c1 e2 04             	shl    $0x4,%edx
f0106306:	81 c2 08 1e 5a f0    	add    $0xf05a1e08,%edx
f010630c:	89 02                	mov    %eax,(%edx)
f010630e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106311:	83 c0 09             	add    $0x9,%eax
f0106314:	c1 e0 04             	shl    $0x4,%eax
f0106317:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f010631c:	8b 00                	mov    (%eax),%eax
f010631e:	85 c0                	test   %eax,%eax
f0106320:	0f 85 bd fe ff ff    	jne    f01061e3 <sched_kill_all+0x127>
f0106326:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010632a:	0f 85 b3 fe ff ff    	jne    f01061e3 <sched_kill_all+0x127>
f0106330:	eb 13                	jmp    f0106345 <sched_kill_all+0x289>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f0106332:	83 ec 08             	sub    $0x8,%esp
f0106335:	ff 75 f0             	pushl  -0x10(%ebp)
f0106338:	68 18 76 12 f0       	push   $0xf0127618
f010633d:	e8 2a ac ff ff       	call   f0100f6c <cprintf>
f0106342:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106345:	83 ec 0c             	sub    $0xc,%esp
f0106348:	68 bc 75 12 f0       	push   $0xf01275bc
f010634d:	e8 1a ac ff ff       	call   f0100f6c <cprintf>
f0106352:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106355:	ff 45 f0             	incl   -0x10(%ebp)
f0106358:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f010635d:	0f b6 c0             	movzbl %al,%eax
f0106360:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106363:	0f 8f 37 fe ff ff    	jg     f01061a0 <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106369:	a1 80 1e 5a f0       	mov    0xf05a1e80,%eax
f010636e:	85 c0                	test   %eax,%eax
f0106370:	0f 84 95 00 00 00    	je     f010640b <sched_kill_all+0x34f>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f0106376:	83 ec 0c             	sub    $0xc,%esp
f0106379:	68 48 77 12 f0       	push   $0xf0127748
f010637e:	e8 e9 ab ff ff       	call   f0100f6c <cprintf>
f0106383:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106386:	a1 80 1e 5a f0       	mov    0xf05a1e80,%eax
f010638b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010638e:	eb 52                	jmp    f01063e2 <sched_kill_all+0x326>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106390:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106393:	8d 50 20             	lea    0x20(%eax),%edx
f0106396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106399:	8b 40 10             	mov    0x10(%eax),%eax
f010639c:	83 ec 04             	sub    $0x4,%esp
f010639f:	52                   	push   %edx
f01063a0:	50                   	push   %eax
f01063a1:	68 e4 76 12 f0       	push   $0xf01276e4
f01063a6:	e8 c1 ab ff ff       	call   f0100f6c <cprintf>
f01063ab:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f01063ae:	83 ec 0c             	sub    $0xc,%esp
f01063b1:	ff 75 f4             	pushl  -0xc(%ebp)
f01063b4:	e8 d1 f1 ff ff       	call   f010558a <sched_remove_exit>
f01063b9:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063bc:	83 ec 0c             	sub    $0xc,%esp
f01063bf:	ff 75 f4             	pushl  -0xc(%ebp)
f01063c2:	e8 36 43 00 00       	call   f010a6fd <env_free>
f01063c7:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063ca:	83 ec 0c             	sub    $0xc,%esp
f01063cd:	68 1e 75 12 f0       	push   $0xf012751e
f01063d2:	e8 95 ab ff ff       	call   f0100f6c <cprintf>
f01063d7:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063da:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f01063df:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01063e6:	74 08                	je     f01063f0 <sched_kill_all+0x334>
f01063e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063eb:	8b 40 08             	mov    0x8(%eax),%eax
f01063ee:	eb 05                	jmp    f01063f5 <sched_kill_all+0x339>
f01063f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01063f5:	a3 88 1e 5a f0       	mov    %eax,0xf05a1e88
f01063fa:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f01063ff:	85 c0                	test   %eax,%eax
f0106401:	75 8d                	jne    f0106390 <sched_kill_all+0x2d4>
f0106403:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106407:	75 87                	jne    f0106390 <sched_kill_all+0x2d4>
f0106409:	eb 10                	jmp    f010641b <sched_kill_all+0x35f>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f010640b:	83 ec 0c             	sub    $0xc,%esp
f010640e:	68 5e 76 12 f0       	push   $0xf012765e
f0106413:	e8 54 ab ff ff       	call   f0100f6c <cprintf>
f0106418:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f010641b:	e8 25 43 00 00       	call   f010a745 <get_cpu_proc>
f0106420:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f0106423:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106427:	74 6b                	je     f0106494 <sched_kill_all+0x3d8>
	{
		ptr_env = cur_env;
f0106429:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010642c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f010642f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106432:	8b 40 18             	mov    0x18(%eax),%eax
f0106435:	83 f8 02             	cmp    $0x2,%eax
f0106438:	74 19                	je     f0106453 <sched_kill_all+0x397>
f010643a:	68 24 75 12 f0       	push   $0xf0127524
f010643f:	68 46 73 12 f0       	push   $0xf0127346
f0106444:	68 57 02 00 00       	push   $0x257
f0106449:	68 5b 73 12 f0       	push   $0xf012735b
f010644e:	e8 c7 9e ff ff       	call   f010031a <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106453:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106456:	8d 50 20             	lea    0x20(%eax),%edx
f0106459:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010645c:	8b 40 10             	mov    0x10(%eax),%eax
f010645f:	83 ec 04             	sub    $0x4,%esp
f0106462:	52                   	push   %edx
f0106463:	50                   	push   %eax
f0106464:	68 48 75 12 f0       	push   $0xf0127548
f0106469:	e8 fe aa ff ff       	call   f0100f6c <cprintf>
f010646e:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f0106471:	83 ec 0c             	sub    $0xc,%esp
f0106474:	ff 75 f4             	pushl  -0xc(%ebp)
f0106477:	e8 81 42 00 00       	call   f010a6fd <env_free>
f010647c:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f010647f:	83 ec 0c             	sub    $0xc,%esp
f0106482:	68 1e 75 12 f0       	push   $0xf012751e
f0106487:	e8 e0 aa ff ff       	call   f0100f6c <cprintf>
f010648c:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f010648f:	e8 3e 44 00 00       	call   f010a8d2 <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106494:	83 ec 0c             	sub    $0xc,%esp
f0106497:	68 00 1e 5a f0       	push   $0xf05a1e00
f010649c:	e8 db 86 00 00       	call   f010eb7c <release_spinlock>
f01064a1:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f01064a4:	e8 fa b8 ff ff       	call   f0101da3 <get_into_prompt>

f01064a9 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f01064a9:	55                   	push   %ebp
f01064aa:	89 e5                	mov    %esp,%ebp
f01064ac:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064af:	83 ec 0c             	sub    $0xc,%esp
f01064b2:	68 00 1e 5a f0       	push   $0xf05a1e00
f01064b7:	e8 39 86 00 00       	call   f010eaf5 <acquire_spinlock>
f01064bc:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01064bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01064c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01064cd:	e9 59 01 00 00       	jmp    f010662b <sched_exit_all_ready_envs+0x182>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01064d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01064d5:	83 c0 09             	add    $0x9,%eax
f01064d8:	c1 e0 04             	shl    $0x4,%eax
f01064db:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f01064e0:	8b 00                	mov    (%eax),%eax
f01064e2:	85 c0                	test   %eax,%eax
f01064e4:	0f 84 3e 01 00 00    	je     f0106628 <sched_exit_all_ready_envs+0x17f>
		{
			ptr_env=NULL;
f01064ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01064f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01064f4:	83 c0 09             	add    $0x9,%eax
f01064f7:	c1 e0 04             	shl    $0x4,%eax
f01064fa:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f01064ff:	8b 00                	mov    (%eax),%eax
f0106501:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106504:	e9 d9 00 00 00       	jmp    f01065e2 <sched_exit_all_ready_envs+0x139>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106509:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010650d:	75 17                	jne    f0106526 <sched_exit_all_ready_envs+0x7d>
f010650f:	83 ec 04             	sub    $0x4,%esp
f0106512:	68 97 73 12 f0       	push   $0xf0127397
f0106517:	68 79 02 00 00       	push   $0x279
f010651c:	68 5b 73 12 f0       	push   $0xf012735b
f0106521:	e8 f4 9d ff ff       	call   f010031a <_panic>
f0106526:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106529:	8b 40 08             	mov    0x8(%eax),%eax
f010652c:	85 c0                	test   %eax,%eax
f010652e:	74 11                	je     f0106541 <sched_exit_all_ready_envs+0x98>
f0106530:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106533:	8b 40 08             	mov    0x8(%eax),%eax
f0106536:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106539:	8b 52 0c             	mov    0xc(%edx),%edx
f010653c:	89 50 0c             	mov    %edx,0xc(%eax)
f010653f:	eb 17                	jmp    f0106558 <sched_exit_all_ready_envs+0xaf>
f0106541:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106544:	8b 40 0c             	mov    0xc(%eax),%eax
f0106547:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010654a:	83 c2 09             	add    $0x9,%edx
f010654d:	c1 e2 04             	shl    $0x4,%edx
f0106550:	81 c2 04 1e 5a f0    	add    $0xf05a1e04,%edx
f0106556:	89 02                	mov    %eax,(%edx)
f0106558:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655b:	8b 40 0c             	mov    0xc(%eax),%eax
f010655e:	85 c0                	test   %eax,%eax
f0106560:	74 11                	je     f0106573 <sched_exit_all_ready_envs+0xca>
f0106562:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106565:	8b 40 0c             	mov    0xc(%eax),%eax
f0106568:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010656b:	8b 52 08             	mov    0x8(%edx),%edx
f010656e:	89 50 08             	mov    %edx,0x8(%eax)
f0106571:	eb 17                	jmp    f010658a <sched_exit_all_ready_envs+0xe1>
f0106573:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106576:	8b 40 08             	mov    0x8(%eax),%eax
f0106579:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010657c:	83 c2 09             	add    $0x9,%edx
f010657f:	c1 e2 04             	shl    $0x4,%edx
f0106582:	81 c2 00 1e 5a f0    	add    $0xf05a1e00,%edx
f0106588:	89 02                	mov    %eax,(%edx)
f010658a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010658d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106594:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106597:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010659e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01065a1:	83 c0 09             	add    $0x9,%eax
f01065a4:	c1 e0 04             	shl    $0x4,%eax
f01065a7:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f01065ac:	8b 00                	mov    (%eax),%eax
f01065ae:	8d 50 ff             	lea    -0x1(%eax),%edx
f01065b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01065b4:	83 c0 09             	add    $0x9,%eax
f01065b7:	c1 e0 04             	shl    $0x4,%eax
f01065ba:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f01065bf:	89 10                	mov    %edx,(%eax)
				sched_insert_exit(ptr_env);
f01065c1:	83 ec 0c             	sub    $0xc,%esp
f01065c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01065c7:	e8 37 ef ff ff       	call   f0105503 <sched_insert_exit>
f01065cc:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01065cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01065d2:	83 c0 09             	add    $0x9,%eax
f01065d5:	c1 e0 04             	shl    $0x4,%eax
f01065d8:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f01065dd:	8b 00                	mov    (%eax),%eax
f01065df:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01065e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065e6:	74 08                	je     f01065f0 <sched_exit_all_ready_envs+0x147>
f01065e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065eb:	8b 40 08             	mov    0x8(%eax),%eax
f01065ee:	eb 05                	jmp    f01065f5 <sched_exit_all_ready_envs+0x14c>
f01065f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01065f5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065f8:	83 c2 09             	add    $0x9,%edx
f01065fb:	c1 e2 04             	shl    $0x4,%edx
f01065fe:	81 c2 08 1e 5a f0    	add    $0xf05a1e08,%edx
f0106604:	89 02                	mov    %eax,(%edx)
f0106606:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106609:	83 c0 09             	add    $0x9,%eax
f010660c:	c1 e0 04             	shl    $0x4,%eax
f010660f:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f0106614:	8b 00                	mov    (%eax),%eax
f0106616:	85 c0                	test   %eax,%eax
f0106618:	0f 85 eb fe ff ff    	jne    f0106509 <sched_exit_all_ready_envs+0x60>
f010661e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106622:	0f 85 e1 fe ff ff    	jne    f0106509 <sched_exit_all_ready_envs+0x60>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106628:	ff 45 f0             	incl   -0x10(%ebp)
f010662b:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f0106630:	0f b6 c0             	movzbl %al,%eax
f0106633:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106636:	0f 8f 96 fe ff ff    	jg     f01064d2 <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010663c:	83 ec 0c             	sub    $0xc,%esp
f010663f:	68 00 1e 5a f0       	push   $0xf05a1e00
f0106644:	e8 33 85 00 00       	call   f010eb7c <release_spinlock>
f0106649:	83 c4 10             	add    $0x10,%esp
}
f010664c:	90                   	nop
f010664d:	c9                   	leave  
f010664e:	c3                   	ret    

f010664f <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f010664f:	55                   	push   %ebp
f0106650:	89 e5                	mov    %esp,%ebp
	return ticks;
f0106652:	a1 68 4a 5a f0       	mov    0xf05a4a68,%eax
f0106657:	8b 15 6c 4a 5a f0    	mov    0xf05a4a6c,%edx
}
f010665d:	5d                   	pop    %ebp
f010665e:	c3                   	ret    

f010665f <env_get_nice>:
int env_get_nice(struct Env* e)
{
f010665f:	55                   	push   %ebp
f0106660:	89 e5                	mov    %esp,%ebp
f0106662:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106665:	83 ec 04             	sub    $0x4,%esp
f0106668:	68 74 77 12 f0       	push   $0xf0127774
f010666d:	68 8c 02 00 00       	push   $0x28c
f0106672:	68 5b 73 12 f0       	push   $0xf012735b
f0106677:	e8 9e 9c ff ff       	call   f010031a <_panic>

f010667c <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f010667c:	55                   	push   %ebp
f010667d:	89 e5                	mov    %esp,%ebp
f010667f:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106682:	83 ec 04             	sub    $0x4,%esp
f0106685:	68 74 77 12 f0       	push   $0xf0127774
f010668a:	68 94 02 00 00       	push   $0x294
f010668f:	68 5b 73 12 f0       	push   $0xf012735b
f0106694:	e8 81 9c ff ff       	call   f010031a <_panic>

f0106699 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f0106699:	55                   	push   %ebp
f010669a:	89 e5                	mov    %esp,%ebp
f010669c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010669f:	83 ec 04             	sub    $0x4,%esp
f01066a2:	68 74 77 12 f0       	push   $0xf0127774
f01066a7:	68 9c 02 00 00       	push   $0x29c
f01066ac:	68 5b 73 12 f0       	push   $0xf012735b
f01066b1:	e8 64 9c ff ff       	call   f010031a <_panic>

f01066b6 <get_load_average>:
}
int get_load_average()
{
f01066b6:	55                   	push   %ebp
f01066b7:	89 e5                	mov    %esp,%ebp
f01066b9:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066bc:	83 ec 04             	sub    $0x4,%esp
f01066bf:	68 74 77 12 f0       	push   $0xf0127774
f01066c4:	68 a4 02 00 00       	push   $0x2a4
f01066c9:	68 5b 73 12 f0       	push   $0xf012735b
f01066ce:	e8 47 9c ff ff       	call   f010031a <_panic>

f01066d3 <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f01066d3:	55                   	push   %ebp
f01066d4:	89 e5                	mov    %esp,%ebp
f01066d6:	a1 b4 48 5a f0       	mov    0xf05a48b4,%eax
f01066db:	85 c0                	test   %eax,%eax
f01066dd:	75 07                	jne    f01066e6 <isSchedMethodRR+0x13>
f01066df:	b8 01 00 00 00       	mov    $0x1,%eax
f01066e4:	eb 05                	jmp    f01066eb <isSchedMethodRR+0x18>
f01066e6:	b8 00 00 00 00       	mov    $0x0,%eax
f01066eb:	5d                   	pop    %ebp
f01066ec:	c3                   	ret    

f01066ed <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f01066ed:	55                   	push   %ebp
f01066ee:	89 e5                	mov    %esp,%ebp
f01066f0:	a1 b4 48 5a f0       	mov    0xf05a48b4,%eax
f01066f5:	83 f8 01             	cmp    $0x1,%eax
f01066f8:	75 07                	jne    f0106701 <isSchedMethodMLFQ+0x14>
f01066fa:	b8 01 00 00 00       	mov    $0x1,%eax
f01066ff:	eb 05                	jmp    f0106706 <isSchedMethodMLFQ+0x19>
f0106701:	b8 00 00 00 00       	mov    $0x0,%eax
f0106706:	5d                   	pop    %ebp
f0106707:	c3                   	ret    

f0106708 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106708:	55                   	push   %ebp
f0106709:	89 e5                	mov    %esp,%ebp
f010670b:	a1 b4 48 5a f0       	mov    0xf05a48b4,%eax
f0106710:	83 f8 02             	cmp    $0x2,%eax
f0106713:	75 07                	jne    f010671c <isSchedMethodBSD+0x14>
f0106715:	b8 01 00 00 00       	mov    $0x1,%eax
f010671a:	eb 05                	jmp    f0106721 <isSchedMethodBSD+0x19>
f010671c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106721:	5d                   	pop    %ebp
f0106722:	c3                   	ret    

f0106723 <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f0106723:	55                   	push   %ebp
f0106724:	89 e5                	mov    %esp,%ebp
f0106726:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106729:	c7 05 88 45 5a f0 00 	movl   $0x0,0xf05a4588
f0106730:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f0106733:	83 ec 0c             	sub    $0xc,%esp
f0106736:	6a 0a                	push   $0xa
f0106738:	e8 6d 02 00 00       	call   f01069aa <sched_init_RR>
f010673d:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f0106740:	83 ec 0c             	sub    $0xc,%esp
f0106743:	68 70 1e 5a f0       	push   $0xf05a1e70
f0106748:	e8 bf e7 ff ff       	call   f0104f0c <init_queue>
f010674d:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f0106750:	83 ec 0c             	sub    $0xc,%esp
f0106753:	68 80 1e 5a f0       	push   $0xf05a1e80
f0106758:	e8 af e7 ff ff       	call   f0104f0c <init_queue>
f010675d:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f0106760:	e8 6d 09 00 00       	call   f01070d2 <mycpu>
f0106765:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f010676c:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f010676f:	83 ec 08             	sub    $0x8,%esp
f0106772:	68 88 77 12 f0       	push   $0xf0127788
f0106777:	68 00 1e 5a f0       	push   $0xf05a1e00
f010677c:	e8 43 83 00 00       	call   f010eac4 <init_spinlock>
f0106781:	83 c4 10             	add    $0x10,%esp
}
f0106784:	90                   	nop
f0106785:	c9                   	leave  
f0106786:	c3                   	ret    

f0106787 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106787:	55                   	push   %ebp
f0106788:	89 e5                	mov    %esp,%ebp
f010678a:	53                   	push   %ebx
f010678b:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010678e:	9c                   	pushf  
f010678f:	58                   	pop    %eax
f0106790:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0106793:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f0106796:	25 00 02 00 00       	and    $0x200,%eax
f010679b:	85 c0                	test   %eax,%eax
f010679d:	74 14                	je     f01067b3 <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f010679f:	83 ec 04             	sub    $0x4,%esp
f01067a2:	68 9c 77 12 f0       	push   $0xf012779c
f01067a7:	6a 37                	push   $0x37
f01067a9:	68 d2 77 12 f0       	push   $0xf01277d2
f01067ae:	e8 67 9b ff ff       	call   f010031a <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01067b3:	e8 1a 09 00 00       	call   f01070d2 <mycpu>
f01067b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f01067bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067be:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01067c5:	00 00 00 

	chk1();
f01067c8:	e8 04 ae 01 00       	call   f01215d1 <chk1>
	c->scheduler_status = SCH_STARTED;
f01067cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067d0:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f01067d7:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f01067da:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f01067e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01067e8:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f01067e9:	83 ec 0c             	sub    $0xc,%esp
f01067ec:	68 00 1e 5a f0       	push   $0xf05a1e00
f01067f1:	e8 ff 82 00 00       	call   f010eaf5 <acquire_spinlock>
f01067f6:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f01067f9:	a1 b4 48 5a f0       	mov    0xf05a48b4,%eax
f01067fe:	8b 04 85 4c 09 18 f0 	mov    -0xfe7f6b4(,%eax,4),%eax
f0106805:	ff d0                	call   *%eax
f0106807:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f010680a:	e8 36 3f 00 00       	call   f010a745 <get_cpu_proc>
f010680f:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f0106812:	83 ec 0c             	sub    $0xc,%esp
f0106815:	ff 75 e8             	pushl  -0x18(%ebp)
f0106818:	e8 51 3f 00 00       	call   f010a76e <set_cpu_proc>
f010681d:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f0106820:	83 ec 0c             	sub    $0xc,%esp
f0106823:	ff 75 e8             	pushl  -0x18(%ebp)
f0106826:	e8 ac ad 01 00       	call   f01215d7 <chk2>
f010682b:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f010682e:	83 ec 0c             	sub    $0xc,%esp
f0106831:	ff 75 e0             	pushl  -0x20(%ebp)
f0106834:	e8 35 3f 00 00       	call   f010a76e <set_cpu_proc>
f0106839:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f010683c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106840:	0f 84 d6 00 00 00    	je     f010691c <fos_scheduler+0x195>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106846:	83 ec 0c             	sub    $0xc,%esp
f0106849:	ff 75 e8             	pushl  -0x18(%ebp)
f010684c:	e8 1d 3f 00 00       	call   f010a76e <set_cpu_proc>
f0106851:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f0106854:	83 ec 0c             	sub    $0xc,%esp
f0106857:	ff 75 e8             	pushl  -0x18(%ebp)
f010685a:	e8 96 41 00 00       	call   f010a9f5 <switchuvm>
f010685f:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f0106862:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106865:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f010686c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010686f:	8b 40 04             	mov    0x4(%eax),%eax
f0106872:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106875:	83 c2 04             	add    $0x4,%edx
f0106878:	83 ec 08             	sub    $0x8,%esp
f010687b:	50                   	push   %eax
f010687c:	52                   	push   %edx
f010687d:	e8 92 e2 ff ff       	call   f0104b14 <context_switch>
f0106882:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106885:	9c                   	pushf  
f0106886:	58                   	pop    %eax
f0106887:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010688a:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f010688d:	25 00 02 00 00       	and    $0x200,%eax
f0106892:	85 c0                	test   %eax,%eax
f0106894:	74 14                	je     f01068aa <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f0106896:	83 ec 04             	sub    $0x4,%esp
f0106899:	68 e4 77 12 f0       	push   $0xf01277e4
f010689e:	6a 74                	push   $0x74
f01068a0:	68 d2 77 12 f0       	push   $0xf01277d2
f01068a5:	e8 70 9a ff ff       	call   f010031a <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01068aa:	e8 ae e3 ff ff       	call   f0104c5d <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01068af:	e8 91 3e 00 00       	call   f010a745 <get_cpu_proc>
f01068b4:	89 c2                	mov    %eax,%edx
f01068b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068b9:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068bf:	39 c2                	cmp    %eax,%edx
f01068c1:	74 16                	je     f01068d9 <fos_scheduler+0x152>
f01068c3:	68 1b 78 12 f0       	push   $0xf012781b
f01068c8:	68 35 78 12 f0       	push   $0xf0127835
f01068cd:	6a 7d                	push   $0x7d
f01068cf:	68 d2 77 12 f0       	push   $0xf01277d2
f01068d4:	e8 41 9a ff ff       	call   f010031a <_panic>
				int status = c->proc->env_status ;
f01068d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068dc:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068e2:	8b 40 18             	mov    0x18(%eax),%eax
f01068e5:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f01068e8:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f01068ec:	75 16                	jne    f0106904 <fos_scheduler+0x17d>
f01068ee:	68 4a 78 12 f0       	push   $0xf012784a
f01068f3:	68 35 78 12 f0       	push   $0xf0127835
f01068f8:	6a 7f                	push   $0x7f
f01068fa:	68 d2 77 12 f0       	push   $0xf01277d2
f01068ff:	e8 16 9a ff ff       	call   f010031a <_panic>
				if (status == ENV_READY)
f0106904:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106908:	74 12                	je     f010691c <fos_scheduler+0x195>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f010690a:	e8 cf 40 00 00       	call   f010a9de <switchkvm>
					set_cpu_proc(NULL);
f010690f:	83 ec 0c             	sub    $0xc,%esp
f0106912:	6a 00                	push   $0x0
f0106914:	e8 55 3e 00 00       	call   f010a76e <set_cpu_proc>
f0106919:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f010691c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106920:	0f 85 d3 fe ff ff    	jne    f01067f9 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106926:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f010692d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106934:	eb 4d                	jmp    f0106983 <fos_scheduler+0x1fc>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106936:	8b 0d b0 13 5a f0    	mov    0xf05a13b0,%ecx
f010693c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010693f:	89 d0                	mov    %edx,%eax
f0106941:	c1 e0 06             	shl    $0x6,%eax
f0106944:	29 d0                	sub    %edx,%eax
f0106946:	c1 e0 02             	shl    $0x2,%eax
f0106949:	01 d0                	add    %edx,%eax
f010694b:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0106952:	01 d8                	add    %ebx,%eax
f0106954:	c1 e0 03             	shl    $0x3,%eax
f0106957:	01 d0                	add    %edx,%eax
f0106959:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0106960:	29 c2                	sub    %eax,%edx
f0106962:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0106969:	89 c2                	mov    %eax,%edx
f010696b:	89 d0                	mov    %edx,%eax
f010696d:	01 c8                	add    %ecx,%eax
f010696f:	8b 40 18             	mov    0x18(%eax),%eax
f0106972:	83 f8 03             	cmp    $0x3,%eax
f0106975:	75 09                	jne    f0106980 <fos_scheduler+0x1f9>
			{
				is_any_blocked = 1;
f0106977:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010697e:	eb 0b                	jmp    f010698b <fos_scheduler+0x204>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f0106980:	ff 45 f0             	incl   -0x10(%ebp)
f0106983:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106986:	83 f8 07             	cmp    $0x7,%eax
f0106989:	76 ab                	jbe    f0106936 <fos_scheduler+0x1af>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f010698b:	83 ec 0c             	sub    $0xc,%esp
f010698e:	68 00 1e 5a f0       	push   $0xf05a1e00
f0106993:	e8 e4 81 00 00       	call   f010eb7c <release_spinlock>
f0106998:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f010699b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010699f:	0f 8f 43 fe ff ff    	jg     f01067e8 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01069a5:	e8 f9 b3 ff ff       	call   f0101da3 <get_into_prompt>

f01069aa <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01069aa:	55                   	push   %ebp
f01069ab:	89 e5                	mov    %esp,%ebp
f01069ad:	83 ec 28             	sub    $0x28,%esp
f01069b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01069b3:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01069b6:	c6 05 00 4b 5a f0 01 	movb   $0x1,0xf05a4b00
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f01069bd:	8a 45 e4             	mov    -0x1c(%ebp),%al
f01069c0:	a2 84 47 5a f0       	mov    %al,0xf05a4784
	kclock_set_quantum(quantums[0]);
f01069c5:	a0 84 47 5a f0       	mov    0xf05a4784,%al
f01069ca:	0f b6 c0             	movzbl %al,%eax
f01069cd:	83 ec 0c             	sub    $0xc,%esp
f01069d0:	50                   	push   %eax
f01069d1:	e8 50 e3 ff ff       	call   f0104d26 <kclock_set_quantum>
f01069d6:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f01069d9:	83 ec 0c             	sub    $0xc,%esp
f01069dc:	68 90 1e 5a f0       	push   $0xf05a1e90
f01069e1:	e8 26 e5 ff ff       	call   f0104f0c <init_queue>
f01069e6:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f01069e9:	e8 97 e4 ff ff       	call   f0104e85 <kclock_read_cnt0_latch>
f01069ee:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f01069f2:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f01069f6:	83 ec 08             	sub    $0x8,%esp
f01069f9:	50                   	push   %eax
f01069fa:	68 60 78 12 f0       	push   $0xf0127860
f01069ff:	e8 68 a5 ff ff       	call   f0100f6c <cprintf>
f0106a04:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106a07:	e8 c6 06 00 00       	call   f01070d2 <mycpu>
f0106a0c:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a13:	00 00 00 
	scheduler_method = SCH_RR;
f0106a16:	c7 05 b4 48 5a f0 00 	movl   $0x0,0xf05a48b4
f0106a1d:	00 00 00 
	//=========================================
	//=========================================
}
f0106a20:	90                   	nop
f0106a21:	c9                   	leave  
f0106a22:	c3                   	ret    

f0106a23 <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106a23:	55                   	push   %ebp
f0106a24:	89 e5                	mov    %esp,%ebp
f0106a26:	83 ec 18             	sub    $0x18,%esp
f0106a29:	8b 45 08             	mov    0x8(%ebp),%eax
f0106a2c:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106a2f:	e8 88 e7 ff ff       	call   f01051bc <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a34:	83 ec 04             	sub    $0x4,%esp
f0106a37:	68 88 78 12 f0       	push   $0xf0127888
f0106a3c:	68 ce 00 00 00       	push   $0xce
f0106a41:	68 d2 77 12 f0       	push   $0xf01277d2
f0106a46:	e8 cf 98 ff ff       	call   f010031a <_panic>

f0106a4b <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106a4b:	55                   	push   %ebp
f0106a4c:	89 e5                	mov    %esp,%ebp
f0106a4e:	83 ec 18             	sub    $0x18,%esp
f0106a51:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a54:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a57:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106a5a:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a5d:	83 ec 04             	sub    $0x4,%esp
f0106a60:	68 88 78 12 f0       	push   $0xf0127888
f0106a65:	68 e4 00 00 00       	push   $0xe4
f0106a6a:	68 d2 77 12 f0       	push   $0xf01277d2
f0106a6f:	e8 a6 98 ff ff       	call   f010031a <_panic>

f0106a74 <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106a74:	55                   	push   %ebp
f0106a75:	89 e5                	mov    %esp,%ebp
f0106a77:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106a7a:	83 ec 0c             	sub    $0xc,%esp
f0106a7d:	68 00 1e 5a f0       	push   $0xf05a1e00
f0106a82:	e8 87 82 00 00       	call   f010ed0e <holding_spinlock>
f0106a87:	83 c4 10             	add    $0x10,%esp
f0106a8a:	85 c0                	test   %eax,%eax
f0106a8c:	75 17                	jne    f0106aa5 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106a8e:	83 ec 04             	sub    $0x4,%esp
f0106a91:	68 9c 78 12 f0       	push   $0xf012789c
f0106a96:	68 fe 00 00 00       	push   $0xfe
f0106a9b:	68 d2 77 12 f0       	push   $0xf01277d2
f0106aa0:	e8 75 98 ff ff       	call   f010031a <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106aa5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106aac:	e8 94 3c 00 00       	call   f010a745 <get_cpu_proc>
f0106ab1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106ab4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106ab8:	74 13                	je     f0106acd <fos_scheduler_RR+0x59>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106aba:	83 ec 08             	sub    $0x8,%esp
f0106abd:	ff 75 f0             	pushl  -0x10(%ebp)
f0106ac0:	68 90 1e 5a f0       	push   $0xf05a1e90
f0106ac5:	e8 83 e4 ff ff       	call   f0104f4d <enqueue>
f0106aca:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106acd:	83 ec 0c             	sub    $0xc,%esp
f0106ad0:	68 90 1e 5a f0       	push   $0xf05a1e90
f0106ad5:	e8 04 e5 ff ff       	call   f0104fde <dequeue>
f0106ada:	83 c4 10             	add    $0x10,%esp
f0106add:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106ae0:	a0 84 47 5a f0       	mov    0xf05a4784,%al
f0106ae5:	0f b6 c0             	movzbl %al,%eax
f0106ae8:	83 ec 0c             	sub    $0xc,%esp
f0106aeb:	50                   	push   %eax
f0106aec:	e8 35 e2 ff ff       	call   f0104d26 <kclock_set_quantum>
f0106af1:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106af7:	c9                   	leave  
f0106af8:	c3                   	ret    

f0106af9 <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106af9:	55                   	push   %ebp
f0106afa:	89 e5                	mov    %esp,%ebp
f0106afc:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106aff:	83 ec 0c             	sub    $0xc,%esp
f0106b02:	68 00 1e 5a f0       	push   $0xf05a1e00
f0106b07:	e8 02 82 00 00       	call   f010ed0e <holding_spinlock>
f0106b0c:	83 c4 10             	add    $0x10,%esp
f0106b0f:	85 c0                	test   %eax,%eax
f0106b11:	75 17                	jne    f0106b2a <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106b13:	83 ec 04             	sub    $0x4,%esp
f0106b16:	68 e8 78 12 f0       	push   $0xf01278e8
f0106b1b:	68 1d 01 00 00       	push   $0x11d
f0106b20:	68 d2 77 12 f0       	push   $0xf01277d2
f0106b25:	e8 f0 97 ff ff       	call   f010031a <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b2a:	83 ec 04             	sub    $0x4,%esp
f0106b2d:	68 88 78 12 f0       	push   $0xf0127888
f0106b32:	68 23 01 00 00       	push   $0x123
f0106b37:	68 d2 77 12 f0       	push   $0xf01277d2
f0106b3c:	e8 d9 97 ff ff       	call   f010031a <_panic>

f0106b41 <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106b41:	55                   	push   %ebp
f0106b42:	89 e5                	mov    %esp,%ebp
f0106b44:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b47:	83 ec 0c             	sub    $0xc,%esp
f0106b4a:	68 00 1e 5a f0       	push   $0xf05a1e00
f0106b4f:	e8 ba 81 00 00       	call   f010ed0e <holding_spinlock>
f0106b54:	83 c4 10             	add    $0x10,%esp
f0106b57:	85 c0                	test   %eax,%eax
f0106b59:	75 17                	jne    f0106b72 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106b5b:	83 ec 04             	sub    $0x4,%esp
f0106b5e:	68 38 79 12 f0       	push   $0xf0127938
f0106b63:	68 2e 01 00 00       	push   $0x12e
f0106b68:	68 d2 77 12 f0       	push   $0xf01277d2
f0106b6d:	e8 a8 97 ff ff       	call   f010031a <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b72:	83 ec 04             	sub    $0x4,%esp
f0106b75:	68 88 78 12 f0       	push   $0xf0127888
f0106b7a:	68 34 01 00 00       	push   $0x134
f0106b7f:	68 d2 77 12 f0       	push   $0xf01277d2
f0106b84:	e8 91 97 ff ff       	call   f010031a <_panic>

f0106b89 <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106b89:	55                   	push   %ebp
f0106b8a:	89 e5                	mov    %esp,%ebp
f0106b8c:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106b8f:	e8 74 fb ff ff       	call   f0106708 <isSchedMethodBSD>
f0106b94:	85 c0                	test   %eax,%eax
f0106b96:	74 17                	je     f0106baf <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106b98:	83 ec 04             	sub    $0x4,%esp
f0106b9b:	68 88 78 12 f0       	push   $0xf0127888
f0106ba0:	68 43 01 00 00       	push   $0x143
f0106ba5:	68 d2 77 12 f0       	push   $0xf01277d2
f0106baa:	e8 6b 97 ff ff       	call   f010031a <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106baf:	a1 68 4a 5a f0       	mov    0xf05a4a68,%eax
f0106bb4:	8b 15 6c 4a 5a f0    	mov    0xf05a4a6c,%edx
f0106bba:	83 c0 01             	add    $0x1,%eax
f0106bbd:	83 d2 00             	adc    $0x0,%edx
f0106bc0:	a3 68 4a 5a f0       	mov    %eax,0xf05a4a68
f0106bc5:	89 15 6c 4a 5a f0    	mov    %edx,0xf05a4a6c
	struct Env* p = get_cpu_proc();
f0106bcb:	e8 75 3b 00 00       	call   f010a745 <get_cpu_proc>
f0106bd0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106bd3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106bd7:	74 30                	je     f0106c09 <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106bd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106bdc:	8b 80 68 da 01 00    	mov    0x1da68(%eax),%eax
f0106be2:	8d 50 01             	lea    0x1(%eax),%edx
f0106be5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106be8:	89 90 68 da 01 00    	mov    %edx,0x1da68(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106bee:	83 ec 0c             	sub    $0xc,%esp
f0106bf1:	6a 01                	push   $0x1
f0106bf3:	e8 ec 7a 00 00       	call   f010e6e4 <isPageReplacmentAlgorithmLRU>
f0106bf8:	83 c4 10             	add    $0x10,%esp
f0106bfb:	85 c0                	test   %eax,%eax
f0106bfd:	74 05                	je     f0106c04 <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106bff:	e8 08 00 00 00       	call   f0106c0c <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106c04:	e8 6a 3c 00 00       	call   f010a873 <yield>
	}
	/*****************************************/
}
f0106c09:	90                   	nop
f0106c0a:	c9                   	leave  
f0106c0b:	c3                   	ret    

f0106c0c <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106c0c:	55                   	push   %ebp
f0106c0d:	89 e5                	mov    %esp,%ebp
f0106c0f:	53                   	push   %ebx
f0106c10:	83 ec 34             	sub    $0x34,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106c13:	e8 2d 3b 00 00       	call   f010a745 <get_cpu_proc>
f0106c18:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106c1b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106c1f:	0f 84 9d 01 00 00    	je     f0106dc2 <update_WS_time_stamps+0x1b6>
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
			{
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
f0106c25:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0106c2c:	e9 99 00 00 00       	jmp    f0106cca <update_WS_time_stamps+0xbe>
				{
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
f0106c31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106c34:	89 d0                	mov    %edx,%eax
f0106c36:	01 c0                	add    %eax,%eax
f0106c38:	01 d0                	add    %edx,%eax
f0106c3a:	c1 e0 03             	shl    $0x3,%eax
f0106c3d:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f0106c43:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c46:	01 d0                	add    %edx,%eax
f0106c48:	83 c0 08             	add    $0x8,%eax
f0106c4b:	89 45 e8             	mov    %eax,-0x18(%ebp)
					if( wse->empty == 1)
f0106c4e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106c51:	8a 40 04             	mov    0x4(%eax),%al
f0106c54:	3c 01                	cmp    $0x1,%al
f0106c56:	74 6e                	je     f0106cc6 <update_WS_time_stamps+0xba>
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106c58:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106c5b:	8b 00                	mov    (%eax),%eax
f0106c5d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106c60:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c63:	8b 40 64             	mov    0x64(%eax),%eax
f0106c66:	83 ec 08             	sub    $0x8,%esp
f0106c69:	ff 75 e4             	pushl  -0x1c(%ebp)
f0106c6c:	50                   	push   %eax
f0106c6d:	e8 4f 1f 00 00       	call   f0108bc1 <pt_get_page_permissions>
f0106c72:	83 c4 10             	add    $0x10,%esp
f0106c75:	89 45 e0             	mov    %eax,-0x20(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106c78:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106c7b:	8b 40 08             	mov    0x8(%eax),%eax
f0106c7e:	89 45 dc             	mov    %eax,-0x24(%ebp)

					if (perm & PERM_USED)
f0106c81:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c84:	83 e0 20             	and    $0x20,%eax
f0106c87:	85 c0                	test   %eax,%eax
f0106c89:	74 2b                	je     f0106cb6 <update_WS_time_stamps+0xaa>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106c8b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0106c8e:	c1 e8 02             	shr    $0x2,%eax
f0106c91:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106c96:	89 c2                	mov    %eax,%edx
f0106c98:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106c9b:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106c9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106ca1:	8b 40 64             	mov    0x64(%eax),%eax
f0106ca4:	6a 20                	push   $0x20
f0106ca6:	6a 00                	push   $0x0
f0106ca8:	ff 75 e4             	pushl  -0x1c(%ebp)
f0106cab:	50                   	push   %eax
f0106cac:	e8 4c 1e 00 00       	call   f0108afd <pt_set_page_permissions>
f0106cb1:	83 c4 10             	add    $0x10,%esp
f0106cb4:	eb 11                	jmp    f0106cc7 <update_WS_time_stamps+0xbb>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106cb6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0106cb9:	c1 e8 02             	shr    $0x2,%eax
f0106cbc:	89 c2                	mov    %eax,%edx
f0106cbe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106cc1:	89 50 08             	mov    %edx,0x8(%eax)
f0106cc4:	eb 01                	jmp    f0106cc7 <update_WS_time_stamps+0xbb>
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
				{
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
f0106cc6:	90                   	nop
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
			{
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
f0106cc7:	ff 45 f4             	incl   -0xc(%ebp)
f0106cca:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106ccd:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0106cd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cd6:	39 c2                	cmp    %eax,%edx
f0106cd8:	0f 87 53 ff ff ff    	ja     f0106c31 <update_WS_time_stamps+0x25>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106cde:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106ce5:	e9 ce 00 00 00       	jmp    f0106db8 <update_WS_time_stamps+0x1ac>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106cea:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106ced:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106cf0:	89 d0                	mov    %edx,%eax
f0106cf2:	01 c0                	add    %eax,%eax
f0106cf4:	01 d0                	add    %edx,%eax
f0106cf6:	c1 e0 03             	shl    $0x3,%eax
f0106cf9:	01 c8                	add    %ecx,%eax
f0106cfb:	05 60 d5 01 00       	add    $0x1d560,%eax
f0106d00:	8a 00                	mov    (%eax),%al
f0106d02:	3c 01                	cmp    $0x1,%al
f0106d04:	0f 84 ab 00 00 00    	je     f0106db5 <update_WS_time_stamps+0x1a9>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106d0a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d0d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d10:	89 d0                	mov    %edx,%eax
f0106d12:	01 c0                	add    %eax,%eax
f0106d14:	01 d0                	add    %edx,%eax
f0106d16:	c1 e0 03             	shl    $0x3,%eax
f0106d19:	01 c8                	add    %ecx,%eax
f0106d1b:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0106d20:	8b 00                	mov    (%eax),%eax
f0106d22:	89 45 d8             	mov    %eax,-0x28(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106d25:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d28:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d2b:	89 d0                	mov    %edx,%eax
f0106d2d:	01 c0                	add    %eax,%eax
f0106d2f:	01 d0                	add    %edx,%eax
f0106d31:	c1 e0 03             	shl    $0x3,%eax
f0106d34:	01 c8                	add    %ecx,%eax
f0106d36:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106d3b:	8b 00                	mov    (%eax),%eax
f0106d3d:	89 45 d4             	mov    %eax,-0x2c(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106d40:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d43:	8b 40 64             	mov    0x64(%eax),%eax
f0106d46:	83 ec 08             	sub    $0x8,%esp
f0106d49:	ff 75 d8             	pushl  -0x28(%ebp)
f0106d4c:	50                   	push   %eax
f0106d4d:	e8 4b 1f 00 00       	call   f0108c9d <pd_is_table_used>
f0106d52:	83 c4 10             	add    $0x10,%esp
f0106d55:	85 c0                	test   %eax,%eax
f0106d57:	74 3c                	je     f0106d95 <update_WS_time_stamps+0x189>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106d59:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0106d5c:	c1 e8 02             	shr    $0x2,%eax
f0106d5f:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106d64:	89 c1                	mov    %eax,%ecx
f0106d66:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106d69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d6c:	89 d0                	mov    %edx,%eax
f0106d6e:	01 c0                	add    %eax,%eax
f0106d70:	01 d0                	add    %edx,%eax
f0106d72:	c1 e0 03             	shl    $0x3,%eax
f0106d75:	01 d8                	add    %ebx,%eax
f0106d77:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106d7c:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106d7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d81:	8b 40 64             	mov    0x64(%eax),%eax
f0106d84:	83 ec 08             	sub    $0x8,%esp
f0106d87:	ff 75 d8             	pushl  -0x28(%ebp)
f0106d8a:	50                   	push   %eax
f0106d8b:	e8 31 1f 00 00       	call   f0108cc1 <pd_set_table_unused>
f0106d90:	83 c4 10             	add    $0x10,%esp
f0106d93:	eb 20                	jmp    f0106db5 <update_WS_time_stamps+0x1a9>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106d95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0106d98:	c1 e8 02             	shr    $0x2,%eax
f0106d9b:	89 c1                	mov    %eax,%ecx
f0106d9d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106da0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106da3:	89 d0                	mov    %edx,%eax
f0106da5:	01 c0                	add    %eax,%eax
f0106da7:	01 d0                	add    %edx,%eax
f0106da9:	c1 e0 03             	shl    $0x3,%eax
f0106dac:	01 d8                	add    %ebx,%eax
f0106dae:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106db3:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106db5:	ff 45 f0             	incl   -0x10(%ebp)
f0106db8:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106dbc:	0f 8e 28 ff ff ff    	jle    f0106cea <update_WS_time_stamps+0xde>
						}
					}
				}
			}
		}
	}
f0106dc2:	90                   	nop
f0106dc3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106dc6:	c9                   	leave  
f0106dc7:	c3                   	ret    

f0106dc8 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106dc8:	55                   	push   %ebp
f0106dc9:	89 e5                	mov    %esp,%ebp
f0106dcb:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106dce:	c7 05 ac 13 5a f0 01 	movl   $0x1,0xf05a13ac
f0106dd5:	00 00 00 
f0106dd8:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106ddf:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106de3:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106de6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106de9:	ee                   	out    %al,(%dx)
f0106dea:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106df1:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106df5:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106df8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106dfb:	ee                   	out    %al,(%dx)
f0106dfc:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106e03:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106e07:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106e0a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106e0d:	ee                   	out    %al,(%dx)
f0106e0e:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106e15:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106e19:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106e1c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106e1f:	ee                   	out    %al,(%dx)
f0106e20:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106e27:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106e2b:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106e2e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106e31:	ee                   	out    %al,(%dx)
f0106e32:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106e39:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106e3d:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106e40:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106e43:	ee                   	out    %al,(%dx)
f0106e44:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106e4b:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106e4f:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106e52:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106e55:	ee                   	out    %al,(%dx)
f0106e56:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106e5d:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106e61:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106e64:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106e67:	ee                   	out    %al,(%dx)
f0106e68:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106e6f:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106e73:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106e76:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106e79:	ee                   	out    %al,(%dx)
f0106e7a:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106e81:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106e85:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106e88:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106e8b:	ee                   	out    %al,(%dx)
f0106e8c:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106e93:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106e97:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106e9a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106e9d:	ee                   	out    %al,(%dx)
f0106e9e:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106ea5:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106ea9:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106eac:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106eaf:	ee                   	out    %al,(%dx)
f0106eb0:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106eb7:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106ebb:	8a 45 be             	mov    -0x42(%ebp),%al
f0106ebe:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106ec1:	ee                   	out    %al,(%dx)
f0106ec2:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106ec9:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106ecd:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106ed0:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106ed3:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106ed4:	66 a1 58 09 18 f0    	mov    0xf0180958,%ax
f0106eda:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106ede:	74 15                	je     f0106ef5 <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106ee0:	66 a1 58 09 18 f0    	mov    0xf0180958,%ax
f0106ee6:	0f b7 c0             	movzwl %ax,%eax
f0106ee9:	83 ec 0c             	sub    $0xc,%esp
f0106eec:	50                   	push   %eax
f0106eed:	e8 06 00 00 00       	call   f0106ef8 <irq_setmask_8259A>
f0106ef2:	83 c4 10             	add    $0x10,%esp
}
f0106ef5:	90                   	nop
f0106ef6:	c9                   	leave  
f0106ef7:	c3                   	ret    

f0106ef8 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106ef8:	55                   	push   %ebp
f0106ef9:	89 e5                	mov    %esp,%ebp
f0106efb:	83 ec 14             	sub    $0x14,%esp
f0106efe:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f01:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106f05:	a1 ac 13 5a f0       	mov    0xf05a13ac,%eax
f0106f0a:	85 c0                	test   %eax,%eax
f0106f0c:	74 34                	je     f0106f42 <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106f0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f11:	0f b6 c0             	movzbl %al,%eax
f0106f14:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106f1b:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106f1e:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106f21:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106f24:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106f25:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f28:	66 c1 e8 08          	shr    $0x8,%ax
f0106f2c:	0f b6 c0             	movzbl %al,%eax
f0106f2f:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106f36:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106f39:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106f3c:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106f3f:	ee                   	out    %al,(%dx)
f0106f40:	eb 01                	jmp    f0106f43 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106f42:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106f43:	c9                   	leave  
f0106f44:	c3                   	ret    

f0106f45 <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106f45:	55                   	push   %ebp
f0106f46:	89 e5                	mov    %esp,%ebp
f0106f48:	53                   	push   %ebx
f0106f49:	83 ec 14             	sub    $0x14,%esp
f0106f4c:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f4f:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f52:	a1 ac 13 5a f0       	mov    0xf05a13ac,%eax
f0106f57:	85 c0                	test   %eax,%eax
f0106f59:	74 58                	je     f0106fb3 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f5b:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106f5f:	77 08                	ja     f0106f69 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106f61:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106f67:	eb 0a                	jmp    f0106f73 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106f69:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106f6f:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106f73:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106f77:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106f7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f7d:	89 c2                	mov    %eax,%edx
f0106f7f:	ec                   	in     (%dx),%al
f0106f80:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106f83:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106f86:	88 c2                	mov    %al,%dl
f0106f88:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106f8c:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106f91:	88 c1                	mov    %al,%cl
f0106f93:	d3 e3                	shl    %cl,%ebx
f0106f95:	89 d8                	mov    %ebx,%eax
f0106f97:	09 d0                	or     %edx,%eax
f0106f99:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106f9c:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106fa0:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106fa4:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106fa7:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106faa:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106fad:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fb0:	ee                   	out    %al,(%dx)
f0106fb1:	eb 01                	jmp    f0106fb4 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106fb3:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106fb4:	83 c4 14             	add    $0x14,%esp
f0106fb7:	5b                   	pop    %ebx
f0106fb8:	5d                   	pop    %ebp
f0106fb9:	c3                   	ret    

f0106fba <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106fba:	55                   	push   %ebp
f0106fbb:	89 e5                	mov    %esp,%ebp
f0106fbd:	53                   	push   %ebx
f0106fbe:	83 ec 14             	sub    $0x14,%esp
f0106fc1:	8b 45 08             	mov    0x8(%ebp),%eax
f0106fc4:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106fc7:	a1 ac 13 5a f0       	mov    0xf05a13ac,%eax
f0106fcc:	85 c0                	test   %eax,%eax
f0106fce:	74 5a                	je     f010702a <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106fd0:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106fd4:	77 08                	ja     f0106fde <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0106fd6:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106fdc:	eb 0a                	jmp    f0106fe8 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106fde:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106fe4:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0106fe8:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fec:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ff2:	89 c2                	mov    %eax,%edx
f0106ff4:	ec                   	in     (%dx),%al
f0106ff5:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106ff8:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106ffb:	88 c2                	mov    %al,%dl
f0106ffd:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107001:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107006:	88 c1                	mov    %al,%cl
f0107008:	d3 e3                	shl    %cl,%ebx
f010700a:	89 d8                	mov    %ebx,%eax
f010700c:	f7 d0                	not    %eax
f010700e:	21 d0                	and    %edx,%eax
f0107010:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107013:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107017:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f010701b:	89 55 f0             	mov    %edx,-0x10(%ebp)
f010701e:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107021:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107024:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107027:	ee                   	out    %al,(%dx)
f0107028:	eb 01                	jmp    f010702b <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f010702a:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f010702b:	83 c4 14             	add    $0x14,%esp
f010702e:	5b                   	pop    %ebx
f010702f:	5d                   	pop    %ebp
f0107030:	c3                   	ret    

f0107031 <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0107031:	55                   	push   %ebp
f0107032:	89 e5                	mov    %esp,%ebp
f0107034:	53                   	push   %ebx
f0107035:	83 ec 14             	sub    $0x14,%esp
f0107038:	8b 45 08             	mov    0x8(%ebp),%eax
f010703b:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f010703e:	a1 ac 13 5a f0       	mov    0xf05a13ac,%eax
f0107043:	85 c0                	test   %eax,%eax
f0107045:	75 07                	jne    f010704e <irq_get_mask+0x1d>
		return -1;
f0107047:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010704c:	eb 45                	jmp    f0107093 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f010704e:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107052:	77 08                	ja     f010705c <irq_get_mask+0x2b>
		port = PIC1_DATA;
f0107054:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f010705a:	eb 0a                	jmp    f0107066 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f010705c:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107062:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f0107066:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f010706a:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010706d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107070:	89 c2                	mov    %eax,%edx
f0107072:	ec                   	in     (%dx),%al
f0107073:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f0107076:	8a 45 f3             	mov    -0xd(%ebp),%al
f0107079:	88 c2                	mov    %al,%dl
f010707b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010707f:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107084:	88 c1                	mov    %al,%cl
f0107086:	d3 e3                	shl    %cl,%ebx
f0107088:	89 d8                	mov    %ebx,%eax
f010708a:	21 d0                	and    %edx,%eax
f010708c:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f010708f:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f0107093:	83 c4 14             	add    $0x14,%esp
f0107096:	5b                   	pop    %ebx
f0107097:	5d                   	pop    %ebp
f0107098:	c3                   	ret    

f0107099 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f0107099:	55                   	push   %ebp
f010709a:	89 e5                	mov    %esp,%ebp
f010709c:	83 ec 14             	sub    $0x14,%esp
f010709f:	8b 45 08             	mov    0x8(%ebp),%eax
f01070a2:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f01070a5:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f01070a9:	76 12                	jbe    f01070bd <pic_sendEOI+0x24>
f01070ab:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f01070b2:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01070b6:	8a 45 f7             	mov    -0x9(%ebp),%al
f01070b9:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01070bc:	ee                   	out    %al,(%dx)
f01070bd:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f01070c4:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f01070c8:	8a 45 f6             	mov    -0xa(%ebp),%al
f01070cb:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01070ce:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f01070cf:	90                   	nop
f01070d0:	c9                   	leave  
f01070d1:	c3                   	ret    

f01070d2 <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f01070d2:	55                   	push   %ebp
f01070d3:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f01070d5:	b8 a0 45 5a f0       	mov    $0xf05a45a0,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f01070da:	5d                   	pop    %ebp
f01070db:	c3                   	ret    

f01070dc <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f01070dc:	55                   	push   %ebp
f01070dd:	89 e5                	mov    %esp,%ebp
f01070df:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f01070e2:	e8 eb ff ff ff       	call   f01070d2 <mycpu>
f01070e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f01070ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070ed:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01070f4:	00 00 00 
  c->ncli = 0;
f01070f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070fa:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0107101:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107104:	9c                   	pushf  
f0107105:	58                   	pop    %eax
f0107106:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107109:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f010710c:	25 00 02 00 00       	and    $0x200,%eax
f0107111:	85 c0                	test   %eax,%eax
f0107113:	0f 95 c0             	setne  %al
f0107116:	0f b6 d0             	movzbl %al,%edx
f0107119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010711c:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f0107122:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107125:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f010712c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010712f:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107136:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107139:	8b 45 08             	mov    0x8(%ebp),%eax
f010713c:	40                   	inc    %eax
f010713d:	c1 e0 0f             	shl    $0xf,%eax
f0107140:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107145:	29 c2                	sub    %eax,%edx
f0107147:	89 d0                	mov    %edx,%eax
f0107149:	89 c2                	mov    %eax,%edx
f010714b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010714e:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f0107151:	e8 18 01 00 00       	call   f010726e <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107156:	e8 49 50 00 00       	call   f010c1a4 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f010715b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715e:	83 c0 0c             	add    $0xc,%eax
f0107161:	83 ec 04             	sub    $0x4,%esp
f0107164:	6a 68                	push   $0x68
f0107166:	6a 00                	push   $0x0
f0107168:	50                   	push   %eax
f0107169:	e8 8c b4 01 00       	call   f01225fa <memset>
f010716e:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f0107171:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107174:	05 a4 00 00 00       	add    $0xa4,%eax
f0107179:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010717c:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f0107183:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107186:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107189:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010718c:	f0 87 02             	lock xchg %eax,(%edx)
f010718f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f0107192:	90                   	nop
f0107193:	c9                   	leave  
f0107194:	c3                   	ret    

f0107195 <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f0107195:	55                   	push   %ebp
f0107196:	89 e5                	mov    %esp,%ebp
f0107198:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010719b:	9c                   	pushf  
f010719c:	58                   	pop    %eax
f010719d:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f01071a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f01071a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01071a6:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f01071a7:	e8 26 ff ff ff       	call   f01070d2 <mycpu>
f01071ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f01071af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071b2:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071b8:	85 c0                	test   %eax,%eax
f01071ba:	75 13                	jne    f01071cf <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f01071bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01071bf:	25 00 02 00 00       	and    $0x200,%eax
f01071c4:	89 c2                	mov    %eax,%edx
f01071c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071c9:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f01071cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071d2:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071d8:	8d 50 01             	lea    0x1(%eax),%edx
f01071db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071de:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f01071e4:	90                   	nop
f01071e5:	c9                   	leave  
f01071e6:	c3                   	ret    

f01071e7 <popcli>:

void popcli(void)
{
f01071e7:	55                   	push   %ebp
f01071e8:	89 e5                	mov    %esp,%ebp
f01071ea:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01071ed:	9c                   	pushf  
f01071ee:	58                   	pop    %eax
f01071ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f01071f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f01071f5:	25 00 02 00 00       	and    $0x200,%eax
f01071fa:	85 c0                	test   %eax,%eax
f01071fc:	74 14                	je     f0107212 <popcli+0x2b>
    panic("popcli - interruptible");
f01071fe:	83 ec 04             	sub    $0x4,%esp
f0107201:	68 85 79 12 f0       	push   $0xf0127985
f0107206:	6a 5e                	push   $0x5e
f0107208:	68 9c 79 12 f0       	push   $0xf012799c
f010720d:	e8 08 91 ff ff       	call   f010031a <_panic>
  struct cpu* c = mycpu();
f0107212:	e8 bb fe ff ff       	call   f01070d2 <mycpu>
f0107217:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f010721a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010721d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107223:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107226:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107229:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f010722f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107232:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107238:	85 c0                	test   %eax,%eax
f010723a:	79 14                	jns    f0107250 <popcli+0x69>
    panic("popcli");
f010723c:	83 ec 04             	sub    $0x4,%esp
f010723f:	68 ab 79 12 f0       	push   $0xf01279ab
f0107244:	6a 61                	push   $0x61
f0107246:	68 9c 79 12 f0       	push   $0xf012799c
f010724b:	e8 ca 90 ff ff       	call   f010031a <_panic>
  if(c->ncli == 0 && c->intena)
f0107250:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107253:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107259:	85 c0                	test   %eax,%eax
f010725b:	75 0e                	jne    f010726b <popcli+0x84>
f010725d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107260:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0107266:	85 c0                	test   %eax,%eax
f0107268:	74 01                	je     f010726b <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010726a:	fb                   	sti    
    sti();
}
f010726b:	90                   	nop
f010726c:	c9                   	leave  
f010726d:	c3                   	ret    

f010726e <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f010726e:	55                   	push   %ebp
f010726f:	89 e5                	mov    %esp,%ebp
f0107271:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f0107274:	e8 1c ff ff ff       	call   f0107195 <pushcli>

	c = mycpu();
f0107279:	e8 54 fe ff ff       	call   f01070d2 <mycpu>
f010727e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f0107281:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107284:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f010728b:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f0107292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107295:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f010729b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010729e:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f01072a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072a7:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f01072ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072b1:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072b7:	83 e2 f0             	and    $0xfffffff0,%edx
f01072ba:	83 ca 0a             	or     $0xa,%edx
f01072bd:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072c6:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072cc:	83 ca 10             	or     $0x10,%edx
f01072cf:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072d8:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072de:	83 e2 9f             	and    $0xffffff9f,%edx
f01072e1:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072ea:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072f0:	83 ca 80             	or     $0xffffff80,%edx
f01072f3:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072fc:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107302:	83 ca 0f             	or     $0xf,%edx
f0107305:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010730b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010730e:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107314:	83 e2 ef             	and    $0xffffffef,%edx
f0107317:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010731d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107320:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107326:	83 e2 df             	and    $0xffffffdf,%edx
f0107329:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010732f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107332:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107338:	83 ca 40             	or     $0x40,%edx
f010733b:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107341:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107344:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010734a:	83 ca 80             	or     $0xffffff80,%edx
f010734d:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107353:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107356:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f010735d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107360:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f0107367:	ff ff 
f0107369:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010736c:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f0107373:	00 00 
f0107375:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107378:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f010737f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107382:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107388:	83 e2 f0             	and    $0xfffffff0,%edx
f010738b:	83 ca 02             	or     $0x2,%edx
f010738e:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107394:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107397:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010739d:	83 ca 10             	or     $0x10,%edx
f01073a0:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073a9:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073af:	83 e2 9f             	and    $0xffffff9f,%edx
f01073b2:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073bb:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073c1:	83 ca 80             	or     $0xffffff80,%edx
f01073c4:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073cd:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073d3:	83 ca 0f             	or     $0xf,%edx
f01073d6:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073df:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073e5:	83 e2 ef             	and    $0xffffffef,%edx
f01073e8:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f1:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073f7:	83 e2 df             	and    $0xffffffdf,%edx
f01073fa:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107400:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107403:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107409:	83 ca 40             	or     $0x40,%edx
f010740c:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107412:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107415:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010741b:	83 ca 80             	or     $0xffffff80,%edx
f010741e:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107424:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107427:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f010742e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107431:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107438:	ff ff 
f010743a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010743d:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f0107444:	00 00 
f0107446:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107449:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f0107450:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107453:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107459:	83 e2 f0             	and    $0xfffffff0,%edx
f010745c:	83 ca 0a             	or     $0xa,%edx
f010745f:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107465:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107468:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010746e:	83 ca 10             	or     $0x10,%edx
f0107471:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107477:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010747a:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107480:	83 ca 60             	or     $0x60,%edx
f0107483:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107489:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010748c:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107492:	83 ca 80             	or     $0xffffff80,%edx
f0107495:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f010749b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010749e:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074a4:	83 ca 0f             	or     $0xf,%edx
f01074a7:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b0:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074b6:	83 e2 ef             	and    $0xffffffef,%edx
f01074b9:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c2:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074c8:	83 e2 df             	and    $0xffffffdf,%edx
f01074cb:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d4:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074da:	83 ca 40             	or     $0x40,%edx
f01074dd:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074e6:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074ec:	83 ca 80             	or     $0xffffff80,%edx
f01074ef:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074f8:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f01074ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107502:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107509:	ff ff 
f010750b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010750e:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f0107515:	00 00 
f0107517:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010751a:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f0107521:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107524:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010752a:	83 e2 f0             	and    $0xfffffff0,%edx
f010752d:	83 ca 02             	or     $0x2,%edx
f0107530:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107536:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107539:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010753f:	83 ca 10             	or     $0x10,%edx
f0107542:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107548:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010754b:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107551:	83 ca 60             	or     $0x60,%edx
f0107554:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f010755a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010755d:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107563:	83 ca 80             	or     $0xffffff80,%edx
f0107566:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f010756c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010756f:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107575:	83 ca 0f             	or     $0xf,%edx
f0107578:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010757e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107581:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107587:	83 e2 ef             	and    $0xffffffef,%edx
f010758a:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107590:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107593:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107599:	83 e2 df             	and    $0xffffffdf,%edx
f010759c:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075a5:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075ab:	83 ca 40             	or     $0x40,%edx
f01075ae:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075b7:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075bd:	83 ca 80             	or     $0xffffff80,%edx
f01075c0:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075c9:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f01075d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075d3:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f01075da:	00 00 00 
f01075dd:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f01075e4:	00 00 00 

	popcli();	//enable interrupt
f01075e7:	e8 fb fb ff ff       	call   f01071e7 <popcli>


}
f01075ec:	90                   	nop
f01075ed:	c9                   	leave  
f01075ee:	c3                   	ret    

f01075ef <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f01075ef:	55                   	push   %ebp
f01075f0:	89 e5                	mov    %esp,%ebp
f01075f2:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f01075f5:	83 ec 08             	sub    $0x8,%esp
f01075f8:	68 00 10 00 00       	push   $0x1000
f01075fd:	68 00 10 00 00       	push   $0x1000
f0107602:	e8 35 02 00 00       	call   f010783c <boot_allocate_space>
f0107607:	83 c4 10             	add    $0x10,%esp
f010760a:	a3 7c 4a 5a f0       	mov    %eax,0xf05a4a7c
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f010760f:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0107614:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107617:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f010761e:	77 14                	ja     f0107634 <initialize_kernel_VM+0x45>
f0107620:	ff 75 e0             	pushl  -0x20(%ebp)
f0107623:	68 b4 79 12 f0       	push   $0xf01279b4
f0107628:	6a 57                	push   $0x57
f010762a:	68 e8 79 12 f0       	push   $0xf01279e8
f010762f:	e8 e6 8c ff ff       	call   f010031a <_panic>
f0107634:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107637:	05 00 00 00 10       	add    $0x10000000,%eax
f010763c:	a3 84 4b 5a f0       	mov    %eax,0xf05a4b84
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f0107641:	c7 45 dc 00 80 17 f0 	movl   $0xf0178000,-0x24(%ebp)
f0107648:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f010764f:	77 14                	ja     f0107665 <initialize_kernel_VM+0x76>
f0107651:	ff 75 dc             	pushl  -0x24(%ebp)
f0107654:	68 b4 79 12 f0       	push   $0xf01279b4
f0107659:	6a 63                	push   $0x63
f010765b:	68 e8 79 12 f0       	push   $0xf01279e8
f0107660:	e8 b5 8c ff ff       	call   f010031a <_panic>
f0107665:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107668:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f010766e:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0107673:	83 ec 0c             	sub    $0xc,%esp
f0107676:	6a 02                	push   $0x2
f0107678:	52                   	push   %edx
f0107679:	68 00 80 00 00       	push   $0x8000
f010767e:	68 00 80 bf ef       	push   $0xefbf8000
f0107683:	50                   	push   %eax
f0107684:	e8 27 02 00 00       	call   f01078b0 <boot_map_range>
f0107689:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f010768c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107693:	eb 24                	jmp    f01076b9 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f0107695:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107698:	40                   	inc    %eax
f0107699:	c1 e0 0f             	shl    $0xf,%eax
f010769c:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01076a1:	29 c2                	sub    %eax,%edx
f01076a3:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f01076a8:	6a 01                	push   $0x1
f01076aa:	6a 00                	push   $0x0
f01076ac:	52                   	push   %edx
f01076ad:	50                   	push   %eax
f01076ae:	e8 4a 14 00 00       	call   f0108afd <pt_set_page_permissions>
f01076b3:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076b6:	ff 45 f4             	incl   -0xc(%ebp)
f01076b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01076bd:	7e d6                	jle    f0107695 <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f01076bf:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f01076c6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f01076cd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f01076d4:	eb 25                	jmp    f01076fb <initialize_kernel_VM+0x10c>
	{
		++nTables;
f01076d6:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f01076d9:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01076dc:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f01076e1:	83 ec 04             	sub    $0x4,%esp
f01076e4:	6a 01                	push   $0x1
f01076e6:	52                   	push   %edx
f01076e7:	50                   	push   %eax
f01076e8:	e8 37 02 00 00       	call   f0107924 <boot_get_page_table>
f01076ed:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f01076f0:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f01076f7:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f01076fb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01076ff:	72 d5                	jb     f01076d6 <initialize_kernel_VM+0xe7>
f0107701:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107705:	77 06                	ja     f010770d <initialize_kernel_VM+0x11e>
f0107707:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f010770b:	76 c9                	jbe    f01076d6 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f010770d:	8b 15 58 46 5a f0    	mov    0xf05a4658,%edx
f0107713:	89 d0                	mov    %edx,%eax
f0107715:	01 c0                	add    %eax,%eax
f0107717:	01 d0                	add    %edx,%eax
f0107719:	c1 e0 03             	shl    $0x3,%eax
f010771c:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f010771f:	83 ec 08             	sub    $0x8,%esp
f0107722:	68 00 10 00 00       	push   $0x1000
f0107727:	ff 75 d8             	pushl  -0x28(%ebp)
f010772a:	e8 0d 01 00 00       	call   f010783c <boot_allocate_space>
f010772f:	83 c4 10             	add    $0x10,%esp
f0107732:	a3 c0 48 5a f0       	mov    %eax,0xf05a48c0
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107737:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f010773e:	83 ec 08             	sub    $0x8,%esp
f0107741:	68 00 10 00 00       	push   $0x1000
f0107746:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107749:	e8 ee 00 00 00       	call   f010783c <boot_allocate_space>
f010774e:	83 c4 10             	add    $0x10,%esp
f0107751:	a3 60 1c 5a f0       	mov    %eax,0xf05a1c60
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107756:	e8 32 05 00 00       	call   f0107c8d <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f010775b:	83 ec 0c             	sub    $0xc,%esp
f010775e:	6a 08                	push   $0x8
f0107760:	e8 ff 92 01 00       	call   f0120a64 <nearest_pow2_ceil>
f0107765:	83 c4 10             	add    $0x10,%esp
f0107768:	83 ec 04             	sub    $0x4,%esp
f010776b:	50                   	push   %eax
f010776c:	6a 08                	push   $0x8
f010776e:	68 08 7a 12 f0       	push   $0xf0127a08
f0107773:	e8 f4 97 ff ff       	call   f0100f6c <cprintf>
f0107778:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f010777b:	c7 45 d0 60 d3 0e 00 	movl   $0xed360,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0107782:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107785:	83 ec 08             	sub    $0x8,%esp
f0107788:	68 00 10 00 00       	push   $0x1000
f010778d:	50                   	push   %eax
f010778e:	e8 a9 00 00 00       	call   f010783c <boot_allocate_space>
f0107793:	83 c4 10             	add    $0x10,%esp
f0107796:	a3 b0 13 5a f0       	mov    %eax,0xf05a13b0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f010779b:	a1 b0 13 5a f0       	mov    0xf05a13b0,%eax
f01077a0:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01077a3:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f01077aa:	77 17                	ja     f01077c3 <initialize_kernel_VM+0x1d4>
f01077ac:	ff 75 cc             	pushl  -0x34(%ebp)
f01077af:	68 b4 79 12 f0       	push   $0xf01279b4
f01077b4:	68 b1 00 00 00       	push   $0xb1
f01077b9:	68 e8 79 12 f0       	push   $0xf01279e8
f01077be:	e8 57 8b ff ff       	call   f010031a <_panic>
f01077c3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01077c6:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01077cc:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01077cf:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f01077d4:	83 ec 0c             	sub    $0xc,%esp
f01077d7:	6a 04                	push   $0x4
f01077d9:	51                   	push   %ecx
f01077da:	52                   	push   %edx
f01077db:	68 00 00 c0 ee       	push   $0xeec00000
f01077e0:	50                   	push   %eax
f01077e1:	e8 ca 00 00 00       	call   f01078b0 <boot_map_range>
f01077e6:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f01077e9:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f01077ee:	05 ec 0e 00 00       	add    $0xeec,%eax
f01077f3:	8b 15 7c 4a 5a f0    	mov    0xf05a4a7c,%edx
f01077f9:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f01077ff:	8b 12                	mov    (%edx),%edx
f0107801:	83 ca 05             	or     $0x5,%edx
f0107804:	89 10                	mov    %edx,(%eax)
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#else
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107806:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f010780b:	83 ec 0c             	sub    $0xc,%esp
f010780e:	6a 02                	push   $0x2
f0107810:	6a 00                	push   $0x0
f0107812:	68 ff ff ff 0f       	push   $0xfffffff
f0107817:	68 00 00 00 f0       	push   $0xf0000000
f010781c:	50                   	push   %eax
f010781d:	e8 8e 00 00 00       	call   f01078b0 <boot_map_range>
f0107822:	83 c4 20             	add    $0x20,%esp
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f0107825:	e8 1c a1 01 00       	call   f0121946 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f010782a:	c7 05 80 45 5a f0 19 	movl   $0x19,0xf05a4580
f0107831:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f0107834:	e8 20 03 00 00       	call   f0107b59 <turn_on_paging>
}
f0107839:	90                   	nop
f010783a:	c9                   	leave  
f010783b:	c3                   	ret    

f010783c <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f010783c:	55                   	push   %ebp
f010783d:	89 e5                	mov    %esp,%ebp
f010783f:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107842:	a1 78 4a 5a f0       	mov    0xf05a4a78,%eax
f0107847:	85 c0                	test   %eax,%eax
f0107849:	75 0a                	jne    f0107855 <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f010784b:	c7 05 78 4a 5a f0 30 	movl   $0xf05c7430,0xf05a4a78
f0107852:	74 5c f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f0107855:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107858:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010785b:	a1 78 4a 5a f0       	mov    0xf05a4a78,%eax
f0107860:	89 c2                	mov    %eax,%edx
f0107862:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107865:	01 d0                	add    %edx,%eax
f0107867:	48                   	dec    %eax
f0107868:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010786b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010786e:	ba 00 00 00 00       	mov    $0x0,%edx
f0107873:	f7 75 f4             	divl   -0xc(%ebp)
f0107876:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107879:	29 d0                	sub    %edx,%eax
f010787b:	a3 78 4a 5a f0       	mov    %eax,0xf05a4a78

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f0107880:	a1 78 4a 5a f0       	mov    0xf05a4a78,%eax
f0107885:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f0107888:	8b 15 78 4a 5a f0    	mov    0xf05a4a78,%edx
f010788e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107891:	01 d0                	add    %edx,%eax
f0107893:	a3 78 4a 5a f0       	mov    %eax,0xf05a4a78

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f0107898:	83 ec 04             	sub    $0x4,%esp
f010789b:	ff 75 08             	pushl  0x8(%ebp)
f010789e:	6a 00                	push   $0x0
f01078a0:	ff 75 ec             	pushl  -0x14(%ebp)
f01078a3:	e8 52 ad 01 00       	call   f01225fa <memset>
f01078a8:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01078ab:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f01078ae:	c9                   	leave  
f01078af:	c3                   	ret    

f01078b0 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01078b0:	55                   	push   %ebp
f01078b1:	89 e5                	mov    %esp,%ebp
f01078b3:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01078b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f01078bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01078c4:	eb 53                	jmp    f0107919 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f01078c6:	83 ec 04             	sub    $0x4,%esp
f01078c9:	6a 01                	push   $0x1
f01078cb:	ff 75 0c             	pushl  0xc(%ebp)
f01078ce:	ff 75 08             	pushl  0x8(%ebp)
f01078d1:	e8 4e 00 00 00       	call   f0107924 <boot_get_page_table>
f01078d6:	83 c4 10             	add    $0x10,%esp
f01078d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f01078dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01078df:	c1 e8 0c             	shr    $0xc,%eax
f01078e2:	25 ff 03 00 00       	and    $0x3ff,%eax
f01078e7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f01078ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01078ed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01078f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078f7:	01 c2                	add    %eax,%edx
f01078f9:	8b 45 18             	mov    0x18(%ebp),%eax
f01078fc:	0b 45 14             	or     0x14(%ebp),%eax
f01078ff:	83 c8 01             	or     $0x1,%eax
f0107902:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f0107904:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f010790b:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107912:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107919:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010791c:	3b 45 10             	cmp    0x10(%ebp),%eax
f010791f:	72 a5                	jb     f01078c6 <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0107921:	90                   	nop
f0107922:	c9                   	leave  
f0107923:	c3                   	ret    

f0107924 <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f0107924:	55                   	push   %ebp
f0107925:	89 e5                	mov    %esp,%ebp
f0107927:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f010792a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010792d:	c1 e8 16             	shr    $0x16,%eax
f0107930:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f0107933:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107936:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010793d:	8b 45 08             	mov    0x8(%ebp),%eax
f0107940:	01 d0                	add    %edx,%eax
f0107942:	8b 00                	mov    (%eax),%eax
f0107944:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f0107947:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010794a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010794f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0107952:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107955:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0107958:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010795b:	c1 e8 0c             	shr    $0xc,%eax
f010795e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107961:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0107966:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0107969:	72 17                	jb     f0107982 <boot_get_page_table+0x5e>
f010796b:	ff 75 e8             	pushl  -0x18(%ebp)
f010796e:	68 30 7a 12 f0       	push   $0xf0127a30
f0107973:	68 33 01 00 00       	push   $0x133
f0107978:	68 e8 79 12 f0       	push   $0xf01279e8
f010797d:	e8 98 89 ff ff       	call   f010031a <_panic>
f0107982:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107985:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010798a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f010798d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107991:	75 72                	jne    f0107a05 <boot_get_page_table+0xe1>
	{
		if (create)
f0107993:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0107997:	74 65                	je     f01079fe <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f0107999:	83 ec 08             	sub    $0x8,%esp
f010799c:	68 00 10 00 00       	push   $0x1000
f01079a1:	68 00 10 00 00       	push   $0x1000
f01079a6:	e8 91 fe ff ff       	call   f010783c <boot_allocate_space>
f01079ab:	83 c4 10             	add    $0x10,%esp
f01079ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01079b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079b4:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01079b7:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01079be:	77 17                	ja     f01079d7 <boot_get_page_table+0xb3>
f01079c0:	ff 75 dc             	pushl  -0x24(%ebp)
f01079c3:	68 b4 79 12 f0       	push   $0xf01279b4
f01079c8:	68 39 01 00 00       	push   $0x139
f01079cd:	68 e8 79 12 f0       	push   $0xf01279e8
f01079d2:	e8 43 89 ff ff       	call   f010031a <_panic>
f01079d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01079da:	05 00 00 00 10       	add    $0x10000000,%eax
f01079df:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f01079e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01079ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01079ef:	01 d0                	add    %edx,%eax
f01079f1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01079f4:	83 ca 03             	or     $0x3,%edx
f01079f7:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f01079f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079fc:	eb 0a                	jmp    f0107a08 <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f01079fe:	b8 00 00 00 00       	mov    $0x0,%eax
f0107a03:	eb 03                	jmp    f0107a08 <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107a05:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107a08:	c9                   	leave  
f0107a09:	c3                   	ret    

f0107a0a <nvram_read>:


int nvram_read(int r)
{
f0107a0a:	55                   	push   %ebp
f0107a0b:	89 e5                	mov    %esp,%ebp
f0107a0d:	53                   	push   %ebx
f0107a0e:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107a11:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a14:	83 ec 0c             	sub    $0xc,%esp
f0107a17:	50                   	push   %eax
f0107a18:	e8 12 d1 ff ff       	call   f0104b2f <mc146818_read>
f0107a1d:	83 c4 10             	add    $0x10,%esp
f0107a20:	89 c3                	mov    %eax,%ebx
f0107a22:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a25:	40                   	inc    %eax
f0107a26:	83 ec 0c             	sub    $0xc,%esp
f0107a29:	50                   	push   %eax
f0107a2a:	e8 00 d1 ff ff       	call   f0104b2f <mc146818_read>
f0107a2f:	83 c4 10             	add    $0x10,%esp
f0107a32:	c1 e0 08             	shl    $0x8,%eax
f0107a35:	09 d8                	or     %ebx,%eax
}
f0107a37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107a3a:	c9                   	leave  
f0107a3b:	c3                   	ret    

f0107a3c <detect_memory>:

void detect_memory()
{
f0107a3c:	55                   	push   %ebp
f0107a3d:	89 e5                	mov    %esp,%ebp
f0107a3f:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107a42:	83 ec 0c             	sub    $0xc,%esp
f0107a45:	6a 15                	push   $0x15
f0107a47:	e8 be ff ff ff       	call   f0107a0a <nvram_read>
f0107a4c:	83 c4 10             	add    $0x10,%esp
f0107a4f:	c1 e0 0a             	shl    $0xa,%eax
f0107a52:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a55:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a58:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107a60:	83 ec 0c             	sub    $0xc,%esp
f0107a63:	6a 17                	push   $0x17
f0107a65:	e8 a0 ff ff ff       	call   f0107a0a <nvram_read>
f0107a6a:	83 c4 10             	add    $0x10,%esp
f0107a6d:	c1 e0 0a             	shl    $0xa,%eax
f0107a70:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107a73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107a76:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107a7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107a7e:	83 ec 0c             	sub    $0xc,%esp
f0107a81:	6a 34                	push   $0x34
f0107a83:	e8 82 ff ff ff       	call   f0107a0a <nvram_read>
f0107a88:	83 c4 10             	add    $0x10,%esp
f0107a8b:	c1 e0 10             	shl    $0x10,%eax
f0107a8e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107a91:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a94:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107a99:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107a9c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107aa0:	74 18                	je     f0107aba <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107aa2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107aa5:	05 00 00 00 01       	add    $0x1000000,%eax
f0107aaa:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107aad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ab0:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107ab5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107ab8:	eb 19                	jmp    f0107ad3 <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107aba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107abe:	74 0d                	je     f0107acd <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107ac0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107ac3:	05 00 00 10 00       	add    $0x100000,%eax
f0107ac8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107acb:	eb 06                	jmp    f0107ad3 <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107acd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107ad0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107ad3:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	if(USE_KHEAP == 0 && maxpa > kernel_virtual_area)
f0107ada:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107add:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0107ae0:	76 32                	jbe    f0107b14 <detect_memory+0xd8>
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
f0107ae2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0107ae5:	c1 e8 0a             	shr    $0xa,%eax
f0107ae8:	89 c2                	mov    %eax,%edx
f0107aea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107aed:	c1 e8 0a             	shr    $0xa,%eax
f0107af0:	83 ec 04             	sub    $0x4,%esp
f0107af3:	52                   	push   %edx
f0107af4:	50                   	push   %eax
f0107af5:	68 60 7a 12 f0       	push   $0xf0127a60
f0107afa:	e8 6d 94 ff ff       	call   f0100f6c <cprintf>
f0107aff:	83 c4 10             	add    $0x10,%esp
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
f0107b02:	83 ec 0c             	sub    $0xc,%esp
f0107b05:	68 a8 7a 12 f0       	push   $0xf0127aa8
f0107b0a:	e8 5d 94 ff ff       	call   f0100f6c <cprintf>
f0107b0f:	83 c4 10             	add    $0x10,%esp
		while(1);
f0107b12:	eb fe                	jmp    f0107b12 <detect_memory+0xd6>
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107b14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b17:	c1 e8 0c             	shr    $0xc,%eax
f0107b1a:	a3 58 46 5a f0       	mov    %eax,0xf05a4658

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107b1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b22:	c1 e8 0a             	shr    $0xa,%eax
f0107b25:	83 ec 08             	sub    $0x8,%esp
f0107b28:	50                   	push   %eax
f0107b29:	68 40 7b 12 f0       	push   $0xf0127b40
f0107b2e:	e8 39 94 ff ff       	call   f0100f6c <cprintf>
f0107b33:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107b36:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b39:	c1 e8 0a             	shr    $0xa,%eax
f0107b3c:	89 c2                	mov    %eax,%edx
f0107b3e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107b41:	c1 e8 0a             	shr    $0xa,%eax
f0107b44:	83 ec 04             	sub    $0x4,%esp
f0107b47:	52                   	push   %edx
f0107b48:	50                   	push   %eax
f0107b49:	68 63 7b 12 f0       	push   $0xf0127b63
f0107b4e:	e8 19 94 ff ff       	call   f0100f6c <cprintf>
f0107b53:	83 c4 10             	add    $0x10,%esp
}
f0107b56:	90                   	nop
f0107b57:	c9                   	leave  
f0107b58:	c3                   	ret    

f0107b59 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107b59:	55                   	push   %ebp
f0107b5a:	89 e5                	mov    %esp,%ebp
f0107b5c:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107b5f:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107b66:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b6d:	eb 24                	jmp    f0107b93 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107b6f:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0107b74:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107b77:	c1 e2 02             	shl    $0x2,%edx
f0107b7a:	01 c2                	add    %eax,%edx
f0107b7c:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0107b81:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107b84:	c1 e1 02             	shl    $0x2,%ecx
f0107b87:	01 c8                	add    %ecx,%eax
f0107b89:	8b 00                	mov    (%eax),%eax
f0107b8b:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b8d:	ff 45 f4             	incl   -0xc(%ebp)
f0107b90:	ff 45 f0             	incl   -0x10(%ebp)
f0107b93:	a1 78 4a 5a f0       	mov    0xf05a4a78,%eax
f0107b98:	c1 e8 16             	shr    $0x16,%eax
f0107b9b:	89 c2                	mov    %eax,%edx
f0107b9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ba0:	39 c2                	cmp    %eax,%edx
f0107ba2:	77 cb                	ja     f0107b6f <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107ba4:	a1 84 4b 5a f0       	mov    0xf05a4b84,%eax
f0107ba9:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107bac:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107baf:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107bb2:	0f 20 c0             	mov    %cr0,%eax
f0107bb5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107bb8:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107bbb:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107bbe:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107bc5:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107bc9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107bcc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107bcf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107bd2:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107bd5:	e8 bb f5 ff ff       	call   f0107195 <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107bda:	e8 f3 f4 ff ff       	call   f01070d2 <mycpu>
f0107bdf:	83 c0 74             	add    $0x74,%eax
f0107be2:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107be5:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107bec:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107bef:	48                   	dec    %eax
f0107bf0:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107bf4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107bf7:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107bfb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107bfe:	c1 e8 10             	shr    $0x10,%eax
f0107c01:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107c05:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107c08:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107c0b:	e8 d7 f5 ff ff       	call   f01071e7 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107c10:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c15:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107c17:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c1c:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107c1e:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c23:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107c25:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c2a:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107c2c:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c31:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107c33:	ea 3a 7c 10 f0 08 00 	ljmp   $0x8,$0xf0107c3a
	asm volatile("lldt %%ax" :: "a" (0));
f0107c3a:	b8 00 00 00 00       	mov    $0x0,%eax
f0107c3f:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107c42:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107c49:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c50:	eb 19                	jmp    f0107c6b <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107c52:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0107c57:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107c5a:	c1 e2 02             	shl    $0x2,%edx
f0107c5d:	01 d0                	add    %edx,%eax
f0107c5f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c65:	ff 45 ec             	incl   -0x14(%ebp)
f0107c68:	ff 45 e8             	incl   -0x18(%ebp)
f0107c6b:	a1 78 4a 5a f0       	mov    0xf05a4a78,%eax
f0107c70:	c1 e8 16             	shr    $0x16,%eax
f0107c73:	89 c2                	mov    %eax,%edx
f0107c75:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c78:	39 c2                	cmp    %eax,%edx
f0107c7a:	77 d6                	ja     f0107c52 <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107c7c:	a1 84 4b 5a f0       	mov    0xf05a4b84,%eax
f0107c81:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107c84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107c87:	0f 22 d8             	mov    %eax,%cr3

}
f0107c8a:	90                   	nop
f0107c8b:	c9                   	leave  
f0107c8c:	c3                   	ret    

f0107c8d <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107c8d:	55                   	push   %ebp
f0107c8e:	89 e5                	mov    %esp,%ebp
f0107c90:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107c93:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0107c98:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107c9b:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107ca2:	77 17                	ja     f0107cbb <setup_listing_to_all_page_tables_entries+0x2e>
f0107ca4:	ff 75 f4             	pushl  -0xc(%ebp)
f0107ca7:	68 b4 79 12 f0       	push   $0xf01279b4
f0107cac:	68 cf 01 00 00       	push   $0x1cf
f0107cb1:	68 e8 79 12 f0       	push   $0xf01279e8
f0107cb6:	e8 5f 86 ff ff       	call   f010031a <_panic>
f0107cbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107cbe:	05 00 00 00 10       	add    $0x10000000,%eax
f0107cc3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107cc6:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0107ccb:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107cd0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107cd3:	83 ca 03             	or     $0x3,%edx
f0107cd6:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107cd8:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0107cdd:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107ce3:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0107ce8:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107ceb:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107cf2:	77 17                	ja     f0107d0b <setup_listing_to_all_page_tables_entries+0x7e>
f0107cf4:	ff 75 ec             	pushl  -0x14(%ebp)
f0107cf7:	68 b4 79 12 f0       	push   $0xf01279b4
f0107cfc:	68 d4 01 00 00       	push   $0x1d4
f0107d01:	68 e8 79 12 f0       	push   $0xf01279e8
f0107d06:	e8 0f 86 ff ff       	call   f010031a <_panic>
f0107d0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107d0e:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d13:	83 c8 05             	or     $0x5,%eax
f0107d16:	89 02                	mov    %eax,(%edx)

}
f0107d18:	90                   	nop
f0107d19:	c9                   	leave  
f0107d1a:	c3                   	ret    

f0107d1b <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107d1b:	55                   	push   %ebp
f0107d1c:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107d1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d21:	8b 15 c0 48 5a f0    	mov    0xf05a48c0,%edx
f0107d27:	29 d0                	sub    %edx,%eax
f0107d29:	c1 f8 03             	sar    $0x3,%eax
f0107d2c:	89 c2                	mov    %eax,%edx
f0107d2e:	89 d0                	mov    %edx,%eax
f0107d30:	c1 e0 02             	shl    $0x2,%eax
f0107d33:	01 d0                	add    %edx,%eax
f0107d35:	c1 e0 02             	shl    $0x2,%eax
f0107d38:	01 d0                	add    %edx,%eax
f0107d3a:	c1 e0 02             	shl    $0x2,%eax
f0107d3d:	01 d0                	add    %edx,%eax
f0107d3f:	89 c1                	mov    %eax,%ecx
f0107d41:	c1 e1 08             	shl    $0x8,%ecx
f0107d44:	01 c8                	add    %ecx,%eax
f0107d46:	89 c1                	mov    %eax,%ecx
f0107d48:	c1 e1 10             	shl    $0x10,%ecx
f0107d4b:	01 c8                	add    %ecx,%eax
f0107d4d:	01 c0                	add    %eax,%eax
f0107d4f:	01 d0                	add    %edx,%eax
}
f0107d51:	5d                   	pop    %ebp
f0107d52:	c3                   	ret    

f0107d53 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107d53:	55                   	push   %ebp
f0107d54:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107d56:	ff 75 08             	pushl  0x8(%ebp)
f0107d59:	e8 bd ff ff ff       	call   f0107d1b <to_frame_number>
f0107d5e:	83 c4 04             	add    $0x4,%esp
f0107d61:	c1 e0 0c             	shl    $0xc,%eax
}
f0107d64:	c9                   	leave  
f0107d65:	c3                   	ret    

f0107d66 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107d66:	55                   	push   %ebp
f0107d67:	89 e5                	mov    %esp,%ebp
f0107d69:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107d6c:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d6f:	c1 e8 0c             	shr    $0xc,%eax
f0107d72:	89 c2                	mov    %eax,%edx
f0107d74:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0107d79:	39 c2                	cmp    %eax,%edx
f0107d7b:	72 14                	jb     f0107d91 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107d7d:	83 ec 04             	sub    $0x4,%esp
f0107d80:	68 80 7b 12 f0       	push   $0xf0127b80
f0107d85:	6a 55                	push   $0x55
f0107d87:	68 a5 7b 12 f0       	push   $0xf0127ba5
f0107d8c:	e8 89 85 ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f0107d91:	8b 15 c0 48 5a f0    	mov    0xf05a48c0,%edx
f0107d97:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d9a:	c1 e8 0c             	shr    $0xc,%eax
f0107d9d:	89 c1                	mov    %eax,%ecx
f0107d9f:	89 c8                	mov    %ecx,%eax
f0107da1:	01 c0                	add    %eax,%eax
f0107da3:	01 c8                	add    %ecx,%eax
f0107da5:	c1 e0 03             	shl    $0x3,%eax
f0107da8:	01 d0                	add    %edx,%eax
}
f0107daa:	c9                   	leave  
f0107dab:	c3                   	ret    

f0107dac <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107dac:	55                   	push   %ebp
f0107dad:	89 e5                	mov    %esp,%ebp
f0107daf:	83 ec 10             	sub    $0x10,%esp
f0107db2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107db5:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107db8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107dbb:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107dbe:	90                   	nop
f0107dbf:	c9                   	leave  
f0107dc0:	c3                   	ret    

f0107dc1 <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107dc1:	55                   	push   %ebp
f0107dc2:	89 e5                	mov    %esp,%ebp
f0107dc4:	53                   	push   %ebx
f0107dc5:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107dc8:	c7 05 c0 1e 5a f0 00 	movl   $0x0,0xf05a1ec0
f0107dcf:	00 00 00 
f0107dd2:	c7 05 c4 1e 5a f0 00 	movl   $0x0,0xf05a1ec4
f0107dd9:	00 00 00 
f0107ddc:	c7 05 cc 1e 5a f0 00 	movl   $0x0,0xf05a1ecc
f0107de3:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107de6:	c7 05 d0 1e 5a f0 00 	movl   $0x0,0xf05a1ed0
f0107ded:	00 00 00 
f0107df0:	c7 05 d4 1e 5a f0 00 	movl   $0x0,0xf05a1ed4
f0107df7:	00 00 00 
f0107dfa:	c7 05 dc 1e 5a f0 00 	movl   $0x0,0xf05a1edc
f0107e01:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107e04:	83 ec 08             	sub    $0x8,%esp
f0107e07:	68 bf 7b 12 f0       	push   $0xf0127bbf
f0107e0c:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f0107e11:	e8 ae 6c 00 00       	call   f010eac4 <init_spinlock>
f0107e16:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107e19:	a1 c0 48 5a f0       	mov    0xf05a48c0,%eax
f0107e1e:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107e24:	a1 c0 48 5a f0       	mov    0xf05a48c0,%eax
f0107e29:	83 c0 18             	add    $0x18,%eax
f0107e2c:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107e32:	a1 c0 48 5a f0       	mov    0xf05a48c0,%eax
f0107e37:	83 c0 30             	add    $0x30,%eax
f0107e3a:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107e40:	c7 05 54 49 5a f0 00 	movl   $0xf0001000,0xf05a4954
f0107e47:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107e4a:	c7 05 04 4b 5a f0 00 	movl   $0xf0002000,0xf05a4b04
f0107e51:	20 00 f0 
	i =0;
f0107e54:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107e5b:	eb 1f                	jmp    f0107e7c <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107e5d:	8b 15 54 49 5a f0    	mov    0xf05a4954,%edx
f0107e63:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e66:	01 d0                	add    %edx,%eax
f0107e68:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107e6b:	8b 15 04 4b 5a f0    	mov    0xf05a4b04,%edx
f0107e71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e74:	01 d0                	add    %edx,%eax
f0107e76:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107e79:	ff 45 f4             	incl   -0xc(%ebp)
f0107e7c:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107e83:	7e d8                	jle    f0107e5d <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107e85:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107e8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e8f:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107e94:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107e97:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107e9a:	ba 00 00 00 00       	mov    $0x0,%edx
f0107e9f:	f7 75 f0             	divl   -0x10(%ebp)
f0107ea2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ea5:	29 d0                	sub    %edx,%eax
f0107ea7:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107eaa:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107eb1:	e9 e8 00 00 00       	jmp    f0107f9e <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107eb6:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f0107ebc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ebf:	89 d0                	mov    %edx,%eax
f0107ec1:	01 c0                	add    %eax,%eax
f0107ec3:	01 d0                	add    %edx,%eax
f0107ec5:	c1 e0 03             	shl    $0x3,%eax
f0107ec8:	01 c8                	add    %ecx,%eax
f0107eca:	83 ec 0c             	sub    $0xc,%esp
f0107ecd:	50                   	push   %eax
f0107ece:	e8 b7 02 00 00       	call   f010818a <initialize_frame_info>
f0107ed3:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107ed6:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f0107edc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107edf:	89 d0                	mov    %edx,%eax
f0107ee1:	01 c0                	add    %eax,%eax
f0107ee3:	01 d0                	add    %edx,%eax
f0107ee5:	c1 e0 03             	shl    $0x3,%eax
f0107ee8:	01 c8                	add    %ecx,%eax
f0107eea:	85 c0                	test   %eax,%eax
f0107eec:	75 14                	jne    f0107f02 <initialize_paging+0x141>
f0107eee:	83 ec 04             	sub    $0x4,%esp
f0107ef1:	68 d0 7b 12 f0       	push   $0xf0127bd0
f0107ef6:	6a 60                	push   $0x60
f0107ef8:	68 f3 7b 12 f0       	push   $0xf0127bf3
f0107efd:	e8 18 84 ff ff       	call   f010031a <_panic>
f0107f02:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f0107f08:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f0b:	89 d0                	mov    %edx,%eax
f0107f0d:	01 c0                	add    %eax,%eax
f0107f0f:	01 d0                	add    %edx,%eax
f0107f11:	c1 e0 03             	shl    $0x3,%eax
f0107f14:	01 c8                	add    %ecx,%eax
f0107f16:	8b 15 c0 1e 5a f0    	mov    0xf05a1ec0,%edx
f0107f1c:	89 10                	mov    %edx,(%eax)
f0107f1e:	8b 00                	mov    (%eax),%eax
f0107f20:	85 c0                	test   %eax,%eax
f0107f22:	74 1f                	je     f0107f43 <initialize_paging+0x182>
f0107f24:	8b 15 c0 1e 5a f0    	mov    0xf05a1ec0,%edx
f0107f2a:	8b 1d c0 48 5a f0    	mov    0xf05a48c0,%ebx
f0107f30:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107f33:	89 c8                	mov    %ecx,%eax
f0107f35:	01 c0                	add    %eax,%eax
f0107f37:	01 c8                	add    %ecx,%eax
f0107f39:	c1 e0 03             	shl    $0x3,%eax
f0107f3c:	01 d8                	add    %ebx,%eax
f0107f3e:	89 42 04             	mov    %eax,0x4(%edx)
f0107f41:	eb 19                	jmp    f0107f5c <initialize_paging+0x19b>
f0107f43:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f0107f49:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f4c:	89 d0                	mov    %edx,%eax
f0107f4e:	01 c0                	add    %eax,%eax
f0107f50:	01 d0                	add    %edx,%eax
f0107f52:	c1 e0 03             	shl    $0x3,%eax
f0107f55:	01 c8                	add    %ecx,%eax
f0107f57:	a3 c4 1e 5a f0       	mov    %eax,0xf05a1ec4
f0107f5c:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f0107f62:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f65:	89 d0                	mov    %edx,%eax
f0107f67:	01 c0                	add    %eax,%eax
f0107f69:	01 d0                	add    %edx,%eax
f0107f6b:	c1 e0 03             	shl    $0x3,%eax
f0107f6e:	01 c8                	add    %ecx,%eax
f0107f70:	a3 c0 1e 5a f0       	mov    %eax,0xf05a1ec0
f0107f75:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f0107f7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f7e:	89 d0                	mov    %edx,%eax
f0107f80:	01 c0                	add    %eax,%eax
f0107f82:	01 d0                	add    %edx,%eax
f0107f84:	c1 e0 03             	shl    $0x3,%eax
f0107f87:	01 c8                	add    %ecx,%eax
f0107f89:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107f90:	a1 cc 1e 5a f0       	mov    0xf05a1ecc,%eax
f0107f95:	40                   	inc    %eax
f0107f96:	a3 cc 1e 5a f0       	mov    %eax,0xf05a1ecc
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107f9b:	ff 45 f4             	incl   -0xc(%ebp)
f0107f9e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107fa1:	85 c0                	test   %eax,%eax
f0107fa3:	79 05                	jns    f0107faa <initialize_paging+0x1e9>
f0107fa5:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107faa:	c1 f8 0c             	sar    $0xc,%eax
f0107fad:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107fb0:	0f 8f 00 ff ff ff    	jg     f0107eb6 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fb6:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107fbd:	eb 1d                	jmp    f0107fdc <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107fbf:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f0107fc5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fc8:	89 d0                	mov    %edx,%eax
f0107fca:	01 c0                	add    %eax,%eax
f0107fcc:	01 d0                	add    %edx,%eax
f0107fce:	c1 e0 03             	shl    $0x3,%eax
f0107fd1:	01 c8                	add    %ecx,%eax
f0107fd3:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fd9:	ff 45 f4             	incl   -0xc(%ebp)
f0107fdc:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107fe3:	7e da                	jle    f0107fbf <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107fe5:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107fec:	a1 78 4a 5a f0       	mov    0xf05a4a78,%eax
f0107ff1:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107ff4:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107ffb:	77 14                	ja     f0108011 <initialize_paging+0x250>
f0107ffd:	ff 75 e0             	pushl  -0x20(%ebp)
f0108000:	68 10 7c 12 f0       	push   $0xf0127c10
f0108005:	6a 68                	push   $0x68
f0108007:	68 f3 7b 12 f0       	push   $0xf0127bf3
f010800c:	e8 09 83 ff ff       	call   f010031a <_panic>
f0108011:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108014:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f010801a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010801d:	01 d0                	add    %edx,%eax
f010801f:	48                   	dec    %eax
f0108020:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108023:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108026:	ba 00 00 00 00       	mov    $0x0,%edx
f010802b:	f7 75 e4             	divl   -0x1c(%ebp)
f010802e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108031:	29 d0                	sub    %edx,%eax
f0108033:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108036:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f010803d:	eb 1d                	jmp    f010805c <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f010803f:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f0108045:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108048:	89 d0                	mov    %edx,%eax
f010804a:	01 c0                	add    %eax,%eax
f010804c:	01 d0                	add    %edx,%eax
f010804e:	c1 e0 03             	shl    $0x3,%eax
f0108051:	01 c8                	add    %ecx,%eax
f0108053:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108059:	ff 45 f4             	incl   -0xc(%ebp)
f010805c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010805f:	85 c0                	test   %eax,%eax
f0108061:	79 05                	jns    f0108068 <initialize_paging+0x2a7>
f0108063:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108068:	c1 f8 0c             	sar    $0xc,%eax
f010806b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010806e:	7f cf                	jg     f010803f <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108070:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108073:	85 c0                	test   %eax,%eax
f0108075:	79 05                	jns    f010807c <initialize_paging+0x2bb>
f0108077:	05 ff 0f 00 00       	add    $0xfff,%eax
f010807c:	c1 f8 0c             	sar    $0xc,%eax
f010807f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108082:	e9 e8 00 00 00       	jmp    f010816f <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0108087:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f010808d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108090:	89 d0                	mov    %edx,%eax
f0108092:	01 c0                	add    %eax,%eax
f0108094:	01 d0                	add    %edx,%eax
f0108096:	c1 e0 03             	shl    $0x3,%eax
f0108099:	01 c8                	add    %ecx,%eax
f010809b:	83 ec 0c             	sub    $0xc,%esp
f010809e:	50                   	push   %eax
f010809f:	e8 e6 00 00 00       	call   f010818a <initialize_frame_info>
f01080a4:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01080a7:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f01080ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080b0:	89 d0                	mov    %edx,%eax
f01080b2:	01 c0                	add    %eax,%eax
f01080b4:	01 d0                	add    %edx,%eax
f01080b6:	c1 e0 03             	shl    $0x3,%eax
f01080b9:	01 c8                	add    %ecx,%eax
f01080bb:	85 c0                	test   %eax,%eax
f01080bd:	75 14                	jne    f01080d3 <initialize_paging+0x312>
f01080bf:	83 ec 04             	sub    $0x4,%esp
f01080c2:	68 d0 7b 12 f0       	push   $0xf0127bd0
f01080c7:	6a 74                	push   $0x74
f01080c9:	68 f3 7b 12 f0       	push   $0xf0127bf3
f01080ce:	e8 47 82 ff ff       	call   f010031a <_panic>
f01080d3:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f01080d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080dc:	89 d0                	mov    %edx,%eax
f01080de:	01 c0                	add    %eax,%eax
f01080e0:	01 d0                	add    %edx,%eax
f01080e2:	c1 e0 03             	shl    $0x3,%eax
f01080e5:	01 c8                	add    %ecx,%eax
f01080e7:	8b 15 c0 1e 5a f0    	mov    0xf05a1ec0,%edx
f01080ed:	89 10                	mov    %edx,(%eax)
f01080ef:	8b 00                	mov    (%eax),%eax
f01080f1:	85 c0                	test   %eax,%eax
f01080f3:	74 1f                	je     f0108114 <initialize_paging+0x353>
f01080f5:	8b 15 c0 1e 5a f0    	mov    0xf05a1ec0,%edx
f01080fb:	8b 1d c0 48 5a f0    	mov    0xf05a48c0,%ebx
f0108101:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108104:	89 c8                	mov    %ecx,%eax
f0108106:	01 c0                	add    %eax,%eax
f0108108:	01 c8                	add    %ecx,%eax
f010810a:	c1 e0 03             	shl    $0x3,%eax
f010810d:	01 d8                	add    %ebx,%eax
f010810f:	89 42 04             	mov    %eax,0x4(%edx)
f0108112:	eb 19                	jmp    f010812d <initialize_paging+0x36c>
f0108114:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f010811a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010811d:	89 d0                	mov    %edx,%eax
f010811f:	01 c0                	add    %eax,%eax
f0108121:	01 d0                	add    %edx,%eax
f0108123:	c1 e0 03             	shl    $0x3,%eax
f0108126:	01 c8                	add    %ecx,%eax
f0108128:	a3 c4 1e 5a f0       	mov    %eax,0xf05a1ec4
f010812d:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f0108133:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108136:	89 d0                	mov    %edx,%eax
f0108138:	01 c0                	add    %eax,%eax
f010813a:	01 d0                	add    %edx,%eax
f010813c:	c1 e0 03             	shl    $0x3,%eax
f010813f:	01 c8                	add    %ecx,%eax
f0108141:	a3 c0 1e 5a f0       	mov    %eax,0xf05a1ec0
f0108146:	8b 0d c0 48 5a f0    	mov    0xf05a48c0,%ecx
f010814c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010814f:	89 d0                	mov    %edx,%eax
f0108151:	01 c0                	add    %eax,%eax
f0108153:	01 d0                	add    %edx,%eax
f0108155:	c1 e0 03             	shl    $0x3,%eax
f0108158:	01 c8                	add    %ecx,%eax
f010815a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108161:	a1 cc 1e 5a f0       	mov    0xf05a1ecc,%eax
f0108166:	40                   	inc    %eax
f0108167:	a3 cc 1e 5a f0       	mov    %eax,0xf05a1ecc
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010816c:	ff 45 f4             	incl   -0xc(%ebp)
f010816f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108172:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0108177:	39 c2                	cmp    %eax,%edx
f0108179:	0f 82 08 ff ff ff    	jb     f0108087 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010817f:	e8 ef b9 ff ff       	call   f0103b73 <initialize_disk_page_file>
}
f0108184:	90                   	nop
f0108185:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108188:	c9                   	leave  
f0108189:	c3                   	ret    

f010818a <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f010818a:	55                   	push   %ebp
f010818b:	89 e5                	mov    %esp,%ebp
f010818d:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f0108190:	83 ec 04             	sub    $0x4,%esp
f0108193:	6a 18                	push   $0x18
f0108195:	6a 00                	push   $0x0
f0108197:	ff 75 08             	pushl  0x8(%ebp)
f010819a:	e8 5b a4 01 00       	call   f01225fa <memset>
f010819f:	83 c4 10             	add    $0x10,%esp
}
f01081a2:	90                   	nop
f01081a3:	c9                   	leave  
f01081a4:	c3                   	ret    

f01081a5 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01081a5:	55                   	push   %ebp
f01081a6:	89 e5                	mov    %esp,%ebp
f01081a8:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01081ab:	83 ec 0c             	sub    $0xc,%esp
f01081ae:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f01081b3:	e8 56 6b 00 00       	call   f010ed0e <holding_spinlock>
f01081b8:	83 c4 10             	add    $0x10,%esp
f01081bb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01081be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01081c2:	75 10                	jne    f01081d4 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01081c4:	83 ec 0c             	sub    $0xc,%esp
f01081c7:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f01081cc:	e8 24 69 00 00       	call   f010eaf5 <acquire_spinlock>
f01081d1:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f01081d4:	8b 15 c0 1e 5a f0    	mov    0xf05a1ec0,%edx
f01081da:	8b 45 08             	mov    0x8(%ebp),%eax
f01081dd:	89 10                	mov    %edx,(%eax)
	int c = 0;
f01081df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f01081e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01081e9:	8b 00                	mov    (%eax),%eax
f01081eb:	85 c0                	test   %eax,%eax
f01081ed:	75 17                	jne    f0108206 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f01081ef:	83 ec 04             	sub    $0x4,%esp
f01081f2:	68 44 7c 12 f0       	push   $0xf0127c44
f01081f7:	68 a2 00 00 00       	push   $0xa2
f01081fc:	68 f3 7b 12 f0       	push   $0xf0127bf3
f0108201:	e8 14 81 ff ff       	call   f010031a <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0108206:	8b 45 08             	mov    0x8(%ebp),%eax
f0108209:	8b 00                	mov    (%eax),%eax
f010820b:	85 c0                	test   %eax,%eax
f010820d:	75 17                	jne    f0108226 <allocate_frame+0x81>
f010820f:	83 ec 04             	sub    $0x4,%esp
f0108212:	68 91 7c 12 f0       	push   $0xf0127c91
f0108217:	68 a8 00 00 00       	push   $0xa8
f010821c:	68 f3 7b 12 f0       	push   $0xf0127bf3
f0108221:	e8 f4 80 ff ff       	call   f010031a <_panic>
f0108226:	8b 45 08             	mov    0x8(%ebp),%eax
f0108229:	8b 00                	mov    (%eax),%eax
f010822b:	8b 00                	mov    (%eax),%eax
f010822d:	85 c0                	test   %eax,%eax
f010822f:	74 14                	je     f0108245 <allocate_frame+0xa0>
f0108231:	8b 45 08             	mov    0x8(%ebp),%eax
f0108234:	8b 00                	mov    (%eax),%eax
f0108236:	8b 00                	mov    (%eax),%eax
f0108238:	8b 55 08             	mov    0x8(%ebp),%edx
f010823b:	8b 12                	mov    (%edx),%edx
f010823d:	8b 52 04             	mov    0x4(%edx),%edx
f0108240:	89 50 04             	mov    %edx,0x4(%eax)
f0108243:	eb 0d                	jmp    f0108252 <allocate_frame+0xad>
f0108245:	8b 45 08             	mov    0x8(%ebp),%eax
f0108248:	8b 00                	mov    (%eax),%eax
f010824a:	8b 40 04             	mov    0x4(%eax),%eax
f010824d:	a3 c4 1e 5a f0       	mov    %eax,0xf05a1ec4
f0108252:	8b 45 08             	mov    0x8(%ebp),%eax
f0108255:	8b 00                	mov    (%eax),%eax
f0108257:	8b 40 04             	mov    0x4(%eax),%eax
f010825a:	85 c0                	test   %eax,%eax
f010825c:	74 13                	je     f0108271 <allocate_frame+0xcc>
f010825e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108261:	8b 00                	mov    (%eax),%eax
f0108263:	8b 40 04             	mov    0x4(%eax),%eax
f0108266:	8b 55 08             	mov    0x8(%ebp),%edx
f0108269:	8b 12                	mov    (%edx),%edx
f010826b:	8b 12                	mov    (%edx),%edx
f010826d:	89 10                	mov    %edx,(%eax)
f010826f:	eb 0c                	jmp    f010827d <allocate_frame+0xd8>
f0108271:	8b 45 08             	mov    0x8(%ebp),%eax
f0108274:	8b 00                	mov    (%eax),%eax
f0108276:	8b 00                	mov    (%eax),%eax
f0108278:	a3 c0 1e 5a f0       	mov    %eax,0xf05a1ec0
f010827d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108280:	8b 00                	mov    (%eax),%eax
f0108282:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108288:	8b 45 08             	mov    0x8(%ebp),%eax
f010828b:	8b 00                	mov    (%eax),%eax
f010828d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108294:	a1 cc 1e 5a f0       	mov    0xf05a1ecc,%eax
f0108299:	48                   	dec    %eax
f010829a:	a3 cc 1e 5a f0       	mov    %eax,0xf05a1ecc

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f010829f:	8b 45 08             	mov    0x8(%ebp),%eax
f01082a2:	8b 00                	mov    (%eax),%eax
f01082a4:	8a 40 14             	mov    0x14(%eax),%al
f01082a7:	84 c0                	test   %al,%al
f01082a9:	74 20                	je     f01082cb <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01082ab:	8b 45 08             	mov    0x8(%ebp),%eax
f01082ae:	8b 00                	mov    (%eax),%eax
f01082b0:	8b 50 10             	mov    0x10(%eax),%edx
f01082b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01082b6:	8b 00                	mov    (%eax),%eax
f01082b8:	8b 40 0c             	mov    0xc(%eax),%eax
f01082bb:	8b 40 64             	mov    0x64(%eax),%eax
f01082be:	83 ec 08             	sub    $0x8,%esp
f01082c1:	52                   	push   %edx
f01082c2:	50                   	push   %eax
f01082c3:	e8 42 09 00 00       	call   f0108c0a <pt_clear_page_table_entry>
f01082c8:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f01082cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01082ce:	8b 00                	mov    (%eax),%eax
f01082d0:	83 ec 0c             	sub    $0xc,%esp
f01082d3:	50                   	push   %eax
f01082d4:	e8 b1 fe ff ff       	call   f010818a <initialize_frame_info>
f01082d9:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f01082dc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01082e0:	75 10                	jne    f01082f2 <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01082e2:	83 ec 0c             	sub    $0xc,%esp
f01082e5:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f01082ea:	e8 8d 68 00 00       	call   f010eb7c <release_spinlock>
f01082ef:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f01082f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01082f7:	c9                   	leave  
f01082f8:	c3                   	ret    

f01082f9 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f01082f9:	55                   	push   %ebp
f01082fa:	89 e5                	mov    %esp,%ebp
f01082fc:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01082ff:	83 ec 0c             	sub    $0xc,%esp
f0108302:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f0108307:	e8 02 6a 00 00       	call   f010ed0e <holding_spinlock>
f010830c:	83 c4 10             	add    $0x10,%esp
f010830f:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f0108312:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108316:	75 10                	jne    f0108328 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108318:	83 ec 0c             	sub    $0xc,%esp
f010831b:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f0108320:	e8 d0 67 00 00       	call   f010eaf5 <acquire_spinlock>
f0108325:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108328:	83 ec 0c             	sub    $0xc,%esp
f010832b:	ff 75 08             	pushl  0x8(%ebp)
f010832e:	e8 57 fe ff ff       	call   f010818a <initialize_frame_info>
f0108333:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108336:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010833a:	75 17                	jne    f0108353 <free_frame+0x5a>
f010833c:	83 ec 04             	sub    $0x4,%esp
f010833f:	68 d0 7b 12 f0       	push   $0xf0127bd0
f0108344:	68 cf 00 00 00       	push   $0xcf
f0108349:	68 f3 7b 12 f0       	push   $0xf0127bf3
f010834e:	e8 c7 7f ff ff       	call   f010031a <_panic>
f0108353:	8b 15 c0 1e 5a f0    	mov    0xf05a1ec0,%edx
f0108359:	8b 45 08             	mov    0x8(%ebp),%eax
f010835c:	89 10                	mov    %edx,(%eax)
f010835e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108361:	8b 00                	mov    (%eax),%eax
f0108363:	85 c0                	test   %eax,%eax
f0108365:	74 0d                	je     f0108374 <free_frame+0x7b>
f0108367:	a1 c0 1e 5a f0       	mov    0xf05a1ec0,%eax
f010836c:	8b 55 08             	mov    0x8(%ebp),%edx
f010836f:	89 50 04             	mov    %edx,0x4(%eax)
f0108372:	eb 08                	jmp    f010837c <free_frame+0x83>
f0108374:	8b 45 08             	mov    0x8(%ebp),%eax
f0108377:	a3 c4 1e 5a f0       	mov    %eax,0xf05a1ec4
f010837c:	8b 45 08             	mov    0x8(%ebp),%eax
f010837f:	a3 c0 1e 5a f0       	mov    %eax,0xf05a1ec0
f0108384:	8b 45 08             	mov    0x8(%ebp),%eax
f0108387:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010838e:	a1 cc 1e 5a f0       	mov    0xf05a1ecc,%eax
f0108393:	40                   	inc    %eax
f0108394:	a3 cc 1e 5a f0       	mov    %eax,0xf05a1ecc
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f0108399:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010839d:	75 10                	jne    f01083af <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f010839f:	83 ec 0c             	sub    $0xc,%esp
f01083a2:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f01083a7:	e8 d0 67 00 00       	call   f010eb7c <release_spinlock>
f01083ac:	83 c4 10             	add    $0x10,%esp
	}
}
f01083af:	90                   	nop
f01083b0:	c9                   	leave  
f01083b1:	c3                   	ret    

f01083b2 <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01083b2:	55                   	push   %ebp
f01083b3:	89 e5                	mov    %esp,%ebp
f01083b5:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01083b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01083bb:	8b 40 08             	mov    0x8(%eax),%eax
f01083be:	48                   	dec    %eax
f01083bf:	8b 55 08             	mov    0x8(%ebp),%edx
f01083c2:	66 89 42 08          	mov    %ax,0x8(%edx)
f01083c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01083c9:	8b 40 08             	mov    0x8(%eax),%eax
f01083cc:	66 85 c0             	test   %ax,%ax
f01083cf:	75 0e                	jne    f01083df <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f01083d1:	83 ec 0c             	sub    $0xc,%esp
f01083d4:	ff 75 08             	pushl  0x8(%ebp)
f01083d7:	e8 1d ff ff ff       	call   f01082f9 <free_frame>
f01083dc:	83 c4 10             	add    $0x10,%esp
}
f01083df:	90                   	nop
f01083e0:	c9                   	leave  
f01083e1:	c3                   	ret    

f01083e2 <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01083e2:	55                   	push   %ebp
f01083e3:	89 e5                	mov    %esp,%ebp
f01083e5:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01083e8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01083eb:	c1 e8 16             	shr    $0x16,%eax
f01083ee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01083f5:	8b 45 08             	mov    0x8(%ebp),%eax
f01083f8:	01 d0                	add    %edx,%eax
f01083fa:	8b 00                	mov    (%eax),%eax
f01083fc:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f01083ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108402:	83 e0 01             	and    $0x1,%eax
f0108405:	85 c0                	test   %eax,%eax
f0108407:	74 4e                	je     f0108457 <get_page_table+0x75>
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108409:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010840c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108411:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108414:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108417:	c1 e8 0c             	shr    $0xc,%eax
f010841a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010841d:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0108422:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108425:	72 17                	jb     f010843e <get_page_table+0x5c>
f0108427:	ff 75 f0             	pushl  -0x10(%ebp)
f010842a:	68 b0 7c 12 f0       	push   $0xf0127cb0
f010842f:	68 fb 00 00 00       	push   $0xfb
f0108434:	68 f3 7b 12 f0       	push   $0xf0127bf3
f0108439:	e8 dc 7e ff ff       	call   f010031a <_panic>
f010843e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108441:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108446:	89 c2                	mov    %eax,%edx
f0108448:	8b 45 10             	mov    0x10(%ebp),%eax
f010844b:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f010844d:	b8 00 00 00 00       	mov    $0x0,%eax
f0108452:	e9 8f 00 00 00       	jmp    f01084e6 <get_page_table+0x104>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f0108457:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010845b:	74 7b                	je     f01084d8 <get_page_table+0xf6>
f010845d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108460:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f0108463:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108466:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0108469:	83 ec 0c             	sub    $0xc,%esp
f010846c:	6a 00                	push   $0x0
f010846e:	e8 56 63 00 00       	call   f010e7c9 <fault_handler>
f0108473:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108476:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108479:	c1 e8 16             	shr    $0x16,%eax
f010847c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108483:	8b 45 08             	mov    0x8(%ebp),%eax
f0108486:	01 d0                	add    %edx,%eax
f0108488:	8b 00                	mov    (%eax),%eax
f010848a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010848d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108490:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108495:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108498:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010849b:	c1 e8 0c             	shr    $0xc,%eax
f010849e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01084a1:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f01084a6:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01084a9:	72 17                	jb     f01084c2 <get_page_table+0xe0>
f01084ab:	ff 75 e8             	pushl  -0x18(%ebp)
f01084ae:	68 b0 7c 12 f0       	push   $0xf0127cb0
f01084b3:	68 13 01 00 00       	push   $0x113
f01084b8:	68 f3 7b 12 f0       	push   $0xf0127bf3
f01084bd:	e8 58 7e ff ff       	call   f010031a <_panic>
f01084c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084c5:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01084ca:	89 c2                	mov    %eax,%edx
f01084cc:	8b 45 10             	mov    0x10(%ebp),%eax
f01084cf:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f01084d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01084d6:	eb 0e                	jmp    f01084e6 <get_page_table+0x104>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f01084d8:	8b 45 10             	mov    0x10(%ebp),%eax
f01084db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f01084e1:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f01084e6:	c9                   	leave  
f01084e7:	c3                   	ret    

f01084e8 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f01084e8:	55                   	push   %ebp
f01084e9:	89 e5                	mov    %esp,%ebp
f01084eb:	83 ec 18             	sub    $0x18,%esp
	memset(ptr_page_table , 0, PAGE_SIZE);
	tlbflush();

#else
	uint32 * ptr_page_table ;
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
f01084ee:	83 ec 04             	sub    $0x4,%esp
f01084f1:	8d 45 f4             	lea    -0xc(%ebp),%eax
f01084f4:	50                   	push   %eax
f01084f5:	ff 75 0c             	pushl  0xc(%ebp)
f01084f8:	ff 75 08             	pushl  0x8(%ebp)
f01084fb:	e8 08 00 00 00       	call   f0108508 <__static_cpt>
f0108500:	83 c4 10             	add    $0x10,%esp
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f0108503:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108506:	c9                   	leave  
f0108507:	c3                   	ret    

f0108508 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0108508:	55                   	push   %ebp
f0108509:	89 e5                	mov    %esp,%ebp
f010850b:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f010850e:	83 ec 0c             	sub    $0xc,%esp
f0108511:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0108514:	50                   	push   %eax
f0108515:	e8 8b fc ff ff       	call   f01081a5 <allocate_frame>
f010851a:	83 c4 10             	add    $0x10,%esp
f010851d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f0108520:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108523:	83 ec 0c             	sub    $0xc,%esp
f0108526:	50                   	push   %eax
f0108527:	e8 27 f8 ff ff       	call   f0107d53 <to_physical_address>
f010852c:	83 c4 10             	add    $0x10,%esp
f010852f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f0108532:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108535:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108538:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010853b:	c1 e8 0c             	shr    $0xc,%eax
f010853e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108541:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0108546:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0108549:	72 17                	jb     f0108562 <__static_cpt+0x5a>
f010854b:	ff 75 ec             	pushl  -0x14(%ebp)
f010854e:	68 b0 7c 12 f0       	push   $0xf0127cb0
f0108553:	68 4e 01 00 00       	push   $0x14e
f0108558:	68 f3 7b 12 f0       	push   $0xf0127bf3
f010855d:	e8 b8 7d ff ff       	call   f010031a <_panic>
f0108562:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108565:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010856a:	89 c2                	mov    %eax,%edx
f010856c:	8b 45 10             	mov    0x10(%ebp),%eax
f010856f:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108571:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108574:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f010857a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010857d:	c1 e8 16             	shr    $0x16,%eax
f0108580:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108587:	8b 45 08             	mov    0x8(%ebp),%eax
f010858a:	01 d0                	add    %edx,%eax
f010858c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010858f:	83 ca 07             	or     $0x7,%edx
f0108592:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108594:	8b 45 10             	mov    0x10(%ebp),%eax
f0108597:	8b 00                	mov    (%eax),%eax
f0108599:	83 ec 04             	sub    $0x4,%esp
f010859c:	68 00 10 00 00       	push   $0x1000
f01085a1:	6a 00                	push   $0x0
f01085a3:	50                   	push   %eax
f01085a4:	e8 51 a0 01 00       	call   f01225fa <memset>
f01085a9:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01085ac:	0f 20 d8             	mov    %cr3,%eax
f01085af:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01085b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01085b5:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01085b8:	90                   	nop
f01085b9:	c9                   	leave  
f01085ba:	c3                   	ret    

f01085bb <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01085bb:	55                   	push   %ebp
f01085bc:	89 e5                	mov    %esp,%ebp
f01085be:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01085c1:	ff 75 0c             	pushl  0xc(%ebp)
f01085c4:	e8 8a f7 ff ff       	call   f0107d53 <to_physical_address>
f01085c9:	83 c4 04             	add    $0x4,%esp
f01085cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f01085cf:	83 ec 04             	sub    $0x4,%esp
f01085d2:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01085d5:	50                   	push   %eax
f01085d6:	ff 75 10             	pushl  0x10(%ebp)
f01085d9:	ff 75 08             	pushl  0x8(%ebp)
f01085dc:	e8 01 fe ff ff       	call   f01083e2 <get_page_table>
f01085e1:	83 c4 10             	add    $0x10,%esp
f01085e4:	83 f8 01             	cmp    $0x1,%eax
f01085e7:	75 15                	jne    f01085fe <map_frame+0x43>
			uint32* ptr_page_table2 =NULL;
			//cprintf("======> After the table created at %x\n\n", get_page_table(ptr_page_directory, virtual_address,&ptr_page_table2));
		}
#else
		{
			__static_cpt(ptr_page_directory, (uint32)virtual_address, &ptr_page_table);
f01085e9:	83 ec 04             	sub    $0x4,%esp
f01085ec:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01085ef:	50                   	push   %eax
f01085f0:	ff 75 10             	pushl  0x10(%ebp)
f01085f3:	ff 75 08             	pushl  0x8(%ebp)
f01085f6:	e8 0d ff ff ff       	call   f0108508 <__static_cpt>
f01085fb:	83 c4 10             	add    $0x10,%esp
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f01085fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108601:	8b 55 10             	mov    0x10(%ebp),%edx
f0108604:	c1 ea 0c             	shr    $0xc,%edx
f0108607:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010860d:	c1 e2 02             	shl    $0x2,%edx
f0108610:	01 d0                	add    %edx,%eax
f0108612:	8b 00                	mov    (%eax),%eax
f0108614:	89 45 f0             	mov    %eax,-0x10(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0108617:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010861a:	83 e0 01             	and    $0x1,%eax
f010861d:	85 c0                	test   %eax,%eax
f010861f:	74 25                	je     f0108646 <map_frame+0x8b>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f0108621:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108624:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108629:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010862c:	75 07                	jne    f0108635 <map_frame+0x7a>
			return 0;
f010862e:	b8 00 00 00 00       	mov    $0x0,%eax
f0108633:	eb 68                	jmp    f010869d <map_frame+0xe2>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0108635:	83 ec 08             	sub    $0x8,%esp
f0108638:	ff 75 10             	pushl  0x10(%ebp)
f010863b:	ff 75 08             	pushl  0x8(%ebp)
f010863e:	e8 d2 00 00 00       	call   f0108715 <unmap_frame>
f0108643:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108646:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108649:	8b 40 08             	mov    0x8(%eax),%eax
f010864c:	40                   	inc    %eax
f010864d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108650:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108654:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108657:	8b 55 10             	mov    0x10(%ebp),%edx
f010865a:	c1 ea 0c             	shr    $0xc,%edx
f010865d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108663:	c1 e2 02             	shl    $0x2,%edx
f0108666:	01 d0                	add    %edx,%eax
f0108668:	8b 00                	mov    (%eax),%eax
f010866a:	25 00 0e 00 00       	and    $0xe00,%eax
f010866f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f0108672:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108675:	8b 55 10             	mov    0x10(%ebp),%edx
f0108678:	c1 ea 0c             	shr    $0xc,%edx
f010867b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108681:	c1 e2 02             	shl    $0x2,%edx
f0108684:	01 c2                	add    %eax,%edx
f0108686:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108689:	0b 45 ec             	or     -0x14(%ebp),%eax
f010868c:	89 c1                	mov    %eax,%ecx
f010868e:	8b 45 14             	mov    0x14(%ebp),%eax
f0108691:	09 c8                	or     %ecx,%eax
f0108693:	83 c8 01             	or     $0x1,%eax
f0108696:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108698:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010869d:	c9                   	leave  
f010869e:	c3                   	ret    

f010869f <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f010869f:	55                   	push   %ebp
f01086a0:	89 e5                	mov    %esp,%ebp
f01086a2:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f01086a5:	83 ec 04             	sub    $0x4,%esp
f01086a8:	ff 75 10             	pushl  0x10(%ebp)
f01086ab:	ff 75 0c             	pushl  0xc(%ebp)
f01086ae:	ff 75 08             	pushl  0x8(%ebp)
f01086b1:	e8 2c fd ff ff       	call   f01083e2 <get_page_table>
f01086b6:	83 c4 10             	add    $0x10,%esp
f01086b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f01086bc:	8b 45 10             	mov    0x10(%ebp),%eax
f01086bf:	8b 00                	mov    (%eax),%eax
f01086c1:	85 c0                	test   %eax,%eax
f01086c3:	74 49                	je     f010870e <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f01086c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01086c8:	c1 e8 0c             	shr    $0xc,%eax
f01086cb:	25 ff 03 00 00       	and    $0x3ff,%eax
f01086d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f01086d3:	8b 45 10             	mov    0x10(%ebp),%eax
f01086d6:	8b 00                	mov    (%eax),%eax
f01086d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01086db:	c1 e2 02             	shl    $0x2,%edx
f01086de:	01 d0                	add    %edx,%eax
f01086e0:	8b 00                	mov    (%eax),%eax
f01086e2:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f01086e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086e8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01086ed:	85 c0                	test   %eax,%eax
f01086ef:	74 16                	je     f0108707 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f01086f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086f4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01086f9:	83 ec 0c             	sub    $0xc,%esp
f01086fc:	50                   	push   %eax
f01086fd:	e8 64 f6 ff ff       	call   f0107d66 <to_frame_info>
f0108702:	83 c4 10             	add    $0x10,%esp
f0108705:	eb 0c                	jmp    f0108713 <get_frame_info+0x74>
		}
		return 0;
f0108707:	b8 00 00 00 00       	mov    $0x0,%eax
f010870c:	eb 05                	jmp    f0108713 <get_frame_info+0x74>
	}
	return 0;
f010870e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108713:	c9                   	leave  
f0108714:	c3                   	ret    

f0108715 <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f0108715:	55                   	push   %ebp
f0108716:	89 e5                	mov    %esp,%ebp
f0108718:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f010871b:	83 ec 04             	sub    $0x4,%esp
f010871e:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0108721:	50                   	push   %eax
f0108722:	ff 75 0c             	pushl  0xc(%ebp)
f0108725:	ff 75 08             	pushl  0x8(%ebp)
f0108728:	e8 72 ff ff ff       	call   f010869f <get_frame_info>
f010872d:	83 c4 10             	add    $0x10,%esp
f0108730:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f0108733:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108737:	74 7d                	je     f01087b6 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108739:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010873c:	8a 40 14             	mov    0x14(%eax),%al
f010873f:	84 c0                	test   %al,%al
f0108741:	74 1c                	je     f010875f <unmap_frame+0x4a>
f0108743:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010874a:	77 13                	ja     f010875f <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f010874c:	83 ec 08             	sub    $0x8,%esp
f010874f:	ff 75 0c             	pushl  0xc(%ebp)
f0108752:	68 e0 7c 12 f0       	push   $0xf0127ce0
f0108757:	e8 10 88 ff ff       	call   f0100f6c <cprintf>
f010875c:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f010875f:	83 ec 0c             	sub    $0xc,%esp
f0108762:	ff 75 f4             	pushl  -0xc(%ebp)
f0108765:	e8 48 fc ff ff       	call   f01083b2 <decrement_references>
f010876a:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f010876d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108770:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108773:	c1 ea 0c             	shr    $0xc,%edx
f0108776:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010877c:	c1 e2 02             	shl    $0x2,%edx
f010877f:	01 d0                	add    %edx,%eax
f0108781:	8b 00                	mov    (%eax),%eax
f0108783:	25 00 0e 00 00       	and    $0xe00,%eax
f0108788:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f010878b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010878e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108791:	c1 ea 0c             	shr    $0xc,%edx
f0108794:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010879a:	c1 e2 02             	shl    $0x2,%edx
f010879d:	01 c2                	add    %eax,%edx
f010879f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01087a2:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f01087a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01087a7:	83 ec 08             	sub    $0x8,%esp
f01087aa:	50                   	push   %eax
f01087ab:	ff 75 08             	pushl  0x8(%ebp)
f01087ae:	e8 f9 f5 ff ff       	call   f0107dac <tlb_invalidate>
f01087b3:	83 c4 10             	add    $0x10,%esp
	}
}
f01087b6:	90                   	nop
f01087b7:	c9                   	leave  
f01087b8:	c3                   	ret    

f01087b9 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01087b9:	55                   	push   %ebp
f01087ba:	89 e5                	mov    %esp,%ebp
f01087bc:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01087bf:	ff 75 0c             	pushl  0xc(%ebp)
f01087c2:	e8 8c f5 ff ff       	call   f0107d53 <to_physical_address>
f01087c7:	83 c4 04             	add    $0x4,%esp
f01087ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01087cd:	8b 45 10             	mov    0x10(%ebp),%eax
f01087d0:	c1 e8 16             	shr    $0x16,%eax
f01087d3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01087da:	8b 45 08             	mov    0x8(%ebp),%eax
f01087dd:	01 d0                	add    %edx,%eax
f01087df:	8b 00                	mov    (%eax),%eax
f01087e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01087e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01087e7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01087ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087f2:	c1 e8 0c             	shr    $0xc,%eax
f01087f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01087f8:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f01087fd:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0108800:	72 17                	jb     f0108819 <loadtime_map_frame+0x60>
f0108802:	ff 75 ec             	pushl  -0x14(%ebp)
f0108805:	68 b0 7c 12 f0       	push   $0xf0127cb0
f010880a:	68 f9 01 00 00       	push   $0x1f9
f010880f:	68 f3 7b 12 f0       	push   $0xf0127bf3
f0108814:	e8 01 7b ff ff       	call   f010031a <_panic>
f0108819:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010881c:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108821:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108824:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108828:	75 15                	jne    f010883f <loadtime_map_frame+0x86>
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
		}
#else
		{
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
f010882a:	83 ec 04             	sub    $0x4,%esp
f010882d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108830:	50                   	push   %eax
f0108831:	ff 75 10             	pushl  0x10(%ebp)
f0108834:	ff 75 08             	pushl  0x8(%ebp)
f0108837:	e8 cc fc ff ff       	call   f0108508 <__static_cpt>
f010883c:	83 c4 10             	add    $0x10,%esp
		}
#endif
	}

	ptr_frame_info->references++;
f010883f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108842:	8b 40 08             	mov    0x8(%eax),%eax
f0108845:	40                   	inc    %eax
f0108846:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108849:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f010884d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108850:	8b 55 10             	mov    0x10(%ebp),%edx
f0108853:	c1 ea 0c             	shr    $0xc,%edx
f0108856:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010885c:	c1 e2 02             	shl    $0x2,%edx
f010885f:	01 c2                	add    %eax,%edx
f0108861:	8b 45 14             	mov    0x14(%ebp),%eax
f0108864:	0b 45 f4             	or     -0xc(%ebp),%eax
f0108867:	83 c8 01             	or     $0x1,%eax
f010886a:	89 02                	mov    %eax,(%edx)

	return 0;
f010886c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108871:	c9                   	leave  
f0108872:	c3                   	ret    

f0108873 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108873:	55                   	push   %ebp
f0108874:	89 e5                	mov    %esp,%ebp
f0108876:	57                   	push   %edi
f0108877:	56                   	push   %esi
f0108878:	53                   	push   %ebx
f0108879:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f010887c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108883:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f010888a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f0108891:	83 ec 0c             	sub    $0xc,%esp
f0108894:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f0108899:	e8 70 64 00 00       	call   f010ed0e <holding_spinlock>
f010889e:	83 c4 10             	add    $0x10,%esp
f01088a1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f01088a4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01088a8:	75 10                	jne    f01088ba <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01088aa:	83 ec 0c             	sub    $0xc,%esp
f01088ad:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f01088b2:	e8 3e 62 00 00       	call   f010eaf5 <acquire_spinlock>
f01088b7:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01088ba:	a1 c0 1e 5a f0       	mov    0xf05a1ec0,%eax
f01088bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01088c2:	eb 1a                	jmp    f01088de <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f01088c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01088c7:	8a 40 14             	mov    0x14(%eax),%al
f01088ca:	84 c0                	test   %al,%al
f01088cc:	74 05                	je     f01088d3 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f01088ce:	ff 45 dc             	incl   -0x24(%ebp)
f01088d1:	eb 03                	jmp    f01088d6 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f01088d3:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01088d6:	a1 c8 1e 5a f0       	mov    0xf05a1ec8,%eax
f01088db:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01088de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01088e2:	74 07                	je     f01088eb <calculate_available_frames+0x78>
f01088e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01088e7:	8b 00                	mov    (%eax),%eax
f01088e9:	eb 05                	jmp    f01088f0 <calculate_available_frames+0x7d>
f01088eb:	b8 00 00 00 00       	mov    $0x0,%eax
f01088f0:	a3 c8 1e 5a f0       	mov    %eax,0xf05a1ec8
f01088f5:	a1 c8 1e 5a f0       	mov    0xf05a1ec8,%eax
f01088fa:	85 c0                	test   %eax,%eax
f01088fc:	75 c6                	jne    f01088c4 <calculate_available_frames+0x51>
f01088fe:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108902:	75 c0                	jne    f01088c4 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0108904:	a1 dc 1e 5a f0       	mov    0xf05a1edc,%eax
f0108909:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f010890c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108910:	75 10                	jne    f0108922 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108912:	83 ec 0c             	sub    $0xc,%esp
f0108915:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f010891a:	e8 5d 62 00 00       	call   f010eb7c <release_spinlock>
f010891f:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108922:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108925:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108928:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010892b:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f010892e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108931:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108934:	8b 45 08             	mov    0x8(%ebp),%eax
f0108937:	89 c3                	mov    %eax,%ebx
f0108939:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010893c:	ba 03 00 00 00       	mov    $0x3,%edx
f0108941:	89 df                	mov    %ebx,%edi
f0108943:	89 c6                	mov    %eax,%esi
f0108945:	89 d1                	mov    %edx,%ecx
f0108947:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108949:	8b 45 08             	mov    0x8(%ebp),%eax
f010894c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010894f:	5b                   	pop    %ebx
f0108950:	5e                   	pop    %esi
f0108951:	5f                   	pop    %edi
f0108952:	5d                   	pop    %ebp
f0108953:	c2 04 00             	ret    $0x4

f0108956 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init(uint32 numOfElements)
{
f0108956:	55                   	push   %ebp
f0108957:	89 e5                	mov    %esp,%ebp
f0108959:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
	init_spinlock(&AllShares.shareslock, "shares lock");
#else
	panic("not handled when KERN HEAP is disabled");
f010895c:	83 ec 04             	sub    $0x4,%esp
f010895f:	68 10 7d 12 f0       	push   $0xf0127d10
f0108964:	6a 1e                	push   $0x1e
f0108966:	68 38 7d 12 f0       	push   $0xf0127d38
f010896b:	e8 aa 79 ff ff       	call   f010031a <_panic>

f0108970 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108970:	55                   	push   %ebp
f0108971:	89 e5                	mov    %esp,%ebp
f0108973:	83 ec 18             	sub    $0x18,%esp
f0108976:	8b 45 14             	mov    0x14(%ebp),%eax
f0108979:	88 45 f4             	mov    %al,-0xc(%ebp)
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_share is not implemented yet");
f010897c:	83 ec 04             	sub    $0x4,%esp
f010897f:	68 5c 7d 12 f0       	push   $0xf0127d5c
f0108984:	6a 32                	push   $0x32
f0108986:	68 38 7d 12 f0       	push   $0xf0127d38
f010898b:	e8 8a 79 ff ff       	call   f010031a <_panic>

f0108990 <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108990:	55                   	push   %ebp
f0108991:	89 e5                	mov    %esp,%ebp
f0108993:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("get_share is not implemented yet");
f0108996:	83 ec 04             	sub    $0x4,%esp
f0108999:	68 80 7d 12 f0       	push   $0xf0127d80
f010899e:	6a 42                	push   $0x42
f01089a0:	68 38 7d 12 f0       	push   $0xf0127d38
f01089a5:	e8 70 79 ff ff       	call   f010031a <_panic>

f01089aa <free_share>:
// [3] Delete Share Object:
//=========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f01089aa:	55                   	push   %ebp
f01089ab:	89 e5                	mov    %esp,%ebp
f01089ad:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] BONUS
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_share is not implemented yet");
f01089b0:	83 ec 04             	sub    $0x4,%esp
f01089b3:	68 a4 7d 12 f0       	push   $0xf0127da4
f01089b8:	6a 50                	push   $0x50
f01089ba:	68 38 7d 12 f0       	push   $0xf0127d38
f01089bf:	e8 56 79 ff ff       	call   f010031a <_panic>

f01089c4 <create_frames_storage>:
//===========================
// [4] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f01089c4:	55                   	push   %ebp
f01089c5:	89 e5                	mov    %esp,%ebp
f01089c7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_frames_storage is not implemented yet");
f01089ca:	83 ec 04             	sub    $0x4,%esp
f01089cd:	68 c8 7d 12 f0       	push   $0xf0127dc8
f01089d2:	6a 5c                	push   $0x5c
f01089d4:	68 38 7d 12 f0       	push   $0xf0127d38
f01089d9:	e8 3c 79 ff ff       	call   f010031a <_panic>

f01089de <createSharedObject>:

//=========================
// [5] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f01089de:	55                   	push   %ebp
f01089df:	89 e5                	mov    %esp,%ebp
f01089e1:	83 ec 18             	sub    $0x18,%esp
f01089e4:	8b 45 14             	mov    0x14(%ebp),%eax
f01089e7:	88 45 f4             	mov    %al,-0xc(%ebp)
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("createSharedObject is not implemented yet");
f01089ea:	83 ec 04             	sub    $0x4,%esp
f01089ed:	68 f8 7d 12 f0       	push   $0xf0127df8
f01089f2:	6a 68                	push   $0x68
f01089f4:	68 38 7d 12 f0       	push   $0xf0127d38
f01089f9:	e8 1c 79 ff ff       	call   f010031a <_panic>

f01089fe <getSizeOfSharedObject>:

//==============================
// [6] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f01089fe:	55                   	push   %ebp
f01089ff:	89 e5                	mov    %esp,%ebp
f0108a01:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108a04:	83 ec 08             	sub    $0x8,%esp
f0108a07:	ff 75 0c             	pushl  0xc(%ebp)
f0108a0a:	ff 75 08             	pushl  0x8(%ebp)
f0108a0d:	e8 7e ff ff ff       	call   f0108990 <get_share>
f0108a12:	83 c4 10             	add    $0x10,%esp
f0108a15:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108a18:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a1c:	75 07                	jne    f0108a25 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108a1e:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108a23:	eb 06                	jmp    f0108a2b <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108a25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a28:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108a2b:	c9                   	leave  
f0108a2c:	c3                   	ret    

f0108a2d <getSharedObject>:

//======================
// [7] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108a2d:	55                   	push   %ebp
f0108a2e:	89 e5                	mov    %esp,%ebp
f0108a30:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("getSharedObject is not implemented yet");
f0108a33:	83 ec 04             	sub    $0x4,%esp
f0108a36:	68 24 7e 12 f0       	push   $0xf0127e24
f0108a3b:	68 89 00 00 00       	push   $0x89
f0108a40:	68 38 7d 12 f0       	push   $0xf0127d38
f0108a45:	e8 d0 78 ff ff       	call   f010031a <_panic>

f0108a4a <freeSharedObject>:

//===================
// Free Share Object:
//===================
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0108a4a:	55                   	push   %ebp
f0108a4b:	89 e5                	mov    %esp,%ebp
f0108a4d:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] BONUS
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("freeSharedObject is not implemented yet");
f0108a50:	83 ec 04             	sub    $0x4,%esp
f0108a53:	68 4c 7e 12 f0       	push   $0xf0127e4c
f0108a58:	68 9a 00 00 00       	push   $0x9a
f0108a5d:	68 38 7d 12 f0       	push   $0xf0127d38
f0108a62:	e8 b3 78 ff ff       	call   f010031a <_panic>

f0108a67 <initialize_kheap_dynamic_allocator>:
//Remember: call the initialize_dynamic_allocator(..) to complete the initialization
//Return:
//	On success: 0
//	Otherwise (if no memory OR initial size exceed the given limit): E_NO_MEM
int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0108a67:	55                   	push   %ebp
f0108a68:	89 e5                	mov    %esp,%ebp
f0108a6a:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
f0108a6d:	83 ec 04             	sub    $0x4,%esp
f0108a70:	68 74 7e 12 f0       	push   $0xf0127e74
f0108a75:	6a 11                	push   $0x11
f0108a77:	68 b5 7e 12 f0       	push   $0xf0127eb5
f0108a7c:	e8 99 78 ff ff       	call   f010031a <_panic>

f0108a81 <sbrk>:
}

void* sbrk(int numOfPages)
{
f0108a81:	55                   	push   %ebp
f0108a82:	89 e5                	mov    %esp,%ebp
	 * 	1) Allocating additional pages for a kernel dynamic allocator will fail if the free frames are exhausted
	 * 		or the break exceed the limit of the dynamic allocator. If sbrk fails, kernel should panic(...)
	 */

	//MS2: COMMENT THIS LINE BEFORE START CODING====
	return (void*)-1 ;
f0108a84:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	//====================================================

	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	panic("sbrk() is not implemented yet...!!");
}
f0108a89:	5d                   	pop    %ebp
f0108a8a:	c3                   	ret    

f0108a8b <kmalloc>:


void* kmalloc(unsigned int size)
{
f0108a8b:	55                   	push   %ebp
f0108a8c:	89 e5                	mov    %esp,%ebp
f0108a8e:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	kpanic_into_prompt("kmalloc() is not implemented yet...!!");
f0108a91:	83 ec 04             	sub    $0x4,%esp
f0108a94:	68 c8 7e 12 f0       	push   $0xf0127ec8
f0108a99:	6a 2e                	push   $0x2e
f0108a9b:	68 b5 7e 12 f0       	push   $0xf0127eb5
f0108aa0:	e8 a0 79 ff ff       	call   f0100445 <_panic_into_prompt>

f0108aa5 <kfree>:
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

}

void kfree(void* virtual_address)
{
f0108aa5:	55                   	push   %ebp
f0108aa6:	89 e5                	mov    %esp,%ebp
f0108aa8:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	panic("kfree() is not implemented yet...!!");
f0108aab:	83 ec 04             	sub    $0x4,%esp
f0108aae:	68 f0 7e 12 f0       	push   $0xf0127ef0
f0108ab3:	6a 38                	push   $0x38
f0108ab5:	68 b5 7e 12 f0       	push   $0xf0127eb5
f0108aba:	e8 5b 78 ff ff       	call   f010031a <_panic>

f0108abf <kheap_virtual_address>:
	//refer to the project presentation and documentation for details

}

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0108abf:	55                   	push   %ebp
f0108ac0:	89 e5                	mov    %esp,%ebp
f0108ac2:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [KERNEL HEAP] kheap_virtual_address
	// Write your code here, remove the panic and write your code
	panic("kheap_virtual_address() is not implemented yet...!!");
f0108ac5:	83 ec 04             	sub    $0x4,%esp
f0108ac8:	68 14 7f 12 f0       	push   $0xf0127f14
f0108acd:	6a 43                	push   $0x43
f0108acf:	68 b5 7e 12 f0       	push   $0xf0127eb5
f0108ad4:	e8 41 78 ff ff       	call   f010031a <_panic>

f0108ad9 <kheap_physical_address>:

	//EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
}

unsigned int kheap_physical_address(unsigned int virtual_address)
{
f0108ad9:	55                   	push   %ebp
f0108ada:	89 e5                	mov    %esp,%ebp
f0108adc:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [KERNEL HEAP] kheap_physical_address
	// Write your code here, remove the panic and write your code
	panic("kheap_physical_address() is not implemented yet...!!");
f0108adf:	83 ec 04             	sub    $0x4,%esp
f0108ae2:	68 48 7f 12 f0       	push   $0xf0127f48
f0108ae7:	6a 4f                	push   $0x4f
f0108ae9:	68 b5 7e 12 f0       	push   $0xf0127eb5
f0108aee:	e8 27 78 ff ff       	call   f010031a <_panic>

f0108af3 <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size)
{
f0108af3:	55                   	push   %ebp
f0108af4:	89 e5                	mov    %esp,%ebp
	//[PROJECT'24.MS2 BONUS2] Kernel Heap Realloc
	// Write your code here, remove the panic and write your code
	return NULL;
f0108af6:	b8 00 00 00 00       	mov    $0x0,%eax
	panic("krealloc() is not implemented yet...!!");
}
f0108afb:	5d                   	pop    %ebp
f0108afc:	c3                   	ret    

f0108afd <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0108afd:	55                   	push   %ebp
f0108afe:	89 e5                	mov    %esp,%ebp
f0108b00:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0108b03:	83 ec 04             	sub    $0x4,%esp
f0108b06:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108b09:	50                   	push   %eax
f0108b0a:	ff 75 0c             	pushl  0xc(%ebp)
f0108b0d:	ff 75 08             	pushl  0x8(%ebp)
f0108b10:	e8 cd f8 ff ff       	call   f01083e2 <get_page_table>
f0108b15:	83 c4 10             	add    $0x10,%esp
f0108b18:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0108b1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b1e:	85 c0                	test   %eax,%eax
f0108b20:	74 64                	je     f0108b86 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0108b22:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b25:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b28:	c1 ea 0c             	shr    $0xc,%edx
f0108b2b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108b31:	c1 e2 02             	shl    $0x2,%edx
f0108b34:	01 c2                	add    %eax,%edx
f0108b36:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b39:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0108b3c:	c1 e9 0c             	shr    $0xc,%ecx
f0108b3f:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0108b45:	c1 e1 02             	shl    $0x2,%ecx
f0108b48:	01 c8                	add    %ecx,%eax
f0108b4a:	8b 00                	mov    (%eax),%eax
f0108b4c:	0b 45 10             	or     0x10(%ebp),%eax
f0108b4f:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0108b51:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b54:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b57:	c1 ea 0c             	shr    $0xc,%edx
f0108b5a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108b60:	c1 e2 02             	shl    $0x2,%edx
f0108b63:	01 d0                	add    %edx,%eax
f0108b65:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108b68:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0108b6b:	c1 e9 0c             	shr    $0xc,%ecx
f0108b6e:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0108b74:	c1 e1 02             	shl    $0x2,%ecx
f0108b77:	01 ca                	add    %ecx,%edx
f0108b79:	8b 12                	mov    (%edx),%edx
f0108b7b:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0108b7e:	f7 d1                	not    %ecx
f0108b80:	21 ca                	and    %ecx,%edx
f0108b82:	89 10                	mov    %edx,(%eax)
f0108b84:	eb 27                	jmp    f0108bad <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0108b86:	83 ec 08             	sub    $0x8,%esp
f0108b89:	ff 75 0c             	pushl  0xc(%ebp)
f0108b8c:	68 80 7f 12 f0       	push   $0xf0127f80
f0108b91:	e8 d6 83 ff ff       	call   f0100f6c <cprintf>
f0108b96:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0108b99:	83 ec 04             	sub    $0x4,%esp
f0108b9c:	68 a8 7f 12 f0       	push   $0xf0127fa8
f0108ba1:	6a 1c                	push   $0x1c
f0108ba3:	68 1c 80 12 f0       	push   $0xf012801c
f0108ba8:	e8 6d 77 ff ff       	call   f010031a <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0108bad:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108bb0:	83 ec 08             	sub    $0x8,%esp
f0108bb3:	50                   	push   %eax
f0108bb4:	6a 00                	push   $0x0
f0108bb6:	e8 f1 f1 ff ff       	call   f0107dac <tlb_invalidate>
f0108bbb:	83 c4 10             	add    $0x10,%esp
}
f0108bbe:	90                   	nop
f0108bbf:	c9                   	leave  
f0108bc0:	c3                   	ret    

f0108bc1 <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f0108bc1:	55                   	push   %ebp
f0108bc2:	89 e5                	mov    %esp,%ebp
f0108bc4:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0108bc7:	83 ec 04             	sub    $0x4,%esp
f0108bca:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108bcd:	50                   	push   %eax
f0108bce:	ff 75 0c             	pushl  0xc(%ebp)
f0108bd1:	ff 75 08             	pushl  0x8(%ebp)
f0108bd4:	e8 09 f8 ff ff       	call   f01083e2 <get_page_table>
f0108bd9:	83 c4 10             	add    $0x10,%esp
f0108bdc:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f0108bdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108be2:	85 c0                	test   %eax,%eax
f0108be4:	74 1d                	je     f0108c03 <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f0108be6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108be9:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108bec:	c1 ea 0c             	shr    $0xc,%edx
f0108bef:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108bf5:	c1 e2 02             	shl    $0x2,%edx
f0108bf8:	01 d0                	add    %edx,%eax
f0108bfa:	8b 00                	mov    (%eax),%eax
f0108bfc:	25 ff 0f 00 00       	and    $0xfff,%eax
f0108c01:	eb 05                	jmp    f0108c08 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f0108c03:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f0108c08:	c9                   	leave  
f0108c09:	c3                   	ret    

f0108c0a <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f0108c0a:	55                   	push   %ebp
f0108c0b:	89 e5                	mov    %esp,%ebp
f0108c0d:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0108c10:	83 ec 04             	sub    $0x4,%esp
f0108c13:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108c16:	50                   	push   %eax
f0108c17:	ff 75 0c             	pushl  0xc(%ebp)
f0108c1a:	ff 75 08             	pushl  0x8(%ebp)
f0108c1d:	e8 c0 f7 ff ff       	call   f01083e2 <get_page_table>
f0108c22:	83 c4 10             	add    $0x10,%esp
f0108c25:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0108c28:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c2b:	85 c0                	test   %eax,%eax
f0108c2d:	74 46                	je     f0108c75 <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f0108c2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c32:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c35:	c1 ea 0c             	shr    $0xc,%edx
f0108c38:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108c3e:	c1 e2 02             	shl    $0x2,%edx
f0108c41:	01 d0                	add    %edx,%eax
f0108c43:	8b 00                	mov    (%eax),%eax
f0108c45:	83 ec 04             	sub    $0x4,%esp
f0108c48:	50                   	push   %eax
f0108c49:	ff 75 0c             	pushl  0xc(%ebp)
f0108c4c:	68 38 80 12 f0       	push   $0xf0128038
f0108c51:	e8 16 83 ff ff       	call   f0100f6c <cprintf>
f0108c56:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f0108c59:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c5c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c5f:	c1 ea 0c             	shr    $0xc,%edx
f0108c62:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108c68:	c1 e2 02             	shl    $0x2,%edx
f0108c6b:	01 d0                	add    %edx,%eax
f0108c6d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108c73:	eb 14                	jmp    f0108c89 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0108c75:	83 ec 04             	sub    $0x4,%esp
f0108c78:	68 60 80 12 f0       	push   $0xf0128060
f0108c7d:	6a 47                	push   $0x47
f0108c7f:	68 1c 80 12 f0       	push   $0xf012801c
f0108c84:	e8 91 76 ff ff       	call   f010031a <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0108c89:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108c8c:	83 ec 08             	sub    $0x8,%esp
f0108c8f:	50                   	push   %eax
f0108c90:	6a 00                	push   $0x0
f0108c92:	e8 15 f1 ff ff       	call   f0107dac <tlb_invalidate>
f0108c97:	83 c4 10             	add    $0x10,%esp
}
f0108c9a:	90                   	nop
f0108c9b:	c9                   	leave  
f0108c9c:	c3                   	ret    

f0108c9d <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f0108c9d:	55                   	push   %ebp
f0108c9e:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0108ca0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108ca3:	c1 e8 16             	shr    $0x16,%eax
f0108ca6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108cad:	8b 45 08             	mov    0x8(%ebp),%eax
f0108cb0:	01 d0                	add    %edx,%eax
f0108cb2:	8b 00                	mov    (%eax),%eax
f0108cb4:	83 e0 20             	and    $0x20,%eax
f0108cb7:	85 c0                	test   %eax,%eax
f0108cb9:	0f 95 c0             	setne  %al
f0108cbc:	0f b6 c0             	movzbl %al,%eax
}
f0108cbf:	5d                   	pop    %ebp
f0108cc0:	c3                   	ret    

f0108cc1 <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f0108cc1:	55                   	push   %ebp
f0108cc2:	89 e5                	mov    %esp,%ebp
f0108cc4:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f0108cc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108cca:	c1 e8 16             	shr    $0x16,%eax
f0108ccd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108cd4:	8b 45 08             	mov    0x8(%ebp),%eax
f0108cd7:	01 d0                	add    %edx,%eax
f0108cd9:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108cdc:	c1 ea 16             	shr    $0x16,%edx
f0108cdf:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0108ce6:	8b 55 08             	mov    0x8(%ebp),%edx
f0108ce9:	01 ca                	add    %ecx,%edx
f0108ceb:	8b 12                	mov    (%edx),%edx
f0108ced:	83 e2 df             	and    $0xffffffdf,%edx
f0108cf0:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0108cf2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108cf5:	83 ec 08             	sub    $0x8,%esp
f0108cf8:	50                   	push   %eax
f0108cf9:	6a 00                	push   $0x0
f0108cfb:	e8 ac f0 ff ff       	call   f0107dac <tlb_invalidate>
f0108d00:	83 c4 10             	add    $0x10,%esp
}
f0108d03:	90                   	nop
f0108d04:	c9                   	leave  
f0108d05:	c3                   	ret    

f0108d06 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f0108d06:	55                   	push   %ebp
f0108d07:	89 e5                	mov    %esp,%ebp
f0108d09:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f0108d0c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108d0f:	c1 e8 16             	shr    $0x16,%eax
f0108d12:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108d19:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d1c:	01 d0                	add    %edx,%eax
f0108d1e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108d24:	0f 20 d8             	mov    %cr3,%eax
f0108d27:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108d2a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0108d2d:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0108d30:	90                   	nop
f0108d31:	c9                   	leave  
f0108d32:	c3                   	ret    

f0108d33 <env_page_ws_get_size>:
		}
	}
}
#else
inline uint32 env_page_ws_get_size(struct Env *e)
{
f0108d33:	55                   	push   %ebp
f0108d34:	89 e5                	mov    %esp,%ebp
f0108d36:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f0108d39:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0108d40:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<e->page_WS_max_size; i++) if(e->ptr_pageWorkingSet[i].empty == 0) counter++;
f0108d47:	eb 22                	jmp    f0108d6b <env_page_ws_get_size+0x38>
f0108d49:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108d4c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0108d4f:	89 d0                	mov    %edx,%eax
f0108d51:	01 c0                	add    %eax,%eax
f0108d53:	01 d0                	add    %edx,%eax
f0108d55:	c1 e0 03             	shl    $0x3,%eax
f0108d58:	01 c8                	add    %ecx,%eax
f0108d5a:	05 8c 00 00 00       	add    $0x8c,%eax
f0108d5f:	8a 00                	mov    (%eax),%al
f0108d61:	84 c0                	test   %al,%al
f0108d63:	75 03                	jne    f0108d68 <env_page_ws_get_size+0x35>
f0108d65:	ff 45 f8             	incl   -0x8(%ebp)
f0108d68:	ff 45 fc             	incl   -0x4(%ebp)
f0108d6b:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d6e:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0108d74:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0108d77:	39 c2                	cmp    %eax,%edx
f0108d79:	77 ce                	ja     f0108d49 <env_page_ws_get_size+0x16>
	return counter;
f0108d7b:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0108d7e:	c9                   	leave  
f0108d7f:	c3                   	ret    

f0108d80 <env_page_ws_invalidate>:

inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0108d80:	55                   	push   %ebp
f0108d81:	89 e5                	mov    %esp,%ebp
f0108d83:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f0108d86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<e->page_WS_max_size; i++)
f0108d8d:	eb 4e                	jmp    f0108ddd <env_page_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->ptr_pageWorkingSet[i].virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0108d8f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108d92:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d95:	89 d0                	mov    %edx,%eax
f0108d97:	01 c0                	add    %eax,%eax
f0108d99:	01 d0                	add    %edx,%eax
f0108d9b:	c1 e0 03             	shl    $0x3,%eax
f0108d9e:	01 c8                	add    %ecx,%eax
f0108da0:	05 88 00 00 00       	add    $0x88,%eax
f0108da5:	8b 00                	mov    (%eax),%eax
f0108da7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108daa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108dad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108db2:	89 c2                	mov    %eax,%edx
f0108db4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108db7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108dba:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108dbd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108dc2:	39 c2                	cmp    %eax,%edx
f0108dc4:	75 14                	jne    f0108dda <env_page_ws_invalidate+0x5a>
		{
			env_page_ws_clear_entry(e, i);
f0108dc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108dc9:	83 ec 08             	sub    $0x8,%esp
f0108dcc:	50                   	push   %eax
f0108dcd:	ff 75 08             	pushl  0x8(%ebp)
f0108dd0:	e8 ce 00 00 00       	call   f0108ea3 <env_page_ws_clear_entry>
f0108dd5:	83 c4 10             	add    $0x10,%esp
			break;
f0108dd8:	eb 13                	jmp    f0108ded <env_page_ws_invalidate+0x6d>
}

inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<e->page_WS_max_size; i++)
f0108dda:	ff 45 f4             	incl   -0xc(%ebp)
f0108ddd:	8b 45 08             	mov    0x8(%ebp),%eax
f0108de0:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0108de6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108de9:	39 c2                	cmp    %eax,%edx
f0108deb:	77 a2                	ja     f0108d8f <env_page_ws_invalidate+0xf>
		{
			env_page_ws_clear_entry(e, i);
			break;
		}
	}
}
f0108ded:	90                   	nop
f0108dee:	c9                   	leave  
f0108def:	c3                   	ret    

f0108df0 <env_page_ws_set_entry>:

inline void env_page_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f0108df0:	55                   	push   %ebp
f0108df1:	89 e5                	mov    %esp,%ebp
f0108df3:	53                   	push   %ebx
f0108df4:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < e->page_WS_max_size);
f0108df7:	8b 45 08             	mov    0x8(%ebp),%eax
f0108dfa:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108e00:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108e03:	77 19                	ja     f0108e1e <env_page_ws_set_entry+0x2e>
f0108e05:	68 d8 80 12 f0       	push   $0xf01280d8
f0108e0a:	68 0e 81 12 f0       	push   $0xf012810e
f0108e0f:	68 a7 00 00 00       	push   $0xa7
f0108e14:	68 24 81 12 f0       	push   $0xf0128124
f0108e19:	e8 fc 74 ff ff       	call   f010031a <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f0108e1e:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0108e25:	76 19                	jbe    f0108e40 <env_page_ws_set_entry+0x50>
f0108e27:	68 44 81 12 f0       	push   $0xf0128144
f0108e2c:	68 0e 81 12 f0       	push   $0xf012810e
f0108e31:	68 a8 00 00 00       	push   $0xa8
f0108e36:	68 24 81 12 f0       	push   $0xf0128124
f0108e3b:	e8 da 74 ff ff       	call   f010031a <_panic>
	e->ptr_pageWorkingSet[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE);
f0108e40:	8b 45 10             	mov    0x10(%ebp),%eax
f0108e43:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108e46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e49:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108e4e:	89 c1                	mov    %eax,%ecx
f0108e50:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0108e53:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108e56:	89 d0                	mov    %edx,%eax
f0108e58:	01 c0                	add    %eax,%eax
f0108e5a:	01 d0                	add    %edx,%eax
f0108e5c:	c1 e0 03             	shl    $0x3,%eax
f0108e5f:	01 d8                	add    %ebx,%eax
f0108e61:	05 88 00 00 00       	add    $0x88,%eax
f0108e66:	89 08                	mov    %ecx,(%eax)
	e->ptr_pageWorkingSet[entry_index].empty = 0;
f0108e68:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108e6b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108e6e:	89 d0                	mov    %edx,%eax
f0108e70:	01 c0                	add    %eax,%eax
f0108e72:	01 d0                	add    %edx,%eax
f0108e74:	c1 e0 03             	shl    $0x3,%eax
f0108e77:	01 c8                	add    %ecx,%eax
f0108e79:	05 8c 00 00 00       	add    $0x8c,%eax
f0108e7e:	c6 00 00             	movb   $0x0,(%eax)

	e->ptr_pageWorkingSet[entry_index].time_stamp = 0x80000000;
f0108e81:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108e84:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108e87:	89 d0                	mov    %edx,%eax
f0108e89:	01 c0                	add    %eax,%eax
f0108e8b:	01 d0                	add    %edx,%eax
f0108e8d:	c1 e0 03             	shl    $0x3,%eax
f0108e90:	01 c8                	add    %ecx,%eax
f0108e92:	05 90 00 00 00       	add    $0x90,%eax
f0108e97:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	//e->ptr_pageWorkingSet[entry_index].time_stamp = time;
	return;
f0108e9d:	90                   	nop
}
f0108e9e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108ea1:	c9                   	leave  
f0108ea2:	c3                   	ret    

f0108ea3 <env_page_ws_clear_entry>:

inline void env_page_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0108ea3:	55                   	push   %ebp
f0108ea4:	89 e5                	mov    %esp,%ebp
f0108ea6:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108ea9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108eac:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108eb2:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108eb5:	77 19                	ja     f0108ed0 <env_page_ws_clear_entry+0x2d>
f0108eb7:	68 78 81 12 f0       	push   $0xf0128178
f0108ebc:	68 0e 81 12 f0       	push   $0xf012810e
f0108ec1:	68 b3 00 00 00       	push   $0xb3
f0108ec6:	68 24 81 12 f0       	push   $0xf0128124
f0108ecb:	e8 4a 74 ff ff       	call   f010031a <_panic>
	e->ptr_pageWorkingSet[entry_index].virtual_address = 0;
f0108ed0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108ed3:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108ed6:	89 d0                	mov    %edx,%eax
f0108ed8:	01 c0                	add    %eax,%eax
f0108eda:	01 d0                	add    %edx,%eax
f0108edc:	c1 e0 03             	shl    $0x3,%eax
f0108edf:	01 c8                	add    %ecx,%eax
f0108ee1:	05 88 00 00 00       	add    $0x88,%eax
f0108ee6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->ptr_pageWorkingSet[entry_index].empty = 1;
f0108eec:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108eef:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108ef2:	89 d0                	mov    %edx,%eax
f0108ef4:	01 c0                	add    %eax,%eax
f0108ef6:	01 d0                	add    %edx,%eax
f0108ef8:	c1 e0 03             	shl    $0x3,%eax
f0108efb:	01 c8                	add    %ecx,%eax
f0108efd:	05 8c 00 00 00       	add    $0x8c,%eax
f0108f02:	c6 00 01             	movb   $0x1,(%eax)
	e->ptr_pageWorkingSet[entry_index].time_stamp = 0;
f0108f05:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108f08:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108f0b:	89 d0                	mov    %edx,%eax
f0108f0d:	01 c0                	add    %eax,%eax
f0108f0f:	01 d0                	add    %edx,%eax
f0108f11:	c1 e0 03             	shl    $0x3,%eax
f0108f14:	01 c8                	add    %ecx,%eax
f0108f16:	05 90 00 00 00       	add    $0x90,%eax
f0108f1b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f0108f21:	90                   	nop
f0108f22:	c9                   	leave  
f0108f23:	c3                   	ret    

f0108f24 <env_page_ws_get_virtual_address>:

inline uint32 env_page_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f0108f24:	55                   	push   %ebp
f0108f25:	89 e5                	mov    %esp,%ebp
f0108f27:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108f2a:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f2d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108f33:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108f36:	77 19                	ja     f0108f51 <env_page_ws_get_virtual_address+0x2d>
f0108f38:	68 78 81 12 f0       	push   $0xf0128178
f0108f3d:	68 0e 81 12 f0       	push   $0xf012810e
f0108f42:	68 bb 00 00 00       	push   $0xbb
f0108f47:	68 24 81 12 f0       	push   $0xf0128124
f0108f4c:	e8 c9 73 ff ff       	call   f010031a <_panic>
	return ROUNDDOWN(e->ptr_pageWorkingSet[entry_index].virtual_address,PAGE_SIZE);
f0108f51:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108f54:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108f57:	89 d0                	mov    %edx,%eax
f0108f59:	01 c0                	add    %eax,%eax
f0108f5b:	01 d0                	add    %edx,%eax
f0108f5d:	c1 e0 03             	shl    $0x3,%eax
f0108f60:	01 c8                	add    %ecx,%eax
f0108f62:	05 88 00 00 00       	add    $0x88,%eax
f0108f67:	8b 00                	mov    (%eax),%eax
f0108f69:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f6f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0108f74:	c9                   	leave  
f0108f75:	c3                   	ret    

f0108f76 <env_page_ws_get_time_stamp>:

inline uint32 env_page_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0108f76:	55                   	push   %ebp
f0108f77:	89 e5                	mov    %esp,%ebp
f0108f79:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108f7c:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f7f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108f85:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108f88:	77 19                	ja     f0108fa3 <env_page_ws_get_time_stamp+0x2d>
f0108f8a:	68 78 81 12 f0       	push   $0xf0128178
f0108f8f:	68 0e 81 12 f0       	push   $0xf012810e
f0108f94:	68 c1 00 00 00       	push   $0xc1
f0108f99:	68 24 81 12 f0       	push   $0xf0128124
f0108f9e:	e8 77 73 ff ff       	call   f010031a <_panic>
	return e->ptr_pageWorkingSet[entry_index].time_stamp;
f0108fa3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108fa6:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108fa9:	89 d0                	mov    %edx,%eax
f0108fab:	01 c0                	add    %eax,%eax
f0108fad:	01 d0                	add    %edx,%eax
f0108faf:	c1 e0 03             	shl    $0x3,%eax
f0108fb2:	01 c8                	add    %ecx,%eax
f0108fb4:	05 90 00 00 00       	add    $0x90,%eax
f0108fb9:	8b 00                	mov    (%eax),%eax
}
f0108fbb:	c9                   	leave  
f0108fbc:	c3                   	ret    

f0108fbd <env_page_ws_is_entry_empty>:

inline uint32 env_page_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0108fbd:	55                   	push   %ebp
f0108fbe:	89 e5                	mov    %esp,%ebp
	return e->ptr_pageWorkingSet[entry_index].empty;
f0108fc0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108fc3:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108fc6:	89 d0                	mov    %edx,%eax
f0108fc8:	01 c0                	add    %eax,%eax
f0108fca:	01 d0                	add    %edx,%eax
f0108fcc:	c1 e0 03             	shl    $0x3,%eax
f0108fcf:	01 c8                	add    %ecx,%eax
f0108fd1:	05 8c 00 00 00       	add    $0x8c,%eax
f0108fd6:	8a 00                	mov    (%eax),%al
f0108fd8:	0f b6 c0             	movzbl %al,%eax
}
f0108fdb:	5d                   	pop    %ebp
f0108fdc:	c3                   	ret    

f0108fdd <env_page_ws_print>:

void env_page_ws_print(struct Env *e)
{
f0108fdd:	55                   	push   %ebp
f0108fde:	89 e5                	mov    %esp,%ebp
f0108fe0:	53                   	push   %ebx
f0108fe1:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0108fe4:	83 ec 0c             	sub    $0xc,%esp
f0108fe7:	6a 02                	push   $0x2
f0108fe9:	e8 f6 56 00 00       	call   f010e6e4 <isPageReplacmentAlgorithmLRU>
f0108fee:	83 c4 10             	add    $0x10,%esp
f0108ff1:	85 c0                	test   %eax,%eax
f0108ff3:	0f 84 fe 00 00 00    	je     f01090f7 <env_page_ws_print+0x11a>
	{
		int i = 0;
f0108ff9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f0109000:	83 ec 0c             	sub    $0xc,%esp
f0109003:	68 b0 81 12 f0       	push   $0xf01281b0
f0109008:	e8 5f 7f ff ff       	call   f0100f6c <cprintf>
f010900d:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109010:	8b 45 08             	mov    0x8(%ebp),%eax
f0109013:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f0109019:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010901c:	eb 2c                	jmp    f010904a <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010901e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109021:	8b 10                	mov    (%eax),%edx
f0109023:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109026:	8d 48 01             	lea    0x1(%eax),%ecx
f0109029:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010902c:	83 ec 04             	sub    $0x4,%esp
f010902f:	52                   	push   %edx
f0109030:	50                   	push   %eax
f0109031:	68 ca 81 12 f0       	push   $0xf01281ca
f0109036:	e8 31 7f ff ff       	call   f0100f6c <cprintf>
f010903b:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010903e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109041:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0109047:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010904a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010904e:	74 08                	je     f0109058 <env_page_ws_print+0x7b>
f0109050:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109053:	8b 40 10             	mov    0x10(%eax),%eax
f0109056:	eb 05                	jmp    f010905d <env_page_ws_print+0x80>
f0109058:	b8 00 00 00 00       	mov    $0x0,%eax
f010905d:	8b 55 08             	mov    0x8(%ebp),%edx
f0109060:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f0109066:	8b 45 08             	mov    0x8(%ebp),%eax
f0109069:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f010906f:	85 c0                	test   %eax,%eax
f0109071:	75 ab                	jne    f010901e <env_page_ws_print+0x41>
f0109073:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109077:	75 a5                	jne    f010901e <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f0109079:	83 ec 0c             	sub    $0xc,%esp
f010907c:	68 d2 81 12 f0       	push   $0xf01281d2
f0109081:	e8 e6 7e ff ff       	call   f0100f6c <cprintf>
f0109086:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109089:	8b 45 08             	mov    0x8(%ebp),%eax
f010908c:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f0109092:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109095:	eb 2c                	jmp    f01090c3 <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0109097:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010909a:	8b 10                	mov    (%eax),%edx
f010909c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010909f:	8d 48 01             	lea    0x1(%eax),%ecx
f01090a2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f01090a5:	83 ec 04             	sub    $0x4,%esp
f01090a8:	52                   	push   %edx
f01090a9:	50                   	push   %eax
f01090aa:	68 ca 81 12 f0       	push   $0xf01281ca
f01090af:	e8 b8 7e ff ff       	call   f0100f6c <cprintf>
f01090b4:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f01090b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01090ba:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f01090c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01090c3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01090c7:	74 08                	je     f01090d1 <env_page_ws_print+0xf4>
f01090c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090cc:	8b 40 10             	mov    0x10(%eax),%eax
f01090cf:	eb 05                	jmp    f01090d6 <env_page_ws_print+0xf9>
f01090d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01090d6:	8b 55 08             	mov    0x8(%ebp),%edx
f01090d9:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f01090df:	8b 45 08             	mov    0x8(%ebp),%eax
f01090e2:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f01090e8:	85 c0                	test   %eax,%eax
f01090ea:	75 ab                	jne    f0109097 <env_page_ws_print+0xba>
f01090ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01090f0:	75 a5                	jne    f0109097 <env_page_ws_print+0xba>
				cprintf(" <--");
			}
			cprintf("\n");
		}
	}
}
f01090f2:	e9 9f 01 00 00       	jmp    f0109296 <env_page_ws_print+0x2b9>
		}
	}
	else
	{
		uint32 i;
		cprintf("PAGE WS:\n");
f01090f7:	83 ec 0c             	sub    $0xc,%esp
f01090fa:	68 ed 81 12 f0       	push   $0xf01281ed
f01090ff:	e8 68 7e ff ff       	call   f0100f6c <cprintf>
f0109104:	83 c4 10             	add    $0x10,%esp
		for(i=0; i< (e->page_WS_max_size); i++ )
f0109107:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010910e:	e9 71 01 00 00       	jmp    f0109284 <env_page_ws_print+0x2a7>
		{
			if (e->ptr_pageWorkingSet[i].empty)
f0109113:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109116:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109119:	89 d0                	mov    %edx,%eax
f010911b:	01 c0                	add    %eax,%eax
f010911d:	01 d0                	add    %edx,%eax
f010911f:	c1 e0 03             	shl    $0x3,%eax
f0109122:	01 c8                	add    %ecx,%eax
f0109124:	05 8c 00 00 00       	add    $0x8c,%eax
f0109129:	8a 00                	mov    (%eax),%al
f010912b:	84 c0                	test   %al,%al
f010912d:	74 43                	je     f0109172 <env_page_ws_print+0x195>
			{
				cprintf("EMPTY LOCATION");
f010912f:	83 ec 0c             	sub    $0xc,%esp
f0109132:	68 f7 81 12 f0       	push   $0xf01281f7
f0109137:	e8 30 7e ff ff       	call   f0100f6c <cprintf>
f010913c:	83 c4 10             	add    $0x10,%esp
				if(i==e->page_last_WS_index )
f010913f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109142:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f0109148:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010914b:	75 10                	jne    f010915d <env_page_ws_print+0x180>
				{
					cprintf("		<--");
f010914d:	83 ec 0c             	sub    $0xc,%esp
f0109150:	68 06 82 12 f0       	push   $0xf0128206
f0109155:	e8 12 7e ff ff       	call   f0100f6c <cprintf>
f010915a:	83 c4 10             	add    $0x10,%esp
				}
				cprintf("\n");
f010915d:	83 ec 0c             	sub    $0xc,%esp
f0109160:	68 0c 82 12 f0       	push   $0xf012820c
f0109165:	e8 02 7e ff ff       	call   f0100f6c <cprintf>
f010916a:	83 c4 10             	add    $0x10,%esp
				continue;
f010916d:	e9 0f 01 00 00       	jmp    f0109281 <env_page_ws_print+0x2a4>
			}
			uint32 virtual_address = e->ptr_pageWorkingSet[i].virtual_address;
f0109172:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109175:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109178:	89 d0                	mov    %edx,%eax
f010917a:	01 c0                	add    %eax,%eax
f010917c:	01 d0                	add    %edx,%eax
f010917e:	c1 e0 03             	shl    $0x3,%eax
f0109181:	01 c8                	add    %ecx,%eax
f0109183:	05 88 00 00 00       	add    $0x88,%eax
f0109188:	8b 00                	mov    (%eax),%eax
f010918a:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 time_stamp = e->ptr_pageWorkingSet[i].time_stamp;
f010918d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109190:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109193:	89 d0                	mov    %edx,%eax
f0109195:	01 c0                	add    %eax,%eax
f0109197:	01 d0                	add    %edx,%eax
f0109199:	c1 e0 03             	shl    $0x3,%eax
f010919c:	01 c8                	add    %ecx,%eax
f010919e:	05 90 00 00 00       	add    $0x90,%eax
f01091a3:	8b 00                	mov    (%eax),%eax
f01091a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f01091a8:	8b 45 08             	mov    0x8(%ebp),%eax
f01091ab:	8b 40 64             	mov    0x64(%eax),%eax
f01091ae:	83 ec 08             	sub    $0x8,%esp
f01091b1:	ff 75 e8             	pushl  -0x18(%ebp)
f01091b4:	50                   	push   %eax
f01091b5:	e8 07 fa ff ff       	call   f0108bc1 <pt_get_page_permissions>
f01091ba:	83 c4 10             	add    $0x10,%esp
f01091bd:	89 45 e0             	mov    %eax,-0x20(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f01091c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01091c3:	83 e0 40             	and    $0x40,%eax
f01091c6:	85 c0                	test   %eax,%eax
f01091c8:	0f 95 c0             	setne  %al
f01091cb:	88 45 df             	mov    %al,-0x21(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f01091ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01091d1:	83 e0 20             	and    $0x20,%eax
f01091d4:	85 c0                	test   %eax,%eax
f01091d6:	0f 95 c0             	setne  %al
f01091d9:	88 45 de             	mov    %al,-0x22(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f01091dc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01091df:	25 00 02 00 00       	and    $0x200,%eax
f01091e4:	85 c0                	test   %eax,%eax
f01091e6:	0f 95 c0             	setne  %al
f01091e9:	88 45 dd             	mov    %al,-0x23(%ebp)


			cprintf("address @ %d = %x",i, e->ptr_pageWorkingSet[i].virtual_address);
f01091ec:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01091ef:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01091f2:	89 d0                	mov    %edx,%eax
f01091f4:	01 c0                	add    %eax,%eax
f01091f6:	01 d0                	add    %edx,%eax
f01091f8:	c1 e0 03             	shl    $0x3,%eax
f01091fb:	01 c8                	add    %ecx,%eax
f01091fd:	05 88 00 00 00       	add    $0x88,%eax
f0109202:	8b 00                	mov    (%eax),%eax
f0109204:	83 ec 04             	sub    $0x4,%esp
f0109207:	50                   	push   %eax
f0109208:	ff 75 ec             	pushl  -0x14(%ebp)
f010920b:	68 0e 82 12 f0       	push   $0xf012820e
f0109210:	e8 57 7d ff ff       	call   f0100f6c <cprintf>
f0109215:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d", isUsed, isModified, isBuffered, time_stamp, e->ptr_pageWorkingSet[i].sweeps_counter) ;
f0109218:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010921b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010921e:	89 d0                	mov    %edx,%eax
f0109220:	01 c0                	add    %eax,%eax
f0109222:	01 d0                	add    %edx,%eax
f0109224:	c1 e0 03             	shl    $0x3,%eax
f0109227:	01 c8                	add    %ecx,%eax
f0109229:	05 94 00 00 00       	add    $0x94,%eax
f010922e:	8b 18                	mov    (%eax),%ebx
f0109230:	0f be 4d dd          	movsbl -0x23(%ebp),%ecx
f0109234:	0f be 55 df          	movsbl -0x21(%ebp),%edx
f0109238:	0f be 45 de          	movsbl -0x22(%ebp),%eax
f010923c:	83 ec 08             	sub    $0x8,%esp
f010923f:	53                   	push   %ebx
f0109240:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109243:	51                   	push   %ecx
f0109244:	52                   	push   %edx
f0109245:	50                   	push   %eax
f0109246:	68 20 82 12 f0       	push   $0xf0128220
f010924b:	e8 1c 7d ff ff       	call   f0100f6c <cprintf>
f0109250:	83 c4 20             	add    $0x20,%esp

			if(i==e->page_last_WS_index )
f0109253:	8b 45 08             	mov    0x8(%ebp),%eax
f0109256:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f010925c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010925f:	75 10                	jne    f0109271 <env_page_ws_print+0x294>
			{
				cprintf(" <--");
f0109261:	83 ec 0c             	sub    $0xc,%esp
f0109264:	68 67 82 12 f0       	push   $0xf0128267
f0109269:	e8 fe 7c ff ff       	call   f0100f6c <cprintf>
f010926e:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109271:	83 ec 0c             	sub    $0xc,%esp
f0109274:	68 0c 82 12 f0       	push   $0xf012820c
f0109279:	e8 ee 7c ff ff       	call   f0100f6c <cprintf>
f010927e:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		uint32 i;
		cprintf("PAGE WS:\n");
		for(i=0; i< (e->page_WS_max_size); i++ )
f0109281:	ff 45 ec             	incl   -0x14(%ebp)
f0109284:	8b 45 08             	mov    0x8(%ebp),%eax
f0109287:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010928d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109290:	0f 87 7d fe ff ff    	ja     f0109113 <env_page_ws_print+0x136>
				cprintf(" <--");
			}
			cprintf("\n");
		}
	}
}
f0109296:	90                   	nop
f0109297:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010929a:	c9                   	leave  
f010929b:	c3                   	ret    

f010929c <env_table_ws_print>:
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010929c:	55                   	push   %ebp
f010929d:	89 e5                	mov    %esp,%ebp
f010929f:	53                   	push   %ebx
f01092a0:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f01092a3:	83 ec 0c             	sub    $0xc,%esp
f01092a6:	68 6c 82 12 f0       	push   $0xf012826c
f01092ab:	e8 bc 7c ff ff       	call   f0100f6c <cprintf>
f01092b0:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f01092b3:	83 ec 0c             	sub    $0xc,%esp
f01092b6:	68 a1 82 12 f0       	push   $0xf01282a1
f01092bb:	e8 ac 7c ff ff       	call   f0100f6c <cprintf>
f01092c0:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f01092c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01092ca:	e9 16 01 00 00       	jmp    f01093e5 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f01092cf:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01092d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01092d5:	89 d0                	mov    %edx,%eax
f01092d7:	01 c0                	add    %eax,%eax
f01092d9:	01 d0                	add    %edx,%eax
f01092db:	c1 e0 03             	shl    $0x3,%eax
f01092de:	01 c8                	add    %ecx,%eax
f01092e0:	05 60 d5 01 00       	add    $0x1d560,%eax
f01092e5:	8a 00                	mov    (%eax),%al
f01092e7:	84 c0                	test   %al,%al
f01092e9:	74 43                	je     f010932e <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f01092eb:	83 ec 0c             	sub    $0xc,%esp
f01092ee:	68 f7 81 12 f0       	push   $0xf01281f7
f01092f3:	e8 74 7c ff ff       	call   f0100f6c <cprintf>
f01092f8:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f01092fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01092fe:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f0109304:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109307:	75 10                	jne    f0109319 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f0109309:	83 ec 0c             	sub    $0xc,%esp
f010930c:	68 06 82 12 f0       	push   $0xf0128206
f0109311:	e8 56 7c ff ff       	call   f0100f6c <cprintf>
f0109316:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109319:	83 ec 0c             	sub    $0xc,%esp
f010931c:	68 0c 82 12 f0       	push   $0xf012820c
f0109321:	e8 46 7c ff ff       	call   f0100f6c <cprintf>
f0109326:	83 c4 10             	add    $0x10,%esp
			continue;
f0109329:	e9 b4 00 00 00       	jmp    f01093e2 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010932e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109331:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109334:	89 d0                	mov    %edx,%eax
f0109336:	01 c0                	add    %eax,%eax
f0109338:	01 d0                	add    %edx,%eax
f010933a:	c1 e0 03             	shl    $0x3,%eax
f010933d:	01 c8                	add    %ecx,%eax
f010933f:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0109344:	8b 00                	mov    (%eax),%eax
f0109346:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f0109349:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010934c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010934f:	89 d0                	mov    %edx,%eax
f0109351:	01 c0                	add    %eax,%eax
f0109353:	01 d0                	add    %edx,%eax
f0109355:	c1 e0 03             	shl    $0x3,%eax
f0109358:	01 c8                	add    %ecx,%eax
f010935a:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010935f:	8b 00                	mov    (%eax),%eax
f0109361:	83 ec 04             	sub    $0x4,%esp
f0109364:	50                   	push   %eax
f0109365:	ff 75 f4             	pushl  -0xc(%ebp)
f0109368:	68 ac 82 12 f0       	push   $0xf01282ac
f010936d:	e8 fa 7b ff ff       	call   f0100f6c <cprintf>
f0109372:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f0109375:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109378:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010937b:	89 d0                	mov    %edx,%eax
f010937d:	01 c0                	add    %eax,%eax
f010937f:	01 d0                	add    %edx,%eax
f0109381:	c1 e0 03             	shl    $0x3,%eax
f0109384:	01 c8                	add    %ecx,%eax
f0109386:	05 64 d5 01 00       	add    $0x1d564,%eax
f010938b:	8b 18                	mov    (%eax),%ebx
f010938d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109390:	8b 40 64             	mov    0x64(%eax),%eax
f0109393:	83 ec 08             	sub    $0x8,%esp
f0109396:	ff 75 f0             	pushl  -0x10(%ebp)
f0109399:	50                   	push   %eax
f010939a:	e8 fe f8 ff ff       	call   f0108c9d <pd_is_table_used>
f010939f:	83 c4 10             	add    $0x10,%esp
f01093a2:	83 ec 04             	sub    $0x4,%esp
f01093a5:	53                   	push   %ebx
f01093a6:	50                   	push   %eax
f01093a7:	68 c4 82 12 f0       	push   $0xf01282c4
f01093ac:	e8 bb 7b ff ff       	call   f0100f6c <cprintf>
f01093b1:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f01093b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01093b7:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f01093bd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01093c0:	75 10                	jne    f01093d2 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f01093c2:	83 ec 0c             	sub    $0xc,%esp
f01093c5:	68 67 82 12 f0       	push   $0xf0128267
f01093ca:	e8 9d 7b ff ff       	call   f0100f6c <cprintf>
f01093cf:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f01093d2:	83 ec 0c             	sub    $0xc,%esp
f01093d5:	68 0c 82 12 f0       	push   $0xf012820c
f01093da:	e8 8d 7b ff ff       	call   f0100f6c <cprintf>
f01093df:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f01093e2:	ff 45 f4             	incl   -0xc(%ebp)
f01093e5:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f01093e9:	0f 86 e0 fe ff ff    	jbe    f01092cf <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f01093ef:	90                   	nop
f01093f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01093f3:	c9                   	leave  
f01093f4:	c3                   	ret    

f01093f5 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f01093f5:	55                   	push   %ebp
f01093f6:	89 e5                	mov    %esp,%ebp
f01093f8:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f01093fb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0109402:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f0109409:	eb 22                	jmp    f010942d <env_table_ws_get_size+0x38>
f010940b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010940e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0109411:	89 d0                	mov    %edx,%eax
f0109413:	01 c0                	add    %eax,%eax
f0109415:	01 d0                	add    %edx,%eax
f0109417:	c1 e0 03             	shl    $0x3,%eax
f010941a:	01 c8                	add    %ecx,%eax
f010941c:	05 60 d5 01 00       	add    $0x1d560,%eax
f0109421:	8a 00                	mov    (%eax),%al
f0109423:	84 c0                	test   %al,%al
f0109425:	75 03                	jne    f010942a <env_table_ws_get_size+0x35>
f0109427:	ff 45 f8             	incl   -0x8(%ebp)
f010942a:	ff 45 fc             	incl   -0x4(%ebp)
f010942d:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f0109431:	7e d8                	jle    f010940b <env_table_ws_get_size+0x16>
	return counter;
f0109433:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0109436:	c9                   	leave  
f0109437:	c3                   	ret    

f0109438 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109438:	55                   	push   %ebp
f0109439:	89 e5                	mov    %esp,%ebp
f010943b:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010943e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f0109445:	eb 4e                	jmp    f0109495 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f0109447:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010944a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010944d:	89 d0                	mov    %edx,%eax
f010944f:	01 c0                	add    %eax,%eax
f0109451:	01 d0                	add    %edx,%eax
f0109453:	c1 e0 03             	shl    $0x3,%eax
f0109456:	01 c8                	add    %ecx,%eax
f0109458:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010945d:	8b 00                	mov    (%eax),%eax
f010945f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109462:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109465:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010946a:	89 c2                	mov    %eax,%edx
f010946c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010946f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109472:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109475:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010947a:	39 c2                	cmp    %eax,%edx
f010947c:	75 14                	jne    f0109492 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010947e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109481:	83 ec 08             	sub    $0x8,%esp
f0109484:	50                   	push   %eax
f0109485:	ff 75 08             	pushl  0x8(%ebp)
f0109488:	e8 bc 00 00 00       	call   f0109549 <env_table_ws_clear_entry>
f010948d:	83 c4 10             	add    $0x10,%esp
			break;
f0109490:	eb 09                	jmp    f010949b <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f0109492:	ff 45 f4             	incl   -0xc(%ebp)
f0109495:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f0109499:	7e ac                	jle    f0109447 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010949b:	90                   	nop
f010949c:	c9                   	leave  
f010949d:	c3                   	ret    

f010949e <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010949e:	55                   	push   %ebp
f010949f:	89 e5                	mov    %esp,%ebp
f01094a1:	53                   	push   %ebx
f01094a2:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f01094a5:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f01094a9:	76 19                	jbe    f01094c4 <env_table_ws_set_entry+0x26>
f01094ab:	68 e8 82 12 f0       	push   $0xf01282e8
f01094b0:	68 0e 81 12 f0       	push   $0xf012810e
f01094b5:	68 37 01 00 00       	push   $0x137
f01094ba:	68 24 81 12 f0       	push   $0xf0128124
f01094bf:	e8 56 6e ff ff       	call   f010031a <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f01094c4:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01094cb:	76 19                	jbe    f01094e6 <env_table_ws_set_entry+0x48>
f01094cd:	68 44 81 12 f0       	push   $0xf0128144
f01094d2:	68 0e 81 12 f0       	push   $0xf012810e
f01094d7:	68 38 01 00 00       	push   $0x138
f01094dc:	68 24 81 12 f0       	push   $0xf0128124
f01094e1:	e8 34 6e ff ff       	call   f010031a <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f01094e6:	8b 45 10             	mov    0x10(%ebp),%eax
f01094e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01094ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094ef:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f01094f4:	89 c1                	mov    %eax,%ecx
f01094f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01094f9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01094fc:	89 d0                	mov    %edx,%eax
f01094fe:	01 c0                	add    %eax,%eax
f0109500:	01 d0                	add    %edx,%eax
f0109502:	c1 e0 03             	shl    $0x3,%eax
f0109505:	01 d8                	add    %ebx,%eax
f0109507:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010950c:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010950e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109511:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109514:	89 d0                	mov    %edx,%eax
f0109516:	01 c0                	add    %eax,%eax
f0109518:	01 d0                	add    %edx,%eax
f010951a:	c1 e0 03             	shl    $0x3,%eax
f010951d:	01 c8                	add    %ecx,%eax
f010951f:	05 60 d5 01 00       	add    $0x1d560,%eax
f0109524:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f0109527:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010952a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010952d:	89 d0                	mov    %edx,%eax
f010952f:	01 c0                	add    %eax,%eax
f0109531:	01 d0                	add    %edx,%eax
f0109533:	c1 e0 03             	shl    $0x3,%eax
f0109536:	01 c8                	add    %ecx,%eax
f0109538:	05 64 d5 01 00       	add    $0x1d564,%eax
f010953d:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f0109543:	90                   	nop
}
f0109544:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109547:	c9                   	leave  
f0109548:	c3                   	ret    

f0109549 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0109549:	55                   	push   %ebp
f010954a:	89 e5                	mov    %esp,%ebp
f010954c:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010954f:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109553:	76 19                	jbe    f010956e <env_table_ws_clear_entry+0x25>
f0109555:	68 e8 82 12 f0       	push   $0xf01282e8
f010955a:	68 0e 81 12 f0       	push   $0xf012810e
f010955f:	68 43 01 00 00       	push   $0x143
f0109564:	68 24 81 12 f0       	push   $0xf0128124
f0109569:	e8 ac 6d ff ff       	call   f010031a <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010956e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109571:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109574:	89 d0                	mov    %edx,%eax
f0109576:	01 c0                	add    %eax,%eax
f0109578:	01 d0                	add    %edx,%eax
f010957a:	c1 e0 03             	shl    $0x3,%eax
f010957d:	01 c8                	add    %ecx,%eax
f010957f:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0109584:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010958a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010958d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109590:	89 d0                	mov    %edx,%eax
f0109592:	01 c0                	add    %eax,%eax
f0109594:	01 d0                	add    %edx,%eax
f0109596:	c1 e0 03             	shl    $0x3,%eax
f0109599:	01 c8                	add    %ecx,%eax
f010959b:	05 60 d5 01 00       	add    $0x1d560,%eax
f01095a0:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f01095a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01095a6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01095a9:	89 d0                	mov    %edx,%eax
f01095ab:	01 c0                	add    %eax,%eax
f01095ad:	01 d0                	add    %edx,%eax
f01095af:	c1 e0 03             	shl    $0x3,%eax
f01095b2:	01 c8                	add    %ecx,%eax
f01095b4:	05 64 d5 01 00       	add    $0x1d564,%eax
f01095b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f01095bf:	90                   	nop
f01095c0:	c9                   	leave  
f01095c1:	c3                   	ret    

f01095c2 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f01095c2:	55                   	push   %ebp
f01095c3:	89 e5                	mov    %esp,%ebp
f01095c5:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f01095c8:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f01095cc:	76 19                	jbe    f01095e7 <env_table_ws_get_virtual_address+0x25>
f01095ce:	68 e8 82 12 f0       	push   $0xf01282e8
f01095d3:	68 0e 81 12 f0       	push   $0xf012810e
f01095d8:	68 4b 01 00 00       	push   $0x14b
f01095dd:	68 24 81 12 f0       	push   $0xf0128124
f01095e2:	e8 33 6d ff ff       	call   f010031a <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f01095e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01095ea:	8b 55 0c             	mov    0xc(%ebp),%edx
f01095ed:	89 d0                	mov    %edx,%eax
f01095ef:	01 c0                	add    %eax,%eax
f01095f1:	01 d0                	add    %edx,%eax
f01095f3:	c1 e0 03             	shl    $0x3,%eax
f01095f6:	01 c8                	add    %ecx,%eax
f01095f8:	05 5c d5 01 00       	add    $0x1d55c,%eax
f01095fd:	8b 00                	mov    (%eax),%eax
f01095ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109602:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109605:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010960a:	c9                   	leave  
f010960b:	c3                   	ret    

f010960c <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010960c:	55                   	push   %ebp
f010960d:	89 e5                	mov    %esp,%ebp
f010960f:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109612:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109616:	76 19                	jbe    f0109631 <env_table_ws_get_time_stamp+0x25>
f0109618:	68 e8 82 12 f0       	push   $0xf01282e8
f010961d:	68 0e 81 12 f0       	push   $0xf012810e
f0109622:	68 52 01 00 00       	push   $0x152
f0109627:	68 24 81 12 f0       	push   $0xf0128124
f010962c:	e8 e9 6c ff ff       	call   f010031a <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f0109631:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109634:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109637:	89 d0                	mov    %edx,%eax
f0109639:	01 c0                	add    %eax,%eax
f010963b:	01 d0                	add    %edx,%eax
f010963d:	c1 e0 03             	shl    $0x3,%eax
f0109640:	01 c8                	add    %ecx,%eax
f0109642:	05 64 d5 01 00       	add    $0x1d564,%eax
f0109647:	8b 00                	mov    (%eax),%eax
}
f0109649:	c9                   	leave  
f010964a:	c3                   	ret    

f010964b <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010964b:	55                   	push   %ebp
f010964c:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010964e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109651:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109654:	89 d0                	mov    %edx,%eax
f0109656:	01 c0                	add    %eax,%eax
f0109658:	01 d0                	add    %edx,%eax
f010965a:	c1 e0 03             	shl    $0x3,%eax
f010965d:	01 c8                	add    %ecx,%eax
f010965f:	05 60 d5 01 00       	add    $0x1d560,%eax
f0109664:	8a 00                	mov    (%eax),%al
f0109666:	0f b6 c0             	movzbl %al,%eax
}
f0109669:	5d                   	pop    %ebp
f010966a:	c3                   	ret    

f010966b <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010966b:	55                   	push   %ebp
f010966c:	89 e5                	mov    %esp,%ebp
f010966e:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f0109671:	83 ec 04             	sub    $0x4,%esp
f0109674:	68 19 83 12 f0       	push   $0xf0128319
f0109679:	68 62 01 00 00       	push   $0x162
f010967e:	68 24 81 12 f0       	push   $0xf0128124
f0109683:	e8 92 6c ff ff       	call   f010031a <_panic>

f0109688 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f0109688:	55                   	push   %ebp
f0109689:	89 e5                	mov    %esp,%ebp
f010968b:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010968e:	83 ec 04             	sub    $0x4,%esp
f0109691:	68 19 83 12 f0       	push   $0xf0128319
f0109696:	68 67 01 00 00       	push   $0x167
f010969b:	68 24 81 12 f0       	push   $0xf0128124
f01096a0:	e8 75 6c ff ff       	call   f010031a <_panic>

f01096a5 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f01096a5:	55                   	push   %ebp
f01096a6:	89 e5                	mov    %esp,%ebp
f01096a8:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f01096ab:	83 ec 04             	sub    $0x4,%esp
f01096ae:	68 2c 83 12 f0       	push   $0xf012832c
f01096b3:	6a 21                	push   $0x21
f01096b5:	68 5a 83 12 f0       	push   $0xf012835a
f01096ba:	e8 5b 6c ff ff       	call   f010031a <_panic>

f01096bf <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f01096bf:	55                   	push   %ebp
f01096c0:	89 e5                	mov    %esp,%ebp
f01096c2:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f01096c5:	83 ec 04             	sub    $0x4,%esp
f01096c8:	68 78 83 12 f0       	push   $0xf0128378
f01096cd:	6a 34                	push   $0x34
f01096cf:	68 5a 83 12 f0       	push   $0xf012835a
f01096d4:	e8 41 6c ff ff       	call   f010031a <_panic>

f01096d9 <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f01096d9:	55                   	push   %ebp
f01096da:	89 e5                	mov    %esp,%ebp
f01096dc:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f01096df:	83 ec 04             	sub    $0x4,%esp
f01096e2:	68 a8 83 12 f0       	push   $0xf01283a8
f01096e7:	6a 44                	push   $0x44
f01096e9:	68 5a 83 12 f0       	push   $0xf012835a
f01096ee:	e8 27 6c ff ff       	call   f010031a <_panic>

f01096f3 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f01096f3:	55                   	push   %ebp
f01096f4:	89 e5                	mov    %esp,%ebp
f01096f6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f01096f9:	83 ec 04             	sub    $0x4,%esp
f01096fc:	68 d4 83 12 f0       	push   $0xf01283d4
f0109701:	6a 52                	push   $0x52
f0109703:	68 5a 83 12 f0       	push   $0xf012835a
f0109708:	e8 0d 6c ff ff       	call   f010031a <_panic>

f010970d <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010970d:	55                   	push   %ebp
f010970e:	89 e5                	mov    %esp,%ebp
f0109710:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f0109713:	83 ec 04             	sub    $0x4,%esp
f0109716:	68 04 84 12 f0       	push   $0xf0128404
f010971b:	6a 5c                	push   $0x5c
f010971d:	68 5a 83 12 f0       	push   $0xf012835a
f0109722:	e8 f3 6b ff ff       	call   f010031a <_panic>

f0109727 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f0109727:	55                   	push   %ebp
f0109728:	89 e5                	mov    %esp,%ebp
f010972a:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010972d:	83 ec 04             	sub    $0x4,%esp
f0109730:	68 3c 84 12 f0       	push   $0xf012843c
f0109735:	6a 69                	push   $0x69
f0109737:	68 5a 83 12 f0       	push   $0xf012835a
f010973c:	e8 d9 6b ff ff       	call   f010031a <_panic>

f0109741 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f0109741:	55                   	push   %ebp
f0109742:	89 e5                	mov    %esp,%ebp
f0109744:	83 ec 18             	sub    $0x18,%esp
	 * 		or the break exceed the limit of the dynamic allocator. If sys_sbrk fails, the net effect should
	 * 		be that sys_sbrk returns (void*) -1 and that the segment break and the process heap are unaffected.
	 * 		You might have to undo any operations you have done so far in this case.
	 */

	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f0109747:	e8 f9 0f 00 00       	call   f010a745 <get_cpu_proc>
f010974c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	/*====================================*/
	/*Remove this line before start coding*/
	return (void*)-1 ;
f010974f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	/*====================================*/

	//[PROJECT'24.MS2] Implement this function

}
f0109754:	c9                   	leave  
f0109755:	c3                   	ret    

f0109756 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109756:	55                   	push   %ebp
f0109757:	89 e5                	mov    %esp,%ebp
f0109759:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/
	/*Remove this line before start coding*/
	inctst();
f010975c:	e8 63 71 01 00       	call   f01208c4 <inctst>
	return;
f0109761:	90                   	nop
	/*====================================*/

	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] allocate_user_mem
	// Write your code here, remove the panic and write your code
	panic("allocate_user_mem() is not implemented yet...!!");
}
f0109762:	c9                   	leave  
f0109763:	c3                   	ret    

f0109764 <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109764:	55                   	push   %ebp
f0109765:	89 e5                	mov    %esp,%ebp
f0109767:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/
	/*Remove this line before start coding*/
	inctst();
f010976a:	e8 55 71 01 00       	call   f01208c4 <inctst>
	return;
f010976f:	90                   	nop
	/*====================================*/

	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] free_user_mem
	// Write your code here, remove the panic and write your code
	panic("free_user_mem() is not implemented yet...!!");
}
f0109770:	c9                   	leave  
f0109771:	c3                   	ret    

f0109772 <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109772:	55                   	push   %ebp
f0109773:	89 e5                	mov    %esp,%ebp
f0109775:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f0109778:	83 ec 04             	sub    $0x4,%esp
f010977b:	68 74 84 12 f0       	push   $0xf0128474
f0109780:	68 bc 00 00 00       	push   $0xbc
f0109785:	68 5a 83 12 f0       	push   $0xf012835a
f010978a:	e8 8b 6b ff ff       	call   f010031a <_panic>

f010978f <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010978f:	55                   	push   %ebp
f0109790:	89 e5                	mov    %esp,%ebp
f0109792:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f0109795:	83 ec 04             	sub    $0x4,%esp
f0109798:	68 b4 84 12 f0       	push   $0xf01284b4
f010979d:	68 c6 00 00 00       	push   $0xc6
f01097a2:	68 5a 83 12 f0       	push   $0xf012835a
f01097a7:	e8 6e 6b ff ff       	call   f010031a <_panic>

f01097ac <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f01097ac:	55                   	push   %ebp
f01097ad:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f01097af:	8b 45 08             	mov    0x8(%ebp),%eax
f01097b2:	8b 15 c0 48 5a f0    	mov    0xf05a48c0,%edx
f01097b8:	29 d0                	sub    %edx,%eax
f01097ba:	c1 f8 03             	sar    $0x3,%eax
f01097bd:	89 c2                	mov    %eax,%edx
f01097bf:	89 d0                	mov    %edx,%eax
f01097c1:	c1 e0 02             	shl    $0x2,%eax
f01097c4:	01 d0                	add    %edx,%eax
f01097c6:	c1 e0 02             	shl    $0x2,%eax
f01097c9:	01 d0                	add    %edx,%eax
f01097cb:	c1 e0 02             	shl    $0x2,%eax
f01097ce:	01 d0                	add    %edx,%eax
f01097d0:	89 c1                	mov    %eax,%ecx
f01097d2:	c1 e1 08             	shl    $0x8,%ecx
f01097d5:	01 c8                	add    %ecx,%eax
f01097d7:	89 c1                	mov    %eax,%ecx
f01097d9:	c1 e1 10             	shl    $0x10,%ecx
f01097dc:	01 c8                	add    %ecx,%eax
f01097de:	01 c0                	add    %eax,%eax
f01097e0:	01 d0                	add    %edx,%eax
}
f01097e2:	5d                   	pop    %ebp
f01097e3:	c3                   	ret    

f01097e4 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f01097e4:	55                   	push   %ebp
f01097e5:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f01097e7:	ff 75 08             	pushl  0x8(%ebp)
f01097ea:	e8 bd ff ff ff       	call   f01097ac <to_frame_number>
f01097ef:	83 c4 04             	add    $0x4,%esp
f01097f2:	c1 e0 0c             	shl    $0xc,%eax
}
f01097f5:	c9                   	leave  
f01097f6:	c3                   	ret    

f01097f7 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f01097f7:	55                   	push   %ebp
f01097f8:	89 e5                	mov    %esp,%ebp
f01097fa:	56                   	push   %esi
f01097fb:	53                   	push   %ebx
f01097fc:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f01097ff:	c7 45 f4 07 00 00 00 	movl   $0x7,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f0109806:	e9 28 02 00 00       	jmp    f0109a33 <env_init+0x23c>
	{
		envs[iEnv].env_status = ENV_FREE;
f010980b:	8b 0d b0 13 5a f0    	mov    0xf05a13b0,%ecx
f0109811:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109814:	89 d0                	mov    %edx,%eax
f0109816:	c1 e0 06             	shl    $0x6,%eax
f0109819:	29 d0                	sub    %edx,%eax
f010981b:	c1 e0 02             	shl    $0x2,%eax
f010981e:	01 d0                	add    %edx,%eax
f0109820:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109827:	01 d8                	add    %ebx,%eax
f0109829:	c1 e0 03             	shl    $0x3,%eax
f010982c:	01 d0                	add    %edx,%eax
f010982e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109835:	29 c2                	sub    %eax,%edx
f0109837:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010983e:	89 c2                	mov    %eax,%edx
f0109840:	89 d0                	mov    %edx,%eax
f0109842:	01 c8                	add    %ecx,%eax
f0109844:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010984b:	8b 0d b0 13 5a f0    	mov    0xf05a13b0,%ecx
f0109851:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109854:	89 d0                	mov    %edx,%eax
f0109856:	c1 e0 06             	shl    $0x6,%eax
f0109859:	29 d0                	sub    %edx,%eax
f010985b:	c1 e0 02             	shl    $0x2,%eax
f010985e:	01 d0                	add    %edx,%eax
f0109860:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109867:	01 d8                	add    %ebx,%eax
f0109869:	c1 e0 03             	shl    $0x3,%eax
f010986c:	01 d0                	add    %edx,%eax
f010986e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109875:	29 c2                	sub    %eax,%edx
f0109877:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010987e:	89 c2                	mov    %eax,%edx
f0109880:	89 d0                	mov    %edx,%eax
f0109882:	01 c8                	add    %ecx,%eax
f0109884:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010988b:	8b 0d b0 13 5a f0    	mov    0xf05a13b0,%ecx
f0109891:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109894:	89 d0                	mov    %edx,%eax
f0109896:	c1 e0 06             	shl    $0x6,%eax
f0109899:	29 d0                	sub    %edx,%eax
f010989b:	c1 e0 02             	shl    $0x2,%eax
f010989e:	01 d0                	add    %edx,%eax
f01098a0:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01098a7:	01 d8                	add    %ebx,%eax
f01098a9:	c1 e0 03             	shl    $0x3,%eax
f01098ac:	01 d0                	add    %edx,%eax
f01098ae:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01098b5:	29 c2                	sub    %eax,%edx
f01098b7:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01098be:	89 c2                	mov    %eax,%edx
f01098c0:	89 d0                	mov    %edx,%eax
f01098c2:	01 c8                	add    %ecx,%eax
f01098c4:	85 c0                	test   %eax,%eax
f01098c6:	75 14                	jne    f01098dc <env_init+0xe5>
f01098c8:	83 ec 04             	sub    $0x4,%esp
f01098cb:	68 e0 84 12 f0       	push   $0xf01284e0
f01098d0:	6a 64                	push   $0x64
f01098d2:	68 03 85 12 f0       	push   $0xf0128503
f01098d7:	e8 3e 6a ff ff       	call   f010031a <_panic>
f01098dc:	8b 0d b0 13 5a f0    	mov    0xf05a13b0,%ecx
f01098e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01098e5:	89 d0                	mov    %edx,%eax
f01098e7:	c1 e0 06             	shl    $0x6,%eax
f01098ea:	29 d0                	sub    %edx,%eax
f01098ec:	c1 e0 02             	shl    $0x2,%eax
f01098ef:	01 d0                	add    %edx,%eax
f01098f1:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01098f8:	01 d8                	add    %ebx,%eax
f01098fa:	c1 e0 03             	shl    $0x3,%eax
f01098fd:	01 d0                	add    %edx,%eax
f01098ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109906:	29 c2                	sub    %eax,%edx
f0109908:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010990f:	89 c2                	mov    %eax,%edx
f0109911:	89 d0                	mov    %edx,%eax
f0109913:	01 c8                	add    %ecx,%eax
f0109915:	8b 15 b4 13 5a f0    	mov    0xf05a13b4,%edx
f010991b:	89 50 08             	mov    %edx,0x8(%eax)
f010991e:	8b 40 08             	mov    0x8(%eax),%eax
f0109921:	85 c0                	test   %eax,%eax
f0109923:	74 44                	je     f0109969 <env_init+0x172>
f0109925:	8b 0d b4 13 5a f0    	mov    0xf05a13b4,%ecx
f010992b:	8b 1d b0 13 5a f0    	mov    0xf05a13b0,%ebx
f0109931:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109934:	89 d0                	mov    %edx,%eax
f0109936:	c1 e0 06             	shl    $0x6,%eax
f0109939:	29 d0                	sub    %edx,%eax
f010993b:	c1 e0 02             	shl    $0x2,%eax
f010993e:	01 d0                	add    %edx,%eax
f0109940:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
f0109947:	01 f0                	add    %esi,%eax
f0109949:	c1 e0 03             	shl    $0x3,%eax
f010994c:	01 d0                	add    %edx,%eax
f010994e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109955:	29 c2                	sub    %eax,%edx
f0109957:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010995e:	89 c2                	mov    %eax,%edx
f0109960:	89 d0                	mov    %edx,%eax
f0109962:	01 d8                	add    %ebx,%eax
f0109964:	89 41 0c             	mov    %eax,0xc(%ecx)
f0109967:	eb 3e                	jmp    f01099a7 <env_init+0x1b0>
f0109969:	8b 0d b0 13 5a f0    	mov    0xf05a13b0,%ecx
f010996f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109972:	89 d0                	mov    %edx,%eax
f0109974:	c1 e0 06             	shl    $0x6,%eax
f0109977:	29 d0                	sub    %edx,%eax
f0109979:	c1 e0 02             	shl    $0x2,%eax
f010997c:	01 d0                	add    %edx,%eax
f010997e:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109985:	01 d8                	add    %ebx,%eax
f0109987:	c1 e0 03             	shl    $0x3,%eax
f010998a:	01 d0                	add    %edx,%eax
f010998c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109993:	29 c2                	sub    %eax,%edx
f0109995:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010999c:	89 c2                	mov    %eax,%edx
f010999e:	89 d0                	mov    %edx,%eax
f01099a0:	01 c8                	add    %ecx,%eax
f01099a2:	a3 b8 13 5a f0       	mov    %eax,0xf05a13b8
f01099a7:	8b 0d b0 13 5a f0    	mov    0xf05a13b0,%ecx
f01099ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01099b0:	89 d0                	mov    %edx,%eax
f01099b2:	c1 e0 06             	shl    $0x6,%eax
f01099b5:	29 d0                	sub    %edx,%eax
f01099b7:	c1 e0 02             	shl    $0x2,%eax
f01099ba:	01 d0                	add    %edx,%eax
f01099bc:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01099c3:	01 d8                	add    %ebx,%eax
f01099c5:	c1 e0 03             	shl    $0x3,%eax
f01099c8:	01 d0                	add    %edx,%eax
f01099ca:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01099d1:	29 c2                	sub    %eax,%edx
f01099d3:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01099da:	89 c2                	mov    %eax,%edx
f01099dc:	89 d0                	mov    %edx,%eax
f01099de:	01 c8                	add    %ecx,%eax
f01099e0:	a3 b4 13 5a f0       	mov    %eax,0xf05a13b4
f01099e5:	8b 0d b0 13 5a f0    	mov    0xf05a13b0,%ecx
f01099eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01099ee:	89 d0                	mov    %edx,%eax
f01099f0:	c1 e0 06             	shl    $0x6,%eax
f01099f3:	29 d0                	sub    %edx,%eax
f01099f5:	c1 e0 02             	shl    $0x2,%eax
f01099f8:	01 d0                	add    %edx,%eax
f01099fa:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109a01:	01 d8                	add    %ebx,%eax
f0109a03:	c1 e0 03             	shl    $0x3,%eax
f0109a06:	01 d0                	add    %edx,%eax
f0109a08:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109a0f:	29 c2                	sub    %eax,%edx
f0109a11:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109a18:	89 c2                	mov    %eax,%edx
f0109a1a:	89 d0                	mov    %edx,%eax
f0109a1c:	01 c8                	add    %ecx,%eax
f0109a1e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0109a25:	a1 c0 13 5a f0       	mov    0xf05a13c0,%eax
f0109a2a:	40                   	inc    %eax
f0109a2b:	a3 c0 13 5a f0       	mov    %eax,0xf05a13c0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f0109a30:	ff 4d f4             	decl   -0xc(%ebp)
f0109a33:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109a37:	0f 89 ce fd ff ff    	jns    f010980b <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f0109a3d:	90                   	nop
f0109a3e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0109a41:	5b                   	pop    %ebx
f0109a42:	5e                   	pop    %esi
f0109a43:	5d                   	pop    %ebp
f0109a44:	c3                   	ret    

f0109a45 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f0109a45:	55                   	push   %ebp
f0109a46:	89 e5                	mov    %esp,%ebp
f0109a48:	57                   	push   %edi
f0109a49:	56                   	push   %esi
f0109a4a:	53                   	push   %ebx
f0109a4b:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f0109a51:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f0109a58:	83 ec 0c             	sub    $0xc,%esp
f0109a5b:	ff 75 08             	pushl  0x8(%ebp)
f0109a5e:	e8 c8 24 00 00       	call   f010bf2b <get_user_program_info>
f0109a63:	83 c4 10             	add    $0x10,%esp
f0109a66:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if(ptr_user_program_info == 0)
f0109a69:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0109a6d:	75 0a                	jne    f0109a79 <env_create+0x34>
	{
		return NULL;
f0109a6f:	b8 00 00 00 00       	mov    $0x0,%eax
f0109a74:	e9 2a 0c 00 00       	jmp    f010a6a3 <env_create+0xc5e>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f0109a79:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109a7c:	8b 40 08             	mov    0x8(%eax),%eax
f0109a7f:	89 45 b8             	mov    %eax,-0x48(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f0109a82:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f0109a89:	00 00 00 
	if(allocate_environment(&e) < 0)
f0109a8c:	83 ec 0c             	sub    $0xc,%esp
f0109a8f:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
f0109a95:	50                   	push   %eax
f0109a96:	e8 23 11 00 00       	call   f010abbe <allocate_environment>
f0109a9b:	83 c4 10             	add    $0x10,%esp
f0109a9e:	85 c0                	test   %eax,%eax
f0109aa0:	79 0a                	jns    f0109aac <env_create+0x67>
	{
		return NULL;
f0109aa2:	b8 00 00 00 00       	mov    $0x0,%eax
f0109aa7:	e9 f7 0b 00 00       	jmp    f010a6a3 <env_create+0xc5e>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f0109aac:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109aaf:	8b 00                	mov    (%eax),%eax
f0109ab1:	83 ec 0c             	sub    $0xc,%esp
f0109ab4:	50                   	push   %eax
f0109ab5:	e8 52 89 01 00       	call   f012240c <strlen>
f0109aba:	83 c4 10             	add    $0x10,%esp
f0109abd:	83 f8 3f             	cmp    $0x3f,%eax
f0109ac0:	7f 1d                	jg     f0109adf <env_create+0x9a>
		strcpy(e->prog_name, ptr_user_program_info->name);
f0109ac2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109ac5:	8b 00                	mov    (%eax),%eax
f0109ac7:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109acd:	83 c2 20             	add    $0x20,%edx
f0109ad0:	83 ec 08             	sub    $0x8,%esp
f0109ad3:	50                   	push   %eax
f0109ad4:	52                   	push   %edx
f0109ad5:	e8 81 89 01 00       	call   f012245b <strcpy>
f0109ada:	83 c4 10             	add    $0x10,%esp
f0109add:	eb 1d                	jmp    f0109afc <env_create+0xb7>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f0109adf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109ae2:	8b 00                	mov    (%eax),%eax
f0109ae4:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109aea:	83 c2 20             	add    $0x20,%edx
f0109aed:	83 ec 04             	sub    $0x4,%esp
f0109af0:	6a 3f                	push   $0x3f
f0109af2:	50                   	push   %eax
f0109af3:	52                   	push   %edx
f0109af4:	e8 90 89 01 00       	call   f0122489 <strncpy>
f0109af9:	83 c4 10             	add    $0x10,%esp
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
	}
#else
	{
		int r;
		struct FrameInfo *p = NULL;
f0109afc:	c7 85 3c ff ff ff 00 	movl   $0x0,-0xc4(%ebp)
f0109b03:	00 00 00 

		allocate_frame(&p) ;
f0109b06:	83 ec 0c             	sub    $0xc,%esp
f0109b09:	8d 85 3c ff ff ff    	lea    -0xc4(%ebp),%eax
f0109b0f:	50                   	push   %eax
f0109b10:	e8 90 e6 ff ff       	call   f01081a5 <allocate_frame>
f0109b15:	83 c4 10             	add    $0x10,%esp
		p->references = 1;
f0109b18:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0109b1e:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

		ptr_user_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f0109b24:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0109b2a:	83 ec 0c             	sub    $0xc,%esp
f0109b2d:	50                   	push   %eax
f0109b2e:	e8 b1 fc ff ff       	call   f01097e4 <to_physical_address>
f0109b33:	83 c4 10             	add    $0x10,%esp
f0109b36:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0109b39:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0109b3c:	c1 e8 0c             	shr    $0xc,%eax
f0109b3f:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0109b42:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0109b47:	39 45 ac             	cmp    %eax,-0x54(%ebp)
f0109b4a:	72 17                	jb     f0109b63 <env_create+0x11e>
f0109b4c:	ff 75 b0             	pushl  -0x50(%ebp)
f0109b4f:	68 20 85 12 f0       	push   $0xf0128520
f0109b54:	68 9c 00 00 00       	push   $0x9c
f0109b59:	68 03 85 12 f0       	push   $0xf0128503
f0109b5e:	e8 b7 67 ff ff       	call   f010031a <_panic>
f0109b63:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0109b66:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0109b6b:	89 45 a8             	mov    %eax,-0x58(%ebp)
		phys_user_page_directory = to_physical_address(p);
f0109b6e:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0109b74:	83 ec 0c             	sub    $0xc,%esp
f0109b77:	50                   	push   %eax
f0109b78:	e8 67 fc ff ff       	call   f01097e4 <to_physical_address>
f0109b7d:	83 c4 10             	add    $0x10,%esp
f0109b80:	89 45 a4             	mov    %eax,-0x5c(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f0109b83:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109b89:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109b8c:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109b92:	83 ec 0c             	sub    $0xc,%esp
f0109b95:	6a 02                	push   $0x2
f0109b97:	e8 48 4b 00 00       	call   f010e6e4 <isPageReplacmentAlgorithmLRU>
f0109b9c:	83 c4 10             	add    $0x10,%esp
f0109b9f:	85 c0                	test   %eax,%eax
f0109ba1:	74 21                	je     f0109bc4 <env_create+0x17f>
	{
		e->SecondListSize = LRU_second_list_size;
f0109ba3:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109ba9:	8b 55 10             	mov    0x10(%ebp),%edx
f0109bac:	89 90 34 da 01 00    	mov    %edx,0x1da34(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f0109bb2:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109bb8:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109bbb:	2b 55 10             	sub    0x10(%ebp),%edx
f0109bbe:	89 90 30 da 01 00    	mov    %edx,0x1da30(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f0109bc4:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0109bc8:	75 12                	jne    f0109bdc <env_create+0x197>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f0109bca:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109bd0:	c7 80 3c da 01 00 0a 	movl   $0xa,0x1da3c(%eax)
f0109bd7:	00 00 00 
f0109bda:	eb 0f                	jmp    f0109beb <env_create+0x1a6>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f0109bdc:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109be2:	8b 55 14             	mov    0x14(%ebp),%edx
f0109be5:	89 90 3c da 01 00    	mov    %edx,0x1da3c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f0109beb:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109bf1:	83 ec 04             	sub    $0x4,%esp
f0109bf4:	ff 75 a4             	pushl  -0x5c(%ebp)
f0109bf7:	ff 75 a8             	pushl  -0x58(%ebp)
f0109bfa:	50                   	push   %eax
f0109bfb:	e8 76 18 00 00       	call   f010b476 <initialize_environment>
f0109c00:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f0109c03:	e8 8d d5 ff ff       	call   f0107195 <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0109c08:	0f 20 d8             	mov    %cr3,%eax
f0109c0b:	89 45 98             	mov    %eax,-0x68(%ebp)
	return val;
f0109c0e:	8b 45 98             	mov    -0x68(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f0109c11:	89 45 9c             	mov    %eax,-0x64(%ebp)
		lcr3(e->env_cr3) ;
f0109c14:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109c1a:	8b 40 68             	mov    0x68(%eax),%eax
f0109c1d:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0109c23:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0109c29:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f0109c2c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		int segment_counter=0;
f0109c33:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f0109c3a:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109c40:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0109c46:	48                   	dec    %eax
f0109c47:	89 45 dc             	mov    %eax,-0x24(%ebp)
		uint32 lastTableNumber=0xffffffff;
f0109c4a:	c7 85 38 ff ff ff ff 	movl   $0xffffffff,-0xc8(%ebp)
f0109c51:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f0109c54:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
f0109c5a:	83 ec 08             	sub    $0x8,%esp
f0109c5d:	ff 75 b8             	pushl  -0x48(%ebp)
f0109c60:	50                   	push   %eax
f0109c61:	e8 d7 1f 00 00       	call   f010bc3d <PROGRAM_SEGMENT_FIRST>
f0109c66:	83 c4 0c             	add    $0xc,%esp
f0109c69:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0109c6f:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f0109c75:	b9 05 00 00 00       	mov    $0x5,%ecx
f0109c7a:	89 c7                	mov    %eax,%edi
f0109c7c:	89 d6                	mov    %edx,%esi
f0109c7e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0109c80:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0109c86:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0109c89:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109c8c:	8b 40 10             	mov    0x10(%eax),%eax
f0109c8f:	83 f8 ff             	cmp    $0xffffffff,%eax
f0109c92:	75 07                	jne    f0109c9b <env_create+0x256>
f0109c94:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0109c9b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109c9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109ca1:	e9 24 03 00 00       	jmp    f0109fca <env_create+0x585>
		{
			segment_counter++;
f0109ca6:	ff 45 e0             	incl   -0x20(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f0109ca9:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0109cb0:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f0109cb3:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109cb9:	83 ec 0c             	sub    $0xc,%esp
f0109cbc:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0109cc2:	52                   	push   %edx
f0109cc3:	ff 75 dc             	pushl  -0x24(%ebp)
f0109cc6:	8d 95 20 ff ff ff    	lea    -0xe0(%ebp),%edx
f0109ccc:	52                   	push   %edx
f0109ccd:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109cd0:	50                   	push   %eax
f0109cd1:	e8 a6 0f 00 00       	call   f010ac7c <program_segment_alloc_map_copy_workingset>
f0109cd6:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f0109cd9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0109cdf:	29 45 dc             	sub    %eax,-0x24(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f0109ce2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109ce5:	8b 00                	mov    (%eax),%eax
f0109ce7:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f0109cea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109ced:	8b 40 0c             	mov    0xc(%eax),%eax
f0109cf0:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f0109cf3:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109cf6:	89 45 8c             	mov    %eax,-0x74(%ebp)
f0109cf9:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0109cfc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109d01:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f0109d04:	c7 45 84 00 10 00 00 	movl   $0x1000,-0x7c(%ebp)
f0109d0b:	8b 55 90             	mov    -0x70(%ebp),%edx
f0109d0e:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0109d11:	01 d0                	add    %edx,%eax
f0109d13:	48                   	dec    %eax
f0109d14:	89 45 80             	mov    %eax,-0x80(%ebp)
f0109d17:	8b 45 80             	mov    -0x80(%ebp),%eax
f0109d1a:	ba 00 00 00 00       	mov    $0x0,%edx
f0109d1f:	f7 75 84             	divl   -0x7c(%ebp)
f0109d22:	8b 45 80             	mov    -0x80(%ebp),%eax
f0109d25:	29 d0                	sub    %edx,%eax
f0109d27:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f0109d2d:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109d30:	2b 45 88             	sub    -0x78(%ebp),%eax
f0109d33:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			memset(ptr_temp_page , 0, PAGE_SIZE);
f0109d39:	a1 04 4b 5a f0       	mov    0xf05a4b04,%eax
f0109d3e:	83 ec 04             	sub    $0x4,%esp
f0109d41:	68 00 10 00 00       	push   $0x1000
f0109d46:	6a 00                	push   $0x0
f0109d48:	50                   	push   %eax
f0109d49:	e8 ac 88 01 00       	call   f01225fa <memset>
f0109d4e:	83 c4 10             	add    $0x10,%esp
			uint8 *src_ptr =  (uint8*) dataSrc_va;
f0109d51:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0109d54:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f0109d57:	8b 15 04 4b 5a f0    	mov    0xf05a4b04,%edx
f0109d5d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0109d63:	01 d0                	add    %edx,%eax
f0109d65:	89 45 d0             	mov    %eax,-0x30(%ebp)
			int i;
			for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f0109d68:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109d6b:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109d6e:	eb 13                	jmp    f0109d83 <env_create+0x33e>
			{
				*dst_ptr = *src_ptr ;
f0109d70:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109d73:	8a 10                	mov    (%eax),%dl
f0109d75:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109d78:	88 10                	mov    %dl,(%eax)

			memset(ptr_temp_page , 0, PAGE_SIZE);
			uint8 *src_ptr =  (uint8*) dataSrc_va;
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f0109d7a:	ff 45 cc             	incl   -0x34(%ebp)
f0109d7d:	ff 45 d4             	incl   -0x2c(%ebp)
f0109d80:	ff 45 d0             	incl   -0x30(%ebp)
f0109d83:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109d86:	3b 85 7c ff ff ff    	cmp    -0x84(%ebp),%eax
f0109d8c:	72 e2                	jb     f0109d70 <env_create+0x32b>
			{
				*dst_ptr = *src_ptr ;
			}

			if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f0109d8e:	8b 15 04 4b 5a f0    	mov    0xf05a4b04,%edx
f0109d94:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109d9a:	83 ec 04             	sub    $0x4,%esp
f0109d9d:	52                   	push   %edx
f0109d9e:	ff 75 88             	pushl  -0x78(%ebp)
f0109da1:	50                   	push   %eax
f0109da2:	e8 76 a3 ff ff       	call   f010411d <pf_add_env_page>
f0109da7:	83 c4 10             	add    $0x10,%esp
f0109daa:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109dad:	75 17                	jne    f0109dc6 <env_create+0x381>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109daf:	83 ec 04             	sub    $0x4,%esp
f0109db2:	68 50 85 12 f0       	push   $0xf0128550
f0109db7:	68 f2 00 00 00       	push   $0xf2
f0109dbc:	68 03 85 12 f0       	push   $0xf0128503
f0109dc1:	e8 54 65 ff ff       	call   f010031a <_panic>
			//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");


			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f0109dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109dc9:	8b 50 04             	mov    0x4(%eax),%edx
f0109dcc:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109dcf:	01 d0                	add    %edx,%eax
f0109dd1:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0109dd7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0109ddd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109de2:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f0109de8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109deb:	8b 50 04             	mov    0x4(%eax),%edx
f0109dee:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109df1:	01 d0                	add    %edx,%eax
f0109df3:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f0109df9:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f0109dff:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109e02:	eb 43                	jmp    f0109e47 <env_create+0x402>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f0109e04:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0109e07:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109e0d:	83 ec 04             	sub    $0x4,%esp
f0109e10:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109e13:	52                   	push   %edx
f0109e14:	50                   	push   %eax
f0109e15:	e8 03 a3 ff ff       	call   f010411d <pf_add_env_page>
f0109e1a:	83 c4 10             	add    $0x10,%esp
f0109e1d:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109e20:	75 17                	jne    f0109e39 <env_create+0x3f4>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109e22:	83 ec 04             	sub    $0x4,%esp
f0109e25:	68 50 85 12 f0       	push   $0xf0128550
f0109e2a:	68 ff 00 00 00       	push   $0xff
f0109e2f:	68 03 85 12 f0       	push   $0xf0128503
f0109e34:	e8 e1 64 ff ff       	call   f010031a <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f0109e39:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f0109e40:	81 45 d4 00 10 00 00 	addl   $0x1000,-0x2c(%ebp)
f0109e47:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109e4a:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f0109e50:	72 b2                	jb     f0109e04 <env_create+0x3bf>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f0109e52:	a1 04 4b 5a f0       	mov    0xf05a4b04,%eax
f0109e57:	89 45 d0             	mov    %eax,-0x30(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f0109e5a:	83 ec 04             	sub    $0x4,%esp
f0109e5d:	68 00 10 00 00       	push   $0x1000
f0109e62:	6a 00                	push   $0x0
f0109e64:	ff 75 d0             	pushl  -0x30(%ebp)
f0109e67:	e8 8e 87 01 00       	call   f01225fa <memset>
f0109e6c:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f0109e6f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0109e75:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109e78:	eb 13                	jmp    f0109e8d <env_create+0x448>
			{
				*dst_ptr = *src_ptr;
f0109e7a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109e7d:	8a 10                	mov    (%eax),%dl
f0109e7f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109e82:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f0109e84:	ff 45 cc             	incl   -0x34(%ebp)
f0109e87:	ff 45 d4             	incl   -0x2c(%ebp)
f0109e8a:	ff 45 d0             	incl   -0x30(%ebp)
f0109e8d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109e90:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f0109e96:	72 e2                	jb     f0109e7a <env_create+0x435>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f0109e98:	8b 15 04 4b 5a f0    	mov    0xf05a4b04,%edx
f0109e9e:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109ea4:	83 ec 04             	sub    $0x4,%esp
f0109ea7:	52                   	push   %edx
f0109ea8:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
f0109eae:	50                   	push   %eax
f0109eaf:	e8 69 a2 ff ff       	call   f010411d <pf_add_env_page>
f0109eb4:	83 c4 10             	add    $0x10,%esp
f0109eb7:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109eba:	75 17                	jne    f0109ed3 <env_create+0x48e>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109ebc:	83 ec 04             	sub    $0x4,%esp
f0109ebf:	68 50 85 12 f0       	push   $0xf0128550
f0109ec4:	68 0e 01 00 00       	push   $0x10e
f0109ec9:	68 03 85 12 f0       	push   $0xf0128503
f0109ece:	e8 47 64 ff ff       	call   f010031a <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f0109ed3:	c7 85 68 ff ff ff 00 	movl   $0x1000,-0x98(%ebp)
f0109eda:	10 00 00 
f0109edd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109ee0:	8b 50 04             	mov    0x4(%eax),%edx
f0109ee3:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109ee6:	01 c2                	add    %eax,%edx
f0109ee8:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f0109eee:	01 d0                	add    %edx,%eax
f0109ef0:	48                   	dec    %eax
f0109ef1:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f0109ef7:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0109efd:	ba 00 00 00 00       	mov    $0x0,%edx
f0109f02:	f7 b5 68 ff ff ff    	divl   -0x98(%ebp)
f0109f08:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0109f0e:	29 d0                	sub    %edx,%eax
f0109f10:	89 45 c8             	mov    %eax,-0x38(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f0109f13:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109f16:	8b 50 08             	mov    0x8(%eax),%edx
f0109f19:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109f1c:	01 d0                	add    %edx,%eax
f0109f1e:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109f21:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f0109f27:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0109f2e:	eb 41                	jmp    f0109f71 <env_create+0x52c>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f0109f30:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109f36:	83 ec 04             	sub    $0x4,%esp
f0109f39:	6a 01                	push   $0x1
f0109f3b:	ff 75 c8             	pushl  -0x38(%ebp)
f0109f3e:	50                   	push   %eax
f0109f3f:	e8 ab a0 ff ff       	call   f0103fef <pf_add_empty_env_page>
f0109f44:	83 c4 10             	add    $0x10,%esp
f0109f47:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109f4a:	75 17                	jne    f0109f63 <env_create+0x51e>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109f4c:	83 ec 04             	sub    $0x4,%esp
f0109f4f:	68 50 85 12 f0       	push   $0xf0128550
f0109f54:	68 1b 01 00 00       	push   $0x11b
f0109f59:	68 03 85 12 f0       	push   $0xf0128503
f0109f5e:	e8 b7 63 ff ff       	call   f010031a <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f0109f63:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f0109f6a:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f0109f71:	c7 85 5c ff ff ff 00 	movl   $0x1000,-0xa4(%ebp)
f0109f78:	10 00 00 
f0109f7b:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
f0109f81:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109f87:	01 d0                	add    %edx,%eax
f0109f89:	48                   	dec    %eax
f0109f8a:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
f0109f90:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0109f96:	ba 00 00 00 00       	mov    $0x0,%edx
f0109f9b:	f7 b5 5c ff ff ff    	divl   -0xa4(%ebp)
f0109fa1:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0109fa7:	29 d0                	sub    %edx,%eax
f0109fa9:	89 c2                	mov    %eax,%edx
f0109fab:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109fae:	39 c2                	cmp    %eax,%edx
f0109fb0:	0f 87 7a ff ff ff    	ja     f0109f30 <env_create+0x4eb>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f0109fb6:	83 ec 08             	sub    $0x8,%esp
f0109fb9:	ff 75 b8             	pushl  -0x48(%ebp)
f0109fbc:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109fbf:	e8 6e 1b 00 00       	call   f010bb32 <PROGRAM_SEGMENT_NEXT>
f0109fc4:	83 c4 10             	add    $0x10,%esp
f0109fc7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109fca:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109fce:	0f 85 d2 fc ff ff    	jne    f0109ca6 <env_create+0x261>
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
		}
#else
		int i=0;
f0109fd4:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		for(;i<(e->page_WS_max_size); i++)
f0109fdb:	e9 a0 00 00 00       	jmp    f010a080 <env_create+0x63b>
		{
			if(e->ptr_pageWorkingSet[i].empty == 0)
f0109fe0:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109fe6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0109fe9:	89 d0                	mov    %edx,%eax
f0109feb:	01 c0                	add    %eax,%eax
f0109fed:	01 d0                	add    %edx,%eax
f0109fef:	c1 e0 03             	shl    $0x3,%eax
f0109ff2:	01 c8                	add    %ecx,%eax
f0109ff4:	05 8c 00 00 00       	add    $0x8c,%eax
f0109ff9:	8a 00                	mov    (%eax),%al
f0109ffb:	84 c0                	test   %al,%al
f0109ffd:	75 7e                	jne    f010a07d <env_create+0x638>
			{
				uint32 virtual_address = e->ptr_pageWorkingSet[i].virtual_address;
f0109fff:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a005:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010a008:	89 d0                	mov    %edx,%eax
f010a00a:	01 c0                	add    %eax,%eax
f010a00c:	01 d0                	add    %edx,%eax
f010a00e:	c1 e0 03             	shl    $0x3,%eax
f010a011:	01 c8                	add    %ecx,%eax
f010a013:	05 88 00 00 00       	add    $0x88,%eax
f010a018:	8b 00                	mov    (%eax),%eax
f010a01a:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
				uint32* ptr_page_table;

				//Here, page tables of all working set pages should be exist in memory
				//So, get_page_table should return the existing table
				get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010a020:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a026:	8b 40 64             	mov    0x64(%eax),%eax
f010a029:	83 ec 04             	sub    $0x4,%esp
f010a02c:	8d 95 1c ff ff ff    	lea    -0xe4(%ebp),%edx
f010a032:	52                   	push   %edx
f010a033:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f010a039:	50                   	push   %eax
f010a03a:	e8 a3 e3 ff ff       	call   f01083e2 <get_page_table>
f010a03f:	83 c4 10             	add    $0x10,%esp
				ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010a042:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f010a048:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
f010a04e:	c1 ea 0c             	shr    $0xc,%edx
f010a051:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a057:	c1 e2 02             	shl    $0x2,%edx
f010a05a:	01 d0                	add    %edx,%eax
f010a05c:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
f010a062:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
f010a068:	c1 e9 0c             	shr    $0xc,%ecx
f010a06b:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010a071:	c1 e1 02             	shl    $0x2,%ecx
f010a074:	01 ca                	add    %ecx,%edx
f010a076:	8b 12                	mov    (%edx),%edx
f010a078:	83 e2 bf             	and    $0xffffffbf,%edx
f010a07b:	89 10                	mov    %edx,(%eax)
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
		}
#else
		int i=0;
		for(;i<(e->page_WS_max_size); i++)
f010a07d:	ff 45 c4             	incl   -0x3c(%ebp)
f010a080:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a086:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f010a08c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a08f:	39 c2                	cmp    %eax,%edx
f010a091:	0f 87 49 ff ff ff    	ja     f0109fe0 <env_create+0x59b>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010a097:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010a09a:	8b 50 08             	mov    0x8(%eax),%edx
f010a09d:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a0a3:	83 ec 08             	sub    $0x8,%esp
f010a0a6:	52                   	push   %edx
f010a0a7:	50                   	push   %eax
f010a0a8:	e8 45 1a 00 00       	call   f010baf2 <set_environment_entry_point>
f010a0ad:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010a0b0:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a0b6:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010a0bd:	c7 85 50 ff ff ff 00 	movl   $0xeebfd000,-0xb0(%ebp)
f010a0c4:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010a0c7:	c7 45 c0 00 d0 bf ee 	movl   $0xeebfd000,-0x40(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010a0ce:	e9 27 05 00 00       	jmp    f010a5fa <env_create+0xbb5>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010a0d3:	c7 85 18 ff ff ff 00 	movl   $0x0,-0xe8(%ebp)
f010a0da:	00 00 00 
			allocate_frame(&pp);
f010a0dd:	83 ec 0c             	sub    $0xc,%esp
f010a0e0:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010a0e6:	50                   	push   %eax
f010a0e7:	e8 b9 e0 ff ff       	call   f01081a5 <allocate_frame>
f010a0ec:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010a0ef:	8b 95 18 ff ff ff    	mov    -0xe8(%ebp),%edx
f010a0f5:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a0fb:	8b 40 64             	mov    0x64(%eax),%eax
f010a0fe:	6a 06                	push   $0x6
f010a100:	ff 75 c0             	pushl  -0x40(%ebp)
f010a103:	52                   	push   %edx
f010a104:	50                   	push   %eax
f010a105:	e8 af e6 ff ff       	call   f01087b9 <loadtime_map_frame>
f010a10a:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010a10d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a110:	83 ec 04             	sub    $0x4,%esp
f010a113:	68 00 10 00 00       	push   $0x1000
f010a118:	6a 00                	push   $0x0
f010a11a:	50                   	push   %eax
f010a11b:	e8 da 84 01 00       	call   f01225fa <memset>
f010a120:	83 c4 10             	add    $0x10,%esp
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
					}
				}
#else
				env_page_ws_set_entry(e, e->page_last_WS_index, (uint32) stackVa) ;
f010a123:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a129:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010a12f:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a135:	83 ec 04             	sub    $0x4,%esp
f010a138:	ff 75 c0             	pushl  -0x40(%ebp)
f010a13b:	52                   	push   %edx
f010a13c:	50                   	push   %eax
f010a13d:	e8 ae ec ff ff       	call   f0108df0 <env_page_ws_set_entry>
f010a142:	83 c4 10             	add    $0x10,%esp
				uint32 lastWSIndex = e->page_last_WS_index ++;
f010a145:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a14b:	8b 82 58 d5 01 00    	mov    0x1d558(%edx),%eax
f010a151:	8d 48 01             	lea    0x1(%eax),%ecx
f010a154:	89 8a 58 d5 01 00    	mov    %ecx,0x1d558(%edx)
f010a15a:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
				e->page_last_WS_index %= (e->page_WS_max_size);
f010a160:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a166:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a16c:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f010a172:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a178:	8b 9a 84 00 00 00    	mov    0x84(%edx),%ebx
f010a17e:	ba 00 00 00 00       	mov    $0x0,%edx
f010a183:	f7 f3                	div    %ebx
f010a185:	89 d0                	mov    %edx,%eax
f010a187:	89 81 58 d5 01 00    	mov    %eax,0x1d558(%ecx)

				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a18d:	83 ec 0c             	sub    $0xc,%esp
f010a190:	6a 02                	push   $0x2
f010a192:	e8 4d 45 00 00       	call   f010e6e4 <isPageReplacmentAlgorithmLRU>
f010a197:	83 c4 10             	add    $0x10,%esp
f010a19a:	85 c0                	test   %eax,%eax
f010a19c:	0f 84 34 04 00 00    	je     f010a5d6 <env_create+0xb91>
				{
					LIST_REMOVE(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f010a1a2:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a1a8:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a1ae:	89 d0                	mov    %edx,%eax
f010a1b0:	01 c0                	add    %eax,%eax
f010a1b2:	01 d0                	add    %edx,%eax
f010a1b4:	c1 e0 03             	shl    $0x3,%eax
f010a1b7:	83 e8 80             	sub    $0xffffff80,%eax
f010a1ba:	01 c8                	add    %ecx,%eax
f010a1bc:	83 c0 08             	add    $0x8,%eax
f010a1bf:	85 c0                	test   %eax,%eax
f010a1c1:	75 17                	jne    f010a1da <env_create+0x795>
f010a1c3:	83 ec 04             	sub    $0x4,%esp
f010a1c6:	68 95 85 12 f0       	push   $0xf0128595
f010a1cb:	68 7a 01 00 00       	push   $0x17a
f010a1d0:	68 03 85 12 f0       	push   $0xf0128503
f010a1d5:	e8 40 61 ff ff       	call   f010031a <_panic>
f010a1da:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a1e0:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a1e6:	89 d0                	mov    %edx,%eax
f010a1e8:	01 c0                	add    %eax,%eax
f010a1ea:	01 d0                	add    %edx,%eax
f010a1ec:	c1 e0 03             	shl    $0x3,%eax
f010a1ef:	01 c8                	add    %ecx,%eax
f010a1f1:	05 98 00 00 00       	add    $0x98,%eax
f010a1f6:	8b 00                	mov    (%eax),%eax
f010a1f8:	85 c0                	test   %eax,%eax
f010a1fa:	74 41                	je     f010a23d <env_create+0x7f8>
f010a1fc:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a202:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a208:	89 d0                	mov    %edx,%eax
f010a20a:	01 c0                	add    %eax,%eax
f010a20c:	01 d0                	add    %edx,%eax
f010a20e:	c1 e0 03             	shl    $0x3,%eax
f010a211:	01 c8                	add    %ecx,%eax
f010a213:	05 98 00 00 00       	add    $0x98,%eax
f010a218:	8b 10                	mov    (%eax),%edx
f010a21a:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a220:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a226:	89 c8                	mov    %ecx,%eax
f010a228:	01 c0                	add    %eax,%eax
f010a22a:	01 c8                	add    %ecx,%eax
f010a22c:	c1 e0 03             	shl    $0x3,%eax
f010a22f:	01 d8                	add    %ebx,%eax
f010a231:	05 9c 00 00 00       	add    $0x9c,%eax
f010a236:	8b 00                	mov    (%eax),%eax
f010a238:	89 42 14             	mov    %eax,0x14(%edx)
f010a23b:	eb 2a                	jmp    f010a267 <env_create+0x822>
f010a23d:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a243:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a249:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a24f:	89 c8                	mov    %ecx,%eax
f010a251:	01 c0                	add    %eax,%eax
f010a253:	01 c8                	add    %ecx,%eax
f010a255:	c1 e0 03             	shl    $0x3,%eax
f010a258:	01 d8                	add    %ebx,%eax
f010a25a:	05 9c 00 00 00       	add    $0x9c,%eax
f010a25f:	8b 00                	mov    (%eax),%eax
f010a261:	89 82 4c d5 01 00    	mov    %eax,0x1d54c(%edx)
f010a267:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a26d:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a273:	89 d0                	mov    %edx,%eax
f010a275:	01 c0                	add    %eax,%eax
f010a277:	01 d0                	add    %edx,%eax
f010a279:	c1 e0 03             	shl    $0x3,%eax
f010a27c:	01 c8                	add    %ecx,%eax
f010a27e:	05 9c 00 00 00       	add    $0x9c,%eax
f010a283:	8b 00                	mov    (%eax),%eax
f010a285:	85 c0                	test   %eax,%eax
f010a287:	74 41                	je     f010a2ca <env_create+0x885>
f010a289:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a28f:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a295:	89 d0                	mov    %edx,%eax
f010a297:	01 c0                	add    %eax,%eax
f010a299:	01 d0                	add    %edx,%eax
f010a29b:	c1 e0 03             	shl    $0x3,%eax
f010a29e:	01 c8                	add    %ecx,%eax
f010a2a0:	05 9c 00 00 00       	add    $0x9c,%eax
f010a2a5:	8b 10                	mov    (%eax),%edx
f010a2a7:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a2ad:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a2b3:	89 c8                	mov    %ecx,%eax
f010a2b5:	01 c0                	add    %eax,%eax
f010a2b7:	01 c8                	add    %ecx,%eax
f010a2b9:	c1 e0 03             	shl    $0x3,%eax
f010a2bc:	01 d8                	add    %ebx,%eax
f010a2be:	05 98 00 00 00       	add    $0x98,%eax
f010a2c3:	8b 00                	mov    (%eax),%eax
f010a2c5:	89 42 10             	mov    %eax,0x10(%edx)
f010a2c8:	eb 2a                	jmp    f010a2f4 <env_create+0x8af>
f010a2ca:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a2d0:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a2d6:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a2dc:	89 c8                	mov    %ecx,%eax
f010a2de:	01 c0                	add    %eax,%eax
f010a2e0:	01 c8                	add    %ecx,%eax
f010a2e2:	c1 e0 03             	shl    $0x3,%eax
f010a2e5:	01 d8                	add    %ebx,%eax
f010a2e7:	05 98 00 00 00       	add    $0x98,%eax
f010a2ec:	8b 00                	mov    (%eax),%eax
f010a2ee:	89 82 48 d5 01 00    	mov    %eax,0x1d548(%edx)
f010a2f4:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a2fa:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a300:	89 d0                	mov    %edx,%eax
f010a302:	01 c0                	add    %eax,%eax
f010a304:	01 d0                	add    %edx,%eax
f010a306:	c1 e0 03             	shl    $0x3,%eax
f010a309:	01 c8                	add    %ecx,%eax
f010a30b:	05 98 00 00 00       	add    $0x98,%eax
f010a310:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a316:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a31c:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a322:	89 d0                	mov    %edx,%eax
f010a324:	01 c0                	add    %eax,%eax
f010a326:	01 d0                	add    %edx,%eax
f010a328:	c1 e0 03             	shl    $0x3,%eax
f010a32b:	01 c8                	add    %ecx,%eax
f010a32d:	05 9c 00 00 00       	add    $0x9c,%eax
f010a332:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a338:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a33e:	8b 90 54 d5 01 00    	mov    0x1d554(%eax),%edx
f010a344:	4a                   	dec    %edx
f010a345:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010a34b:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a351:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010a357:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a35d:	8b 80 30 da 01 00    	mov    0x1da30(%eax),%eax
f010a363:	39 c2                	cmp    %eax,%edx
f010a365:	0f 83 38 01 00 00    	jae    f010a4a3 <env_create+0xa5e>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f010a36b:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a371:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a377:	89 d0                	mov    %edx,%eax
f010a379:	01 c0                	add    %eax,%eax
f010a37b:	01 d0                	add    %edx,%eax
f010a37d:	c1 e0 03             	shl    $0x3,%eax
f010a380:	83 e8 80             	sub    $0xffffff80,%eax
f010a383:	01 c8                	add    %ecx,%eax
f010a385:	83 c0 08             	add    $0x8,%eax
f010a388:	85 c0                	test   %eax,%eax
f010a38a:	75 17                	jne    f010a3a3 <env_create+0x95e>
f010a38c:	83 ec 04             	sub    $0x4,%esp
f010a38f:	68 e0 84 12 f0       	push   $0xf01284e0
f010a394:	68 7f 01 00 00       	push   $0x17f
f010a399:	68 03 85 12 f0       	push   $0xf0128503
f010a39e:	e8 77 5f ff ff       	call   f010031a <_panic>
f010a3a3:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a3a9:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a3af:	8b 88 10 da 01 00    	mov    0x1da10(%eax),%ecx
f010a3b5:	8b 9d 4c ff ff ff    	mov    -0xb4(%ebp),%ebx
f010a3bb:	89 d8                	mov    %ebx,%eax
f010a3bd:	01 c0                	add    %eax,%eax
f010a3bf:	01 d8                	add    %ebx,%eax
f010a3c1:	c1 e0 03             	shl    $0x3,%eax
f010a3c4:	01 d0                	add    %edx,%eax
f010a3c6:	05 98 00 00 00       	add    $0x98,%eax
f010a3cb:	89 08                	mov    %ecx,(%eax)
f010a3cd:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a3d3:	89 c8                	mov    %ecx,%eax
f010a3d5:	01 c0                	add    %eax,%eax
f010a3d7:	01 c8                	add    %ecx,%eax
f010a3d9:	c1 e0 03             	shl    $0x3,%eax
f010a3dc:	01 d0                	add    %edx,%eax
f010a3de:	05 98 00 00 00       	add    $0x98,%eax
f010a3e3:	8b 00                	mov    (%eax),%eax
f010a3e5:	85 c0                	test   %eax,%eax
f010a3e7:	74 2e                	je     f010a417 <env_create+0x9d2>
f010a3e9:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a3ef:	8b 90 10 da 01 00    	mov    0x1da10(%eax),%edx
f010a3f5:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a3fb:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a401:	89 c8                	mov    %ecx,%eax
f010a403:	01 c0                	add    %eax,%eax
f010a405:	01 c8                	add    %ecx,%eax
f010a407:	c1 e0 03             	shl    $0x3,%eax
f010a40a:	83 e8 80             	sub    $0xffffff80,%eax
f010a40d:	01 d8                	add    %ebx,%eax
f010a40f:	83 c0 08             	add    $0x8,%eax
f010a412:	89 42 14             	mov    %eax,0x14(%edx)
f010a415:	eb 29                	jmp    f010a440 <env_create+0x9fb>
f010a417:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a41d:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a423:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a429:	89 c8                	mov    %ecx,%eax
f010a42b:	01 c0                	add    %eax,%eax
f010a42d:	01 c8                	add    %ecx,%eax
f010a42f:	c1 e0 03             	shl    $0x3,%eax
f010a432:	83 e8 80             	sub    $0xffffff80,%eax
f010a435:	01 d8                	add    %ebx,%eax
f010a437:	83 c0 08             	add    $0x8,%eax
f010a43a:	89 82 14 da 01 00    	mov    %eax,0x1da14(%edx)
f010a440:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a446:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a44c:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a452:	89 c8                	mov    %ecx,%eax
f010a454:	01 c0                	add    %eax,%eax
f010a456:	01 c8                	add    %ecx,%eax
f010a458:	c1 e0 03             	shl    $0x3,%eax
f010a45b:	83 e8 80             	sub    $0xffffff80,%eax
f010a45e:	01 d8                	add    %ebx,%eax
f010a460:	83 c0 08             	add    $0x8,%eax
f010a463:	89 82 10 da 01 00    	mov    %eax,0x1da10(%edx)
f010a469:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a46f:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a475:	89 d0                	mov    %edx,%eax
f010a477:	01 c0                	add    %eax,%eax
f010a479:	01 d0                	add    %edx,%eax
f010a47b:	c1 e0 03             	shl    $0x3,%eax
f010a47e:	01 c8                	add    %ecx,%eax
f010a480:	05 9c 00 00 00       	add    $0x9c,%eax
f010a485:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a48b:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a491:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010a497:	42                   	inc    %edx
f010a498:	89 90 1c da 01 00    	mov    %edx,0x1da1c(%eax)
f010a49e:	e9 33 01 00 00       	jmp    f010a5d6 <env_create+0xb91>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f010a4a3:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a4a9:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a4af:	89 d0                	mov    %edx,%eax
f010a4b1:	01 c0                	add    %eax,%eax
f010a4b3:	01 d0                	add    %edx,%eax
f010a4b5:	c1 e0 03             	shl    $0x3,%eax
f010a4b8:	83 e8 80             	sub    $0xffffff80,%eax
f010a4bb:	01 c8                	add    %ecx,%eax
f010a4bd:	83 c0 08             	add    $0x8,%eax
f010a4c0:	85 c0                	test   %eax,%eax
f010a4c2:	75 17                	jne    f010a4db <env_create+0xa96>
f010a4c4:	83 ec 04             	sub    $0x4,%esp
f010a4c7:	68 e0 84 12 f0       	push   $0xf01284e0
f010a4cc:	68 83 01 00 00       	push   $0x183
f010a4d1:	68 03 85 12 f0       	push   $0xf0128503
f010a4d6:	e8 3f 5e ff ff       	call   f010031a <_panic>
f010a4db:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a4e1:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a4e7:	8b 88 20 da 01 00    	mov    0x1da20(%eax),%ecx
f010a4ed:	8b 9d 4c ff ff ff    	mov    -0xb4(%ebp),%ebx
f010a4f3:	89 d8                	mov    %ebx,%eax
f010a4f5:	01 c0                	add    %eax,%eax
f010a4f7:	01 d8                	add    %ebx,%eax
f010a4f9:	c1 e0 03             	shl    $0x3,%eax
f010a4fc:	01 d0                	add    %edx,%eax
f010a4fe:	05 98 00 00 00       	add    $0x98,%eax
f010a503:	89 08                	mov    %ecx,(%eax)
f010a505:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a50b:	89 c8                	mov    %ecx,%eax
f010a50d:	01 c0                	add    %eax,%eax
f010a50f:	01 c8                	add    %ecx,%eax
f010a511:	c1 e0 03             	shl    $0x3,%eax
f010a514:	01 d0                	add    %edx,%eax
f010a516:	05 98 00 00 00       	add    $0x98,%eax
f010a51b:	8b 00                	mov    (%eax),%eax
f010a51d:	85 c0                	test   %eax,%eax
f010a51f:	74 2e                	je     f010a54f <env_create+0xb0a>
f010a521:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a527:	8b 90 20 da 01 00    	mov    0x1da20(%eax),%edx
f010a52d:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a533:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a539:	89 c8                	mov    %ecx,%eax
f010a53b:	01 c0                	add    %eax,%eax
f010a53d:	01 c8                	add    %ecx,%eax
f010a53f:	c1 e0 03             	shl    $0x3,%eax
f010a542:	83 e8 80             	sub    $0xffffff80,%eax
f010a545:	01 d8                	add    %ebx,%eax
f010a547:	83 c0 08             	add    $0x8,%eax
f010a54a:	89 42 14             	mov    %eax,0x14(%edx)
f010a54d:	eb 29                	jmp    f010a578 <env_create+0xb33>
f010a54f:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a555:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a55b:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a561:	89 c8                	mov    %ecx,%eax
f010a563:	01 c0                	add    %eax,%eax
f010a565:	01 c8                	add    %ecx,%eax
f010a567:	c1 e0 03             	shl    $0x3,%eax
f010a56a:	83 e8 80             	sub    $0xffffff80,%eax
f010a56d:	01 d8                	add    %ebx,%eax
f010a56f:	83 c0 08             	add    $0x8,%eax
f010a572:	89 82 24 da 01 00    	mov    %eax,0x1da24(%edx)
f010a578:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a57e:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a584:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a58a:	89 c8                	mov    %ecx,%eax
f010a58c:	01 c0                	add    %eax,%eax
f010a58e:	01 c8                	add    %ecx,%eax
f010a590:	c1 e0 03             	shl    $0x3,%eax
f010a593:	83 e8 80             	sub    $0xffffff80,%eax
f010a596:	01 d8                	add    %ebx,%eax
f010a598:	83 c0 08             	add    $0x8,%eax
f010a59b:	89 82 20 da 01 00    	mov    %eax,0x1da20(%edx)
f010a5a1:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a5a7:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a5ad:	89 d0                	mov    %edx,%eax
f010a5af:	01 c0                	add    %eax,%eax
f010a5b1:	01 d0                	add    %edx,%eax
f010a5b3:	c1 e0 03             	shl    $0x3,%eax
f010a5b6:	01 c8                	add    %ecx,%eax
f010a5b8:	05 9c 00 00 00       	add    $0x9c,%eax
f010a5bd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a5c3:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a5c9:	8b 90 2c da 01 00    	mov    0x1da2c(%eax),%edx
f010a5cf:	42                   	inc    %edx
f010a5d0:	89 90 2c da 01 00    	mov    %edx,0x1da2c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010a5d6:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a5dc:	83 ec 04             	sub    $0x4,%esp
f010a5df:	6a 01                	push   $0x1
f010a5e1:	ff 75 c0             	pushl  -0x40(%ebp)
f010a5e4:	50                   	push   %eax
f010a5e5:	e8 05 9a ff ff       	call   f0103fef <pf_add_empty_env_page>
f010a5ea:	83 c4 10             	add    $0x10,%esp
f010a5ed:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010a5f3:	81 6d c0 00 10 00 00 	subl   $0x1000,-0x40(%ebp)
f010a5fa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a5fd:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
f010a603:	0f 83 ca fa ff ff    	jae    f010a0d3 <env_create+0x68e>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a609:	83 ec 0c             	sub    $0xc,%esp
f010a60c:	6a 02                	push   $0x2
f010a60e:	e8 d1 40 00 00       	call   f010e6e4 <isPageReplacmentAlgorithmLRU>
f010a613:	83 c4 10             	add    $0x10,%esp
f010a616:	85 c0                	test   %eax,%eax
f010a618:	74 72                	je     f010a68c <env_create+0xc47>
		{
			struct WorkingSetElement * elm = NULL;
f010a61a:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010a621:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a627:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f010a62d:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010a630:	eb 2b                	jmp    f010a65d <env_create+0xc18>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010a632:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010a635:	8b 10                	mov    (%eax),%edx
f010a637:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a63d:	8b 40 64             	mov    0x64(%eax),%eax
f010a640:	6a 01                	push   $0x1
f010a642:	6a 00                	push   $0x0
f010a644:	52                   	push   %edx
f010a645:	50                   	push   %eax
f010a646:	e8 b2 e4 ff ff       	call   f0108afd <pt_set_page_permissions>
f010a64b:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010a64e:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a654:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f010a65a:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010a65d:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a663:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010a667:	74 08                	je     f010a671 <env_create+0xc2c>
f010a669:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010a66c:	8b 52 10             	mov    0x10(%edx),%edx
f010a66f:	eb 05                	jmp    f010a676 <env_create+0xc31>
f010a671:	ba 00 00 00 00       	mov    $0x0,%edx
f010a676:	89 90 28 da 01 00    	mov    %edx,0x1da28(%eax)
f010a67c:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f010a682:	85 c0                	test   %eax,%eax
f010a684:	75 ac                	jne    f010a632 <env_create+0xbed>
f010a686:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010a68a:	75 a6                	jne    f010a632 <env_create+0xbed>
f010a68c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010a68f:	89 45 a0             	mov    %eax,-0x60(%ebp)
f010a692:	8b 45 a0             	mov    -0x60(%ebp),%eax
f010a695:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010a698:	e8 4a cb ff ff       	call   f01071e7 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010a69d:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
}
f010a6a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010a6a6:	5b                   	pop    %ebx
f010a6a7:	5e                   	pop    %esi
f010a6a8:	5f                   	pop    %edi
f010a6a9:	5d                   	pop    %ebp
f010a6aa:	c3                   	ret    

f010a6ab <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010a6ab:	55                   	push   %ebp
f010a6ac:	89 e5                	mov    %esp,%ebp
f010a6ae:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010a6b1:	83 ec 0c             	sub    $0xc,%esp
f010a6b4:	68 00 1e 5a f0       	push   $0xf05a1e00
f010a6b9:	e8 be 44 00 00       	call   f010eb7c <release_spinlock>
f010a6be:	83 c4 10             	add    $0x10,%esp

	if (first)
f010a6c1:	a1 60 09 18 f0       	mov    0xf0180960,%eax
f010a6c6:	85 c0                	test   %eax,%eax
f010a6c8:	74 30                	je     f010a6fa <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010a6ca:	e8 76 00 00 00       	call   f010a745 <get_cpu_proc>
f010a6cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010a6d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a6d5:	8b 40 10             	mov    0x10(%eax),%eax
f010a6d8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a6db:	83 c2 20             	add    $0x20,%edx
f010a6de:	83 ec 04             	sub    $0x4,%esp
f010a6e1:	50                   	push   %eax
f010a6e2:	52                   	push   %edx
f010a6e3:	68 b3 85 12 f0       	push   $0xf01285b3
f010a6e8:	e8 7f 68 ff ff       	call   f0100f6c <cprintf>
f010a6ed:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010a6f0:	c7 05 60 09 18 f0 00 	movl   $0x0,0xf0180960
f010a6f7:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010a6fa:	90                   	nop
f010a6fb:	c9                   	leave  
f010a6fc:	c3                   	ret    

f010a6fd <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010a6fd:	55                   	push   %ebp
f010a6fe:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010a700:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010a701:	5d                   	pop    %ebp
f010a702:	c3                   	ret    

f010a703 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010a703:	55                   	push   %ebp
f010a704:	89 e5                	mov    %esp,%ebp
f010a706:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010a709:	e8 37 00 00 00       	call   f010a745 <get_cpu_proc>
f010a70e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010a711:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a715:	75 19                	jne    f010a730 <env_exit+0x2d>
f010a717:	68 c9 85 12 f0       	push   $0xf01285c9
f010a71c:	68 d9 85 12 f0       	push   $0xf01285d9
f010a721:	68 ea 01 00 00       	push   $0x1ea
f010a726:	68 03 85 12 f0       	push   $0xf0128503
f010a72b:	e8 ea 5b ff ff       	call   f010031a <_panic>
	sched_exit_env(cur_env->env_id);
f010a730:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a733:	8b 40 10             	mov    0x10(%eax),%eax
f010a736:	83 ec 0c             	sub    $0xc,%esp
f010a739:	50                   	push   %eax
f010a73a:	e8 48 b0 ff ff       	call   f0105787 <sched_exit_env>
f010a73f:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010a742:	90                   	nop
f010a743:	c9                   	leave  
f010a744:	c3                   	ret    

f010a745 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010a745:	55                   	push   %ebp
f010a746:	89 e5                	mov    %esp,%ebp
f010a748:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010a74b:	e8 45 ca ff ff       	call   f0107195 <pushcli>
	c = mycpu();
f010a750:	e8 7d c9 ff ff       	call   f01070d2 <mycpu>
f010a755:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010a758:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a75b:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010a761:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010a764:	e8 7e ca ff ff       	call   f01071e7 <popcli>
	return p;
f010a769:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010a76c:	c9                   	leave  
f010a76d:	c3                   	ret    

f010a76e <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010a76e:	55                   	push   %ebp
f010a76f:	89 e5                	mov    %esp,%ebp
f010a771:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010a774:	e8 1c ca ff ff       	call   f0107195 <pushcli>
	c = mycpu();
f010a779:	e8 54 c9 ff ff       	call   f01070d2 <mycpu>
f010a77e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010a781:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a784:	8b 55 08             	mov    0x8(%ebp),%edx
f010a787:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010a78d:	e8 55 ca ff ff       	call   f01071e7 <popcli>
}
f010a792:	90                   	nop
f010a793:	c9                   	leave  
f010a794:	c3                   	ret    

f010a795 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010a795:	55                   	push   %ebp
f010a796:	89 e5                	mov    %esp,%ebp
f010a798:	53                   	push   %ebx
f010a799:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010a79c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a7a0:	75 16                	jne    f010a7b8 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010a7a2:	e8 9e ff ff ff       	call   f010a745 <get_cpu_proc>
f010a7a7:	89 c2                	mov    %eax,%edx
f010a7a9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a7ac:	89 10                	mov    %edx,(%eax)
		return 0;
f010a7ae:	b8 00 00 00 00       	mov    $0x0,%eax
f010a7b3:	e9 b6 00 00 00       	jmp    f010a86e <envid2env+0xd9>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010a7b8:	8b 1d b0 13 5a f0    	mov    0xf05a13b0,%ebx
f010a7be:	83 ec 0c             	sub    $0xc,%esp
f010a7c1:	6a 08                	push   $0x8
f010a7c3:	e8 9c 62 01 00       	call   f0120a64 <nearest_pow2_ceil>
f010a7c8:	83 c4 10             	add    $0x10,%esp
f010a7cb:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a7ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7d1:	21 c2                	and    %eax,%edx
f010a7d3:	89 d0                	mov    %edx,%eax
f010a7d5:	c1 e0 06             	shl    $0x6,%eax
f010a7d8:	29 d0                	sub    %edx,%eax
f010a7da:	c1 e0 02             	shl    $0x2,%eax
f010a7dd:	01 d0                	add    %edx,%eax
f010a7df:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010a7e6:	01 c8                	add    %ecx,%eax
f010a7e8:	c1 e0 03             	shl    $0x3,%eax
f010a7eb:	01 d0                	add    %edx,%eax
f010a7ed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a7f4:	29 c2                	sub    %eax,%edx
f010a7f6:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010a7fd:	89 c2                	mov    %eax,%edx
f010a7ff:	89 d0                	mov    %edx,%eax
f010a801:	01 d8                	add    %ebx,%eax
f010a803:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010a806:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a809:	8b 40 18             	mov    0x18(%eax),%eax
f010a80c:	85 c0                	test   %eax,%eax
f010a80e:	74 0b                	je     f010a81b <envid2env+0x86>
f010a810:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a813:	8b 40 10             	mov    0x10(%eax),%eax
f010a816:	3b 45 08             	cmp    0x8(%ebp),%eax
f010a819:	74 10                	je     f010a82b <envid2env+0x96>
		*env_store = 0;
f010a81b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a81e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010a824:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010a829:	eb 43                	jmp    f010a86e <envid2env+0xd9>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010a82b:	e8 15 ff ff ff       	call   f010a745 <get_cpu_proc>
f010a830:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010a833:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010a837:	74 28                	je     f010a861 <envid2env+0xcc>
f010a839:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a83c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010a83f:	74 20                	je     f010a861 <envid2env+0xcc>
f010a841:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a844:	8b 50 14             	mov    0x14(%eax),%edx
f010a847:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a84a:	8b 40 10             	mov    0x10(%eax),%eax
f010a84d:	39 c2                	cmp    %eax,%edx
f010a84f:	74 10                	je     f010a861 <envid2env+0xcc>
		*env_store = 0;
f010a851:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a854:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010a85a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010a85f:	eb 0d                	jmp    f010a86e <envid2env+0xd9>
	}

	*env_store = e;
f010a861:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a864:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a867:	89 10                	mov    %edx,(%eax)
	return 0;
f010a869:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010a86e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a871:	c9                   	leave  
f010a872:	c3                   	ret    

f010a873 <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010a873:	55                   	push   %ebp
f010a874:	89 e5                	mov    %esp,%ebp
f010a876:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010a879:	83 ec 0c             	sub    $0xc,%esp
f010a87c:	68 00 1e 5a f0       	push   $0xf05a1e00
f010a881:	e8 6f 42 00 00       	call   f010eaf5 <acquire_spinlock>
f010a886:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010a889:	e8 b7 fe ff ff       	call   f010a745 <get_cpu_proc>
f010a88e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010a891:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a895:	75 19                	jne    f010a8b0 <yield+0x3d>
f010a897:	68 ee 85 12 f0       	push   $0xf01285ee
f010a89c:	68 d9 85 12 f0       	push   $0xf01285d9
f010a8a1:	68 49 02 00 00       	push   $0x249
f010a8a6:	68 03 85 12 f0       	push   $0xf0128503
f010a8ab:	e8 6a 5a ff ff       	call   f010031a <_panic>
		p->env_status = ENV_READY;
f010a8b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8b3:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010a8ba:	e8 13 00 00 00       	call   f010a8d2 <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010a8bf:	83 ec 0c             	sub    $0xc,%esp
f010a8c2:	68 00 1e 5a f0       	push   $0xf05a1e00
f010a8c7:	e8 b0 42 00 00       	call   f010eb7c <release_spinlock>
f010a8cc:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010a8cf:	90                   	nop
f010a8d0:	c9                   	leave  
f010a8d1:	c3                   	ret    

f010a8d2 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010a8d2:	55                   	push   %ebp
f010a8d3:	89 e5                	mov    %esp,%ebp
f010a8d5:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010a8d8:	e8 68 fe ff ff       	call   f010a745 <get_cpu_proc>
f010a8dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010a8e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a8e4:	75 19                	jne    f010a8ff <sched+0x2d>
f010a8e6:	68 ee 85 12 f0       	push   $0xf01285ee
f010a8eb:	68 d9 85 12 f0       	push   $0xf01285d9
f010a8f0:	68 5d 02 00 00       	push   $0x25d
f010a8f5:	68 03 85 12 f0       	push   $0xf0128503
f010a8fa:	e8 1b 5a ff ff       	call   f010031a <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010a8ff:	83 ec 0c             	sub    $0xc,%esp
f010a902:	68 00 1e 5a f0       	push   $0xf05a1e00
f010a907:	e8 02 44 00 00       	call   f010ed0e <holding_spinlock>
f010a90c:	83 c4 10             	add    $0x10,%esp
f010a90f:	85 c0                	test   %eax,%eax
f010a911:	75 17                	jne    f010a92a <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010a913:	83 ec 04             	sub    $0x4,%esp
f010a916:	68 f8 85 12 f0       	push   $0xf01285f8
f010a91b:	68 61 02 00 00       	push   $0x261
f010a920:	68 03 85 12 f0       	push   $0xf0128503
f010a925:	e8 f0 59 ff ff       	call   f010031a <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010a92a:	e8 a3 c7 ff ff       	call   f01070d2 <mycpu>
f010a92f:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010a935:	83 f8 01             	cmp    $0x1,%eax
f010a938:	74 20                	je     f010a95a <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010a93a:	e8 93 c7 ff ff       	call   f01070d2 <mycpu>
f010a93f:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010a945:	50                   	push   %eax
f010a946:	68 3a 86 12 f0       	push   $0xf012863a
f010a94b:	68 64 02 00 00       	push   $0x264
f010a950:	68 03 85 12 f0       	push   $0xf0128503
f010a955:	e8 c0 59 ff ff       	call   f010031a <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010a95a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a95d:	8b 40 18             	mov    0x18(%eax),%eax
f010a960:	83 f8 02             	cmp    $0x2,%eax
f010a963:	75 17                	jne    f010a97c <sched+0xaa>
		panic("sched a running process");
f010a965:	83 ec 04             	sub    $0x4,%esp
f010a968:	68 51 86 12 f0       	push   $0xf0128651
f010a96d:	68 67 02 00 00       	push   $0x267
f010a972:	68 03 85 12 f0       	push   $0xf0128503
f010a977:	e8 9e 59 ff ff       	call   f010031a <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010a97c:	9c                   	pushf  
f010a97d:	58                   	pop    %eax
f010a97e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010a981:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010a984:	25 00 02 00 00       	and    $0x200,%eax
f010a989:	85 c0                	test   %eax,%eax
f010a98b:	74 17                	je     f010a9a4 <sched+0xd2>
		panic("sched is interruptible!");
f010a98d:	83 ec 04             	sub    $0x4,%esp
f010a990:	68 69 86 12 f0       	push   $0xf0128669
f010a995:	68 69 02 00 00       	push   $0x269
f010a99a:	68 03 85 12 f0       	push   $0xf0128503
f010a99f:	e8 76 59 ff ff       	call   f010031a <_panic>
	intena = mycpu()->intena;
f010a9a4:	e8 29 c7 ff ff       	call   f01070d2 <mycpu>
f010a9a9:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010a9af:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010a9b2:	e8 1b c7 ff ff       	call   f01070d2 <mycpu>
f010a9b7:	8b 40 04             	mov    0x4(%eax),%eax
f010a9ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a9bd:	83 c2 04             	add    $0x4,%edx
f010a9c0:	83 ec 08             	sub    $0x8,%esp
f010a9c3:	50                   	push   %eax
f010a9c4:	52                   	push   %edx
f010a9c5:	e8 4a a1 ff ff       	call   f0104b14 <context_switch>
f010a9ca:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010a9cd:	e8 00 c7 ff ff       	call   f01070d2 <mycpu>
f010a9d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a9d5:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010a9db:	90                   	nop
f010a9dc:	c9                   	leave  
f010a9dd:	c3                   	ret    

f010a9de <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010a9de:	55                   	push   %ebp
f010a9df:	89 e5                	mov    %esp,%ebp
f010a9e1:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010a9e4:	a1 84 4b 5a f0       	mov    0xf05a4b84,%eax
f010a9e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010a9ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010a9ef:	0f 22 d8             	mov    %eax,%cr3
}
f010a9f2:	90                   	nop
f010a9f3:	c9                   	leave  
f010a9f4:	c3                   	ret    

f010a9f5 <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010a9f5:	55                   	push   %ebp
f010a9f6:	89 e5                	mov    %esp,%ebp
f010a9f8:	53                   	push   %ebx
f010a9f9:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010a9fc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010aa00:	75 17                	jne    f010aa19 <switchuvm+0x24>
		panic("switchuvm: no process");
f010aa02:	83 ec 04             	sub    $0x4,%esp
f010aa05:	68 81 86 12 f0       	push   $0xf0128681
f010aa0a:	68 7e 02 00 00       	push   $0x27e
f010aa0f:	68 03 85 12 f0       	push   $0xf0128503
f010aa14:	e8 01 59 ff ff       	call   f010031a <_panic>
	if(proc->kstack == 0)
f010aa19:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa1c:	8b 40 70             	mov    0x70(%eax),%eax
f010aa1f:	85 c0                	test   %eax,%eax
f010aa21:	75 17                	jne    f010aa3a <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010aa23:	83 ec 04             	sub    $0x4,%esp
f010aa26:	68 97 86 12 f0       	push   $0xf0128697
f010aa2b:	68 80 02 00 00       	push   $0x280
f010aa30:	68 03 85 12 f0       	push   $0xf0128503
f010aa35:	e8 e0 58 ff ff       	call   f010031a <_panic>
	if(proc->env_page_directory == 0)
f010aa3a:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa3d:	8b 40 64             	mov    0x64(%eax),%eax
f010aa40:	85 c0                	test   %eax,%eax
f010aa42:	75 17                	jne    f010aa5b <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010aa44:	83 ec 04             	sub    $0x4,%esp
f010aa47:	68 ac 86 12 f0       	push   $0xf01286ac
f010aa4c:	68 82 02 00 00       	push   $0x282
f010aa51:	68 03 85 12 f0       	push   $0xf0128503
f010aa56:	e8 bf 58 ff ff       	call   f010031a <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010aa5b:	e8 35 c7 ff ff       	call   f0107195 <pushcli>
	struct cpu* c = mycpu();
f010aa60:	e8 6d c6 ff ff       	call   f01070d2 <mycpu>
f010aa65:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010aa68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aa6b:	8b 55 08             	mov    0x8(%ebp),%edx
f010aa6e:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010aa74:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aa77:	83 c0 0c             	add    $0xc,%eax
f010aa7a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aa7d:	83 c2 0c             	add    $0xc,%edx
f010aa80:	c1 ea 10             	shr    $0x10,%edx
f010aa83:	88 d3                	mov    %dl,%bl
f010aa85:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aa88:	83 c2 0c             	add    $0xc,%edx
f010aa8b:	c1 ea 18             	shr    $0x18,%edx
f010aa8e:	88 d1                	mov    %dl,%cl
f010aa90:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aa93:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010aa9a:	68 00 
f010aa9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aa9f:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010aaa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aaa9:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010aaaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aab2:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010aab8:	83 e2 f0             	and    $0xfffffff0,%edx
f010aabb:	83 ca 09             	or     $0x9,%edx
f010aabe:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010aac4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aac7:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010aacd:	83 ca 10             	or     $0x10,%edx
f010aad0:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010aad6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aad9:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010aadf:	83 e2 9f             	and    $0xffffff9f,%edx
f010aae2:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010aae8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aaeb:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010aaf1:	83 ca 80             	or     $0xffffff80,%edx
f010aaf4:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010aafa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aafd:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ab03:	83 e2 f0             	and    $0xfffffff0,%edx
f010ab06:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ab0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab0f:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ab15:	83 e2 ef             	and    $0xffffffef,%edx
f010ab18:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ab1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab21:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ab27:	83 e2 df             	and    $0xffffffdf,%edx
f010ab2a:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ab30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab33:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ab39:	83 ca 40             	or     $0x40,%edx
f010ab3c:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ab42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab45:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ab4b:	83 e2 7f             	and    $0x7f,%edx
f010ab4e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ab54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab57:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010ab5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab60:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ab66:	83 e2 ef             	and    $0xffffffef,%edx
f010ab69:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010ab6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab72:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010ab78:	8b 40 70             	mov    0x70(%eax),%eax
f010ab7b:	05 00 80 00 00       	add    $0x8000,%eax
f010ab80:	89 c2                	mov    %eax,%edx
f010ab82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab85:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010ab88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab8b:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010ab91:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010ab97:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010ab9b:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010ab9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aba1:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010aba7:	8b 40 68             	mov    0x68(%eax),%eax
f010abaa:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010abad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010abb0:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010abb3:	e8 2f c6 ff ff       	call   f01071e7 <popcli>
}
f010abb8:	90                   	nop
f010abb9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010abbc:	c9                   	leave  
f010abbd:	c3                   	ret    

f010abbe <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010abbe:	55                   	push   %ebp
f010abbf:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010abc1:	8b 15 b4 13 5a f0    	mov    0xf05a13b4,%edx
f010abc7:	8b 45 08             	mov    0x8(%ebp),%eax
f010abca:	89 10                	mov    %edx,(%eax)
f010abcc:	8b 45 08             	mov    0x8(%ebp),%eax
f010abcf:	8b 00                	mov    (%eax),%eax
f010abd1:	85 c0                	test   %eax,%eax
f010abd3:	75 07                	jne    f010abdc <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010abd5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010abda:	eb 11                	jmp    f010abed <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010abdc:	8b 45 08             	mov    0x8(%ebp),%eax
f010abdf:	8b 00                	mov    (%eax),%eax
f010abe1:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010abe8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010abed:	5d                   	pop    %ebp
f010abee:	c3                   	ret    

f010abef <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010abef:	55                   	push   %ebp
f010abf0:	89 e5                	mov    %esp,%ebp
f010abf2:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010abf5:	83 ec 04             	sub    $0x4,%esp
f010abf8:	68 6c da 01 00       	push   $0x1da6c
f010abfd:	6a 00                	push   $0x0
f010abff:	ff 75 08             	pushl  0x8(%ebp)
f010ac02:	e8 f3 79 01 00       	call   f01225fa <memset>
f010ac07:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010ac0a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac0d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010ac14:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ac18:	75 17                	jne    f010ac31 <free_environment+0x42>
f010ac1a:	83 ec 04             	sub    $0x4,%esp
f010ac1d:	68 e0 84 12 f0       	push   $0xf01284e0
f010ac22:	68 bd 02 00 00       	push   $0x2bd
f010ac27:	68 03 85 12 f0       	push   $0xf0128503
f010ac2c:	e8 e9 56 ff ff       	call   f010031a <_panic>
f010ac31:	8b 15 b4 13 5a f0    	mov    0xf05a13b4,%edx
f010ac37:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac3a:	89 50 08             	mov    %edx,0x8(%eax)
f010ac3d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac40:	8b 40 08             	mov    0x8(%eax),%eax
f010ac43:	85 c0                	test   %eax,%eax
f010ac45:	74 0d                	je     f010ac54 <free_environment+0x65>
f010ac47:	a1 b4 13 5a f0       	mov    0xf05a13b4,%eax
f010ac4c:	8b 55 08             	mov    0x8(%ebp),%edx
f010ac4f:	89 50 0c             	mov    %edx,0xc(%eax)
f010ac52:	eb 08                	jmp    f010ac5c <free_environment+0x6d>
f010ac54:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac57:	a3 b8 13 5a f0       	mov    %eax,0xf05a13b8
f010ac5c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac5f:	a3 b4 13 5a f0       	mov    %eax,0xf05a13b4
f010ac64:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac67:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010ac6e:	a1 c0 13 5a f0       	mov    0xf05a13c0,%eax
f010ac73:	40                   	inc    %eax
f010ac74:	a3 c0 13 5a f0       	mov    %eax,0xf05a13c0
}
f010ac79:	90                   	nop
f010ac7a:	c9                   	leave  
f010ac7b:	c3                   	ret    

f010ac7c <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010ac7c:	55                   	push   %ebp
f010ac7d:	89 e5                	mov    %esp,%ebp
f010ac7f:	53                   	push   %ebx
f010ac80:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010ac83:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ac86:	8b 40 0c             	mov    0xc(%eax),%eax
f010ac89:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010ac8c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ac8f:	8b 40 08             	mov    0x8(%eax),%eax
f010ac92:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010ac95:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010ac9c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010ac9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010aca2:	01 c2                	add    %eax,%edx
f010aca4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010aca7:	01 d0                	add    %edx,%eax
f010aca9:	48                   	dec    %eax
f010acaa:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010acad:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010acb0:	ba 00 00 00 00       	mov    $0x0,%edx
f010acb5:	f7 75 dc             	divl   -0x24(%ebp)
f010acb8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010acbb:	29 d0                	sub    %edx,%eax
f010acbd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010acc0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010acc3:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010acc6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010acc9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010acce:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010acd1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010acd8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)

	*allocated_pages = 0;
f010acdf:	8b 45 10             	mov    0x10(%ebp),%eax
f010ace2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010ace8:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010acef:	0f 85 35 06 00 00    	jne    f010b32a <program_segment_alloc_map_copy_workingset+0x6ae>
f010acf5:	8b 45 08             	mov    0x8(%ebp),%eax
f010acf8:	83 c0 20             	add    $0x20,%eax
f010acfb:	83 ec 08             	sub    $0x8,%esp
f010acfe:	68 c0 86 12 f0       	push   $0xf01286c0
f010ad03:	50                   	push   %eax
f010ad04:	e8 0f 78 01 00       	call   f0122518 <strcmp>
f010ad09:	83 c4 10             	add    $0x10,%esp
f010ad0c:	85 c0                	test   %eax,%eax
f010ad0e:	0f 84 16 06 00 00    	je     f010b32a <program_segment_alloc_map_copy_workingset+0x6ae>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010ad14:	8b 45 14             	mov    0x14(%ebp),%eax
f010ad17:	83 f8 06             	cmp    $0x6,%eax
f010ad1a:	76 05                	jbe    f010ad21 <program_segment_alloc_map_copy_workingset+0xa5>
f010ad1c:	b8 06 00 00 00       	mov    $0x6,%eax
f010ad21:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010ad24:	e9 01 06 00 00       	jmp    f010b32a <program_segment_alloc_map_copy_workingset+0x6ae>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010ad29:	83 ec 0c             	sub    $0xc,%esp
f010ad2c:	8d 45 c0             	lea    -0x40(%ebp),%eax
f010ad2f:	50                   	push   %eax
f010ad30:	e8 70 d4 ff ff       	call   f01081a5 <allocate_frame>
f010ad35:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010ad38:	8b 55 c0             	mov    -0x40(%ebp),%edx
f010ad3b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad3e:	8b 40 64             	mov    0x64(%eax),%eax
f010ad41:	6a 06                	push   $0x6
f010ad43:	ff 75 f4             	pushl  -0xc(%ebp)
f010ad46:	52                   	push   %edx
f010ad47:	50                   	push   %eax
f010ad48:	e8 6c da ff ff       	call   f01087b9 <loadtime_map_frame>
f010ad4d:	83 c4 10             	add    $0x10,%esp
		wse->time_stamp = 0;
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);

#else
		LOG_STATMENT(cprintf("Updating working set entry # %d",e->page_last_WS_index));
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
f010ad50:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad53:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ad59:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad5c:	89 d0                	mov    %edx,%eax
f010ad5e:	01 c0                	add    %eax,%eax
f010ad60:	01 d0                	add    %edx,%eax
f010ad62:	c1 e0 03             	shl    $0x3,%eax
f010ad65:	01 c8                	add    %ecx,%eax
f010ad67:	8d 90 88 00 00 00    	lea    0x88(%eax),%edx
f010ad6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad70:	89 02                	mov    %eax,(%edx)
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
f010ad72:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad75:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ad7b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad7e:	89 d0                	mov    %edx,%eax
f010ad80:	01 c0                	add    %eax,%eax
f010ad82:	01 d0                	add    %edx,%eax
f010ad84:	c1 e0 03             	shl    $0x3,%eax
f010ad87:	01 c8                	add    %ecx,%eax
f010ad89:	05 8c 00 00 00       	add    $0x8c,%eax
f010ad8e:	c6 00 00             	movb   $0x0,(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
f010ad91:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad94:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ad9a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad9d:	89 d0                	mov    %edx,%eax
f010ad9f:	01 c0                	add    %eax,%eax
f010ada1:	01 d0                	add    %edx,%eax
f010ada3:	c1 e0 03             	shl    $0x3,%eax
f010ada6:	01 c8                	add    %ecx,%eax
f010ada8:	05 90 00 00 00       	add    $0x90,%eax
f010adad:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010adb3:	83 ec 0c             	sub    $0xc,%esp
f010adb6:	6a 02                	push   $0x2
f010adb8:	e8 27 39 00 00       	call   f010e6e4 <isPageReplacmentAlgorithmLRU>
f010adbd:	83 c4 10             	add    $0x10,%esp
f010adc0:	85 c0                	test   %eax,%eax
f010adc2:	0f 84 2c 04 00 00    	je     f010b1f4 <program_segment_alloc_map_copy_workingset+0x578>
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
			}
#else

			LIST_REMOVE(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010adc8:	8b 45 08             	mov    0x8(%ebp),%eax
f010adcb:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010add1:	89 d0                	mov    %edx,%eax
f010add3:	01 c0                	add    %eax,%eax
f010add5:	01 d0                	add    %edx,%eax
f010add7:	c1 e0 03             	shl    $0x3,%eax
f010adda:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010ade0:	8b 45 08             	mov    0x8(%ebp),%eax
f010ade3:	01 d0                	add    %edx,%eax
f010ade5:	83 c0 08             	add    $0x8,%eax
f010ade8:	85 c0                	test   %eax,%eax
f010adea:	75 17                	jne    f010ae03 <program_segment_alloc_map_copy_workingset+0x187>
f010adec:	83 ec 04             	sub    $0x4,%esp
f010adef:	68 95 85 12 f0       	push   $0xf0128595
f010adf4:	68 00 03 00 00       	push   $0x300
f010adf9:	68 03 85 12 f0       	push   $0xf0128503
f010adfe:	e8 17 55 ff ff       	call   f010031a <_panic>
f010ae03:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae06:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ae0c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae0f:	89 d0                	mov    %edx,%eax
f010ae11:	01 c0                	add    %eax,%eax
f010ae13:	01 d0                	add    %edx,%eax
f010ae15:	c1 e0 03             	shl    $0x3,%eax
f010ae18:	01 c8                	add    %ecx,%eax
f010ae1a:	05 98 00 00 00       	add    $0x98,%eax
f010ae1f:	8b 00                	mov    (%eax),%eax
f010ae21:	85 c0                	test   %eax,%eax
f010ae23:	74 41                	je     f010ae66 <program_segment_alloc_map_copy_workingset+0x1ea>
f010ae25:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae28:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ae2e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae31:	89 d0                	mov    %edx,%eax
f010ae33:	01 c0                	add    %eax,%eax
f010ae35:	01 d0                	add    %edx,%eax
f010ae37:	c1 e0 03             	shl    $0x3,%eax
f010ae3a:	01 c8                	add    %ecx,%eax
f010ae3c:	05 98 00 00 00       	add    $0x98,%eax
f010ae41:	8b 10                	mov    (%eax),%edx
f010ae43:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae46:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010ae4c:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ae4f:	89 c8                	mov    %ecx,%eax
f010ae51:	01 c0                	add    %eax,%eax
f010ae53:	01 c8                	add    %ecx,%eax
f010ae55:	c1 e0 03             	shl    $0x3,%eax
f010ae58:	01 d8                	add    %ebx,%eax
f010ae5a:	05 9c 00 00 00       	add    $0x9c,%eax
f010ae5f:	8b 00                	mov    (%eax),%eax
f010ae61:	89 42 14             	mov    %eax,0x14(%edx)
f010ae64:	eb 27                	jmp    f010ae8d <program_segment_alloc_map_copy_workingset+0x211>
f010ae66:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae69:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ae6f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae72:	89 d0                	mov    %edx,%eax
f010ae74:	01 c0                	add    %eax,%eax
f010ae76:	01 d0                	add    %edx,%eax
f010ae78:	c1 e0 03             	shl    $0x3,%eax
f010ae7b:	01 c8                	add    %ecx,%eax
f010ae7d:	05 9c 00 00 00       	add    $0x9c,%eax
f010ae82:	8b 10                	mov    (%eax),%edx
f010ae84:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae87:	89 90 4c d5 01 00    	mov    %edx,0x1d54c(%eax)
f010ae8d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae90:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ae96:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae99:	89 d0                	mov    %edx,%eax
f010ae9b:	01 c0                	add    %eax,%eax
f010ae9d:	01 d0                	add    %edx,%eax
f010ae9f:	c1 e0 03             	shl    $0x3,%eax
f010aea2:	01 c8                	add    %ecx,%eax
f010aea4:	05 9c 00 00 00       	add    $0x9c,%eax
f010aea9:	8b 00                	mov    (%eax),%eax
f010aeab:	85 c0                	test   %eax,%eax
f010aead:	74 41                	je     f010aef0 <program_segment_alloc_map_copy_workingset+0x274>
f010aeaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010aeb2:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aeb8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aebb:	89 d0                	mov    %edx,%eax
f010aebd:	01 c0                	add    %eax,%eax
f010aebf:	01 d0                	add    %edx,%eax
f010aec1:	c1 e0 03             	shl    $0x3,%eax
f010aec4:	01 c8                	add    %ecx,%eax
f010aec6:	05 9c 00 00 00       	add    $0x9c,%eax
f010aecb:	8b 10                	mov    (%eax),%edx
f010aecd:	8b 45 08             	mov    0x8(%ebp),%eax
f010aed0:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010aed6:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010aed9:	89 c8                	mov    %ecx,%eax
f010aedb:	01 c0                	add    %eax,%eax
f010aedd:	01 c8                	add    %ecx,%eax
f010aedf:	c1 e0 03             	shl    $0x3,%eax
f010aee2:	01 d8                	add    %ebx,%eax
f010aee4:	05 98 00 00 00       	add    $0x98,%eax
f010aee9:	8b 00                	mov    (%eax),%eax
f010aeeb:	89 42 10             	mov    %eax,0x10(%edx)
f010aeee:	eb 27                	jmp    f010af17 <program_segment_alloc_map_copy_workingset+0x29b>
f010aef0:	8b 45 08             	mov    0x8(%ebp),%eax
f010aef3:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aef9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aefc:	89 d0                	mov    %edx,%eax
f010aefe:	01 c0                	add    %eax,%eax
f010af00:	01 d0                	add    %edx,%eax
f010af02:	c1 e0 03             	shl    $0x3,%eax
f010af05:	01 c8                	add    %ecx,%eax
f010af07:	05 98 00 00 00       	add    $0x98,%eax
f010af0c:	8b 10                	mov    (%eax),%edx
f010af0e:	8b 45 08             	mov    0x8(%ebp),%eax
f010af11:	89 90 48 d5 01 00    	mov    %edx,0x1d548(%eax)
f010af17:	8b 45 08             	mov    0x8(%ebp),%eax
f010af1a:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010af20:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010af23:	89 d0                	mov    %edx,%eax
f010af25:	01 c0                	add    %eax,%eax
f010af27:	01 d0                	add    %edx,%eax
f010af29:	c1 e0 03             	shl    $0x3,%eax
f010af2c:	01 c8                	add    %ecx,%eax
f010af2e:	05 98 00 00 00       	add    $0x98,%eax
f010af33:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010af39:	8b 45 08             	mov    0x8(%ebp),%eax
f010af3c:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010af42:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010af45:	89 d0                	mov    %edx,%eax
f010af47:	01 c0                	add    %eax,%eax
f010af49:	01 d0                	add    %edx,%eax
f010af4b:	c1 e0 03             	shl    $0x3,%eax
f010af4e:	01 c8                	add    %ecx,%eax
f010af50:	05 9c 00 00 00       	add    $0x9c,%eax
f010af55:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010af5b:	8b 45 08             	mov    0x8(%ebp),%eax
f010af5e:	8b 80 54 d5 01 00    	mov    0x1d554(%eax),%eax
f010af64:	8d 50 ff             	lea    -0x1(%eax),%edx
f010af67:	8b 45 08             	mov    0x8(%ebp),%eax
f010af6a:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010af70:	8b 45 08             	mov    0x8(%ebp),%eax
f010af73:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010af79:	8b 45 08             	mov    0x8(%ebp),%eax
f010af7c:	8b 80 30 da 01 00    	mov    0x1da30(%eax),%eax
f010af82:	48                   	dec    %eax
f010af83:	39 c2                	cmp    %eax,%edx
f010af85:	0f 83 37 01 00 00    	jae    f010b0c2 <program_segment_alloc_map_copy_workingset+0x446>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010af8b:	8b 45 08             	mov    0x8(%ebp),%eax
f010af8e:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010af94:	89 d0                	mov    %edx,%eax
f010af96:	01 c0                	add    %eax,%eax
f010af98:	01 d0                	add    %edx,%eax
f010af9a:	c1 e0 03             	shl    $0x3,%eax
f010af9d:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010afa3:	8b 45 08             	mov    0x8(%ebp),%eax
f010afa6:	01 d0                	add    %edx,%eax
f010afa8:	83 c0 08             	add    $0x8,%eax
f010afab:	85 c0                	test   %eax,%eax
f010afad:	75 17                	jne    f010afc6 <program_segment_alloc_map_copy_workingset+0x34a>
f010afaf:	83 ec 04             	sub    $0x4,%esp
f010afb2:	68 e0 84 12 f0       	push   $0xf01284e0
f010afb7:	68 04 03 00 00       	push   $0x304
f010afbc:	68 03 85 12 f0       	push   $0xf0128503
f010afc1:	e8 54 53 ff ff       	call   f010031a <_panic>
f010afc6:	8b 45 08             	mov    0x8(%ebp),%eax
f010afc9:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010afcf:	8b 45 08             	mov    0x8(%ebp),%eax
f010afd2:	8b 88 10 da 01 00    	mov    0x1da10(%eax),%ecx
f010afd8:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010afdb:	89 d0                	mov    %edx,%eax
f010afdd:	01 c0                	add    %eax,%eax
f010afdf:	01 d0                	add    %edx,%eax
f010afe1:	c1 e0 03             	shl    $0x3,%eax
f010afe4:	01 d8                	add    %ebx,%eax
f010afe6:	05 98 00 00 00       	add    $0x98,%eax
f010afeb:	89 08                	mov    %ecx,(%eax)
f010afed:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aff0:	89 d0                	mov    %edx,%eax
f010aff2:	01 c0                	add    %eax,%eax
f010aff4:	01 d0                	add    %edx,%eax
f010aff6:	c1 e0 03             	shl    $0x3,%eax
f010aff9:	01 c8                	add    %ecx,%eax
f010affb:	05 98 00 00 00       	add    $0x98,%eax
f010b000:	8b 00                	mov    (%eax),%eax
f010b002:	85 c0                	test   %eax,%eax
f010b004:	74 2e                	je     f010b034 <program_segment_alloc_map_copy_workingset+0x3b8>
f010b006:	8b 45 08             	mov    0x8(%ebp),%eax
f010b009:	8b 90 10 da 01 00    	mov    0x1da10(%eax),%edx
f010b00f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b012:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010b018:	89 c8                	mov    %ecx,%eax
f010b01a:	01 c0                	add    %eax,%eax
f010b01c:	01 c8                	add    %ecx,%eax
f010b01e:	c1 e0 03             	shl    $0x3,%eax
f010b021:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010b027:	8b 45 08             	mov    0x8(%ebp),%eax
f010b02a:	01 c8                	add    %ecx,%eax
f010b02c:	83 c0 08             	add    $0x8,%eax
f010b02f:	89 42 14             	mov    %eax,0x14(%edx)
f010b032:	eb 29                	jmp    f010b05d <program_segment_alloc_map_copy_workingset+0x3e1>
f010b034:	8b 45 08             	mov    0x8(%ebp),%eax
f010b037:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b03d:	89 d0                	mov    %edx,%eax
f010b03f:	01 c0                	add    %eax,%eax
f010b041:	01 d0                	add    %edx,%eax
f010b043:	c1 e0 03             	shl    $0x3,%eax
f010b046:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b04c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b04f:	01 d0                	add    %edx,%eax
f010b051:	8d 50 08             	lea    0x8(%eax),%edx
f010b054:	8b 45 08             	mov    0x8(%ebp),%eax
f010b057:	89 90 14 da 01 00    	mov    %edx,0x1da14(%eax)
f010b05d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b060:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b066:	89 d0                	mov    %edx,%eax
f010b068:	01 c0                	add    %eax,%eax
f010b06a:	01 d0                	add    %edx,%eax
f010b06c:	c1 e0 03             	shl    $0x3,%eax
f010b06f:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b075:	8b 45 08             	mov    0x8(%ebp),%eax
f010b078:	01 d0                	add    %edx,%eax
f010b07a:	8d 50 08             	lea    0x8(%eax),%edx
f010b07d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b080:	89 90 10 da 01 00    	mov    %edx,0x1da10(%eax)
f010b086:	8b 45 08             	mov    0x8(%ebp),%eax
f010b089:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b08f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b092:	89 d0                	mov    %edx,%eax
f010b094:	01 c0                	add    %eax,%eax
f010b096:	01 d0                	add    %edx,%eax
f010b098:	c1 e0 03             	shl    $0x3,%eax
f010b09b:	01 c8                	add    %ecx,%eax
f010b09d:	05 9c 00 00 00       	add    $0x9c,%eax
f010b0a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010b0a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0ab:	8b 80 1c da 01 00    	mov    0x1da1c(%eax),%eax
f010b0b1:	8d 50 01             	lea    0x1(%eax),%edx
f010b0b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0b7:	89 90 1c da 01 00    	mov    %edx,0x1da1c(%eax)
f010b0bd:	e9 32 01 00 00       	jmp    f010b1f4 <program_segment_alloc_map_copy_workingset+0x578>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010b0c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0c5:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b0cb:	89 d0                	mov    %edx,%eax
f010b0cd:	01 c0                	add    %eax,%eax
f010b0cf:	01 d0                	add    %edx,%eax
f010b0d1:	c1 e0 03             	shl    $0x3,%eax
f010b0d4:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b0da:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0dd:	01 d0                	add    %edx,%eax
f010b0df:	83 c0 08             	add    $0x8,%eax
f010b0e2:	85 c0                	test   %eax,%eax
f010b0e4:	75 17                	jne    f010b0fd <program_segment_alloc_map_copy_workingset+0x481>
f010b0e6:	83 ec 04             	sub    $0x4,%esp
f010b0e9:	68 e0 84 12 f0       	push   $0xf01284e0
f010b0ee:	68 09 03 00 00       	push   $0x309
f010b0f3:	68 03 85 12 f0       	push   $0xf0128503
f010b0f8:	e8 1d 52 ff ff       	call   f010031a <_panic>
f010b0fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b100:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b106:	8b 45 08             	mov    0x8(%ebp),%eax
f010b109:	8b 88 20 da 01 00    	mov    0x1da20(%eax),%ecx
f010b10f:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b112:	89 d0                	mov    %edx,%eax
f010b114:	01 c0                	add    %eax,%eax
f010b116:	01 d0                	add    %edx,%eax
f010b118:	c1 e0 03             	shl    $0x3,%eax
f010b11b:	01 d8                	add    %ebx,%eax
f010b11d:	05 98 00 00 00       	add    $0x98,%eax
f010b122:	89 08                	mov    %ecx,(%eax)
f010b124:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b127:	89 d0                	mov    %edx,%eax
f010b129:	01 c0                	add    %eax,%eax
f010b12b:	01 d0                	add    %edx,%eax
f010b12d:	c1 e0 03             	shl    $0x3,%eax
f010b130:	01 c8                	add    %ecx,%eax
f010b132:	05 98 00 00 00       	add    $0x98,%eax
f010b137:	8b 00                	mov    (%eax),%eax
f010b139:	85 c0                	test   %eax,%eax
f010b13b:	74 2e                	je     f010b16b <program_segment_alloc_map_copy_workingset+0x4ef>
f010b13d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b140:	8b 90 20 da 01 00    	mov    0x1da20(%eax),%edx
f010b146:	8b 45 08             	mov    0x8(%ebp),%eax
f010b149:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010b14f:	89 c8                	mov    %ecx,%eax
f010b151:	01 c0                	add    %eax,%eax
f010b153:	01 c8                	add    %ecx,%eax
f010b155:	c1 e0 03             	shl    $0x3,%eax
f010b158:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010b15e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b161:	01 c8                	add    %ecx,%eax
f010b163:	83 c0 08             	add    $0x8,%eax
f010b166:	89 42 14             	mov    %eax,0x14(%edx)
f010b169:	eb 29                	jmp    f010b194 <program_segment_alloc_map_copy_workingset+0x518>
f010b16b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b16e:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b174:	89 d0                	mov    %edx,%eax
f010b176:	01 c0                	add    %eax,%eax
f010b178:	01 d0                	add    %edx,%eax
f010b17a:	c1 e0 03             	shl    $0x3,%eax
f010b17d:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b183:	8b 45 08             	mov    0x8(%ebp),%eax
f010b186:	01 d0                	add    %edx,%eax
f010b188:	8d 50 08             	lea    0x8(%eax),%edx
f010b18b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b18e:	89 90 24 da 01 00    	mov    %edx,0x1da24(%eax)
f010b194:	8b 45 08             	mov    0x8(%ebp),%eax
f010b197:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b19d:	89 d0                	mov    %edx,%eax
f010b19f:	01 c0                	add    %eax,%eax
f010b1a1:	01 d0                	add    %edx,%eax
f010b1a3:	c1 e0 03             	shl    $0x3,%eax
f010b1a6:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b1ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1af:	01 d0                	add    %edx,%eax
f010b1b1:	8d 50 08             	lea    0x8(%eax),%edx
f010b1b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1b7:	89 90 20 da 01 00    	mov    %edx,0x1da20(%eax)
f010b1bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1c0:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010b1c6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b1c9:	89 d0                	mov    %edx,%eax
f010b1cb:	01 c0                	add    %eax,%eax
f010b1cd:	01 d0                	add    %edx,%eax
f010b1cf:	c1 e0 03             	shl    $0x3,%eax
f010b1d2:	01 c8                	add    %ecx,%eax
f010b1d4:	05 9c 00 00 00       	add    $0x9c,%eax
f010b1d9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010b1df:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1e2:	8b 80 2c da 01 00    	mov    0x1da2c(%eax),%eax
f010b1e8:	8d 50 01             	lea    0x1(%eax),%edx
f010b1eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1ee:	89 90 2c da 01 00    	mov    %edx,0x1da2c(%eax)
		else
		{
			e->page_last_WS_element = NULL;
		}
#else
		e->page_last_WS_index ++;
f010b1f4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1f7:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f010b1fd:	8d 50 01             	lea    0x1(%eax),%edx
f010b200:	8b 45 08             	mov    0x8(%ebp),%eax
f010b203:	89 90 58 d5 01 00    	mov    %edx,0x1d558(%eax)
		e->page_last_WS_index %= (e->page_WS_max_size);
f010b209:	8b 45 08             	mov    0x8(%ebp),%eax
f010b20c:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f010b212:	8b 55 08             	mov    0x8(%ebp),%edx
f010b215:	8b 8a 84 00 00 00    	mov    0x84(%edx),%ecx
f010b21b:	ba 00 00 00 00       	mov    $0x0,%edx
f010b220:	f7 f1                	div    %ecx
f010b222:	8b 45 08             	mov    0x8(%ebp),%eax
f010b225:	89 90 58 d5 01 00    	mov    %edx,0x1d558(%eax)
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010b22b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b22e:	c1 e8 16             	shr    $0x16,%eax
f010b231:	89 c2                	mov    %eax,%edx
f010b233:	8b 45 18             	mov    0x18(%ebp),%eax
f010b236:	8b 00                	mov    (%eax),%eax
f010b238:	39 c2                	cmp    %eax,%edx
f010b23a:	0f 84 d3 00 00 00    	je     f010b313 <program_segment_alloc_map_copy_workingset+0x697>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010b240:	8b 45 08             	mov    0x8(%ebp),%eax
f010b243:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010b249:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b24c:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b24f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b252:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010b257:	89 c1                	mov    %eax,%ecx
f010b259:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b25c:	89 d0                	mov    %edx,%eax
f010b25e:	01 c0                	add    %eax,%eax
f010b260:	01 d0                	add    %edx,%eax
f010b262:	c1 e0 03             	shl    $0x3,%eax
f010b265:	01 d8                	add    %ebx,%eax
f010b267:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010b26c:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010b26e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b271:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010b277:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b27a:	89 d0                	mov    %edx,%eax
f010b27c:	01 c0                	add    %eax,%eax
f010b27e:	01 d0                	add    %edx,%eax
f010b280:	c1 e0 03             	shl    $0x3,%eax
f010b283:	01 c8                	add    %ecx,%eax
f010b285:	05 60 d5 01 00       	add    $0x1d560,%eax
f010b28a:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010b28d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b290:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010b296:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b299:	89 d0                	mov    %edx,%eax
f010b29b:	01 c0                	add    %eax,%eax
f010b29d:	01 d0                	add    %edx,%eax
f010b29f:	c1 e0 03             	shl    $0x3,%eax
f010b2a2:	01 c8                	add    %ecx,%eax
f010b2a4:	05 64 d5 01 00       	add    $0x1d564,%eax
f010b2a9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010b2af:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2b2:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010b2b8:	8d 50 01             	lea    0x1(%eax),%edx
f010b2bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2be:	89 90 0c da 01 00    	mov    %edx,0x1da0c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010b2c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2c7:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010b2cd:	b9 32 00 00 00       	mov    $0x32,%ecx
f010b2d2:	ba 00 00 00 00       	mov    $0x0,%edx
f010b2d7:	f7 f1                	div    %ecx
f010b2d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2dc:	89 90 0c da 01 00    	mov    %edx,0x1da0c(%eax)
			if (e->table_last_WS_index == 0)
f010b2e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2e5:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010b2eb:	85 c0                	test   %eax,%eax
f010b2ed:	75 17                	jne    f010b306 <program_segment_alloc_map_copy_workingset+0x68a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010b2ef:	83 ec 04             	sub    $0x4,%esp
f010b2f2:	68 c4 86 12 f0       	push   $0xf01286c4
f010b2f7:	68 24 03 00 00       	push   $0x324
f010b2fc:	68 03 85 12 f0       	push   $0xf0128503
f010b301:	e8 14 50 ff ff       	call   f010031a <_panic>
			(*lastTableNumber) = PDX(iVA);
f010b306:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b309:	c1 e8 16             	shr    $0x16,%eax
f010b30c:	89 c2                	mov    %eax,%edx
f010b30e:	8b 45 18             	mov    0x18(%ebp),%eax
f010b311:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010b313:	8b 45 10             	mov    0x10(%ebp),%eax
f010b316:	8b 00                	mov    (%eax),%eax
f010b318:	8d 50 01             	lea    0x1(%eax),%edx
f010b31b:	8b 45 10             	mov    0x10(%ebp),%eax
f010b31e:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b320:	ff 45 f0             	incl   -0x10(%ebp)
f010b323:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010b32a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b32d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010b330:	73 0c                	jae    f010b33e <program_segment_alloc_map_copy_workingset+0x6c2>
f010b332:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b335:	3b 45 14             	cmp    0x14(%ebp),%eax
f010b338:	0f 82 eb f9 ff ff    	jb     f010ad29 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010b33e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b341:	8b 00                	mov    (%eax),%eax
f010b343:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010b346:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b349:	8b 40 0c             	mov    0xc(%eax),%eax
f010b34c:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b34f:	eb 10                	jmp    f010b361 <program_segment_alloc_map_copy_workingset+0x6e5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010b351:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b354:	8a 10                	mov    (%eax),%dl
f010b356:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b359:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010b35b:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010b35e:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b361:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b364:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010b367:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010b36a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b36f:	89 c2                	mov    %eax,%edx
f010b371:	8b 45 10             	mov    0x10(%ebp),%eax
f010b374:	8b 00                	mov    (%eax),%eax
f010b376:	c1 e0 0c             	shl    $0xc,%eax
f010b379:	01 c2                	add    %eax,%edx
f010b37b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b37e:	39 c2                	cmp    %eax,%edx
f010b380:	76 1d                	jbe    f010b39f <program_segment_alloc_map_copy_workingset+0x723>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010b382:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b385:	8b 50 04             	mov    0x4(%eax),%edx
f010b388:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b38b:	01 c2                	add    %eax,%edx
f010b38d:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b390:	39 c2                	cmp    %eax,%edx
f010b392:	77 bd                	ja     f010b351 <program_segment_alloc_map_copy_workingset+0x6d5>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b394:	eb 09                	jmp    f010b39f <program_segment_alloc_map_copy_workingset+0x723>
	{
		*dst_ptr = 0;
f010b396:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b399:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010b39c:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b39f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b3a2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b3a5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b3a8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b3ad:	89 c2                	mov    %eax,%edx
f010b3af:	8b 45 10             	mov    0x10(%ebp),%eax
f010b3b2:	8b 00                	mov    (%eax),%eax
f010b3b4:	c1 e0 0c             	shl    $0xc,%eax
f010b3b7:	01 c2                	add    %eax,%edx
f010b3b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b3bc:	39 c2                	cmp    %eax,%edx
f010b3be:	77 d6                	ja     f010b396 <program_segment_alloc_map_copy_workingset+0x71a>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010b3c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b3c5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b3c8:	c9                   	leave  
f010b3c9:	c3                   	ret    

f010b3ca <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010b3ca:	55                   	push   %ebp
f010b3cb:	89 e5                	mov    %esp,%ebp
f010b3cd:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010b3d0:	83 ec 0c             	sub    $0xc,%esp
f010b3d3:	68 00 10 00 00       	push   $0x1000
f010b3d8:	e8 ae d6 ff ff       	call   f0108a8b <kmalloc>
f010b3dd:	83 c4 10             	add    $0x10,%esp
f010b3e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010b3e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b3e7:	75 17                	jne    f010b400 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010b3e9:	83 ec 04             	sub    $0x4,%esp
f010b3ec:	68 67 87 12 f0       	push   $0xf0128767
f010b3f1:	68 54 03 00 00       	push   $0x354
f010b3f6:	68 03 85 12 f0       	push   $0xf0128503
f010b3fb:	e8 1a 4f ff ff       	call   f010031a <_panic>
	}
	return ptr_user_page_directory;
f010b400:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010b403:	c9                   	leave  
f010b404:	c3                   	ret    

f010b405 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010b405:	55                   	push   %ebp
f010b406:	89 e5                	mov    %esp,%ebp
f010b408:	83 ec 18             	sub    $0x18,%esp
	//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
	//return a pointer to the start of the allocated space (including the GUARD PAGE)


#else
	if (KERNEL_HEAP_MAX - __cur_k_stk < KERNEL_STACK_SIZE)
f010b40b:	a1 5c 09 18 f0       	mov    0xf018095c,%eax
f010b410:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
f010b415:	29 c2                	sub    %eax,%edx
f010b417:	89 d0                	mov    %edx,%eax
f010b419:	3d ff 7f 00 00       	cmp    $0x7fff,%eax
f010b41e:	77 17                	ja     f010b437 <create_user_kern_stack+0x32>
		panic("Run out of kernel heap!! Unable to create a kernel stack for the process. Can't create more processes!");
f010b420:	83 ec 04             	sub    $0x4,%esp
f010b423:	68 84 87 12 f0       	push   $0xf0128784
f010b428:	68 6d 03 00 00       	push   $0x36d
f010b42d:	68 03 85 12 f0       	push   $0xf0128503
f010b432:	e8 e3 4e ff ff       	call   f010031a <_panic>
	void* kstack = (void*) __cur_k_stk;
f010b437:	a1 5c 09 18 f0       	mov    0xf018095c,%eax
f010b43c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	__cur_k_stk += KERNEL_STACK_SIZE;
f010b43f:	a1 5c 09 18 f0       	mov    0xf018095c,%eax
f010b444:	05 00 80 00 00       	add    $0x8000,%eax
f010b449:	a3 5c 09 18 f0       	mov    %eax,0xf018095c
	return kstack ;
f010b44e:	8b 45 f4             	mov    -0xc(%ebp),%eax
//	panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010b451:	c9                   	leave  
f010b452:	c3                   	ret    

f010b453 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010b453:	55                   	push   %ebp
f010b454:	89 e5                	mov    %esp,%ebp
f010b456:	83 ec 08             	sub    $0x8,%esp
	panic("delete_user_kern_stack() is not implemented yet...!!");

	//Delete the allocated space for the user kernel stack of this process "e"
	//remember to delete the bottom GUARD PAGE (i.e. not mapped)
#else
	panic("KERNEL HEAP is OFF! user kernel stack can't be deleted");
f010b459:	83 ec 04             	sub    $0x4,%esp
f010b45c:	68 ec 87 12 f0       	push   $0xf01287ec
f010b461:	68 83 03 00 00       	push   $0x383
f010b466:	68 03 85 12 f0       	push   $0xf0128503
f010b46b:	e8 aa 4e ff ff       	call   f010031a <_panic>

f010b470 <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010b470:	55                   	push   %ebp
f010b471:	89 e5                	mov    %esp,%ebp
	//[PROJECT'24.MS2] Initialize the dynamic allocator of the user heap
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
}
f010b473:	90                   	nop
f010b474:	5d                   	pop    %ebp
f010b475:	c3                   	ret    

f010b476 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010b476:	55                   	push   %ebp
f010b477:	89 e5                	mov    %esp,%ebp
f010b479:	53                   	push   %ebx
f010b47a:	83 ec 14             	sub    $0x14,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010b47d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b480:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b483:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010b486:	8b 45 08             	mov    0x8(%ebp),%eax
f010b489:	8b 55 10             	mov    0x10(%ebp),%edx
f010b48c:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b48f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b496:	eb 17                	jmp    f010b4af <initialize_environment+0x39>
	{
		e->env_page_directory[i] = 0 ;
f010b498:	8b 45 08             	mov    0x8(%ebp),%eax
f010b49b:	8b 40 64             	mov    0x64(%eax),%eax
f010b49e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4a1:	c1 e2 02             	shl    $0x2,%edx
f010b4a4:	01 d0                	add    %edx,%eax
f010b4a6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b4ac:	ff 45 f4             	incl   -0xc(%ebp)
f010b4af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4b2:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010b4b7:	76 df                	jbe    f010b498 <initialize_environment+0x22>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b4b9:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010b4c0:	eb 22                	jmp    f010b4e4 <initialize_environment+0x6e>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010b4c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4c5:	8b 40 64             	mov    0x64(%eax),%eax
f010b4c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4cb:	c1 e2 02             	shl    $0x2,%edx
f010b4ce:	01 c2                	add    %eax,%edx
f010b4d0:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f010b4d5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010b4d8:	c1 e1 02             	shl    $0x2,%ecx
f010b4db:	01 c8                	add    %ecx,%eax
f010b4dd:	8b 00                	mov    (%eax),%eax
f010b4df:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b4e1:	ff 45 f4             	incl   -0xc(%ebp)
f010b4e4:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010b4eb:	7e d5                	jle    f010b4c2 <initialize_environment+0x4c>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010b4ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4f0:	8b 40 64             	mov    0x64(%eax),%eax
f010b4f3:	83 ec 0c             	sub    $0xc,%esp
f010b4f6:	50                   	push   %eax
f010b4f7:	e8 09 ff ff ff       	call   f010b405 <create_user_kern_stack>
f010b4fc:	83 c4 10             	add    $0x10,%esp
f010b4ff:	89 c2                	mov    %eax,%edx
f010b501:	8b 45 08             	mov    0x8(%ebp),%eax
f010b504:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010b507:	8b 45 08             	mov    0x8(%ebp),%eax
f010b50a:	8b 40 70             	mov    0x70(%eax),%eax
f010b50d:	05 00 80 00 00       	add    $0x8000,%eax
f010b512:	89 45 ec             	mov    %eax,-0x14(%ebp)
		sp -= sizeof(struct Trapframe);
f010b515:	83 6d ec 44          	subl   $0x44,-0x14(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010b519:	8b 45 08             	mov    0x8(%ebp),%eax
f010b51c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010b51f:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010b521:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010b525:	ba 58 d7 10 f0       	mov    $0xf010d758,%edx
f010b52a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b52d:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010b52f:	83 6d ec 20          	subl   $0x20,-0x14(%ebp)
		e->context = (struct Context *) sp;
f010b533:	8b 45 08             	mov    0x8(%ebp),%eax
f010b536:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010b539:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010b53c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b53f:	8b 40 04             	mov    0x4(%eax),%eax
f010b542:	83 ec 04             	sub    $0x4,%esp
f010b545:	6a 20                	push   $0x20
f010b547:	6a 00                	push   $0x0
f010b549:	50                   	push   %eax
f010b54a:	e8 ab 70 01 00       	call   f01225fa <memset>
f010b54f:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010b552:	8b 45 08             	mov    0x8(%ebp),%eax
f010b555:	8b 40 04             	mov    0x4(%eax),%eax
f010b558:	ba ab a6 10 f0       	mov    $0xf010a6ab,%edx
f010b55d:	89 50 1c             	mov    %edx,0x1c(%eax)
	{
		LIST_INIT(&(e->page_WS_list));
	}
#else
	{
		uint32 env_index = (uint32)(e-envs);
f010b560:	8b 45 08             	mov    0x8(%ebp),%eax
f010b563:	8b 15 b0 13 5a f0    	mov    0xf05a13b0,%edx
f010b569:	29 d0                	sub    %edx,%eax
f010b56b:	c1 f8 02             	sar    $0x2,%eax
f010b56e:	89 c2                	mov    %eax,%edx
f010b570:	89 d0                	mov    %edx,%eax
f010b572:	c1 e0 02             	shl    $0x2,%eax
f010b575:	01 d0                	add    %edx,%eax
f010b577:	c1 e0 02             	shl    $0x2,%eax
f010b57a:	01 d0                	add    %edx,%eax
f010b57c:	c1 e0 02             	shl    $0x2,%eax
f010b57f:	01 d0                	add    %edx,%eax
f010b581:	c1 e0 02             	shl    $0x2,%eax
f010b584:	01 d0                	add    %edx,%eax
f010b586:	c1 e0 08             	shl    $0x8,%eax
f010b589:	29 d0                	sub    %edx,%eax
f010b58b:	c1 e0 08             	shl    $0x8,%eax
f010b58e:	29 d0                	sub    %edx,%eax
f010b590:	c1 e0 03             	shl    $0x3,%eax
f010b593:	01 d0                	add    %edx,%eax
f010b595:	c1 e0 03             	shl    $0x3,%eax
f010b598:	01 d0                	add    %edx,%eax
f010b59a:	01 c0                	add    %eax,%eax
f010b59c:	01 d0                	add    %edx,%eax
f010b59e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		e->__uptr_pws = (struct WorkingSetElement*) ( ((struct Env*)(UENVS+sizeof(struct Env)*env_index))->ptr_pageWorkingSet );
f010b5a1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010b5a4:	89 d0                	mov    %edx,%eax
f010b5a6:	c1 e0 06             	shl    $0x6,%eax
f010b5a9:	29 d0                	sub    %edx,%eax
f010b5ab:	c1 e0 02             	shl    $0x2,%eax
f010b5ae:	01 d0                	add    %edx,%eax
f010b5b0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010b5b7:	01 c8                	add    %ecx,%eax
f010b5b9:	c1 e0 03             	shl    $0x3,%eax
f010b5bc:	01 d0                	add    %edx,%eax
f010b5be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010b5c5:	29 c2                	sub    %eax,%edx
f010b5c7:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010b5ce:	89 c2                	mov    %eax,%edx
f010b5d0:	89 d0                	mov    %edx,%eax
f010b5d2:	2d 00 00 40 11       	sub    $0x11400000,%eax
f010b5d7:	8d 90 88 00 00 00    	lea    0x88(%eax),%edx
f010b5dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5e0:	89 90 38 da 01 00    	mov    %edx,0x1da38(%eax)
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b5e6:	83 ec 0c             	sub    $0xc,%esp
f010b5e9:	6a 02                	push   $0x2
f010b5eb:	e8 f4 30 00 00       	call   f010e6e4 <isPageReplacmentAlgorithmLRU>
f010b5f0:	83 c4 10             	add    $0x10,%esp
f010b5f3:	85 c0                	test   %eax,%eax
f010b5f5:	0f 84 34 01 00 00    	je     f010b72f <initialize_environment+0x2b9>
	{
#if USE_KHEAP == 1
		//panic("not handled yet");
#else
		for (int i = 0; i < e->page_WS_max_size; ++i)
f010b5fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010b602:	e9 14 01 00 00       	jmp    f010b71b <initialize_environment+0x2a5>
		{
			LIST_INSERT_HEAD(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[i]));
f010b607:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b60a:	89 d0                	mov    %edx,%eax
f010b60c:	01 c0                	add    %eax,%eax
f010b60e:	01 d0                	add    %edx,%eax
f010b610:	c1 e0 03             	shl    $0x3,%eax
f010b613:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b619:	8b 45 08             	mov    0x8(%ebp),%eax
f010b61c:	01 d0                	add    %edx,%eax
f010b61e:	83 c0 08             	add    $0x8,%eax
f010b621:	85 c0                	test   %eax,%eax
f010b623:	75 17                	jne    f010b63c <initialize_environment+0x1c6>
f010b625:	83 ec 04             	sub    $0x4,%esp
f010b628:	68 e0 84 12 f0       	push   $0xf01284e0
f010b62d:	68 e6 03 00 00       	push   $0x3e6
f010b632:	68 03 85 12 f0       	push   $0xf0128503
f010b637:	e8 de 4c ff ff       	call   f010031a <_panic>
f010b63c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b63f:	8b 90 48 d5 01 00    	mov    0x1d548(%eax),%edx
f010b645:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b648:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f010b64b:	89 c8                	mov    %ecx,%eax
f010b64d:	01 c0                	add    %eax,%eax
f010b64f:	01 c8                	add    %ecx,%eax
f010b651:	c1 e0 03             	shl    $0x3,%eax
f010b654:	01 d8                	add    %ebx,%eax
f010b656:	05 98 00 00 00       	add    $0x98,%eax
f010b65b:	89 10                	mov    %edx,(%eax)
f010b65d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b660:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b663:	89 d0                	mov    %edx,%eax
f010b665:	01 c0                	add    %eax,%eax
f010b667:	01 d0                	add    %edx,%eax
f010b669:	c1 e0 03             	shl    $0x3,%eax
f010b66c:	01 c8                	add    %ecx,%eax
f010b66e:	05 98 00 00 00       	add    $0x98,%eax
f010b673:	8b 00                	mov    (%eax),%eax
f010b675:	85 c0                	test   %eax,%eax
f010b677:	74 28                	je     f010b6a1 <initialize_environment+0x22b>
f010b679:	8b 45 08             	mov    0x8(%ebp),%eax
f010b67c:	8b 90 48 d5 01 00    	mov    0x1d548(%eax),%edx
f010b682:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f010b685:	89 c8                	mov    %ecx,%eax
f010b687:	01 c0                	add    %eax,%eax
f010b689:	01 c8                	add    %ecx,%eax
f010b68b:	c1 e0 03             	shl    $0x3,%eax
f010b68e:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010b694:	8b 45 08             	mov    0x8(%ebp),%eax
f010b697:	01 c8                	add    %ecx,%eax
f010b699:	83 c0 08             	add    $0x8,%eax
f010b69c:	89 42 14             	mov    %eax,0x14(%edx)
f010b69f:	eb 23                	jmp    f010b6c4 <initialize_environment+0x24e>
f010b6a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b6a4:	89 d0                	mov    %edx,%eax
f010b6a6:	01 c0                	add    %eax,%eax
f010b6a8:	01 d0                	add    %edx,%eax
f010b6aa:	c1 e0 03             	shl    $0x3,%eax
f010b6ad:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b6b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6b6:	01 d0                	add    %edx,%eax
f010b6b8:	8d 50 08             	lea    0x8(%eax),%edx
f010b6bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6be:	89 90 4c d5 01 00    	mov    %edx,0x1d54c(%eax)
f010b6c4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b6c7:	89 d0                	mov    %edx,%eax
f010b6c9:	01 c0                	add    %eax,%eax
f010b6cb:	01 d0                	add    %edx,%eax
f010b6cd:	c1 e0 03             	shl    $0x3,%eax
f010b6d0:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b6d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6d9:	01 d0                	add    %edx,%eax
f010b6db:	8d 50 08             	lea    0x8(%eax),%edx
f010b6de:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6e1:	89 90 48 d5 01 00    	mov    %edx,0x1d548(%eax)
f010b6e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b6ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b6ed:	89 d0                	mov    %edx,%eax
f010b6ef:	01 c0                	add    %eax,%eax
f010b6f1:	01 d0                	add    %edx,%eax
f010b6f3:	c1 e0 03             	shl    $0x3,%eax
f010b6f6:	01 c8                	add    %ecx,%eax
f010b6f8:	05 9c 00 00 00       	add    $0x9c,%eax
f010b6fd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010b703:	8b 45 08             	mov    0x8(%ebp),%eax
f010b706:	8b 80 54 d5 01 00    	mov    0x1d554(%eax),%eax
f010b70c:	8d 50 01             	lea    0x1(%eax),%edx
f010b70f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b712:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
#if USE_KHEAP == 1
		//panic("not handled yet");
#else
		for (int i = 0; i < e->page_WS_max_size; ++i)
f010b718:	ff 45 f0             	incl   -0x10(%ebp)
f010b71b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b71e:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f010b724:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b727:	39 c2                	cmp    %eax,%edx
f010b729:	0f 87 d8 fe ff ff    	ja     f010b607 <initialize_environment+0x191>
	}

	//initialize environment working set
#if USE_KHEAP
#else
	for(i=0; i< (e->page_WS_max_size); i++)
f010b72f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b736:	eb 54                	jmp    f010b78c <initialize_environment+0x316>
	{
		e->ptr_pageWorkingSet[i].virtual_address = 0;
f010b738:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b73b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b73e:	89 d0                	mov    %edx,%eax
f010b740:	01 c0                	add    %eax,%eax
f010b742:	01 d0                	add    %edx,%eax
f010b744:	c1 e0 03             	shl    $0x3,%eax
f010b747:	01 c8                	add    %ecx,%eax
f010b749:	05 88 00 00 00       	add    $0x88,%eax
f010b74e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].empty = 1;
f010b754:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b757:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b75a:	89 d0                	mov    %edx,%eax
f010b75c:	01 c0                	add    %eax,%eax
f010b75e:	01 d0                	add    %edx,%eax
f010b760:	c1 e0 03             	shl    $0x3,%eax
f010b763:	01 c8                	add    %ecx,%eax
f010b765:	05 8c 00 00 00       	add    $0x8c,%eax
f010b76a:	c6 00 01             	movb   $0x1,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
f010b76d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b770:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b773:	89 d0                	mov    %edx,%eax
f010b775:	01 c0                	add    %eax,%eax
f010b777:	01 d0                	add    %edx,%eax
f010b779:	c1 e0 03             	shl    $0x3,%eax
f010b77c:	01 c8                	add    %ecx,%eax
f010b77e:	05 90 00 00 00       	add    $0x90,%eax
f010b783:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}

	//initialize environment working set
#if USE_KHEAP
#else
	for(i=0; i< (e->page_WS_max_size); i++)
f010b789:	ff 45 f4             	incl   -0xc(%ebp)
f010b78c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b78f:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f010b795:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b798:	39 c2                	cmp    %eax,%edx
f010b79a:	77 9c                	ja     f010b738 <initialize_environment+0x2c2>
	{
		e->ptr_pageWorkingSet[i].virtual_address = 0;
		e->ptr_pageWorkingSet[i].empty = 1;
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
f010b79c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b79f:	c7 80 58 d5 01 00 00 	movl   $0x0,0x1d558(%eax)
f010b7a6:	00 00 00 
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b7a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b7b0:	eb 54                	jmp    f010b806 <initialize_environment+0x390>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010b7b2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b7b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b7b8:	89 d0                	mov    %edx,%eax
f010b7ba:	01 c0                	add    %eax,%eax
f010b7bc:	01 d0                	add    %edx,%eax
f010b7be:	c1 e0 03             	shl    $0x3,%eax
f010b7c1:	01 c8                	add    %ecx,%eax
f010b7c3:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010b7c8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010b7ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b7d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b7d4:	89 d0                	mov    %edx,%eax
f010b7d6:	01 c0                	add    %eax,%eax
f010b7d8:	01 d0                	add    %edx,%eax
f010b7da:	c1 e0 03             	shl    $0x3,%eax
f010b7dd:	01 c8                	add    %ecx,%eax
f010b7df:	05 60 d5 01 00       	add    $0x1d560,%eax
f010b7e4:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010b7e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b7ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b7ed:	89 d0                	mov    %edx,%eax
f010b7ef:	01 c0                	add    %eax,%eax
f010b7f1:	01 d0                	add    %edx,%eax
f010b7f3:	c1 e0 03             	shl    $0x3,%eax
f010b7f6:	01 c8                	add    %ecx,%eax
f010b7f8:	05 64 d5 01 00       	add    $0x1d564,%eax
f010b7fd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b803:	ff 45 f4             	incl   -0xc(%ebp)
f010b806:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010b80a:	7e a6                	jle    f010b7b2 <initialize_environment+0x33c>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010b80c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b80f:	c7 80 0c da 01 00 00 	movl   $0x0,0x1da0c(%eax)
f010b816:	00 00 00 

	e->pageFaultsCounter=0;
f010b819:	8b 45 08             	mov    0x8(%ebp),%eax
f010b81c:	c7 80 40 da 01 00 00 	movl   $0x0,0x1da40(%eax)
f010b823:	00 00 00 
	e->tableFaultsCounter=0;
f010b826:	8b 45 08             	mov    0x8(%ebp),%eax
f010b829:	c7 80 44 da 01 00 00 	movl   $0x0,0x1da44(%eax)
f010b830:	00 00 00 

	e->freeingFullWSCounter = 0;
f010b833:	8b 45 08             	mov    0x8(%ebp),%eax
f010b836:	c7 80 48 da 01 00 00 	movl   $0x0,0x1da48(%eax)
f010b83d:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010b840:	8b 45 08             	mov    0x8(%ebp),%eax
f010b843:	c7 80 4c da 01 00 00 	movl   $0x0,0x1da4c(%eax)
f010b84a:	00 00 00 

	e->nModifiedPages=0;
f010b84d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b850:	c7 80 50 da 01 00 00 	movl   $0x0,0x1da50(%eax)
f010b857:	00 00 00 
	e->nNotModifiedPages=0;
f010b85a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b85d:	c7 80 54 da 01 00 00 	movl   $0x0,0x1da54(%eax)
f010b864:	00 00 00 
	e->nClocks = 0;
f010b867:	8b 45 08             	mov    0x8(%ebp),%eax
f010b86a:	c7 80 68 da 01 00 00 	movl   $0x0,0x1da68(%eax)
f010b871:	00 00 00 

	//2020
	e->nPageIn = 0;
f010b874:	8b 45 08             	mov    0x8(%ebp),%eax
f010b877:	c7 80 5c da 01 00 00 	movl   $0x0,0x1da5c(%eax)
f010b87e:	00 00 00 
	e->nPageOut = 0;
f010b881:	8b 45 08             	mov    0x8(%ebp),%eax
f010b884:	c7 80 60 da 01 00 00 	movl   $0x0,0x1da60(%eax)
f010b88b:	00 00 00 
	e->nNewPageAdded = 0;
f010b88e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b891:	c7 80 64 da 01 00 00 	movl   $0x0,0x1da64(%eax)
f010b898:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010b89b:	83 ec 04             	sub    $0x4,%esp
f010b89e:	68 00 00 00 82       	push   $0x82000000
f010b8a3:	68 00 00 00 80       	push   $0x80000000
f010b8a8:	ff 75 08             	pushl  0x8(%ebp)
f010b8ab:	e8 c0 fb ff ff       	call   f010b470 <initialize_uheap_dynamic_allocator>
f010b8b0:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010b8b3:	83 ec 0c             	sub    $0xc,%esp
f010b8b6:	ff 75 08             	pushl  0x8(%ebp)
f010b8b9:	e8 09 00 00 00       	call   f010b8c7 <complete_environment_initialization>
f010b8be:	83 c4 10             	add    $0x10,%esp
}
f010b8c1:	90                   	nop
f010b8c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b8c5:	c9                   	leave  
f010b8c6:	c3                   	ret    

f010b8c7 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010b8c7:	55                   	push   %ebp
f010b8c8:	89 e5                	mov    %esp,%ebp
f010b8ca:	53                   	push   %ebx
f010b8cb:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010b8ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8d1:	8b 40 64             	mov    0x64(%eax),%eax
f010b8d4:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010b8da:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8dd:	8b 40 68             	mov    0x68(%eax),%eax
f010b8e0:	83 c8 03             	or     $0x3,%eax
f010b8e3:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010b8e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8e8:	8b 40 64             	mov    0x64(%eax),%eax
f010b8eb:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010b8f1:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8f4:	8b 40 68             	mov    0x68(%eax),%eax
f010b8f7:	83 c8 05             	or     $0x5,%eax
f010b8fa:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010b8fc:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8ff:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	e->disk_env_pgdir_PA= 0;
f010b906:	8b 45 08             	mov    0x8(%ebp),%eax
f010b909:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	e->disk_env_tabledir = 0;
f010b910:	8b 45 08             	mov    0x8(%ebp),%eax
f010b913:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	e->disk_env_tabledir_PA = 0;
f010b91a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b91d:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010b924:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010b927:	8b 45 08             	mov    0x8(%ebp),%eax
f010b92a:	8b 58 10             	mov    0x10(%eax),%ebx
f010b92d:	83 ec 0c             	sub    $0xc,%esp
f010b930:	6a 08                	push   $0x8
f010b932:	e8 62 51 01 00       	call   f0120a99 <log2_ceil>
f010b937:	83 c4 10             	add    $0x10,%esp
f010b93a:	ba 01 00 00 00       	mov    $0x1,%edx
f010b93f:	88 c1                	mov    %al,%cl
f010b941:	d3 e2                	shl    %cl,%edx
f010b943:	89 d0                	mov    %edx,%eax
f010b945:	01 d8                	add    %ebx,%eax
f010b947:	89 c3                	mov    %eax,%ebx
f010b949:	83 ec 0c             	sub    $0xc,%esp
f010b94c:	6a 08                	push   $0x8
f010b94e:	e8 11 51 01 00       	call   f0120a64 <nearest_pow2_ceil>
f010b953:	83 c4 10             	add    $0x10,%esp
f010b956:	f7 d8                	neg    %eax
f010b958:	21 d8                	and    %ebx,%eax
f010b95a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010b95d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b961:	7f 1b                	jg     f010b97e <complete_environment_initialization+0xb7>
		generation = 1 << ENVGENSHIFT;
f010b963:	83 ec 0c             	sub    $0xc,%esp
f010b966:	6a 08                	push   $0x8
f010b968:	e8 2c 51 01 00       	call   f0120a99 <log2_ceil>
f010b96d:	83 c4 10             	add    $0x10,%esp
f010b970:	ba 01 00 00 00       	mov    $0x1,%edx
f010b975:	88 c1                	mov    %al,%cl
f010b977:	d3 e2                	shl    %cl,%edx
f010b979:	89 d0                	mov    %edx,%eax
f010b97b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010b97e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b981:	8b 15 b0 13 5a f0    	mov    0xf05a13b0,%edx
f010b987:	29 d0                	sub    %edx,%eax
f010b989:	c1 f8 02             	sar    $0x2,%eax
f010b98c:	89 c2                	mov    %eax,%edx
f010b98e:	89 d0                	mov    %edx,%eax
f010b990:	c1 e0 02             	shl    $0x2,%eax
f010b993:	01 d0                	add    %edx,%eax
f010b995:	c1 e0 02             	shl    $0x2,%eax
f010b998:	01 d0                	add    %edx,%eax
f010b99a:	c1 e0 02             	shl    $0x2,%eax
f010b99d:	01 d0                	add    %edx,%eax
f010b99f:	c1 e0 02             	shl    $0x2,%eax
f010b9a2:	01 d0                	add    %edx,%eax
f010b9a4:	c1 e0 08             	shl    $0x8,%eax
f010b9a7:	29 d0                	sub    %edx,%eax
f010b9a9:	c1 e0 08             	shl    $0x8,%eax
f010b9ac:	29 d0                	sub    %edx,%eax
f010b9ae:	c1 e0 03             	shl    $0x3,%eax
f010b9b1:	01 d0                	add    %edx,%eax
f010b9b3:	c1 e0 03             	shl    $0x3,%eax
f010b9b6:	01 d0                	add    %edx,%eax
f010b9b8:	01 c0                	add    %eax,%eax
f010b9ba:	01 d0                	add    %edx,%eax
f010b9bc:	0b 45 f4             	or     -0xc(%ebp),%eax
f010b9bf:	89 c2                	mov    %eax,%edx
f010b9c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9c4:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010b9c7:	e8 79 ed ff ff       	call   f010a745 <get_cpu_proc>
f010b9cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010b9cf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010b9d3:	75 0c                	jne    f010b9e1 <complete_environment_initialization+0x11a>
		e->env_parent_id = 0;//no parent;
f010b9d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9d8:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b9df:	eb 0c                	jmp    f010b9ed <complete_environment_initialization+0x126>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010b9e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b9e4:	8b 50 10             	mov    0x10(%eax),%edx
f010b9e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9ea:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010b9ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9f0:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010b9f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9fa:	c7 80 58 da 01 00 00 	movl   $0x0,0x1da58(%eax)
f010ba01:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010ba04:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba07:	8b 00                	mov    (%eax),%eax
f010ba09:	83 ec 04             	sub    $0x4,%esp
f010ba0c:	6a 44                	push   $0x44
f010ba0e:	6a 00                	push   $0x0
f010ba10:	50                   	push   %eax
f010ba11:	e8 e4 6b 01 00       	call   f01225fa <memset>
f010ba16:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010ba19:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba1c:	8b 00                	mov    (%eax),%eax
f010ba1e:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010ba24:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba27:	8b 00                	mov    (%eax),%eax
f010ba29:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010ba2f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba32:	8b 00                	mov    (%eax),%eax
f010ba34:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010ba3a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba3d:	8b 00                	mov    (%eax),%eax
f010ba3f:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010ba46:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba49:	8b 00                	mov    (%eax),%eax
f010ba4b:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010ba51:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba54:	8b 00                	mov    (%eax),%eax
f010ba56:	8b 55 08             	mov    0x8(%ebp),%edx
f010ba59:	8b 12                	mov    (%edx),%edx
f010ba5b:	8b 52 38             	mov    0x38(%edx),%edx
f010ba5e:	80 ce 02             	or     $0x2,%dh
f010ba61:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010ba64:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ba68:	75 17                	jne    f010ba81 <complete_environment_initialization+0x1ba>
f010ba6a:	83 ec 04             	sub    $0x4,%esp
f010ba6d:	68 95 85 12 f0       	push   $0xf0128595
f010ba72:	68 52 04 00 00       	push   $0x452
f010ba77:	68 03 85 12 f0       	push   $0xf0128503
f010ba7c:	e8 99 48 ff ff       	call   f010031a <_panic>
f010ba81:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba84:	8b 40 08             	mov    0x8(%eax),%eax
f010ba87:	85 c0                	test   %eax,%eax
f010ba89:	74 11                	je     f010ba9c <complete_environment_initialization+0x1d5>
f010ba8b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba8e:	8b 40 08             	mov    0x8(%eax),%eax
f010ba91:	8b 55 08             	mov    0x8(%ebp),%edx
f010ba94:	8b 52 0c             	mov    0xc(%edx),%edx
f010ba97:	89 50 0c             	mov    %edx,0xc(%eax)
f010ba9a:	eb 0b                	jmp    f010baa7 <complete_environment_initialization+0x1e0>
f010ba9c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba9f:	8b 40 0c             	mov    0xc(%eax),%eax
f010baa2:	a3 b8 13 5a f0       	mov    %eax,0xf05a13b8
f010baa7:	8b 45 08             	mov    0x8(%ebp),%eax
f010baaa:	8b 40 0c             	mov    0xc(%eax),%eax
f010baad:	85 c0                	test   %eax,%eax
f010baaf:	74 11                	je     f010bac2 <complete_environment_initialization+0x1fb>
f010bab1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bab4:	8b 40 0c             	mov    0xc(%eax),%eax
f010bab7:	8b 55 08             	mov    0x8(%ebp),%edx
f010baba:	8b 52 08             	mov    0x8(%edx),%edx
f010babd:	89 50 08             	mov    %edx,0x8(%eax)
f010bac0:	eb 0b                	jmp    f010bacd <complete_environment_initialization+0x206>
f010bac2:	8b 45 08             	mov    0x8(%ebp),%eax
f010bac5:	8b 40 08             	mov    0x8(%eax),%eax
f010bac8:	a3 b4 13 5a f0       	mov    %eax,0xf05a13b4
f010bacd:	8b 45 08             	mov    0x8(%ebp),%eax
f010bad0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010bad7:	8b 45 08             	mov    0x8(%ebp),%eax
f010bada:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010bae1:	a1 c0 13 5a f0       	mov    0xf05a13c0,%eax
f010bae6:	48                   	dec    %eax
f010bae7:	a3 c0 13 5a f0       	mov    %eax,0xf05a13c0
	return ;
f010baec:	90                   	nop
}
f010baed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010baf0:	c9                   	leave  
f010baf1:	c3                   	ret    

f010baf2 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010baf2:	55                   	push   %ebp
f010baf3:	89 e5                	mov    %esp,%ebp
f010baf5:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010baf8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bafb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bafe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb01:	8b 00                	mov    (%eax),%eax
f010bb03:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bb08:	74 17                	je     f010bb21 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010bb0a:	83 ec 04             	sub    $0x4,%esp
f010bb0d:	68 23 88 12 f0       	push   $0xf0128823
f010bb12:	68 5e 04 00 00       	push   $0x45e
f010bb17:	68 03 85 12 f0       	push   $0xf0128503
f010bb1c:	e8 f9 47 ff ff       	call   f010031a <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010bb21:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb24:	8b 00                	mov    (%eax),%eax
f010bb26:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bb29:	8b 52 18             	mov    0x18(%edx),%edx
f010bb2c:	89 50 30             	mov    %edx,0x30(%eax)
}
f010bb2f:	90                   	nop
f010bb30:	c9                   	leave  
f010bb31:	c3                   	ret    

f010bb32 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010bb32:	55                   	push   %ebp
f010bb33:	89 e5                	mov    %esp,%ebp
f010bb35:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010bb38:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb3b:	8b 40 10             	mov    0x10(%eax),%eax
f010bb3e:	8d 48 01             	lea    0x1(%eax),%ecx
f010bb41:	8b 55 08             	mov    0x8(%ebp),%edx
f010bb44:	89 4a 10             	mov    %ecx,0x10(%edx)
f010bb47:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010bb4a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bb50:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bb53:	8b 00                	mov    (%eax),%eax
f010bb55:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bb5a:	74 17                	je     f010bb73 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010bb5c:	83 ec 04             	sub    $0x4,%esp
f010bb5f:	68 23 88 12 f0       	push   $0xf0128823
f010bb64:	68 6c 04 00 00       	push   $0x46c
f010bb69:	68 03 85 12 f0       	push   $0xf0128503
f010bb6e:	e8 a7 47 ff ff       	call   f010031a <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010bb73:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bb76:	8b 50 1c             	mov    0x1c(%eax),%edx
f010bb79:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb7c:	01 d0                	add    %edx,%eax
f010bb7e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010bb81:	eb 0f                	jmp    f010bb92 <PROGRAM_SEGMENT_NEXT+0x60>
f010bb83:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb86:	8b 40 10             	mov    0x10(%eax),%eax
f010bb89:	8d 50 01             	lea    0x1(%eax),%edx
f010bb8c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb8f:	89 50 10             	mov    %edx,0x10(%eax)
f010bb92:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb95:	8b 40 10             	mov    0x10(%eax),%eax
f010bb98:	c1 e0 05             	shl    $0x5,%eax
f010bb9b:	89 c2                	mov    %eax,%edx
f010bb9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bba0:	01 d0                	add    %edx,%eax
f010bba2:	8b 00                	mov    (%eax),%eax
f010bba4:	83 f8 01             	cmp    $0x1,%eax
f010bba7:	74 13                	je     f010bbbc <PROGRAM_SEGMENT_NEXT+0x8a>
f010bba9:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbac:	8b 50 10             	mov    0x10(%eax),%edx
f010bbaf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bbb2:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bbb5:	0f b7 c0             	movzwl %ax,%eax
f010bbb8:	39 c2                	cmp    %eax,%edx
f010bbba:	72 c7                	jb     f010bb83 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010bbbc:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbbf:	8b 40 10             	mov    0x10(%eax),%eax
f010bbc2:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010bbc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bbc8:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bbcb:	0f b7 c0             	movzwl %ax,%eax
f010bbce:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010bbd1:	7e 63                	jle    f010bc36 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010bbd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bbd6:	c1 e0 05             	shl    $0x5,%eax
f010bbd9:	89 c2                	mov    %eax,%edx
f010bbdb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bbde:	01 d0                	add    %edx,%eax
f010bbe0:	8b 50 04             	mov    0x4(%eax),%edx
f010bbe3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bbe6:	01 c2                	add    %eax,%edx
f010bbe8:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbeb:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010bbed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bbf0:	c1 e0 05             	shl    $0x5,%eax
f010bbf3:	89 c2                	mov    %eax,%edx
f010bbf5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bbf8:	01 d0                	add    %edx,%eax
f010bbfa:	8b 50 14             	mov    0x14(%eax),%edx
f010bbfd:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc00:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010bc03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc06:	c1 e0 05             	shl    $0x5,%eax
f010bc09:	89 c2                	mov    %eax,%edx
f010bc0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc0e:	01 d0                	add    %edx,%eax
f010bc10:	8b 50 10             	mov    0x10(%eax),%edx
f010bc13:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc16:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010bc19:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc1c:	c1 e0 05             	shl    $0x5,%eax
f010bc1f:	89 c2                	mov    %eax,%edx
f010bc21:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc24:	01 d0                	add    %edx,%eax
f010bc26:	8b 40 08             	mov    0x8(%eax),%eax
f010bc29:	89 c2                	mov    %eax,%edx
f010bc2b:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc2e:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010bc31:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc34:	eb 05                	jmp    f010bc3b <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010bc36:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bc3b:	c9                   	leave  
f010bc3c:	c3                   	ret    

f010bc3d <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010bc3d:	55                   	push   %ebp
f010bc3e:	89 e5                	mov    %esp,%ebp
f010bc40:	57                   	push   %edi
f010bc41:	56                   	push   %esi
f010bc42:	53                   	push   %ebx
f010bc43:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010bc46:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010bc4d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc50:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bc53:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bc56:	8b 00                	mov    (%eax),%eax
f010bc58:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bc5d:	74 17                	je     f010bc76 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010bc5f:	83 ec 04             	sub    $0x4,%esp
f010bc62:	68 23 88 12 f0       	push   $0xf0128823
f010bc67:	68 88 04 00 00       	push   $0x488
f010bc6c:	68 03 85 12 f0       	push   $0xf0128503
f010bc71:	e8 a4 46 ff ff       	call   f010031a <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010bc76:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bc79:	8b 50 1c             	mov    0x1c(%eax),%edx
f010bc7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc7f:	01 d0                	add    %edx,%eax
f010bc81:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010bc84:	eb 07                	jmp    f010bc8d <PROGRAM_SEGMENT_FIRST+0x50>
f010bc86:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bc89:	40                   	inc    %eax
f010bc8a:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010bc8d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bc90:	c1 e0 05             	shl    $0x5,%eax
f010bc93:	89 c2                	mov    %eax,%edx
f010bc95:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bc98:	01 d0                	add    %edx,%eax
f010bc9a:	8b 00                	mov    (%eax),%eax
f010bc9c:	83 f8 01             	cmp    $0x1,%eax
f010bc9f:	74 10                	je     f010bcb1 <PROGRAM_SEGMENT_FIRST+0x74>
f010bca1:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010bca4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bca7:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bcaa:	0f b7 c0             	movzwl %ax,%eax
f010bcad:	39 c2                	cmp    %eax,%edx
f010bcaf:	72 d5                	jb     f010bc86 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010bcb1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bcb4:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010bcb7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bcba:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bcbd:	0f b7 c0             	movzwl %ax,%eax
f010bcc0:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010bcc3:	7e 68                	jle    f010bd2d <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010bcc5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bcc8:	c1 e0 05             	shl    $0x5,%eax
f010bccb:	89 c2                	mov    %eax,%edx
f010bccd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bcd0:	01 d0                	add    %edx,%eax
f010bcd2:	8b 50 04             	mov    0x4(%eax),%edx
f010bcd5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bcd8:	01 d0                	add    %edx,%eax
f010bcda:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010bcdd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bce0:	c1 e0 05             	shl    $0x5,%eax
f010bce3:	89 c2                	mov    %eax,%edx
f010bce5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bce8:	01 d0                	add    %edx,%eax
f010bcea:	8b 40 14             	mov    0x14(%eax),%eax
f010bced:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010bcf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bcf3:	c1 e0 05             	shl    $0x5,%eax
f010bcf6:	89 c2                	mov    %eax,%edx
f010bcf8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bcfb:	01 d0                	add    %edx,%eax
f010bcfd:	8b 40 10             	mov    0x10(%eax),%eax
f010bd00:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010bd03:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bd06:	c1 e0 05             	shl    $0x5,%eax
f010bd09:	89 c2                	mov    %eax,%edx
f010bd0b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd0e:	01 d0                	add    %edx,%eax
f010bd10:	8b 40 08             	mov    0x8(%eax),%eax
f010bd13:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010bd16:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd19:	89 c3                	mov    %eax,%ebx
f010bd1b:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010bd1e:	ba 05 00 00 00       	mov    $0x5,%edx
f010bd23:	89 df                	mov    %ebx,%edi
f010bd25:	89 c6                	mov    %eax,%esi
f010bd27:	89 d1                	mov    %edx,%ecx
f010bd29:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010bd2b:	eb 1c                	jmp    f010bd49 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010bd2d:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010bd34:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd37:	89 c3                	mov    %eax,%ebx
f010bd39:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010bd3c:	ba 05 00 00 00       	mov    $0x5,%edx
f010bd41:	89 df                	mov    %ebx,%edi
f010bd43:	89 c6                	mov    %eax,%esi
f010bd45:	89 d1                	mov    %edx,%ecx
f010bd47:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010bd49:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd4c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010bd4f:	5b                   	pop    %ebx
f010bd50:	5e                   	pop    %esi
f010bd51:	5f                   	pop    %edi
f010bd52:	5d                   	pop    %ebp
f010bd53:	c2 04 00             	ret    $0x4

f010bd56 <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010bd56:	55                   	push   %ebp
f010bd57:	89 e5                	mov    %esp,%ebp
f010bd59:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010bd5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010bd63:	83 ec 0c             	sub    $0xc,%esp
f010bd66:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f010bd6b:	e8 85 2d 00 00       	call   f010eaf5 <acquire_spinlock>
f010bd70:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010bd73:	a1 d0 1e 5a f0       	mov    0xf05a1ed0,%eax
f010bd78:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010bd7b:	e9 c3 00 00 00       	jmp    f010be43 <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010bd80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd83:	8b 40 0c             	mov    0xc(%eax),%eax
f010bd86:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bd89:	0f 85 ac 00 00 00    	jne    f010be3b <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010bd8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd92:	8b 50 10             	mov    0x10(%eax),%edx
f010bd95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd98:	8b 40 0c             	mov    0xc(%eax),%eax
f010bd9b:	8b 40 64             	mov    0x64(%eax),%eax
f010bd9e:	83 ec 08             	sub    $0x8,%esp
f010bda1:	52                   	push   %edx
f010bda2:	50                   	push   %eax
f010bda3:	e8 62 ce ff ff       	call   f0108c0a <pt_clear_page_table_entry>
f010bda8:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010bdab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bdaf:	75 17                	jne    f010bdc8 <cleanup_buffers+0x72>
f010bdb1:	83 ec 04             	sub    $0x4,%esp
f010bdb4:	68 95 85 12 f0       	push   $0xf0128595
f010bdb9:	68 b1 04 00 00       	push   $0x4b1
f010bdbe:	68 03 85 12 f0       	push   $0xf0128503
f010bdc3:	e8 52 45 ff ff       	call   f010031a <_panic>
f010bdc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdcb:	8b 00                	mov    (%eax),%eax
f010bdcd:	85 c0                	test   %eax,%eax
f010bdcf:	74 10                	je     f010bde1 <cleanup_buffers+0x8b>
f010bdd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdd4:	8b 00                	mov    (%eax),%eax
f010bdd6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bdd9:	8b 52 04             	mov    0x4(%edx),%edx
f010bddc:	89 50 04             	mov    %edx,0x4(%eax)
f010bddf:	eb 0b                	jmp    f010bdec <cleanup_buffers+0x96>
f010bde1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bde4:	8b 40 04             	mov    0x4(%eax),%eax
f010bde7:	a3 d4 1e 5a f0       	mov    %eax,0xf05a1ed4
f010bdec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdef:	8b 40 04             	mov    0x4(%eax),%eax
f010bdf2:	85 c0                	test   %eax,%eax
f010bdf4:	74 0f                	je     f010be05 <cleanup_buffers+0xaf>
f010bdf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdf9:	8b 40 04             	mov    0x4(%eax),%eax
f010bdfc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bdff:	8b 12                	mov    (%edx),%edx
f010be01:	89 10                	mov    %edx,(%eax)
f010be03:	eb 0a                	jmp    f010be0f <cleanup_buffers+0xb9>
f010be05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be08:	8b 00                	mov    (%eax),%eax
f010be0a:	a3 d0 1e 5a f0       	mov    %eax,0xf05a1ed0
f010be0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be12:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010be18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be1b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010be22:	a1 dc 1e 5a f0       	mov    0xf05a1edc,%eax
f010be27:	48                   	dec    %eax
f010be28:	a3 dc 1e 5a f0       	mov    %eax,0xf05a1edc

				free_frame(ptr_fi);
f010be2d:	83 ec 0c             	sub    $0xc,%esp
f010be30:	ff 75 f4             	pushl  -0xc(%ebp)
f010be33:	e8 c1 c4 ff ff       	call   f01082f9 <free_frame>
f010be38:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010be3b:	a1 d8 1e 5a f0       	mov    0xf05a1ed8,%eax
f010be40:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010be43:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010be47:	74 07                	je     f010be50 <cleanup_buffers+0xfa>
f010be49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be4c:	8b 00                	mov    (%eax),%eax
f010be4e:	eb 05                	jmp    f010be55 <cleanup_buffers+0xff>
f010be50:	b8 00 00 00 00       	mov    $0x0,%eax
f010be55:	a3 d8 1e 5a f0       	mov    %eax,0xf05a1ed8
f010be5a:	a1 d8 1e 5a f0       	mov    0xf05a1ed8,%eax
f010be5f:	85 c0                	test   %eax,%eax
f010be61:	0f 85 19 ff ff ff    	jne    f010bd80 <cleanup_buffers+0x2a>
f010be67:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010be6b:	0f 85 0f ff ff ff    	jne    f010bd80 <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010be71:	83 ec 0c             	sub    $0xc,%esp
f010be74:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f010be79:	e8 fe 2c 00 00       	call   f010eb7c <release_spinlock>
f010be7e:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010be81:	90                   	nop
f010be82:	c9                   	leave  
f010be83:	c3                   	ret    

f010be84 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010be84:	55                   	push   %ebp
f010be85:	89 e5                	mov    %esp,%ebp
f010be87:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010be8a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010be8e:	7e 06                	jle    f010be96 <set_program_priority+0x12>
f010be90:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010be94:	7e 14                	jle    f010beaa <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010be96:	83 ec 04             	sub    $0x4,%esp
f010be99:	68 3c 88 12 f0       	push   $0xf012883c
f010be9e:	6a 10                	push   $0x10
f010bea0:	68 60 88 12 f0       	push   $0xf0128860
f010bea5:	e8 70 44 ff ff       	call   f010031a <_panic>
		return;
	}
	if(env == NULL)
f010beaa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010beae:	74 78                	je     f010bf28 <set_program_priority+0xa4>
		return;
	switch(priority)
f010beb0:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010beb4:	77 56                	ja     f010bf0c <set_program_priority+0x88>
f010beb6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010beb9:	c1 e0 02             	shl    $0x2,%eax
f010bebc:	05 9c 88 12 f0       	add    $0xf012889c,%eax
f010bec1:	8b 00                	mov    (%eax),%eax
f010bec3:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010bec5:	83 ec 08             	sub    $0x8,%esp
f010bec8:	6a 01                	push   $0x1
f010beca:	ff 75 08             	pushl  0x8(%ebp)
f010becd:	e8 b6 d7 ff ff       	call   f0109688 <half_WS_Size>
f010bed2:	83 c4 10             	add    $0x10,%esp
			break;
f010bed5:	eb 35                	jmp    f010bf0c <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010bed7:	83 ec 08             	sub    $0x8,%esp
f010beda:	6a 00                	push   $0x0
f010bedc:	ff 75 08             	pushl  0x8(%ebp)
f010bedf:	e8 a4 d7 ff ff       	call   f0109688 <half_WS_Size>
f010bee4:	83 c4 10             	add    $0x10,%esp
			break;
f010bee7:	eb 23                	jmp    f010bf0c <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010bee9:	83 ec 08             	sub    $0x8,%esp
f010beec:	6a 01                	push   $0x1
f010beee:	ff 75 08             	pushl  0x8(%ebp)
f010bef1:	e8 75 d7 ff ff       	call   f010966b <double_WS_Size>
f010bef6:	83 c4 10             	add    $0x10,%esp
			break;
f010bef9:	eb 11                	jmp    f010bf0c <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010befb:	83 ec 08             	sub    $0x8,%esp
f010befe:	6a 00                	push   $0x0
f010bf00:	ff 75 08             	pushl  0x8(%ebp)
f010bf03:	e8 63 d7 ff ff       	call   f010966b <double_WS_Size>
f010bf08:	83 c4 10             	add    $0x10,%esp
			break;
f010bf0b:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010bf0c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf0f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010bf15:	83 ec 08             	sub    $0x8,%esp
f010bf18:	50                   	push   %eax
f010bf19:	68 7d 88 12 f0       	push   $0xf012887d
f010bf1e:	e8 49 50 ff ff       	call   f0100f6c <cprintf>
f010bf23:	83 c4 10             	add    $0x10,%esp
f010bf26:	eb 01                	jmp    f010bf29 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010bf28:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010bf29:	c9                   	leave  
f010bf2a:	c3                   	ret    

f010bf2b <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010bf2b:	55                   	push   %ebp
f010bf2c:	89 e5                	mov    %esp,%ebp
f010bf2e:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bf31:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bf38:	eb 29                	jmp    f010bf63 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010bf3a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf3d:	89 d0                	mov    %edx,%eax
f010bf3f:	01 c0                	add    %eax,%eax
f010bf41:	01 d0                	add    %edx,%eax
f010bf43:	c1 e0 02             	shl    $0x2,%eax
f010bf46:	05 80 09 18 f0       	add    $0xf0180980,%eax
f010bf4b:	8b 00                	mov    (%eax),%eax
f010bf4d:	83 ec 08             	sub    $0x8,%esp
f010bf50:	50                   	push   %eax
f010bf51:	ff 75 08             	pushl  0x8(%ebp)
f010bf54:	e8 bf 65 01 00       	call   f0122518 <strcmp>
f010bf59:	83 c4 10             	add    $0x10,%esp
f010bf5c:	85 c0                	test   %eax,%eax
f010bf5e:	74 0f                	je     f010bf6f <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bf60:	ff 45 f4             	incl   -0xc(%ebp)
f010bf63:	a1 e4 0c 18 f0       	mov    0xf0180ce4,%eax
f010bf68:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bf6b:	7c cd                	jl     f010bf3a <get_user_program_info+0xf>
f010bf6d:	eb 01                	jmp    f010bf70 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010bf6f:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010bf70:	a1 e4 0c 18 f0       	mov    0xf0180ce4,%eax
f010bf75:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bf78:	75 1a                	jne    f010bf94 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010bf7a:	83 ec 08             	sub    $0x8,%esp
f010bf7d:	ff 75 08             	pushl  0x8(%ebp)
f010bf80:	68 01 96 12 f0       	push   $0xf0129601
f010bf85:	e8 e2 4f ff ff       	call   f0100f6c <cprintf>
f010bf8a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010bf8d:	b8 00 00 00 00       	mov    $0x0,%eax
f010bf92:	eb 11                	jmp    f010bfa5 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010bf94:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf97:	89 d0                	mov    %edx,%eax
f010bf99:	01 c0                	add    %eax,%eax
f010bf9b:	01 d0                	add    %edx,%eax
f010bf9d:	c1 e0 02             	shl    $0x2,%eax
f010bfa0:	05 80 09 18 f0       	add    $0xf0180980,%eax
}
f010bfa5:	c9                   	leave  
f010bfa6:	c3                   	ret    

f010bfa7 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010bfa7:	55                   	push   %ebp
f010bfa8:	89 e5                	mov    %esp,%ebp
f010bfaa:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bfad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bfb4:	eb 2d                	jmp    f010bfe3 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010bfb6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bfb9:	89 d0                	mov    %edx,%eax
f010bfbb:	01 c0                	add    %eax,%eax
f010bfbd:	01 d0                	add    %edx,%eax
f010bfbf:	c1 e0 02             	shl    $0x2,%eax
f010bfc2:	05 80 09 18 f0       	add    $0xf0180980,%eax
f010bfc7:	8b 00                	mov    (%eax),%eax
f010bfc9:	8b 55 08             	mov    0x8(%ebp),%edx
f010bfcc:	83 c2 20             	add    $0x20,%edx
f010bfcf:	83 ec 08             	sub    $0x8,%esp
f010bfd2:	50                   	push   %eax
f010bfd3:	52                   	push   %edx
f010bfd4:	e8 3f 65 01 00       	call   f0122518 <strcmp>
f010bfd9:	83 c4 10             	add    $0x10,%esp
f010bfdc:	85 c0                	test   %eax,%eax
f010bfde:	74 0f                	je     f010bfef <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bfe0:	ff 45 f4             	incl   -0xc(%ebp)
f010bfe3:	a1 e4 0c 18 f0       	mov    0xf0180ce4,%eax
f010bfe8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bfeb:	7c c9                	jl     f010bfb6 <get_user_program_info_by_env+0xf>
f010bfed:	eb 01                	jmp    f010bff0 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010bfef:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010bff0:	a1 e4 0c 18 f0       	mov    0xf0180ce4,%eax
f010bff5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bff8:	75 17                	jne    f010c011 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010bffa:	83 ec 0c             	sub    $0xc,%esp
f010bffd:	68 1c 96 12 f0       	push   $0xf012961c
f010c002:	e8 65 4f ff ff       	call   f0100f6c <cprintf>
f010c007:	83 c4 10             	add    $0x10,%esp
		return 0;
f010c00a:	b8 00 00 00 00       	mov    $0x0,%eax
f010c00f:	eb 11                	jmp    f010c022 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010c011:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c014:	89 d0                	mov    %edx,%eax
f010c016:	01 c0                	add    %eax,%eax
f010c018:	01 d0                	add    %edx,%eax
f010c01a:	c1 e0 02             	shl    $0x2,%eax
f010c01d:	05 80 09 18 f0       	add    $0xf0180980,%eax
}
f010c022:	c9                   	leave  
f010c023:	c3                   	ret    

f010c024 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010c024:	55                   	push   %ebp
f010c025:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010c027:	8b 45 08             	mov    0x8(%ebp),%eax
f010c02a:	83 f8 13             	cmp    $0x13,%eax
f010c02d:	77 0c                	ja     f010c03b <trapname+0x17>
		return excnames[trapno];
f010c02f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c032:	8b 04 85 00 9a 12 f0 	mov    -0xfed6600(,%eax,4),%eax
f010c039:	eb 2c                	jmp    f010c067 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010c03b:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010c03f:	75 07                	jne    f010c048 <trapname+0x24>
		return "System call";
f010c041:	b8 40 96 12 f0       	mov    $0xf0129640,%eax
f010c046:	eb 1f                	jmp    f010c067 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010c048:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010c04c:	75 07                	jne    f010c055 <trapname+0x31>
		return "Clock Interrupt";
f010c04e:	b8 4c 96 12 f0       	mov    $0xf012964c,%eax
f010c053:	eb 12                	jmp    f010c067 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010c055:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010c059:	75 07                	jne    f010c062 <trapname+0x3e>
		return "Keyboard Interrupt";
f010c05b:	b8 5c 96 12 f0       	mov    $0xf012965c,%eax
f010c060:	eb 05                	jmp    f010c067 <trapname+0x43>
	return "(unknown trap)";
f010c062:	b8 6f 96 12 f0       	mov    $0xf012966f,%eax
}
f010c067:	5d                   	pop    %ebp
f010c068:	c3                   	ret    

f010c069 <ts_init>:


void ts_init(void)
{
f010c069:	55                   	push   %ebp
f010c06a:	89 e5                	mov    %esp,%ebp
f010c06c:	53                   	push   %ebx
f010c06d:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010c070:	e8 20 b1 ff ff       	call   f0107195 <pushcli>

	struct cpu* c = mycpu();
f010c075:	e8 58 b0 ff ff       	call   f01070d2 <mycpu>
f010c07a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010c07d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c080:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010c087:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c08a:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010c090:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c093:	83 c0 0c             	add    $0xc,%eax
f010c096:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c099:	83 c2 0c             	add    $0xc,%edx
f010c09c:	c1 ea 10             	shr    $0x10,%edx
f010c09f:	88 d3                	mov    %dl,%bl
f010c0a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0a4:	83 c2 0c             	add    $0xc,%edx
f010c0a7:	c1 ea 18             	shr    $0x18,%edx
f010c0aa:	88 d1                	mov    %dl,%cl
f010c0ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0af:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010c0b6:	68 00 
f010c0b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0bb:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010c0c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0c5:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010c0cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0ce:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c0d4:	83 e2 f0             	and    $0xfffffff0,%edx
f010c0d7:	83 ca 09             	or     $0x9,%edx
f010c0da:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c0e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0e3:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c0e9:	83 ca 10             	or     $0x10,%edx
f010c0ec:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c0f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0f5:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c0fb:	83 e2 9f             	and    $0xffffff9f,%edx
f010c0fe:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c104:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c107:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c10d:	83 ca 80             	or     $0xffffff80,%edx
f010c110:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c116:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c119:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c11f:	83 e2 f0             	and    $0xfffffff0,%edx
f010c122:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c128:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c12b:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c131:	83 e2 ef             	and    $0xffffffef,%edx
f010c134:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c13a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c13d:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c143:	83 e2 df             	and    $0xffffffdf,%edx
f010c146:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c14c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c14f:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c155:	83 ca 40             	or     $0x40,%edx
f010c158:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c15e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c161:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c167:	83 e2 7f             	and    $0x7f,%edx
f010c16a:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c170:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c173:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010c179:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c17c:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c182:	83 e2 ef             	and    $0xffffffef,%edx
f010c185:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010c18b:	e8 57 b0 ff ff       	call   f01071e7 <popcli>
f010c190:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010c196:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010c19a:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010c19d:	90                   	nop
f010c19e:	83 c4 14             	add    $0x14,%esp
f010c1a1:	5b                   	pop    %ebx
f010c1a2:	5d                   	pop    %ebp
f010c1a3:	c3                   	ret    

f010c1a4 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010c1a4:	55                   	push   %ebp
f010c1a5:	89 e5                	mov    %esp,%ebp
f010c1a7:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010c1aa:	b8 52 d6 10 f0       	mov    $0xf010d652,%eax
f010c1af:	66 a3 20 14 5a f0    	mov    %ax,0xf05a1420
f010c1b5:	66 c7 05 22 14 5a f0 	movw   $0x8,0xf05a1422
f010c1bc:	08 00 
f010c1be:	a0 24 14 5a f0       	mov    0xf05a1424,%al
f010c1c3:	83 e0 e0             	and    $0xffffffe0,%eax
f010c1c6:	a2 24 14 5a f0       	mov    %al,0xf05a1424
f010c1cb:	a0 24 14 5a f0       	mov    0xf05a1424,%al
f010c1d0:	83 e0 1f             	and    $0x1f,%eax
f010c1d3:	a2 24 14 5a f0       	mov    %al,0xf05a1424
f010c1d8:	a0 25 14 5a f0       	mov    0xf05a1425,%al
f010c1dd:	83 e0 f0             	and    $0xfffffff0,%eax
f010c1e0:	83 c8 0e             	or     $0xe,%eax
f010c1e3:	a2 25 14 5a f0       	mov    %al,0xf05a1425
f010c1e8:	a0 25 14 5a f0       	mov    0xf05a1425,%al
f010c1ed:	83 e0 ef             	and    $0xffffffef,%eax
f010c1f0:	a2 25 14 5a f0       	mov    %al,0xf05a1425
f010c1f5:	a0 25 14 5a f0       	mov    0xf05a1425,%al
f010c1fa:	83 e0 9f             	and    $0xffffff9f,%eax
f010c1fd:	a2 25 14 5a f0       	mov    %al,0xf05a1425
f010c202:	a0 25 14 5a f0       	mov    0xf05a1425,%al
f010c207:	83 c8 80             	or     $0xffffff80,%eax
f010c20a:	a2 25 14 5a f0       	mov    %al,0xf05a1425
f010c20f:	b8 52 d6 10 f0       	mov    $0xf010d652,%eax
f010c214:	c1 e8 10             	shr    $0x10,%eax
f010c217:	66 a3 26 14 5a f0    	mov    %ax,0xf05a1426
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010c21d:	b8 5a d6 10 f0       	mov    $0xf010d65a,%eax
f010c222:	66 a3 50 14 5a f0    	mov    %ax,0xf05a1450
f010c228:	66 c7 05 52 14 5a f0 	movw   $0x8,0xf05a1452
f010c22f:	08 00 
f010c231:	a0 54 14 5a f0       	mov    0xf05a1454,%al
f010c236:	83 e0 e0             	and    $0xffffffe0,%eax
f010c239:	a2 54 14 5a f0       	mov    %al,0xf05a1454
f010c23e:	a0 54 14 5a f0       	mov    0xf05a1454,%al
f010c243:	83 e0 1f             	and    $0x1f,%eax
f010c246:	a2 54 14 5a f0       	mov    %al,0xf05a1454
f010c24b:	a0 55 14 5a f0       	mov    0xf05a1455,%al
f010c250:	83 e0 f0             	and    $0xfffffff0,%eax
f010c253:	83 c8 0e             	or     $0xe,%eax
f010c256:	a2 55 14 5a f0       	mov    %al,0xf05a1455
f010c25b:	a0 55 14 5a f0       	mov    0xf05a1455,%al
f010c260:	83 e0 ef             	and    $0xffffffef,%eax
f010c263:	a2 55 14 5a f0       	mov    %al,0xf05a1455
f010c268:	a0 55 14 5a f0       	mov    0xf05a1455,%al
f010c26d:	83 e0 9f             	and    $0xffffff9f,%eax
f010c270:	a2 55 14 5a f0       	mov    %al,0xf05a1455
f010c275:	a0 55 14 5a f0       	mov    0xf05a1455,%al
f010c27a:	83 c8 80             	or     $0xffffff80,%eax
f010c27d:	a2 55 14 5a f0       	mov    %al,0xf05a1455
f010c282:	b8 5a d6 10 f0       	mov    $0xf010d65a,%eax
f010c287:	c1 e8 10             	shr    $0x10,%eax
f010c28a:	66 a3 56 14 5a f0    	mov    %ax,0xf05a1456
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010c290:	b8 62 d6 10 f0       	mov    $0xf010d662,%eax
f010c295:	66 a3 e0 14 5a f0    	mov    %ax,0xf05a14e0
f010c29b:	66 c7 05 e2 14 5a f0 	movw   $0x8,0xf05a14e2
f010c2a2:	08 00 
f010c2a4:	a0 e4 14 5a f0       	mov    0xf05a14e4,%al
f010c2a9:	83 e0 e0             	and    $0xffffffe0,%eax
f010c2ac:	a2 e4 14 5a f0       	mov    %al,0xf05a14e4
f010c2b1:	a0 e4 14 5a f0       	mov    0xf05a14e4,%al
f010c2b6:	83 e0 1f             	and    $0x1f,%eax
f010c2b9:	a2 e4 14 5a f0       	mov    %al,0xf05a14e4
f010c2be:	a0 e5 14 5a f0       	mov    0xf05a14e5,%al
f010c2c3:	83 e0 f0             	and    $0xfffffff0,%eax
f010c2c6:	83 c8 0e             	or     $0xe,%eax
f010c2c9:	a2 e5 14 5a f0       	mov    %al,0xf05a14e5
f010c2ce:	a0 e5 14 5a f0       	mov    0xf05a14e5,%al
f010c2d3:	83 e0 ef             	and    $0xffffffef,%eax
f010c2d6:	a2 e5 14 5a f0       	mov    %al,0xf05a14e5
f010c2db:	a0 e5 14 5a f0       	mov    0xf05a14e5,%al
f010c2e0:	83 c8 60             	or     $0x60,%eax
f010c2e3:	a2 e5 14 5a f0       	mov    %al,0xf05a14e5
f010c2e8:	a0 e5 14 5a f0       	mov    0xf05a14e5,%al
f010c2ed:	83 c8 80             	or     $0xffffff80,%eax
f010c2f0:	a2 e5 14 5a f0       	mov    %al,0xf05a14e5
f010c2f5:	b8 62 d6 10 f0       	mov    $0xf010d662,%eax
f010c2fa:	c1 e8 10             	shr    $0x10,%eax
f010c2fd:	66 a3 e6 14 5a f0    	mov    %ax,0xf05a14e6
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010c303:	b8 6c d6 10 f0       	mov    $0xf010d66c,%eax
f010c308:	66 a3 e8 14 5a f0    	mov    %ax,0xf05a14e8
f010c30e:	66 c7 05 ea 14 5a f0 	movw   $0x8,0xf05a14ea
f010c315:	08 00 
f010c317:	a0 ec 14 5a f0       	mov    0xf05a14ec,%al
f010c31c:	83 e0 e0             	and    $0xffffffe0,%eax
f010c31f:	a2 ec 14 5a f0       	mov    %al,0xf05a14ec
f010c324:	a0 ec 14 5a f0       	mov    0xf05a14ec,%al
f010c329:	83 e0 1f             	and    $0x1f,%eax
f010c32c:	a2 ec 14 5a f0       	mov    %al,0xf05a14ec
f010c331:	a0 ed 14 5a f0       	mov    0xf05a14ed,%al
f010c336:	83 e0 f0             	and    $0xfffffff0,%eax
f010c339:	83 c8 0e             	or     $0xe,%eax
f010c33c:	a2 ed 14 5a f0       	mov    %al,0xf05a14ed
f010c341:	a0 ed 14 5a f0       	mov    0xf05a14ed,%al
f010c346:	83 e0 ef             	and    $0xffffffef,%eax
f010c349:	a2 ed 14 5a f0       	mov    %al,0xf05a14ed
f010c34e:	a0 ed 14 5a f0       	mov    0xf05a14ed,%al
f010c353:	83 c8 60             	or     $0x60,%eax
f010c356:	a2 ed 14 5a f0       	mov    %al,0xf05a14ed
f010c35b:	a0 ed 14 5a f0       	mov    0xf05a14ed,%al
f010c360:	83 c8 80             	or     $0xffffff80,%eax
f010c363:	a2 ed 14 5a f0       	mov    %al,0xf05a14ed
f010c368:	b8 6c d6 10 f0       	mov    $0xf010d66c,%eax
f010c36d:	c1 e8 10             	shr    $0x10,%eax
f010c370:	66 a3 ee 14 5a f0    	mov    %ax,0xf05a14ee
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010c376:	b8 76 d6 10 f0       	mov    $0xf010d676,%eax
f010c37b:	66 a3 60 15 5a f0    	mov    %ax,0xf05a1560
f010c381:	66 c7 05 62 15 5a f0 	movw   $0x8,0xf05a1562
f010c388:	08 00 
f010c38a:	a0 64 15 5a f0       	mov    0xf05a1564,%al
f010c38f:	83 e0 e0             	and    $0xffffffe0,%eax
f010c392:	a2 64 15 5a f0       	mov    %al,0xf05a1564
f010c397:	a0 64 15 5a f0       	mov    0xf05a1564,%al
f010c39c:	83 e0 1f             	and    $0x1f,%eax
f010c39f:	a2 64 15 5a f0       	mov    %al,0xf05a1564
f010c3a4:	a0 65 15 5a f0       	mov    0xf05a1565,%al
f010c3a9:	83 e0 f0             	and    $0xfffffff0,%eax
f010c3ac:	83 c8 0e             	or     $0xe,%eax
f010c3af:	a2 65 15 5a f0       	mov    %al,0xf05a1565
f010c3b4:	a0 65 15 5a f0       	mov    0xf05a1565,%al
f010c3b9:	83 e0 ef             	and    $0xffffffef,%eax
f010c3bc:	a2 65 15 5a f0       	mov    %al,0xf05a1565
f010c3c1:	a0 65 15 5a f0       	mov    0xf05a1565,%al
f010c3c6:	83 c8 60             	or     $0x60,%eax
f010c3c9:	a2 65 15 5a f0       	mov    %al,0xf05a1565
f010c3ce:	a0 65 15 5a f0       	mov    0xf05a1565,%al
f010c3d3:	83 c8 80             	or     $0xffffff80,%eax
f010c3d6:	a2 65 15 5a f0       	mov    %al,0xf05a1565
f010c3db:	b8 76 d6 10 f0       	mov    $0xf010d676,%eax
f010c3e0:	c1 e8 10             	shr    $0x10,%eax
f010c3e3:	66 a3 66 15 5a f0    	mov    %ax,0xf05a1566

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010c3e9:	b8 80 d6 10 f0       	mov    $0xf010d680,%eax
f010c3ee:	66 a3 e0 13 5a f0    	mov    %ax,0xf05a13e0
f010c3f4:	66 c7 05 e2 13 5a f0 	movw   $0x8,0xf05a13e2
f010c3fb:	08 00 
f010c3fd:	a0 e4 13 5a f0       	mov    0xf05a13e4,%al
f010c402:	83 e0 e0             	and    $0xffffffe0,%eax
f010c405:	a2 e4 13 5a f0       	mov    %al,0xf05a13e4
f010c40a:	a0 e4 13 5a f0       	mov    0xf05a13e4,%al
f010c40f:	83 e0 1f             	and    $0x1f,%eax
f010c412:	a2 e4 13 5a f0       	mov    %al,0xf05a13e4
f010c417:	a0 e5 13 5a f0       	mov    0xf05a13e5,%al
f010c41c:	83 e0 f0             	and    $0xfffffff0,%eax
f010c41f:	83 c8 0e             	or     $0xe,%eax
f010c422:	a2 e5 13 5a f0       	mov    %al,0xf05a13e5
f010c427:	a0 e5 13 5a f0       	mov    0xf05a13e5,%al
f010c42c:	83 e0 ef             	and    $0xffffffef,%eax
f010c42f:	a2 e5 13 5a f0       	mov    %al,0xf05a13e5
f010c434:	a0 e5 13 5a f0       	mov    0xf05a13e5,%al
f010c439:	83 c8 60             	or     $0x60,%eax
f010c43c:	a2 e5 13 5a f0       	mov    %al,0xf05a13e5
f010c441:	a0 e5 13 5a f0       	mov    0xf05a13e5,%al
f010c446:	83 c8 80             	or     $0xffffff80,%eax
f010c449:	a2 e5 13 5a f0       	mov    %al,0xf05a13e5
f010c44e:	b8 80 d6 10 f0       	mov    $0xf010d680,%eax
f010c453:	c1 e8 10             	shr    $0x10,%eax
f010c456:	66 a3 e6 13 5a f0    	mov    %ax,0xf05a13e6
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010c45c:	b8 8a d6 10 f0       	mov    $0xf010d68a,%eax
f010c461:	66 a3 e8 13 5a f0    	mov    %ax,0xf05a13e8
f010c467:	66 c7 05 ea 13 5a f0 	movw   $0x8,0xf05a13ea
f010c46e:	08 00 
f010c470:	a0 ec 13 5a f0       	mov    0xf05a13ec,%al
f010c475:	83 e0 e0             	and    $0xffffffe0,%eax
f010c478:	a2 ec 13 5a f0       	mov    %al,0xf05a13ec
f010c47d:	a0 ec 13 5a f0       	mov    0xf05a13ec,%al
f010c482:	83 e0 1f             	and    $0x1f,%eax
f010c485:	a2 ec 13 5a f0       	mov    %al,0xf05a13ec
f010c48a:	a0 ed 13 5a f0       	mov    0xf05a13ed,%al
f010c48f:	83 c8 0f             	or     $0xf,%eax
f010c492:	a2 ed 13 5a f0       	mov    %al,0xf05a13ed
f010c497:	a0 ed 13 5a f0       	mov    0xf05a13ed,%al
f010c49c:	83 e0 ef             	and    $0xffffffef,%eax
f010c49f:	a2 ed 13 5a f0       	mov    %al,0xf05a13ed
f010c4a4:	a0 ed 13 5a f0       	mov    0xf05a13ed,%al
f010c4a9:	83 c8 60             	or     $0x60,%eax
f010c4ac:	a2 ed 13 5a f0       	mov    %al,0xf05a13ed
f010c4b1:	a0 ed 13 5a f0       	mov    0xf05a13ed,%al
f010c4b6:	83 c8 80             	or     $0xffffff80,%eax
f010c4b9:	a2 ed 13 5a f0       	mov    %al,0xf05a13ed
f010c4be:	b8 8a d6 10 f0       	mov    $0xf010d68a,%eax
f010c4c3:	c1 e8 10             	shr    $0x10,%eax
f010c4c6:	66 a3 ee 13 5a f0    	mov    %ax,0xf05a13ee
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010c4cc:	b8 94 d6 10 f0       	mov    $0xf010d694,%eax
f010c4d1:	66 a3 f0 13 5a f0    	mov    %ax,0xf05a13f0
f010c4d7:	66 c7 05 f2 13 5a f0 	movw   $0x8,0xf05a13f2
f010c4de:	08 00 
f010c4e0:	a0 f4 13 5a f0       	mov    0xf05a13f4,%al
f010c4e5:	83 e0 e0             	and    $0xffffffe0,%eax
f010c4e8:	a2 f4 13 5a f0       	mov    %al,0xf05a13f4
f010c4ed:	a0 f4 13 5a f0       	mov    0xf05a13f4,%al
f010c4f2:	83 e0 1f             	and    $0x1f,%eax
f010c4f5:	a2 f4 13 5a f0       	mov    %al,0xf05a13f4
f010c4fa:	a0 f5 13 5a f0       	mov    0xf05a13f5,%al
f010c4ff:	83 e0 f0             	and    $0xfffffff0,%eax
f010c502:	83 c8 0e             	or     $0xe,%eax
f010c505:	a2 f5 13 5a f0       	mov    %al,0xf05a13f5
f010c50a:	a0 f5 13 5a f0       	mov    0xf05a13f5,%al
f010c50f:	83 e0 ef             	and    $0xffffffef,%eax
f010c512:	a2 f5 13 5a f0       	mov    %al,0xf05a13f5
f010c517:	a0 f5 13 5a f0       	mov    0xf05a13f5,%al
f010c51c:	83 c8 60             	or     $0x60,%eax
f010c51f:	a2 f5 13 5a f0       	mov    %al,0xf05a13f5
f010c524:	a0 f5 13 5a f0       	mov    0xf05a13f5,%al
f010c529:	83 c8 80             	or     $0xffffff80,%eax
f010c52c:	a2 f5 13 5a f0       	mov    %al,0xf05a13f5
f010c531:	b8 94 d6 10 f0       	mov    $0xf010d694,%eax
f010c536:	c1 e8 10             	shr    $0x10,%eax
f010c539:	66 a3 f6 13 5a f0    	mov    %ax,0xf05a13f6
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010c53f:	b8 9e d6 10 f0       	mov    $0xf010d69e,%eax
f010c544:	66 a3 f8 13 5a f0    	mov    %ax,0xf05a13f8
f010c54a:	66 c7 05 fa 13 5a f0 	movw   $0x8,0xf05a13fa
f010c551:	08 00 
f010c553:	a0 fc 13 5a f0       	mov    0xf05a13fc,%al
f010c558:	83 e0 e0             	and    $0xffffffe0,%eax
f010c55b:	a2 fc 13 5a f0       	mov    %al,0xf05a13fc
f010c560:	a0 fc 13 5a f0       	mov    0xf05a13fc,%al
f010c565:	83 e0 1f             	and    $0x1f,%eax
f010c568:	a2 fc 13 5a f0       	mov    %al,0xf05a13fc
f010c56d:	a0 fd 13 5a f0       	mov    0xf05a13fd,%al
f010c572:	83 c8 0f             	or     $0xf,%eax
f010c575:	a2 fd 13 5a f0       	mov    %al,0xf05a13fd
f010c57a:	a0 fd 13 5a f0       	mov    0xf05a13fd,%al
f010c57f:	83 e0 ef             	and    $0xffffffef,%eax
f010c582:	a2 fd 13 5a f0       	mov    %al,0xf05a13fd
f010c587:	a0 fd 13 5a f0       	mov    0xf05a13fd,%al
f010c58c:	83 c8 60             	or     $0x60,%eax
f010c58f:	a2 fd 13 5a f0       	mov    %al,0xf05a13fd
f010c594:	a0 fd 13 5a f0       	mov    0xf05a13fd,%al
f010c599:	83 c8 80             	or     $0xffffff80,%eax
f010c59c:	a2 fd 13 5a f0       	mov    %al,0xf05a13fd
f010c5a1:	b8 9e d6 10 f0       	mov    $0xf010d69e,%eax
f010c5a6:	c1 e8 10             	shr    $0x10,%eax
f010c5a9:	66 a3 fe 13 5a f0    	mov    %ax,0xf05a13fe
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010c5af:	b8 a8 d6 10 f0       	mov    $0xf010d6a8,%eax
f010c5b4:	66 a3 00 14 5a f0    	mov    %ax,0xf05a1400
f010c5ba:	66 c7 05 02 14 5a f0 	movw   $0x8,0xf05a1402
f010c5c1:	08 00 
f010c5c3:	a0 04 14 5a f0       	mov    0xf05a1404,%al
f010c5c8:	83 e0 e0             	and    $0xffffffe0,%eax
f010c5cb:	a2 04 14 5a f0       	mov    %al,0xf05a1404
f010c5d0:	a0 04 14 5a f0       	mov    0xf05a1404,%al
f010c5d5:	83 e0 1f             	and    $0x1f,%eax
f010c5d8:	a2 04 14 5a f0       	mov    %al,0xf05a1404
f010c5dd:	a0 05 14 5a f0       	mov    0xf05a1405,%al
f010c5e2:	83 c8 0f             	or     $0xf,%eax
f010c5e5:	a2 05 14 5a f0       	mov    %al,0xf05a1405
f010c5ea:	a0 05 14 5a f0       	mov    0xf05a1405,%al
f010c5ef:	83 e0 ef             	and    $0xffffffef,%eax
f010c5f2:	a2 05 14 5a f0       	mov    %al,0xf05a1405
f010c5f7:	a0 05 14 5a f0       	mov    0xf05a1405,%al
f010c5fc:	83 c8 60             	or     $0x60,%eax
f010c5ff:	a2 05 14 5a f0       	mov    %al,0xf05a1405
f010c604:	a0 05 14 5a f0       	mov    0xf05a1405,%al
f010c609:	83 c8 80             	or     $0xffffff80,%eax
f010c60c:	a2 05 14 5a f0       	mov    %al,0xf05a1405
f010c611:	b8 a8 d6 10 f0       	mov    $0xf010d6a8,%eax
f010c616:	c1 e8 10             	shr    $0x10,%eax
f010c619:	66 a3 06 14 5a f0    	mov    %ax,0xf05a1406
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010c61f:	b8 b2 d6 10 f0       	mov    $0xf010d6b2,%eax
f010c624:	66 a3 08 14 5a f0    	mov    %ax,0xf05a1408
f010c62a:	66 c7 05 0a 14 5a f0 	movw   $0x8,0xf05a140a
f010c631:	08 00 
f010c633:	a0 0c 14 5a f0       	mov    0xf05a140c,%al
f010c638:	83 e0 e0             	and    $0xffffffe0,%eax
f010c63b:	a2 0c 14 5a f0       	mov    %al,0xf05a140c
f010c640:	a0 0c 14 5a f0       	mov    0xf05a140c,%al
f010c645:	83 e0 1f             	and    $0x1f,%eax
f010c648:	a2 0c 14 5a f0       	mov    %al,0xf05a140c
f010c64d:	a0 0d 14 5a f0       	mov    0xf05a140d,%al
f010c652:	83 e0 f0             	and    $0xfffffff0,%eax
f010c655:	83 c8 0e             	or     $0xe,%eax
f010c658:	a2 0d 14 5a f0       	mov    %al,0xf05a140d
f010c65d:	a0 0d 14 5a f0       	mov    0xf05a140d,%al
f010c662:	83 e0 ef             	and    $0xffffffef,%eax
f010c665:	a2 0d 14 5a f0       	mov    %al,0xf05a140d
f010c66a:	a0 0d 14 5a f0       	mov    0xf05a140d,%al
f010c66f:	83 c8 60             	or     $0x60,%eax
f010c672:	a2 0d 14 5a f0       	mov    %al,0xf05a140d
f010c677:	a0 0d 14 5a f0       	mov    0xf05a140d,%al
f010c67c:	83 c8 80             	or     $0xffffff80,%eax
f010c67f:	a2 0d 14 5a f0       	mov    %al,0xf05a140d
f010c684:	b8 b2 d6 10 f0       	mov    $0xf010d6b2,%eax
f010c689:	c1 e8 10             	shr    $0x10,%eax
f010c68c:	66 a3 0e 14 5a f0    	mov    %ax,0xf05a140e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010c692:	b8 bc d6 10 f0       	mov    $0xf010d6bc,%eax
f010c697:	66 a3 10 14 5a f0    	mov    %ax,0xf05a1410
f010c69d:	66 c7 05 12 14 5a f0 	movw   $0x8,0xf05a1412
f010c6a4:	08 00 
f010c6a6:	a0 14 14 5a f0       	mov    0xf05a1414,%al
f010c6ab:	83 e0 e0             	and    $0xffffffe0,%eax
f010c6ae:	a2 14 14 5a f0       	mov    %al,0xf05a1414
f010c6b3:	a0 14 14 5a f0       	mov    0xf05a1414,%al
f010c6b8:	83 e0 1f             	and    $0x1f,%eax
f010c6bb:	a2 14 14 5a f0       	mov    %al,0xf05a1414
f010c6c0:	a0 15 14 5a f0       	mov    0xf05a1415,%al
f010c6c5:	83 e0 f0             	and    $0xfffffff0,%eax
f010c6c8:	83 c8 0e             	or     $0xe,%eax
f010c6cb:	a2 15 14 5a f0       	mov    %al,0xf05a1415
f010c6d0:	a0 15 14 5a f0       	mov    0xf05a1415,%al
f010c6d5:	83 e0 ef             	and    $0xffffffef,%eax
f010c6d8:	a2 15 14 5a f0       	mov    %al,0xf05a1415
f010c6dd:	a0 15 14 5a f0       	mov    0xf05a1415,%al
f010c6e2:	83 c8 60             	or     $0x60,%eax
f010c6e5:	a2 15 14 5a f0       	mov    %al,0xf05a1415
f010c6ea:	a0 15 14 5a f0       	mov    0xf05a1415,%al
f010c6ef:	83 c8 80             	or     $0xffffff80,%eax
f010c6f2:	a2 15 14 5a f0       	mov    %al,0xf05a1415
f010c6f7:	b8 bc d6 10 f0       	mov    $0xf010d6bc,%eax
f010c6fc:	c1 e8 10             	shr    $0x10,%eax
f010c6ff:	66 a3 16 14 5a f0    	mov    %ax,0xf05a1416
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010c705:	b8 c6 d6 10 f0       	mov    $0xf010d6c6,%eax
f010c70a:	66 a3 18 14 5a f0    	mov    %ax,0xf05a1418
f010c710:	66 c7 05 1a 14 5a f0 	movw   $0x8,0xf05a141a
f010c717:	08 00 
f010c719:	a0 1c 14 5a f0       	mov    0xf05a141c,%al
f010c71e:	83 e0 e0             	and    $0xffffffe0,%eax
f010c721:	a2 1c 14 5a f0       	mov    %al,0xf05a141c
f010c726:	a0 1c 14 5a f0       	mov    0xf05a141c,%al
f010c72b:	83 e0 1f             	and    $0x1f,%eax
f010c72e:	a2 1c 14 5a f0       	mov    %al,0xf05a141c
f010c733:	a0 1d 14 5a f0       	mov    0xf05a141d,%al
f010c738:	83 e0 f0             	and    $0xfffffff0,%eax
f010c73b:	83 c8 0e             	or     $0xe,%eax
f010c73e:	a2 1d 14 5a f0       	mov    %al,0xf05a141d
f010c743:	a0 1d 14 5a f0       	mov    0xf05a141d,%al
f010c748:	83 e0 ef             	and    $0xffffffef,%eax
f010c74b:	a2 1d 14 5a f0       	mov    %al,0xf05a141d
f010c750:	a0 1d 14 5a f0       	mov    0xf05a141d,%al
f010c755:	83 c8 60             	or     $0x60,%eax
f010c758:	a2 1d 14 5a f0       	mov    %al,0xf05a141d
f010c75d:	a0 1d 14 5a f0       	mov    0xf05a141d,%al
f010c762:	83 c8 80             	or     $0xffffff80,%eax
f010c765:	a2 1d 14 5a f0       	mov    %al,0xf05a141d
f010c76a:	b8 c6 d6 10 f0       	mov    $0xf010d6c6,%eax
f010c76f:	c1 e8 10             	shr    $0x10,%eax
f010c772:	66 a3 1e 14 5a f0    	mov    %ax,0xf05a141e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010c778:	b8 cc d6 10 f0       	mov    $0xf010d6cc,%eax
f010c77d:	66 a3 30 14 5a f0    	mov    %ax,0xf05a1430
f010c783:	66 c7 05 32 14 5a f0 	movw   $0x8,0xf05a1432
f010c78a:	08 00 
f010c78c:	a0 34 14 5a f0       	mov    0xf05a1434,%al
f010c791:	83 e0 e0             	and    $0xffffffe0,%eax
f010c794:	a2 34 14 5a f0       	mov    %al,0xf05a1434
f010c799:	a0 34 14 5a f0       	mov    0xf05a1434,%al
f010c79e:	83 e0 1f             	and    $0x1f,%eax
f010c7a1:	a2 34 14 5a f0       	mov    %al,0xf05a1434
f010c7a6:	a0 35 14 5a f0       	mov    0xf05a1435,%al
f010c7ab:	83 e0 f0             	and    $0xfffffff0,%eax
f010c7ae:	83 c8 0e             	or     $0xe,%eax
f010c7b1:	a2 35 14 5a f0       	mov    %al,0xf05a1435
f010c7b6:	a0 35 14 5a f0       	mov    0xf05a1435,%al
f010c7bb:	83 e0 ef             	and    $0xffffffef,%eax
f010c7be:	a2 35 14 5a f0       	mov    %al,0xf05a1435
f010c7c3:	a0 35 14 5a f0       	mov    0xf05a1435,%al
f010c7c8:	83 c8 60             	or     $0x60,%eax
f010c7cb:	a2 35 14 5a f0       	mov    %al,0xf05a1435
f010c7d0:	a0 35 14 5a f0       	mov    0xf05a1435,%al
f010c7d5:	83 c8 80             	or     $0xffffff80,%eax
f010c7d8:	a2 35 14 5a f0       	mov    %al,0xf05a1435
f010c7dd:	b8 cc d6 10 f0       	mov    $0xf010d6cc,%eax
f010c7e2:	c1 e8 10             	shr    $0x10,%eax
f010c7e5:	66 a3 36 14 5a f0    	mov    %ax,0xf05a1436
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010c7eb:	b8 d0 d6 10 f0       	mov    $0xf010d6d0,%eax
f010c7f0:	66 a3 38 14 5a f0    	mov    %ax,0xf05a1438
f010c7f6:	66 c7 05 3a 14 5a f0 	movw   $0x8,0xf05a143a
f010c7fd:	08 00 
f010c7ff:	a0 3c 14 5a f0       	mov    0xf05a143c,%al
f010c804:	83 e0 e0             	and    $0xffffffe0,%eax
f010c807:	a2 3c 14 5a f0       	mov    %al,0xf05a143c
f010c80c:	a0 3c 14 5a f0       	mov    0xf05a143c,%al
f010c811:	83 e0 1f             	and    $0x1f,%eax
f010c814:	a2 3c 14 5a f0       	mov    %al,0xf05a143c
f010c819:	a0 3d 14 5a f0       	mov    0xf05a143d,%al
f010c81e:	83 e0 f0             	and    $0xfffffff0,%eax
f010c821:	83 c8 0e             	or     $0xe,%eax
f010c824:	a2 3d 14 5a f0       	mov    %al,0xf05a143d
f010c829:	a0 3d 14 5a f0       	mov    0xf05a143d,%al
f010c82e:	83 e0 ef             	and    $0xffffffef,%eax
f010c831:	a2 3d 14 5a f0       	mov    %al,0xf05a143d
f010c836:	a0 3d 14 5a f0       	mov    0xf05a143d,%al
f010c83b:	83 c8 60             	or     $0x60,%eax
f010c83e:	a2 3d 14 5a f0       	mov    %al,0xf05a143d
f010c843:	a0 3d 14 5a f0       	mov    0xf05a143d,%al
f010c848:	83 c8 80             	or     $0xffffff80,%eax
f010c84b:	a2 3d 14 5a f0       	mov    %al,0xf05a143d
f010c850:	b8 d0 d6 10 f0       	mov    $0xf010d6d0,%eax
f010c855:	c1 e8 10             	shr    $0x10,%eax
f010c858:	66 a3 3e 14 5a f0    	mov    %ax,0xf05a143e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010c85e:	b8 d4 d6 10 f0       	mov    $0xf010d6d4,%eax
f010c863:	66 a3 40 14 5a f0    	mov    %ax,0xf05a1440
f010c869:	66 c7 05 42 14 5a f0 	movw   $0x8,0xf05a1442
f010c870:	08 00 
f010c872:	a0 44 14 5a f0       	mov    0xf05a1444,%al
f010c877:	83 e0 e0             	and    $0xffffffe0,%eax
f010c87a:	a2 44 14 5a f0       	mov    %al,0xf05a1444
f010c87f:	a0 44 14 5a f0       	mov    0xf05a1444,%al
f010c884:	83 e0 1f             	and    $0x1f,%eax
f010c887:	a2 44 14 5a f0       	mov    %al,0xf05a1444
f010c88c:	a0 45 14 5a f0       	mov    0xf05a1445,%al
f010c891:	83 e0 f0             	and    $0xfffffff0,%eax
f010c894:	83 c8 0e             	or     $0xe,%eax
f010c897:	a2 45 14 5a f0       	mov    %al,0xf05a1445
f010c89c:	a0 45 14 5a f0       	mov    0xf05a1445,%al
f010c8a1:	83 e0 ef             	and    $0xffffffef,%eax
f010c8a4:	a2 45 14 5a f0       	mov    %al,0xf05a1445
f010c8a9:	a0 45 14 5a f0       	mov    0xf05a1445,%al
f010c8ae:	83 c8 60             	or     $0x60,%eax
f010c8b1:	a2 45 14 5a f0       	mov    %al,0xf05a1445
f010c8b6:	a0 45 14 5a f0       	mov    0xf05a1445,%al
f010c8bb:	83 c8 80             	or     $0xffffff80,%eax
f010c8be:	a2 45 14 5a f0       	mov    %al,0xf05a1445
f010c8c3:	b8 d4 d6 10 f0       	mov    $0xf010d6d4,%eax
f010c8c8:	c1 e8 10             	shr    $0x10,%eax
f010c8cb:	66 a3 46 14 5a f0    	mov    %ax,0xf05a1446
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010c8d1:	b8 d8 d6 10 f0       	mov    $0xf010d6d8,%eax
f010c8d6:	66 a3 48 14 5a f0    	mov    %ax,0xf05a1448
f010c8dc:	66 c7 05 4a 14 5a f0 	movw   $0x8,0xf05a144a
f010c8e3:	08 00 
f010c8e5:	a0 4c 14 5a f0       	mov    0xf05a144c,%al
f010c8ea:	83 e0 e0             	and    $0xffffffe0,%eax
f010c8ed:	a2 4c 14 5a f0       	mov    %al,0xf05a144c
f010c8f2:	a0 4c 14 5a f0       	mov    0xf05a144c,%al
f010c8f7:	83 e0 1f             	and    $0x1f,%eax
f010c8fa:	a2 4c 14 5a f0       	mov    %al,0xf05a144c
f010c8ff:	a0 4d 14 5a f0       	mov    0xf05a144d,%al
f010c904:	83 e0 f0             	and    $0xfffffff0,%eax
f010c907:	83 c8 0e             	or     $0xe,%eax
f010c90a:	a2 4d 14 5a f0       	mov    %al,0xf05a144d
f010c90f:	a0 4d 14 5a f0       	mov    0xf05a144d,%al
f010c914:	83 e0 ef             	and    $0xffffffef,%eax
f010c917:	a2 4d 14 5a f0       	mov    %al,0xf05a144d
f010c91c:	a0 4d 14 5a f0       	mov    0xf05a144d,%al
f010c921:	83 c8 60             	or     $0x60,%eax
f010c924:	a2 4d 14 5a f0       	mov    %al,0xf05a144d
f010c929:	a0 4d 14 5a f0       	mov    0xf05a144d,%al
f010c92e:	83 c8 80             	or     $0xffffff80,%eax
f010c931:	a2 4d 14 5a f0       	mov    %al,0xf05a144d
f010c936:	b8 d8 d6 10 f0       	mov    $0xf010d6d8,%eax
f010c93b:	c1 e8 10             	shr    $0x10,%eax
f010c93e:	66 a3 4e 14 5a f0    	mov    %ax,0xf05a144e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010c944:	b8 dc d6 10 f0       	mov    $0xf010d6dc,%eax
f010c949:	66 a3 60 14 5a f0    	mov    %ax,0xf05a1460
f010c94f:	66 c7 05 62 14 5a f0 	movw   $0x8,0xf05a1462
f010c956:	08 00 
f010c958:	a0 64 14 5a f0       	mov    0xf05a1464,%al
f010c95d:	83 e0 e0             	and    $0xffffffe0,%eax
f010c960:	a2 64 14 5a f0       	mov    %al,0xf05a1464
f010c965:	a0 64 14 5a f0       	mov    0xf05a1464,%al
f010c96a:	83 e0 1f             	and    $0x1f,%eax
f010c96d:	a2 64 14 5a f0       	mov    %al,0xf05a1464
f010c972:	a0 65 14 5a f0       	mov    0xf05a1465,%al
f010c977:	83 e0 f0             	and    $0xfffffff0,%eax
f010c97a:	83 c8 0e             	or     $0xe,%eax
f010c97d:	a2 65 14 5a f0       	mov    %al,0xf05a1465
f010c982:	a0 65 14 5a f0       	mov    0xf05a1465,%al
f010c987:	83 e0 ef             	and    $0xffffffef,%eax
f010c98a:	a2 65 14 5a f0       	mov    %al,0xf05a1465
f010c98f:	a0 65 14 5a f0       	mov    0xf05a1465,%al
f010c994:	83 c8 60             	or     $0x60,%eax
f010c997:	a2 65 14 5a f0       	mov    %al,0xf05a1465
f010c99c:	a0 65 14 5a f0       	mov    0xf05a1465,%al
f010c9a1:	83 c8 80             	or     $0xffffff80,%eax
f010c9a4:	a2 65 14 5a f0       	mov    %al,0xf05a1465
f010c9a9:	b8 dc d6 10 f0       	mov    $0xf010d6dc,%eax
f010c9ae:	c1 e8 10             	shr    $0x10,%eax
f010c9b1:	66 a3 66 14 5a f0    	mov    %ax,0xf05a1466
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010c9b7:	b8 e2 d6 10 f0       	mov    $0xf010d6e2,%eax
f010c9bc:	66 a3 68 14 5a f0    	mov    %ax,0xf05a1468
f010c9c2:	66 c7 05 6a 14 5a f0 	movw   $0x8,0xf05a146a
f010c9c9:	08 00 
f010c9cb:	a0 6c 14 5a f0       	mov    0xf05a146c,%al
f010c9d0:	83 e0 e0             	and    $0xffffffe0,%eax
f010c9d3:	a2 6c 14 5a f0       	mov    %al,0xf05a146c
f010c9d8:	a0 6c 14 5a f0       	mov    0xf05a146c,%al
f010c9dd:	83 e0 1f             	and    $0x1f,%eax
f010c9e0:	a2 6c 14 5a f0       	mov    %al,0xf05a146c
f010c9e5:	a0 6d 14 5a f0       	mov    0xf05a146d,%al
f010c9ea:	83 e0 f0             	and    $0xfffffff0,%eax
f010c9ed:	83 c8 0e             	or     $0xe,%eax
f010c9f0:	a2 6d 14 5a f0       	mov    %al,0xf05a146d
f010c9f5:	a0 6d 14 5a f0       	mov    0xf05a146d,%al
f010c9fa:	83 e0 ef             	and    $0xffffffef,%eax
f010c9fd:	a2 6d 14 5a f0       	mov    %al,0xf05a146d
f010ca02:	a0 6d 14 5a f0       	mov    0xf05a146d,%al
f010ca07:	83 c8 60             	or     $0x60,%eax
f010ca0a:	a2 6d 14 5a f0       	mov    %al,0xf05a146d
f010ca0f:	a0 6d 14 5a f0       	mov    0xf05a146d,%al
f010ca14:	83 c8 80             	or     $0xffffff80,%eax
f010ca17:	a2 6d 14 5a f0       	mov    %al,0xf05a146d
f010ca1c:	b8 e2 d6 10 f0       	mov    $0xf010d6e2,%eax
f010ca21:	c1 e8 10             	shr    $0x10,%eax
f010ca24:	66 a3 6e 14 5a f0    	mov    %ax,0xf05a146e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010ca2a:	b8 e6 d6 10 f0       	mov    $0xf010d6e6,%eax
f010ca2f:	66 a3 70 14 5a f0    	mov    %ax,0xf05a1470
f010ca35:	66 c7 05 72 14 5a f0 	movw   $0x8,0xf05a1472
f010ca3c:	08 00 
f010ca3e:	a0 74 14 5a f0       	mov    0xf05a1474,%al
f010ca43:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca46:	a2 74 14 5a f0       	mov    %al,0xf05a1474
f010ca4b:	a0 74 14 5a f0       	mov    0xf05a1474,%al
f010ca50:	83 e0 1f             	and    $0x1f,%eax
f010ca53:	a2 74 14 5a f0       	mov    %al,0xf05a1474
f010ca58:	a0 75 14 5a f0       	mov    0xf05a1475,%al
f010ca5d:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca60:	83 c8 0e             	or     $0xe,%eax
f010ca63:	a2 75 14 5a f0       	mov    %al,0xf05a1475
f010ca68:	a0 75 14 5a f0       	mov    0xf05a1475,%al
f010ca6d:	83 e0 ef             	and    $0xffffffef,%eax
f010ca70:	a2 75 14 5a f0       	mov    %al,0xf05a1475
f010ca75:	a0 75 14 5a f0       	mov    0xf05a1475,%al
f010ca7a:	83 c8 60             	or     $0x60,%eax
f010ca7d:	a2 75 14 5a f0       	mov    %al,0xf05a1475
f010ca82:	a0 75 14 5a f0       	mov    0xf05a1475,%al
f010ca87:	83 c8 80             	or     $0xffffff80,%eax
f010ca8a:	a2 75 14 5a f0       	mov    %al,0xf05a1475
f010ca8f:	b8 e6 d6 10 f0       	mov    $0xf010d6e6,%eax
f010ca94:	c1 e8 10             	shr    $0x10,%eax
f010ca97:	66 a3 76 14 5a f0    	mov    %ax,0xf05a1476
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010ca9d:	b8 ec d6 10 f0       	mov    $0xf010d6ec,%eax
f010caa2:	66 a3 78 14 5a f0    	mov    %ax,0xf05a1478
f010caa8:	66 c7 05 7a 14 5a f0 	movw   $0x8,0xf05a147a
f010caaf:	08 00 
f010cab1:	a0 7c 14 5a f0       	mov    0xf05a147c,%al
f010cab6:	83 e0 e0             	and    $0xffffffe0,%eax
f010cab9:	a2 7c 14 5a f0       	mov    %al,0xf05a147c
f010cabe:	a0 7c 14 5a f0       	mov    0xf05a147c,%al
f010cac3:	83 e0 1f             	and    $0x1f,%eax
f010cac6:	a2 7c 14 5a f0       	mov    %al,0xf05a147c
f010cacb:	a0 7d 14 5a f0       	mov    0xf05a147d,%al
f010cad0:	83 e0 f0             	and    $0xfffffff0,%eax
f010cad3:	83 c8 0e             	or     $0xe,%eax
f010cad6:	a2 7d 14 5a f0       	mov    %al,0xf05a147d
f010cadb:	a0 7d 14 5a f0       	mov    0xf05a147d,%al
f010cae0:	83 e0 ef             	and    $0xffffffef,%eax
f010cae3:	a2 7d 14 5a f0       	mov    %al,0xf05a147d
f010cae8:	a0 7d 14 5a f0       	mov    0xf05a147d,%al
f010caed:	83 c8 60             	or     $0x60,%eax
f010caf0:	a2 7d 14 5a f0       	mov    %al,0xf05a147d
f010caf5:	a0 7d 14 5a f0       	mov    0xf05a147d,%al
f010cafa:	83 c8 80             	or     $0xffffff80,%eax
f010cafd:	a2 7d 14 5a f0       	mov    %al,0xf05a147d
f010cb02:	b8 ec d6 10 f0       	mov    $0xf010d6ec,%eax
f010cb07:	c1 e8 10             	shr    $0x10,%eax
f010cb0a:	66 a3 7e 14 5a f0    	mov    %ax,0xf05a147e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010cb10:	b8 f2 d6 10 f0       	mov    $0xf010d6f2,%eax
f010cb15:	66 a3 f0 14 5a f0    	mov    %ax,0xf05a14f0
f010cb1b:	66 c7 05 f2 14 5a f0 	movw   $0x8,0xf05a14f2
f010cb22:	08 00 
f010cb24:	a0 f4 14 5a f0       	mov    0xf05a14f4,%al
f010cb29:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb2c:	a2 f4 14 5a f0       	mov    %al,0xf05a14f4
f010cb31:	a0 f4 14 5a f0       	mov    0xf05a14f4,%al
f010cb36:	83 e0 1f             	and    $0x1f,%eax
f010cb39:	a2 f4 14 5a f0       	mov    %al,0xf05a14f4
f010cb3e:	a0 f5 14 5a f0       	mov    0xf05a14f5,%al
f010cb43:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb46:	83 c8 0e             	or     $0xe,%eax
f010cb49:	a2 f5 14 5a f0       	mov    %al,0xf05a14f5
f010cb4e:	a0 f5 14 5a f0       	mov    0xf05a14f5,%al
f010cb53:	83 e0 ef             	and    $0xffffffef,%eax
f010cb56:	a2 f5 14 5a f0       	mov    %al,0xf05a14f5
f010cb5b:	a0 f5 14 5a f0       	mov    0xf05a14f5,%al
f010cb60:	83 c8 60             	or     $0x60,%eax
f010cb63:	a2 f5 14 5a f0       	mov    %al,0xf05a14f5
f010cb68:	a0 f5 14 5a f0       	mov    0xf05a14f5,%al
f010cb6d:	83 c8 80             	or     $0xffffff80,%eax
f010cb70:	a2 f5 14 5a f0       	mov    %al,0xf05a14f5
f010cb75:	b8 f2 d6 10 f0       	mov    $0xf010d6f2,%eax
f010cb7a:	c1 e8 10             	shr    $0x10,%eax
f010cb7d:	66 a3 f6 14 5a f0    	mov    %ax,0xf05a14f6
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010cb83:	b8 f8 d6 10 f0       	mov    $0xf010d6f8,%eax
f010cb88:	66 a3 f8 14 5a f0    	mov    %ax,0xf05a14f8
f010cb8e:	66 c7 05 fa 14 5a f0 	movw   $0x8,0xf05a14fa
f010cb95:	08 00 
f010cb97:	a0 fc 14 5a f0       	mov    0xf05a14fc,%al
f010cb9c:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb9f:	a2 fc 14 5a f0       	mov    %al,0xf05a14fc
f010cba4:	a0 fc 14 5a f0       	mov    0xf05a14fc,%al
f010cba9:	83 e0 1f             	and    $0x1f,%eax
f010cbac:	a2 fc 14 5a f0       	mov    %al,0xf05a14fc
f010cbb1:	a0 fd 14 5a f0       	mov    0xf05a14fd,%al
f010cbb6:	83 e0 f0             	and    $0xfffffff0,%eax
f010cbb9:	83 c8 0e             	or     $0xe,%eax
f010cbbc:	a2 fd 14 5a f0       	mov    %al,0xf05a14fd
f010cbc1:	a0 fd 14 5a f0       	mov    0xf05a14fd,%al
f010cbc6:	83 e0 ef             	and    $0xffffffef,%eax
f010cbc9:	a2 fd 14 5a f0       	mov    %al,0xf05a14fd
f010cbce:	a0 fd 14 5a f0       	mov    0xf05a14fd,%al
f010cbd3:	83 c8 60             	or     $0x60,%eax
f010cbd6:	a2 fd 14 5a f0       	mov    %al,0xf05a14fd
f010cbdb:	a0 fd 14 5a f0       	mov    0xf05a14fd,%al
f010cbe0:	83 c8 80             	or     $0xffffff80,%eax
f010cbe3:	a2 fd 14 5a f0       	mov    %al,0xf05a14fd
f010cbe8:	b8 f8 d6 10 f0       	mov    $0xf010d6f8,%eax
f010cbed:	c1 e8 10             	shr    $0x10,%eax
f010cbf0:	66 a3 fe 14 5a f0    	mov    %ax,0xf05a14fe
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010cbf6:	b8 fe d6 10 f0       	mov    $0xf010d6fe,%eax
f010cbfb:	66 a3 00 15 5a f0    	mov    %ax,0xf05a1500
f010cc01:	66 c7 05 02 15 5a f0 	movw   $0x8,0xf05a1502
f010cc08:	08 00 
f010cc0a:	a0 04 15 5a f0       	mov    0xf05a1504,%al
f010cc0f:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc12:	a2 04 15 5a f0       	mov    %al,0xf05a1504
f010cc17:	a0 04 15 5a f0       	mov    0xf05a1504,%al
f010cc1c:	83 e0 1f             	and    $0x1f,%eax
f010cc1f:	a2 04 15 5a f0       	mov    %al,0xf05a1504
f010cc24:	a0 05 15 5a f0       	mov    0xf05a1505,%al
f010cc29:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc2c:	83 c8 0e             	or     $0xe,%eax
f010cc2f:	a2 05 15 5a f0       	mov    %al,0xf05a1505
f010cc34:	a0 05 15 5a f0       	mov    0xf05a1505,%al
f010cc39:	83 e0 ef             	and    $0xffffffef,%eax
f010cc3c:	a2 05 15 5a f0       	mov    %al,0xf05a1505
f010cc41:	a0 05 15 5a f0       	mov    0xf05a1505,%al
f010cc46:	83 c8 60             	or     $0x60,%eax
f010cc49:	a2 05 15 5a f0       	mov    %al,0xf05a1505
f010cc4e:	a0 05 15 5a f0       	mov    0xf05a1505,%al
f010cc53:	83 c8 80             	or     $0xffffff80,%eax
f010cc56:	a2 05 15 5a f0       	mov    %al,0xf05a1505
f010cc5b:	b8 fe d6 10 f0       	mov    $0xf010d6fe,%eax
f010cc60:	c1 e8 10             	shr    $0x10,%eax
f010cc63:	66 a3 06 15 5a f0    	mov    %ax,0xf05a1506
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010cc69:	b8 04 d7 10 f0       	mov    $0xf010d704,%eax
f010cc6e:	66 a3 08 15 5a f0    	mov    %ax,0xf05a1508
f010cc74:	66 c7 05 0a 15 5a f0 	movw   $0x8,0xf05a150a
f010cc7b:	08 00 
f010cc7d:	a0 0c 15 5a f0       	mov    0xf05a150c,%al
f010cc82:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc85:	a2 0c 15 5a f0       	mov    %al,0xf05a150c
f010cc8a:	a0 0c 15 5a f0       	mov    0xf05a150c,%al
f010cc8f:	83 e0 1f             	and    $0x1f,%eax
f010cc92:	a2 0c 15 5a f0       	mov    %al,0xf05a150c
f010cc97:	a0 0d 15 5a f0       	mov    0xf05a150d,%al
f010cc9c:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc9f:	83 c8 0e             	or     $0xe,%eax
f010cca2:	a2 0d 15 5a f0       	mov    %al,0xf05a150d
f010cca7:	a0 0d 15 5a f0       	mov    0xf05a150d,%al
f010ccac:	83 e0 ef             	and    $0xffffffef,%eax
f010ccaf:	a2 0d 15 5a f0       	mov    %al,0xf05a150d
f010ccb4:	a0 0d 15 5a f0       	mov    0xf05a150d,%al
f010ccb9:	83 c8 60             	or     $0x60,%eax
f010ccbc:	a2 0d 15 5a f0       	mov    %al,0xf05a150d
f010ccc1:	a0 0d 15 5a f0       	mov    0xf05a150d,%al
f010ccc6:	83 c8 80             	or     $0xffffff80,%eax
f010ccc9:	a2 0d 15 5a f0       	mov    %al,0xf05a150d
f010ccce:	b8 04 d7 10 f0       	mov    $0xf010d704,%eax
f010ccd3:	c1 e8 10             	shr    $0x10,%eax
f010ccd6:	66 a3 0e 15 5a f0    	mov    %ax,0xf05a150e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010ccdc:	b8 0a d7 10 f0       	mov    $0xf010d70a,%eax
f010cce1:	66 a3 10 15 5a f0    	mov    %ax,0xf05a1510
f010cce7:	66 c7 05 12 15 5a f0 	movw   $0x8,0xf05a1512
f010ccee:	08 00 
f010ccf0:	a0 14 15 5a f0       	mov    0xf05a1514,%al
f010ccf5:	83 e0 e0             	and    $0xffffffe0,%eax
f010ccf8:	a2 14 15 5a f0       	mov    %al,0xf05a1514
f010ccfd:	a0 14 15 5a f0       	mov    0xf05a1514,%al
f010cd02:	83 e0 1f             	and    $0x1f,%eax
f010cd05:	a2 14 15 5a f0       	mov    %al,0xf05a1514
f010cd0a:	a0 15 15 5a f0       	mov    0xf05a1515,%al
f010cd0f:	83 e0 f0             	and    $0xfffffff0,%eax
f010cd12:	83 c8 0e             	or     $0xe,%eax
f010cd15:	a2 15 15 5a f0       	mov    %al,0xf05a1515
f010cd1a:	a0 15 15 5a f0       	mov    0xf05a1515,%al
f010cd1f:	83 e0 ef             	and    $0xffffffef,%eax
f010cd22:	a2 15 15 5a f0       	mov    %al,0xf05a1515
f010cd27:	a0 15 15 5a f0       	mov    0xf05a1515,%al
f010cd2c:	83 c8 60             	or     $0x60,%eax
f010cd2f:	a2 15 15 5a f0       	mov    %al,0xf05a1515
f010cd34:	a0 15 15 5a f0       	mov    0xf05a1515,%al
f010cd39:	83 c8 80             	or     $0xffffff80,%eax
f010cd3c:	a2 15 15 5a f0       	mov    %al,0xf05a1515
f010cd41:	b8 0a d7 10 f0       	mov    $0xf010d70a,%eax
f010cd46:	c1 e8 10             	shr    $0x10,%eax
f010cd49:	66 a3 16 15 5a f0    	mov    %ax,0xf05a1516
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010cd4f:	b8 10 d7 10 f0       	mov    $0xf010d710,%eax
f010cd54:	66 a3 18 15 5a f0    	mov    %ax,0xf05a1518
f010cd5a:	66 c7 05 1a 15 5a f0 	movw   $0x8,0xf05a151a
f010cd61:	08 00 
f010cd63:	a0 1c 15 5a f0       	mov    0xf05a151c,%al
f010cd68:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd6b:	a2 1c 15 5a f0       	mov    %al,0xf05a151c
f010cd70:	a0 1c 15 5a f0       	mov    0xf05a151c,%al
f010cd75:	83 e0 1f             	and    $0x1f,%eax
f010cd78:	a2 1c 15 5a f0       	mov    %al,0xf05a151c
f010cd7d:	a0 1d 15 5a f0       	mov    0xf05a151d,%al
f010cd82:	83 e0 f0             	and    $0xfffffff0,%eax
f010cd85:	83 c8 0e             	or     $0xe,%eax
f010cd88:	a2 1d 15 5a f0       	mov    %al,0xf05a151d
f010cd8d:	a0 1d 15 5a f0       	mov    0xf05a151d,%al
f010cd92:	83 e0 ef             	and    $0xffffffef,%eax
f010cd95:	a2 1d 15 5a f0       	mov    %al,0xf05a151d
f010cd9a:	a0 1d 15 5a f0       	mov    0xf05a151d,%al
f010cd9f:	83 c8 60             	or     $0x60,%eax
f010cda2:	a2 1d 15 5a f0       	mov    %al,0xf05a151d
f010cda7:	a0 1d 15 5a f0       	mov    0xf05a151d,%al
f010cdac:	83 c8 80             	or     $0xffffff80,%eax
f010cdaf:	a2 1d 15 5a f0       	mov    %al,0xf05a151d
f010cdb4:	b8 10 d7 10 f0       	mov    $0xf010d710,%eax
f010cdb9:	c1 e8 10             	shr    $0x10,%eax
f010cdbc:	66 a3 1e 15 5a f0    	mov    %ax,0xf05a151e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010cdc2:	b8 16 d7 10 f0       	mov    $0xf010d716,%eax
f010cdc7:	66 a3 20 15 5a f0    	mov    %ax,0xf05a1520
f010cdcd:	66 c7 05 22 15 5a f0 	movw   $0x8,0xf05a1522
f010cdd4:	08 00 
f010cdd6:	a0 24 15 5a f0       	mov    0xf05a1524,%al
f010cddb:	83 e0 e0             	and    $0xffffffe0,%eax
f010cdde:	a2 24 15 5a f0       	mov    %al,0xf05a1524
f010cde3:	a0 24 15 5a f0       	mov    0xf05a1524,%al
f010cde8:	83 e0 1f             	and    $0x1f,%eax
f010cdeb:	a2 24 15 5a f0       	mov    %al,0xf05a1524
f010cdf0:	a0 25 15 5a f0       	mov    0xf05a1525,%al
f010cdf5:	83 e0 f0             	and    $0xfffffff0,%eax
f010cdf8:	83 c8 0e             	or     $0xe,%eax
f010cdfb:	a2 25 15 5a f0       	mov    %al,0xf05a1525
f010ce00:	a0 25 15 5a f0       	mov    0xf05a1525,%al
f010ce05:	83 e0 ef             	and    $0xffffffef,%eax
f010ce08:	a2 25 15 5a f0       	mov    %al,0xf05a1525
f010ce0d:	a0 25 15 5a f0       	mov    0xf05a1525,%al
f010ce12:	83 c8 60             	or     $0x60,%eax
f010ce15:	a2 25 15 5a f0       	mov    %al,0xf05a1525
f010ce1a:	a0 25 15 5a f0       	mov    0xf05a1525,%al
f010ce1f:	83 c8 80             	or     $0xffffff80,%eax
f010ce22:	a2 25 15 5a f0       	mov    %al,0xf05a1525
f010ce27:	b8 16 d7 10 f0       	mov    $0xf010d716,%eax
f010ce2c:	c1 e8 10             	shr    $0x10,%eax
f010ce2f:	66 a3 26 15 5a f0    	mov    %ax,0xf05a1526
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010ce35:	b8 1c d7 10 f0       	mov    $0xf010d71c,%eax
f010ce3a:	66 a3 28 15 5a f0    	mov    %ax,0xf05a1528
f010ce40:	66 c7 05 2a 15 5a f0 	movw   $0x8,0xf05a152a
f010ce47:	08 00 
f010ce49:	a0 2c 15 5a f0       	mov    0xf05a152c,%al
f010ce4e:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce51:	a2 2c 15 5a f0       	mov    %al,0xf05a152c
f010ce56:	a0 2c 15 5a f0       	mov    0xf05a152c,%al
f010ce5b:	83 e0 1f             	and    $0x1f,%eax
f010ce5e:	a2 2c 15 5a f0       	mov    %al,0xf05a152c
f010ce63:	a0 2d 15 5a f0       	mov    0xf05a152d,%al
f010ce68:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce6b:	83 c8 0e             	or     $0xe,%eax
f010ce6e:	a2 2d 15 5a f0       	mov    %al,0xf05a152d
f010ce73:	a0 2d 15 5a f0       	mov    0xf05a152d,%al
f010ce78:	83 e0 ef             	and    $0xffffffef,%eax
f010ce7b:	a2 2d 15 5a f0       	mov    %al,0xf05a152d
f010ce80:	a0 2d 15 5a f0       	mov    0xf05a152d,%al
f010ce85:	83 c8 60             	or     $0x60,%eax
f010ce88:	a2 2d 15 5a f0       	mov    %al,0xf05a152d
f010ce8d:	a0 2d 15 5a f0       	mov    0xf05a152d,%al
f010ce92:	83 c8 80             	or     $0xffffff80,%eax
f010ce95:	a2 2d 15 5a f0       	mov    %al,0xf05a152d
f010ce9a:	b8 1c d7 10 f0       	mov    $0xf010d71c,%eax
f010ce9f:	c1 e8 10             	shr    $0x10,%eax
f010cea2:	66 a3 2e 15 5a f0    	mov    %ax,0xf05a152e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010cea8:	b8 22 d7 10 f0       	mov    $0xf010d722,%eax
f010cead:	66 a3 30 15 5a f0    	mov    %ax,0xf05a1530
f010ceb3:	66 c7 05 32 15 5a f0 	movw   $0x8,0xf05a1532
f010ceba:	08 00 
f010cebc:	a0 34 15 5a f0       	mov    0xf05a1534,%al
f010cec1:	83 e0 e0             	and    $0xffffffe0,%eax
f010cec4:	a2 34 15 5a f0       	mov    %al,0xf05a1534
f010cec9:	a0 34 15 5a f0       	mov    0xf05a1534,%al
f010cece:	83 e0 1f             	and    $0x1f,%eax
f010ced1:	a2 34 15 5a f0       	mov    %al,0xf05a1534
f010ced6:	a0 35 15 5a f0       	mov    0xf05a1535,%al
f010cedb:	83 e0 f0             	and    $0xfffffff0,%eax
f010cede:	83 c8 0e             	or     $0xe,%eax
f010cee1:	a2 35 15 5a f0       	mov    %al,0xf05a1535
f010cee6:	a0 35 15 5a f0       	mov    0xf05a1535,%al
f010ceeb:	83 e0 ef             	and    $0xffffffef,%eax
f010ceee:	a2 35 15 5a f0       	mov    %al,0xf05a1535
f010cef3:	a0 35 15 5a f0       	mov    0xf05a1535,%al
f010cef8:	83 c8 60             	or     $0x60,%eax
f010cefb:	a2 35 15 5a f0       	mov    %al,0xf05a1535
f010cf00:	a0 35 15 5a f0       	mov    0xf05a1535,%al
f010cf05:	83 c8 80             	or     $0xffffff80,%eax
f010cf08:	a2 35 15 5a f0       	mov    %al,0xf05a1535
f010cf0d:	b8 22 d7 10 f0       	mov    $0xf010d722,%eax
f010cf12:	c1 e8 10             	shr    $0x10,%eax
f010cf15:	66 a3 36 15 5a f0    	mov    %ax,0xf05a1536
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010cf1b:	b8 28 d7 10 f0       	mov    $0xf010d728,%eax
f010cf20:	66 a3 38 15 5a f0    	mov    %ax,0xf05a1538
f010cf26:	66 c7 05 3a 15 5a f0 	movw   $0x8,0xf05a153a
f010cf2d:	08 00 
f010cf2f:	a0 3c 15 5a f0       	mov    0xf05a153c,%al
f010cf34:	83 e0 e0             	and    $0xffffffe0,%eax
f010cf37:	a2 3c 15 5a f0       	mov    %al,0xf05a153c
f010cf3c:	a0 3c 15 5a f0       	mov    0xf05a153c,%al
f010cf41:	83 e0 1f             	and    $0x1f,%eax
f010cf44:	a2 3c 15 5a f0       	mov    %al,0xf05a153c
f010cf49:	a0 3d 15 5a f0       	mov    0xf05a153d,%al
f010cf4e:	83 e0 f0             	and    $0xfffffff0,%eax
f010cf51:	83 c8 0e             	or     $0xe,%eax
f010cf54:	a2 3d 15 5a f0       	mov    %al,0xf05a153d
f010cf59:	a0 3d 15 5a f0       	mov    0xf05a153d,%al
f010cf5e:	83 e0 ef             	and    $0xffffffef,%eax
f010cf61:	a2 3d 15 5a f0       	mov    %al,0xf05a153d
f010cf66:	a0 3d 15 5a f0       	mov    0xf05a153d,%al
f010cf6b:	83 c8 60             	or     $0x60,%eax
f010cf6e:	a2 3d 15 5a f0       	mov    %al,0xf05a153d
f010cf73:	a0 3d 15 5a f0       	mov    0xf05a153d,%al
f010cf78:	83 c8 80             	or     $0xffffff80,%eax
f010cf7b:	a2 3d 15 5a f0       	mov    %al,0xf05a153d
f010cf80:	b8 28 d7 10 f0       	mov    $0xf010d728,%eax
f010cf85:	c1 e8 10             	shr    $0x10,%eax
f010cf88:	66 a3 3e 15 5a f0    	mov    %ax,0xf05a153e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010cf8e:	b8 2e d7 10 f0       	mov    $0xf010d72e,%eax
f010cf93:	66 a3 40 15 5a f0    	mov    %ax,0xf05a1540
f010cf99:	66 c7 05 42 15 5a f0 	movw   $0x8,0xf05a1542
f010cfa0:	08 00 
f010cfa2:	a0 44 15 5a f0       	mov    0xf05a1544,%al
f010cfa7:	83 e0 e0             	and    $0xffffffe0,%eax
f010cfaa:	a2 44 15 5a f0       	mov    %al,0xf05a1544
f010cfaf:	a0 44 15 5a f0       	mov    0xf05a1544,%al
f010cfb4:	83 e0 1f             	and    $0x1f,%eax
f010cfb7:	a2 44 15 5a f0       	mov    %al,0xf05a1544
f010cfbc:	a0 45 15 5a f0       	mov    0xf05a1545,%al
f010cfc1:	83 e0 f0             	and    $0xfffffff0,%eax
f010cfc4:	83 c8 0e             	or     $0xe,%eax
f010cfc7:	a2 45 15 5a f0       	mov    %al,0xf05a1545
f010cfcc:	a0 45 15 5a f0       	mov    0xf05a1545,%al
f010cfd1:	83 e0 ef             	and    $0xffffffef,%eax
f010cfd4:	a2 45 15 5a f0       	mov    %al,0xf05a1545
f010cfd9:	a0 45 15 5a f0       	mov    0xf05a1545,%al
f010cfde:	83 c8 60             	or     $0x60,%eax
f010cfe1:	a2 45 15 5a f0       	mov    %al,0xf05a1545
f010cfe6:	a0 45 15 5a f0       	mov    0xf05a1545,%al
f010cfeb:	83 c8 80             	or     $0xffffff80,%eax
f010cfee:	a2 45 15 5a f0       	mov    %al,0xf05a1545
f010cff3:	b8 2e d7 10 f0       	mov    $0xf010d72e,%eax
f010cff8:	c1 e8 10             	shr    $0x10,%eax
f010cffb:	66 a3 46 15 5a f0    	mov    %ax,0xf05a1546
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010d001:	b8 34 d7 10 f0       	mov    $0xf010d734,%eax
f010d006:	66 a3 48 15 5a f0    	mov    %ax,0xf05a1548
f010d00c:	66 c7 05 4a 15 5a f0 	movw   $0x8,0xf05a154a
f010d013:	08 00 
f010d015:	a0 4c 15 5a f0       	mov    0xf05a154c,%al
f010d01a:	83 e0 e0             	and    $0xffffffe0,%eax
f010d01d:	a2 4c 15 5a f0       	mov    %al,0xf05a154c
f010d022:	a0 4c 15 5a f0       	mov    0xf05a154c,%al
f010d027:	83 e0 1f             	and    $0x1f,%eax
f010d02a:	a2 4c 15 5a f0       	mov    %al,0xf05a154c
f010d02f:	a0 4d 15 5a f0       	mov    0xf05a154d,%al
f010d034:	83 e0 f0             	and    $0xfffffff0,%eax
f010d037:	83 c8 0e             	or     $0xe,%eax
f010d03a:	a2 4d 15 5a f0       	mov    %al,0xf05a154d
f010d03f:	a0 4d 15 5a f0       	mov    0xf05a154d,%al
f010d044:	83 e0 ef             	and    $0xffffffef,%eax
f010d047:	a2 4d 15 5a f0       	mov    %al,0xf05a154d
f010d04c:	a0 4d 15 5a f0       	mov    0xf05a154d,%al
f010d051:	83 c8 60             	or     $0x60,%eax
f010d054:	a2 4d 15 5a f0       	mov    %al,0xf05a154d
f010d059:	a0 4d 15 5a f0       	mov    0xf05a154d,%al
f010d05e:	83 c8 80             	or     $0xffffff80,%eax
f010d061:	a2 4d 15 5a f0       	mov    %al,0xf05a154d
f010d066:	b8 34 d7 10 f0       	mov    $0xf010d734,%eax
f010d06b:	c1 e8 10             	shr    $0x10,%eax
f010d06e:	66 a3 4e 15 5a f0    	mov    %ax,0xf05a154e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010d074:	b8 3a d7 10 f0       	mov    $0xf010d73a,%eax
f010d079:	66 a3 50 15 5a f0    	mov    %ax,0xf05a1550
f010d07f:	66 c7 05 52 15 5a f0 	movw   $0x8,0xf05a1552
f010d086:	08 00 
f010d088:	a0 54 15 5a f0       	mov    0xf05a1554,%al
f010d08d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d090:	a2 54 15 5a f0       	mov    %al,0xf05a1554
f010d095:	a0 54 15 5a f0       	mov    0xf05a1554,%al
f010d09a:	83 e0 1f             	and    $0x1f,%eax
f010d09d:	a2 54 15 5a f0       	mov    %al,0xf05a1554
f010d0a2:	a0 55 15 5a f0       	mov    0xf05a1555,%al
f010d0a7:	83 e0 f0             	and    $0xfffffff0,%eax
f010d0aa:	83 c8 0e             	or     $0xe,%eax
f010d0ad:	a2 55 15 5a f0       	mov    %al,0xf05a1555
f010d0b2:	a0 55 15 5a f0       	mov    0xf05a1555,%al
f010d0b7:	83 e0 ef             	and    $0xffffffef,%eax
f010d0ba:	a2 55 15 5a f0       	mov    %al,0xf05a1555
f010d0bf:	a0 55 15 5a f0       	mov    0xf05a1555,%al
f010d0c4:	83 c8 60             	or     $0x60,%eax
f010d0c7:	a2 55 15 5a f0       	mov    %al,0xf05a1555
f010d0cc:	a0 55 15 5a f0       	mov    0xf05a1555,%al
f010d0d1:	83 c8 80             	or     $0xffffff80,%eax
f010d0d4:	a2 55 15 5a f0       	mov    %al,0xf05a1555
f010d0d9:	b8 3a d7 10 f0       	mov    $0xf010d73a,%eax
f010d0de:	c1 e8 10             	shr    $0x10,%eax
f010d0e1:	66 a3 56 15 5a f0    	mov    %ax,0xf05a1556
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010d0e7:	b8 40 d7 10 f0       	mov    $0xf010d740,%eax
f010d0ec:	66 a3 58 15 5a f0    	mov    %ax,0xf05a1558
f010d0f2:	66 c7 05 5a 15 5a f0 	movw   $0x8,0xf05a155a
f010d0f9:	08 00 
f010d0fb:	a0 5c 15 5a f0       	mov    0xf05a155c,%al
f010d100:	83 e0 e0             	and    $0xffffffe0,%eax
f010d103:	a2 5c 15 5a f0       	mov    %al,0xf05a155c
f010d108:	a0 5c 15 5a f0       	mov    0xf05a155c,%al
f010d10d:	83 e0 1f             	and    $0x1f,%eax
f010d110:	a2 5c 15 5a f0       	mov    %al,0xf05a155c
f010d115:	a0 5d 15 5a f0       	mov    0xf05a155d,%al
f010d11a:	83 e0 f0             	and    $0xfffffff0,%eax
f010d11d:	83 c8 0e             	or     $0xe,%eax
f010d120:	a2 5d 15 5a f0       	mov    %al,0xf05a155d
f010d125:	a0 5d 15 5a f0       	mov    0xf05a155d,%al
f010d12a:	83 e0 ef             	and    $0xffffffef,%eax
f010d12d:	a2 5d 15 5a f0       	mov    %al,0xf05a155d
f010d132:	a0 5d 15 5a f0       	mov    0xf05a155d,%al
f010d137:	83 c8 60             	or     $0x60,%eax
f010d13a:	a2 5d 15 5a f0       	mov    %al,0xf05a155d
f010d13f:	a0 5d 15 5a f0       	mov    0xf05a155d,%al
f010d144:	83 c8 80             	or     $0xffffff80,%eax
f010d147:	a2 5d 15 5a f0       	mov    %al,0xf05a155d
f010d14c:	b8 40 d7 10 f0       	mov    $0xf010d740,%eax
f010d151:	c1 e8 10             	shr    $0x10,%eax
f010d154:	66 a3 5e 15 5a f0    	mov    %ax,0xf05a155e
f010d15a:	c7 45 fc e0 13 5a f0 	movl   $0xf05a13e0,-0x4(%ebp)
f010d161:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010d168:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010d16b:	48                   	dec    %eax
f010d16c:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010d170:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010d173:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010d177:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010d17a:	c1 e8 10             	shr    $0x10,%eax
f010d17d:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010d181:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010d184:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010d187:	90                   	nop
f010d188:	c9                   	leave  
f010d189:	c3                   	ret    

f010d18a <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010d18a:	55                   	push   %ebp
f010d18b:	89 e5                	mov    %esp,%ebp
f010d18d:	53                   	push   %ebx
f010d18e:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010d191:	83 ec 08             	sub    $0x8,%esp
f010d194:	ff 75 08             	pushl  0x8(%ebp)
f010d197:	68 7e 96 12 f0       	push   $0xf012967e
f010d19c:	e8 cb 3d ff ff       	call   f0100f6c <cprintf>
f010d1a1:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010d1a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1a7:	83 ec 0c             	sub    $0xc,%esp
f010d1aa:	50                   	push   %eax
f010d1ab:	e8 fd 00 00 00       	call   f010d2ad <print_regs>
f010d1b0:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010d1b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1b6:	8b 40 20             	mov    0x20(%eax),%eax
f010d1b9:	0f b7 c0             	movzwl %ax,%eax
f010d1bc:	83 ec 08             	sub    $0x8,%esp
f010d1bf:	50                   	push   %eax
f010d1c0:	68 90 96 12 f0       	push   $0xf0129690
f010d1c5:	e8 a2 3d ff ff       	call   f0100f6c <cprintf>
f010d1ca:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010d1cd:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1d0:	8b 40 24             	mov    0x24(%eax),%eax
f010d1d3:	0f b7 c0             	movzwl %ax,%eax
f010d1d6:	83 ec 08             	sub    $0x8,%esp
f010d1d9:	50                   	push   %eax
f010d1da:	68 a3 96 12 f0       	push   $0xf01296a3
f010d1df:	e8 88 3d ff ff       	call   f0100f6c <cprintf>
f010d1e4:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010d1e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1ea:	8b 58 28             	mov    0x28(%eax),%ebx
f010d1ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1f0:	8b 40 28             	mov    0x28(%eax),%eax
f010d1f3:	83 ec 0c             	sub    $0xc,%esp
f010d1f6:	50                   	push   %eax
f010d1f7:	e8 28 ee ff ff       	call   f010c024 <trapname>
f010d1fc:	83 c4 10             	add    $0x10,%esp
f010d1ff:	89 c2                	mov    %eax,%edx
f010d201:	8b 45 08             	mov    0x8(%ebp),%eax
f010d204:	8b 40 28             	mov    0x28(%eax),%eax
f010d207:	53                   	push   %ebx
f010d208:	52                   	push   %edx
f010d209:	50                   	push   %eax
f010d20a:	68 b6 96 12 f0       	push   $0xf01296b6
f010d20f:	e8 58 3d ff ff       	call   f0100f6c <cprintf>
f010d214:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010d217:	8b 45 08             	mov    0x8(%ebp),%eax
f010d21a:	8b 40 2c             	mov    0x2c(%eax),%eax
f010d21d:	83 ec 08             	sub    $0x8,%esp
f010d220:	50                   	push   %eax
f010d221:	68 cd 96 12 f0       	push   $0xf01296cd
f010d226:	e8 41 3d ff ff       	call   f0100f6c <cprintf>
f010d22b:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010d22e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d231:	8b 40 30             	mov    0x30(%eax),%eax
f010d234:	83 ec 08             	sub    $0x8,%esp
f010d237:	50                   	push   %eax
f010d238:	68 dc 96 12 f0       	push   $0xf01296dc
f010d23d:	e8 2a 3d ff ff       	call   f0100f6c <cprintf>
f010d242:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010d245:	8b 45 08             	mov    0x8(%ebp),%eax
f010d248:	8b 40 34             	mov    0x34(%eax),%eax
f010d24b:	0f b7 c0             	movzwl %ax,%eax
f010d24e:	83 ec 08             	sub    $0x8,%esp
f010d251:	50                   	push   %eax
f010d252:	68 eb 96 12 f0       	push   $0xf01296eb
f010d257:	e8 10 3d ff ff       	call   f0100f6c <cprintf>
f010d25c:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010d25f:	8b 45 08             	mov    0x8(%ebp),%eax
f010d262:	8b 40 38             	mov    0x38(%eax),%eax
f010d265:	83 ec 08             	sub    $0x8,%esp
f010d268:	50                   	push   %eax
f010d269:	68 fe 96 12 f0       	push   $0xf01296fe
f010d26e:	e8 f9 3c ff ff       	call   f0100f6c <cprintf>
f010d273:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010d276:	8b 45 08             	mov    0x8(%ebp),%eax
f010d279:	8b 40 3c             	mov    0x3c(%eax),%eax
f010d27c:	83 ec 08             	sub    $0x8,%esp
f010d27f:	50                   	push   %eax
f010d280:	68 0d 97 12 f0       	push   $0xf012970d
f010d285:	e8 e2 3c ff ff       	call   f0100f6c <cprintf>
f010d28a:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010d28d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d290:	8b 40 40             	mov    0x40(%eax),%eax
f010d293:	0f b7 c0             	movzwl %ax,%eax
f010d296:	83 ec 08             	sub    $0x8,%esp
f010d299:	50                   	push   %eax
f010d29a:	68 1c 97 12 f0       	push   $0xf012971c
f010d29f:	e8 c8 3c ff ff       	call   f0100f6c <cprintf>
f010d2a4:	83 c4 10             	add    $0x10,%esp
}
f010d2a7:	90                   	nop
f010d2a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010d2ab:	c9                   	leave  
f010d2ac:	c3                   	ret    

f010d2ad <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010d2ad:	55                   	push   %ebp
f010d2ae:	89 e5                	mov    %esp,%ebp
f010d2b0:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010d2b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2b6:	8b 00                	mov    (%eax),%eax
f010d2b8:	83 ec 08             	sub    $0x8,%esp
f010d2bb:	50                   	push   %eax
f010d2bc:	68 2f 97 12 f0       	push   $0xf012972f
f010d2c1:	e8 a6 3c ff ff       	call   f0100f6c <cprintf>
f010d2c6:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010d2c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2cc:	8b 40 04             	mov    0x4(%eax),%eax
f010d2cf:	83 ec 08             	sub    $0x8,%esp
f010d2d2:	50                   	push   %eax
f010d2d3:	68 3e 97 12 f0       	push   $0xf012973e
f010d2d8:	e8 8f 3c ff ff       	call   f0100f6c <cprintf>
f010d2dd:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010d2e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2e3:	8b 40 08             	mov    0x8(%eax),%eax
f010d2e6:	83 ec 08             	sub    $0x8,%esp
f010d2e9:	50                   	push   %eax
f010d2ea:	68 4d 97 12 f0       	push   $0xf012974d
f010d2ef:	e8 78 3c ff ff       	call   f0100f6c <cprintf>
f010d2f4:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010d2f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2fa:	8b 40 0c             	mov    0xc(%eax),%eax
f010d2fd:	83 ec 08             	sub    $0x8,%esp
f010d300:	50                   	push   %eax
f010d301:	68 5c 97 12 f0       	push   $0xf012975c
f010d306:	e8 61 3c ff ff       	call   f0100f6c <cprintf>
f010d30b:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010d30e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d311:	8b 40 10             	mov    0x10(%eax),%eax
f010d314:	83 ec 08             	sub    $0x8,%esp
f010d317:	50                   	push   %eax
f010d318:	68 6b 97 12 f0       	push   $0xf012976b
f010d31d:	e8 4a 3c ff ff       	call   f0100f6c <cprintf>
f010d322:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010d325:	8b 45 08             	mov    0x8(%ebp),%eax
f010d328:	8b 40 14             	mov    0x14(%eax),%eax
f010d32b:	83 ec 08             	sub    $0x8,%esp
f010d32e:	50                   	push   %eax
f010d32f:	68 7a 97 12 f0       	push   $0xf012977a
f010d334:	e8 33 3c ff ff       	call   f0100f6c <cprintf>
f010d339:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010d33c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d33f:	8b 40 18             	mov    0x18(%eax),%eax
f010d342:	83 ec 08             	sub    $0x8,%esp
f010d345:	50                   	push   %eax
f010d346:	68 89 97 12 f0       	push   $0xf0129789
f010d34b:	e8 1c 3c ff ff       	call   f0100f6c <cprintf>
f010d350:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010d353:	8b 45 08             	mov    0x8(%ebp),%eax
f010d356:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d359:	83 ec 08             	sub    $0x8,%esp
f010d35c:	50                   	push   %eax
f010d35d:	68 98 97 12 f0       	push   $0xf0129798
f010d362:	e8 05 3c ff ff       	call   f0100f6c <cprintf>
f010d367:	83 c4 10             	add    $0x10,%esp
}
f010d36a:	90                   	nop
f010d36b:	c9                   	leave  
f010d36c:	c3                   	ret    

f010d36d <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010d36d:	55                   	push   %ebp
f010d36e:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010d370:	8b 45 08             	mov    0x8(%ebp),%eax
f010d373:	8b 55 0c             	mov    0xc(%ebp),%edx
f010d376:	89 14 85 e0 1b 5a f0 	mov    %edx,-0xfa5e420(,%eax,4)
}
f010d37d:	90                   	nop
f010d37e:	5d                   	pop    %ebp
f010d37f:	c3                   	ret    

f010d380 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010d380:	55                   	push   %ebp
f010d381:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010d383:	8b 45 08             	mov    0x8(%ebp),%eax
f010d386:	c7 04 85 e0 1b 5a f0 	movl   $0x0,-0xfa5e420(,%eax,4)
f010d38d:	00 00 00 00 
}
f010d391:	90                   	nop
f010d392:	5d                   	pop    %ebp
f010d393:	c3                   	ret    

f010d394 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010d394:	55                   	push   %ebp
f010d395:	89 e5                	mov    %esp,%ebp
f010d397:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010d39a:	8b 45 08             	mov    0x8(%ebp),%eax
f010d39d:	8b 40 28             	mov    0x28(%eax),%eax
f010d3a0:	83 e8 20             	sub    $0x20,%eax
f010d3a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010d3a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3a9:	8b 04 85 e0 1b 5a f0 	mov    -0xfa5e420(,%eax,4),%eax
f010d3b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010d3b3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d3b7:	74 0e                	je     f010d3c7 <irq_dispatch+0x33>
	{
		handler(tf);
f010d3b9:	83 ec 0c             	sub    $0xc,%esp
f010d3bc:	ff 75 08             	pushl  0x8(%ebp)
f010d3bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d3c2:	ff d0                	call   *%eax
f010d3c4:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010d3c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3ca:	0f b6 c0             	movzbl %al,%eax
f010d3cd:	83 ec 0c             	sub    $0xc,%esp
f010d3d0:	50                   	push   %eax
f010d3d1:	e8 c3 9c ff ff       	call   f0107099 <pic_sendEOI>
f010d3d6:	83 c4 10             	add    $0x10,%esp
}
f010d3d9:	90                   	nop
f010d3da:	c9                   	leave  
f010d3db:	c3                   	ret    

f010d3dc <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010d3dc:	55                   	push   %ebp
f010d3dd:	89 e5                	mov    %esp,%ebp
f010d3df:	57                   	push   %edi
f010d3e0:	56                   	push   %esi
f010d3e1:	53                   	push   %ebx
f010d3e2:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010d3e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010d3e8:	8b 40 28             	mov    0x28(%eax),%eax
f010d3eb:	83 f8 0e             	cmp    $0xe,%eax
f010d3ee:	75 51                	jne    f010d441 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010d3f0:	a0 20 1c 5a f0       	mov    0xf05a1c20,%al
f010d3f5:	84 c0                	test   %al,%al
f010d3f7:	74 1f                	je     f010d418 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010d3f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d3fc:	8b 40 30             	mov    0x30(%eax),%eax
f010d3ff:	89 c2                	mov    %eax,%edx
f010d401:	a0 20 1c 5a f0       	mov    0xf05a1c20,%al
f010d406:	0f b6 c0             	movzbl %al,%eax
f010d409:	01 d0                	add    %edx,%eax
f010d40b:	89 c2                	mov    %eax,%edx
f010d40d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d410:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010d413:	e9 0c 01 00 00       	jmp    f010d524 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010d418:	83 ec 0c             	sub    $0xc,%esp
f010d41b:	6a 01                	push   $0x1
f010d41d:	e8 c2 12 00 00       	call   f010e6e4 <isPageReplacmentAlgorithmLRU>
f010d422:	83 c4 10             	add    $0x10,%esp
f010d425:	85 c0                	test   %eax,%eax
f010d427:	74 05                	je     f010d42e <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010d429:	e8 de 97 ff ff       	call   f0106c0c <update_WS_time_stamps>
		}
		fault_handler(tf);
f010d42e:	83 ec 0c             	sub    $0xc,%esp
f010d431:	ff 75 08             	pushl  0x8(%ebp)
f010d434:	e8 90 13 00 00       	call   f010e7c9 <fault_handler>
f010d439:	83 c4 10             	add    $0x10,%esp
f010d43c:	e9 e3 00 00 00       	jmp    f010d524 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010d441:	8b 45 08             	mov    0x8(%ebp),%eax
f010d444:	8b 40 28             	mov    0x28(%eax),%eax
f010d447:	83 f8 30             	cmp    $0x30,%eax
f010d44a:	75 6e                	jne    f010d4ba <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010d44c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d44f:	8b 40 38             	mov    0x38(%eax),%eax
f010d452:	25 00 02 00 00       	and    $0x200,%eax
f010d457:	85 c0                	test   %eax,%eax
f010d459:	74 06                	je     f010d461 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010d45b:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010d45c:	e8 24 78 ff ff       	call   f0104c85 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010d461:	8b 45 08             	mov    0x8(%ebp),%eax
f010d464:	8b 78 04             	mov    0x4(%eax),%edi
f010d467:	8b 45 08             	mov    0x8(%ebp),%eax
f010d46a:	8b 30                	mov    (%eax),%esi
f010d46c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d46f:	8b 58 10             	mov    0x10(%eax),%ebx
f010d472:	8b 45 08             	mov    0x8(%ebp),%eax
f010d475:	8b 48 18             	mov    0x18(%eax),%ecx
f010d478:	8b 45 08             	mov    0x8(%ebp),%eax
f010d47b:	8b 50 14             	mov    0x14(%eax),%edx
f010d47e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d481:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d484:	83 ec 08             	sub    $0x8,%esp
f010d487:	57                   	push   %edi
f010d488:	56                   	push   %esi
f010d489:	53                   	push   %ebx
f010d48a:	51                   	push   %ecx
f010d48b:	52                   	push   %edx
f010d48c:	50                   	push   %eax
f010d48d:	e8 79 09 00 00       	call   f010de0b <syscall>
f010d492:	83 c4 20             	add    $0x20,%esp
f010d495:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010d498:	8b 45 08             	mov    0x8(%ebp),%eax
f010d49b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010d49e:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d4a1:	9c                   	pushf  
f010d4a2:	58                   	pop    %eax
f010d4a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010d4a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010d4a9:	25 00 02 00 00       	and    $0x200,%eax
f010d4ae:	85 c0                	test   %eax,%eax
f010d4b0:	74 72                	je     f010d524 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010d4b2:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010d4b3:	e8 a5 77 ff ff       	call   f0104c5d <kclock_stop>
f010d4b8:	eb 6a                	jmp    f010d524 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010d4ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4bd:	8b 40 28             	mov    0x28(%eax),%eax
f010d4c0:	83 f8 08             	cmp    $0x8,%eax
f010d4c3:	75 17                	jne    f010d4dc <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010d4c5:	83 ec 04             	sub    $0x4,%esp
f010d4c8:	68 a7 97 12 f0       	push   $0xf01297a7
f010d4cd:	68 22 01 00 00       	push   $0x122
f010d4d2:	68 b6 97 12 f0       	push   $0xf01297b6
f010d4d7:	e8 3e 2e ff ff       	call   f010031a <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010d4dc:	83 ec 0c             	sub    $0xc,%esp
f010d4df:	ff 75 08             	pushl  0x8(%ebp)
f010d4e2:	e8 a3 fc ff ff       	call   f010d18a <print_trapframe>
f010d4e7:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010d4ea:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4ed:	8b 40 34             	mov    0x34(%eax),%eax
f010d4f0:	66 83 f8 08          	cmp    $0x8,%ax
f010d4f4:	75 17                	jne    f010d50d <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010d4f6:	83 ec 04             	sub    $0x4,%esp
f010d4f9:	68 c7 97 12 f0       	push   $0xf01297c7
f010d4fe:	68 2a 01 00 00       	push   $0x12a
f010d503:	68 b6 97 12 f0       	push   $0xf01297b6
f010d508:	e8 0d 2e ff ff       	call   f010031a <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010d50d:	83 ec 04             	sub    $0x4,%esp
f010d510:	68 e0 97 12 f0       	push   $0xf01297e0
f010d515:	68 2f 01 00 00       	push   $0x12f
f010d51a:	68 b6 97 12 f0       	push   $0xf01297b6
f010d51f:	e8 f6 2d ff ff       	call   f010031a <_panic>
		}
	}
}
f010d524:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010d527:	5b                   	pop    %ebx
f010d528:	5e                   	pop    %esi
f010d529:	5f                   	pop    %edi
f010d52a:	5d                   	pop    %ebp
f010d52b:	c3                   	ret    

f010d52c <trap>:

void trap(struct Trapframe *tf)
{
f010d52c:	55                   	push   %ebp
f010d52d:	89 e5                	mov    %esp,%ebp
f010d52f:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010d532:	e8 26 77 ff ff       	call   f0104c5d <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d537:	9c                   	pushf  
f010d538:	58                   	pop    %eax
f010d539:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010d53c:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010d53f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010d542:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d545:	25 00 02 00 00       	and    $0x200,%eax
f010d54a:	85 c0                	test   %eax,%eax
f010d54c:	74 25                	je     f010d573 <trap+0x47>
	{
		print_trapframe(tf);
f010d54e:	83 ec 0c             	sub    $0xc,%esp
f010d551:	ff 75 08             	pushl  0x8(%ebp)
f010d554:	e8 31 fc ff ff       	call   f010d18a <print_trapframe>
f010d559:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010d55c:	83 ec 04             	sub    $0x4,%esp
f010d55f:	68 00 98 12 f0       	push   $0xf0129800
f010d564:	68 45 01 00 00       	push   $0x145
f010d569:	68 b6 97 12 f0       	push   $0xf01297b6
f010d56e:	e8 a7 2d ff ff       	call   f010031a <_panic>
	}

	int userTrap = 0;
f010d573:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010d57a:	e8 c6 d1 ff ff       	call   f010a745 <get_cpu_proc>
f010d57f:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010d582:	8b 45 08             	mov    0x8(%ebp),%eax
f010d585:	8b 40 34             	mov    0x34(%eax),%eax
f010d588:	0f b7 c0             	movzwl %ax,%eax
f010d58b:	83 e0 03             	and    $0x3,%eax
f010d58e:	83 f8 03             	cmp    $0x3,%eax
f010d591:	75 54                	jne    f010d5e7 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010d593:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010d597:	74 0b                	je     f010d5a4 <trap+0x78>
f010d599:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d59c:	8b 40 18             	mov    0x18(%eax),%eax
f010d59f:	83 f8 02             	cmp    $0x2,%eax
f010d5a2:	74 19                	je     f010d5bd <trap+0x91>
f010d5a4:	68 44 98 12 f0       	push   $0xf0129844
f010d5a9:	68 72 98 12 f0       	push   $0xf0129872
f010d5ae:	68 4d 01 00 00       	push   $0x14d
f010d5b3:	68 b6 97 12 f0       	push   $0xf01297b6
f010d5b8:	e8 5d 2d ff ff       	call   f010031a <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010d5bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d5c0:	8b 00                	mov    (%eax),%eax
f010d5c2:	3b 45 08             	cmp    0x8(%ebp),%eax
f010d5c5:	74 19                	je     f010d5e0 <trap+0xb4>
f010d5c7:	68 87 98 12 f0       	push   $0xf0129887
f010d5cc:	68 72 98 12 f0       	push   $0xf0129872
f010d5d1:	68 4f 01 00 00       	push   $0x14f
f010d5d6:	68 b6 97 12 f0       	push   $0xf01297b6
f010d5db:	e8 3a 2d ff ff       	call   f010031a <_panic>
		userTrap = 1;
f010d5e0:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010d5e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010d5ea:	8b 40 28             	mov    0x28(%eax),%eax
f010d5ed:	83 f8 1f             	cmp    $0x1f,%eax
f010d5f0:	76 1b                	jbe    f010d60d <trap+0xe1>
f010d5f2:	8b 45 08             	mov    0x8(%ebp),%eax
f010d5f5:	8b 40 28             	mov    0x28(%eax),%eax
f010d5f8:	83 f8 2f             	cmp    $0x2f,%eax
f010d5fb:	77 10                	ja     f010d60d <trap+0xe1>
	{
		irq_dispatch(tf);
f010d5fd:	83 ec 0c             	sub    $0xc,%esp
f010d600:	ff 75 08             	pushl  0x8(%ebp)
f010d603:	e8 8c fd ff ff       	call   f010d394 <irq_dispatch>
f010d608:	83 c4 10             	add    $0x10,%esp
f010d60b:	eb 0e                	jmp    f010d61b <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010d60d:	83 ec 0c             	sub    $0xc,%esp
f010d610:	ff 75 08             	pushl  0x8(%ebp)
f010d613:	e8 c4 fd ff ff       	call   f010d3dc <trap_dispatch>
f010d618:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d61b:	9c                   	pushf  
f010d61c:	58                   	pop    %eax
f010d61d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010d620:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010d623:	25 00 02 00 00       	and    $0x200,%eax
f010d628:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010d62b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010d62f:	74 19                	je     f010d64a <trap+0x11e>
f010d631:	68 9d 98 12 f0       	push   $0xf012989d
f010d636:	68 72 98 12 f0       	push   $0xf0129872
f010d63b:	68 66 01 00 00       	push   $0x166
f010d640:	68 b6 97 12 f0       	push   $0xf01297b6
f010d645:	e8 d0 2c ff ff       	call   f010031a <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010d64a:	e8 36 76 ff ff       	call   f0104c85 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010d64f:	90                   	nop
f010d650:	c9                   	leave  
f010d651:	c3                   	ret    

f010d652 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010d652:	6a 08                	push   $0x8
f010d654:	e9 ed 00 00 00       	jmp    f010d746 <_alltraps>
f010d659:	90                   	nop

f010d65a <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010d65a:	6a 0e                	push   $0xe
f010d65c:	e9 e5 00 00 00       	jmp    f010d746 <_alltraps>
f010d661:	90                   	nop

f010d662 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010d662:	6a 00                	push   $0x0
f010d664:	6a 20                	push   $0x20
f010d666:	e9 db 00 00 00       	jmp    f010d746 <_alltraps>
f010d66b:	90                   	nop

f010d66c <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010d66c:	6a 00                	push   $0x0
f010d66e:	6a 21                	push   $0x21
f010d670:	e9 d1 00 00 00       	jmp    f010d746 <_alltraps>
f010d675:	90                   	nop

f010d676 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010d676:	6a 00                	push   $0x0
f010d678:	6a 30                	push   $0x30
f010d67a:	e9 c7 00 00 00       	jmp    f010d746 <_alltraps>
f010d67f:	90                   	nop

f010d680 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010d680:	6a 00                	push   $0x0
f010d682:	6a 00                	push   $0x0
f010d684:	e9 bd 00 00 00       	jmp    f010d746 <_alltraps>
f010d689:	90                   	nop

f010d68a <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010d68a:	6a 00                	push   $0x0
f010d68c:	6a 01                	push   $0x1
f010d68e:	e9 b3 00 00 00       	jmp    f010d746 <_alltraps>
f010d693:	90                   	nop

f010d694 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010d694:	6a 00                	push   $0x0
f010d696:	6a 02                	push   $0x2
f010d698:	e9 a9 00 00 00       	jmp    f010d746 <_alltraps>
f010d69d:	90                   	nop

f010d69e <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010d69e:	6a 00                	push   $0x0
f010d6a0:	6a 03                	push   $0x3
f010d6a2:	e9 9f 00 00 00       	jmp    f010d746 <_alltraps>
f010d6a7:	90                   	nop

f010d6a8 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010d6a8:	6a 00                	push   $0x0
f010d6aa:	6a 04                	push   $0x4
f010d6ac:	e9 95 00 00 00       	jmp    f010d746 <_alltraps>
f010d6b1:	90                   	nop

f010d6b2 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010d6b2:	6a 00                	push   $0x0
f010d6b4:	6a 05                	push   $0x5
f010d6b6:	e9 8b 00 00 00       	jmp    f010d746 <_alltraps>
f010d6bb:	90                   	nop

f010d6bc <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010d6bc:	6a 00                	push   $0x0
f010d6be:	6a 06                	push   $0x6
f010d6c0:	e9 81 00 00 00       	jmp    f010d746 <_alltraps>
f010d6c5:	90                   	nop

f010d6c6 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010d6c6:	6a 00                	push   $0x0
f010d6c8:	6a 07                	push   $0x7
f010d6ca:	eb 7a                	jmp    f010d746 <_alltraps>

f010d6cc <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010d6cc:	6a 0a                	push   $0xa
f010d6ce:	eb 76                	jmp    f010d746 <_alltraps>

f010d6d0 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010d6d0:	6a 0b                	push   $0xb
f010d6d2:	eb 72                	jmp    f010d746 <_alltraps>

f010d6d4 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010d6d4:	6a 0c                	push   $0xc
f010d6d6:	eb 6e                	jmp    f010d746 <_alltraps>

f010d6d8 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010d6d8:	6a 0d                	push   $0xd
f010d6da:	eb 6a                	jmp    f010d746 <_alltraps>

f010d6dc <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010d6dc:	6a 00                	push   $0x0
f010d6de:	6a 10                	push   $0x10
f010d6e0:	eb 64                	jmp    f010d746 <_alltraps>

f010d6e2 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010d6e2:	6a 11                	push   $0x11
f010d6e4:	eb 60                	jmp    f010d746 <_alltraps>

f010d6e6 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010d6e6:	6a 00                	push   $0x0
f010d6e8:	6a 12                	push   $0x12
f010d6ea:	eb 5a                	jmp    f010d746 <_alltraps>

f010d6ec <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010d6ec:	6a 00                	push   $0x0
f010d6ee:	6a 13                	push   $0x13
f010d6f0:	eb 54                	jmp    f010d746 <_alltraps>

f010d6f2 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010d6f2:	6a 00                	push   $0x0
f010d6f4:	6a 22                	push   $0x22
f010d6f6:	eb 4e                	jmp    f010d746 <_alltraps>

f010d6f8 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010d6f8:	6a 00                	push   $0x0
f010d6fa:	6a 23                	push   $0x23
f010d6fc:	eb 48                	jmp    f010d746 <_alltraps>

f010d6fe <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010d6fe:	6a 00                	push   $0x0
f010d700:	6a 24                	push   $0x24
f010d702:	eb 42                	jmp    f010d746 <_alltraps>

f010d704 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010d704:	6a 00                	push   $0x0
f010d706:	6a 25                	push   $0x25
f010d708:	eb 3c                	jmp    f010d746 <_alltraps>

f010d70a <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010d70a:	6a 00                	push   $0x0
f010d70c:	6a 26                	push   $0x26
f010d70e:	eb 36                	jmp    f010d746 <_alltraps>

f010d710 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010d710:	6a 00                	push   $0x0
f010d712:	6a 27                	push   $0x27
f010d714:	eb 30                	jmp    f010d746 <_alltraps>

f010d716 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010d716:	6a 00                	push   $0x0
f010d718:	6a 28                	push   $0x28
f010d71a:	eb 2a                	jmp    f010d746 <_alltraps>

f010d71c <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010d71c:	6a 00                	push   $0x0
f010d71e:	6a 29                	push   $0x29
f010d720:	eb 24                	jmp    f010d746 <_alltraps>

f010d722 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010d722:	6a 00                	push   $0x0
f010d724:	6a 2a                	push   $0x2a
f010d726:	eb 1e                	jmp    f010d746 <_alltraps>

f010d728 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010d728:	6a 00                	push   $0x0
f010d72a:	6a 2b                	push   $0x2b
f010d72c:	eb 18                	jmp    f010d746 <_alltraps>

f010d72e <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010d72e:	6a 00                	push   $0x0
f010d730:	6a 2c                	push   $0x2c
f010d732:	eb 12                	jmp    f010d746 <_alltraps>

f010d734 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010d734:	6a 00                	push   $0x0
f010d736:	6a 2d                	push   $0x2d
f010d738:	eb 0c                	jmp    f010d746 <_alltraps>

f010d73a <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010d73a:	6a 00                	push   $0x0
f010d73c:	6a 2e                	push   $0x2e
f010d73e:	eb 06                	jmp    f010d746 <_alltraps>

f010d740 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010d740:	6a 00                	push   $0x0
f010d742:	6a 2f                	push   $0x2f
f010d744:	eb 00                	jmp    f010d746 <_alltraps>

f010d746 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010d746:	1e                   	push   %ds
push 	%es
f010d747:	06                   	push   %es
pushal
f010d748:	60                   	pusha  

mov 	$(GD_KD), %ax
f010d749:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010d74d:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010d74f:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010d751:	54                   	push   %esp
call 	trap
f010d752:	e8 d5 fd ff ff       	call   f010d52c <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010d757:	59                   	pop    %ecx

f010d758 <trapret>:
.globl trapret
trapret:
popal
f010d758:	61                   	popa   
pop 	%es
f010d759:	07                   	pop    %es
pop 	%ds
f010d75a:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010d75b:	83 c4 08             	add    $0x8,%esp
iret
f010d75e:	cf                   	iret   

f010d75f <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010d75f:	55                   	push   %ebp
f010d760:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010d762:	8b 45 08             	mov    0x8(%ebp),%eax
f010d765:	8b 15 c0 48 5a f0    	mov    0xf05a48c0,%edx
f010d76b:	29 d0                	sub    %edx,%eax
f010d76d:	c1 f8 03             	sar    $0x3,%eax
f010d770:	89 c2                	mov    %eax,%edx
f010d772:	89 d0                	mov    %edx,%eax
f010d774:	c1 e0 02             	shl    $0x2,%eax
f010d777:	01 d0                	add    %edx,%eax
f010d779:	c1 e0 02             	shl    $0x2,%eax
f010d77c:	01 d0                	add    %edx,%eax
f010d77e:	c1 e0 02             	shl    $0x2,%eax
f010d781:	01 d0                	add    %edx,%eax
f010d783:	89 c1                	mov    %eax,%ecx
f010d785:	c1 e1 08             	shl    $0x8,%ecx
f010d788:	01 c8                	add    %ecx,%eax
f010d78a:	89 c1                	mov    %eax,%ecx
f010d78c:	c1 e1 10             	shl    $0x10,%ecx
f010d78f:	01 c8                	add    %ecx,%eax
f010d791:	01 c0                	add    %eax,%eax
f010d793:	01 d0                	add    %edx,%eax
}
f010d795:	5d                   	pop    %ebp
f010d796:	c3                   	ret    

f010d797 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010d797:	55                   	push   %ebp
f010d798:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010d79a:	ff 75 08             	pushl  0x8(%ebp)
f010d79d:	e8 bd ff ff ff       	call   f010d75f <to_frame_number>
f010d7a2:	83 c4 04             	add    $0x4,%esp
f010d7a5:	c1 e0 0c             	shl    $0xc,%eax
}
f010d7a8:	c9                   	leave  
f010d7a9:	c3                   	ret    

f010d7aa <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010d7aa:	55                   	push   %ebp
f010d7ab:	89 e5                	mov    %esp,%ebp
f010d7ad:	83 ec 18             	sub    $0x18,%esp
f010d7b0:	8b 45 10             	mov    0x10(%ebp),%eax
f010d7b3:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010d7b6:	e8 da 99 ff ff       	call   f0107195 <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010d7bb:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010d7bf:	74 23                	je     f010d7e4 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010d7c1:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010d7c6:	8b 40 10             	mov    0x10(%eax),%eax
f010d7c9:	8b 15 64 30 5c f0    	mov    0xf05c3064,%edx
f010d7cf:	83 c2 20             	add    $0x20,%edx
f010d7d2:	83 ec 04             	sub    $0x4,%esp
f010d7d5:	50                   	push   %eax
f010d7d6:	52                   	push   %edx
f010d7d7:	68 50 9a 12 f0       	push   $0xf0129a50
f010d7dc:	e8 8b 37 ff ff       	call   f0100f6c <cprintf>
f010d7e1:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010d7e4:	83 ec 04             	sub    $0x4,%esp
f010d7e7:	ff 75 08             	pushl  0x8(%ebp)
f010d7ea:	ff 75 0c             	pushl  0xc(%ebp)
f010d7ed:	68 59 9a 12 f0       	push   $0xf0129a59
f010d7f2:	e8 75 37 ff ff       	call   f0100f6c <cprintf>
f010d7f7:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010d7fa:	e8 e8 99 ff ff       	call   f01071e7 <popcli>
}
f010d7ff:	90                   	nop
f010d800:	c9                   	leave  
f010d801:	c3                   	ret    

f010d802 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010d802:	55                   	push   %ebp
f010d803:	89 e5                	mov    %esp,%ebp
f010d805:	83 ec 18             	sub    $0x18,%esp
f010d808:	8b 45 08             	mov    0x8(%ebp),%eax
f010d80b:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010d80e:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010d812:	83 ec 08             	sub    $0x8,%esp
f010d815:	50                   	push   %eax
f010d816:	68 5e 9a 12 f0       	push   $0xf0129a5e
f010d81b:	e8 4c 37 ff ff       	call   f0100f6c <cprintf>
f010d820:	83 c4 10             	add    $0x10,%esp
}
f010d823:	90                   	nop
f010d824:	c9                   	leave  
f010d825:	c3                   	ret    

f010d826 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010d826:	55                   	push   %ebp
f010d827:	89 e5                	mov    %esp,%ebp
f010d829:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d82c:	9c                   	pushf  
f010d82d:	58                   	pop    %eax
f010d82e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010d831:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010d834:	25 00 02 00 00       	and    $0x200,%eax
f010d839:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010d83c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d840:	74 10                	je     f010d852 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010d842:	e8 5e 35 ff ff       	call   f0100da5 <cons_getc2>
f010d847:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d84a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d84e:	74 f2                	je     f010d842 <sys_cgetc+0x1c>
f010d850:	eb 0e                	jmp    f010d860 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010d852:	e8 f3 34 ff ff       	call   f0100d4a <cons_getc>
f010d857:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d85a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d85e:	74 f2                	je     f010d852 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010d860:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010d863:	c9                   	leave  
f010d864:	c3                   	ret    

f010d865 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010d865:	55                   	push   %ebp
f010d866:	89 e5                	mov    %esp,%ebp
f010d868:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010d86b:	e8 21 36 ff ff       	call   f0100e91 <cons_lock>
}
f010d870:	90                   	nop
f010d871:	c9                   	leave  
f010d872:	c3                   	ret    

f010d873 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010d873:	55                   	push   %ebp
f010d874:	89 e5                	mov    %esp,%ebp
f010d876:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010d879:	e8 5a 36 ff ff       	call   f0100ed8 <cons_unlock>
}
f010d87e:	90                   	nop
f010d87f:	c9                   	leave  
f010d880:	c3                   	ret    

f010d881 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010d881:	55                   	push   %ebp
f010d882:	89 e5                	mov    %esp,%ebp
f010d884:	83 ec 28             	sub    $0x28,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010d887:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010d88c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010d88f:	83 ec 0c             	sub    $0xc,%esp
f010d892:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010d895:	50                   	push   %eax
f010d896:	e8 0a a9 ff ff       	call   f01081a5 <allocate_frame>
f010d89b:	83 c4 10             	add    $0x10,%esp
f010d89e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d8a1:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d8a5:	75 08                	jne    f010d8af <__sys_allocate_page+0x2e>
		return r ;
f010d8a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d8aa:	e9 d0 00 00 00       	jmp    f010d97f <__sys_allocate_page+0xfe>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010d8af:	8b 45 08             	mov    0x8(%ebp),%eax
f010d8b2:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010d8b7:	77 0c                	ja     f010d8c5 <__sys_allocate_page+0x44>
f010d8b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d8bc:	25 ff 0f 00 00       	and    $0xfff,%eax
f010d8c1:	85 c0                	test   %eax,%eax
f010d8c3:	74 0a                	je     f010d8cf <__sys_allocate_page+0x4e>
		return E_INVAL;
f010d8c5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d8ca:	e9 b0 00 00 00       	jmp    f010d97f <__sys_allocate_page+0xfe>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010d8cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d8d2:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010d8d7:	83 f8 04             	cmp    $0x4,%eax
f010d8da:	74 0a                	je     f010d8e6 <__sys_allocate_page+0x65>
		return E_INVAL;
f010d8dc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d8e1:	e9 99 00 00 00       	jmp    f010d97f <__sys_allocate_page+0xfe>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010d8e6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d8e9:	83 ec 0c             	sub    $0xc,%esp
f010d8ec:	50                   	push   %eax
f010d8ed:	e8 a5 fe ff ff       	call   f010d797 <to_physical_address>
f010d8f2:	83 c4 10             	add    $0x10,%esp
f010d8f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//return it to the original status
		ptr_frame_info->references -= 1;
	}
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
f010d8f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010d8fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010d8fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d901:	c1 e8 0c             	shr    $0xc,%eax
f010d904:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010d907:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f010d90c:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010d90f:	72 17                	jb     f010d928 <__sys_allocate_page+0xa7>
f010d911:	ff 75 e8             	pushl  -0x18(%ebp)
f010d914:	68 64 9a 12 f0       	push   $0xf0129a64
f010d919:	68 b5 00 00 00       	push   $0xb5
f010d91e:	68 93 9a 12 f0       	push   $0xf0129a93
f010d923:	e8 f2 29 ff ff       	call   f010031a <_panic>
f010d928:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d92b:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010d930:	83 ec 04             	sub    $0x4,%esp
f010d933:	68 00 10 00 00       	push   $0x1000
f010d938:	6a 00                	push   $0x0
f010d93a:	50                   	push   %eax
f010d93b:	e8 ba 4c 01 00       	call   f01225fa <memset>
f010d940:	83 c4 10             	add    $0x10,%esp
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010d943:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010d946:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010d949:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d94c:	8b 40 64             	mov    0x64(%eax),%eax
f010d94f:	ff 75 0c             	pushl  0xc(%ebp)
f010d952:	51                   	push   %ecx
f010d953:	52                   	push   %edx
f010d954:	50                   	push   %eax
f010d955:	e8 61 ac ff ff       	call   f01085bb <map_frame>
f010d95a:	83 c4 10             	add    $0x10,%esp
f010d95d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d960:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d964:	75 14                	jne    f010d97a <__sys_allocate_page+0xf9>
	{
		decrement_references(ptr_frame_info);
f010d966:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d969:	83 ec 0c             	sub    $0xc,%esp
f010d96c:	50                   	push   %eax
f010d96d:	e8 40 aa ff ff       	call   f01083b2 <decrement_references>
f010d972:	83 c4 10             	add    $0x10,%esp
		return r;
f010d975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d978:	eb 05                	jmp    f010d97f <__sys_allocate_page+0xfe>
	}
	return 0 ;
f010d97a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010d97f:	c9                   	leave  
f010d980:	c3                   	ret    

f010d981 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010d981:	55                   	push   %ebp
f010d982:	89 e5                	mov    %esp,%ebp
f010d984:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010d987:	83 ec 04             	sub    $0x4,%esp
f010d98a:	68 a7 9a 12 f0       	push   $0xf0129aa7
f010d98f:	68 dc 00 00 00       	push   $0xdc
f010d994:	68 93 9a 12 f0       	push   $0xf0129a93
f010d999:	e8 7c 29 ff ff       	call   f010031a <_panic>

f010d99e <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010d99e:	55                   	push   %ebp
f010d99f:	89 e5                	mov    %esp,%ebp
f010d9a1:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010d9a4:	83 ec 04             	sub    $0x4,%esp
f010d9a7:	68 c8 9a 12 f0       	push   $0xf0129ac8
f010d9ac:	68 ed 00 00 00       	push   $0xed
f010d9b1:	68 93 9a 12 f0       	push   $0xf0129a93
f010d9b6:	e8 5f 29 ff ff       	call   f010031a <_panic>

f010d9bb <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010d9bb:	55                   	push   %ebp
f010d9bc:	89 e5                	mov    %esp,%ebp
f010d9be:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010d9c1:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010d9c6:	8b 40 64             	mov    0x64(%eax),%eax
f010d9c9:	83 ec 04             	sub    $0x4,%esp
f010d9cc:	ff 75 0c             	pushl  0xc(%ebp)
f010d9cf:	ff 75 08             	pushl  0x8(%ebp)
f010d9d2:	50                   	push   %eax
f010d9d3:	e8 4f bd ff ff       	call   f0109727 <calculate_required_frames>
f010d9d8:	83 c4 10             	add    $0x10,%esp
}
f010d9db:	c9                   	leave  
f010d9dc:	c3                   	ret    

f010d9dd <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010d9dd:	55                   	push   %ebp
f010d9de:	89 e5                	mov    %esp,%ebp
f010d9e0:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010d9e3:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d9e6:	83 ec 0c             	sub    $0xc,%esp
f010d9e9:	50                   	push   %eax
f010d9ea:	e8 84 ae ff ff       	call   f0108873 <calculate_available_frames>
f010d9ef:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010d9f2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010d9f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d9f8:	01 d0                	add    %edx,%eax
}
f010d9fa:	c9                   	leave  
f010d9fb:	c3                   	ret    

f010d9fc <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010d9fc:	55                   	push   %ebp
f010d9fd:	89 e5                	mov    %esp,%ebp
f010d9ff:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010da02:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010da05:	83 ec 0c             	sub    $0xc,%esp
f010da08:	50                   	push   %eax
f010da09:	e8 65 ae ff ff       	call   f0108873 <calculate_available_frames>
f010da0e:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010da11:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010da14:	c9                   	leave  
f010da15:	c3                   	ret    

f010da16 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010da16:	55                   	push   %ebp
f010da17:	89 e5                	mov    %esp,%ebp
f010da19:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010da1c:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010da1f:	83 ec 0c             	sub    $0xc,%esp
f010da22:	50                   	push   %eax
f010da23:	e8 4b ae ff ff       	call   f0108873 <calculate_available_frames>
f010da28:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010da2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010da2e:	c9                   	leave  
f010da2f:	c3                   	ret    

f010da30 <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010da30:	55                   	push   %ebp
f010da31:	89 e5                	mov    %esp,%ebp
f010da33:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010da36:	83 ec 0c             	sub    $0xc,%esp
f010da39:	ff 75 08             	pushl  0x8(%ebp)
f010da3c:	e8 44 37 01 00       	call   f0121185 <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010da41:	83 c4 10             	add    $0x10,%esp
}
f010da44:	c9                   	leave  
f010da45:	c3                   	ret    

f010da46 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010da46:	55                   	push   %ebp
f010da47:	89 e5                	mov    %esp,%ebp
f010da49:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010da4c:	e8 5f 36 01 00       	call   f01210b0 <scarce_memory>
}
f010da51:	90                   	nop
f010da52:	c9                   	leave  
f010da53:	c3                   	ret    

f010da54 <sys_clearFFL>:

void sys_clearFFL()
{
f010da54:	55                   	push   %ebp
f010da55:	89 e5                	mov    %esp,%ebp
f010da57:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010da5a:	83 ec 0c             	sub    $0xc,%esp
f010da5d:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f010da62:	e8 8e 10 00 00       	call   f010eaf5 <acquire_spinlock>
f010da67:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010da6a:	a1 cc 1e 5a f0       	mov    0xf05a1ecc,%eax
f010da6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010da72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010da79:	eb 12                	jmp    f010da8d <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010da7b:	83 ec 0c             	sub    $0xc,%esp
f010da7e:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010da81:	50                   	push   %eax
f010da82:	e8 1e a7 ff ff       	call   f01081a5 <allocate_frame>
f010da87:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010da8a:	ff 45 f4             	incl   -0xc(%ebp)
f010da8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da90:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010da93:	7c e6                	jl     f010da7b <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010da95:	83 ec 0c             	sub    $0xc,%esp
f010da98:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f010da9d:	e8 da 10 00 00       	call   f010eb7c <release_spinlock>
f010daa2:	83 c4 10             	add    $0x10,%esp
}
f010daa5:	90                   	nop
f010daa6:	c9                   	leave  
f010daa7:	c3                   	ret    

f010daa8 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010daa8:	55                   	push   %ebp
f010daa9:	89 e5                	mov    %esp,%ebp
f010daab:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010daae:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010dab3:	83 ec 0c             	sub    $0xc,%esp
f010dab6:	50                   	push   %eax
f010dab7:	e8 88 6c ff ff       	call   f0104744 <pf_calculate_allocated_pages>
f010dabc:	83 c4 10             	add    $0x10,%esp
}
f010dabf:	c9                   	leave  
f010dac0:	c3                   	ret    

f010dac1 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010dac1:	55                   	push   %ebp
f010dac2:	89 e5                	mov    %esp,%ebp
f010dac4:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010dac7:	e8 db 0c 00 00       	call   f010e7a7 <isBufferingEnabled>
f010dacc:	84 c0                	test   %al,%al
f010dace:	74 19                	je     f010dae9 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010dad0:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010dad5:	83 ec 04             	sub    $0x4,%esp
f010dad8:	ff 75 0c             	pushl  0xc(%ebp)
f010dadb:	ff 75 08             	pushl  0x8(%ebp)
f010dade:	50                   	push   %eax
f010dadf:	e8 8e bc ff ff       	call   f0109772 <__free_user_mem_with_buffering>
f010dae4:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010dae7:	eb 18                	jmp    f010db01 <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010dae9:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010daee:	83 ec 04             	sub    $0x4,%esp
f010daf1:	ff 75 0c             	pushl  0xc(%ebp)
f010daf4:	ff 75 08             	pushl  0x8(%ebp)
f010daf7:	50                   	push   %eax
f010daf8:	e8 67 bc ff ff       	call   f0109764 <free_user_mem>
f010dafd:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010db00:	90                   	nop
}
f010db01:	c9                   	leave  
f010db02:	c3                   	ret    

f010db03 <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010db03:	55                   	push   %ebp
f010db04:	89 e5                	mov    %esp,%ebp
f010db06:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010db09:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010db0d:	75 07                	jne    f010db16 <check_Param+0x13>
	{
		env_exit();
f010db0f:	e8 ef cb ff ff       	call   f010a703 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010db14:	eb 25                	jmp    f010db3b <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010db16:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010db1d:	77 07                	ja     f010db26 <check_Param+0x23>
f010db1f:	8b 45 08             	mov    0x8(%ebp),%eax
f010db22:	85 c0                	test   %eax,%eax
f010db24:	78 07                	js     f010db2d <check_Param+0x2a>
	{
		env_exit();
f010db26:	e8 d8 cb ff ff       	call   f010a703 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010db2b:	eb 0e                	jmp    f010db3b <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010db2d:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010db34:	76 05                	jbe    f010db3b <check_Param+0x38>
	{
		env_exit();
f010db36:	e8 c8 cb ff ff       	call   f010a703 <env_exit>
	}
}
f010db3b:	90                   	nop
f010db3c:	c9                   	leave  
f010db3d:	c3                   	ret    

f010db3e <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010db3e:	55                   	push   %ebp
f010db3f:	89 e5                	mov    %esp,%ebp
f010db41:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010db44:	83 ec 0c             	sub    $0xc,%esp
f010db47:	ff 75 08             	pushl  0x8(%ebp)
f010db4a:	e8 b4 ff ff ff       	call   f010db03 <check_Param>
f010db4f:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010db52:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010db57:	83 ec 04             	sub    $0x4,%esp
f010db5a:	ff 75 0c             	pushl  0xc(%ebp)
f010db5d:	ff 75 08             	pushl  0x8(%ebp)
f010db60:	50                   	push   %eax
f010db61:	e8 f0 bb ff ff       	call   f0109756 <allocate_user_mem>
f010db66:	83 c4 10             	add    $0x10,%esp
	return;
f010db69:	90                   	nop
}
f010db6a:	c9                   	leave  
f010db6b:	c3                   	ret    

f010db6c <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010db6c:	55                   	push   %ebp
f010db6d:	89 e5                	mov    %esp,%ebp
f010db6f:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010db72:	83 ec 0c             	sub    $0xc,%esp
f010db75:	ff 75 08             	pushl  0x8(%ebp)
f010db78:	e8 86 ff ff ff       	call   f010db03 <check_Param>
f010db7d:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010db80:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010db85:	8b 40 64             	mov    0x64(%eax),%eax
f010db88:	ff 75 10             	pushl  0x10(%ebp)
f010db8b:	ff 75 0c             	pushl  0xc(%ebp)
f010db8e:	ff 75 08             	pushl  0x8(%ebp)
f010db91:	50                   	push   %eax
f010db92:	e8 5c bb ff ff       	call   f01096f3 <allocate_chunk>
f010db97:	83 c4 10             	add    $0x10,%esp
	return;
f010db9a:	90                   	nop
}
f010db9b:	c9                   	leave  
f010db9c:	c3                   	ret    

f010db9d <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010db9d:	55                   	push   %ebp
f010db9e:	89 e5                	mov    %esp,%ebp
f010dba0:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010dba3:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010dba8:	ff 75 10             	pushl  0x10(%ebp)
f010dbab:	ff 75 0c             	pushl  0xc(%ebp)
f010dbae:	ff 75 08             	pushl  0x8(%ebp)
f010dbb1:	50                   	push   %eax
f010dbb2:	e8 d8 bb ff ff       	call   f010978f <move_user_mem>
f010dbb7:	83 c4 10             	add    $0x10,%esp
	return;
f010dbba:	90                   	nop
}
f010dbbb:	c9                   	leave  
f010dbbc:	c3                   	ret    

f010dbbd <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010dbbd:	55                   	push   %ebp
f010dbbe:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010dbc0:	a1 a4 48 5a f0       	mov    0xf05a48a4,%eax
}
f010dbc5:	5d                   	pop    %ebp
f010dbc6:	c3                   	ret    

f010dbc7 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010dbc7:	55                   	push   %ebp
f010dbc8:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010dbca:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbcd:	a3 a4 48 5a f0       	mov    %eax,0xf05a48a4
}
f010dbd2:	90                   	nop
f010dbd3:	5d                   	pop    %ebp
f010dbd4:	c3                   	ret    

f010dbd5 <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010dbd5:	55                   	push   %ebp
f010dbd6:	89 e5                	mov    %esp,%ebp
f010dbd8:	83 ec 18             	sub    $0x18,%esp
f010dbdb:	8b 45 10             	mov    0x10(%ebp),%eax
f010dbde:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010dbe1:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010dbe5:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010dbea:	8b 40 10             	mov    0x10(%eax),%eax
f010dbed:	83 ec 0c             	sub    $0xc,%esp
f010dbf0:	ff 75 14             	pushl  0x14(%ebp)
f010dbf3:	52                   	push   %edx
f010dbf4:	ff 75 0c             	pushl  0xc(%ebp)
f010dbf7:	ff 75 08             	pushl  0x8(%ebp)
f010dbfa:	50                   	push   %eax
f010dbfb:	e8 de ad ff ff       	call   f01089de <createSharedObject>
f010dc00:	83 c4 20             	add    $0x20,%esp
}
f010dc03:	c9                   	leave  
f010dc04:	c3                   	ret    

f010dc05 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010dc05:	55                   	push   %ebp
f010dc06:	89 e5                	mov    %esp,%ebp
f010dc08:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010dc0b:	83 ec 08             	sub    $0x8,%esp
f010dc0e:	ff 75 0c             	pushl  0xc(%ebp)
f010dc11:	ff 75 08             	pushl  0x8(%ebp)
f010dc14:	e8 e5 ad ff ff       	call   f01089fe <getSizeOfSharedObject>
f010dc19:	83 c4 10             	add    $0x10,%esp
}
f010dc1c:	c9                   	leave  
f010dc1d:	c3                   	ret    

f010dc1e <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010dc1e:	55                   	push   %ebp
f010dc1f:	89 e5                	mov    %esp,%ebp
f010dc21:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010dc24:	83 ec 04             	sub    $0x4,%esp
f010dc27:	ff 75 10             	pushl  0x10(%ebp)
f010dc2a:	ff 75 0c             	pushl  0xc(%ebp)
f010dc2d:	ff 75 08             	pushl  0x8(%ebp)
f010dc30:	e8 f8 ad ff ff       	call   f0108a2d <getSharedObject>
f010dc35:	83 c4 10             	add    $0x10,%esp
}
f010dc38:	c9                   	leave  
f010dc39:	c3                   	ret    

f010dc3a <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010dc3a:	55                   	push   %ebp
f010dc3b:	89 e5                	mov    %esp,%ebp
f010dc3d:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010dc40:	83 ec 08             	sub    $0x8,%esp
f010dc43:	ff 75 0c             	pushl  0xc(%ebp)
f010dc46:	ff 75 08             	pushl  0x8(%ebp)
f010dc49:	e8 fc ad ff ff       	call   f0108a4a <freeSharedObject>
f010dc4e:	83 c4 10             	add    $0x10,%esp
}
f010dc51:	c9                   	leave  
f010dc52:	c3                   	ret    

f010dc53 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010dc53:	55                   	push   %ebp
f010dc54:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010dc56:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010dc5b:	8b 40 10             	mov    0x10(%eax),%eax
}
f010dc5e:	5d                   	pop    %ebp
f010dc5f:	c3                   	ret    

f010dc60 <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010dc60:	55                   	push   %ebp
f010dc61:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010dc63:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010dc68:	89 c2                	mov    %eax,%edx
f010dc6a:	a1 b0 13 5a f0       	mov    0xf05a13b0,%eax
f010dc6f:	29 c2                	sub    %eax,%edx
f010dc71:	89 d0                	mov    %edx,%eax
f010dc73:	c1 f8 02             	sar    $0x2,%eax
f010dc76:	89 c2                	mov    %eax,%edx
f010dc78:	89 d0                	mov    %edx,%eax
f010dc7a:	c1 e0 02             	shl    $0x2,%eax
f010dc7d:	01 d0                	add    %edx,%eax
f010dc7f:	c1 e0 02             	shl    $0x2,%eax
f010dc82:	01 d0                	add    %edx,%eax
f010dc84:	c1 e0 02             	shl    $0x2,%eax
f010dc87:	01 d0                	add    %edx,%eax
f010dc89:	c1 e0 02             	shl    $0x2,%eax
f010dc8c:	01 d0                	add    %edx,%eax
f010dc8e:	c1 e0 08             	shl    $0x8,%eax
f010dc91:	29 d0                	sub    %edx,%eax
f010dc93:	c1 e0 08             	shl    $0x8,%eax
f010dc96:	29 d0                	sub    %edx,%eax
f010dc98:	c1 e0 03             	shl    $0x3,%eax
f010dc9b:	01 d0                	add    %edx,%eax
f010dc9d:	c1 e0 03             	shl    $0x3,%eax
f010dca0:	01 d0                	add    %edx,%eax
f010dca2:	01 c0                	add    %eax,%eax
f010dca4:	01 d0                	add    %edx,%eax
}
f010dca6:	5d                   	pop    %ebp
f010dca7:	c3                   	ret    

f010dca8 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010dca8:	55                   	push   %ebp
f010dca9:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010dcab:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010dcb0:	8b 40 14             	mov    0x14(%eax),%eax
}
f010dcb3:	5d                   	pop    %ebp
f010dcb4:	c3                   	ret    

f010dcb5 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010dcb5:	55                   	push   %ebp
f010dcb6:	89 e5                	mov    %esp,%ebp
f010dcb8:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010dcbb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010dcbf:	75 0a                	jne    f010dccb <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010dcc1:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010dcc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010dcc9:	eb 22                	jmp    f010dced <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010dccb:	83 ec 04             	sub    $0x4,%esp
f010dcce:	6a 00                	push   $0x0
f010dcd0:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010dcd3:	50                   	push   %eax
f010dcd4:	ff 75 08             	pushl  0x8(%ebp)
f010dcd7:	e8 b9 ca ff ff       	call   f010a795 <envid2env>
f010dcdc:	83 c4 10             	add    $0x10,%esp
f010dcdf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010dce2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010dce6:	79 05                	jns    f010dced <sys_destroy_env+0x38>
	{
		return r;
f010dce8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dceb:	eb 5e                	jmp    f010dd4b <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010dced:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010dcf0:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010dcf5:	39 c2                	cmp    %eax,%edx
f010dcf7:	75 1b                	jne    f010dd14 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010dcf9:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010dcfe:	8b 40 10             	mov    0x10(%eax),%eax
f010dd01:	83 ec 08             	sub    $0x8,%esp
f010dd04:	50                   	push   %eax
f010dd05:	68 e7 9a 12 f0       	push   $0xf0129ae7
f010dd0a:	e8 5d 32 ff ff       	call   f0100f6c <cprintf>
f010dd0f:	83 c4 10             	add    $0x10,%esp
f010dd12:	eb 20                	jmp    f010dd34 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010dd14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dd17:	8b 50 10             	mov    0x10(%eax),%edx
f010dd1a:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010dd1f:	8b 40 10             	mov    0x10(%eax),%eax
f010dd22:	83 ec 04             	sub    $0x4,%esp
f010dd25:	52                   	push   %edx
f010dd26:	50                   	push   %eax
f010dd27:	68 02 9b 12 f0       	push   $0xf0129b02
f010dd2c:	e8 3b 32 ff ff       	call   f0100f6c <cprintf>
f010dd31:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010dd34:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dd37:	8b 40 10             	mov    0x10(%eax),%eax
f010dd3a:	83 ec 0c             	sub    $0xc,%esp
f010dd3d:	50                   	push   %eax
f010dd3e:	e8 f5 7c ff ff       	call   f0105a38 <sched_kill_env>
f010dd43:	83 c4 10             	add    $0x10,%esp

	return 0;
f010dd46:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010dd4b:	c9                   	leave  
f010dd4c:	c3                   	ret    

f010dd4d <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010dd4d:	55                   	push   %ebp
f010dd4e:	89 e5                	mov    %esp,%ebp
f010dd50:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010dd53:	e8 ab c9 ff ff       	call   f010a703 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010dd58:	90                   	nop
f010dd59:	c9                   	leave  
f010dd5a:	c3                   	ret    

f010dd5b <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010dd5b:	55                   	push   %ebp
f010dd5c:	89 e5                	mov    %esp,%ebp
f010dd5e:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010dd61:	ff 75 14             	pushl  0x14(%ebp)
f010dd64:	ff 75 10             	pushl  0x10(%ebp)
f010dd67:	ff 75 0c             	pushl  0xc(%ebp)
f010dd6a:	ff 75 08             	pushl  0x8(%ebp)
f010dd6d:	e8 d3 bc ff ff       	call   f0109a45 <env_create>
f010dd72:	83 c4 10             	add    $0x10,%esp
f010dd75:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010dd78:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010dd7c:	75 07                	jne    f010dd85 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010dd7e:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010dd83:	eb 14                	jmp    f010dd99 <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010dd85:	83 ec 0c             	sub    $0xc,%esp
f010dd88:	ff 75 f4             	pushl  -0xc(%ebp)
f010dd8b:	e8 ea 78 ff ff       	call   f010567a <sched_new_env>
f010dd90:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010dd93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dd96:	8b 40 10             	mov    0x10(%eax),%eax
}
f010dd99:	c9                   	leave  
f010dd9a:	c3                   	ret    

f010dd9b <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010dd9b:	55                   	push   %ebp
f010dd9c:	89 e5                	mov    %esp,%ebp
f010dd9e:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010dda1:	8b 45 08             	mov    0x8(%ebp),%eax
f010dda4:	83 ec 0c             	sub    $0xc,%esp
f010dda7:	50                   	push   %eax
f010dda8:	e8 23 79 ff ff       	call   f01056d0 <sched_run_env>
f010ddad:	83 c4 10             	add    $0x10,%esp
}
f010ddb0:	90                   	nop
f010ddb1:	c9                   	leave  
f010ddb2:	c3                   	ret    

f010ddb3 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010ddb3:	55                   	push   %ebp
f010ddb4:	89 e5                	mov    %esp,%ebp
f010ddb6:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010ddb9:	0f 31                	rdtsc  
f010ddbb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ddbe:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010ddc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ddc4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ddc7:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010ddca:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010ddcd:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ddd0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ddd3:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ddd6:	89 01                	mov    %eax,(%ecx)
f010ddd8:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010dddb:	8b 45 08             	mov    0x8(%ebp),%eax
f010ddde:	c9                   	leave  
f010dddf:	c2 04 00             	ret    $0x4

f010dde2 <sys_rcr2>:

uint32 sys_rcr2()
{
f010dde2:	55                   	push   %ebp
f010dde3:	89 e5                	mov    %esp,%ebp
f010dde5:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010dde8:	0f 20 d0             	mov    %cr2,%eax
f010ddeb:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010ddee:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010ddf1:	90                   	nop
}
f010ddf2:	c9                   	leave  
f010ddf3:	c3                   	ret    

f010ddf4 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010ddf4:	55                   	push   %ebp
f010ddf5:	89 e5                	mov    %esp,%ebp
f010ddf7:	83 ec 04             	sub    $0x4,%esp
f010ddfa:	8b 45 08             	mov    0x8(%ebp),%eax
f010ddfd:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010de00:	8a 45 fc             	mov    -0x4(%ebp),%al
f010de03:	a2 20 1c 5a f0       	mov    %al,0xf05a1c20
}
f010de08:	90                   	nop
f010de09:	c9                   	leave  
f010de0a:	c3                   	ret    

f010de0b <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010de0b:	55                   	push   %ebp
f010de0c:	89 e5                	mov    %esp,%ebp
f010de0e:	56                   	push   %esi
f010de0f:	53                   	push   %ebx
f010de10:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010de13:	e8 2d c9 ff ff       	call   f010a745 <get_cpu_proc>
f010de18:	a3 64 30 5c f0       	mov    %eax,0xf05c3064
	assert(cur_env != NULL);
f010de1d:	a1 64 30 5c f0       	mov    0xf05c3064,%eax
f010de22:	85 c0                	test   %eax,%eax
f010de24:	75 19                	jne    f010de3f <syscall+0x34>
f010de26:	68 1a 9b 12 f0       	push   $0xf0129b1a
f010de2b:	68 2a 9b 12 f0       	push   $0xf0129b2a
f010de30:	68 05 02 00 00       	push   $0x205
f010de35:	68 93 9a 12 f0       	push   $0xf0129a93
f010de3a:	e8 db 24 ff ff       	call   f010031a <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010de3f:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010de43:	0f 87 06 04 00 00    	ja     f010e24f <syscall+0x444>
f010de49:	8b 45 08             	mov    0x8(%ebp),%eax
f010de4c:	c1 e0 02             	shl    $0x2,%eax
f010de4f:	05 40 9b 12 f0       	add    $0xf0129b40,%eax
f010de54:	8b 00                	mov    (%eax),%eax
f010de56:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010de58:	8b 45 0c             	mov    0xc(%ebp),%eax
f010de5b:	83 ec 0c             	sub    $0xc,%esp
f010de5e:	50                   	push   %eax
f010de5f:	e8 dd b8 ff ff       	call   f0109741 <sys_sbrk>
f010de64:	83 c4 10             	add    $0x10,%esp
f010de67:	e9 e8 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010de6c:	83 ec 08             	sub    $0x8,%esp
f010de6f:	ff 75 10             	pushl  0x10(%ebp)
f010de72:	ff 75 0c             	pushl  0xc(%ebp)
f010de75:	e8 47 fc ff ff       	call   f010dac1 <sys_free_user_mem>
f010de7a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010de7d:	b8 00 00 00 00       	mov    $0x0,%eax
f010de82:	e9 cd 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010de87:	83 ec 08             	sub    $0x8,%esp
f010de8a:	ff 75 10             	pushl  0x10(%ebp)
f010de8d:	ff 75 0c             	pushl  0xc(%ebp)
f010de90:	e8 a9 fc ff ff       	call   f010db3e <sys_allocate_user_mem>
f010de95:	83 c4 10             	add    $0x10,%esp
		return 0;
f010de98:	b8 00 00 00 00       	mov    $0x0,%eax
f010de9d:	e9 b2 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010dea2:	8b 45 14             	mov    0x14(%ebp),%eax
f010dea5:	0f b6 d0             	movzbl %al,%edx
f010dea8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010deab:	83 ec 04             	sub    $0x4,%esp
f010deae:	52                   	push   %edx
f010deaf:	ff 75 10             	pushl  0x10(%ebp)
f010deb2:	50                   	push   %eax
f010deb3:	e8 f2 f8 ff ff       	call   f010d7aa <sys_cputs>
f010deb8:	83 c4 10             	add    $0x10,%esp
		return 0;
f010debb:	b8 00 00 00 00       	mov    $0x0,%eax
f010dec0:	e9 8f 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010dec5:	e8 5c f9 ff ff       	call   f010d826 <sys_cgetc>
f010deca:	e9 85 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010decf:	e8 91 f9 ff ff       	call   f010d865 <sys_lock_cons>
		return 0;
f010ded4:	b8 00 00 00 00       	mov    $0x0,%eax
f010ded9:	e9 76 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010dede:	e8 90 f9 ff ff       	call   f010d873 <sys_unlock_cons>
		return 0;
f010dee3:	b8 00 00 00 00       	mov    $0x0,%eax
f010dee8:	e9 67 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010deed:	83 ec 08             	sub    $0x8,%esp
f010def0:	ff 75 10             	pushl  0x10(%ebp)
f010def3:	ff 75 0c             	pushl  0xc(%ebp)
f010def6:	e8 c0 fa ff ff       	call   f010d9bb <sys_calculate_required_frames>
f010defb:	83 c4 10             	add    $0x10,%esp
f010defe:	e9 51 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010df03:	e8 d5 fa ff ff       	call   f010d9dd <sys_calculate_free_frames>
f010df08:	e9 47 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010df0d:	e8 ea fa ff ff       	call   f010d9fc <sys_calculate_modified_frames>
f010df12:	e9 3d 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010df17:	e8 fa fa ff ff       	call   f010da16 <sys_calculate_notmod_frames>
f010df1c:	e9 33 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010df21:	e8 82 fb ff ff       	call   f010daa8 <sys_pf_calculate_allocated_pages>
f010df26:	e9 29 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010df2b:	83 ec 0c             	sub    $0xc,%esp
f010df2e:	ff 75 0c             	pushl  0xc(%ebp)
f010df31:	e8 fa fa ff ff       	call   f010da30 <sys_calculate_pages_tobe_removed_ready_exit>
f010df36:	83 c4 10             	add    $0x10,%esp
f010df39:	e9 16 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010df3e:	e8 03 fb ff ff       	call   f010da46 <sys_scarce_memory>
		return 0;
f010df43:	b8 00 00 00 00       	mov    $0x0,%eax
f010df48:	e9 07 03 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010df4d:	83 ec 04             	sub    $0x4,%esp
f010df50:	ff 75 14             	pushl  0x14(%ebp)
f010df53:	ff 75 10             	pushl  0x10(%ebp)
f010df56:	ff 75 0c             	pushl  0xc(%ebp)
f010df59:	e8 0e fc ff ff       	call   f010db6c <sys_allocate_chunk>
f010df5e:	83 c4 10             	add    $0x10,%esp
		return 0;
f010df61:	b8 00 00 00 00       	mov    $0x0,%eax
f010df66:	e9 e9 02 00 00       	jmp    f010e254 <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010df6b:	8b 55 10             	mov    0x10(%ebp),%edx
f010df6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010df71:	83 ec 08             	sub    $0x8,%esp
f010df74:	52                   	push   %edx
f010df75:	50                   	push   %eax
f010df76:	e8 06 f9 ff ff       	call   f010d881 <__sys_allocate_page>
f010df7b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010df7e:	b8 00 00 00 00       	mov    $0x0,%eax
f010df83:	e9 cc 02 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010df88:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010df8b:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010df8e:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010df91:	8b 55 10             	mov    0x10(%ebp),%edx
f010df94:	8b 45 0c             	mov    0xc(%ebp),%eax
f010df97:	83 ec 0c             	sub    $0xc,%esp
f010df9a:	56                   	push   %esi
f010df9b:	53                   	push   %ebx
f010df9c:	51                   	push   %ecx
f010df9d:	52                   	push   %edx
f010df9e:	50                   	push   %eax
f010df9f:	e8 dd f9 ff ff       	call   f010d981 <__sys_map_frame>
f010dfa4:	83 c4 20             	add    $0x20,%esp
		return 0;
f010dfa7:	b8 00 00 00 00       	mov    $0x0,%eax
f010dfac:	e9 a3 02 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010dfb1:	8b 55 10             	mov    0x10(%ebp),%edx
f010dfb4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfb7:	83 ec 08             	sub    $0x8,%esp
f010dfba:	52                   	push   %edx
f010dfbb:	50                   	push   %eax
f010dfbc:	e8 dd f9 ff ff       	call   f010d99e <__sys_unmap_frame>
f010dfc1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dfc4:	b8 00 00 00 00       	mov    $0x0,%eax
f010dfc9:	e9 86 02 00 00       	jmp    f010e254 <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010dfce:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfd1:	0f be c0             	movsbl %al,%eax
f010dfd4:	83 ec 0c             	sub    $0xc,%esp
f010dfd7:	50                   	push   %eax
f010dfd8:	e8 25 f8 ff ff       	call   f010d802 <sys_cputc>
f010dfdd:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dfe0:	b8 00 00 00 00       	mov    $0x0,%eax
f010dfe5:	e9 6a 02 00 00       	jmp    f010e254 <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010dfea:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfed:	0f be c0             	movsbl %al,%eax
f010dff0:	83 ec 0c             	sub    $0xc,%esp
f010dff3:	50                   	push   %eax
f010dff4:	e8 5b fa ff ff       	call   f010da54 <sys_clearFFL>
f010dff9:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dffc:	b8 00 00 00 00       	mov    $0x0,%eax
f010e001:	e9 4e 02 00 00       	jmp    f010e254 <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010e006:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e009:	8b 45 14             	mov    0x14(%ebp),%eax
f010e00c:	0f b6 d0             	movzbl %al,%edx
f010e00f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e012:	51                   	push   %ecx
f010e013:	52                   	push   %edx
f010e014:	ff 75 10             	pushl  0x10(%ebp)
f010e017:	50                   	push   %eax
f010e018:	e8 b8 fb ff ff       	call   f010dbd5 <sys_createSharedObject>
f010e01d:	83 c4 10             	add    $0x10,%esp
f010e020:	e9 2f 02 00 00       	jmp    f010e254 <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010e025:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e028:	8b 55 10             	mov    0x10(%ebp),%edx
f010e02b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e02e:	83 ec 04             	sub    $0x4,%esp
f010e031:	51                   	push   %ecx
f010e032:	52                   	push   %edx
f010e033:	50                   	push   %eax
f010e034:	e8 e5 fb ff ff       	call   f010dc1e <sys_getSharedObject>
f010e039:	83 c4 10             	add    $0x10,%esp
f010e03c:	e9 13 02 00 00       	jmp    f010e254 <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010e041:	8b 55 10             	mov    0x10(%ebp),%edx
f010e044:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e047:	83 ec 08             	sub    $0x8,%esp
f010e04a:	52                   	push   %edx
f010e04b:	50                   	push   %eax
f010e04c:	e8 e9 fb ff ff       	call   f010dc3a <sys_freeSharedObject>
f010e051:	83 c4 10             	add    $0x10,%esp
f010e054:	e9 fb 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010e059:	8b 55 10             	mov    0x10(%ebp),%edx
f010e05c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e05f:	83 ec 08             	sub    $0x8,%esp
f010e062:	52                   	push   %edx
f010e063:	50                   	push   %eax
f010e064:	e8 9c fb ff ff       	call   f010dc05 <sys_getSizeOfSharedObject>
f010e069:	83 c4 10             	add    $0x10,%esp
f010e06c:	e9 e3 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010e071:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e074:	ff 75 18             	pushl  0x18(%ebp)
f010e077:	ff 75 14             	pushl  0x14(%ebp)
f010e07a:	ff 75 10             	pushl  0x10(%ebp)
f010e07d:	50                   	push   %eax
f010e07e:	e8 d8 fc ff ff       	call   f010dd5b <sys_create_env>
f010e083:	83 c4 10             	add    $0x10,%esp
f010e086:	e9 c9 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010e08b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e08e:	83 ec 0c             	sub    $0xc,%esp
f010e091:	50                   	push   %eax
f010e092:	e8 04 fd ff ff       	call   f010dd9b <sys_run_env>
f010e097:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e09a:	b8 00 00 00 00       	mov    $0x0,%eax
f010e09f:	e9 b0 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010e0a4:	e8 b7 fb ff ff       	call   f010dc60 <sys_getenvindex>
f010e0a9:	e9 a6 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010e0ae:	e8 a0 fb ff ff       	call   f010dc53 <sys_getenvid>
f010e0b3:	e9 9c 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010e0b8:	e8 eb fb ff ff       	call   f010dca8 <sys_getparentenvid>
f010e0bd:	e9 92 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010e0c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0c5:	83 ec 0c             	sub    $0xc,%esp
f010e0c8:	50                   	push   %eax
f010e0c9:	e8 e7 fb ff ff       	call   f010dcb5 <sys_destroy_env>
f010e0ce:	83 c4 10             	add    $0x10,%esp
f010e0d1:	e9 7e 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010e0d6:	e8 72 fc ff ff       	call   f010dd4d <sys_exit_env>
		return 0;
f010e0db:	b8 00 00 00 00       	mov    $0x0,%eax
f010e0e0:	e9 6f 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010e0e5:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e0e8:	83 ec 0c             	sub    $0xc,%esp
f010e0eb:	50                   	push   %eax
f010e0ec:	e8 c2 fc ff ff       	call   f010ddb3 <sys_get_virtual_time>
f010e0f1:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010e0f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010e0fa:	8b 45 10             	mov    0x10(%ebp),%eax
f010e0fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010e100:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e103:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e106:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010e108:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e10b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e10e:	89 10                	mov    %edx,(%eax)
		return 0;
f010e110:	b8 00 00 00 00       	mov    $0x0,%eax
f010e115:	e9 3a 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010e11a:	83 ec 04             	sub    $0x4,%esp
f010e11d:	ff 75 14             	pushl  0x14(%ebp)
f010e120:	ff 75 10             	pushl  0x10(%ebp)
f010e123:	ff 75 0c             	pushl  0xc(%ebp)
f010e126:	e8 72 fa ff ff       	call   f010db9d <sys_move_user_mem>
f010e12b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e12e:	b8 00 00 00 00       	mov    $0x0,%eax
f010e133:	e9 1c 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010e138:	e8 a5 fc ff ff       	call   f010dde2 <sys_rcr2>
f010e13d:	e9 12 01 00 00       	jmp    f010e254 <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010e142:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e145:	0f b6 c0             	movzbl %al,%eax
f010e148:	83 ec 0c             	sub    $0xc,%esp
f010e14b:	50                   	push   %eax
f010e14c:	e8 a3 fc ff ff       	call   f010ddf4 <sys_bypassPageFault>
f010e151:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e154:	b8 00 00 00 00       	mov    $0x0,%eax
f010e159:	e9 f6 00 00 00       	jmp    f010e254 <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010e15e:	e8 19 27 01 00       	call   f012087c <rsttst>
		return 0;
f010e163:	b8 00 00 00 00       	mov    $0x0,%eax
f010e168:	e9 e7 00 00 00       	jmp    f010e254 <syscall+0x449>
	case SYS_inctst:
		inctst();
f010e16d:	e8 52 27 01 00       	call   f01208c4 <inctst>
		return 0;
f010e172:	b8 00 00 00 00       	mov    $0x0,%eax
f010e177:	e9 d8 00 00 00       	jmp    f010e254 <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010e17c:	83 ec 0c             	sub    $0xc,%esp
f010e17f:	ff 75 0c             	pushl  0xc(%ebp)
f010e182:	e8 7f 28 01 00       	call   f0120a06 <chktst>
f010e187:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e18a:	b8 00 00 00 00       	mov    $0x0,%eax
f010e18f:	e9 c0 00 00 00       	jmp    f010e254 <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010e194:	e8 5f 27 01 00       	call   f01208f8 <gettst>
f010e199:	e9 b6 00 00 00       	jmp    f010e254 <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010e19e:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010e1a1:	8b 45 18             	mov    0x18(%ebp),%eax
f010e1a4:	0f be c0             	movsbl %al,%eax
f010e1a7:	83 ec 0c             	sub    $0xc,%esp
f010e1aa:	52                   	push   %edx
f010e1ab:	50                   	push   %eax
f010e1ac:	ff 75 14             	pushl  0x14(%ebp)
f010e1af:	ff 75 10             	pushl  0x10(%ebp)
f010e1b2:	ff 75 0c             	pushl  0xc(%ebp)
f010e1b5:	e8 48 27 01 00       	call   f0120902 <tst>
f010e1ba:	83 c4 20             	add    $0x20,%esp
		return 0;
f010e1bd:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1c2:	e9 8d 00 00 00       	jmp    f010e254 <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010e1c7:	e8 f1 f9 ff ff       	call   f010dbbd <sys_get_heap_strategy>
f010e1cc:	e9 83 00 00 00       	jmp    f010e254 <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010e1d1:	83 ec 0c             	sub    $0xc,%esp
f010e1d4:	ff 75 0c             	pushl  0xc(%ebp)
f010e1d7:	e8 eb f9 ff ff       	call   f010dbc7 <sys_set_uheap_strategy>
f010e1dc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e1df:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1e4:	eb 6e                	jmp    f010e254 <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010e1e6:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010e1e9:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e1ec:	8b 55 10             	mov    0x10(%ebp),%edx
f010e1ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e1f2:	53                   	push   %ebx
f010e1f3:	51                   	push   %ecx
f010e1f4:	52                   	push   %edx
f010e1f5:	50                   	push   %eax
f010e1f6:	e8 98 4b 00 00       	call   f0112d93 <sys_check_LRU_lists>
f010e1fb:	83 c4 10             	add    $0x10,%esp
f010e1fe:	eb 54                	jmp    f010e254 <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010e200:	8b 55 10             	mov    0x10(%ebp),%edx
f010e203:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e206:	83 ec 08             	sub    $0x8,%esp
f010e209:	52                   	push   %edx
f010e20a:	50                   	push   %eax
f010e20b:	e8 45 4d 00 00       	call   f0112f55 <sys_check_LRU_lists_free>
f010e210:	83 c4 10             	add    $0x10,%esp
f010e213:	eb 3f                	jmp    f010e254 <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010e215:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e218:	8b 55 10             	mov    0x10(%ebp),%edx
f010e21b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e21e:	51                   	push   %ecx
f010e21f:	ff 75 14             	pushl  0x14(%ebp)
f010e222:	52                   	push   %edx
f010e223:	50                   	push   %eax
f010e224:	e8 b9 4e 00 00       	call   f01130e2 <sys_check_WS_list>
f010e229:	83 c4 10             	add    $0x10,%esp
f010e22c:	eb 26                	jmp    f010e254 <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010e22e:	8b 55 10             	mov    0x10(%ebp),%edx
f010e231:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e234:	83 ec 08             	sub    $0x8,%esp
f010e237:	52                   	push   %edx
f010e238:	50                   	push   %eax
f010e239:	e8 c9 29 01 00       	call   f0120c07 <sys_utilities>
f010e23e:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e241:	b8 00 00 00 00       	mov    $0x0,%eax
f010e246:	eb 0c                	jmp    f010e254 <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010e248:	b8 03 00 00 00       	mov    $0x3,%eax
f010e24d:	eb 05                	jmp    f010e254 <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010e24f:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010e254:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010e257:	5b                   	pop    %ebx
f010e258:	5e                   	pop    %esi
f010e259:	5d                   	pop    %ebp
f010e25a:	c3                   	ret    

f010e25b <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010e25b:	55                   	push   %ebp
f010e25c:	89 e5                	mov    %esp,%ebp
f010e25e:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010e261:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e264:	8b 00                	mov    (%eax),%eax
f010e266:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e269:	8b 45 10             	mov    0x10(%ebp),%eax
f010e26c:	8b 00                	mov    (%eax),%eax
f010e26e:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e271:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010e278:	e9 ca 00 00 00       	jmp    f010e347 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010e27d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e280:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e283:	01 d0                	add    %edx,%eax
f010e285:	89 c2                	mov    %eax,%edx
f010e287:	c1 ea 1f             	shr    $0x1f,%edx
f010e28a:	01 d0                	add    %edx,%eax
f010e28c:	d1 f8                	sar    %eax
f010e28e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010e291:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e294:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010e297:	eb 03                	jmp    f010e29c <stab_binsearch+0x41>
			m--;
f010e299:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010e29c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e29f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e2a2:	7c 1e                	jl     f010e2c2 <stab_binsearch+0x67>
f010e2a4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e2a7:	89 d0                	mov    %edx,%eax
f010e2a9:	01 c0                	add    %eax,%eax
f010e2ab:	01 d0                	add    %edx,%eax
f010e2ad:	c1 e0 02             	shl    $0x2,%eax
f010e2b0:	89 c2                	mov    %eax,%edx
f010e2b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2b5:	01 d0                	add    %edx,%eax
f010e2b7:	8a 40 04             	mov    0x4(%eax),%al
f010e2ba:	0f b6 c0             	movzbl %al,%eax
f010e2bd:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e2c0:	75 d7                	jne    f010e299 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010e2c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e2c5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e2c8:	7d 09                	jge    f010e2d3 <stab_binsearch+0x78>
			l = true_m + 1;
f010e2ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e2cd:	40                   	inc    %eax
f010e2ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010e2d1:	eb 74                	jmp    f010e347 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010e2d3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010e2da:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e2dd:	89 d0                	mov    %edx,%eax
f010e2df:	01 c0                	add    %eax,%eax
f010e2e1:	01 d0                	add    %edx,%eax
f010e2e3:	c1 e0 02             	shl    $0x2,%eax
f010e2e6:	89 c2                	mov    %eax,%edx
f010e2e8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2eb:	01 d0                	add    %edx,%eax
f010e2ed:	8b 40 08             	mov    0x8(%eax),%eax
f010e2f0:	3b 45 18             	cmp    0x18(%ebp),%eax
f010e2f3:	73 11                	jae    f010e306 <stab_binsearch+0xab>
			*region_left = m;
f010e2f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e2f8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e2fb:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010e2fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e300:	40                   	inc    %eax
f010e301:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e304:	eb 41                	jmp    f010e347 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010e306:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e309:	89 d0                	mov    %edx,%eax
f010e30b:	01 c0                	add    %eax,%eax
f010e30d:	01 d0                	add    %edx,%eax
f010e30f:	c1 e0 02             	shl    $0x2,%eax
f010e312:	89 c2                	mov    %eax,%edx
f010e314:	8b 45 08             	mov    0x8(%ebp),%eax
f010e317:	01 d0                	add    %edx,%eax
f010e319:	8b 40 08             	mov    0x8(%eax),%eax
f010e31c:	3b 45 18             	cmp    0x18(%ebp),%eax
f010e31f:	76 14                	jbe    f010e335 <stab_binsearch+0xda>
			*region_right = m - 1;
f010e321:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e324:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e327:	8b 45 10             	mov    0x10(%ebp),%eax
f010e32a:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010e32c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e32f:	48                   	dec    %eax
f010e330:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e333:	eb 12                	jmp    f010e347 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010e335:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e338:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e33b:	89 10                	mov    %edx,(%eax)
			l = m;
f010e33d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e340:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010e343:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010e347:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e34a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010e34d:	0f 8e 2a ff ff ff    	jle    f010e27d <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010e353:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e357:	75 0f                	jne    f010e368 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010e359:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e35c:	8b 00                	mov    (%eax),%eax
f010e35e:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e361:	8b 45 10             	mov    0x10(%ebp),%eax
f010e364:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010e366:	eb 3d                	jmp    f010e3a5 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e368:	8b 45 10             	mov    0x10(%ebp),%eax
f010e36b:	8b 00                	mov    (%eax),%eax
f010e36d:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e370:	eb 03                	jmp    f010e375 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010e372:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010e375:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e378:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e37a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e37d:	7d 1e                	jge    f010e39d <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010e37f:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e382:	89 d0                	mov    %edx,%eax
f010e384:	01 c0                	add    %eax,%eax
f010e386:	01 d0                	add    %edx,%eax
f010e388:	c1 e0 02             	shl    $0x2,%eax
f010e38b:	89 c2                	mov    %eax,%edx
f010e38d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e390:	01 d0                	add    %edx,%eax
f010e392:	8a 40 04             	mov    0x4(%eax),%al
f010e395:	0f b6 c0             	movzbl %al,%eax
f010e398:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e39b:	75 d5                	jne    f010e372 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010e39d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3a0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e3a3:	89 10                	mov    %edx,(%eax)
	}
}
f010e3a5:	90                   	nop
f010e3a6:	c9                   	leave  
f010e3a7:	c3                   	ret    

f010e3a8 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010e3a8:	55                   	push   %ebp
f010e3a9:	89 e5                	mov    %esp,%ebp
f010e3ab:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010e3ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3b1:	c7 00 fc 9b 12 f0    	movl   $0xf0129bfc,(%eax)
	info->eip_line = 0;
f010e3b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3ba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010e3c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3c4:	c7 40 08 fc 9b 12 f0 	movl   $0xf0129bfc,0x8(%eax)
	info->eip_fn_namelen = 9;
f010e3cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3ce:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010e3d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3d8:	8b 55 08             	mov    0x8(%ebp),%edx
f010e3db:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010e3de:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3e1:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010e3e8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3eb:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010e3f0:	76 1e                	jbe    f010e410 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010e3f2:	c7 45 f4 d4 0f 13 f0 	movl   $0xf0130fd4,-0xc(%ebp)
		stab_end = __STAB_END__;
f010e3f9:	c7 45 f0 88 58 16 f0 	movl   $0xf0165888,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010e400:	c7 45 ec 89 58 16 f0 	movl   $0xf0165889,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010e407:	c7 45 e8 bf 71 17 f0 	movl   $0xf01771bf,-0x18(%ebp)
f010e40e:	eb 2a                	jmp    f010e43a <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010e410:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010e417:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e41a:	8b 00                	mov    (%eax),%eax
f010e41c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010e41f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e422:	8b 40 04             	mov    0x4(%eax),%eax
f010e425:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010e428:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e42b:	8b 40 08             	mov    0x8(%eax),%eax
f010e42e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010e431:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e434:	8b 40 0c             	mov    0xc(%eax),%eax
f010e437:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010e43a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e43d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e440:	76 0a                	jbe    f010e44c <debuginfo_eip+0xa4>
f010e442:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e445:	48                   	dec    %eax
f010e446:	8a 00                	mov    (%eax),%al
f010e448:	84 c0                	test   %al,%al
f010e44a:	74 0a                	je     f010e456 <debuginfo_eip+0xae>
		return -1;
f010e44c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e451:	e9 01 02 00 00       	jmp    f010e657 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010e456:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010e45d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e460:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e463:	29 c2                	sub    %eax,%edx
f010e465:	89 d0                	mov    %edx,%eax
f010e467:	c1 f8 02             	sar    $0x2,%eax
f010e46a:	89 c2                	mov    %eax,%edx
f010e46c:	89 d0                	mov    %edx,%eax
f010e46e:	c1 e0 02             	shl    $0x2,%eax
f010e471:	01 d0                	add    %edx,%eax
f010e473:	c1 e0 02             	shl    $0x2,%eax
f010e476:	01 d0                	add    %edx,%eax
f010e478:	c1 e0 02             	shl    $0x2,%eax
f010e47b:	01 d0                	add    %edx,%eax
f010e47d:	89 c1                	mov    %eax,%ecx
f010e47f:	c1 e1 08             	shl    $0x8,%ecx
f010e482:	01 c8                	add    %ecx,%eax
f010e484:	89 c1                	mov    %eax,%ecx
f010e486:	c1 e1 10             	shl    $0x10,%ecx
f010e489:	01 c8                	add    %ecx,%eax
f010e48b:	01 c0                	add    %eax,%eax
f010e48d:	01 d0                	add    %edx,%eax
f010e48f:	48                   	dec    %eax
f010e490:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010e493:	ff 75 08             	pushl  0x8(%ebp)
f010e496:	6a 64                	push   $0x64
f010e498:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010e49b:	50                   	push   %eax
f010e49c:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010e49f:	50                   	push   %eax
f010e4a0:	ff 75 f4             	pushl  -0xc(%ebp)
f010e4a3:	e8 b3 fd ff ff       	call   f010e25b <stab_binsearch>
f010e4a8:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010e4ab:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4ae:	85 c0                	test   %eax,%eax
f010e4b0:	75 0a                	jne    f010e4bc <debuginfo_eip+0x114>
		return -1;
f010e4b2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e4b7:	e9 9b 01 00 00       	jmp    f010e657 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010e4bc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4bf:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010e4c2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e4c5:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010e4c8:	ff 75 08             	pushl  0x8(%ebp)
f010e4cb:	6a 24                	push   $0x24
f010e4cd:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010e4d0:	50                   	push   %eax
f010e4d1:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010e4d4:	50                   	push   %eax
f010e4d5:	ff 75 f4             	pushl  -0xc(%ebp)
f010e4d8:	e8 7e fd ff ff       	call   f010e25b <stab_binsearch>
f010e4dd:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010e4e0:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010e4e3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e4e6:	39 c2                	cmp    %eax,%edx
f010e4e8:	0f 8f 86 00 00 00    	jg     f010e574 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010e4ee:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e4f1:	89 c2                	mov    %eax,%edx
f010e4f3:	89 d0                	mov    %edx,%eax
f010e4f5:	01 c0                	add    %eax,%eax
f010e4f7:	01 d0                	add    %edx,%eax
f010e4f9:	c1 e0 02             	shl    $0x2,%eax
f010e4fc:	89 c2                	mov    %eax,%edx
f010e4fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e501:	01 d0                	add    %edx,%eax
f010e503:	8b 00                	mov    (%eax),%eax
f010e505:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e508:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e50b:	29 d1                	sub    %edx,%ecx
f010e50d:	89 ca                	mov    %ecx,%edx
f010e50f:	39 d0                	cmp    %edx,%eax
f010e511:	73 22                	jae    f010e535 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010e513:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e516:	89 c2                	mov    %eax,%edx
f010e518:	89 d0                	mov    %edx,%eax
f010e51a:	01 c0                	add    %eax,%eax
f010e51c:	01 d0                	add    %edx,%eax
f010e51e:	c1 e0 02             	shl    $0x2,%eax
f010e521:	89 c2                	mov    %eax,%edx
f010e523:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e526:	01 d0                	add    %edx,%eax
f010e528:	8b 10                	mov    (%eax),%edx
f010e52a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e52d:	01 c2                	add    %eax,%edx
f010e52f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e532:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010e535:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e538:	89 c2                	mov    %eax,%edx
f010e53a:	89 d0                	mov    %edx,%eax
f010e53c:	01 c0                	add    %eax,%eax
f010e53e:	01 d0                	add    %edx,%eax
f010e540:	c1 e0 02             	shl    $0x2,%eax
f010e543:	89 c2                	mov    %eax,%edx
f010e545:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e548:	01 d0                	add    %edx,%eax
f010e54a:	8b 50 08             	mov    0x8(%eax),%edx
f010e54d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e550:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010e553:	8b 55 08             	mov    0x8(%ebp),%edx
f010e556:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e559:	8b 40 10             	mov    0x10(%eax),%eax
f010e55c:	29 c2                	sub    %eax,%edx
f010e55e:	89 d0                	mov    %edx,%eax
f010e560:	c1 f8 02             	sar    $0x2,%eax
f010e563:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010e566:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e569:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010e56c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e56f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010e572:	eb 15                	jmp    f010e589 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010e574:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e577:	8b 55 08             	mov    0x8(%ebp),%edx
f010e57a:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010e57d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e580:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010e583:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e586:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010e589:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e58c:	8b 40 08             	mov    0x8(%eax),%eax
f010e58f:	83 ec 08             	sub    $0x8,%esp
f010e592:	6a 3a                	push   $0x3a
f010e594:	50                   	push   %eax
f010e595:	e8 34 40 01 00       	call   f01225ce <strfind>
f010e59a:	83 c4 10             	add    $0x10,%esp
f010e59d:	89 c2                	mov    %eax,%edx
f010e59f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5a2:	8b 40 08             	mov    0x8(%eax),%eax
f010e5a5:	29 c2                	sub    %eax,%edx
f010e5a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5aa:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e5ad:	eb 03                	jmp    f010e5b2 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010e5af:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e5b2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e5b5:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e5b8:	7c 4e                	jl     f010e608 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010e5ba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e5bd:	89 d0                	mov    %edx,%eax
f010e5bf:	01 c0                	add    %eax,%eax
f010e5c1:	01 d0                	add    %edx,%eax
f010e5c3:	c1 e0 02             	shl    $0x2,%eax
f010e5c6:	89 c2                	mov    %eax,%edx
f010e5c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e5cb:	01 d0                	add    %edx,%eax
f010e5cd:	8a 40 04             	mov    0x4(%eax),%al
f010e5d0:	3c 84                	cmp    $0x84,%al
f010e5d2:	74 34                	je     f010e608 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010e5d4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e5d7:	89 d0                	mov    %edx,%eax
f010e5d9:	01 c0                	add    %eax,%eax
f010e5db:	01 d0                	add    %edx,%eax
f010e5dd:	c1 e0 02             	shl    $0x2,%eax
f010e5e0:	89 c2                	mov    %eax,%edx
f010e5e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e5e5:	01 d0                	add    %edx,%eax
f010e5e7:	8a 40 04             	mov    0x4(%eax),%al
f010e5ea:	3c 64                	cmp    $0x64,%al
f010e5ec:	75 c1                	jne    f010e5af <debuginfo_eip+0x207>
f010e5ee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e5f1:	89 d0                	mov    %edx,%eax
f010e5f3:	01 c0                	add    %eax,%eax
f010e5f5:	01 d0                	add    %edx,%eax
f010e5f7:	c1 e0 02             	shl    $0x2,%eax
f010e5fa:	89 c2                	mov    %eax,%edx
f010e5fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e5ff:	01 d0                	add    %edx,%eax
f010e601:	8b 40 08             	mov    0x8(%eax),%eax
f010e604:	85 c0                	test   %eax,%eax
f010e606:	74 a7                	je     f010e5af <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010e608:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e60b:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e60e:	7c 42                	jl     f010e652 <debuginfo_eip+0x2aa>
f010e610:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e613:	89 d0                	mov    %edx,%eax
f010e615:	01 c0                	add    %eax,%eax
f010e617:	01 d0                	add    %edx,%eax
f010e619:	c1 e0 02             	shl    $0x2,%eax
f010e61c:	89 c2                	mov    %eax,%edx
f010e61e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e621:	01 d0                	add    %edx,%eax
f010e623:	8b 00                	mov    (%eax),%eax
f010e625:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e628:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e62b:	29 d1                	sub    %edx,%ecx
f010e62d:	89 ca                	mov    %ecx,%edx
f010e62f:	39 d0                	cmp    %edx,%eax
f010e631:	73 1f                	jae    f010e652 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010e633:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e636:	89 d0                	mov    %edx,%eax
f010e638:	01 c0                	add    %eax,%eax
f010e63a:	01 d0                	add    %edx,%eax
f010e63c:	c1 e0 02             	shl    $0x2,%eax
f010e63f:	89 c2                	mov    %eax,%edx
f010e641:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e644:	01 d0                	add    %edx,%eax
f010e646:	8b 10                	mov    (%eax),%edx
f010e648:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e64b:	01 c2                	add    %eax,%edx
f010e64d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e650:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010e652:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e657:	c9                   	leave  
f010e658:	c3                   	ret    

f010e659 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010e659:	55                   	push   %ebp
f010e65a:	89 e5                	mov    %esp,%ebp
f010e65c:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010e65f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010e663:	74 1c                	je     f010e681 <setPageReplacmentAlgorithmLRU+0x28>
f010e665:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010e669:	74 16                	je     f010e681 <setPageReplacmentAlgorithmLRU+0x28>
f010e66b:	68 08 9c 12 f0       	push   $0xf0129c08
f010e670:	68 52 9c 12 f0       	push   $0xf0129c52
f010e675:	6a 19                	push   $0x19
f010e677:	68 67 9c 12 f0       	push   $0xf0129c67
f010e67c:	e8 99 1c ff ff       	call   f010031a <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010e681:	8b 45 08             	mov    0x8(%ebp),%eax
f010e684:	a3 08 4b 5a f0       	mov    %eax,0xf05a4b08
}
f010e689:	90                   	nop
f010e68a:	c9                   	leave  
f010e68b:	c3                   	ret    

f010e68c <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010e68c:	55                   	push   %ebp
f010e68d:	89 e5                	mov    %esp,%ebp
f010e68f:	c7 05 08 4b 5a f0 03 	movl   $0x3,0xf05a4b08
f010e696:	00 00 00 
f010e699:	90                   	nop
f010e69a:	5d                   	pop    %ebp
f010e69b:	c3                   	ret    

f010e69c <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010e69c:	55                   	push   %ebp
f010e69d:	89 e5                	mov    %esp,%ebp
f010e69f:	c7 05 08 4b 5a f0 04 	movl   $0x4,0xf05a4b08
f010e6a6:	00 00 00 
f010e6a9:	90                   	nop
f010e6aa:	5d                   	pop    %ebp
f010e6ab:	c3                   	ret    

f010e6ac <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010e6ac:	55                   	push   %ebp
f010e6ad:	89 e5                	mov    %esp,%ebp
f010e6af:	c7 05 08 4b 5a f0 05 	movl   $0x5,0xf05a4b08
f010e6b6:	00 00 00 
f010e6b9:	90                   	nop
f010e6ba:	5d                   	pop    %ebp
f010e6bb:	c3                   	ret    

f010e6bc <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010e6bc:	55                   	push   %ebp
f010e6bd:	89 e5                	mov    %esp,%ebp
f010e6bf:	c7 05 08 4b 5a f0 07 	movl   $0x7,0xf05a4b08
f010e6c6:	00 00 00 
f010e6c9:	90                   	nop
f010e6ca:	5d                   	pop    %ebp
f010e6cb:	c3                   	ret    

f010e6cc <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010e6cc:	55                   	push   %ebp
f010e6cd:	89 e5                	mov    %esp,%ebp
f010e6cf:	c7 05 08 4b 5a f0 06 	movl   $0x6,0xf05a4b08
f010e6d6:	00 00 00 
f010e6d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6dc:	a3 a0 1e 5a f0       	mov    %eax,0xf05a1ea0
f010e6e1:	90                   	nop
f010e6e2:	5d                   	pop    %ebp
f010e6e3:	c3                   	ret    

f010e6e4 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010e6e4:	55                   	push   %ebp
f010e6e5:	89 e5                	mov    %esp,%ebp
f010e6e7:	8b 15 08 4b 5a f0    	mov    0xf05a4b08,%edx
f010e6ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6f0:	39 c2                	cmp    %eax,%edx
f010e6f2:	0f 94 c0             	sete   %al
f010e6f5:	0f b6 c0             	movzbl %al,%eax
f010e6f8:	5d                   	pop    %ebp
f010e6f9:	c3                   	ret    

f010e6fa <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010e6fa:	55                   	push   %ebp
f010e6fb:	89 e5                	mov    %esp,%ebp
f010e6fd:	a1 08 4b 5a f0       	mov    0xf05a4b08,%eax
f010e702:	83 f8 03             	cmp    $0x3,%eax
f010e705:	75 07                	jne    f010e70e <isPageReplacmentAlgorithmCLOCK+0x14>
f010e707:	b8 01 00 00 00       	mov    $0x1,%eax
f010e70c:	eb 05                	jmp    f010e713 <isPageReplacmentAlgorithmCLOCK+0x19>
f010e70e:	b8 00 00 00 00       	mov    $0x0,%eax
f010e713:	5d                   	pop    %ebp
f010e714:	c3                   	ret    

f010e715 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010e715:	55                   	push   %ebp
f010e716:	89 e5                	mov    %esp,%ebp
f010e718:	a1 08 4b 5a f0       	mov    0xf05a4b08,%eax
f010e71d:	83 f8 04             	cmp    $0x4,%eax
f010e720:	75 07                	jne    f010e729 <isPageReplacmentAlgorithmFIFO+0x14>
f010e722:	b8 01 00 00 00       	mov    $0x1,%eax
f010e727:	eb 05                	jmp    f010e72e <isPageReplacmentAlgorithmFIFO+0x19>
f010e729:	b8 00 00 00 00       	mov    $0x0,%eax
f010e72e:	5d                   	pop    %ebp
f010e72f:	c3                   	ret    

f010e730 <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010e730:	55                   	push   %ebp
f010e731:	89 e5                	mov    %esp,%ebp
f010e733:	a1 08 4b 5a f0       	mov    0xf05a4b08,%eax
f010e738:	83 f8 05             	cmp    $0x5,%eax
f010e73b:	75 07                	jne    f010e744 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010e73d:	b8 01 00 00 00       	mov    $0x1,%eax
f010e742:	eb 05                	jmp    f010e749 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010e744:	b8 00 00 00 00       	mov    $0x0,%eax
f010e749:	5d                   	pop    %ebp
f010e74a:	c3                   	ret    

f010e74b <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010e74b:	55                   	push   %ebp
f010e74c:	89 e5                	mov    %esp,%ebp
f010e74e:	a1 08 4b 5a f0       	mov    0xf05a4b08,%eax
f010e753:	83 f8 07             	cmp    $0x7,%eax
f010e756:	75 07                	jne    f010e75f <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010e758:	b8 01 00 00 00       	mov    $0x1,%eax
f010e75d:	eb 05                	jmp    f010e764 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010e75f:	b8 00 00 00 00       	mov    $0x0,%eax
f010e764:	5d                   	pop    %ebp
f010e765:	c3                   	ret    

f010e766 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010e766:	55                   	push   %ebp
f010e767:	89 e5                	mov    %esp,%ebp
f010e769:	a1 08 4b 5a f0       	mov    0xf05a4b08,%eax
f010e76e:	83 f8 06             	cmp    $0x6,%eax
f010e771:	75 07                	jne    f010e77a <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010e773:	b8 01 00 00 00       	mov    $0x1,%eax
f010e778:	eb 05                	jmp    f010e77f <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010e77a:	b8 00 00 00 00       	mov    $0x0,%eax
f010e77f:	5d                   	pop    %ebp
f010e780:	c3                   	ret    

f010e781 <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010e781:	55                   	push   %ebp
f010e782:	89 e5                	mov    %esp,%ebp
f010e784:	8b 45 08             	mov    0x8(%ebp),%eax
f010e787:	a3 b8 48 5a f0       	mov    %eax,0xf05a48b8
f010e78c:	90                   	nop
f010e78d:	5d                   	pop    %ebp
f010e78e:	c3                   	ret    

f010e78f <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010e78f:	55                   	push   %ebp
f010e790:	89 e5                	mov    %esp,%ebp
f010e792:	a1 b8 48 5a f0       	mov    0xf05a48b8,%eax
f010e797:	5d                   	pop    %ebp
f010e798:	c3                   	ret    

f010e799 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010e799:	55                   	push   %ebp
f010e79a:	89 e5                	mov    %esp,%ebp
f010e79c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e79f:	a3 74 4b 5a f0       	mov    %eax,0xf05a4b74
f010e7a4:	90                   	nop
f010e7a5:	5d                   	pop    %ebp
f010e7a6:	c3                   	ret    

f010e7a7 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010e7a7:	55                   	push   %ebp
f010e7a8:	89 e5                	mov    %esp,%ebp
f010e7aa:	a1 74 4b 5a f0       	mov    0xf05a4b74,%eax
f010e7af:	5d                   	pop    %ebp
f010e7b0:	c3                   	ret    

f010e7b1 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010e7b1:	55                   	push   %ebp
f010e7b2:	89 e5                	mov    %esp,%ebp
f010e7b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7b7:	a3 10 4c 5a f0       	mov    %eax,0xf05a4c10
f010e7bc:	90                   	nop
f010e7bd:	5d                   	pop    %ebp
f010e7be:	c3                   	ret    

f010e7bf <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010e7bf:	55                   	push   %ebp
f010e7c0:	89 e5                	mov    %esp,%ebp
f010e7c2:	a1 10 4c 5a f0       	mov    0xf05a4c10,%eax
f010e7c7:	5d                   	pop    %ebp
f010e7c8:	c3                   	ret    

f010e7c9 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010e7c9:	55                   	push   %ebp
f010e7ca:	89 e5                	mov    %esp,%ebp
f010e7cc:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e7cf:	0f 20 d0             	mov    %cr2,%eax
f010e7d2:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010e7d5:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010e7d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010e7db:	e8 65 bf ff ff       	call   f010a745 <get_cpu_proc>
f010e7e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010e7e3:	a1 2c 1c 5a f0       	mov    0xf05a1c2c,%eax
f010e7e8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e7eb:	75 50                	jne    f010e83d <fault_handler+0x74>
f010e7ed:	a1 38 1c 5a f0       	mov    0xf05a1c38,%eax
f010e7f2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010e7f5:	75 46                	jne    f010e83d <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010e7f7:	a0 34 1c 5a f0       	mov    0xf05a1c34,%al
f010e7fc:	40                   	inc    %eax
f010e7fd:	a2 34 1c 5a f0       	mov    %al,0xf05a1c34
		if (num_repeated_fault == 3)
f010e802:	a0 34 1c 5a f0       	mov    0xf05a1c34,%al
f010e807:	3c 03                	cmp    $0x3,%al
f010e809:	75 4d                	jne    f010e858 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010e80b:	83 ec 0c             	sub    $0xc,%esp
f010e80e:	ff 75 08             	pushl  0x8(%ebp)
f010e811:	e8 74 e9 ff ff       	call   f010d18a <print_trapframe>
f010e816:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010e819:	8b 15 28 1c 5a f0    	mov    0xf05a1c28,%edx
f010e81f:	a1 30 1c 5a f0       	mov    0xf05a1c30,%eax
f010e824:	83 ec 08             	sub    $0x8,%esp
f010e827:	ff 75 ec             	pushl  -0x14(%ebp)
f010e82a:	52                   	push   %edx
f010e82b:	50                   	push   %eax
f010e82c:	68 84 9c 12 f0       	push   $0xf0129c84
f010e831:	6a 57                	push   $0x57
f010e833:	68 67 9c 12 f0       	push   $0xf0129c67
f010e838:	e8 dd 1a ff ff       	call   f010031a <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010e83d:	a1 2c 1c 5a f0       	mov    0xf05a1c2c,%eax
f010e842:	a3 30 1c 5a f0       	mov    %eax,0xf05a1c30
		before_last_eip = last_eip;
f010e847:	a1 24 1c 5a f0       	mov    0xf05a1c24,%eax
f010e84c:	a3 28 1c 5a f0       	mov    %eax,0xf05a1c28
		num_repeated_fault = 0;
f010e851:	c6 05 34 1c 5a f0 00 	movb   $0x0,0xf05a1c34
	}
	last_eip = (uint32)tf->tf_eip;
f010e858:	8b 45 08             	mov    0x8(%ebp),%eax
f010e85b:	8b 40 30             	mov    0x30(%eax),%eax
f010e85e:	a3 24 1c 5a f0       	mov    %eax,0xf05a1c24
	last_fault_va = fault_va ;
f010e863:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e866:	a3 2c 1c 5a f0       	mov    %eax,0xf05a1c2c
	last_faulted_env = cur_env;
f010e86b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e86e:	a3 38 1c 5a f0       	mov    %eax,0xf05a1c38
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010e873:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010e87a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e87d:	8b 40 34             	mov    0x34(%eax),%eax
f010e880:	0f b7 c0             	movzwl %ax,%eax
f010e883:	83 e0 03             	and    $0x3,%eax
f010e886:	83 f8 03             	cmp    $0x3,%eax
f010e889:	75 07                	jne    f010e892 <fault_handler+0xc9>
		userTrap = 1;
f010e88b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010e892:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e896:	0f 85 a9 00 00 00    	jne    f010e945 <fault_handler+0x17c>
	{
		struct cpu* c = mycpu();
f010e89c:	e8 31 88 ff ff       	call   f01070d2 <mycpu>
f010e8a1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010e8a4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e8a8:	74 2f                	je     f010e8d9 <fault_handler+0x110>
f010e8aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8ad:	8b 40 70             	mov    0x70(%eax),%eax
f010e8b0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e8b3:	77 24                	ja     f010e8d9 <fault_handler+0x110>
f010e8b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8b8:	8b 40 70             	mov    0x70(%eax),%eax
f010e8bb:	05 00 10 00 00       	add    $0x1000,%eax
f010e8c0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e8c3:	76 14                	jbe    f010e8d9 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010e8c5:	83 ec 04             	sub    $0x4,%esp
f010e8c8:	68 f4 9c 12 f0       	push   $0xf0129cf4
f010e8cd:	6a 6e                	push   $0x6e
f010e8cf:	68 67 9c 12 f0       	push   $0xf0129c67
f010e8d4:	e8 41 1a ff ff       	call   f010031a <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010e8d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e8dc:	8b 40 08             	mov    0x8(%eax),%eax
f010e8df:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e8e2:	0f 87 83 00 00 00    	ja     f010e96b <fault_handler+0x1a2>
f010e8e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e8eb:	8b 40 08             	mov    0x8(%eax),%eax
f010e8ee:	05 00 10 00 00       	add    $0x1000,%eax
f010e8f3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e8f6:	76 73                	jbe    f010e96b <fault_handler+0x1a2>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010e8f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e8fb:	ba a0 45 5a f0       	mov    $0xf05a45a0,%edx
f010e900:	29 d0                	sub    %edx,%eax
f010e902:	c1 f8 03             	sar    $0x3,%eax
f010e905:	89 c2                	mov    %eax,%edx
f010e907:	89 d0                	mov    %edx,%eax
f010e909:	c1 e0 02             	shl    $0x2,%eax
f010e90c:	01 d0                	add    %edx,%eax
f010e90e:	01 c0                	add    %eax,%eax
f010e910:	01 d0                	add    %edx,%eax
f010e912:	c1 e0 03             	shl    $0x3,%eax
f010e915:	01 d0                	add    %edx,%eax
f010e917:	89 c1                	mov    %eax,%ecx
f010e919:	c1 e1 0b             	shl    $0xb,%ecx
f010e91c:	01 c8                	add    %ecx,%eax
f010e91e:	c1 e0 05             	shl    $0x5,%eax
f010e921:	01 d0                	add    %edx,%eax
f010e923:	c1 e0 02             	shl    $0x2,%eax
f010e926:	01 d0                	add    %edx,%eax
f010e928:	01 c0                	add    %eax,%eax
f010e92a:	01 d0                	add    %edx,%eax
f010e92c:	c1 e0 03             	shl    $0x3,%eax
f010e92f:	01 d0                	add    %edx,%eax
f010e931:	f7 d8                	neg    %eax
f010e933:	50                   	push   %eax
f010e934:	68 1c 9d 12 f0       	push   $0xf0129d1c
f010e939:	6a 70                	push   $0x70
f010e93b:	68 67 9c 12 f0       	push   $0xf0129c67
f010e940:	e8 d5 19 ff ff       	call   f010031a <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010e945:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010e94c:	76 1d                	jbe    f010e96b <fault_handler+0x1a2>
f010e94e:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010e955:	77 14                	ja     f010e96b <fault_handler+0x1a2>
			panic("User: stack underflow exception!");
f010e957:	83 ec 04             	sub    $0x4,%esp
f010e95a:	68 50 9d 12 f0       	push   $0xf0129d50
f010e95f:	6a 7b                	push   $0x7b
f010e961:	68 67 9c 12 f0       	push   $0xf0129c67
f010e966:	e8 af 19 ff ff       	call   f010031a <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010e96b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e96e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010e971:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010e975:	75 25                	jne    f010e99c <fault_handler+0x1d3>
	{
		print_trapframe(tf);
f010e977:	83 ec 0c             	sub    $0xc,%esp
f010e97a:	ff 75 08             	pushl  0x8(%ebp)
f010e97d:	e8 08 e8 ff ff       	call   f010d18a <print_trapframe>
f010e982:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010e985:	83 ec 04             	sub    $0x4,%esp
f010e988:	68 71 9d 12 f0       	push   $0xf0129d71
f010e98d:	68 84 00 00 00       	push   $0x84
f010e992:	68 67 9c 12 f0       	push   $0xf0129c67
f010e997:	e8 7e 19 ff ff       	call   f010031a <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010e99c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e99f:	8b 40 64             	mov    0x64(%eax),%eax
f010e9a2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e9a5:	c1 ea 16             	shr    $0x16,%edx
f010e9a8:	c1 e2 02             	shl    $0x2,%edx
f010e9ab:	01 d0                	add    %edx,%eax
f010e9ad:	8b 00                	mov    (%eax),%eax
f010e9af:	83 e0 01             	and    $0x1,%eax
f010e9b2:	85 c0                	test   %eax,%eax
f010e9b4:	75 28                	jne    f010e9de <fault_handler+0x215>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010e9b6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e9b9:	8b 80 44 da 01 00    	mov    0x1da44(%eax),%eax
f010e9bf:	8d 50 01             	lea    0x1(%eax),%edx
f010e9c2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e9c5:	89 90 44 da 01 00    	mov    %edx,0x1da44(%eax)

		table_fault_handler(faulted_env, fault_va);
f010e9cb:	83 ec 08             	sub    $0x8,%esp
f010e9ce:	ff 75 ec             	pushl  -0x14(%ebp)
f010e9d1:	ff 75 e0             	pushl  -0x20(%ebp)
f010e9d4:	e8 8f 00 00 00       	call   f010ea68 <table_fault_handler>
f010e9d9:	83 c4 10             	add    $0x10,%esp
f010e9dc:	eb 7b                	jmp    f010ea59 <fault_handler+0x290>

			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010e9de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e9e1:	8b 40 64             	mov    0x64(%eax),%eax
f010e9e4:	83 ec 08             	sub    $0x8,%esp
f010e9e7:	ff 75 ec             	pushl  -0x14(%ebp)
f010e9ea:	50                   	push   %eax
f010e9eb:	e8 d1 a1 ff ff       	call   f0108bc1 <pt_get_page_permissions>
f010e9f0:	83 c4 10             	add    $0x10,%esp
f010e9f3:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010e9f6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010e9f9:	83 e0 01             	and    $0x1,%eax
f010e9fc:	85 c0                	test   %eax,%eax
f010e9fe:	74 17                	je     f010ea17 <fault_handler+0x24e>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010ea00:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea03:	68 88 9d 12 f0       	push   $0xf0129d88
f010ea08:	68 a1 00 00 00       	push   $0xa1
f010ea0d:	68 67 9c 12 f0       	push   $0xf0129c67
f010ea12:	e8 03 19 ff ff       	call   f010031a <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010ea17:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea1a:	8b 80 40 da 01 00    	mov    0x1da40(%eax),%eax
f010ea20:	8d 50 01             	lea    0x1(%eax),%edx
f010ea23:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea26:	89 90 40 da 01 00    	mov    %edx,0x1da40(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010ea2c:	e8 76 fd ff ff       	call   f010e7a7 <isBufferingEnabled>
f010ea31:	84 c0                	test   %al,%al
f010ea33:	74 13                	je     f010ea48 <fault_handler+0x27f>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010ea35:	83 ec 08             	sub    $0x8,%esp
f010ea38:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea3b:	ff 75 e0             	pushl  -0x20(%ebp)
f010ea3e:	e8 64 00 00 00       	call   f010eaa7 <__page_fault_handler_with_buffering>
f010ea43:	83 c4 10             	add    $0x10,%esp
f010ea46:	eb 11                	jmp    f010ea59 <fault_handler+0x290>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010ea48:	83 ec 08             	sub    $0x8,%esp
f010ea4b:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea4e:	ff 75 e0             	pushl  -0x20(%ebp)
f010ea51:	e8 34 00 00 00       	call   f010ea8a <page_fault_handler>
f010ea56:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010ea59:	0f 20 d8             	mov    %cr3,%eax
f010ea5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010ea5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ea62:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010ea65:	90                   	nop
f010ea66:	c9                   	leave  
f010ea67:	c3                   	ret    

f010ea68 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010ea68:	55                   	push   %ebp
f010ea69:	89 e5                	mov    %esp,%ebp
f010ea6b:	83 ec 18             	sub    $0x18,%esp
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
	}
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
f010ea6e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea71:	8b 40 64             	mov    0x64(%eax),%eax
f010ea74:	83 ec 04             	sub    $0x4,%esp
f010ea77:	8d 55 f4             	lea    -0xc(%ebp),%edx
f010ea7a:	52                   	push   %edx
f010ea7b:	ff 75 0c             	pushl  0xc(%ebp)
f010ea7e:	50                   	push   %eax
f010ea7f:	e8 84 9a ff ff       	call   f0108508 <__static_cpt>
f010ea84:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f010ea87:	90                   	nop
f010ea88:	c9                   	leave  
f010ea89:	c3                   	ret    

f010ea8a <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010ea8a:	55                   	push   %ebp
f010ea8b:	89 e5                	mov    %esp,%ebp
f010ea8d:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24] [3] PAGE FAULT HANDLER
	// Write your code here, remove the panic and write your code
	panic("page_fault_handler() is not implemented yet...!!");
f010ea90:	83 ec 04             	sub    $0x4,%esp
f010ea93:	68 cc 9d 12 f0       	push   $0xf0129dcc
f010ea98:	68 db 00 00 00       	push   $0xdb
f010ea9d:	68 67 9c 12 f0       	push   $0xf0129c67
f010eaa2:	e8 73 18 ff ff       	call   f010031a <_panic>

f010eaa7 <__page_fault_handler_with_buffering>:
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010eaa7:	55                   	push   %ebp
f010eaa8:	89 e5                	mov    %esp,%ebp
f010eaaa:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010eaad:	83 ec 04             	sub    $0x4,%esp
f010eab0:	68 00 9e 12 f0       	push   $0xf0129e00
f010eab5:	68 fc 00 00 00       	push   $0xfc
f010eaba:	68 67 9c 12 f0       	push   $0xf0129c67
f010eabf:	e8 56 18 ff ff       	call   f010031a <_panic>

f010eac4 <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010eac4:	55                   	push   %ebp
f010eac5:	89 e5                	mov    %esp,%ebp
f010eac7:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010eaca:	8b 45 08             	mov    0x8(%ebp),%eax
f010eacd:	83 c0 04             	add    $0x4,%eax
f010ead0:	83 ec 08             	sub    $0x8,%esp
f010ead3:	ff 75 0c             	pushl  0xc(%ebp)
f010ead6:	50                   	push   %eax
f010ead7:	e8 7f 39 01 00       	call   f012245b <strcpy>
f010eadc:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010eadf:	8b 45 08             	mov    0x8(%ebp),%eax
f010eae2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010eae8:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaeb:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010eaf2:	90                   	nop
f010eaf3:	c9                   	leave  
f010eaf4:	c3                   	ret    

f010eaf5 <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010eaf5:	55                   	push   %ebp
f010eaf6:	89 e5                	mov    %esp,%ebp
f010eaf8:	53                   	push   %ebx
f010eaf9:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010eafc:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaff:	83 ec 0c             	sub    $0xc,%esp
f010eb02:	50                   	push   %eax
f010eb03:	e8 06 02 00 00       	call   f010ed0e <holding_spinlock>
f010eb08:	83 c4 10             	add    $0x10,%esp
f010eb0b:	85 c0                	test   %eax,%eax
f010eb0d:	74 18                	je     f010eb27 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010eb0f:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb12:	83 c0 04             	add    $0x4,%eax
f010eb15:	50                   	push   %eax
f010eb16:	68 44 9e 12 f0       	push   $0xf0129e44
f010eb1b:	6a 1f                	push   $0x1f
f010eb1d:	68 81 9e 12 f0       	push   $0xf0129e81
f010eb22:	e8 f3 17 ff ff       	call   f010031a <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010eb27:	e8 69 86 ff ff       	call   f0107195 <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010eb2c:	90                   	nop
f010eb2d:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb30:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010eb33:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010eb3a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010eb3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eb40:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010eb43:	f0 87 02             	lock xchg %eax,(%edx)
f010eb46:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010eb49:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eb4c:	85 c0                	test   %eax,%eax
f010eb4e:	75 dd                	jne    f010eb2d <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010eb50:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010eb55:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010eb58:	e8 75 85 ff ff       	call   f01070d2 <mycpu>
f010eb5d:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010eb60:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb63:	83 c0 48             	add    $0x48,%eax
f010eb66:	83 ec 08             	sub    $0x8,%esp
f010eb69:	50                   	push   %eax
f010eb6a:	8d 45 08             	lea    0x8(%ebp),%eax
f010eb6d:	50                   	push   %eax
f010eb6e:	e8 74 00 00 00       	call   f010ebe7 <getcallerpcs>
f010eb73:	83 c4 10             	add    $0x10,%esp

}
f010eb76:	90                   	nop
f010eb77:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010eb7a:	c9                   	leave  
f010eb7b:	c3                   	ret    

f010eb7c <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010eb7c:	55                   	push   %ebp
f010eb7d:	89 e5                	mov    %esp,%ebp
f010eb7f:	83 ec 08             	sub    $0x8,%esp
	if(!holding_spinlock(lk))
f010eb82:	83 ec 0c             	sub    $0xc,%esp
f010eb85:	ff 75 08             	pushl  0x8(%ebp)
f010eb88:	e8 81 01 00 00       	call   f010ed0e <holding_spinlock>
f010eb8d:	83 c4 10             	add    $0x10,%esp
f010eb90:	85 c0                	test   %eax,%eax
f010eb92:	75 26                	jne    f010ebba <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010eb94:	83 ec 0c             	sub    $0xc,%esp
f010eb97:	ff 75 08             	pushl  0x8(%ebp)
f010eb9a:	e8 08 01 00 00       	call   f010eca7 <printcallstack>
f010eb9f:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010eba2:	8b 45 08             	mov    0x8(%ebp),%eax
f010eba5:	83 c0 04             	add    $0x4,%eax
f010eba8:	50                   	push   %eax
f010eba9:	68 98 9e 12 f0       	push   $0xf0129e98
f010ebae:	6a 3b                	push   $0x3b
f010ebb0:	68 81 9e 12 f0       	push   $0xf0129e81
f010ebb5:	e8 60 17 ff ff       	call   f010031a <_panic>
	}
	lk->pcs[0] = 0;
f010ebba:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebbd:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010ebc4:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebc7:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010ebce:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010ebd3:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebd6:	8b 55 08             	mov    0x8(%ebp),%edx
f010ebd9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010ebdf:	e8 03 86 ff ff       	call   f01071e7 <popcli>
}
f010ebe4:	90                   	nop
f010ebe5:	c9                   	leave  
f010ebe6:	c3                   	ret    

f010ebe7 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010ebe7:	55                   	push   %ebp
f010ebe8:	89 e5                	mov    %esp,%ebp
f010ebea:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010ebed:	e8 53 bb ff ff       	call   f010a745 <get_cpu_proc>
f010ebf2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010ebf5:	e8 d8 84 ff ff       	call   f01070d2 <mycpu>
f010ebfa:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010ebfd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec00:	83 e8 08             	sub    $0x8,%eax
f010ec03:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010ec06:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010ec0d:	eb 67                	jmp    f010ec76 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010ec0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec13:	74 67                	je     f010ec7c <getcallerpcs+0x95>
f010ec15:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010ec1c:	76 5e                	jbe    f010ec7c <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010ec1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ec21:	8b 40 08             	mov    0x8(%eax),%eax
f010ec24:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010ec29:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ec2c:	77 10                	ja     f010ec3e <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010ec2e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ec31:	8b 40 08             	mov    0x8(%eax),%eax
f010ec34:	05 00 90 00 00       	add    $0x9000,%eax
f010ec39:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ec3c:	77 3e                	ja     f010ec7c <getcallerpcs+0x95>
f010ec3e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ec42:	74 10                	je     f010ec54 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010ec44:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ec47:	8b 40 70             	mov    0x70(%eax),%eax
f010ec4a:	05 00 80 00 00       	add    $0x8000,%eax
f010ec4f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ec52:	76 28                	jbe    f010ec7c <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010ec54:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec57:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ec5e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec61:	01 c2                	add    %eax,%edx
f010ec63:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec66:	8b 40 04             	mov    0x4(%eax),%eax
f010ec69:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010ec6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec6e:	8b 00                	mov    (%eax),%eax
f010ec70:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010ec73:	ff 45 f0             	incl   -0x10(%ebp)
f010ec76:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010ec7a:	7e 93                	jle    f010ec0f <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010ec7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec7f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010ec82:	eb 18                	jmp    f010ec9c <getcallerpcs+0xb5>
		pcs[i] = 0;
f010ec84:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec87:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ec8e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec91:	01 d0                	add    %edx,%eax
f010ec93:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010ec99:	ff 45 f0             	incl   -0x10(%ebp)
f010ec9c:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010eca0:	7e e2                	jle    f010ec84 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010eca2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010eca5:	c9                   	leave  
f010eca6:	c3                   	ret    

f010eca7 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010eca7:	55                   	push   %ebp
f010eca8:	89 e5                	mov    %esp,%ebp
f010ecaa:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010ecad:	83 ec 0c             	sub    $0xc,%esp
f010ecb0:	68 d6 9e 12 f0       	push   $0xf0129ed6
f010ecb5:	e8 b2 22 ff ff       	call   f0100f6c <cprintf>
f010ecba:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010ecbd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ecc0:	83 c0 48             	add    $0x48,%eax
f010ecc3:	83 ec 08             	sub    $0x8,%esp
f010ecc6:	50                   	push   %eax
f010ecc7:	8d 45 08             	lea    0x8(%ebp),%eax
f010ecca:	50                   	push   %eax
f010eccb:	e8 17 ff ff ff       	call   f010ebe7 <getcallerpcs>
f010ecd0:	83 c4 10             	add    $0x10,%esp
f010ecd3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010ecd6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ecdd:	eb 24                	jmp    f010ed03 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010ecdf:	8b 45 08             	mov    0x8(%ebp),%eax
f010ece2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ece5:	83 c2 10             	add    $0x10,%edx
f010ece8:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010ecec:	83 ec 04             	sub    $0x4,%esp
f010ecef:	50                   	push   %eax
f010ecf0:	ff 75 f4             	pushl  -0xc(%ebp)
f010ecf3:	68 e6 9e 12 f0       	push   $0xf0129ee6
f010ecf8:	e8 6f 22 ff ff       	call   f0100f6c <cprintf>
f010ecfd:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010ed00:	ff 45 f4             	incl   -0xc(%ebp)
f010ed03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed06:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ed09:	7c d4                	jl     f010ecdf <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010ed0b:	90                   	nop
f010ed0c:	c9                   	leave  
f010ed0d:	c3                   	ret    

f010ed0e <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010ed0e:	55                   	push   %ebp
f010ed0f:	89 e5                	mov    %esp,%ebp
f010ed11:	53                   	push   %ebx
f010ed12:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010ed15:	e8 7b 84 ff ff       	call   f0107195 <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010ed1a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed1d:	8b 00                	mov    (%eax),%eax
f010ed1f:	85 c0                	test   %eax,%eax
f010ed21:	74 16                	je     f010ed39 <holding_spinlock+0x2b>
f010ed23:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed26:	8b 58 44             	mov    0x44(%eax),%ebx
f010ed29:	e8 a4 83 ff ff       	call   f01070d2 <mycpu>
f010ed2e:	39 c3                	cmp    %eax,%ebx
f010ed30:	75 07                	jne    f010ed39 <holding_spinlock+0x2b>
f010ed32:	b8 01 00 00 00       	mov    $0x1,%eax
f010ed37:	eb 05                	jmp    f010ed3e <holding_spinlock+0x30>
f010ed39:	b8 00 00 00 00       	mov    $0x0,%eax
f010ed3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010ed41:	e8 a1 84 ff ff       	call   f01071e7 <popcli>
	return r;
f010ed46:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ed49:	83 c4 14             	add    $0x14,%esp
f010ed4c:	5b                   	pop    %ebx
f010ed4d:	5d                   	pop    %ebp
f010ed4e:	c3                   	ret    

f010ed4f <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010ed4f:	55                   	push   %ebp
f010ed50:	89 e5                	mov    %esp,%ebp
f010ed52:	83 ec 08             	sub    $0x8,%esp
	init_channel(&(lk->chan), "sleep lock channel");
f010ed55:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed58:	83 c0 74             	add    $0x74,%eax
f010ed5b:	83 ec 08             	sub    $0x8,%esp
f010ed5e:	68 f8 9e 12 f0       	push   $0xf0129ef8
f010ed63:	50                   	push   %eax
f010ed64:	e8 de 00 00 00       	call   f010ee47 <init_channel>
f010ed69:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010ed6c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed6f:	83 c0 04             	add    $0x4,%eax
f010ed72:	83 ec 08             	sub    $0x8,%esp
f010ed75:	68 0b 9f 12 f0       	push   $0xf0129f0b
f010ed7a:	50                   	push   %eax
f010ed7b:	e8 44 fd ff ff       	call   f010eac4 <init_spinlock>
f010ed80:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010ed83:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed86:	05 c4 00 00 00       	add    $0xc4,%eax
f010ed8b:	83 ec 08             	sub    $0x8,%esp
f010ed8e:	ff 75 0c             	pushl  0xc(%ebp)
f010ed91:	50                   	push   %eax
f010ed92:	e8 c4 36 01 00       	call   f012245b <strcpy>
f010ed97:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010ed9a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed9d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010eda3:	8b 45 08             	mov    0x8(%ebp),%eax
f010eda6:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010edad:	00 00 00 
}
f010edb0:	90                   	nop
f010edb1:	c9                   	leave  
f010edb2:	c3                   	ret    

f010edb3 <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk)
{
f010edb3:	55                   	push   %ebp
f010edb4:	89 e5                	mov    %esp,%ebp
f010edb6:	53                   	push   %ebx
f010edb7:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010edba:	8b 45 08             	mov    0x8(%ebp),%eax
f010edbd:	83 c0 04             	add    $0x4,%eax
f010edc0:	83 ec 0c             	sub    $0xc,%esp
f010edc3:	50                   	push   %eax
f010edc4:	e8 2c fd ff ff       	call   f010eaf5 <acquire_spinlock>
f010edc9:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010edcc:	8b 45 08             	mov    0x8(%ebp),%eax
f010edcf:	8b 00                	mov    (%eax),%eax
f010edd1:	85 c0                	test   %eax,%eax
f010edd3:	74 1c                	je     f010edf1 <holding_sleeplock+0x3e>
f010edd5:	8b 45 08             	mov    0x8(%ebp),%eax
f010edd8:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010edde:	e8 62 b9 ff ff       	call   f010a745 <get_cpu_proc>
f010ede3:	8b 40 10             	mov    0x10(%eax),%eax
f010ede6:	39 c3                	cmp    %eax,%ebx
f010ede8:	75 07                	jne    f010edf1 <holding_sleeplock+0x3e>
f010edea:	b8 01 00 00 00       	mov    $0x1,%eax
f010edef:	eb 05                	jmp    f010edf6 <holding_sleeplock+0x43>
f010edf1:	b8 00 00 00 00       	mov    $0x0,%eax
f010edf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010edf9:	8b 45 08             	mov    0x8(%ebp),%eax
f010edfc:	83 c0 04             	add    $0x4,%eax
f010edff:	83 ec 0c             	sub    $0xc,%esp
f010ee02:	50                   	push   %eax
f010ee03:	e8 74 fd ff ff       	call   f010eb7c <release_spinlock>
f010ee08:	83 c4 10             	add    $0x10,%esp
	return r;
f010ee0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ee0e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ee11:	c9                   	leave  
f010ee12:	c3                   	ret    

f010ee13 <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010ee13:	55                   	push   %ebp
f010ee14:	89 e5                	mov    %esp,%ebp
f010ee16:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("acquire_sleeplock is not implemented yet");
f010ee19:	83 ec 04             	sub    $0x4,%esp
f010ee1c:	68 20 9f 12 f0       	push   $0xf0129f20
f010ee21:	6a 25                	push   $0x25
f010ee23:	68 49 9f 12 f0       	push   $0xf0129f49
f010ee28:	e8 ed 14 ff ff       	call   f010031a <_panic>

f010ee2d <release_sleeplock>:
	//Your Code is Here...

}

void release_sleeplock(struct sleeplock *lk)
{
f010ee2d:	55                   	push   %ebp
f010ee2e:	89 e5                	mov    %esp,%ebp
f010ee30:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("release_sleeplock is not implemented yet");
f010ee33:	83 ec 04             	sub    $0x4,%esp
f010ee36:	68 60 9f 12 f0       	push   $0xf0129f60
f010ee3b:	6a 2e                	push   $0x2e
f010ee3d:	68 49 9f 12 f0       	push   $0xf0129f49
f010ee42:	e8 d3 14 ff ff       	call   f010031a <_panic>

f010ee47 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f010ee47:	55                   	push   %ebp
f010ee48:	89 e5                	mov    %esp,%ebp
f010ee4a:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f010ee4d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee50:	83 c0 10             	add    $0x10,%eax
f010ee53:	83 ec 08             	sub    $0x8,%esp
f010ee56:	ff 75 0c             	pushl  0xc(%ebp)
f010ee59:	50                   	push   %eax
f010ee5a:	e8 fc 35 01 00       	call   f012245b <strcpy>
f010ee5f:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f010ee62:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee65:	83 ec 0c             	sub    $0xc,%esp
f010ee68:	50                   	push   %eax
f010ee69:	e8 9e 60 ff ff       	call   f0104f0c <init_queue>
f010ee6e:	83 c4 10             	add    $0x10,%esp
}
f010ee71:	90                   	nop
f010ee72:	c9                   	leave  
f010ee73:	c3                   	ret    

f010ee74 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f010ee74:	55                   	push   %ebp
f010ee75:	89 e5                	mov    %esp,%ebp
f010ee77:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("sleep is not implemented yet");
f010ee7a:	83 ec 04             	sub    $0x4,%esp
f010ee7d:	68 8c 9f 12 f0       	push   $0xf0129f8c
f010ee82:	6a 21                	push   $0x21
f010ee84:	68 a9 9f 12 f0       	push   $0xf0129fa9
f010ee89:	e8 8c 14 ff ff       	call   f010031a <_panic>

f010ee8e <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f010ee8e:	55                   	push   %ebp
f010ee8f:	89 e5                	mov    %esp,%ebp
f010ee91:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wakeup_one is not implemented yet");
f010ee94:	83 ec 04             	sub    $0x4,%esp
f010ee97:	68 c0 9f 12 f0       	push   $0xf0129fc0
f010ee9c:	6a 31                	push   $0x31
f010ee9e:	68 a9 9f 12 f0       	push   $0xf0129fa9
f010eea3:	e8 72 14 ff ff       	call   f010031a <_panic>

f010eea8 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f010eea8:	55                   	push   %ebp
f010eea9:	89 e5                	mov    %esp,%ebp
f010eeab:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wakeup_all is not implemented yet");
f010eeae:	83 ec 04             	sub    $0x4,%esp
f010eeb1:	68 e4 9f 12 f0       	push   $0xf0129fe4
f010eeb6:	6a 41                	push   $0x41
f010eeb8:	68 a9 9f 12 f0       	push   $0xf0129fa9
f010eebd:	e8 58 14 ff ff       	call   f010031a <_panic>

f010eec2 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f010eec2:	55                   	push   %ebp
f010eec3:	89 e5                	mov    %esp,%ebp
f010eec5:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f010eec8:	83 ec 04             	sub    $0x4,%esp
f010eecb:	68 08 a0 12 f0       	push   $0xf012a008
f010eed0:	6a 13                	push   $0x13
f010eed2:	68 2f a0 12 f0       	push   $0xf012a02f
f010eed7:	e8 3e 14 ff ff       	call   f010031a <_panic>

f010eedc <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f010eedc:	55                   	push   %ebp
f010eedd:	89 e5                	mov    %esp,%ebp
f010eedf:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f010eee2:	83 ec 04             	sub    $0x4,%esp
f010eee5:	68 48 a0 12 f0       	push   $0xf012a048
f010eeea:	6a 1b                	push   $0x1b
f010eeec:	68 2f a0 12 f0       	push   $0xf012a02f
f010eef1:	e8 24 14 ff ff       	call   f010031a <_panic>

f010eef6 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f010eef6:	55                   	push   %ebp
f010eef7:	89 e5                	mov    %esp,%ebp
f010eef9:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f010eefc:	83 ec 04             	sub    $0x4,%esp
f010eeff:	68 70 a0 12 f0       	push   $0xf012a070
f010ef04:	6a 24                	push   $0x24
f010ef06:	68 2f a0 12 f0       	push   $0xf012a02f
f010ef0b:	e8 0a 14 ff ff       	call   f010031a <_panic>

f010ef10 <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010ef10:	55                   	push   %ebp
f010ef11:	89 e5                	mov    %esp,%ebp
f010ef13:	c7 05 50 49 5a f0 01 	movl   $0x1,0xf05a4950
f010ef1a:	00 00 00 
f010ef1d:	90                   	nop
f010ef1e:	5d                   	pop    %ebp
f010ef1f:	c3                   	ret    

f010ef20 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f010ef20:	55                   	push   %ebp
f010ef21:	89 e5                	mov    %esp,%ebp
f010ef23:	c7 05 50 49 5a f0 02 	movl   $0x2,0xf05a4950
f010ef2a:	00 00 00 
f010ef2d:	90                   	nop
f010ef2e:	5d                   	pop    %ebp
f010ef2f:	c3                   	ret    

f010ef30 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f010ef30:	55                   	push   %ebp
f010ef31:	89 e5                	mov    %esp,%ebp
f010ef33:	c7 05 50 49 5a f0 03 	movl   $0x3,0xf05a4950
f010ef3a:	00 00 00 
f010ef3d:	90                   	nop
f010ef3e:	5d                   	pop    %ebp
f010ef3f:	c3                   	ret    

f010ef40 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010ef40:	55                   	push   %ebp
f010ef41:	89 e5                	mov    %esp,%ebp
f010ef43:	a1 50 49 5a f0       	mov    0xf05a4950,%eax
f010ef48:	83 f8 01             	cmp    $0x1,%eax
f010ef4b:	75 04                	jne    f010ef51 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f010ef4d:	b0 01                	mov    $0x1,%al
f010ef4f:	eb 02                	jmp    f010ef53 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010ef51:	b0 00                	mov    $0x0,%al
f010ef53:	5d                   	pop    %ebp
f010ef54:	c3                   	ret    

f010ef55 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010ef55:	55                   	push   %ebp
f010ef56:	89 e5                	mov    %esp,%ebp
f010ef58:	a1 50 49 5a f0       	mov    0xf05a4950,%eax
f010ef5d:	83 f8 02             	cmp    $0x2,%eax
f010ef60:	75 04                	jne    f010ef66 <isKHeapPlacementStrategyBESTFIT+0x11>
f010ef62:	b0 01                	mov    $0x1,%al
f010ef64:	eb 02                	jmp    f010ef68 <isKHeapPlacementStrategyBESTFIT+0x13>
f010ef66:	b0 00                	mov    $0x0,%al
f010ef68:	5d                   	pop    %ebp
f010ef69:	c3                   	ret    

f010ef6a <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f010ef6a:	55                   	push   %ebp
f010ef6b:	89 e5                	mov    %esp,%ebp
f010ef6d:	a1 50 49 5a f0       	mov    0xf05a4950,%eax
f010ef72:	83 f8 03             	cmp    $0x3,%eax
f010ef75:	75 04                	jne    f010ef7b <isKHeapPlacementStrategyNEXTFIT+0x11>
f010ef77:	b0 01                	mov    $0x1,%al
f010ef79:	eb 02                	jmp    f010ef7d <isKHeapPlacementStrategyNEXTFIT+0x13>
f010ef7b:	b0 00                	mov    $0x0,%al
f010ef7d:	5d                   	pop    %ebp
f010ef7e:	c3                   	ret    

f010ef7f <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f010ef7f:	55                   	push   %ebp
f010ef80:	89 e5                	mov    %esp,%ebp
f010ef82:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010ef85:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ef8c:	eb 26                	jmp    f010efb4 <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f010ef8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ef91:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ef98:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef9b:	01 c2                	add    %eax,%edx
f010ef9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010efa0:	40                   	inc    %eax
f010efa1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010efa8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efab:	01 c8                	add    %ecx,%eax
f010efad:	8b 00                	mov    (%eax),%eax
f010efaf:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010efb1:	ff 45 f4             	incl   -0xc(%ebp)
f010efb4:	8b 45 08             	mov    0x8(%ebp),%eax
f010efb7:	48                   	dec    %eax
f010efb8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010efbb:	7f d1                	jg     f010ef8e <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f010efbd:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f010efc0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010efc7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010efce:	eb 35                	jmp    f010f005 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f010efd0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010efd3:	89 d0                	mov    %edx,%eax
f010efd5:	01 c0                	add    %eax,%eax
f010efd7:	01 d0                	add    %edx,%eax
f010efd9:	c1 e0 02             	shl    $0x2,%eax
f010efdc:	05 00 0d 18 f0       	add    $0xf0180d00,%eax
f010efe1:	8b 10                	mov    (%eax),%edx
f010efe3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efe6:	8b 00                	mov    (%eax),%eax
f010efe8:	83 ec 08             	sub    $0x8,%esp
f010efeb:	52                   	push   %edx
f010efec:	50                   	push   %eax
f010efed:	e8 26 35 01 00       	call   f0122518 <strcmp>
f010eff2:	83 c4 10             	add    $0x10,%esp
f010eff5:	85 c0                	test   %eax,%eax
f010eff7:	75 09                	jne    f010f002 <tst_handler+0x83>
		{
			test_found = 1;
f010eff9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f010f000:	eb 0f                	jmp    f010f011 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010f002:	ff 45 ec             	incl   -0x14(%ebp)
f010f005:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f008:	a1 b4 0d 18 f0       	mov    0xf0180db4,%eax
f010f00d:	39 c2                	cmp    %eax,%edx
f010f00f:	72 bf                	jb     f010efd0 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f010f011:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f015:	74 29                	je     f010f040 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f010f017:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f01a:	89 d0                	mov    %edx,%eax
f010f01c:	01 c0                	add    %eax,%eax
f010f01e:	01 d0                	add    %edx,%eax
f010f020:	c1 e0 02             	shl    $0x2,%eax
f010f023:	05 08 0d 18 f0       	add    $0xf0180d08,%eax
f010f028:	8b 00                	mov    (%eax),%eax
f010f02a:	83 ec 08             	sub    $0x8,%esp
f010f02d:	ff 75 0c             	pushl  0xc(%ebp)
f010f030:	ff 75 08             	pushl  0x8(%ebp)
f010f033:	ff d0                	call   *%eax
f010f035:	83 c4 10             	add    $0x10,%esp
f010f038:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f010f03b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f03e:	eb 1b                	jmp    f010f05b <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f010f040:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f043:	8b 00                	mov    (%eax),%eax
f010f045:	83 ec 08             	sub    $0x8,%esp
f010f048:	50                   	push   %eax
f010f049:	68 b0 a3 12 f0       	push   $0xf012a3b0
f010f04e:	e8 19 1f ff ff       	call   f0100f6c <cprintf>
f010f053:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f056:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f010f05b:	c9                   	leave  
f010f05c:	c3                   	ret    

f010f05d <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f010f05d:	55                   	push   %ebp
f010f05e:	89 e5                	mov    %esp,%ebp
f010f060:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f010f063:	e8 34 0b 01 00       	call   f011fb9c <test_three_creation_functions>
	return 0;
f010f068:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f06d:	c9                   	leave  
f010f06e:	c3                   	ret    

f010f06f <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f010f06f:	55                   	push   %ebp
f010f070:	89 e5                	mov    %esp,%ebp
f010f072:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f010f075:	e8 76 9a 00 00       	call   f0118af0 <test_priority_normal_and_higher>
	return 0;
f010f07a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f07f:	c9                   	leave  
f010f080:	c3                   	ret    

f010f081 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f010f081:	55                   	push   %ebp
f010f082:	89 e5                	mov    %esp,%ebp
f010f084:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f010f087:	e8 ce a4 00 00       	call   f011955a <test_priority_normal_and_lower>
	return 0;
f010f08c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f091:	c9                   	leave  
f010f092:	c3                   	ret    

f010f093 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f010f093:	55                   	push   %ebp
f010f094:	89 e5                	mov    %esp,%ebp
f010f096:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f010f099:	e8 b6 0c 01 00       	call   f011fd54 <test_kfreeall>
	return 0;
f010f09e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f0a3:	c9                   	leave  
f010f0a4:	c3                   	ret    

f010f0a5 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f010f0a5:	55                   	push   %ebp
f010f0a6:	89 e5                	mov    %esp,%ebp
f010f0a8:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f010f0ab:	e8 c1 0c 01 00       	call   f011fd71 <test_kexpand>
	return 0;
f010f0b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f0b5:	c9                   	leave  
f010f0b6:	c3                   	ret    

f010f0b7 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f010f0b7:	55                   	push   %ebp
f010f0b8:	89 e5                	mov    %esp,%ebp
f010f0ba:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f010f0bd:	e8 cc 0c 01 00       	call   f011fd8e <test_kshrink>
	return 0;
f010f0c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f0c7:	c9                   	leave  
f010f0c8:	c3                   	ret    

f010f0c9 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f010f0c9:	55                   	push   %ebp
f010f0ca:	89 e5                	mov    %esp,%ebp
f010f0cc:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f010f0cf:	e8 d7 0c 01 00       	call   f011fdab <test_kfreelast>
	return 0;
f010f0d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f0d9:	c9                   	leave  
f010f0da:	c3                   	ret    

f010f0db <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f010f0db:	55                   	push   %ebp
f010f0dc:	89 e5                	mov    %esp,%ebp
f010f0de:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f010f0e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0e4:	83 c0 04             	add    $0x4,%eax
f010f0e7:	8b 00                	mov    (%eax),%eax
f010f0e9:	83 ec 04             	sub    $0x4,%esp
f010f0ec:	6a 0a                	push   $0xa
f010f0ee:	6a 00                	push   $0x0
f010f0f0:	50                   	push   %eax
f010f0f1:	e8 76 36 01 00       	call   f012276c <strtol>
f010f0f6:	83 c4 10             	add    $0x10,%esp
f010f0f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f010f0fc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f010f103:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f010f10a:	83 ec 0c             	sub    $0xc,%esp
f010f10d:	68 00 1e 5a f0       	push   $0xf05a1e00
f010f112:	e8 de f9 ff ff       	call   f010eaf5 <acquire_spinlock>
f010f117:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010f11a:	a1 80 1e 5a f0       	mov    0xf05a1e80,%eax
f010f11f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f122:	eb 3b                	jmp    f010f15f <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f010f124:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f127:	83 c0 20             	add    $0x20,%eax
f010f12a:	83 ec 08             	sub    $0x8,%esp
f010f12d:	68 c3 a3 12 f0       	push   $0xf012a3c3
f010f132:	50                   	push   %eax
f010f133:	e8 e0 33 01 00       	call   f0122518 <strcmp>
f010f138:	83 c4 10             	add    $0x10,%esp
f010f13b:	85 c0                	test   %eax,%eax
f010f13d:	75 12                	jne    f010f151 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f010f13f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f143:	74 07                	je     f010f14c <tst_sc_MLFQ+0x71>
					firstTime = 0;
f010f145:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f010f14c:	ff 45 f4             	incl   -0xc(%ebp)
f010f14f:	eb 06                	jmp    f010f157 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f010f151:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f155:	74 31                	je     f010f188 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010f157:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f010f15c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f15f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f163:	74 08                	je     f010f16d <tst_sc_MLFQ+0x92>
f010f165:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f168:	8b 40 08             	mov    0x8(%eax),%eax
f010f16b:	eb 05                	jmp    f010f172 <tst_sc_MLFQ+0x97>
f010f16d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f172:	a3 88 1e 5a f0       	mov    %eax,0xf05a1e88
f010f177:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f010f17c:	85 c0                	test   %eax,%eax
f010f17e:	75 a4                	jne    f010f124 <tst_sc_MLFQ+0x49>
f010f180:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f184:	75 9e                	jne    f010f124 <tst_sc_MLFQ+0x49>
f010f186:	eb 01                	jmp    f010f189 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f010f188:	90                   	nop
			}
		if(cnt == numOfSlave2)
f010f189:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f18c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f18f:	75 12                	jne    f010f1a3 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f010f191:	83 ec 0c             	sub    $0xc,%esp
f010f194:	68 cc a3 12 f0       	push   $0xf012a3cc
f010f199:	e8 ce 1d ff ff       	call   f0100f6c <cprintf>
f010f19e:	83 c4 10             	add    $0x10,%esp
f010f1a1:	eb 17                	jmp    f010f1ba <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f010f1a3:	83 ec 04             	sub    $0x4,%esp
f010f1a6:	68 05 a4 12 f0       	push   $0xf012a405
f010f1ab:	68 9b 00 00 00       	push   $0x9b
f010f1b0:	68 1b a4 12 f0       	push   $0xf012a41b
f010f1b5:	e8 60 11 ff ff       	call   f010031a <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f010f1ba:	83 ec 0c             	sub    $0xc,%esp
f010f1bd:	68 00 1e 5a f0       	push   $0xf05a1e00
f010f1c2:	e8 b5 f9 ff ff       	call   f010eb7c <release_spinlock>
f010f1c7:	83 c4 10             	add    $0x10,%esp
	return 0;
f010f1ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f1cf:	c9                   	leave  
f010f1d0:	c3                   	ret    

f010f1d1 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f010f1d1:	55                   	push   %ebp
f010f1d2:	89 e5                	mov    %esp,%ebp
f010f1d4:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f010f1d7:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f1db:	74 17                	je     f010f1f4 <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f010f1dd:	83 ec 0c             	sub    $0xc,%esp
f010f1e0:	68 34 a4 12 f0       	push   $0xf012a434
f010f1e5:	e8 82 1d ff ff       	call   f0100f6c <cprintf>
f010f1ea:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1ed:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1f2:	eb 45                	jmp    f010f239 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f010f1f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1f7:	83 c0 04             	add    $0x4,%eax
f010f1fa:	8b 00                	mov    (%eax),%eax
f010f1fc:	83 ec 04             	sub    $0x4,%esp
f010f1ff:	6a 0a                	push   $0xa
f010f201:	6a 00                	push   $0x0
f010f203:	50                   	push   %eax
f010f204:	e8 63 35 01 00       	call   f012276c <strtol>
f010f209:	83 c4 10             	add    $0x10,%esp
f010f20c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f010f20f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f212:	83 f8 01             	cmp    $0x1,%eax
f010f215:	74 10                	je     f010f227 <tst_bsd_nice+0x56>
f010f217:	83 f8 02             	cmp    $0x2,%eax
f010f21a:	74 12                	je     f010f22e <tst_bsd_nice+0x5d>
f010f21c:	85 c0                	test   %eax,%eax
f010f21e:	75 14                	jne    f010f234 <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f010f220:	e8 79 0e 01 00       	call   f012009e <test_bsd_nice_0>
		break;
f010f225:	eb 0d                	jmp    f010f234 <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f010f227:	e8 fc 10 01 00       	call   f0120328 <test_bsd_nice_1>
		break;
f010f22c:	eb 06                	jmp    f010f234 <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f010f22e:	e8 09 13 01 00       	call   f012053c <test_bsd_nice_2>
		break;
f010f233:	90                   	nop
	}
	return 0;
f010f234:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f239:	c9                   	leave  
f010f23a:	c3                   	ret    

f010f23b <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f010f23b:	55                   	push   %ebp
f010f23c:	89 e5                	mov    %esp,%ebp
f010f23e:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f010f241:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f245:	74 17                	je     f010f25e <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f010f247:	83 ec 0c             	sub    $0xc,%esp
f010f24a:	68 74 a4 12 f0       	push   $0xf012a474
f010f24f:	e8 18 1d ff ff       	call   f0100f6c <cprintf>
f010f254:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f257:	b8 00 00 00 00       	mov    $0x0,%eax
f010f25c:	eb 0a                	jmp    f010f268 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f010f25e:	e8 67 43 00 00       	call   f01135ca <test_str2lower_function>
	return 0;
f010f263:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f268:	c9                   	leave  
f010f269:	c3                   	ret    

f010f26a <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f010f26a:	55                   	push   %ebp
f010f26b:	89 e5                	mov    %esp,%ebp
f010f26d:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f010f270:	e8 8b 3f 00 00       	call   f0113200 <TestAutoCompleteCommand>
f010f275:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f010f278:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f27d:	c9                   	leave  
f010f27e:	c3                   	ret    

f010f27f <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f010f27f:	55                   	push   %ebp
f010f280:	89 e5                	mov    %esp,%ebp
f010f282:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f285:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f289:	74 1a                	je     f010f2a5 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f010f28b:	83 ec 0c             	sub    $0xc,%esp
f010f28e:	68 a8 a4 12 f0       	push   $0xf012a4a8
f010f293:	e8 d4 1c ff ff       	call   f0100f6c <cprintf>
f010f298:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f29b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2a0:	e9 2f 01 00 00       	jmp    f010f3d4 <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f010f2a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2a8:	83 c0 04             	add    $0x4,%eax
f010f2ab:	8b 00                	mov    (%eax),%eax
f010f2ad:	83 ec 08             	sub    $0x8,%esp
f010f2b0:	68 e5 a4 12 f0       	push   $0xf012a4e5
f010f2b5:	50                   	push   %eax
f010f2b6:	e8 5d 32 01 00       	call   f0122518 <strcmp>
f010f2bb:	83 c4 10             	add    $0x10,%esp
f010f2be:	85 c0                	test   %eax,%eax
f010f2c0:	75 0a                	jne    f010f2cc <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f010f2c2:	e8 f4 07 00 00       	call   f010fabb <test_initialize_dynamic_allocator>
f010f2c7:	e9 03 01 00 00       	jmp    f010f3cf <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f010f2cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2cf:	83 c0 04             	add    $0x4,%eax
f010f2d2:	8b 00                	mov    (%eax),%eax
f010f2d4:	83 ec 08             	sub    $0x8,%esp
f010f2d7:	68 ea a4 12 f0       	push   $0xf012a4ea
f010f2dc:	50                   	push   %eax
f010f2dd:	e8 36 32 01 00       	call   f0122518 <strcmp>
f010f2e2:	83 c4 10             	add    $0x10,%esp
f010f2e5:	85 c0                	test   %eax,%eax
f010f2e7:	75 0a                	jne    f010f2f3 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f010f2e9:	e8 9d 0c 00 00       	call   f010ff8b <test_alloc_block_FF>
f010f2ee:	e9 dc 00 00 00       	jmp    f010f3cf <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f010f2f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2f6:	83 c0 04             	add    $0x4,%eax
f010f2f9:	8b 00                	mov    (%eax),%eax
f010f2fb:	83 ec 08             	sub    $0x8,%esp
f010f2fe:	68 f2 a4 12 f0       	push   $0xf012a4f2
f010f303:	50                   	push   %eax
f010f304:	e8 0f 32 01 00       	call   f0122518 <strcmp>
f010f309:	83 c4 10             	add    $0x10,%esp
f010f30c:	85 c0                	test   %eax,%eax
f010f30e:	75 0a                	jne    f010f31a <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f010f310:	e8 93 11 00 00       	call   f01104a8 <test_alloc_block_BF>
f010f315:	e9 b5 00 00 00       	jmp    f010f3cf <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f010f31a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f31d:	83 c0 04             	add    $0x4,%eax
f010f320:	8b 00                	mov    (%eax),%eax
f010f322:	83 ec 08             	sub    $0x8,%esp
f010f325:	68 fa a4 12 f0       	push   $0xf012a4fa
f010f32a:	50                   	push   %eax
f010f32b:	e8 e8 31 01 00       	call   f0122518 <strcmp>
f010f330:	83 c4 10             	add    $0x10,%esp
f010f333:	85 c0                	test   %eax,%eax
f010f335:	75 0a                	jne    f010f341 <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f010f337:	e8 ab 16 00 00       	call   f01109e7 <test_alloc_block_NF>
f010f33c:	e9 8e 00 00 00       	jmp    f010f3cf <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f010f341:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f344:	83 c0 04             	add    $0x4,%eax
f010f347:	8b 00                	mov    (%eax),%eax
f010f349:	83 ec 08             	sub    $0x8,%esp
f010f34c:	68 02 a5 12 f0       	push   $0xf012a502
f010f351:	50                   	push   %eax
f010f352:	e8 c1 31 01 00       	call   f0122518 <strcmp>
f010f357:	83 c4 10             	add    $0x10,%esp
f010f35a:	85 c0                	test   %eax,%eax
f010f35c:	75 07                	jne    f010f365 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f010f35e:	e8 8a 16 00 00       	call   f01109ed <test_free_block_FF>
f010f363:	eb 6a                	jmp    f010f3cf <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f010f365:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f368:	83 c0 04             	add    $0x4,%eax
f010f36b:	8b 00                	mov    (%eax),%eax
f010f36d:	83 ec 08             	sub    $0x8,%esp
f010f370:	68 09 a5 12 f0       	push   $0xf012a509
f010f375:	50                   	push   %eax
f010f376:	e8 9d 31 01 00       	call   f0122518 <strcmp>
f010f37b:	83 c4 10             	add    $0x10,%esp
f010f37e:	85 c0                	test   %eax,%eax
f010f380:	75 07                	jne    f010f389 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f010f382:	e8 cd 22 00 00       	call   f0111654 <test_free_block_BF>
f010f387:	eb 46                	jmp    f010f3cf <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f010f389:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f38c:	83 c0 04             	add    $0x4,%eax
f010f38f:	8b 00                	mov    (%eax),%eax
f010f391:	83 ec 08             	sub    $0x8,%esp
f010f394:	68 10 a5 12 f0       	push   $0xf012a510
f010f399:	50                   	push   %eax
f010f39a:	e8 79 31 01 00       	call   f0122518 <strcmp>
f010f39f:	83 c4 10             	add    $0x10,%esp
f010f3a2:	85 c0                	test   %eax,%eax
f010f3a4:	75 07                	jne    f010f3ad <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f010f3a6:	e8 20 2f 00 00       	call   f01122cb <test_free_block_NF>
f010f3ab:	eb 22                	jmp    f010f3cf <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f010f3ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3b0:	83 c0 04             	add    $0x4,%eax
f010f3b3:	8b 00                	mov    (%eax),%eax
f010f3b5:	83 ec 08             	sub    $0x8,%esp
f010f3b8:	68 17 a5 12 f0       	push   $0xf012a517
f010f3bd:	50                   	push   %eax
f010f3be:	e8 55 31 01 00       	call   f0122518 <strcmp>
f010f3c3:	83 c4 10             	add    $0x10,%esp
f010f3c6:	85 c0                	test   %eax,%eax
f010f3c8:	75 05                	jne    f010f3cf <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f010f3ca:	e8 19 2f 00 00       	call   f01122e8 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f010f3cf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f3d4:	c9                   	leave  
f010f3d5:	c3                   	ret    

f010f3d6 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f010f3d6:	55                   	push   %ebp
f010f3d7:	89 e5                	mov    %esp,%ebp
f010f3d9:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f3dc:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f3e0:	74 1a                	je     f010f3fc <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f010f3e2:	83 ec 0c             	sub    $0xc,%esp
f010f3e5:	68 24 a5 12 f0       	push   $0xf012a524
f010f3ea:	e8 7d 1b ff ff       	call   f0100f6c <cprintf>
f010f3ef:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f3f2:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3f7:	e9 e1 00 00 00       	jmp    f010f4dd <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f010f3fc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3ff:	83 c0 04             	add    $0x4,%eax
f010f402:	8b 00                	mov    (%eax),%eax
f010f404:	83 ec 08             	sub    $0x8,%esp
f010f407:	68 5d a5 12 f0       	push   $0xf012a55d
f010f40c:	50                   	push   %eax
f010f40d:	e8 06 31 01 00       	call   f0122518 <strcmp>
f010f412:	83 c4 10             	add    $0x10,%esp
f010f415:	85 c0                	test   %eax,%eax
f010f417:	75 0a                	jne    f010f423 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f010f419:	e8 bf 4a 00 00       	call   f0113edd <test_cut_paste_pages>
f010f41e:	e9 b5 00 00 00       	jmp    f010f4d8 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f010f423:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f426:	83 c0 04             	add    $0x4,%eax
f010f429:	8b 00                	mov    (%eax),%eax
f010f42b:	83 ec 08             	sub    $0x8,%esp
f010f42e:	68 66 a5 12 f0       	push   $0xf012a566
f010f433:	50                   	push   %eax
f010f434:	e8 df 30 01 00       	call   f0122518 <strcmp>
f010f439:	83 c4 10             	add    $0x10,%esp
f010f43c:	85 c0                	test   %eax,%eax
f010f43e:	75 0a                	jne    f010f44a <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f010f440:	e8 e3 54 00 00       	call   f0114928 <test_copy_paste_chunk>
f010f445:	e9 8e 00 00 00       	jmp    f010f4d8 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f010f44a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f44d:	83 c0 04             	add    $0x4,%eax
f010f450:	8b 00                	mov    (%eax),%eax
f010f452:	83 ec 08             	sub    $0x8,%esp
f010f455:	68 70 a5 12 f0       	push   $0xf012a570
f010f45a:	50                   	push   %eax
f010f45b:	e8 b8 30 01 00       	call   f0122518 <strcmp>
f010f460:	83 c4 10             	add    $0x10,%esp
f010f463:	85 c0                	test   %eax,%eax
f010f465:	75 07                	jne    f010f46e <tst_chunks+0x98>
	{
		test_share_chunk();
f010f467:	e8 ba 65 00 00       	call   f0115a26 <test_share_chunk>
f010f46c:	eb 6a                	jmp    f010f4d8 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f010f46e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f471:	83 c0 04             	add    $0x4,%eax
f010f474:	8b 00                	mov    (%eax),%eax
f010f476:	83 ec 08             	sub    $0x8,%esp
f010f479:	68 76 a5 12 f0       	push   $0xf012a576
f010f47e:	50                   	push   %eax
f010f47f:	e8 94 30 01 00       	call   f0122518 <strcmp>
f010f484:	83 c4 10             	add    $0x10,%esp
f010f487:	85 c0                	test   %eax,%eax
f010f489:	75 07                	jne    f010f492 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f010f48b:	e8 be 6f 00 00       	call   f011644e <test_allocate_chunk>
f010f490:	eb 46                	jmp    f010f4d8 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f010f492:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f495:	83 c0 04             	add    $0x4,%eax
f010f498:	8b 00                	mov    (%eax),%eax
f010f49a:	83 ec 08             	sub    $0x8,%esp
f010f49d:	68 7f a5 12 f0       	push   $0xf012a57f
f010f4a2:	50                   	push   %eax
f010f4a3:	e8 70 30 01 00       	call   f0122518 <strcmp>
f010f4a8:	83 c4 10             	add    $0x10,%esp
f010f4ab:	85 c0                	test   %eax,%eax
f010f4ad:	75 07                	jne    f010f4b6 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f010f4af:	e8 a1 78 00 00       	call   f0116d55 <test_calculate_required_frames>
f010f4b4:	eb 22                	jmp    f010f4d8 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f010f4b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4b9:	83 c0 04             	add    $0x4,%eax
f010f4bc:	8b 00                	mov    (%eax),%eax
f010f4be:	83 ec 08             	sub    $0x8,%esp
f010f4c1:	68 8e a5 12 f0       	push   $0xf012a58e
f010f4c6:	50                   	push   %eax
f010f4c7:	e8 4c 30 01 00       	call   f0122518 <strcmp>
f010f4cc:	83 c4 10             	add    $0x10,%esp
f010f4cf:	85 c0                	test   %eax,%eax
f010f4d1:	75 05                	jne    f010f4d8 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f010f4d3:	e8 f1 80 00 00       	call   f01175c9 <test_calculate_allocated_space>
	}
	return 0;
f010f4d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f4dd:	c9                   	leave  
f010f4de:	c3                   	ret    

f010f4df <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f010f4df:	55                   	push   %ebp
f010f4e0:	89 e5                	mov    %esp,%ebp
f010f4e2:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f4e5:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f4e9:	74 1a                	je     f010f505 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f010f4eb:	83 ec 0c             	sub    $0xc,%esp
f010f4ee:	68 a0 a5 12 f0       	push   $0xf012a5a0
f010f4f3:	e8 74 1a ff ff       	call   f0100f6c <cprintf>
f010f4f8:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f4fb:	b8 00 00 00 00       	mov    $0x0,%eax
f010f500:	e9 ba 00 00 00       	jmp    f010f5bf <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f010f505:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f508:	83 c0 04             	add    $0x4,%eax
f010f50b:	8b 00                	mov    (%eax),%eax
f010f50d:	83 ec 08             	sub    $0x8,%esp
f010f510:	68 d6 a5 12 f0       	push   $0xf012a5d6
f010f515:	50                   	push   %eax
f010f516:	e8 fd 2f 01 00       	call   f0122518 <strcmp>
f010f51b:	83 c4 10             	add    $0x10,%esp
f010f51e:	85 c0                	test   %eax,%eax
f010f520:	75 0a                	jne    f010f52c <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f010f522:	e8 29 44 00 00       	call   f0113950 <test_pt_set_page_permissions>
f010f527:	e9 8e 00 00 00       	jmp    f010f5ba <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f010f52c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f52f:	83 c0 04             	add    $0x4,%eax
f010f532:	8b 00                	mov    (%eax),%eax
f010f534:	83 ec 08             	sub    $0x8,%esp
f010f537:	68 de a5 12 f0       	push   $0xf012a5de
f010f53c:	50                   	push   %eax
f010f53d:	e8 d6 2f 01 00       	call   f0122518 <strcmp>
f010f542:	83 c4 10             	add    $0x10,%esp
f010f545:	85 c0                	test   %eax,%eax
f010f547:	75 07                	jne    f010f550 <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f010f549:	e8 71 46 00 00       	call   f0113bbf <test_pt_set_page_permissions_invalid_va>
f010f54e:	eb 6a                	jmp    f010f5ba <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f010f550:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f553:	83 c0 04             	add    $0x4,%eax
f010f556:	8b 00                	mov    (%eax),%eax
f010f558:	83 ec 08             	sub    $0x8,%esp
f010f55b:	68 e6 a5 12 f0       	push   $0xf012a5e6
f010f560:	50                   	push   %eax
f010f561:	e8 b2 2f 01 00       	call   f0122518 <strcmp>
f010f566:	83 c4 10             	add    $0x10,%esp
f010f569:	85 c0                	test   %eax,%eax
f010f56b:	75 07                	jne    f010f574 <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f010f56d:	e8 96 46 00 00       	call   f0113c08 <test_pt_get_page_permissions>
f010f572:	eb 46                	jmp    f010f5ba <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f010f574:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f577:	83 c0 04             	add    $0x4,%eax
f010f57a:	8b 00                	mov    (%eax),%eax
f010f57c:	83 ec 08             	sub    $0x8,%esp
f010f57f:	68 ee a5 12 f0       	push   $0xf012a5ee
f010f584:	50                   	push   %eax
f010f585:	e8 8e 2f 01 00       	call   f0122518 <strcmp>
f010f58a:	83 c4 10             	add    $0x10,%esp
f010f58d:	85 c0                	test   %eax,%eax
f010f58f:	75 07                	jne    f010f598 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f010f591:	e8 b6 47 00 00       	call   f0113d4c <test_pt_clear_page_table_entry>
f010f596:	eb 22                	jmp    f010f5ba <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f010f598:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f59b:	83 c0 04             	add    $0x4,%eax
f010f59e:	8b 00                	mov    (%eax),%eax
f010f5a0:	83 ec 08             	sub    $0x8,%esp
f010f5a3:	68 f5 a5 12 f0       	push   $0xf012a5f5
f010f5a8:	50                   	push   %eax
f010f5a9:	e8 6a 2f 01 00       	call   f0122518 <strcmp>
f010f5ae:	83 c4 10             	add    $0x10,%esp
f010f5b1:	85 c0                	test   %eax,%eax
f010f5b3:	75 05                	jne    f010f5ba <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f010f5b5:	e8 eb 48 00 00       	call   f0113ea5 <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f010f5ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f5bf:	c9                   	leave  
f010f5c0:	c3                   	ret    

f010f5c1 <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f010f5c1:	55                   	push   %ebp
f010f5c2:	89 e5                	mov    %esp,%ebp
f010f5c4:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f010f5c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5ca:	83 c0 08             	add    $0x8,%eax
f010f5cd:	8b 00                	mov    (%eax),%eax
f010f5cf:	83 ec 08             	sub    $0x8,%esp
f010f5d2:	68 fc a5 12 f0       	push   $0xf012a5fc
f010f5d7:	50                   	push   %eax
f010f5d8:	e8 3b 2f 01 00       	call   f0122518 <strcmp>
f010f5dd:	83 c4 10             	add    $0x10,%esp
f010f5e0:	85 c0                	test   %eax,%eax
f010f5e2:	75 20                	jne    f010f604 <tst_kheap+0x43>
f010f5e4:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010f5e8:	74 1a                	je     f010f604 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f010f5ea:	83 ec 0c             	sub    $0xc,%esp
f010f5ed:	68 04 a6 12 f0       	push   $0xf012a604
f010f5f2:	e8 75 19 ff ff       	call   f0100f6c <cprintf>
f010f5f7:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f5fa:	b8 00 00 00 00       	mov    $0x0,%eax
f010f5ff:	e9 f6 03 00 00       	jmp    f010f9fa <tst_kheap+0x439>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f010f604:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f607:	83 c0 08             	add    $0x8,%eax
f010f60a:	8b 00                	mov    (%eax),%eax
f010f60c:	83 ec 08             	sub    $0x8,%esp
f010f60f:	68 fc a5 12 f0       	push   $0xf012a5fc
f010f614:	50                   	push   %eax
f010f615:	e8 fe 2e 01 00       	call   f0122518 <strcmp>
f010f61a:	83 c4 10             	add    $0x10,%esp
f010f61d:	85 c0                	test   %eax,%eax
f010f61f:	74 43                	je     f010f664 <tst_kheap+0xa3>
f010f621:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010f625:	74 3d                	je     f010f664 <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f010f627:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f62a:	83 c0 08             	add    $0x8,%eax
f010f62d:	8b 00                	mov    (%eax),%eax
f010f62f:	83 ec 08             	sub    $0x8,%esp
f010f632:	68 54 a6 12 f0       	push   $0xf012a654
f010f637:	50                   	push   %eax
f010f638:	e8 db 2e 01 00       	call   f0122518 <strcmp>
f010f63d:	83 c4 10             	add    $0x10,%esp
f010f640:	85 c0                	test   %eax,%eax
f010f642:	74 20                	je     f010f664 <tst_kheap+0xa3>
f010f644:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f010f648:	74 1a                	je     f010f664 <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f010f64a:	83 ec 0c             	sub    $0xc,%esp
f010f64d:	68 60 a6 12 f0       	push   $0xf012a660
f010f652:	e8 15 19 ff ff       	call   f0100f6c <cprintf>
f010f657:	83 c4 10             	add    $0x10,%esp
			return 0;
f010f65a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f65f:	e9 96 03 00 00       	jmp    f010f9fa <tst_kheap+0x439>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f010f664:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f667:	83 c0 04             	add    $0x4,%eax
f010f66a:	8b 00                	mov    (%eax),%eax
f010f66c:	83 ec 08             	sub    $0x8,%esp
f010f66f:	68 a5 a6 12 f0       	push   $0xf012a6a5
f010f674:	50                   	push   %eax
f010f675:	e8 9e 2e 01 00       	call   f0122518 <strcmp>
f010f67a:	83 c4 10             	add    $0x10,%esp
f010f67d:	85 c0                	test   %eax,%eax
f010f67f:	74 1d                	je     f010f69e <tst_kheap+0xdd>
f010f681:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f684:	83 c0 04             	add    $0x4,%eax
f010f687:	8b 00                	mov    (%eax),%eax
f010f689:	83 ec 08             	sub    $0x8,%esp
f010f68c:	68 a8 a6 12 f0       	push   $0xf012a6a8
f010f691:	50                   	push   %eax
f010f692:	e8 81 2e 01 00       	call   f0122518 <strcmp>
f010f697:	83 c4 10             	add    $0x10,%esp
f010f69a:	85 c0                	test   %eax,%eax
f010f69c:	75 1a                	jne    f010f6b8 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f010f69e:	e8 6d f8 ff ff       	call   f010ef10 <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010f6a3:	83 ec 0c             	sub    $0xc,%esp
f010f6a6:	68 ac a6 12 f0       	push   $0xf012a6ac
f010f6ab:	e8 bc 18 ff ff       	call   f0100f6c <cprintf>
f010f6b0:	83 c4 10             	add    $0x10,%esp
f010f6b3:	e9 a0 00 00 00       	jmp    f010f758 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f010f6b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6bb:	83 c0 04             	add    $0x4,%eax
f010f6be:	8b 00                	mov    (%eax),%eax
f010f6c0:	83 ec 08             	sub    $0x8,%esp
f010f6c3:	68 d9 a6 12 f0       	push   $0xf012a6d9
f010f6c8:	50                   	push   %eax
f010f6c9:	e8 4a 2e 01 00       	call   f0122518 <strcmp>
f010f6ce:	83 c4 10             	add    $0x10,%esp
f010f6d1:	85 c0                	test   %eax,%eax
f010f6d3:	74 1d                	je     f010f6f2 <tst_kheap+0x131>
f010f6d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6d8:	83 c0 04             	add    $0x4,%eax
f010f6db:	8b 00                	mov    (%eax),%eax
f010f6dd:	83 ec 08             	sub    $0x8,%esp
f010f6e0:	68 dc a6 12 f0       	push   $0xf012a6dc
f010f6e5:	50                   	push   %eax
f010f6e6:	e8 2d 2e 01 00       	call   f0122518 <strcmp>
f010f6eb:	83 c4 10             	add    $0x10,%esp
f010f6ee:	85 c0                	test   %eax,%eax
f010f6f0:	75 17                	jne    f010f709 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f010f6f2:	e8 29 f8 ff ff       	call   f010ef20 <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f010f6f7:	83 ec 0c             	sub    $0xc,%esp
f010f6fa:	68 e0 a6 12 f0       	push   $0xf012a6e0
f010f6ff:	e8 68 18 ff ff       	call   f0100f6c <cprintf>
f010f704:	83 c4 10             	add    $0x10,%esp
f010f707:	eb 4f                	jmp    f010f758 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f010f709:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f70c:	83 c0 04             	add    $0x4,%eax
f010f70f:	8b 00                	mov    (%eax),%eax
f010f711:	83 ec 08             	sub    $0x8,%esp
f010f714:	68 0c a7 12 f0       	push   $0xf012a70c
f010f719:	50                   	push   %eax
f010f71a:	e8 f9 2d 01 00       	call   f0122518 <strcmp>
f010f71f:	83 c4 10             	add    $0x10,%esp
f010f722:	85 c0                	test   %eax,%eax
f010f724:	74 1d                	je     f010f743 <tst_kheap+0x182>
f010f726:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f729:	83 c0 04             	add    $0x4,%eax
f010f72c:	8b 00                	mov    (%eax),%eax
f010f72e:	83 ec 08             	sub    $0x8,%esp
f010f731:	68 0f a7 12 f0       	push   $0xf012a70f
f010f736:	50                   	push   %eax
f010f737:	e8 dc 2d 01 00       	call   f0122518 <strcmp>
f010f73c:	83 c4 10             	add    $0x10,%esp
f010f73f:	85 c0                	test   %eax,%eax
f010f741:	75 15                	jne    f010f758 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f010f743:	e8 e8 f7 ff ff       	call   f010ef30 <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f010f748:	83 ec 0c             	sub    $0xc,%esp
f010f74b:	68 14 a7 12 f0       	push   $0xf012a714
f010f750:	e8 17 18 ff ff       	call   f0100f6c <cprintf>
f010f755:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f010f758:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f75b:	83 c0 08             	add    $0x8,%eax
f010f75e:	8b 00                	mov    (%eax),%eax
f010f760:	83 ec 08             	sub    $0x8,%esp
f010f763:	68 fc a5 12 f0       	push   $0xf012a5fc
f010f768:	50                   	push   %eax
f010f769:	e8 aa 2d 01 00       	call   f0122518 <strcmp>
f010f76e:	83 c4 10             	add    $0x10,%esp
f010f771:	85 c0                	test   %eax,%eax
f010f773:	0f 85 13 01 00 00    	jne    f010f88c <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010f779:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f77c:	83 c0 0c             	add    $0xc,%eax
f010f77f:	8b 00                	mov    (%eax),%eax
f010f781:	83 ec 04             	sub    $0x4,%esp
f010f784:	6a 0a                	push   $0xa
f010f786:	6a 00                	push   $0x0
f010f788:	50                   	push   %eax
f010f789:	e8 de 2f 01 00       	call   f012276c <strtol>
f010f78e:	83 c4 10             	add    $0x10,%esp
f010f791:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f794:	e8 a7 f7 ff ff       	call   f010ef40 <isKHeapPlacementStrategyFIRSTFIT>
f010f799:	84 c0                	test   %al,%al
f010f79b:	74 54                	je     f010f7f1 <tst_kheap+0x230>
		{
			if (testNum == 0)
f010f79d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f7a1:	75 1a                	jne    f010f7bd <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010f7a3:	83 ec 0c             	sub    $0xc,%esp
f010f7a6:	68 40 a7 12 f0       	push   $0xf012a740
f010f7ab:	e8 bc 17 ff ff       	call   f0100f6c <cprintf>
f010f7b0:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f7b3:	b8 00 00 00 00       	mov    $0x0,%eax
f010f7b8:	e9 3d 02 00 00       	jmp    f010f9fa <tst_kheap+0x439>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f010f7bd:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f7c1:	75 0a                	jne    f010f7cd <tst_kheap+0x20c>
				test_kmalloc();
f010f7c3:	e8 df a7 00 00       	call   f0119fa7 <test_kmalloc>
f010f7c8:	e9 b5 00 00 00       	jmp    f010f882 <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f7cd:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f7d1:	75 0a                	jne    f010f7dd <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f010f7d3:	e8 e9 b2 00 00       	call   f011aac1 <test_kmalloc_firstfit1>
f010f7d8:	e9 a5 00 00 00       	jmp    f010f882 <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f7dd:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010f7e1:	0f 85 9b 00 00 00    	jne    f010f882 <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f010f7e7:	e8 69 bd 00 00       	call   f011b555 <test_kmalloc_firstfit2>
f010f7ec:	e9 91 00 00 00       	jmp    f010f882 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f010f7f1:	e8 5f f7 ff ff       	call   f010ef55 <isKHeapPlacementStrategyBESTFIT>
f010f7f6:	84 c0                	test   %al,%al
f010f7f8:	74 47                	je     f010f841 <tst_kheap+0x280>
		{
			if (testNum == 0)
f010f7fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f7fe:	75 1a                	jne    f010f81a <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f010f800:	83 ec 0c             	sub    $0xc,%esp
f010f803:	68 90 a7 12 f0       	push   $0xf012a790
f010f808:	e8 5f 17 ff ff       	call   f0100f6c <cprintf>
f010f80d:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f810:	b8 00 00 00 00       	mov    $0x0,%eax
f010f815:	e9 e0 01 00 00       	jmp    f010f9fa <tst_kheap+0x439>
			}
			if (testNum == 1)
f010f81a:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f81e:	75 07                	jne    f010f827 <tst_kheap+0x266>
				test_kmalloc();
f010f820:	e8 82 a7 00 00       	call   f0119fa7 <test_kmalloc>
f010f825:	eb 5b                	jmp    f010f882 <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f827:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f82b:	75 07                	jne    f010f834 <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f010f82d:	e8 f0 02 01 00       	call   f011fb22 <test_kmalloc_bestfit1>
f010f832:	eb 4e                	jmp    f010f882 <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f834:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010f838:	75 48                	jne    f010f882 <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f010f83a:	e8 00 03 01 00       	call   f011fb3f <test_kmalloc_bestfit2>
f010f83f:	eb 41                	jmp    f010f882 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f010f841:	e8 24 f7 ff ff       	call   f010ef6a <isKHeapPlacementStrategyNEXTFIT>
f010f846:	84 c0                	test   %al,%al
f010f848:	74 38                	je     f010f882 <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f010f84a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f84e:	75 1a                	jne    f010f86a <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f010f850:	83 ec 0c             	sub    $0xc,%esp
f010f853:	68 e0 a7 12 f0       	push   $0xf012a7e0
f010f858:	e8 0f 17 ff ff       	call   f0100f6c <cprintf>
f010f85d:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f860:	b8 00 00 00 00       	mov    $0x0,%eax
f010f865:	e9 90 01 00 00       	jmp    f010f9fa <tst_kheap+0x439>
			}
			//Test cont. allocation
			if (testNum == 1)
f010f86a:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f86e:	75 07                	jne    f010f877 <tst_kheap+0x2b6>
				test_kmalloc();
f010f870:	e8 32 a7 00 00       	call   f0119fa7 <test_kmalloc>
f010f875:	eb 0b                	jmp    f010f882 <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f010f877:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f87b:	75 05                	jne    f010f882 <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f010f87d:	e8 80 02 01 00       	call   f011fb02 <test_kmalloc_nextfit>
		}
		return 0;
f010f882:	b8 00 00 00 00       	mov    $0x0,%eax
f010f887:	e9 6e 01 00 00       	jmp    f010f9fa <tst_kheap+0x439>
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f010f88c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f88f:	83 c0 08             	add    $0x8,%eax
f010f892:	8b 00                	mov    (%eax),%eax
f010f894:	83 ec 08             	sub    $0x8,%esp
f010f897:	68 2e a8 12 f0       	push   $0xf012a82e
f010f89c:	50                   	push   %eax
f010f89d:	e8 76 2c 01 00       	call   f0122518 <strcmp>
f010f8a2:	83 c4 10             	add    $0x10,%esp
f010f8a5:	85 c0                	test   %eax,%eax
f010f8a7:	75 28                	jne    f010f8d1 <tst_kheap+0x310>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f010f8a9:	e8 a7 f6 ff ff       	call   f010ef55 <isKHeapPlacementStrategyBESTFIT>
f010f8ae:	84 c0                	test   %al,%al
f010f8b0:	75 09                	jne    f010f8bb <tst_kheap+0x2fa>
f010f8b2:	e8 89 f6 ff ff       	call   f010ef40 <isKHeapPlacementStrategyFIRSTFIT>
f010f8b7:	84 c0                	test   %al,%al
f010f8b9:	74 07                	je     f010f8c2 <tst_kheap+0x301>
		{
			test_kfree_bestfirstfit();
f010f8bb:	e8 4e c7 00 00       	call   f011c00e <test_kfree_bestfirstfit>
f010f8c0:	eb 05                	jmp    f010f8c7 <tst_kheap+0x306>
		}
		else //NEXT & CONT
		{
			test_kfree();
f010f8c2:	e8 b5 02 01 00       	call   f011fb7c <test_kfree>
		}
		return 0;
f010f8c7:	b8 00 00 00 00       	mov    $0x0,%eax
f010f8cc:	e9 29 01 00 00       	jmp    f010f9fa <tst_kheap+0x439>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f010f8d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8d4:	83 c0 08             	add    $0x8,%eax
f010f8d7:	8b 00                	mov    (%eax),%eax
f010f8d9:	83 ec 08             	sub    $0x8,%esp
f010f8dc:	68 34 a8 12 f0       	push   $0xf012a834
f010f8e1:	50                   	push   %eax
f010f8e2:	e8 31 2c 01 00       	call   f0122518 <strcmp>
f010f8e7:	83 c4 10             	add    $0x10,%esp
f010f8ea:	85 c0                	test   %eax,%eax
f010f8ec:	75 0f                	jne    f010f8fd <tst_kheap+0x33c>
	{
		test_kheap_phys_addr();
f010f8ee:	e8 26 dd 00 00       	call   f011d619 <test_kheap_phys_addr>
		return 0;
f010f8f3:	b8 00 00 00 00       	mov    $0x0,%eax
f010f8f8:	e9 fd 00 00 00       	jmp    f010f9fa <tst_kheap+0x439>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f010f8fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f900:	83 c0 08             	add    $0x8,%eax
f010f903:	8b 00                	mov    (%eax),%eax
f010f905:	83 ec 08             	sub    $0x8,%esp
f010f908:	68 3e a8 12 f0       	push   $0xf012a83e
f010f90d:	50                   	push   %eax
f010f90e:	e8 05 2c 01 00       	call   f0122518 <strcmp>
f010f913:	83 c4 10             	add    $0x10,%esp
f010f916:	85 c0                	test   %eax,%eax
f010f918:	75 0f                	jne    f010f929 <tst_kheap+0x368>
	{
		test_kheap_virt_addr();
f010f91a:	e8 74 ea 00 00       	call   f011e393 <test_kheap_virt_addr>
		return 0;
f010f91f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f924:	e9 d1 00 00 00       	jmp    f010f9fa <tst_kheap+0x439>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f010f929:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f92c:	83 c0 08             	add    $0x8,%eax
f010f92f:	8b 00                	mov    (%eax),%eax
f010f931:	83 ec 08             	sub    $0x8,%esp
f010f934:	68 54 a6 12 f0       	push   $0xf012a654
f010f939:	50                   	push   %eax
f010f93a:	e8 d9 2b 01 00       	call   f0122518 <strcmp>
f010f93f:	83 c4 10             	add    $0x10,%esp
f010f942:	85 c0                	test   %eax,%eax
f010f944:	0f 85 89 00 00 00    	jne    f010f9d3 <tst_kheap+0x412>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010f94a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f94d:	83 c0 0c             	add    $0xc,%eax
f010f950:	8b 00                	mov    (%eax),%eax
f010f952:	83 ec 04             	sub    $0x4,%esp
f010f955:	6a 0a                	push   $0xa
f010f957:	6a 00                	push   $0x0
f010f959:	50                   	push   %eax
f010f95a:	e8 0d 2e 01 00       	call   f012276c <strtol>
f010f95f:	83 c4 10             	add    $0x10,%esp
f010f962:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f965:	e8 d6 f5 ff ff       	call   f010ef40 <isKHeapPlacementStrategyFIRSTFIT>
f010f96a:	84 c0                	test   %al,%al
f010f96c:	74 42                	je     f010f9b0 <tst_kheap+0x3ef>
		{
			if (testNum == 0)
f010f96e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f972:	75 17                	jne    f010f98b <tst_kheap+0x3ca>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010f974:	83 ec 0c             	sub    $0xc,%esp
f010f977:	68 40 a7 12 f0       	push   $0xf012a740
f010f97c:	e8 eb 15 ff ff       	call   f0100f6c <cprintf>
f010f981:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f984:	b8 00 00 00 00       	mov    $0x0,%eax
f010f989:	eb 6f                	jmp    f010f9fa <tst_kheap+0x439>
			}
			if (testNum==1)
f010f98b:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f010f98f:	75 07                	jne    f010f998 <tst_kheap+0x3d7>
				test_krealloc_FF1();
f010f991:	e8 cc 04 01 00       	call   f011fe62 <test_krealloc_FF1>
f010f996:	eb 18                	jmp    f010f9b0 <tst_kheap+0x3ef>
			else if (testNum==2)
f010f998:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f010f99c:	75 07                	jne    f010f9a5 <tst_kheap+0x3e4>
				test_krealloc_FF2();
f010f99e:	e8 0c 05 01 00       	call   f011feaf <test_krealloc_FF2>
f010f9a3:	eb 0b                	jmp    f010f9b0 <tst_kheap+0x3ef>
			else if (testNum==3)
f010f9a5:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f010f9a9:	75 05                	jne    f010f9b0 <tst_kheap+0x3ef>
				test_krealloc_FF3();
f010f9ab:	e8 4c 05 01 00       	call   f011fefc <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f010f9b0:	e8 b5 f5 ff ff       	call   f010ef6a <isKHeapPlacementStrategyNEXTFIT>
f010f9b5:	84 c0                	test   %al,%al
f010f9b7:	74 05                	je     f010f9be <tst_kheap+0x3fd>
		{
			test_krealloc();
f010f9b9:	e8 0a 04 01 00       	call   f011fdc8 <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f010f9be:	e8 92 f5 ff ff       	call   f010ef55 <isKHeapPlacementStrategyBESTFIT>
f010f9c3:	84 c0                	test   %al,%al
f010f9c5:	74 05                	je     f010f9cc <tst_kheap+0x40b>
		{
			test_krealloc_BF();
f010f9c7:	e8 49 04 01 00       	call   f011fe15 <test_krealloc_BF>
		}
		return 0;
f010f9cc:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9d1:	eb 27                	jmp    f010f9fa <tst_kheap+0x439>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f010f9d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f9d6:	83 c0 08             	add    $0x8,%eax
f010f9d9:	8b 00                	mov    (%eax),%eax
f010f9db:	83 ec 08             	sub    $0x8,%esp
f010f9de:	68 48 a8 12 f0       	push   $0xf012a848
f010f9e3:	50                   	push   %eax
f010f9e4:	e8 2f 2b 01 00       	call   f0122518 <strcmp>
f010f9e9:	83 c4 10             	add    $0x10,%esp
f010f9ec:	85 c0                	test   %eax,%eax
f010f9ee:	75 05                	jne    f010f9f5 <tst_kheap+0x434>
	{
		test_ksbrk();
f010f9f0:	e8 38 f6 00 00       	call   f011f02d <test_ksbrk>
	}
	return 0;
f010f9f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f9fa:	c9                   	leave  
f010f9fb:	c3                   	ret    

f010f9fc <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f010f9fc:	55                   	push   %ebp
f010f9fd:	89 e5                	mov    %esp,%ebp
f010f9ff:	83 ec 28             	sub    $0x28,%esp
f010fa02:	8b 45 14             	mov    0x14(%ebp),%eax
f010fa05:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f010fa08:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa0b:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fa0e:	74 1d                	je     f010fa2d <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f010fa10:	83 ec 04             	sub    $0x4,%esp
f010fa13:	ff 75 08             	pushl  0x8(%ebp)
f010fa16:	ff 75 0c             	pushl  0xc(%ebp)
f010fa19:	68 50 a8 12 f0       	push   $0xf012a850
f010fa1e:	e8 49 15 ff ff       	call   f0100f6c <cprintf>
f010fa23:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fa26:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa2b:	eb 55                	jmp    f010fa82 <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f010fa2d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa30:	8b 40 fc             	mov    -0x4(%eax),%eax
f010fa33:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f010fa36:	8b 45 10             	mov    0x10(%ebp),%eax
f010fa39:	8d 50 f8             	lea    -0x8(%eax),%edx
f010fa3c:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa3f:	01 d0                	add    %edx,%eax
f010fa41:	8b 00                	mov    (%eax),%eax
f010fa43:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f010fa46:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f010fa4a:	0b 45 10             	or     0x10(%ebp),%eax
f010fa4d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f010fa50:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fa53:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa56:	75 08                	jne    f010fa60 <check_block+0x64>
f010fa58:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fa5b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa5e:	74 1d                	je     f010fa7d <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f010fa60:	ff 75 f0             	pushl  -0x10(%ebp)
f010fa63:	ff 75 f4             	pushl  -0xc(%ebp)
f010fa66:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa69:	68 80 a8 12 f0       	push   $0xf012a880
f010fa6e:	e8 f9 14 ff ff       	call   f0100f6c <cprintf>
f010fa73:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fa76:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa7b:	eb 05                	jmp    f010fa82 <check_block+0x86>
	}
	return 1;
f010fa7d:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010fa82:	c9                   	leave  
f010fa83:	c3                   	ret    

f010fa84 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f010fa84:	55                   	push   %ebp
f010fa85:	89 e5                	mov    %esp,%ebp
f010fa87:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f010fa8a:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f010fa8f:	3b 45 08             	cmp    0x8(%ebp),%eax
f010fa92:	74 20                	je     f010fab4 <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f010fa94:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f010fa99:	83 ec 04             	sub    $0x4,%esp
f010fa9c:	50                   	push   %eax
f010fa9d:	ff 75 08             	pushl  0x8(%ebp)
f010faa0:	68 bc a8 12 f0       	push   $0xf012a8bc
f010faa5:	e8 c2 14 ff ff       	call   f0100f6c <cprintf>
f010faaa:	83 c4 10             	add    $0x10,%esp
		return 0;
f010faad:	b8 00 00 00 00       	mov    $0x0,%eax
f010fab2:	eb 05                	jmp    f010fab9 <check_list_size+0x35>
	}
	return 1;
f010fab4:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010fab9:	c9                   	leave  
f010faba:	c3                   	ret    

f010fabb <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f010fabb:	55                   	push   %ebp
f010fabc:	89 e5                	mov    %esp,%ebp
f010fabe:	83 ec 28             	sub    $0x28,%esp
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
	return;
#endif

	//write initial data at the start (for checking)
	int* tmp_ptr = (int*)KERNEL_HEAP_START;
f010fac1:	c7 45 f4 00 00 00 f6 	movl   $0xf6000000,-0xc(%ebp)
	*tmp_ptr = -1 ;
f010fac8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010facb:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	*(tmp_ptr+1) = 1 ;
f010fad1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fad4:	83 c0 04             	add    $0x4,%eax
f010fad7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	uint32 initAllocatedSpace = 2*Mega;
f010fadd:	c7 45 f0 00 00 20 00 	movl   $0x200000,-0x10(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f010fae4:	83 ec 08             	sub    $0x8,%esp
f010fae7:	ff 75 f0             	pushl  -0x10(%ebp)
f010faea:	68 00 00 00 f6       	push   $0xf6000000
f010faef:	e8 e7 34 01 00       	call   f0122fdb <initialize_dynamic_allocator>
f010faf4:	83 c4 10             	add    $0x10,%esp


	//Check#1: Metadata
	uint32* daBeg = (uint32*) KERNEL_HEAP_START ;
f010faf7:	c7 45 ec 00 00 00 f6 	movl   $0xf6000000,-0x14(%ebp)
	uint32* daEnd = (uint32*) (KERNEL_HEAP_START +  initAllocatedSpace - sizeof(int));
f010fafe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fb01:	2d 04 00 00 0a       	sub    $0xa000004,%eax
f010fb06:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32* blkHeader = (uint32*) (KERNEL_HEAP_START + sizeof(int));
f010fb09:	c7 45 e4 04 00 00 f6 	movl   $0xf6000004,-0x1c(%ebp)
	uint32* blkFooter = (uint32*) (KERNEL_HEAP_START +  initAllocatedSpace - 2*sizeof(int));
f010fb10:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fb13:	2d 08 00 00 0a       	sub    $0xa000008,%eax
f010fb18:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (*daBeg != 1 || *daEnd != 1 || (*blkHeader != initAllocatedSpace - 2*sizeof(int))|| (*blkFooter != initAllocatedSpace - 2*sizeof(int)))
f010fb1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fb1e:	8b 00                	mov    (%eax),%eax
f010fb20:	83 f8 01             	cmp    $0x1,%eax
f010fb23:	75 28                	jne    f010fb4d <test_initialize_dynamic_allocator+0x92>
f010fb25:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fb28:	8b 00                	mov    (%eax),%eax
f010fb2a:	83 f8 01             	cmp    $0x1,%eax
f010fb2d:	75 1e                	jne    f010fb4d <test_initialize_dynamic_allocator+0x92>
f010fb2f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fb32:	8b 00                	mov    (%eax),%eax
f010fb34:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010fb37:	83 ea 08             	sub    $0x8,%edx
f010fb3a:	39 d0                	cmp    %edx,%eax
f010fb3c:	75 0f                	jne    f010fb4d <test_initialize_dynamic_allocator+0x92>
f010fb3e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fb41:	8b 00                	mov    (%eax),%eax
f010fb43:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010fb46:	83 ea 08             	sub    $0x8,%edx
f010fb49:	39 d0                	cmp    %edx,%eax
f010fb4b:	74 14                	je     f010fb61 <test_initialize_dynamic_allocator+0xa6>
	{
		panic("Content of header/footer and/or DA begin/end are not set correctly");
f010fb4d:	83 ec 04             	sub    $0x4,%esp
f010fb50:	68 f0 a8 12 f0       	push   $0xf012a8f0
f010fb55:	6a 53                	push   $0x53
f010fb57:	68 34 a9 12 f0       	push   $0xf012a934
f010fb5c:	e8 b9 07 ff ff       	call   f010031a <_panic>
	}
	if (LIST_SIZE(&freeBlocksList) != 1 || (uint32)LIST_FIRST(&freeBlocksList) != KERNEL_HEAP_START + 2*sizeof(int))
f010fb61:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f010fb66:	83 f8 01             	cmp    $0x1,%eax
f010fb69:	75 0c                	jne    f010fb77 <test_initialize_dynamic_allocator+0xbc>
f010fb6b:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f010fb70:	3d 08 00 00 f6       	cmp    $0xf6000008,%eax
f010fb75:	74 14                	je     f010fb8b <test_initialize_dynamic_allocator+0xd0>
	{
		panic("free block is not added correctly");
f010fb77:	83 ec 04             	sub    $0x4,%esp
f010fb7a:	68 58 a9 12 f0       	push   $0xf012a958
f010fb7f:	6a 57                	push   $0x57
f010fb81:	68 34 a9 12 f0       	push   $0xf012a934
f010fb86:	e8 8f 07 ff ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
f010fb8b:	83 ec 0c             	sub    $0xc,%esp
f010fb8e:	68 7c a9 12 f0       	push   $0xf012a97c
f010fb93:	e8 d4 13 ff ff       	call   f0100f6c <cprintf>
f010fb98:	83 c4 10             	add    $0x10,%esp
}
f010fb9b:	90                   	nop
f010fb9c:	c9                   	leave  
f010fb9d:	c3                   	ret    

f010fb9e <test_initial_alloc>:


int test_initial_alloc(int ALLOC_STRATEGY)
{
f010fb9e:	55                   	push   %ebp
f010fb9f:	89 e5                	mov    %esp,%ebp
f010fba1:	83 ec 48             	sub    $0x48,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return 0;
#endif

	int eval = 0;
f010fba4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool is_correct = 1;
f010fbab:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int initAllocatedSpace = 3*Mega;
f010fbb2:	c7 45 d0 00 00 30 00 	movl   $0x300000,-0x30(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f010fbb9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fbbc:	83 ec 08             	sub    $0x8,%esp
f010fbbf:	50                   	push   %eax
f010fbc0:	68 00 00 00 f6       	push   $0xf6000000
f010fbc5:	e8 11 34 01 00       	call   f0122fdb <initialize_dynamic_allocator>
f010fbca:	83 c4 10             	add    $0x10,%esp

	void * va ;
	//====================================================================//
	/*INITIAL ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
f010fbcd:	83 ec 0c             	sub    $0xc,%esp
f010fbd0:	68 cc a9 12 f0       	push   $0xf012a9cc
f010fbd5:	e8 92 13 ff ff       	call   f0100f6c <cprintf>
f010fbda:	83 c4 10             	add    $0x10,%esp

	is_correct = 1;
f010fbdd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	va = alloc_block(3*initAllocatedSpace, ALLOC_STRATEGY);
f010fbe4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fbe7:	89 c2                	mov    %eax,%edx
f010fbe9:	01 d2                	add    %edx,%edx
f010fbeb:	01 d0                	add    %edx,%eax
f010fbed:	83 ec 08             	sub    $0x8,%esp
f010fbf0:	ff 75 08             	pushl  0x8(%ebp)
f010fbf3:	50                   	push   %eax
f010fbf4:	e8 b5 32 01 00       	call   f0122eae <alloc_block>
f010fbf9:	83 c4 10             	add    $0x10,%esp
f010fbfc:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//Check returned va
	if(va != NULL)
f010fbff:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010fc03:	74 17                	je     f010fc1c <test_initial_alloc+0x7e>
	{
		is_correct = 0;
f010fc05:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx #1: should not be allocated.\n");
f010fc0c:	83 ec 0c             	sub    $0xc,%esp
f010fc0f:	68 08 aa 12 f0       	push   $0xf012aa08
f010fc14:	e8 53 13 ff ff       	call   f0100f6c <cprintf>
f010fc19:	83 c4 10             	add    $0x10,%esp
	}
	va = alloc_block(initAllocatedSpace, ALLOC_STRATEGY);
f010fc1c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fc1f:	83 ec 08             	sub    $0x8,%esp
f010fc22:	ff 75 08             	pushl  0x8(%ebp)
f010fc25:	50                   	push   %eax
f010fc26:	e8 83 32 01 00       	call   f0122eae <alloc_block>
f010fc2b:	83 c4 10             	add    $0x10,%esp
f010fc2e:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//Check returned va
	if(va != NULL)
f010fc31:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010fc35:	74 17                	je     f010fc4e <test_initial_alloc+0xb0>
	{
		is_correct = 0;
f010fc37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx #2: should not be allocated.\n");
f010fc3e:	83 ec 0c             	sub    $0xc,%esp
f010fc41:	68 38 aa 12 f0       	push   $0xf012aa38
f010fc46:	e8 21 13 ff ff       	call   f0100f6c <cprintf>
f010fc4b:	83 c4 10             	add    $0x10,%esp
	}

	if (is_correct)
f010fc4e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fc52:	74 04                	je     f010fc58 <test_initial_alloc+0xba>
	{
		eval += 5;
f010fc54:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 2: Try to allocate set of blocks with different sizes*/
	cprintf("	2: Try to allocate set of blocks with different sizes [all should fit]\n\n") ;
f010fc58:	83 ec 0c             	sub    $0xc,%esp
f010fc5b:	68 68 aa 12 f0       	push   $0xf012aa68
f010fc60:	e8 07 13 ff ff       	call   f0100f6c <cprintf>
f010fc65:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fc68:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	void* expectedVA;
	uint32 expectedNumFreeBlks;
	int totalSizes = 0;
f010fc6f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f010fc76:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010fc7d:	eb 2a                	jmp    f010fca9 <test_initial_alloc+0x10b>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f010fc7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fc82:	8b 14 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%edx
f010fc89:	89 d0                	mov    %edx,%eax
f010fc8b:	c1 e0 02             	shl    $0x2,%eax
f010fc8e:	01 d0                	add    %edx,%eax
f010fc90:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fc97:	01 d0                	add    %edx,%eax
f010fc99:	c1 e0 03             	shl    $0x3,%eax
f010fc9c:	89 c2                	mov    %eax,%edx
f010fc9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fca1:	01 d0                	add    %edx,%eax
f010fca3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	cprintf("	2: Try to allocate set of blocks with different sizes [all should fit]\n\n") ;
	is_correct = 1;
	void* expectedVA;
	uint32 expectedNumFreeBlks;
	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f010fca6:	ff 45 e8             	incl   -0x18(%ebp)
f010fca9:	83 7d e8 06          	cmpl   $0x6,-0x18(%ebp)
f010fcad:	7e d0                	jle    f010fc7f <test_initial_alloc+0xe1>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
	}
	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ; //exclude size of "DA Begin & End" blocks
f010fcaf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fcb2:	2b 45 ec             	sub    -0x14(%ebp),%eax
f010fcb5:	83 e8 08             	sub    $0x8,%eax
f010fcb8:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//cprintf("\n********* Remaining size = %d\n", remainSize);
	if (remainSize <= 0)
f010fcbb:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f010fcbf:	7f 17                	jg     f010fcd8 <test_initial_alloc+0x13a>
	{
		is_correct = 0;
f010fcc1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx test is not configured correctly. Consider updating the initial allocated space OR the required allocations\n");
f010fcc8:	83 ec 0c             	sub    $0xc,%esp
f010fccb:	68 b4 aa 12 f0       	push   $0xf012aab4
f010fcd0:	e8 97 12 ff ff       	call   f0100f6c <cprintf>
f010fcd5:	83 c4 10             	add    $0x10,%esp
	}
	int idx = 0;
f010fcd8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
f010fcdf:	c7 45 e0 04 00 00 f6 	movl   $0xf6000004,-0x20(%ebp)
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f010fce6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010fced:	e9 f3 00 00 00       	jmp    f010fde5 <test_initial_alloc+0x247>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f010fcf2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010fcf9:	e9 d7 00 00 00       	jmp    f010fdd5 <test_initial_alloc+0x237>
		{
			actualSize = allocSizes[i] - sizeOfMetaData;
f010fcfe:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fd01:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f010fd08:	83 e8 08             	sub    $0x8,%eax
f010fd0b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			va = startVAs[idx] = alloc_block(actualSize, ALLOC_STRATEGY);
f010fd0e:	83 ec 08             	sub    $0x8,%esp
f010fd11:	ff 75 08             	pushl  0x8(%ebp)
f010fd14:	ff 75 c4             	pushl  -0x3c(%ebp)
f010fd17:	e8 92 31 01 00       	call   f0122eae <alloc_block>
f010fd1c:	83 c4 10             	add    $0x10,%esp
f010fd1f:	89 c2                	mov    %eax,%edx
f010fd21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fd24:	89 14 85 80 30 5c f0 	mov    %edx,-0xfa3cf80(,%eax,4)
f010fd2b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fd2e:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f010fd35:	89 45 cc             	mov    %eax,-0x34(%ebp)
			midVAs[idx] = va + actualSize/2 ;
f010fd38:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fd3b:	d1 e8                	shr    %eax
f010fd3d:	89 c2                	mov    %eax,%edx
f010fd3f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fd42:	01 c2                	add    %eax,%edx
f010fd44:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fd47:	89 14 85 80 5c 5c f0 	mov    %edx,-0xfa3a380(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f010fd4e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fd51:	8d 50 fe             	lea    -0x2(%eax),%edx
f010fd54:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fd57:	01 c2                	add    %eax,%edx
f010fd59:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fd5c:	89 14 85 80 46 5c f0 	mov    %edx,-0xfa3b980(,%eax,4)
			//Check block
			expectedVA = (curVA + sizeOfMetaData/2);
f010fd63:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd66:	83 c0 04             	add    $0x4,%eax
f010fd69:	89 45 c0             	mov    %eax,-0x40(%ebp)
			if (check_block(va, expectedVA, allocSizes[i], 1) == 0)
f010fd6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fd6f:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f010fd76:	6a 01                	push   $0x1
f010fd78:	50                   	push   %eax
f010fd79:	ff 75 c0             	pushl  -0x40(%ebp)
f010fd7c:	ff 75 cc             	pushl  -0x34(%ebp)
f010fd7f:	e8 78 fc ff ff       	call   f010f9fc <check_block>
f010fd84:	83 c4 10             	add    $0x10,%esp
f010fd87:	85 c0                	test   %eax,%eax
f010fd89:	75 07                	jne    f010fd92 <test_initial_alloc+0x1f4>
			{
				is_correct = 0;
f010fd8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			}
			curVA += allocSizes[i] ;
f010fd92:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fd95:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f010fd9c:	01 45 e0             	add    %eax,-0x20(%ebp)
			*(startVAs[idx]) = idx ;
f010fd9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fda2:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f010fda9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fdac:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f010fdaf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fdb2:	8b 14 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%edx
f010fdb9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fdbc:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f010fdbf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fdc2:	8b 14 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%edx
f010fdc9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fdcc:	66 89 02             	mov    %ax,(%edx)
			idx++;
f010fdcf:	ff 45 e4             	incl   -0x1c(%ebp)
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f010fdd2:	ff 45 d8             	incl   -0x28(%ebp)
f010fdd5:	81 7d d8 c7 00 00 00 	cmpl   $0xc7,-0x28(%ebp)
f010fddc:	0f 8e 1c ff ff ff    	jle    f010fcfe <test_initial_alloc+0x160>
		cprintf("alloc_block_xx test is not configured correctly. Consider updating the initial allocated space OR the required allocations\n");
	}
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f010fde2:	ff 45 dc             	incl   -0x24(%ebp)
f010fde5:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f010fde9:	0f 8e 03 ff ff ff    	jle    f010fcf2 <test_initial_alloc+0x154>
			idx++;
		}
		//if (is_correct == 0)
		//break;
	}
	if (is_correct)
f010fdef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fdf3:	74 04                	je     f010fdf9 <test_initial_alloc+0x25b>
	{
		eval += 15;
f010fdf5:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}
	if (check_list_size(1))
f010fdf9:	83 ec 0c             	sub    $0xc,%esp
f010fdfc:	6a 01                	push   $0x1
f010fdfe:	e8 81 fc ff ff       	call   f010fa84 <check_list_size>
f010fe03:	83 c4 10             	add    $0x10,%esp
f010fe06:	85 c0                	test   %eax,%eax
f010fe08:	74 04                	je     f010fe0e <test_initial_alloc+0x270>
	{
		eval += 5;
f010fe0a:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 3: Try to allocate a block with a size equal to the size of the first existing free block*/
	cprintf("	3: Try to allocate a block with equal to the first existing free block\n\n") ;
f010fe0e:	83 ec 0c             	sub    $0xc,%esp
f010fe11:	68 30 ab 12 f0       	push   $0xf012ab30
f010fe16:	e8 51 11 ff ff       	call   f0100f6c <cprintf>
f010fe1b:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fe1e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	actualSize = remainSize - sizeOfMetaData;
f010fe25:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fe28:	83 e8 08             	sub    $0x8,%eax
f010fe2b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = startVAs[idx] = alloc_block(actualSize, ALLOC_STRATEGY);
f010fe2e:	83 ec 08             	sub    $0x8,%esp
f010fe31:	ff 75 08             	pushl  0x8(%ebp)
f010fe34:	ff 75 c4             	pushl  -0x3c(%ebp)
f010fe37:	e8 72 30 01 00       	call   f0122eae <alloc_block>
f010fe3c:	83 c4 10             	add    $0x10,%esp
f010fe3f:	89 c2                	mov    %eax,%edx
f010fe41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fe44:	89 14 85 80 30 5c f0 	mov    %edx,-0xfa3cf80(,%eax,4)
f010fe4b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fe4e:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f010fe55:	89 45 cc             	mov    %eax,-0x34(%ebp)
	midVAs[idx] = va + actualSize/2 ;
f010fe58:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fe5b:	d1 e8                	shr    %eax
f010fe5d:	89 c2                	mov    %eax,%edx
f010fe5f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fe62:	01 c2                	add    %eax,%edx
f010fe64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fe67:	89 14 85 80 5c 5c f0 	mov    %edx,-0xfa3a380(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f010fe6e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fe71:	8d 50 fe             	lea    -0x2(%eax),%edx
f010fe74:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fe77:	01 c2                	add    %eax,%edx
f010fe79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fe7c:	89 14 85 80 46 5c f0 	mov    %edx,-0xfa3b980(,%eax,4)
	//Check block
	expectedVA = (curVA + sizeOfMetaData/2);
f010fe83:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fe86:	83 c0 04             	add    $0x4,%eax
f010fe89:	89 45 c0             	mov    %eax,-0x40(%ebp)

	if (is_correct) is_correct = check_block(va, expectedVA, remainSize, 1) ;
f010fe8c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fe90:	74 17                	je     f010fea9 <test_initial_alloc+0x30b>
f010fe92:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fe95:	6a 01                	push   $0x1
f010fe97:	50                   	push   %eax
f010fe98:	ff 75 c0             	pushl  -0x40(%ebp)
f010fe9b:	ff 75 cc             	pushl  -0x34(%ebp)
f010fe9e:	e8 59 fb ff ff       	call   f010f9fc <check_block>
f010fea3:	83 c4 10             	add    $0x10,%esp
f010fea6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (is_correct) is_correct = check_list_size(0);
f010fea9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fead:	74 10                	je     f010febf <test_initial_alloc+0x321>
f010feaf:	83 ec 0c             	sub    $0xc,%esp
f010feb2:	6a 00                	push   $0x0
f010feb4:	e8 cb fb ff ff       	call   f010fa84 <check_list_size>
f010feb9:	83 c4 10             	add    $0x10,%esp
f010febc:	89 45 f0             	mov    %eax,-0x10(%ebp)

	*(startVAs[idx]) = idx ;
f010febf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fec2:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f010fec9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fecc:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f010fecf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fed2:	8b 14 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%edx
f010fed9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fedc:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f010fedf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fee2:	8b 14 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%edx
f010fee9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010feec:	66 89 02             	mov    %ax,(%edx)
	if (is_correct)
f010feef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fef3:	74 04                	je     f010fef9 <test_initial_alloc+0x35b>
	{
		eval += 5;
f010fef5:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
f010fef9:	83 ec 0c             	sub    $0xc,%esp
f010fefc:	68 7c ab 12 f0       	push   $0xf012ab7c
f010ff01:	e8 66 10 ff ff       	call   f0100f6c <cprintf>
f010ff06:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010ff09:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	for (int i = 0; i < idx; ++i)
f010ff10:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f010ff17:	eb 5b                	jmp    f010ff74 <test_initial_alloc+0x3d6>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f010ff19:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ff1c:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f010ff23:	66 8b 00             	mov    (%eax),%ax
f010ff26:	98                   	cwtl   
f010ff27:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010ff2a:	75 26                	jne    f010ff52 <test_initial_alloc+0x3b4>
f010ff2c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ff2f:	8b 04 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%eax
f010ff36:	66 8b 00             	mov    (%eax),%ax
f010ff39:	98                   	cwtl   
f010ff3a:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010ff3d:	75 13                	jne    f010ff52 <test_initial_alloc+0x3b4>
f010ff3f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ff42:	8b 04 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%eax
f010ff49:	66 8b 00             	mov    (%eax),%ax
f010ff4c:	98                   	cwtl   
f010ff4d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010ff50:	74 1f                	je     f010ff71 <test_initial_alloc+0x3d3>
		{
			is_correct = 0;
f010ff52:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("alloc_block_xx #4.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
f010ff59:	83 ec 04             	sub    $0x4,%esp
f010ff5c:	ff 75 d4             	pushl  -0x2c(%ebp)
f010ff5f:	ff 75 d4             	pushl  -0x2c(%ebp)
f010ff62:	68 b0 ab 12 f0       	push   $0xf012abb0
f010ff67:	e8 00 10 ff ff       	call   f0100f6c <cprintf>
f010ff6c:	83 c4 10             	add    $0x10,%esp
			break;
f010ff6f:	eb 0b                	jmp    f010ff7c <test_initial_alloc+0x3de>
	//====================================================================//
	/*INITIAL ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < idx; ++i)
f010ff71:	ff 45 d4             	incl   -0x2c(%ebp)
f010ff74:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ff77:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010ff7a:	7c 9d                	jl     f010ff19 <test_initial_alloc+0x37b>
			is_correct = 0;
			cprintf("alloc_block_xx #4.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
			break;
		}
	}
	if (is_correct)
f010ff7c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ff80:	74 04                	je     f010ff86 <test_initial_alloc+0x3e8>
	{
		eval += 10;
f010ff82:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}
	return eval;
f010ff86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ff89:	c9                   	leave  
f010ff8a:	c3                   	ret    

f010ff8b <test_alloc_block_FF>:

void test_alloc_block_FF()
{
f010ff8b:	55                   	push   %ebp
f010ff8c:	89 e5                	mov    %esp,%ebp
f010ff8e:	57                   	push   %edi
f010ff8f:	56                   	push   %esi
f010ff90:	53                   	push   %ebx
f010ff91:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	int eval = 0;
f010ff97:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_correct;
	void* va = NULL;
f010ff9e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 actualSize = 0;
f010ffa5:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)

	cprintf("=======================================================\n") ;
f010ffac:	83 ec 0c             	sub    $0xc,%esp
f010ffaf:	68 00 ac 12 f0       	push   $0xf012ac00
f010ffb4:	e8 b3 0f ff ff       	call   f0100f6c <cprintf>
f010ffb9:	83 c4 10             	add    $0x10,%esp
	cprintf("FIRST: Tests depend on the Allocate Function ONLY [40%]\n") ;
f010ffbc:	83 ec 0c             	sub    $0xc,%esp
f010ffbf:	68 3c ac 12 f0       	push   $0xf012ac3c
f010ffc4:	e8 a3 0f ff ff       	call   f0100f6c <cprintf>
f010ffc9:	83 c4 10             	add    $0x10,%esp
	cprintf("=======================================================\n") ;
f010ffcc:	83 ec 0c             	sub    $0xc,%esp
f010ffcf:	68 00 ac 12 f0       	push   $0xf012ac00
f010ffd4:	e8 93 0f ff ff       	call   f0100f6c <cprintf>
f010ffd9:	83 c4 10             	add    $0x10,%esp
	eval = test_initial_alloc(DA_FF);
f010ffdc:	83 ec 0c             	sub    $0xc,%esp
f010ffdf:	6a 01                	push   $0x1
f010ffe1:	e8 b8 fb ff ff       	call   f010fb9e <test_initial_alloc>
f010ffe6:	83 c4 10             	add    $0x10,%esp
f010ffe9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	cprintf("====================================================\n") ;
f010ffec:	83 ec 0c             	sub    $0xc,%esp
f010ffef:	68 78 ac 12 f0       	push   $0xf012ac78
f010fff4:	e8 73 0f ff ff       	call   f0100f6c <cprintf>
f010fff9:	83 c4 10             	add    $0x10,%esp
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
f010fffc:	83 ec 0c             	sub    $0xc,%esp
f010ffff:	68 b0 ac 12 f0       	push   $0xf012acb0
f0110004:	e8 63 0f ff ff       	call   f0100f6c <cprintf>
f0110009:	83 c4 10             	add    $0x10,%esp
	cprintf("====================================================\n") ;
f011000c:	83 ec 0c             	sub    $0xc,%esp
f011000f:	68 78 ac 12 f0       	push   $0xf012ac78
f0110014:	e8 53 0f ff ff       	call   f0100f6c <cprintf>
f0110019:	83 c4 10             	add    $0x10,%esp

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f011001c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0110023:	eb 2c                	jmp    f0110051 <test_alloc_block_FF+0xc6>
	{
		free_block(startVAs[i*allocCntPerSize]);
f0110025:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0110028:	89 d0                	mov    %edx,%eax
f011002a:	c1 e0 02             	shl    $0x2,%eax
f011002d:	01 d0                	add    %edx,%eax
f011002f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110036:	01 d0                	add    %edx,%eax
f0110038:	c1 e0 03             	shl    $0x3,%eax
f011003b:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0110042:	83 ec 0c             	sub    $0xc,%esp
f0110045:	50                   	push   %eax
f0110046:	e8 30 40 01 00       	call   f012407b <free_block>
f011004b:	83 c4 10             	add    $0x10,%esp
	cprintf("====================================================\n") ;
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
	cprintf("====================================================\n") ;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f011004e:	ff 45 dc             	incl   -0x24(%ebp)
f0110051:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f0110055:	7e ce                	jle    f0110025 <test_alloc_block_FF+0x9a>
	{
		free_block(startVAs[i*allocCntPerSize]);
	}
	//Check number of freed blocks
	is_correct = check_list_size(numOfAllocs);
f0110057:	83 ec 0c             	sub    $0xc,%esp
f011005a:	6a 07                	push   $0x7
f011005c:	e8 23 fa ff ff       	call   f010fa84 <check_list_size>
f0110061:	83 c4 10             	add    $0x10,%esp
f0110064:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct)
f0110067:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011006b:	74 04                	je     f0110071 <test_alloc_block_FF+0xe6>
	{
		eval += 10;
f011006d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
f0110071:	83 ec 0c             	sub    $0xc,%esp
f0110074:	68 cc a9 12 f0       	push   $0xf012a9cc
f0110079:	e8 ee 0e ff ff       	call   f0100f6c <cprintf>
f011007e:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110081:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	uint32 maxSize = 0 ;
f0110088:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f011008f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0110096:	eb 1f                	jmp    f01100b7 <test_alloc_block_FF+0x12c>
	{
		if (allocSizes[i] > maxSize)
f0110098:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011009b:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f01100a2:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01100a5:	76 0d                	jbe    f01100b4 <test_alloc_block_FF+0x129>
			maxSize = allocSizes[i] ;
f01100a7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01100aa:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f01100b1:	89 45 d8             	mov    %eax,-0x28(%ebp)
	/*FF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
	is_correct = 1;

	uint32 maxSize = 0 ;
	for (int i = 0; i < numOfAllocs; ++i)
f01100b4:	ff 45 d4             	incl   -0x2c(%ebp)
f01100b7:	83 7d d4 06          	cmpl   $0x6,-0x2c(%ebp)
f01100bb:	7e db                	jle    f0110098 <test_alloc_block_FF+0x10d>
	{
		if (allocSizes[i] > maxSize)
			maxSize = allocSizes[i] ;
	}
	va = alloc_block(maxSize, DA_FF);
f01100bd:	83 ec 08             	sub    $0x8,%esp
f01100c0:	6a 01                	push   $0x1
f01100c2:	ff 75 d8             	pushl  -0x28(%ebp)
f01100c5:	e8 e4 2d 01 00       	call   f0122eae <alloc_block>
f01100ca:	83 c4 10             	add    $0x10,%esp
f01100cd:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//Check returned va
	if(va != NULL)
f01100d0:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01100d4:	74 17                	je     f01100ed <test_alloc_block_FF+0x162>
	{
		is_correct = 0;
f01100d6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_FF #5: WRONG FF ALLOC - alloc_block_FF find a block instead no existing free blocks with the given size.\n");
f01100dd:	83 ec 0c             	sub    $0xc,%esp
f01100e0:	68 e8 ac 12 f0       	push   $0xf012ace8
f01100e5:	e8 82 0e ff ff       	call   f0100f6c <cprintf>
f01100ea:	83 c4 10             	add    $0x10,%esp
	}

	if (is_correct)
f01100ed:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01100f1:	74 04                	je     f01100f7 <test_alloc_block_FF+0x16c>
	{
		eval += 5;
f01100f3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 2: Try to allocate blocks with sizes smaller than existing free blocks*/
	cprintf("	2: Try to allocate set of blocks with different sizes smaller than existing free blocks\n\n") ;
f01100f7:	83 ec 0c             	sub    $0xc,%esp
f01100fa:	68 60 ad 12 f0       	push   $0xf012ad60
f01100ff:	e8 68 0e ff ff       	call   f0100f6c <cprintf>
f0110104:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110107:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* expectedVA;
	uint32 expectedNumFreeBlks;
#define numOfFFTests 3
	uint32 startVA = KERNEL_HEAP_START + sizeof(int); //just after the DA Begin block
f011010e:	c7 45 c0 04 00 00 f6 	movl   $0xf6000004,-0x40(%ebp)
	uint32 testSizes[numOfFFTests] = {1*kilo + kilo/2, 3*kilo, kilo/2} ;
f0110115:	8d 45 ac             	lea    -0x54(%ebp),%eax
f0110118:	bb ec ae 12 f0       	mov    $0xf012aeec,%ebx
f011011d:	ba 03 00 00 00       	mov    $0x3,%edx
f0110122:	89 c7                	mov    %eax,%edi
f0110124:	89 de                	mov    %ebx,%esi
f0110126:	89 d1                	mov    %edx,%ecx
f0110128:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 startOf1st7KB = (uint32)startVAs[6*allocCntPerSize];
f011012a:	a1 40 43 5c f0       	mov    0xf05c4340,%eax
f011012f:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32 expectedVAs[numOfFFTests] = {startVA + sizeOfMetaData/2, startOf1st7KB, startVA + testSizes[0] + sizeOfMetaData/2};
f0110132:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110135:	83 c0 04             	add    $0x4,%eax
f0110138:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011013b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011013e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0110141:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0110144:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110147:	01 d0                	add    %edx,%eax
f0110149:	83 c0 04             	add    $0x4,%eax
f011014c:	89 45 a8             	mov    %eax,-0x58(%ebp)
	short* tstStartVAs[numOfFFTests+2] ;
	short* tstMidVAs[numOfFFTests+2] ;
	short* tstEndVAs[numOfFFTests+2] ;
	for (int i = 0; i < numOfFFTests; ++i)
f011014f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0110156:	e9 c8 00 00 00       	jmp    f0110223 <test_alloc_block_FF+0x298>
	{
		actualSize = testSizes[i] - sizeOfMetaData;
f011015b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011015e:	8b 44 85 ac          	mov    -0x54(%ebp,%eax,4),%eax
f0110162:	83 e8 08             	sub    $0x8,%eax
f0110165:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		va = tstStartVAs[i] = alloc_block(actualSize, DA_FF);
f0110168:	83 ec 08             	sub    $0x8,%esp
f011016b:	6a 01                	push   $0x1
f011016d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110170:	e8 39 2d 01 00       	call   f0122eae <alloc_block>
f0110175:	83 c4 10             	add    $0x10,%esp
f0110178:	89 c2                	mov    %eax,%edx
f011017a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011017d:	89 54 85 8c          	mov    %edx,-0x74(%ebp,%eax,4)
f0110181:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110184:	8b 44 85 8c          	mov    -0x74(%ebp,%eax,4),%eax
f0110188:	89 45 c8             	mov    %eax,-0x38(%ebp)
		tstMidVAs[i] = va + actualSize/2 ;
f011018b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011018e:	d1 e8                	shr    %eax
f0110190:	89 c2                	mov    %eax,%edx
f0110192:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110195:	01 c2                	add    %eax,%edx
f0110197:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011019a:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%ebp,%eax,4)
		tstEndVAs[i] = va + actualSize - sizeof(short);
f01101a1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01101a4:	8d 50 fe             	lea    -0x2(%eax),%edx
f01101a7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01101aa:	01 c2                	add    %eax,%edx
f01101ac:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01101af:	89 94 85 64 ff ff ff 	mov    %edx,-0x9c(%ebp,%eax,4)
		//Check block
		cprintf("test#%d\n",i);
f01101b6:	83 ec 08             	sub    $0x8,%esp
f01101b9:	ff 75 d0             	pushl  -0x30(%ebp)
f01101bc:	68 bb ad 12 f0       	push   $0xf012adbb
f01101c1:	e8 a6 0d ff ff       	call   f0100f6c <cprintf>
f01101c6:	83 c4 10             	add    $0x10,%esp
		expectedVA = (void*)expectedVAs[i];
f01101c9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01101cc:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
f01101d0:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if (check_block(va, expectedVA, testSizes[i], 1) == 0)
f01101d3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01101d6:	8b 44 85 ac          	mov    -0x54(%ebp,%eax,4),%eax
f01101da:	6a 01                	push   $0x1
f01101dc:	50                   	push   %eax
f01101dd:	ff 75 b8             	pushl  -0x48(%ebp)
f01101e0:	ff 75 c8             	pushl  -0x38(%ebp)
f01101e3:	e8 14 f8 ff ff       	call   f010f9fc <check_block>
f01101e8:	83 c4 10             	add    $0x10,%esp
f01101eb:	85 c0                	test   %eax,%eax
f01101ed:	75 07                	jne    f01101f6 <test_alloc_block_FF+0x26b>
		{
			is_correct = 0;
f01101ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		*(tstStartVAs[i]) = 353;
f01101f6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01101f9:	8b 44 85 8c          	mov    -0x74(%ebp,%eax,4),%eax
f01101fd:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstMidVAs[i]) = 353;
f0110202:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110205:	8b 84 85 78 ff ff ff 	mov    -0x88(%ebp,%eax,4),%eax
f011020c:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstEndVAs[i]) = 353;
f0110211:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110214:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011021b:	66 c7 00 61 01       	movw   $0x161,(%eax)
	uint32 startOf1st7KB = (uint32)startVAs[6*allocCntPerSize];
	uint32 expectedVAs[numOfFFTests] = {startVA + sizeOfMetaData/2, startOf1st7KB, startVA + testSizes[0] + sizeOfMetaData/2};
	short* tstStartVAs[numOfFFTests+2] ;
	short* tstMidVAs[numOfFFTests+2] ;
	short* tstEndVAs[numOfFFTests+2] ;
	for (int i = 0; i < numOfFFTests; ++i)
f0110220:	ff 45 d0             	incl   -0x30(%ebp)
f0110223:	83 7d d0 02          	cmpl   $0x2,-0x30(%ebp)
f0110227:	0f 8e 2e ff ff ff    	jle    f011015b <test_alloc_block_FF+0x1d0>
		}
		*(tstStartVAs[i]) = 353;
		*(tstMidVAs[i]) = 353;
		*(tstEndVAs[i]) = 353;
	}
	if (is_correct) is_correct = check_list_size(numOfAllocs);
f011022d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110231:	74 10                	je     f0110243 <test_alloc_block_FF+0x2b8>
f0110233:	83 ec 0c             	sub    $0xc,%esp
f0110236:	6a 07                	push   $0x7
f0110238:	e8 47 f8 ff ff       	call   f010fa84 <check_list_size>
f011023d:	83 c4 10             	add    $0x10,%esp
f0110240:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct)
f0110243:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110247:	74 04                	je     f011024d <test_alloc_block_FF+0x2c2>
	{
		eval += 15;
f0110249:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 3: Try to allocate a block with a size equal to the size of the first existing free block*/
	cprintf("	3: Try to allocate a block with equal to the first existing free block\n\n") ;
f011024d:	83 ec 0c             	sub    $0xc,%esp
f0110250:	68 30 ab 12 f0       	push   $0xf012ab30
f0110255:	e8 12 0d ff ff       	call   f0100f6c <cprintf>
f011025a:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011025d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	actualSize = 2*kilo - sizeOfMetaData;
f0110264:	c7 45 c4 f8 07 00 00 	movl   $0x7f8,-0x3c(%ebp)
	va = tstStartVAs[numOfFFTests] = alloc_block(actualSize, DA_FF);
f011026b:	83 ec 08             	sub    $0x8,%esp
f011026e:	6a 01                	push   $0x1
f0110270:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110273:	e8 36 2c 01 00       	call   f0122eae <alloc_block>
f0110278:	83 c4 10             	add    $0x10,%esp
f011027b:	89 45 98             	mov    %eax,-0x68(%ebp)
f011027e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0110281:	89 45 c8             	mov    %eax,-0x38(%ebp)
	tstMidVAs[numOfFFTests] = va + actualSize/2 ;
f0110284:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110287:	d1 e8                	shr    %eax
f0110289:	89 c2                	mov    %eax,%edx
f011028b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011028e:	01 d0                	add    %edx,%eax
f0110290:	89 45 84             	mov    %eax,-0x7c(%ebp)
	tstEndVAs[numOfFFTests] = va + actualSize - sizeof(short);
f0110293:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110296:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110299:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011029c:	01 d0                	add    %edx,%eax
f011029e:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
	//Check block
	expectedVA = (void*)(startVA + testSizes[0] + testSizes[2] + sizeOfMetaData/2) ;
f01102a4:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01102a7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01102aa:	01 c2                	add    %eax,%edx
f01102ac:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01102af:	01 d0                	add    %edx,%eax
f01102b1:	83 c0 04             	add    $0x4,%eax
f01102b4:	89 45 b8             	mov    %eax,-0x48(%ebp)

	if (is_correct) is_correct = check_block(va, expectedVA, 2*kilo, 1);
f01102b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01102bb:	74 18                	je     f01102d5 <test_alloc_block_FF+0x34a>
f01102bd:	6a 01                	push   $0x1
f01102bf:	68 00 08 00 00       	push   $0x800
f01102c4:	ff 75 b8             	pushl  -0x48(%ebp)
f01102c7:	ff 75 c8             	pushl  -0x38(%ebp)
f01102ca:	e8 2d f7 ff ff       	call   f010f9fc <check_block>
f01102cf:	83 c4 10             	add    $0x10,%esp
f01102d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct) is_correct = check_list_size(numOfAllocs - 1);
f01102d5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01102d9:	74 10                	je     f01102eb <test_alloc_block_FF+0x360>
f01102db:	83 ec 0c             	sub    $0xc,%esp
f01102de:	6a 06                	push   $0x6
f01102e0:	e8 9f f7 ff ff       	call   f010fa84 <check_list_size>
f01102e5:	83 c4 10             	add    $0x10,%esp
f01102e8:	89 45 e0             	mov    %eax,-0x20(%ebp)

	*(tstStartVAs[numOfFFTests]) = 353 ;
f01102eb:	8b 45 98             	mov    -0x68(%ebp),%eax
f01102ee:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstMidVAs[numOfFFTests]) = 353 ;
f01102f3:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01102f6:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstEndVAs[numOfFFTests]) = 353 ;
f01102fb:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0110301:	66 c7 00 61 01       	movw   $0x161,(%eax)

	if (is_correct)
f0110306:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011030a:	74 04                	je     f0110310 <test_alloc_block_FF+0x385>
	{
		eval += 10;
f011030c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 4: Try to allocate a block with a bit smaller size [internal fragmentation case]*/
	cprintf("	4: Try to allocate a block with a bit smaller size [internal fragmentation case]\n\n") ;
f0110310:	83 ec 0c             	sub    $0xc,%esp
f0110313:	68 c4 ad 12 f0       	push   $0xf012adc4
f0110318:	e8 4f 0c ff ff       	call   f0100f6c <cprintf>
f011031d:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110320:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	actualSize = allocSizes[1] - sizeOfMetaData - 10;
f0110327:	a1 bc 0d 18 f0       	mov    0xf0180dbc,%eax
f011032c:	83 e8 12             	sub    $0x12,%eax
f011032f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = tstStartVAs[numOfFFTests+1] = alloc_block(actualSize, DA_FF);
f0110332:	83 ec 08             	sub    $0x8,%esp
f0110335:	6a 01                	push   $0x1
f0110337:	ff 75 c4             	pushl  -0x3c(%ebp)
f011033a:	e8 6f 2b 01 00       	call   f0122eae <alloc_block>
f011033f:	83 c4 10             	add    $0x10,%esp
f0110342:	89 45 9c             	mov    %eax,-0x64(%ebp)
f0110345:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0110348:	89 45 c8             	mov    %eax,-0x38(%ebp)
	tstMidVAs[numOfFFTests+1] = va + actualSize/2 ;
f011034b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011034e:	d1 e8                	shr    %eax
f0110350:	89 c2                	mov    %eax,%edx
f0110352:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110355:	01 d0                	add    %edx,%eax
f0110357:	89 45 88             	mov    %eax,-0x78(%ebp)
	tstEndVAs[numOfFFTests+1] = va + actualSize - sizeof(short);
f011035a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011035d:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110360:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110363:	01 d0                	add    %edx,%eax
f0110365:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
	//Check block
	expectedVA = startVAs[1*allocCntPerSize];
f011036b:	a1 a0 33 5c f0       	mov    0xf05c33a0,%eax
f0110370:	89 45 b8             	mov    %eax,-0x48(%ebp)

	if (is_correct) is_correct = check_block(va, expectedVA, allocSizes[1], 1);
f0110373:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110377:	74 19                	je     f0110392 <test_alloc_block_FF+0x407>
f0110379:	a1 bc 0d 18 f0       	mov    0xf0180dbc,%eax
f011037e:	6a 01                	push   $0x1
f0110380:	50                   	push   %eax
f0110381:	ff 75 b8             	pushl  -0x48(%ebp)
f0110384:	ff 75 c8             	pushl  -0x38(%ebp)
f0110387:	e8 70 f6 ff ff       	call   f010f9fc <check_block>
f011038c:	83 c4 10             	add    $0x10,%esp
f011038f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct) is_correct = check_list_size(numOfAllocs - 2);
f0110392:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110396:	74 10                	je     f01103a8 <test_alloc_block_FF+0x41d>
f0110398:	83 ec 0c             	sub    $0xc,%esp
f011039b:	6a 05                	push   $0x5
f011039d:	e8 e2 f6 ff ff       	call   f010fa84 <check_list_size>
f01103a2:	83 c4 10             	add    $0x10,%esp
f01103a5:	89 45 e0             	mov    %eax,-0x20(%ebp)

	*(tstStartVAs[numOfFFTests+1]) = 353 ;
f01103a8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01103ab:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstMidVAs[numOfFFTests+1]) = 353 ;
f01103b0:	8b 45 88             	mov    -0x78(%ebp),%eax
f01103b3:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstEndVAs[numOfFFTests+1]) = 353 ;
f01103b8:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01103be:	66 c7 00 61 01       	movw   $0x161,(%eax)

	if (is_correct)
f01103c3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01103c7:	74 04                	je     f01103cd <test_alloc_block_FF+0x442>
	{
		eval += 10;
f01103c9:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 5: Check stored data inside each allocated block*/
	cprintf("	5: Check stored data inside each allocated block\n\n") ;
f01103cd:	83 ec 0c             	sub    $0xc,%esp
f01103d0:	68 18 ae 12 f0       	push   $0xf012ae18
f01103d5:	e8 92 0b ff ff       	call   f0100f6c <cprintf>
f01103da:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01103dd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	for (int i = 0; i < numOfFFTests + 2; ++i)
f01103e4:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f01103eb:	e9 88 00 00 00       	jmp    f0110478 <test_alloc_block_FF+0x4ed>
	{
		//cprintf("startVA = %x, mid = %x, last = %x\n", tstStartVAs[i], tstMidVAs[i], tstEndVAs[i]);
		if (*(tstStartVAs[i]) != 353 || *(tstMidVAs[i]) != 353 || *(tstEndVAs[i]) != 353)
f01103f0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01103f3:	8b 44 85 8c          	mov    -0x74(%ebp,%eax,4),%eax
f01103f7:	66 8b 00             	mov    (%eax),%ax
f01103fa:	66 3d 61 01          	cmp    $0x161,%ax
f01103fe:	75 26                	jne    f0110426 <test_alloc_block_FF+0x49b>
f0110400:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110403:	8b 84 85 78 ff ff ff 	mov    -0x88(%ebp,%eax,4),%eax
f011040a:	66 8b 00             	mov    (%eax),%ax
f011040d:	66 3d 61 01          	cmp    $0x161,%ax
f0110411:	75 13                	jne    f0110426 <test_alloc_block_FF+0x49b>
f0110413:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110416:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011041d:	66 8b 00             	mov    (%eax),%ax
f0110420:	66 3d 61 01          	cmp    $0x161,%ax
f0110424:	74 4f                	je     f0110475 <test_alloc_block_FF+0x4ea>
		{
			is_correct = 0;
f0110426:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("alloc_block_FF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
f011042d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110430:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f0110437:	66 8b 00             	mov    (%eax),%ax
f011043a:	0f bf c8             	movswl %ax,%ecx
f011043d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110440:	8b 84 85 78 ff ff ff 	mov    -0x88(%ebp,%eax,4),%eax
f0110447:	66 8b 00             	mov    (%eax),%ax
f011044a:	0f bf d0             	movswl %ax,%edx
f011044d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110450:	8b 44 85 8c          	mov    -0x74(%ebp,%eax,4),%eax
f0110454:	66 8b 00             	mov    (%eax),%ax
f0110457:	98                   	cwtl   
f0110458:	83 ec 08             	sub    $0x8,%esp
f011045b:	51                   	push   %ecx
f011045c:	52                   	push   %edx
f011045d:	50                   	push   %eax
f011045e:	68 61 01 00 00       	push   $0x161
f0110463:	ff 75 cc             	pushl  -0x34(%ebp)
f0110466:	68 4c ae 12 f0       	push   $0xf012ae4c
f011046b:	e8 fc 0a ff ff       	call   f0100f6c <cprintf>
f0110470:	83 c4 20             	add    $0x20,%esp
			break;
f0110473:	eb 0d                	jmp    f0110482 <test_alloc_block_FF+0x4f7>
	//====================================================================//
	/*FF ALLOC Scenario 5: Check stored data inside each allocated block*/
	cprintf("	5: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < numOfFFTests + 2; ++i)
f0110475:	ff 45 cc             	incl   -0x34(%ebp)
f0110478:	83 7d cc 04          	cmpl   $0x4,-0x34(%ebp)
f011047c:	0f 8e 6e ff ff ff    	jle    f01103f0 <test_alloc_block_FF+0x465>
			cprintf("alloc_block_FF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
			break;
		}
	}

	if (is_correct)
f0110482:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110486:	74 04                	je     f011048c <test_alloc_block_FF+0x501>
	{
		eval += 10;
f0110488:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
f011048c:	83 ec 08             	sub    $0x8,%esp
f011048f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0110492:	68 b8 ae 12 f0       	push   $0xf012aeb8
f0110497:	e8 d0 0a ff ff       	call   f0100f6c <cprintf>
f011049c:	83 c4 10             	add    $0x10,%esp
}
f011049f:	90                   	nop
f01104a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01104a3:	5b                   	pop    %ebx
f01104a4:	5e                   	pop    %esi
f01104a5:	5f                   	pop    %edi
f01104a6:	5d                   	pop    %ebp
f01104a7:	c3                   	ret    

f01104a8 <test_alloc_block_BF>:

void test_alloc_block_BF()
{
f01104a8:	55                   	push   %ebp
f01104a9:	89 e5                	mov    %esp,%ebp
f01104ab:	57                   	push   %edi
f01104ac:	56                   	push   %esi
f01104ad:	53                   	push   %ebx
f01104ae:	81 ec bc 00 00 00    	sub    $0xbc,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	int eval = 0;
f01104b4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_correct;
	void* va = NULL;
f01104bb:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 actualSize = 0;
f01104c2:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)

	cprintf("=======================================================\n") ;
f01104c9:	83 ec 0c             	sub    $0xc,%esp
f01104cc:	68 00 ac 12 f0       	push   $0xf012ac00
f01104d1:	e8 96 0a ff ff       	call   f0100f6c <cprintf>
f01104d6:	83 c4 10             	add    $0x10,%esp
	cprintf("FIRST: Tests depend on the Allocate Function ONLY [40%]\n") ;
f01104d9:	83 ec 0c             	sub    $0xc,%esp
f01104dc:	68 3c ac 12 f0       	push   $0xf012ac3c
f01104e1:	e8 86 0a ff ff       	call   f0100f6c <cprintf>
f01104e6:	83 c4 10             	add    $0x10,%esp
	cprintf("=======================================================\n") ;
f01104e9:	83 ec 0c             	sub    $0xc,%esp
f01104ec:	68 00 ac 12 f0       	push   $0xf012ac00
f01104f1:	e8 76 0a ff ff       	call   f0100f6c <cprintf>
f01104f6:	83 c4 10             	add    $0x10,%esp
	eval = test_initial_alloc(DA_BF);
f01104f9:	83 ec 0c             	sub    $0xc,%esp
f01104fc:	6a 03                	push   $0x3
f01104fe:	e8 9b f6 ff ff       	call   f010fb9e <test_initial_alloc>
f0110503:	83 c4 10             	add    $0x10,%esp
f0110506:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	cprintf("====================================================\n") ;
f0110509:	83 ec 0c             	sub    $0xc,%esp
f011050c:	68 78 ac 12 f0       	push   $0xf012ac78
f0110511:	e8 56 0a ff ff       	call   f0100f6c <cprintf>
f0110516:	83 c4 10             	add    $0x10,%esp
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
f0110519:	83 ec 0c             	sub    $0xc,%esp
f011051c:	68 b0 ac 12 f0       	push   $0xf012acb0
f0110521:	e8 46 0a ff ff       	call   f0100f6c <cprintf>
f0110526:	83 c4 10             	add    $0x10,%esp
	cprintf("====================================================\n") ;
f0110529:	83 ec 0c             	sub    $0xc,%esp
f011052c:	68 78 ac 12 f0       	push   $0xf012ac78
f0110531:	e8 36 0a ff ff       	call   f0100f6c <cprintf>
f0110536:	83 c4 10             	add    $0x10,%esp
	void* expectedVA;
	uint32 expectedNumFreeBlks;
	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0110539:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0110540:	eb 2c                	jmp    f011056e <test_alloc_block_BF+0xc6>
	{
		free_block(startVAs[i*allocCntPerSize]);
f0110542:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0110545:	89 d0                	mov    %edx,%eax
f0110547:	c1 e0 02             	shl    $0x2,%eax
f011054a:	01 d0                	add    %edx,%eax
f011054c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110553:	01 d0                	add    %edx,%eax
f0110555:	c1 e0 03             	shl    $0x3,%eax
f0110558:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f011055f:	83 ec 0c             	sub    $0xc,%esp
f0110562:	50                   	push   %eax
f0110563:	e8 13 3b 01 00       	call   f012407b <free_block>
f0110568:	83 c4 10             	add    $0x10,%esp
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
	cprintf("====================================================\n") ;
	void* expectedVA;
	uint32 expectedNumFreeBlks;
	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f011056b:	ff 45 dc             	incl   -0x24(%ebp)
f011056e:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f0110572:	7e ce                	jle    f0110542 <test_alloc_block_BF+0x9a>
	{
		free_block(startVAs[i*allocCntPerSize]);
	}
	//Check number of freed blocks
	is_correct = check_list_size(numOfAllocs);
f0110574:	83 ec 0c             	sub    $0xc,%esp
f0110577:	6a 07                	push   $0x7
f0110579:	e8 06 f5 ff ff       	call   f010fa84 <check_list_size>
f011057e:	83 c4 10             	add    $0x10,%esp
f0110581:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct)
f0110584:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110588:	74 04                	je     f011058e <test_alloc_block_BF+0xe6>
	{
		eval += 10;
f011058a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*BF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
f011058e:	83 ec 0c             	sub    $0xc,%esp
f0110591:	68 cc a9 12 f0       	push   $0xf012a9cc
f0110596:	e8 d1 09 ff ff       	call   f0100f6c <cprintf>
f011059b:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011059e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	uint32 maxSize = 0 ;
f01105a5:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f01105ac:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f01105b3:	eb 1f                	jmp    f01105d4 <test_alloc_block_BF+0x12c>
	{
		if (allocSizes[i] > maxSize)
f01105b5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01105b8:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f01105bf:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01105c2:	76 0d                	jbe    f01105d1 <test_alloc_block_BF+0x129>
			maxSize = allocSizes[i] ;
f01105c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01105c7:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f01105ce:	89 45 d8             	mov    %eax,-0x28(%ebp)
	/*BF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
	is_correct = 1;

	uint32 maxSize = 0 ;
	for (int i = 0; i < numOfAllocs; ++i)
f01105d1:	ff 45 d4             	incl   -0x2c(%ebp)
f01105d4:	83 7d d4 06          	cmpl   $0x6,-0x2c(%ebp)
f01105d8:	7e db                	jle    f01105b5 <test_alloc_block_BF+0x10d>
	{
		if (allocSizes[i] > maxSize)
			maxSize = allocSizes[i] ;
	}
	va = alloc_block(maxSize, DA_BF);
f01105da:	83 ec 08             	sub    $0x8,%esp
f01105dd:	6a 03                	push   $0x3
f01105df:	ff 75 d8             	pushl  -0x28(%ebp)
f01105e2:	e8 c7 28 01 00       	call   f0122eae <alloc_block>
f01105e7:	83 c4 10             	add    $0x10,%esp
f01105ea:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//Check returned va
	if(va != NULL)
f01105ed:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01105f1:	74 17                	je     f011060a <test_alloc_block_BF+0x162>
	{
		is_correct = 0;
f01105f3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_BF #5: WRONG BF ALLOC - alloc_block_BF find a block instead no existing free blocks with the given size.\n");
f01105fa:	83 ec 0c             	sub    $0xc,%esp
f01105fd:	68 f8 ae 12 f0       	push   $0xf012aef8
f0110602:	e8 65 09 ff ff       	call   f0100f6c <cprintf>
f0110607:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f011060a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011060e:	74 04                	je     f0110614 <test_alloc_block_BF+0x16c>
	{
		eval += 5;
f0110610:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	//====================================================================//
	/*BF ALLOC Scenario 2: Try to allocate blocks with sizes smaller than existing free blocks*/
	cprintf("	2: Try to allocate set of blocks with different sizes smaller than existing free blocks\n\n") ;
f0110614:	83 ec 0c             	sub    $0xc,%esp
f0110617:	68 60 ad 12 f0       	push   $0xf012ad60
f011061c:	e8 4b 09 ff ff       	call   f0100f6c <cprintf>
f0110621:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110624:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

#define numOfBFTests 5
	uint32 testSizes[numOfBFTests] = {
f011062b:	8d 45 a0             	lea    -0x60(%ebp),%eax
f011062e:	bb 54 b0 12 f0       	mov    $0xf012b054,%ebx
f0110633:	ba 05 00 00 00       	mov    $0x5,%edx
f0110638:	89 c7                	mov    %eax,%edi
f011063a:	89 de                	mov    %ebx,%esi
f011063c:	89 d1                	mov    %edx,%ecx
f011063e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			/*only 1 can fit*/4*kilo + kilo/2,
			/*many can fit*/ 1*kilo + kilo/4,
			/*many can fit*/kilo/2,
			/*many can fit*/kilo/2,
			/*only 1 can fit (@head)*/3*kilo } ;
	uint32 startOf1st1KB = (uint32)startVAs[2*allocCntPerSize];
f0110640:	a1 c0 36 5c f0       	mov    0xf05c36c0,%eax
f0110645:	89 45 c0             	mov    %eax,-0x40(%ebp)
	uint32 startOf1st2KB = (uint32)startVAs[4*allocCntPerSize];
f0110648:	a1 00 3d 5c f0       	mov    0xf05c3d00,%eax
f011064d:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32 startOf1st7KB = (uint32)startVAs[6*allocCntPerSize];
f0110650:	a1 40 43 5c f0       	mov    0xf05c4340,%eax
f0110655:	89 45 b8             	mov    %eax,-0x48(%ebp)

	uint32 expectedVAs[numOfBFTests] = {startOf1st7KB, startOf1st2KB, startOf1st2KB + testSizes[1],startOf1st1KB, KERNEL_HEAP_START + 2*sizeof(int)};
f0110658:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011065b:	89 45 8c             	mov    %eax,-0x74(%ebp)
f011065e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0110661:	89 45 90             	mov    %eax,-0x70(%ebp)
f0110664:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0110667:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011066a:	01 d0                	add    %edx,%eax
f011066c:	89 45 94             	mov    %eax,-0x6c(%ebp)
f011066f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110672:	89 45 98             	mov    %eax,-0x68(%ebp)
f0110675:	c7 45 9c 08 00 00 f6 	movl   $0xf6000008,-0x64(%ebp)
	short* tstStartVAs[numOfBFTests+2] ;
	short* tstMidVAs[numOfBFTests+2] ;
	short* tstEndVAs[numOfBFTests+2] ;
	for (int i = 0; i < numOfBFTests; ++i)
f011067c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0110683:	e9 d1 00 00 00       	jmp    f0110759 <test_alloc_block_BF+0x2b1>
	{
		actualSize = testSizes[i] - sizeOfMetaData;
f0110688:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011068b:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
f011068f:	83 e8 08             	sub    $0x8,%eax
f0110692:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		va = tstStartVAs[i] = alloc_block(actualSize, DA_BF);
f0110695:	83 ec 08             	sub    $0x8,%esp
f0110698:	6a 03                	push   $0x3
f011069a:	ff 75 c4             	pushl  -0x3c(%ebp)
f011069d:	e8 0c 28 01 00       	call   f0122eae <alloc_block>
f01106a2:	83 c4 10             	add    $0x10,%esp
f01106a5:	89 c2                	mov    %eax,%edx
f01106a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01106aa:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
f01106b1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01106b4:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f01106bb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		tstMidVAs[i] = va + actualSize/2 ;
f01106be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01106c1:	d1 e8                	shr    %eax
f01106c3:	89 c2                	mov    %eax,%edx
f01106c5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01106c8:	01 c2                	add    %eax,%edx
f01106ca:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01106cd:	89 94 85 54 ff ff ff 	mov    %edx,-0xac(%ebp,%eax,4)
		tstEndVAs[i] = va + actualSize - sizeof(short);
f01106d4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01106d7:	8d 50 fe             	lea    -0x2(%eax),%edx
f01106da:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01106dd:	01 c2                	add    %eax,%edx
f01106df:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01106e2:	89 94 85 38 ff ff ff 	mov    %edx,-0xc8(%ebp,%eax,4)

		//Check block
		cprintf("test#%d\n",i);
f01106e9:	83 ec 08             	sub    $0x8,%esp
f01106ec:	ff 75 d0             	pushl  -0x30(%ebp)
f01106ef:	68 bb ad 12 f0       	push   $0xf012adbb
f01106f4:	e8 73 08 ff ff       	call   f0100f6c <cprintf>
f01106f9:	83 c4 10             	add    $0x10,%esp
		expectedVA = (void*)expectedVAs[i];
f01106fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01106ff:	8b 44 85 8c          	mov    -0x74(%ebp,%eax,4),%eax
f0110703:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if (check_block(va, expectedVA, testSizes[i], 1) == 0)
f0110706:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110709:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
f011070d:	6a 01                	push   $0x1
f011070f:	50                   	push   %eax
f0110710:	ff 75 b4             	pushl  -0x4c(%ebp)
f0110713:	ff 75 c8             	pushl  -0x38(%ebp)
f0110716:	e8 e1 f2 ff ff       	call   f010f9fc <check_block>
f011071b:	83 c4 10             	add    $0x10,%esp
f011071e:	85 c0                	test   %eax,%eax
f0110720:	75 07                	jne    f0110729 <test_alloc_block_BF+0x281>
		{
			is_correct = 0;
f0110722:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		*(tstStartVAs[i]) = 353;
f0110729:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011072c:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f0110733:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstMidVAs[i]) = 353;
f0110738:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011073b:	8b 84 85 54 ff ff ff 	mov    -0xac(%ebp,%eax,4),%eax
f0110742:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstEndVAs[i]) = 353;
f0110747:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011074a:	8b 84 85 38 ff ff ff 	mov    -0xc8(%ebp,%eax,4),%eax
f0110751:	66 c7 00 61 01       	movw   $0x161,(%eax)

	uint32 expectedVAs[numOfBFTests] = {startOf1st7KB, startOf1st2KB, startOf1st2KB + testSizes[1],startOf1st1KB, KERNEL_HEAP_START + 2*sizeof(int)};
	short* tstStartVAs[numOfBFTests+2] ;
	short* tstMidVAs[numOfBFTests+2] ;
	short* tstEndVAs[numOfBFTests+2] ;
	for (int i = 0; i < numOfBFTests; ++i)
f0110756:	ff 45 d0             	incl   -0x30(%ebp)
f0110759:	83 7d d0 04          	cmpl   $0x4,-0x30(%ebp)
f011075d:	0f 8e 25 ff ff ff    	jle    f0110688 <test_alloc_block_BF+0x1e0>
		*(tstStartVAs[i]) = 353;
		*(tstMidVAs[i]) = 353;
		*(tstEndVAs[i]) = 353;
	}

	if (is_correct) is_correct = check_list_size(numOfAllocs);
f0110763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110767:	74 10                	je     f0110779 <test_alloc_block_BF+0x2d1>
f0110769:	83 ec 0c             	sub    $0xc,%esp
f011076c:	6a 07                	push   $0x7
f011076e:	e8 11 f3 ff ff       	call   f010fa84 <check_list_size>
f0110773:	83 c4 10             	add    $0x10,%esp
f0110776:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct)
f0110779:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011077d:	74 04                	je     f0110783 <test_alloc_block_BF+0x2db>
	{
		eval += 15;
f011077f:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	//====================================================================//
	/*BF ALLOC Scenario 3: Try to allocate a block with a size equal to the size of an existing free block*/
	cprintf("	3: Try to allocate a block with equal to an existing free block\n\n") ;
f0110783:	83 ec 0c             	sub    $0xc,%esp
f0110786:	68 70 af 12 f0       	push   $0xf012af70
f011078b:	e8 dc 07 ff ff       	call   f0100f6c <cprintf>
f0110790:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110793:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	actualSize = kilo/4 - sizeOfMetaData;
f011079a:	c7 45 c4 f8 00 00 00 	movl   $0xf8,-0x3c(%ebp)
	va = tstStartVAs[numOfBFTests] = alloc_block(actualSize, DA_BF);
f01107a1:	83 ec 08             	sub    $0x8,%esp
f01107a4:	6a 03                	push   $0x3
f01107a6:	ff 75 c4             	pushl  -0x3c(%ebp)
f01107a9:	e8 00 27 01 00       	call   f0122eae <alloc_block>
f01107ae:	83 c4 10             	add    $0x10,%esp
f01107b1:	89 45 84             	mov    %eax,-0x7c(%ebp)
f01107b4:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01107b7:	89 45 c8             	mov    %eax,-0x38(%ebp)
	tstMidVAs[numOfBFTests] = va + actualSize/2 ;
f01107ba:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01107bd:	d1 e8                	shr    %eax
f01107bf:	89 c2                	mov    %eax,%edx
f01107c1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01107c4:	01 d0                	add    %edx,%eax
f01107c6:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
	tstEndVAs[numOfBFTests] = va + actualSize - sizeof(short);
f01107cc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01107cf:	8d 50 fe             	lea    -0x2(%eax),%edx
f01107d2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01107d5:	01 d0                	add    %edx,%eax
f01107d7:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
	//Check returned va
	expectedVA = (void*)(startOf1st2KB + testSizes[1] + testSizes[3]) ;
f01107dd:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f01107e0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01107e3:	01 c2                	add    %eax,%edx
f01107e5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01107e8:	01 d0                	add    %edx,%eax
f01107ea:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (is_correct) is_correct = check_block(va, expectedVA, kilo/4, 1);
f01107ed:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01107f1:	74 18                	je     f011080b <test_alloc_block_BF+0x363>
f01107f3:	6a 01                	push   $0x1
f01107f5:	68 00 01 00 00       	push   $0x100
f01107fa:	ff 75 b4             	pushl  -0x4c(%ebp)
f01107fd:	ff 75 c8             	pushl  -0x38(%ebp)
f0110800:	e8 f7 f1 ff ff       	call   f010f9fc <check_block>
f0110805:	83 c4 10             	add    $0x10,%esp
f0110808:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct) is_correct = check_list_size(numOfAllocs-1);
f011080b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011080f:	74 10                	je     f0110821 <test_alloc_block_BF+0x379>
f0110811:	83 ec 0c             	sub    $0xc,%esp
f0110814:	6a 06                	push   $0x6
f0110816:	e8 69 f2 ff ff       	call   f010fa84 <check_list_size>
f011081b:	83 c4 10             	add    $0x10,%esp
f011081e:	89 45 e0             	mov    %eax,-0x20(%ebp)

	*(tstStartVAs[numOfBFTests]) = 353 ;
f0110821:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0110824:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstMidVAs[numOfBFTests]) = 353 ;
f0110829:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f011082f:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstEndVAs[numOfBFTests]) = 353 ;
f0110834:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011083a:	66 c7 00 61 01       	movw   $0x161,(%eax)

	if (is_correct)
f011083f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110843:	74 04                	je     f0110849 <test_alloc_block_BF+0x3a1>
	{
		eval += 10;
f0110845:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 4: Try to allocate a block with a bit smaller size [internal fragmentation case]*/
	cprintf("	4: Try to allocate a block with a bit smaller size [internal fragmentation case]\n\n") ;
f0110849:	83 ec 0c             	sub    $0xc,%esp
f011084c:	68 c4 ad 12 f0       	push   $0xf012adc4
f0110851:	e8 16 07 ff ff       	call   f0100f6c <cprintf>
f0110856:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110859:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	actualSize = allocSizes[5] - sizeOfMetaData - 2;
f0110860:	a1 cc 0d 18 f0       	mov    0xf0180dcc,%eax
f0110865:	83 e8 0a             	sub    $0xa,%eax
f0110868:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = tstStartVAs[numOfBFTests+1] = alloc_block(actualSize, DA_BF);
f011086b:	83 ec 08             	sub    $0x8,%esp
f011086e:	6a 03                	push   $0x3
f0110870:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110873:	e8 36 26 01 00       	call   f0122eae <alloc_block>
f0110878:	83 c4 10             	add    $0x10,%esp
f011087b:	89 45 88             	mov    %eax,-0x78(%ebp)
f011087e:	8b 45 88             	mov    -0x78(%ebp),%eax
f0110881:	89 45 c8             	mov    %eax,-0x38(%ebp)
	tstMidVAs[numOfBFTests+1] = va + 2 ;
f0110884:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110887:	83 c0 02             	add    $0x2,%eax
f011088a:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
	tstEndVAs[numOfBFTests+1] = va + actualSize - sizeof(short);
f0110890:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110893:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110896:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110899:	01 d0                	add    %edx,%eax
f011089b:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
	//Check block
	expectedVA = startVAs[5*allocCntPerSize];
f01108a1:	a1 20 40 5c f0       	mov    0xf05c4020,%eax
f01108a6:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	if (is_correct) is_correct = check_block(va, expectedVA, allocSizes[5], 1);
f01108a9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01108ad:	74 19                	je     f01108c8 <test_alloc_block_BF+0x420>
f01108af:	a1 cc 0d 18 f0       	mov    0xf0180dcc,%eax
f01108b4:	6a 01                	push   $0x1
f01108b6:	50                   	push   %eax
f01108b7:	ff 75 b4             	pushl  -0x4c(%ebp)
f01108ba:	ff 75 c8             	pushl  -0x38(%ebp)
f01108bd:	e8 3a f1 ff ff       	call   f010f9fc <check_block>
f01108c2:	83 c4 10             	add    $0x10,%esp
f01108c5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (is_correct) is_correct = check_list_size(numOfAllocs - 2);
f01108c8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01108cc:	74 10                	je     f01108de <test_alloc_block_BF+0x436>
f01108ce:	83 ec 0c             	sub    $0xc,%esp
f01108d1:	6a 05                	push   $0x5
f01108d3:	e8 ac f1 ff ff       	call   f010fa84 <check_list_size>
f01108d8:	83 c4 10             	add    $0x10,%esp
f01108db:	89 45 e0             	mov    %eax,-0x20(%ebp)

	*(tstStartVAs[numOfBFTests+1]) = 353 ;
f01108de:	8b 45 88             	mov    -0x78(%ebp),%eax
f01108e1:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstMidVAs[numOfBFTests+1]) = 353 ;
f01108e6:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f01108ec:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstEndVAs[numOfBFTests+1]) = 353 ;
f01108f1:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01108f7:	66 c7 00 61 01       	movw   $0x161,(%eax)

	if (is_correct)
f01108fc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110900:	74 04                	je     f0110906 <test_alloc_block_BF+0x45e>
	{
		eval += 10;
f0110902:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*BF ALLOC Scenario 5: Check stored data inside each allocated block*/
	cprintf("	5: Check stored data inside each allocated block\n\n") ;
f0110906:	83 ec 0c             	sub    $0xc,%esp
f0110909:	68 18 ae 12 f0       	push   $0xf012ae18
f011090e:	e8 59 06 ff ff       	call   f0100f6c <cprintf>
f0110913:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110916:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	for (int i = 0; i < numOfBFTests+2; ++i)
f011091d:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0110924:	e9 8e 00 00 00       	jmp    f01109b7 <test_alloc_block_BF+0x50f>
	{
		//cprintf("startVA = %x, mid = %x, last = %x\n", tstStartVAs[i], tstMidVAs[i], tstEndVAs[i]);
		if (*(tstStartVAs[i]) != 353 || *(tstMidVAs[i]) != 353 || *(tstEndVAs[i]) != 353)
f0110929:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011092c:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f0110933:	66 8b 00             	mov    (%eax),%ax
f0110936:	66 3d 61 01          	cmp    $0x161,%ax
f011093a:	75 26                	jne    f0110962 <test_alloc_block_BF+0x4ba>
f011093c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011093f:	8b 84 85 54 ff ff ff 	mov    -0xac(%ebp,%eax,4),%eax
f0110946:	66 8b 00             	mov    (%eax),%ax
f0110949:	66 3d 61 01          	cmp    $0x161,%ax
f011094d:	75 13                	jne    f0110962 <test_alloc_block_BF+0x4ba>
f011094f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110952:	8b 84 85 38 ff ff ff 	mov    -0xc8(%ebp,%eax,4),%eax
f0110959:	66 8b 00             	mov    (%eax),%ax
f011095c:	66 3d 61 01          	cmp    $0x161,%ax
f0110960:	74 52                	je     f01109b4 <test_alloc_block_BF+0x50c>
		{
			//cprintf("start VA = %x, mid VA = %x, end VA = %x\n", tstStartVAs[i], tstMidVAs[i], tstEndVAs[i]);
			is_correct = 0;
f0110962:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("alloc_block_BF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
f0110969:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011096c:	8b 84 85 38 ff ff ff 	mov    -0xc8(%ebp,%eax,4),%eax
f0110973:	66 8b 00             	mov    (%eax),%ax
f0110976:	0f bf c8             	movswl %ax,%ecx
f0110979:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011097c:	8b 84 85 54 ff ff ff 	mov    -0xac(%ebp,%eax,4),%eax
f0110983:	66 8b 00             	mov    (%eax),%ax
f0110986:	0f bf d0             	movswl %ax,%edx
f0110989:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011098c:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f0110993:	66 8b 00             	mov    (%eax),%ax
f0110996:	98                   	cwtl   
f0110997:	83 ec 08             	sub    $0x8,%esp
f011099a:	51                   	push   %ecx
f011099b:	52                   	push   %edx
f011099c:	50                   	push   %eax
f011099d:	68 61 01 00 00       	push   $0x161
f01109a2:	ff 75 cc             	pushl  -0x34(%ebp)
f01109a5:	68 b4 af 12 f0       	push   $0xf012afb4
f01109aa:	e8 bd 05 ff ff       	call   f0100f6c <cprintf>
f01109af:	83 c4 20             	add    $0x20,%esp
			break;
f01109b2:	eb 0d                	jmp    f01109c1 <test_alloc_block_BF+0x519>
	//====================================================================//
	/*BF ALLOC Scenario 5: Check stored data inside each allocated block*/
	cprintf("	5: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < numOfBFTests+2; ++i)
f01109b4:	ff 45 cc             	incl   -0x34(%ebp)
f01109b7:	83 7d cc 06          	cmpl   $0x6,-0x34(%ebp)
f01109bb:	0f 8e 68 ff ff ff    	jle    f0110929 <test_alloc_block_BF+0x481>
			cprintf("alloc_block_BF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
			break;
		}
	}

	if (is_correct)
f01109c1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01109c5:	74 04                	je     f01109cb <test_alloc_block_BF+0x523>
	{
		eval += 10;
f01109c7:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
f01109cb:	83 ec 08             	sub    $0x8,%esp
f01109ce:	ff 75 e4             	pushl  -0x1c(%ebp)
f01109d1:	68 20 b0 12 f0       	push   $0xf012b020
f01109d6:	e8 91 05 ff ff       	call   f0100f6c <cprintf>
f01109db:	83 c4 10             	add    $0x10,%esp
}
f01109de:	90                   	nop
f01109df:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01109e2:	5b                   	pop    %ebx
f01109e3:	5e                   	pop    %esi
f01109e4:	5f                   	pop    %edi
f01109e5:	5d                   	pop    %ebp
f01109e6:	c3                   	ret    

f01109e7 <test_alloc_block_NF>:

void test_alloc_block_NF()
{
f01109e7:	55                   	push   %ebp
f01109e8:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f01109ea:	90                   	nop
f01109eb:	5d                   	pop    %ebp
f01109ec:	c3                   	ret    

f01109ed <test_free_block_FF>:

void test_free_block_FF()
{
f01109ed:	55                   	push   %ebp
f01109ee:	89 e5                	mov    %esp,%ebp
f01109f0:	53                   	push   %ebx
f01109f1:	81 ec 94 00 00 00    	sub    $0x94,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	cprintf("===========================================================\n") ;
f01109f7:	83 ec 0c             	sub    $0xc,%esp
f01109fa:	68 68 b0 12 f0       	push   $0xf012b068
f01109ff:	e8 68 05 ff ff       	call   f0100f6c <cprintf>
f0110a04:	83 c4 10             	add    $0x10,%esp
	cprintf("NOTE: THIS TEST IS DEPEND ON BOTH ALLOCATE & FREE FUNCTIONS\n") ;
f0110a07:	83 ec 0c             	sub    $0xc,%esp
f0110a0a:	68 a8 b0 12 f0       	push   $0xf012b0a8
f0110a0f:	e8 58 05 ff ff       	call   f0100f6c <cprintf>
f0110a14:	83 c4 10             	add    $0x10,%esp
	cprintf("===========================================================\n") ;
f0110a17:	83 ec 0c             	sub    $0xc,%esp
f0110a1a:	68 68 b0 12 f0       	push   $0xf012b068
f0110a1f:	e8 48 05 ff ff       	call   f0100f6c <cprintf>
f0110a24:	83 c4 10             	add    $0x10,%esp
	void*expected_va ;

	int eval = 0;
f0110a27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool is_correct;
	int initAllocatedSpace = 3*Mega;
f0110a2e:	c7 45 cc 00 00 30 00 	movl   $0x300000,-0x34(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f0110a35:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110a38:	83 ec 08             	sub    $0x8,%esp
f0110a3b:	50                   	push   %eax
f0110a3c:	68 00 00 00 f6       	push   $0xf6000000
f0110a41:	e8 95 25 01 00       	call   f0122fdb <initialize_dynamic_allocator>
f0110a46:	83 c4 10             	add    $0x10,%esp

	void * va ;
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;
f0110a49:	83 ec 0c             	sub    $0xc,%esp
f0110a4c:	68 e8 b0 12 f0       	push   $0xf012b0e8
f0110a51:	e8 16 05 ff ff       	call   f0100f6c <cprintf>
f0110a56:	83 c4 10             	add    $0x10,%esp

	int totalSizes = 0;
f0110a59:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f0110a60:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110a67:	eb 2a                	jmp    f0110a93 <test_free_block_FF+0xa6>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f0110a69:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110a6c:	8b 14 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%edx
f0110a73:	89 d0                	mov    %edx,%eax
f0110a75:	c1 e0 02             	shl    $0x2,%eax
f0110a78:	01 d0                	add    %edx,%eax
f0110a7a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110a81:	01 d0                	add    %edx,%eax
f0110a83:	c1 e0 03             	shl    $0x3,%eax
f0110a86:	89 c2                	mov    %eax,%edx
f0110a88:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110a8b:	01 d0                	add    %edx,%eax
f0110a8d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;

	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f0110a90:	ff 45 e8             	incl   -0x18(%ebp)
f0110a93:	83 7d e8 06          	cmpl   $0x6,-0x18(%ebp)
f0110a97:	7e d0                	jle    f0110a69 <test_free_block_FF+0x7c>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
	}
	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ; //exclude size of "DA Begin & End" blocks
f0110a99:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110a9c:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0110a9f:	83 e8 08             	sub    $0x8,%eax
f0110aa2:	89 45 c8             	mov    %eax,-0x38(%ebp)
	if (remainSize <= 0)
f0110aa5:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0110aa9:	7f 17                	jg     f0110ac2 <test_free_block_FF+0xd5>
		panic("test_free_block is not configured correctly. Consider updating the initial allocated space OR the required allocations");
f0110aab:	83 ec 04             	sub    $0x4,%esp
f0110aae:	68 40 b1 12 f0       	push   $0xf012b140
f0110ab3:	68 68 02 00 00       	push   $0x268
f0110ab8:	68 34 a9 12 f0       	push   $0xf012a934
f0110abd:	e8 58 f8 fe ff       	call   f010031a <_panic>

	int idx = 0;
f0110ac2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
f0110ac9:	c7 45 e0 04 00 00 f6 	movl   $0xf6000004,-0x20(%ebp)
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f0110ad0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0110ad7:	e9 0b 01 00 00       	jmp    f0110be7 <test_free_block_FF+0x1fa>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f0110adc:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0110ae3:	e9 ef 00 00 00       	jmp    f0110bd7 <test_free_block_FF+0x1ea>
		{
			actualSize = allocSizes[i] - sizeOfMetaData;
f0110ae8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110aeb:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f0110af2:	83 e8 08             	sub    $0x8,%eax
f0110af5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			va = startVAs[idx] = alloc_block(actualSize, DA_FF);
f0110af8:	83 ec 08             	sub    $0x8,%esp
f0110afb:	6a 01                	push   $0x1
f0110afd:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110b00:	e8 a9 23 01 00       	call   f0122eae <alloc_block>
f0110b05:	83 c4 10             	add    $0x10,%esp
f0110b08:	89 c2                	mov    %eax,%edx
f0110b0a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110b0d:	89 14 85 80 30 5c f0 	mov    %edx,-0xfa3cf80(,%eax,4)
f0110b14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110b17:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0110b1e:	89 45 c0             	mov    %eax,-0x40(%ebp)
			midVAs[idx] = va + actualSize/2 ;
f0110b21:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110b24:	d1 e8                	shr    %eax
f0110b26:	89 c2                	mov    %eax,%edx
f0110b28:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110b2b:	01 c2                	add    %eax,%edx
f0110b2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110b30:	89 14 85 80 5c 5c f0 	mov    %edx,-0xfa3a380(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f0110b37:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110b3a:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110b3d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110b40:	01 c2                	add    %eax,%edx
f0110b42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110b45:	89 14 85 80 46 5c f0 	mov    %edx,-0xfa3b980(,%eax,4)
			//Check returned va
			expected_va = curVA + sizeOfMetaData/2;
f0110b4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110b4f:	83 c0 04             	add    $0x4,%eax
f0110b52:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (check_block(va, expected_va, allocSizes[i], 1) == 0)
f0110b55:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110b58:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f0110b5f:	6a 01                	push   $0x1
f0110b61:	50                   	push   %eax
f0110b62:	ff 75 bc             	pushl  -0x44(%ebp)
f0110b65:	ff 75 c0             	pushl  -0x40(%ebp)
f0110b68:	e8 8f ee ff ff       	call   f010f9fc <check_block>
f0110b6d:	83 c4 10             	add    $0x10,%esp
f0110b70:	85 c0                	test   %eax,%eax
f0110b72:	75 20                	jne    f0110b94 <test_free_block_FF+0x1a7>
				//			if(va != (curVA + sizeOfMetaData/2))
				panic("test_free_block #1.%d: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x", idx, expected_va ,va);
f0110b74:	83 ec 08             	sub    $0x8,%esp
f0110b77:	ff 75 c0             	pushl  -0x40(%ebp)
f0110b7a:	ff 75 bc             	pushl  -0x44(%ebp)
f0110b7d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0110b80:	68 b8 b1 12 f0       	push   $0xf012b1b8
f0110b85:	68 79 02 00 00       	push   $0x279
f0110b8a:	68 34 a9 12 f0       	push   $0xf012a934
f0110b8f:	e8 86 f7 fe ff       	call   f010031a <_panic>
			curVA += allocSizes[i] ;
f0110b94:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110b97:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f0110b9e:	01 45 e0             	add    %eax,-0x20(%ebp)
			*(startVAs[idx]) = idx ;
f0110ba1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110ba4:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0110bab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110bae:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f0110bb1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110bb4:	8b 14 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%edx
f0110bbb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110bbe:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f0110bc1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110bc4:	8b 14 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%edx
f0110bcb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110bce:	66 89 02             	mov    %ax,(%edx)
			idx++;
f0110bd1:	ff 45 e4             	incl   -0x1c(%ebp)
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f0110bd4:	ff 45 d8             	incl   -0x28(%ebp)
f0110bd7:	81 7d d8 c7 00 00 00 	cmpl   $0xc7,-0x28(%ebp)
f0110bde:	0f 8e 04 ff ff ff    	jle    f0110ae8 <test_free_block_FF+0xfb>
		panic("test_free_block is not configured correctly. Consider updating the initial allocated space OR the required allocations");

	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f0110be4:	ff 45 dc             	incl   -0x24(%ebp)
f0110be7:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f0110beb:	0f 8e eb fe ff ff    	jle    f0110adc <test_free_block_FF+0xef>
		}
	}

	//====================================================================//
	/* Try to allocate a block with a size equal to the size of the first existing free block*/
	actualSize = remainSize - sizeOfMetaData;
f0110bf1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110bf4:	83 e8 08             	sub    $0x8,%eax
f0110bf7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = startVAs[idx] = alloc_block(actualSize, DA_FF);
f0110bfa:	83 ec 08             	sub    $0x8,%esp
f0110bfd:	6a 01                	push   $0x1
f0110bff:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110c02:	e8 a7 22 01 00       	call   f0122eae <alloc_block>
f0110c07:	83 c4 10             	add    $0x10,%esp
f0110c0a:	89 c2                	mov    %eax,%edx
f0110c0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110c0f:	89 14 85 80 30 5c f0 	mov    %edx,-0xfa3cf80(,%eax,4)
f0110c16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110c19:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0110c20:	89 45 c0             	mov    %eax,-0x40(%ebp)
	midVAs[idx] = va + actualSize/2 ;
f0110c23:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110c26:	d1 e8                	shr    %eax
f0110c28:	89 c2                	mov    %eax,%edx
f0110c2a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110c2d:	01 c2                	add    %eax,%edx
f0110c2f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110c32:	89 14 85 80 5c 5c f0 	mov    %edx,-0xfa3a380(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f0110c39:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110c3c:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110c3f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110c42:	01 c2                	add    %eax,%edx
f0110c44:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110c47:	89 14 85 80 46 5c f0 	mov    %edx,-0xfa3b980(,%eax,4)
	//Check returned va
	expected_va = curVA + sizeOfMetaData/2;
f0110c4e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110c51:	83 c0 04             	add    $0x4,%eax
f0110c54:	89 45 bc             	mov    %eax,-0x44(%ebp)
	if (check_block(va, expected_va, remainSize, 1) == 0)
f0110c57:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110c5a:	6a 01                	push   $0x1
f0110c5c:	50                   	push   %eax
f0110c5d:	ff 75 bc             	pushl  -0x44(%ebp)
f0110c60:	ff 75 c0             	pushl  -0x40(%ebp)
f0110c63:	e8 94 ed ff ff       	call   f010f9fc <check_block>
f0110c68:	83 c4 10             	add    $0x10,%esp
f0110c6b:	85 c0                	test   %eax,%eax
f0110c6d:	75 1d                	jne    f0110c8c <test_free_block_FF+0x29f>
		//			if(va != (curVA + sizeOfMetaData/2))
		panic("test_free_block #2: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x",  expected_va ,va);
f0110c6f:	83 ec 0c             	sub    $0xc,%esp
f0110c72:	ff 75 c0             	pushl  -0x40(%ebp)
f0110c75:	ff 75 bc             	pushl  -0x44(%ebp)
f0110c78:	68 1c b2 12 f0       	push   $0xf012b21c
f0110c7d:	68 8c 02 00 00       	push   $0x28c
f0110c82:	68 34 a9 12 f0       	push   $0xf012a934
f0110c87:	e8 8e f6 fe ff       	call   f010031a <_panic>
	*(startVAs[idx]) = idx ;
f0110c8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110c8f:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0110c96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110c99:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f0110c9c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110c9f:	8b 14 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%edx
f0110ca6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110ca9:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f0110cac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110caf:	8b 14 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%edx
f0110cb6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110cb9:	66 89 02             	mov    %ax,(%edx)

	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;
f0110cbc:	83 ec 0c             	sub    $0xc,%esp
f0110cbf:	68 7c b2 12 f0       	push   $0xf012b27c
f0110cc4:	e8 a3 02 ff ff       	call   f0100f6c <cprintf>
f0110cc9:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110ccc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	for (int i = 0; i < idx; ++i)
f0110cd3:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0110cda:	eb 5b                	jmp    f0110d37 <test_free_block_FF+0x34a>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f0110cdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110cdf:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0110ce6:	66 8b 00             	mov    (%eax),%ax
f0110ce9:	98                   	cwtl   
f0110cea:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0110ced:	75 26                	jne    f0110d15 <test_free_block_FF+0x328>
f0110cef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110cf2:	8b 04 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%eax
f0110cf9:	66 8b 00             	mov    (%eax),%ax
f0110cfc:	98                   	cwtl   
f0110cfd:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0110d00:	75 13                	jne    f0110d15 <test_free_block_FF+0x328>
f0110d02:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110d05:	8b 04 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%eax
f0110d0c:	66 8b 00             	mov    (%eax),%ax
f0110d0f:	98                   	cwtl   
f0110d10:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0110d13:	74 1f                	je     f0110d34 <test_free_block_FF+0x347>
		{
			is_correct = 0;
f0110d15:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_free_block #3.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
f0110d1c:	83 ec 04             	sub    $0x4,%esp
f0110d1f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0110d22:	ff 75 d4             	pushl  -0x2c(%ebp)
f0110d25:	68 b0 b2 12 f0       	push   $0xf012b2b0
f0110d2a:	e8 3d 02 ff ff       	call   f0100f6c <cprintf>
f0110d2f:	83 c4 10             	add    $0x10,%esp
			break;
f0110d32:	eb 0b                	jmp    f0110d3f <test_free_block_FF+0x352>
	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < idx; ++i)
f0110d34:	ff 45 d4             	incl   -0x2c(%ebp)
f0110d37:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110d3a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110d3d:	7c 9d                	jl     f0110cdc <test_free_block_FF+0x2ef>
		}
	}

	//====================================================================//
	/* free_block Scenario 1: Free some allocated blocks [no coalesce]*/
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;
f0110d3f:	83 ec 0c             	sub    $0xc,%esp
f0110d42:	68 00 b3 12 f0       	push   $0xf012b300
f0110d47:	e8 20 02 ff ff       	call   f0100f6c <cprintf>
f0110d4c:	83 c4 10             	add    $0x10,%esp
	uint32 block_size, block_status, expected_size, *blk_header, *blk_footer;
	is_correct = 1;
f0110d4f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0110d56:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0110d5d:	e9 9b 00 00 00       	jmp    f0110dfd <test_free_block_FF+0x410>
	{
		cprintf("test#%d\n",i);
f0110d62:	83 ec 08             	sub    $0x8,%esp
f0110d65:	ff 75 d0             	pushl  -0x30(%ebp)
f0110d68:	68 bb ad 12 f0       	push   $0xf012adbb
f0110d6d:	e8 fa 01 ff ff       	call   f0100f6c <cprintf>
f0110d72:	83 c4 10             	add    $0x10,%esp
		free_block(startVAs[i*allocCntPerSize]);
f0110d75:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0110d78:	89 d0                	mov    %edx,%eax
f0110d7a:	c1 e0 02             	shl    $0x2,%eax
f0110d7d:	01 d0                	add    %edx,%eax
f0110d7f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110d86:	01 d0                	add    %edx,%eax
f0110d88:	c1 e0 03             	shl    $0x3,%eax
f0110d8b:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0110d92:	83 ec 0c             	sub    $0xc,%esp
f0110d95:	50                   	push   %eax
f0110d96:	e8 e0 32 01 00       	call   f012407b <free_block>
f0110d9b:	83 c4 10             	add    $0x10,%esp
		if (check_block(startVAs[i*allocCntPerSize], startVAs[i*allocCntPerSize], allocSizes[i], 0) == 0)
f0110d9e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110da1:	8b 0c 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%ecx
f0110da8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0110dab:	89 d0                	mov    %edx,%eax
f0110dad:	c1 e0 02             	shl    $0x2,%eax
f0110db0:	01 d0                	add    %edx,%eax
f0110db2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110db9:	01 d0                	add    %edx,%eax
f0110dbb:	c1 e0 03             	shl    $0x3,%eax
f0110dbe:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0110dc5:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f0110dc8:	89 d8                	mov    %ebx,%eax
f0110dca:	c1 e0 02             	shl    $0x2,%eax
f0110dcd:	01 d8                	add    %ebx,%eax
f0110dcf:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0110dd6:	01 d8                	add    %ebx,%eax
f0110dd8:	c1 e0 03             	shl    $0x3,%eax
f0110ddb:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0110de2:	6a 00                	push   $0x0
f0110de4:	51                   	push   %ecx
f0110de5:	52                   	push   %edx
f0110de6:	50                   	push   %eax
f0110de7:	e8 10 ec ff ff       	call   f010f9fc <check_block>
f0110dec:	83 c4 10             	add    $0x10,%esp
f0110def:	85 c0                	test   %eax,%eax
f0110df1:	75 07                	jne    f0110dfa <test_free_block_FF+0x40d>
		{
			is_correct = 0;
f0110df3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;
	uint32 block_size, block_status, expected_size, *blk_header, *blk_footer;
	is_correct = 1;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0110dfa:	ff 45 d0             	incl   -0x30(%ebp)
f0110dfd:	83 7d d0 06          	cmpl   $0x6,-0x30(%ebp)
f0110e01:	0f 8e 5b ff ff ff    	jle    f0110d62 <test_free_block_FF+0x375>
		if (check_block(startVAs[i*allocCntPerSize], startVAs[i*allocCntPerSize], allocSizes[i], 0) == 0)
		{
			is_correct = 0;
		}
	}
	uint32 expectedNumOfFreeBlks = numOfAllocs;
f0110e07:	c7 45 b8 07 00 00 00 	movl   $0x7,-0x48(%ebp)
	if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f0110e0e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e12:	74 11                	je     f0110e25 <test_free_block_FF+0x438>
f0110e14:	83 ec 0c             	sub    $0xc,%esp
f0110e17:	ff 75 b8             	pushl  -0x48(%ebp)
f0110e1a:	e8 65 ec ff ff       	call   f010fa84 <check_list_size>
f0110e1f:	83 c4 10             	add    $0x10,%esp
f0110e22:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (is_correct)
f0110e25:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e29:	74 04                	je     f0110e2f <test_free_block_FF+0x442>
	{
		eval += 10;
f0110e2b:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	is_correct = 1;
f0110e2f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Free last block
	free_block(startVAs[numOfAllocs*allocCntPerSize]);
f0110e36:	a1 60 46 5c f0       	mov    0xf05c4660,%eax
f0110e3b:	83 ec 0c             	sub    $0xc,%esp
f0110e3e:	50                   	push   %eax
f0110e3f:	e8 37 32 01 00       	call   f012407b <free_block>
f0110e44:	83 c4 10             	add    $0x10,%esp
	if (is_correct) is_correct = check_block(startVAs[numOfAllocs*allocCntPerSize], startVAs[numOfAllocs*allocCntPerSize], remainSize, 0);
f0110e47:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e4b:	74 1e                	je     f0110e6b <test_free_block_FF+0x47e>
f0110e4d:	8b 4d c8             	mov    -0x38(%ebp),%ecx
f0110e50:	8b 15 60 46 5c f0    	mov    0xf05c4660,%edx
f0110e56:	a1 60 46 5c f0       	mov    0xf05c4660,%eax
f0110e5b:	6a 00                	push   $0x0
f0110e5d:	51                   	push   %ecx
f0110e5e:	52                   	push   %edx
f0110e5f:	50                   	push   %eax
f0110e60:	e8 97 eb ff ff       	call   f010f9fc <check_block>
f0110e65:	83 c4 10             	add    $0x10,%esp
f0110e68:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//Reallocate last block
	actualSize = remainSize - sizeOfMetaData;
f0110e6b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110e6e:	83 e8 08             	sub    $0x8,%eax
f0110e71:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110e74:	83 ec 08             	sub    $0x8,%esp
f0110e77:	6a 01                	push   $0x1
f0110e79:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110e7c:	e8 2d 20 01 00       	call   f0122eae <alloc_block>
f0110e81:	83 c4 10             	add    $0x10,%esp
f0110e84:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check block
	expected_va = (curVA + sizeOfMetaData/2);
f0110e87:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110e8a:	83 c0 04             	add    $0x4,%eax
f0110e8d:	89 45 bc             	mov    %eax,-0x44(%ebp)
	if (is_correct) is_correct = check_block(va, expected_va, remainSize, 1);
f0110e90:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e94:	74 17                	je     f0110ead <test_free_block_FF+0x4c0>
f0110e96:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110e99:	6a 01                	push   $0x1
f0110e9b:	50                   	push   %eax
f0110e9c:	ff 75 bc             	pushl  -0x44(%ebp)
f0110e9f:	ff 75 c0             	pushl  -0x40(%ebp)
f0110ea2:	e8 55 eb ff ff       	call   f010f9fc <check_block>
f0110ea7:	83 c4 10             	add    $0x10,%esp
f0110eaa:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//Free block before last
	free_block(startVAs[numOfAllocs*allocCntPerSize - 1]);
f0110ead:	a1 5c 46 5c f0       	mov    0xf05c465c,%eax
f0110eb2:	83 ec 0c             	sub    $0xc,%esp
f0110eb5:	50                   	push   %eax
f0110eb6:	e8 c0 31 01 00       	call   f012407b <free_block>
f0110ebb:	83 c4 10             	add    $0x10,%esp
	if (is_correct) is_correct = check_block(startVAs[numOfAllocs*allocCntPerSize-1], startVAs[numOfAllocs*allocCntPerSize-1], allocSizes[numOfAllocs-1], 0);
f0110ebe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110ec2:	74 21                	je     f0110ee5 <test_free_block_FF+0x4f8>
f0110ec4:	8b 0d d0 0d 18 f0    	mov    0xf0180dd0,%ecx
f0110eca:	8b 15 5c 46 5c f0    	mov    0xf05c465c,%edx
f0110ed0:	a1 5c 46 5c f0       	mov    0xf05c465c,%eax
f0110ed5:	6a 00                	push   $0x0
f0110ed7:	51                   	push   %ecx
f0110ed8:	52                   	push   %edx
f0110ed9:	50                   	push   %eax
f0110eda:	e8 1d eb ff ff       	call   f010f9fc <check_block>
f0110edf:	83 c4 10             	add    $0x10,%esp
f0110ee2:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//Reallocate first block
	actualSize = allocSizes[0] - sizeOfMetaData;
f0110ee5:	a1 b8 0d 18 f0       	mov    0xf0180db8,%eax
f0110eea:	83 e8 08             	sub    $0x8,%eax
f0110eed:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110ef0:	83 ec 08             	sub    $0x8,%esp
f0110ef3:	6a 01                	push   $0x1
f0110ef5:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110ef8:	e8 b1 1f 01 00       	call   f0122eae <alloc_block>
f0110efd:	83 c4 10             	add    $0x10,%esp
f0110f00:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected_va = (void*)(KERNEL_HEAP_START + sizeof(int) + sizeOfMetaData/2);
f0110f03:	c7 45 bc 08 00 00 f6 	movl   $0xf6000008,-0x44(%ebp)
	if (is_correct) is_correct = check_block(va, expected_va, allocSizes[0], 1);
f0110f0a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110f0e:	74 19                	je     f0110f29 <test_free_block_FF+0x53c>
f0110f10:	a1 b8 0d 18 f0       	mov    0xf0180db8,%eax
f0110f15:	6a 01                	push   $0x1
f0110f17:	50                   	push   %eax
f0110f18:	ff 75 bc             	pushl  -0x44(%ebp)
f0110f1b:	ff 75 c0             	pushl  -0x40(%ebp)
f0110f1e:	e8 d9 ea ff ff       	call   f010f9fc <check_block>
f0110f23:	83 c4 10             	add    $0x10,%esp
f0110f26:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//Free 2nd block
	free_block(startVAs[1]);
f0110f29:	a1 84 30 5c f0       	mov    0xf05c3084,%eax
f0110f2e:	83 ec 0c             	sub    $0xc,%esp
f0110f31:	50                   	push   %eax
f0110f32:	e8 44 31 01 00       	call   f012407b <free_block>
f0110f37:	83 c4 10             	add    $0x10,%esp
	if (is_correct) is_correct = check_block(startVAs[1], startVAs[1], allocSizes[0], 0);
f0110f3a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110f3e:	74 21                	je     f0110f61 <test_free_block_FF+0x574>
f0110f40:	8b 0d b8 0d 18 f0    	mov    0xf0180db8,%ecx
f0110f46:	8b 15 84 30 5c f0    	mov    0xf05c3084,%edx
f0110f4c:	a1 84 30 5c f0       	mov    0xf05c3084,%eax
f0110f51:	6a 00                	push   $0x0
f0110f53:	51                   	push   %ecx
f0110f54:	52                   	push   %edx
f0110f55:	50                   	push   %eax
f0110f56:	e8 a1 ea ff ff       	call   f010f9fc <check_block>
f0110f5b:	83 c4 10             	add    $0x10,%esp
f0110f5e:	89 45 f0             	mov    %eax,-0x10(%ebp)

	expectedNumOfFreeBlks++ ;
f0110f61:	ff 45 b8             	incl   -0x48(%ebp)
	if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f0110f64:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110f68:	74 11                	je     f0110f7b <test_free_block_FF+0x58e>
f0110f6a:	83 ec 0c             	sub    $0xc,%esp
f0110f6d:	ff 75 b8             	pushl  -0x48(%ebp)
f0110f70:	e8 0f eb ff ff       	call   f010fa84 <check_list_size>
f0110f75:	83 c4 10             	add    $0x10,%esp
f0110f78:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (is_correct)
f0110f7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110f7f:	74 04                	je     f0110f85 <test_free_block_FF+0x598>
	{
		eval += 10;
f0110f81:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 2: Merge with previous ONLY (AT the tail)*/
	cprintf("	4: Free some allocated blocks [Merge with previous ONLY]\n\n") ;
f0110f85:	83 ec 0c             	sub    $0xc,%esp
f0110f88:	68 30 b3 12 f0       	push   $0xf012b330
f0110f8d:	e8 da ff fe ff       	call   f0100f6c <cprintf>
f0110f92:	83 c4 10             	add    $0x10,%esp
	cprintf("		4.1: at the tail\n\n") ;
f0110f95:	83 ec 0c             	sub    $0xc,%esp
f0110f98:	68 6c b3 12 f0       	push   $0xf012b36c
f0110f9d:	e8 ca ff fe ff       	call   f0100f6c <cprintf>
f0110fa2:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110fa5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Free last block (coalesce with previous)
	uint32 blockIndex = numOfAllocs*allocCntPerSize;
f0110fac:	c7 45 b4 78 05 00 00 	movl   $0x578,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);
f0110fb3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0110fb6:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0110fbd:	83 ec 0c             	sub    $0xc,%esp
f0110fc0:	50                   	push   %eax
f0110fc1:	e8 b5 30 01 00       	call   f012407b <free_block>
f0110fc6:	83 c4 10             	add    $0x10,%esp
	expected_size = remainSize + allocSizes[numOfAllocs-1];
f0110fc9:	8b 15 d0 0d 18 f0    	mov    0xf0180dd0,%edx
f0110fcf:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110fd2:	01 d0                	add    %edx,%eax
f0110fd4:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f0110fd7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0110fda:	48                   	dec    %eax
f0110fdb:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0110fe2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0110fe5:	48                   	dec    %eax
f0110fe6:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0110fed:	6a 00                	push   $0x0
f0110fef:	ff 75 b0             	pushl  -0x50(%ebp)
f0110ff2:	52                   	push   %edx
f0110ff3:	50                   	push   %eax
f0110ff4:	e8 03 ea ff ff       	call   f010f9fc <check_block>
f0110ff9:	83 c4 10             	add    $0x10,%esp
f0110ffc:	85 c0                	test   %eax,%eax
f0110ffe:	75 07                	jne    f0111007 <test_free_block_FF+0x61a>
	{
		is_correct = 0;
f0111000:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	//====================================================================//
	/*free_block Scenario 3: Merge with previous ONLY (between 2 blocks)*/
	cprintf("		4.2: between 2 blocks\n\n") ;
f0111007:	83 ec 0c             	sub    $0xc,%esp
f011100a:	68 81 b3 12 f0       	push   $0xf012b381
f011100f:	e8 58 ff fe ff       	call   f0100f6c <cprintf>
f0111014:	83 c4 10             	add    $0x10,%esp
	blockIndex = 2*allocCntPerSize+1 ;
f0111017:	c7 45 b4 91 01 00 00 	movl   $0x191,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);
f011101e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111021:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111028:	83 ec 0c             	sub    $0xc,%esp
f011102b:	50                   	push   %eax
f011102c:	e8 4a 30 01 00       	call   f012407b <free_block>
f0111031:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[2]+allocSizes[2];
f0111034:	8b 15 c0 0d 18 f0    	mov    0xf0180dc0,%edx
f011103a:	a1 c0 0d 18 f0       	mov    0xf0180dc0,%eax
f011103f:	01 d0                	add    %edx,%eax
f0111041:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f0111044:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111047:	48                   	dec    %eax
f0111048:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f011104f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111052:	48                   	dec    %eax
f0111053:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f011105a:	6a 00                	push   $0x0
f011105c:	ff 75 b0             	pushl  -0x50(%ebp)
f011105f:	52                   	push   %edx
f0111060:	50                   	push   %eax
f0111061:	e8 96 e9 ff ff       	call   f010f9fc <check_block>
f0111066:	83 c4 10             	add    $0x10,%esp
f0111069:	85 c0                	test   %eax,%eax
f011106b:	75 07                	jne    f0111074 <test_free_block_FF+0x687>
	{
		is_correct = 0;
f011106d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	if (check_list_size(expectedNumOfFreeBlks) == 0)
f0111074:	83 ec 0c             	sub    $0xc,%esp
f0111077:	ff 75 b8             	pushl  -0x48(%ebp)
f011107a:	e8 05 ea ff ff       	call   f010fa84 <check_list_size>
f011107f:	83 c4 10             	add    $0x10,%esp
f0111082:	85 c0                	test   %eax,%eax
f0111084:	75 07                	jne    f011108d <test_free_block_FF+0x6a0>
	{
		is_correct = 0;
f0111086:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	if (is_correct)
f011108d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111091:	74 04                	je     f0111097 <test_free_block_FF+0x6aa>
	{
		eval += 15;
f0111093:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 4: Merge with next ONLY (AT the head)*/
	cprintf("	5: Free some allocated blocks [Merge with next ONLY]\n\n") ;
f0111097:	83 ec 0c             	sub    $0xc,%esp
f011109a:	68 9c b3 12 f0       	push   $0xf012b39c
f011109f:	e8 c8 fe fe ff       	call   f0100f6c <cprintf>
f01110a4:	83 c4 10             	add    $0x10,%esp
	cprintf("		5.1: at the head\n\n") ;
f01110a7:	83 ec 0c             	sub    $0xc,%esp
f01110aa:	68 d4 b3 12 f0       	push   $0xf012b3d4
f01110af:	e8 b8 fe fe ff       	call   f0100f6c <cprintf>
f01110b4:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01110b7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	blockIndex = 0 ;
f01110be:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);
f01110c5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01110c8:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f01110cf:	83 ec 0c             	sub    $0xc,%esp
f01110d2:	50                   	push   %eax
f01110d3:	e8 a3 2f 01 00       	call   f012407b <free_block>
f01110d8:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[0]+allocSizes[0];
f01110db:	8b 15 b8 0d 18 f0    	mov    0xf0180db8,%edx
f01110e1:	a1 b8 0d 18 f0       	mov    0xf0180db8,%eax
f01110e6:	01 d0                	add    %edx,%eax
f01110e8:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (check_block(startVAs[blockIndex], startVAs[blockIndex], expected_size, 0) == 0)
f01110eb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01110ee:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f01110f5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01110f8:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f01110ff:	6a 00                	push   $0x0
f0111101:	ff 75 b0             	pushl  -0x50(%ebp)
f0111104:	52                   	push   %edx
f0111105:	50                   	push   %eax
f0111106:	e8 f1 e8 ff ff       	call   f010f9fc <check_block>
f011110b:	83 c4 10             	add    $0x10,%esp
f011110e:	85 c0                	test   %eax,%eax
f0111110:	75 07                	jne    f0111119 <test_free_block_FF+0x72c>
	{
		is_correct = 0;
f0111112:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 5: Merge with next ONLY (between 2 blocks)*/
	cprintf("		5.2: between 2 blocks\n\n") ;
f0111119:	83 ec 0c             	sub    $0xc,%esp
f011111c:	68 e9 b3 12 f0       	push   $0xf012b3e9
f0111121:	e8 46 fe fe ff       	call   f0100f6c <cprintf>
f0111126:	83 c4 10             	add    $0x10,%esp
	blockIndex = 1*allocCntPerSize - 1 ;
f0111129:	c7 45 b4 c7 00 00 00 	movl   $0xc7,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);
f0111130:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111133:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f011113a:	83 ec 0c             	sub    $0xc,%esp
f011113d:	50                   	push   %eax
f011113e:	e8 38 2f 01 00       	call   f012407b <free_block>
f0111143:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[blockIndex]) ;
f0111146:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111149:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111150:	83 ec 0c             	sub    $0xc,%esp
f0111153:	50                   	push   %eax
f0111154:	e8 1e 1d 01 00       	call   f0122e77 <get_block_size>
f0111159:	83 c4 10             	add    $0x10,%esp
f011115c:	89 45 ac             	mov    %eax,-0x54(%ebp)
	expected_size = allocSizes[0]+allocSizes[1];
f011115f:	8b 15 b8 0d 18 f0    	mov    0xf0180db8,%edx
f0111165:	a1 bc 0d 18 f0       	mov    0xf0180dbc,%eax
f011116a:	01 d0                	add    %edx,%eax
f011116c:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (check_block(startVAs[blockIndex], startVAs[blockIndex], expected_size, 0) == 0)
f011116f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111172:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0111179:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011117c:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111183:	6a 00                	push   $0x0
f0111185:	ff 75 b0             	pushl  -0x50(%ebp)
f0111188:	52                   	push   %edx
f0111189:	50                   	push   %eax
f011118a:	e8 6d e8 ff ff       	call   f010f9fc <check_block>
f011118f:	83 c4 10             	add    $0x10,%esp
f0111192:	85 c0                	test   %eax,%eax
f0111194:	75 07                	jne    f011119d <test_free_block_FF+0x7b0>
	{
		is_correct = 0;
f0111196:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}

	if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f011119d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01111a1:	74 11                	je     f01111b4 <test_free_block_FF+0x7c7>
f01111a3:	83 ec 0c             	sub    $0xc,%esp
f01111a6:	ff 75 b8             	pushl  -0x48(%ebp)
f01111a9:	e8 d6 e8 ff ff       	call   f010fa84 <check_list_size>
f01111ae:	83 c4 10             	add    $0x10,%esp
f01111b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (is_correct)
f01111b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01111b8:	74 04                	je     f01111be <test_free_block_FF+0x7d1>
	{
		eval += 15;
f01111ba:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 6: Merge with prev & next */
	cprintf("	6: Free some allocated blocks [Merge with previous & next]\n\n") ;
f01111be:	83 ec 0c             	sub    $0xc,%esp
f01111c1:	68 04 b4 12 f0       	push   $0xf012b404
f01111c6:	e8 a1 fd fe ff       	call   f0100f6c <cprintf>
f01111cb:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01111ce:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	blockIndex = 4*allocCntPerSize - 2 ;
f01111d5:	c7 45 b4 1e 03 00 00 	movl   $0x31e,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);	//no merge
f01111dc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01111df:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f01111e6:	83 ec 0c             	sub    $0xc,%esp
f01111e9:	50                   	push   %eax
f01111ea:	e8 8c 2e 01 00       	call   f012407b <free_block>
f01111ef:	83 c4 10             	add    $0x10,%esp
	expectedNumOfFreeBlks++;
f01111f2:	ff 45 b8             	incl   -0x48(%ebp)

	blockIndex = 4*allocCntPerSize - 1 ;
f01111f5:	c7 45 b4 1f 03 00 00 	movl   $0x31f,-0x4c(%ebp)
	free_block(startVAs[blockIndex]);	//merge with prev & next
f01111fc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01111ff:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111206:	83 ec 0c             	sub    $0xc,%esp
f0111209:	50                   	push   %eax
f011120a:	e8 6c 2e 01 00       	call   f012407b <free_block>
f011120f:	83 c4 10             	add    $0x10,%esp
	expectedNumOfFreeBlks--;
f0111212:	ff 4d b8             	decl   -0x48(%ebp)

	block_size = get_block_size(startVAs[blockIndex-1]) ;
f0111215:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111218:	48                   	dec    %eax
f0111219:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111220:	83 ec 0c             	sub    $0xc,%esp
f0111223:	50                   	push   %eax
f0111224:	e8 4e 1c 01 00       	call   f0122e77 <get_block_size>
f0111229:	83 c4 10             	add    $0x10,%esp
f011122c:	89 45 ac             	mov    %eax,-0x54(%ebp)
	expected_size = allocSizes[3]+allocSizes[3]+allocSizes[4];
f011122f:	8b 15 c4 0d 18 f0    	mov    0xf0180dc4,%edx
f0111235:	a1 c4 0d 18 f0       	mov    0xf0180dc4,%eax
f011123a:	01 c2                	add    %eax,%edx
f011123c:	a1 c8 0d 18 f0       	mov    0xf0180dc8,%eax
f0111241:	01 d0                	add    %edx,%eax
f0111243:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f0111246:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111249:	48                   	dec    %eax
f011124a:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0111251:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111254:	48                   	dec    %eax
f0111255:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f011125c:	6a 00                	push   $0x0
f011125e:	ff 75 b0             	pushl  -0x50(%ebp)
f0111261:	52                   	push   %edx
f0111262:	50                   	push   %eax
f0111263:	e8 94 e7 ff ff       	call   f010f9fc <check_block>
f0111268:	83 c4 10             	add    $0x10,%esp
f011126b:	85 c0                	test   %eax,%eax
f011126d:	75 07                	jne    f0111276 <test_free_block_FF+0x889>
	{
		is_correct = 0;
f011126f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}

	if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f0111276:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011127a:	74 11                	je     f011128d <test_free_block_FF+0x8a0>
f011127c:	83 ec 0c             	sub    $0xc,%esp
f011127f:	ff 75 b8             	pushl  -0x48(%ebp)
f0111282:	e8 fd e7 ff ff       	call   f010fa84 <check_list_size>
f0111287:	83 c4 10             	add    $0x10,%esp
f011128a:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (is_correct)
f011128d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111291:	74 04                	je     f0111297 <test_free_block_FF+0x8aa>
	{
		eval += 20;
f0111293:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)
	}

	//====================================================================//
	/*Allocate After Free Scenarios */
	cprintf("	7: Allocate After Free [should be placed in coalesced blocks]\n\n") ;
f0111297:	83 ec 0c             	sub    $0xc,%esp
f011129a:	68 44 b4 12 f0       	push   $0xf012b444
f011129f:	e8 c8 fc fe ff       	call   f0100f6c <cprintf>
f01112a4:	83 c4 10             	add    $0x10,%esp

	cprintf("		7.1: in block coalesces with NEXT\n\n") ;
f01112a7:	83 ec 0c             	sub    $0xc,%esp
f01112aa:	68 88 b4 12 f0       	push   $0xf012b488
f01112af:	e8 b8 fc fe ff       	call   f0100f6c <cprintf>
f01112b4:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01112b7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 5*kilo - sizeOfMetaData;
f01112be:	c7 45 c4 f8 13 00 00 	movl   $0x13f8,-0x3c(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData, 2);
f01112c5:	c7 45 a8 02 00 00 00 	movl   $0x2,-0x58(%ebp)
f01112cc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01112cf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01112d2:	01 d0                	add    %edx,%eax
f01112d4:	83 c0 07             	add    $0x7,%eax
f01112d7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f01112da:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01112dd:	ba 00 00 00 00       	mov    $0x0,%edx
f01112e2:	f7 75 a8             	divl   -0x58(%ebp)
f01112e5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01112e8:	29 d0                	sub    %edx,%eax
f01112ea:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f01112ed:	83 ec 08             	sub    $0x8,%esp
f01112f0:	6a 01                	push   $0x1
f01112f2:	ff 75 c4             	pushl  -0x3c(%ebp)
f01112f5:	e8 b4 1b 01 00       	call   f0122eae <alloc_block>
f01112fa:	83 c4 10             	add    $0x10,%esp
f01112fd:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	void* expected = (void*)(KERNEL_HEAP_START + sizeof(int) + sizeOfMetaData/2);
f0111300:	c7 45 a0 08 00 00 f6 	movl   $0xf6000008,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f0111307:	6a 01                	push   $0x1
f0111309:	ff 75 b0             	pushl  -0x50(%ebp)
f011130c:	ff 75 a0             	pushl  -0x60(%ebp)
f011130f:	ff 75 c0             	pushl  -0x40(%ebp)
f0111312:	e8 e5 e6 ff ff       	call   f010f9fc <check_block>
f0111317:	83 c4 10             	add    $0x10,%esp
f011131a:	85 c0                	test   %eax,%eax
f011131c:	75 17                	jne    f0111335 <test_free_block_FF+0x948>
	{
		is_correct = 0;
f011131e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.1: Failed\n");
f0111325:	83 ec 0c             	sub    $0xc,%esp
f0111328:	68 ae b4 12 f0       	push   $0xf012b4ae
f011132d:	e8 3a fc fe ff       	call   f0100f6c <cprintf>
f0111332:	83 c4 10             	add    $0x10,%esp
	}
	actualSize = 3*kilo - sizeOfMetaData;
f0111335:	c7 45 c4 f8 0b 00 00 	movl   $0xbf8,-0x3c(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData, 2);
f011133c:	c7 45 9c 02 00 00 00 	movl   $0x2,-0x64(%ebp)
f0111343:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0111346:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0111349:	01 d0                	add    %edx,%eax
f011134b:	83 c0 07             	add    $0x7,%eax
f011134e:	89 45 98             	mov    %eax,-0x68(%ebp)
f0111351:	8b 45 98             	mov    -0x68(%ebp),%eax
f0111354:	ba 00 00 00 00       	mov    $0x0,%edx
f0111359:	f7 75 9c             	divl   -0x64(%ebp)
f011135c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011135f:	29 d0                	sub    %edx,%eax
f0111361:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0111364:	83 ec 08             	sub    $0x8,%esp
f0111367:	6a 01                	push   $0x1
f0111369:	ff 75 c4             	pushl  -0x3c(%ebp)
f011136c:	e8 3d 1b 01 00       	call   f0122eae <alloc_block>
f0111371:	83 c4 10             	add    $0x10,%esp
f0111374:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = (void*)(KERNEL_HEAP_START + sizeof(int) + 5*kilo + sizeOfMetaData/2);
f0111377:	c7 45 a0 08 14 00 f6 	movl   $0xf6001408,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f011137e:	6a 01                	push   $0x1
f0111380:	ff 75 b0             	pushl  -0x50(%ebp)
f0111383:	ff 75 a0             	pushl  -0x60(%ebp)
f0111386:	ff 75 c0             	pushl  -0x40(%ebp)
f0111389:	e8 6e e6 ff ff       	call   f010f9fc <check_block>
f011138e:	83 c4 10             	add    $0x10,%esp
f0111391:	85 c0                	test   %eax,%eax
f0111393:	75 17                	jne    f01113ac <test_free_block_FF+0x9bf>
	{
		is_correct = 0;
f0111395:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.2: Failed\n");
f011139c:	83 ec 0c             	sub    $0xc,%esp
f011139f:	68 cc b4 12 f0       	push   $0xf012b4cc
f01113a4:	e8 c3 fb fe ff       	call   f0100f6c <cprintf>
f01113a9:	83 c4 10             	add    $0x10,%esp
	}

	expectedNumOfFreeBlks--;
f01113ac:	ff 4d b8             	decl   -0x48(%ebp)

	/*INTERNAL FRAGMENTATION CASE*/
	actualSize = 4*kilo + 10 ;
f01113af:	c7 45 c4 0a 10 00 00 	movl   $0x100a,-0x3c(%ebp)
	expected_size = MAX(ROUNDUP(actualSize + sizeOfMetaData, 2), allocSizes[0]+allocSizes[1]) ;
f01113b6:	c7 45 94 02 00 00 00 	movl   $0x2,-0x6c(%ebp)
f01113bd:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01113c0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01113c3:	01 d0                	add    %edx,%eax
f01113c5:	83 c0 07             	add    $0x7,%eax
f01113c8:	89 45 90             	mov    %eax,-0x70(%ebp)
f01113cb:	8b 45 90             	mov    -0x70(%ebp),%eax
f01113ce:	ba 00 00 00 00       	mov    $0x0,%edx
f01113d3:	f7 75 94             	divl   -0x6c(%ebp)
f01113d6:	8b 45 90             	mov    -0x70(%ebp),%eax
f01113d9:	29 d0                	sub    %edx,%eax
f01113db:	89 45 8c             	mov    %eax,-0x74(%ebp)
f01113de:	8b 15 b8 0d 18 f0    	mov    0xf0180db8,%edx
f01113e4:	a1 bc 0d 18 f0       	mov    0xf0180dbc,%eax
f01113e9:	01 d0                	add    %edx,%eax
f01113eb:	89 45 88             	mov    %eax,-0x78(%ebp)
f01113ee:	8b 55 88             	mov    -0x78(%ebp),%edx
f01113f1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01113f4:	39 d0                	cmp    %edx,%eax
f01113f6:	73 02                	jae    f01113fa <test_free_block_FF+0xa0d>
f01113f8:	89 d0                	mov    %edx,%eax
f01113fa:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f01113fd:	83 ec 08             	sub    $0x8,%esp
f0111400:	6a 01                	push   $0x1
f0111402:	ff 75 c4             	pushl  -0x3c(%ebp)
f0111405:	e8 a4 1a 01 00       	call   f0122eae <alloc_block>
f011140a:	83 c4 10             	add    $0x10,%esp
f011140d:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[1*allocCntPerSize - 1];
f0111410:	a1 9c 33 5c f0       	mov    0xf05c339c,%eax
f0111415:	89 45 a0             	mov    %eax,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f0111418:	6a 01                	push   $0x1
f011141a:	ff 75 b0             	pushl  -0x50(%ebp)
f011141d:	ff 75 a0             	pushl  -0x60(%ebp)
f0111420:	ff 75 c0             	pushl  -0x40(%ebp)
f0111423:	e8 d4 e5 ff ff       	call   f010f9fc <check_block>
f0111428:	83 c4 10             	add    $0x10,%esp
f011142b:	85 c0                	test   %eax,%eax
f011142d:	75 17                	jne    f0111446 <test_free_block_FF+0xa59>
	{
		is_correct = 0;
f011142f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.3: Failed INTERNAL FRAGMENTATION CASE\n");
f0111436:	83 ec 0c             	sub    $0xc,%esp
f0111439:	68 ec b4 12 f0       	push   $0xf012b4ec
f011143e:	e8 29 fb fe ff       	call   f0100f6c <cprintf>
f0111443:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0111446:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011144a:	74 04                	je     f0111450 <test_free_block_FF+0xa63>
	{
		eval += 10;
f011144c:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	expectedNumOfFreeBlks--;
f0111450:	ff 4d b8             	decl   -0x48(%ebp)

	cprintf("		7.2: in block coalesces with PREV & NEXT\n\n") ;
f0111453:	83 ec 0c             	sub    $0xc,%esp
f0111456:	68 28 b5 12 f0       	push   $0xf012b528
f011145b:	e8 0c fb fe ff       	call   f0100f6c <cprintf>
f0111460:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0111463:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 2*kilo + 1;
f011146a:	c7 45 c4 01 08 00 00 	movl   $0x801,-0x3c(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData, 2);
f0111471:	c7 45 84 02 00 00 00 	movl   $0x2,-0x7c(%ebp)
f0111478:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011147b:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011147e:	01 d0                	add    %edx,%eax
f0111480:	83 c0 07             	add    $0x7,%eax
f0111483:	89 45 80             	mov    %eax,-0x80(%ebp)
f0111486:	8b 45 80             	mov    -0x80(%ebp),%eax
f0111489:	ba 00 00 00 00       	mov    $0x0,%edx
f011148e:	f7 75 84             	divl   -0x7c(%ebp)
f0111491:	8b 45 80             	mov    -0x80(%ebp),%eax
f0111494:	29 d0                	sub    %edx,%eax
f0111496:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0111499:	83 ec 08             	sub    $0x8,%esp
f011149c:	6a 01                	push   $0x1
f011149e:	ff 75 c4             	pushl  -0x3c(%ebp)
f01114a1:	e8 08 1a 01 00       	call   f0122eae <alloc_block>
f01114a6:	83 c4 10             	add    $0x10,%esp
f01114a9:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[4*allocCntPerSize - 2];
f01114ac:	a1 f8 3c 5c f0       	mov    0xf05c3cf8,%eax
f01114b1:	89 45 a0             	mov    %eax,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f01114b4:	6a 01                	push   $0x1
f01114b6:	ff 75 b0             	pushl  -0x50(%ebp)
f01114b9:	ff 75 a0             	pushl  -0x60(%ebp)
f01114bc:	ff 75 c0             	pushl  -0x40(%ebp)
f01114bf:	e8 38 e5 ff ff       	call   f010f9fc <check_block>
f01114c4:	83 c4 10             	add    $0x10,%esp
f01114c7:	85 c0                	test   %eax,%eax
f01114c9:	75 17                	jne    f01114e2 <test_free_block_FF+0xaf5>
	{
		is_correct = 0;
f01114cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.4: Failed\n");
f01114d2:	83 ec 0c             	sub    $0xc,%esp
f01114d5:	68 55 b5 12 f0       	push   $0xf012b555
f01114da:	e8 8d fa fe ff       	call   f0100f6c <cprintf>
f01114df:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f01114e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01114e6:	74 04                	je     f01114ec <test_free_block_FF+0xaff>
	{
		eval += 10;
f01114e8:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	cprintf("		7.3: in block coalesces with PREV\n\n") ;
f01114ec:	83 ec 0c             	sub    $0xc,%esp
f01114ef:	68 74 b5 12 f0       	push   $0xf012b574
f01114f4:	e8 73 fa fe ff       	call   f0100f6c <cprintf>
f01114f9:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01114fc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 2*kilo - sizeOfMetaData;
f0111503:	c7 45 c4 f8 07 00 00 	movl   $0x7f8,-0x3c(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData, 2);
f011150a:	c7 85 7c ff ff ff 02 	movl   $0x2,-0x84(%ebp)
f0111511:	00 00 00 
f0111514:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0111517:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011151d:	01 d0                	add    %edx,%eax
f011151f:	83 c0 07             	add    $0x7,%eax
f0111522:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0111528:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011152e:	ba 00 00 00 00       	mov    $0x0,%edx
f0111533:	f7 b5 7c ff ff ff    	divl   -0x84(%ebp)
f0111539:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011153f:	29 d0                	sub    %edx,%eax
f0111541:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0111544:	83 ec 08             	sub    $0x8,%esp
f0111547:	6a 01                	push   $0x1
f0111549:	ff 75 c4             	pushl  -0x3c(%ebp)
f011154c:	e8 5d 19 01 00       	call   f0122eae <alloc_block>
f0111551:	83 c4 10             	add    $0x10,%esp
f0111554:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[2*allocCntPerSize];
f0111557:	a1 c0 36 5c f0       	mov    0xf05c36c0,%eax
f011155c:	89 45 a0             	mov    %eax,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f011155f:	6a 01                	push   $0x1
f0111561:	ff 75 b0             	pushl  -0x50(%ebp)
f0111564:	ff 75 a0             	pushl  -0x60(%ebp)
f0111567:	ff 75 c0             	pushl  -0x40(%ebp)
f011156a:	e8 8d e4 ff ff       	call   f010f9fc <check_block>
f011156f:	83 c4 10             	add    $0x10,%esp
f0111572:	85 c0                	test   %eax,%eax
f0111574:	75 17                	jne    f011158d <test_free_block_FF+0xba0>
	{
		is_correct = 0;
f0111576:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.5: Failed\n");
f011157d:	83 ec 0c             	sub    $0xc,%esp
f0111580:	68 9a b5 12 f0       	push   $0xf012b59a
f0111585:	e8 e2 f9 fe ff       	call   f0100f6c <cprintf>
f011158a:	83 c4 10             	add    $0x10,%esp
	}

	expectedNumOfFreeBlks--;
f011158d:	ff 4d b8             	decl   -0x48(%ebp)

	actualSize = 8*kilo - sizeOfMetaData;
f0111590:	c7 45 c4 f8 1f 00 00 	movl   $0x1ff8,-0x3c(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData, 2);
f0111597:	c7 85 74 ff ff ff 02 	movl   $0x2,-0x8c(%ebp)
f011159e:	00 00 00 
f01115a1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01115a4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01115aa:	01 d0                	add    %edx,%eax
f01115ac:	83 c0 07             	add    $0x7,%eax
f01115af:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f01115b5:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01115bb:	ba 00 00 00 00       	mov    $0x0,%edx
f01115c0:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f01115c6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01115cc:	29 d0                	sub    %edx,%eax
f01115ce:	89 45 b0             	mov    %eax,-0x50(%ebp)
	va = alloc_block(actualSize, DA_FF);
f01115d1:	83 ec 08             	sub    $0x8,%esp
f01115d4:	6a 01                	push   $0x1
f01115d6:	ff 75 c4             	pushl  -0x3c(%ebp)
f01115d9:	e8 d0 18 01 00       	call   f0122eae <alloc_block>
f01115de:	83 c4 10             	add    $0x10,%esp
f01115e1:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[numOfAllocs*allocCntPerSize-1];
f01115e4:	a1 5c 46 5c f0       	mov    0xf05c465c,%eax
f01115e9:	89 45 a0             	mov    %eax,-0x60(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f01115ec:	6a 01                	push   $0x1
f01115ee:	ff 75 b0             	pushl  -0x50(%ebp)
f01115f1:	ff 75 a0             	pushl  -0x60(%ebp)
f01115f4:	ff 75 c0             	pushl  -0x40(%ebp)
f01115f7:	e8 00 e4 ff ff       	call   f010f9fc <check_block>
f01115fc:	83 c4 10             	add    $0x10,%esp
f01115ff:	85 c0                	test   %eax,%eax
f0111601:	75 17                	jne    f011161a <test_free_block_FF+0xc2d>
	{
		is_correct = 0;
f0111603:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.6: Failed\n");
f011160a:	83 ec 0c             	sub    $0xc,%esp
f011160d:	68 b8 b5 12 f0       	push   $0xf012b5b8
f0111612:	e8 55 f9 fe ff       	call   f0100f6c <cprintf>
f0111617:	83 c4 10             	add    $0x10,%esp
	}

	if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f011161a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011161e:	74 11                	je     f0111631 <test_free_block_FF+0xc44>
f0111620:	83 ec 0c             	sub    $0xc,%esp
f0111623:	ff 75 b8             	pushl  -0x48(%ebp)
f0111626:	e8 59 e4 ff ff       	call   f010fa84 <check_list_size>
f011162b:	83 c4 10             	add    $0x10,%esp
f011162e:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (is_correct)
f0111631:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111635:	74 04                	je     f011163b <test_free_block_FF+0xc4e>
	{
		eval += 10;
f0111637:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);
f011163b:	83 ec 08             	sub    $0x8,%esp
f011163e:	ff 75 f4             	pushl  -0xc(%ebp)
f0111641:	68 d8 b5 12 f0       	push   $0xf012b5d8
f0111646:	e8 21 f9 fe ff       	call   f0100f6c <cprintf>
f011164b:	83 c4 10             	add    $0x10,%esp

}
f011164e:	90                   	nop
f011164f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0111652:	c9                   	leave  
f0111653:	c3                   	ret    

f0111654 <test_free_block_BF>:

void test_free_block_BF()
{
f0111654:	55                   	push   %ebp
f0111655:	89 e5                	mov    %esp,%ebp
f0111657:	53                   	push   %ebx
f0111658:	81 ec 84 00 00 00    	sub    $0x84,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	cprintf("===========================================================\n") ;
f011165e:	83 ec 0c             	sub    $0xc,%esp
f0111661:	68 68 b0 12 f0       	push   $0xf012b068
f0111666:	e8 01 f9 fe ff       	call   f0100f6c <cprintf>
f011166b:	83 c4 10             	add    $0x10,%esp
	cprintf("NOTE: THIS TEST IS DEPEND ON BOTH ALLOCATE & FREE FUNCTIONS\n") ;
f011166e:	83 ec 0c             	sub    $0xc,%esp
f0111671:	68 a8 b0 12 f0       	push   $0xf012b0a8
f0111676:	e8 f1 f8 fe ff       	call   f0100f6c <cprintf>
f011167b:	83 c4 10             	add    $0x10,%esp
	cprintf("===========================================================\n") ;
f011167e:	83 ec 0c             	sub    $0xc,%esp
f0111681:	68 68 b0 12 f0       	push   $0xf012b068
f0111686:	e8 e1 f8 fe ff       	call   f0100f6c <cprintf>
f011168b:	83 c4 10             	add    $0x10,%esp

	int initAllocatedSpace = 3*Mega;
f011168e:	c7 45 d4 00 00 30 00 	movl   $0x300000,-0x2c(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f0111695:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111698:	83 ec 08             	sub    $0x8,%esp
f011169b:	50                   	push   %eax
f011169c:	68 00 00 00 f6       	push   $0xf6000000
f01116a1:	e8 35 19 01 00       	call   f0122fdb <initialize_dynamic_allocator>
f01116a6:	83 c4 10             	add    $0x10,%esp

	void * va ;
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;
f01116a9:	83 ec 0c             	sub    $0xc,%esp
f01116ac:	68 e8 b0 12 f0       	push   $0xf012b0e8
f01116b1:	e8 b6 f8 fe ff       	call   f0100f6c <cprintf>
f01116b6:	83 c4 10             	add    $0x10,%esp

	int totalSizes = 0;
f01116b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f01116c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01116c7:	eb 2a                	jmp    f01116f3 <test_free_block_BF+0x9f>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f01116c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01116cc:	8b 14 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%edx
f01116d3:	89 d0                	mov    %edx,%eax
f01116d5:	c1 e0 02             	shl    $0x2,%eax
f01116d8:	01 d0                	add    %edx,%eax
f01116da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01116e1:	01 d0                	add    %edx,%eax
f01116e3:	c1 e0 03             	shl    $0x3,%eax
f01116e6:	89 c2                	mov    %eax,%edx
f01116e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01116eb:	01 d0                	add    %edx,%eax
f01116ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;

	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f01116f0:	ff 45 f0             	incl   -0x10(%ebp)
f01116f3:	83 7d f0 06          	cmpl   $0x6,-0x10(%ebp)
f01116f7:	7e d0                	jle    f01116c9 <test_free_block_BF+0x75>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
	}
	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ; //exclude size of "DA Begin & End" blocks
f01116f9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01116fc:	2b 45 f4             	sub    -0xc(%ebp),%eax
f01116ff:	83 e8 08             	sub    $0x8,%eax
f0111702:	89 45 d0             	mov    %eax,-0x30(%ebp)
	if (remainSize <= 0)
f0111705:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0111709:	7f 17                	jg     f0111722 <test_free_block_BF+0xce>
		panic("test_free_block is not configured correctly. Consider updating the initial allocated space OR the required allocations");
f011170b:	83 ec 04             	sub    $0x4,%esp
f011170e:	68 40 b1 12 f0       	push   $0xf012b140
f0111713:	68 b1 03 00 00       	push   $0x3b1
f0111718:	68 34 a9 12 f0       	push   $0xf012a934
f011171d:	e8 f8 eb fe ff       	call   f010031a <_panic>

	int idx = 0;
f0111722:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
f0111729:	c7 45 e8 04 00 00 f6 	movl   $0xf6000004,-0x18(%ebp)

	uint32 actualSize, expected_size;
	void* expected_va;
	for (int i = 0; i < numOfAllocs; ++i)
f0111730:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0111737:	e9 0f 01 00 00       	jmp    f011184b <test_free_block_BF+0x1f7>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f011173c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0111743:	e9 f3 00 00 00       	jmp    f011183b <test_free_block_BF+0x1e7>
		{
			actualSize = allocSizes[i] - sizeOfMetaData;
f0111748:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011174b:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f0111752:	83 e8 08             	sub    $0x8,%eax
f0111755:	89 45 cc             	mov    %eax,-0x34(%ebp)
			va = startVAs[idx] = alloc_block(actualSize, DA_BF);
f0111758:	83 ec 08             	sub    $0x8,%esp
f011175b:	6a 03                	push   $0x3
f011175d:	ff 75 cc             	pushl  -0x34(%ebp)
f0111760:	e8 49 17 01 00       	call   f0122eae <alloc_block>
f0111765:	83 c4 10             	add    $0x10,%esp
f0111768:	89 c2                	mov    %eax,%edx
f011176a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011176d:	89 14 85 80 30 5c f0 	mov    %edx,-0xfa3cf80(,%eax,4)
f0111774:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111777:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f011177e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			midVAs[idx] = va + actualSize/2 ;
f0111781:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111784:	d1 e8                	shr    %eax
f0111786:	89 c2                	mov    %eax,%edx
f0111788:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011178b:	01 c2                	add    %eax,%edx
f011178d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111790:	89 14 85 80 5c 5c f0 	mov    %edx,-0xfa3a380(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f0111797:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011179a:	8d 50 fe             	lea    -0x2(%eax),%edx
f011179d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01117a0:	01 c2                	add    %eax,%edx
f01117a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01117a5:	89 14 85 80 46 5c f0 	mov    %edx,-0xfa3b980(,%eax,4)
			//Check returned va
			expected_va = curVA + sizeOfMetaData/2;
f01117ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01117af:	83 c0 04             	add    $0x4,%eax
f01117b2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if (check_block(va, expected_va, allocSizes[i], 1) == 0)
f01117b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01117b8:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f01117bf:	6a 01                	push   $0x1
f01117c1:	50                   	push   %eax
f01117c2:	ff 75 c4             	pushl  -0x3c(%ebp)
f01117c5:	ff 75 c8             	pushl  -0x38(%ebp)
f01117c8:	e8 2f e2 ff ff       	call   f010f9fc <check_block>
f01117cd:	83 c4 10             	add    $0x10,%esp
f01117d0:	85 c0                	test   %eax,%eax
f01117d2:	75 24                	jne    f01117f8 <test_free_block_BF+0x1a4>
				panic("test_free_block #1.%d: WRONG ALLOC - alloc_block_BF return wrong address. Expected %x, Actual %x", idx, curVA + sizeOfMetaData ,va);
f01117d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01117d7:	83 c0 08             	add    $0x8,%eax
f01117da:	83 ec 08             	sub    $0x8,%esp
f01117dd:	ff 75 c8             	pushl  -0x38(%ebp)
f01117e0:	50                   	push   %eax
f01117e1:	ff 75 ec             	pushl  -0x14(%ebp)
f01117e4:	68 14 b6 12 f0       	push   $0xf012b614
f01117e9:	68 c3 03 00 00       	push   $0x3c3
f01117ee:	68 34 a9 12 f0       	push   $0xf012a934
f01117f3:	e8 22 eb fe ff       	call   f010031a <_panic>
			curVA += allocSizes[i] ;
f01117f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01117fb:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f0111802:	01 45 e8             	add    %eax,-0x18(%ebp)
			*(startVAs[idx]) = idx ;
f0111805:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111808:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f011180f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111812:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f0111815:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111818:	8b 14 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%edx
f011181f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111822:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f0111825:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111828:	8b 14 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%edx
f011182f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111832:	66 89 02             	mov    %ax,(%edx)
			idx++;
f0111835:	ff 45 ec             	incl   -0x14(%ebp)

	uint32 actualSize, expected_size;
	void* expected_va;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f0111838:	ff 45 e0             	incl   -0x20(%ebp)
f011183b:	81 7d e0 c7 00 00 00 	cmpl   $0xc7,-0x20(%ebp)
f0111842:	0f 8e 00 ff ff ff    	jle    f0111748 <test_free_block_BF+0xf4>
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block

	uint32 actualSize, expected_size;
	void* expected_va;
	for (int i = 0; i < numOfAllocs; ++i)
f0111848:	ff 45 e4             	incl   -0x1c(%ebp)
f011184b:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
f011184f:	0f 8e e7 fe ff ff    	jle    f011173c <test_free_block_BF+0xe8>
		}
	}

	//====================================================================//
	/* Try to allocate a block with a size equal to the size of the first existing free block*/
	actualSize = remainSize - sizeOfMetaData;
f0111855:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111858:	83 e8 08             	sub    $0x8,%eax
f011185b:	89 45 cc             	mov    %eax,-0x34(%ebp)
	va = startVAs[idx] = alloc_block(actualSize, DA_BF);
f011185e:	83 ec 08             	sub    $0x8,%esp
f0111861:	6a 03                	push   $0x3
f0111863:	ff 75 cc             	pushl  -0x34(%ebp)
f0111866:	e8 43 16 01 00       	call   f0122eae <alloc_block>
f011186b:	83 c4 10             	add    $0x10,%esp
f011186e:	89 c2                	mov    %eax,%edx
f0111870:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111873:	89 14 85 80 30 5c f0 	mov    %edx,-0xfa3cf80(,%eax,4)
f011187a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011187d:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111884:	89 45 c8             	mov    %eax,-0x38(%ebp)
	midVAs[idx] = va + actualSize/2 ;
f0111887:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011188a:	d1 e8                	shr    %eax
f011188c:	89 c2                	mov    %eax,%edx
f011188e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111891:	01 c2                	add    %eax,%edx
f0111893:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111896:	89 14 85 80 5c 5c f0 	mov    %edx,-0xfa3a380(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f011189d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01118a0:	8d 50 fe             	lea    -0x2(%eax),%edx
f01118a3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01118a6:	01 c2                	add    %eax,%edx
f01118a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01118ab:	89 14 85 80 46 5c f0 	mov    %edx,-0xfa3b980(,%eax,4)
	//Check returned va
	expected_va = curVA + sizeOfMetaData/2;
f01118b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01118b5:	83 c0 04             	add    $0x4,%eax
f01118b8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if (check_block(va, expected_va, remainSize, 1) == 0)
f01118bb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01118be:	6a 01                	push   $0x1
f01118c0:	50                   	push   %eax
f01118c1:	ff 75 c4             	pushl  -0x3c(%ebp)
f01118c4:	ff 75 c8             	pushl  -0x38(%ebp)
f01118c7:	e8 30 e1 ff ff       	call   f010f9fc <check_block>
f01118cc:	83 c4 10             	add    $0x10,%esp
f01118cf:	85 c0                	test   %eax,%eax
f01118d1:	75 17                	jne    f01118ea <test_free_block_BF+0x296>
		panic("test_free_block #1: WRONG ALLOC - alloc_block_BF return wrong address.");
f01118d3:	83 ec 04             	sub    $0x4,%esp
f01118d6:	68 78 b6 12 f0       	push   $0xf012b678
f01118db:	68 d5 03 00 00       	push   $0x3d5
f01118e0:	68 34 a9 12 f0       	push   $0xf012a934
f01118e5:	e8 30 ea fe ff       	call   f010031a <_panic>
	*(startVAs[idx]) = idx ;
f01118ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01118ed:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f01118f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01118f7:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f01118fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01118fd:	8b 14 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%edx
f0111904:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111907:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f011190a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011190d:	8b 14 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%edx
f0111914:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111917:	66 89 02             	mov    %ax,(%edx)

	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;
f011191a:	83 ec 0c             	sub    $0xc,%esp
f011191d:	68 7c b2 12 f0       	push   $0xf012b27c
f0111922:	e8 45 f6 fe ff       	call   f0100f6c <cprintf>
f0111927:	83 c4 10             	add    $0x10,%esp

	for (int i = 0; i < idx; ++i)
f011192a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0111931:	eb 59                	jmp    f011198c <test_free_block_BF+0x338>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f0111933:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111936:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f011193d:	66 8b 00             	mov    (%eax),%ax
f0111940:	98                   	cwtl   
f0111941:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0111944:	75 26                	jne    f011196c <test_free_block_BF+0x318>
f0111946:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111949:	8b 04 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%eax
f0111950:	66 8b 00             	mov    (%eax),%ax
f0111953:	98                   	cwtl   
f0111954:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0111957:	75 13                	jne    f011196c <test_free_block_BF+0x318>
f0111959:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011195c:	8b 04 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%eax
f0111963:	66 8b 00             	mov    (%eax),%ax
f0111966:	98                   	cwtl   
f0111967:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011196a:	74 1d                	je     f0111989 <test_free_block_BF+0x335>
			panic("test_free_block #2.%d: WRONG! content of the block is not correct. Expected %d",i, i);
f011196c:	83 ec 0c             	sub    $0xc,%esp
f011196f:	ff 75 dc             	pushl  -0x24(%ebp)
f0111972:	ff 75 dc             	pushl  -0x24(%ebp)
f0111975:	68 c0 b6 12 f0       	push   $0xf012b6c0
f011197a:	68 e1 03 00 00       	push   $0x3e1
f011197f:	68 34 a9 12 f0       	push   $0xf012a934
f0111984:	e8 91 e9 fe ff       	call   f010031a <_panic>

	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;

	for (int i = 0; i < idx; ++i)
f0111989:	ff 45 dc             	incl   -0x24(%ebp)
f011198c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011198f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0111992:	7c 9f                	jl     f0111933 <test_free_block_BF+0x2df>
			panic("test_free_block #2.%d: WRONG! content of the block is not correct. Expected %d",i, i);
	}

	//====================================================================//
	/* free_block Scenario 1: Free some allocated blocks [no coalesce]*/
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;
f0111994:	83 ec 0c             	sub    $0xc,%esp
f0111997:	68 00 b3 12 f0       	push   $0xf012b300
f011199c:	e8 cb f5 fe ff       	call   f0100f6c <cprintf>
f01119a1:	83 c4 10             	add    $0x10,%esp

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f01119a4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01119ab:	e9 98 00 00 00       	jmp    f0111a48 <test_free_block_BF+0x3f4>
	{
		free_block(startVAs[i*allocCntPerSize]);
f01119b0:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01119b3:	89 d0                	mov    %edx,%eax
f01119b5:	c1 e0 02             	shl    $0x2,%eax
f01119b8:	01 d0                	add    %edx,%eax
f01119ba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01119c1:	01 d0                	add    %edx,%eax
f01119c3:	c1 e0 03             	shl    $0x3,%eax
f01119c6:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f01119cd:	83 ec 0c             	sub    $0xc,%esp
f01119d0:	50                   	push   %eax
f01119d1:	e8 a5 26 01 00       	call   f012407b <free_block>
f01119d6:	83 c4 10             	add    $0x10,%esp
		if (check_block(startVAs[i*allocCntPerSize], startVAs[i*allocCntPerSize], allocSizes[i], 0) == 0)
f01119d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01119dc:	8b 0c 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%ecx
f01119e3:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01119e6:	89 d0                	mov    %edx,%eax
f01119e8:	c1 e0 02             	shl    $0x2,%eax
f01119eb:	01 d0                	add    %edx,%eax
f01119ed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01119f4:	01 d0                	add    %edx,%eax
f01119f6:	c1 e0 03             	shl    $0x3,%eax
f01119f9:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0111a00:	8b 5d d8             	mov    -0x28(%ebp),%ebx
f0111a03:	89 d8                	mov    %ebx,%eax
f0111a05:	c1 e0 02             	shl    $0x2,%eax
f0111a08:	01 d8                	add    %ebx,%eax
f0111a0a:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0111a11:	01 d8                	add    %ebx,%eax
f0111a13:	c1 e0 03             	shl    $0x3,%eax
f0111a16:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111a1d:	6a 00                	push   $0x0
f0111a1f:	51                   	push   %ecx
f0111a20:	52                   	push   %edx
f0111a21:	50                   	push   %eax
f0111a22:	e8 d5 df ff ff       	call   f010f9fc <check_block>
f0111a27:	83 c4 10             	add    $0x10,%esp
f0111a2a:	85 c0                	test   %eax,%eax
f0111a2c:	75 17                	jne    f0111a45 <test_free_block_BF+0x3f1>
		{
			panic("3.1 Failed");
f0111a2e:	83 ec 04             	sub    $0x4,%esp
f0111a31:	68 0f b7 12 f0       	push   $0xf012b70f
f0111a36:	68 ee 03 00 00       	push   $0x3ee
f0111a3b:	68 34 a9 12 f0       	push   $0xf012a934
f0111a40:	e8 d5 e8 fe ff       	call   f010031a <_panic>
	//====================================================================//
	/* free_block Scenario 1: Free some allocated blocks [no coalesce]*/
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0111a45:	ff 45 d8             	incl   -0x28(%ebp)
f0111a48:	83 7d d8 06          	cmpl   $0x6,-0x28(%ebp)
f0111a4c:	0f 8e 5e ff ff ff    	jle    f01119b0 <test_free_block_BF+0x35c>
		if (check_block(startVAs[i*allocCntPerSize], startVAs[i*allocCntPerSize], allocSizes[i], 0) == 0)
		{
			panic("3.1 Failed");
		}
	}
	uint32 expectedNumOfFreeBlks = numOfAllocs;
f0111a52:	c7 45 c0 07 00 00 00 	movl   $0x7,-0x40(%ebp)
	if (check_list_size(expectedNumOfFreeBlks) == 0)
f0111a59:	83 ec 0c             	sub    $0xc,%esp
f0111a5c:	ff 75 c0             	pushl  -0x40(%ebp)
f0111a5f:	e8 20 e0 ff ff       	call   f010fa84 <check_list_size>
f0111a64:	83 c4 10             	add    $0x10,%esp
f0111a67:	85 c0                	test   %eax,%eax
f0111a69:	75 17                	jne    f0111a82 <test_free_block_BF+0x42e>
	{
		panic("3.2 Failed");
f0111a6b:	83 ec 04             	sub    $0x4,%esp
f0111a6e:	68 1a b7 12 f0       	push   $0xf012b71a
f0111a73:	68 f4 03 00 00       	push   $0x3f4
f0111a78:	68 34 a9 12 f0       	push   $0xf012a934
f0111a7d:	e8 98 e8 fe ff       	call   f010031a <_panic>
	}

	//Free last block
	free_block(startVAs[numOfAllocs*allocCntPerSize]);
f0111a82:	a1 60 46 5c f0       	mov    0xf05c4660,%eax
f0111a87:	83 ec 0c             	sub    $0xc,%esp
f0111a8a:	50                   	push   %eax
f0111a8b:	e8 eb 25 01 00       	call   f012407b <free_block>
f0111a90:	83 c4 10             	add    $0x10,%esp
	if (check_block(startVAs[numOfAllocs*allocCntPerSize], startVAs[numOfAllocs*allocCntPerSize], remainSize, 0) == 0)
f0111a93:	8b 4d d0             	mov    -0x30(%ebp),%ecx
f0111a96:	8b 15 60 46 5c f0    	mov    0xf05c4660,%edx
f0111a9c:	a1 60 46 5c f0       	mov    0xf05c4660,%eax
f0111aa1:	6a 00                	push   $0x0
f0111aa3:	51                   	push   %ecx
f0111aa4:	52                   	push   %edx
f0111aa5:	50                   	push   %eax
f0111aa6:	e8 51 df ff ff       	call   f010f9fc <check_block>
f0111aab:	83 c4 10             	add    $0x10,%esp
f0111aae:	85 c0                	test   %eax,%eax
f0111ab0:	75 17                	jne    f0111ac9 <test_free_block_BF+0x475>
		panic("3.3 Failed");
f0111ab2:	83 ec 04             	sub    $0x4,%esp
f0111ab5:	68 25 b7 12 f0       	push   $0xf012b725
f0111aba:	68 fa 03 00 00       	push   $0x3fa
f0111abf:	68 34 a9 12 f0       	push   $0xf012a934
f0111ac4:	e8 51 e8 fe ff       	call   f010031a <_panic>

	//Reallocate last block
	actualSize = remainSize - sizeOfMetaData;
f0111ac9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111acc:	83 e8 08             	sub    $0x8,%eax
f0111acf:	89 45 cc             	mov    %eax,-0x34(%ebp)
	va = alloc_block(actualSize, DA_BF);
f0111ad2:	83 ec 08             	sub    $0x8,%esp
f0111ad5:	6a 03                	push   $0x3
f0111ad7:	ff 75 cc             	pushl  -0x34(%ebp)
f0111ada:	e8 cf 13 01 00       	call   f0122eae <alloc_block>
f0111adf:	83 c4 10             	add    $0x10,%esp
f0111ae2:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected_va = (curVA + sizeOfMetaData/2);
f0111ae5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111ae8:	83 c0 04             	add    $0x4,%eax
f0111aeb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(check_block(va, expected_va, remainSize, 1) == 0)
f0111aee:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111af1:	6a 01                	push   $0x1
f0111af3:	50                   	push   %eax
f0111af4:	ff 75 c4             	pushl  -0x3c(%ebp)
f0111af7:	ff 75 c8             	pushl  -0x38(%ebp)
f0111afa:	e8 fd de ff ff       	call   f010f9fc <check_block>
f0111aff:	83 c4 10             	add    $0x10,%esp
f0111b02:	85 c0                	test   %eax,%eax
f0111b04:	75 17                	jne    f0111b1d <test_free_block_BF+0x4c9>
		panic("3.4 Failed");
f0111b06:	83 ec 04             	sub    $0x4,%esp
f0111b09:	68 30 b7 12 f0       	push   $0xf012b730
f0111b0e:	68 02 04 00 00       	push   $0x402
f0111b13:	68 34 a9 12 f0       	push   $0xf012a934
f0111b18:	e8 fd e7 fe ff       	call   f010031a <_panic>

	//Free block before last
	free_block(startVAs[numOfAllocs*allocCntPerSize - 1]);
f0111b1d:	a1 5c 46 5c f0       	mov    0xf05c465c,%eax
f0111b22:	83 ec 0c             	sub    $0xc,%esp
f0111b25:	50                   	push   %eax
f0111b26:	e8 50 25 01 00       	call   f012407b <free_block>
f0111b2b:	83 c4 10             	add    $0x10,%esp
	if (check_block(startVAs[numOfAllocs*allocCntPerSize-1], startVAs[numOfAllocs*allocCntPerSize-1], allocSizes[numOfAllocs-1], 0) == 0)
f0111b2e:	8b 0d d0 0d 18 f0    	mov    0xf0180dd0,%ecx
f0111b34:	8b 15 5c 46 5c f0    	mov    0xf05c465c,%edx
f0111b3a:	a1 5c 46 5c f0       	mov    0xf05c465c,%eax
f0111b3f:	6a 00                	push   $0x0
f0111b41:	51                   	push   %ecx
f0111b42:	52                   	push   %edx
f0111b43:	50                   	push   %eax
f0111b44:	e8 b3 de ff ff       	call   f010f9fc <check_block>
f0111b49:	83 c4 10             	add    $0x10,%esp
f0111b4c:	85 c0                	test   %eax,%eax
f0111b4e:	75 17                	jne    f0111b67 <test_free_block_BF+0x513>
		panic("3.5 Failed");
f0111b50:	83 ec 04             	sub    $0x4,%esp
f0111b53:	68 3b b7 12 f0       	push   $0xf012b73b
f0111b58:	68 07 04 00 00       	push   $0x407
f0111b5d:	68 34 a9 12 f0       	push   $0xf012a934
f0111b62:	e8 b3 e7 fe ff       	call   f010031a <_panic>

	//Reallocate first block
	actualSize = allocSizes[0] - sizeOfMetaData;
f0111b67:	a1 b8 0d 18 f0       	mov    0xf0180db8,%eax
f0111b6c:	83 e8 08             	sub    $0x8,%eax
f0111b6f:	89 45 cc             	mov    %eax,-0x34(%ebp)
	va = alloc_block(actualSize, DA_BF);
f0111b72:	83 ec 08             	sub    $0x8,%esp
f0111b75:	6a 03                	push   $0x3
f0111b77:	ff 75 cc             	pushl  -0x34(%ebp)
f0111b7a:	e8 2f 13 01 00       	call   f0122eae <alloc_block>
f0111b7f:	83 c4 10             	add    $0x10,%esp
f0111b82:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected_va = (void*)(KERNEL_HEAP_START + 2*sizeof(int));
f0111b85:	c7 45 c4 08 00 00 f6 	movl   $0xf6000008,-0x3c(%ebp)
	if(check_block(va, expected_va, allocSizes[0], 1) == 0)
f0111b8c:	a1 b8 0d 18 f0       	mov    0xf0180db8,%eax
f0111b91:	6a 01                	push   $0x1
f0111b93:	50                   	push   %eax
f0111b94:	ff 75 c4             	pushl  -0x3c(%ebp)
f0111b97:	ff 75 c8             	pushl  -0x38(%ebp)
f0111b9a:	e8 5d de ff ff       	call   f010f9fc <check_block>
f0111b9f:	83 c4 10             	add    $0x10,%esp
f0111ba2:	85 c0                	test   %eax,%eax
f0111ba4:	75 17                	jne    f0111bbd <test_free_block_BF+0x569>
		panic("3.6 Failed");
f0111ba6:	83 ec 04             	sub    $0x4,%esp
f0111ba9:	68 46 b7 12 f0       	push   $0xf012b746
f0111bae:	68 0f 04 00 00       	push   $0x40f
f0111bb3:	68 34 a9 12 f0       	push   $0xf012a934
f0111bb8:	e8 5d e7 fe ff       	call   f010031a <_panic>

	//Free 2nd block
	free_block(startVAs[1]);
f0111bbd:	a1 84 30 5c f0       	mov    0xf05c3084,%eax
f0111bc2:	83 ec 0c             	sub    $0xc,%esp
f0111bc5:	50                   	push   %eax
f0111bc6:	e8 b0 24 01 00       	call   f012407b <free_block>
f0111bcb:	83 c4 10             	add    $0x10,%esp
	if (check_block(startVAs[1], startVAs[1], allocSizes[0], 0) == 0)
f0111bce:	8b 0d b8 0d 18 f0    	mov    0xf0180db8,%ecx
f0111bd4:	8b 15 84 30 5c f0    	mov    0xf05c3084,%edx
f0111bda:	a1 84 30 5c f0       	mov    0xf05c3084,%eax
f0111bdf:	6a 00                	push   $0x0
f0111be1:	51                   	push   %ecx
f0111be2:	52                   	push   %edx
f0111be3:	50                   	push   %eax
f0111be4:	e8 13 de ff ff       	call   f010f9fc <check_block>
f0111be9:	83 c4 10             	add    $0x10,%esp
f0111bec:	85 c0                	test   %eax,%eax
f0111bee:	75 17                	jne    f0111c07 <test_free_block_BF+0x5b3>
		panic("3.7 Failed");
f0111bf0:	83 ec 04             	sub    $0x4,%esp
f0111bf3:	68 51 b7 12 f0       	push   $0xf012b751
f0111bf8:	68 14 04 00 00       	push   $0x414
f0111bfd:	68 34 a9 12 f0       	push   $0xf012a934
f0111c02:	e8 13 e7 fe ff       	call   f010031a <_panic>

	expectedNumOfFreeBlks++ ;
f0111c07:	ff 45 c0             	incl   -0x40(%ebp)
	if (check_list_size(expectedNumOfFreeBlks) == 0)
f0111c0a:	83 ec 0c             	sub    $0xc,%esp
f0111c0d:	ff 75 c0             	pushl  -0x40(%ebp)
f0111c10:	e8 6f de ff ff       	call   f010fa84 <check_list_size>
f0111c15:	83 c4 10             	add    $0x10,%esp
f0111c18:	85 c0                	test   %eax,%eax
f0111c1a:	75 17                	jne    f0111c33 <test_free_block_BF+0x5df>
	{
		panic("3.8 Failed");
f0111c1c:	83 ec 04             	sub    $0x4,%esp
f0111c1f:	68 5c b7 12 f0       	push   $0xf012b75c
f0111c24:	68 19 04 00 00       	push   $0x419
f0111c29:	68 34 a9 12 f0       	push   $0xf012a934
f0111c2e:	e8 e7 e6 fe ff       	call   f010031a <_panic>
	}

	uint32 block_size, block_status;
	//====================================================================//
	/*free_block Scenario 2: Merge with previous ONLY (AT the tail)*/
	cprintf("	4: Free some allocated blocks [Merge with previous ONLY]\n\n") ;
f0111c33:	83 ec 0c             	sub    $0xc,%esp
f0111c36:	68 30 b3 12 f0       	push   $0xf012b330
f0111c3b:	e8 2c f3 fe ff       	call   f0100f6c <cprintf>
f0111c40:	83 c4 10             	add    $0x10,%esp
	cprintf("		4.1: at the tail\n\n") ;
f0111c43:	83 ec 0c             	sub    $0xc,%esp
f0111c46:	68 6c b3 12 f0       	push   $0xf012b36c
f0111c4b:	e8 1c f3 fe ff       	call   f0100f6c <cprintf>
f0111c50:	83 c4 10             	add    $0x10,%esp
	//Free last block (coalesce with previous)
	uint32 blockIndex = numOfAllocs*allocCntPerSize;
f0111c53:	c7 45 bc 78 05 00 00 	movl   $0x578,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f0111c5a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111c5d:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111c64:	83 ec 0c             	sub    $0xc,%esp
f0111c67:	50                   	push   %eax
f0111c68:	e8 0e 24 01 00       	call   f012407b <free_block>
f0111c6d:	83 c4 10             	add    $0x10,%esp
	expected_size = remainSize + allocSizes[numOfAllocs-1];
f0111c70:	8b 15 d0 0d 18 f0    	mov    0xf0180dd0,%edx
f0111c76:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111c79:	01 d0                	add    %edx,%eax
f0111c7b:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f0111c7e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111c81:	48                   	dec    %eax
f0111c82:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0111c89:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111c8c:	48                   	dec    %eax
f0111c8d:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111c94:	6a 00                	push   $0x0
f0111c96:	ff 75 b8             	pushl  -0x48(%ebp)
f0111c99:	52                   	push   %edx
f0111c9a:	50                   	push   %eax
f0111c9b:	e8 5c dd ff ff       	call   f010f9fc <check_block>
f0111ca0:	83 c4 10             	add    $0x10,%esp
f0111ca3:	85 c0                	test   %eax,%eax
f0111ca5:	75 17                	jne    f0111cbe <test_free_block_BF+0x66a>
	{
		panic("4.1 Failed");
f0111ca7:	83 ec 04             	sub    $0x4,%esp
f0111caa:	68 67 b7 12 f0       	push   $0xf012b767
f0111caf:	68 27 04 00 00       	push   $0x427
f0111cb4:	68 34 a9 12 f0       	push   $0xf012a934
f0111cb9:	e8 5c e6 fe ff       	call   f010031a <_panic>
	}
	//====================================================================//
	/*free_block Scenario 3: Merge with previous ONLY (between 2 blocks)*/
	cprintf("		4.2: between 2 blocks\n\n") ;
f0111cbe:	83 ec 0c             	sub    $0xc,%esp
f0111cc1:	68 81 b3 12 f0       	push   $0xf012b381
f0111cc6:	e8 a1 f2 fe ff       	call   f0100f6c <cprintf>
f0111ccb:	83 c4 10             	add    $0x10,%esp
	blockIndex = 2*allocCntPerSize+1 ;
f0111cce:	c7 45 bc 91 01 00 00 	movl   $0x191,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f0111cd5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111cd8:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111cdf:	83 ec 0c             	sub    $0xc,%esp
f0111ce2:	50                   	push   %eax
f0111ce3:	e8 93 23 01 00       	call   f012407b <free_block>
f0111ce8:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[2]+allocSizes[2];
f0111ceb:	8b 15 c0 0d 18 f0    	mov    0xf0180dc0,%edx
f0111cf1:	a1 c0 0d 18 f0       	mov    0xf0180dc0,%eax
f0111cf6:	01 d0                	add    %edx,%eax
f0111cf8:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f0111cfb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111cfe:	48                   	dec    %eax
f0111cff:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0111d06:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111d09:	48                   	dec    %eax
f0111d0a:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111d11:	6a 00                	push   $0x0
f0111d13:	ff 75 b8             	pushl  -0x48(%ebp)
f0111d16:	52                   	push   %edx
f0111d17:	50                   	push   %eax
f0111d18:	e8 df dc ff ff       	call   f010f9fc <check_block>
f0111d1d:	83 c4 10             	add    $0x10,%esp
f0111d20:	85 c0                	test   %eax,%eax
f0111d22:	75 17                	jne    f0111d3b <test_free_block_BF+0x6e7>
	{
		panic("4.2 Failed");
f0111d24:	83 ec 04             	sub    $0x4,%esp
f0111d27:	68 72 b7 12 f0       	push   $0xf012b772
f0111d2c:	68 31 04 00 00       	push   $0x431
f0111d31:	68 34 a9 12 f0       	push   $0xf012a934
f0111d36:	e8 df e5 fe ff       	call   f010031a <_panic>
	}
	//====================================================================//
	/*free_block Scenario 4: Merge with next ONLY (AT the head)*/
	cprintf("	5: Free some allocated blocks [Merge with next ONLY]\n\n") ;
f0111d3b:	83 ec 0c             	sub    $0xc,%esp
f0111d3e:	68 9c b3 12 f0       	push   $0xf012b39c
f0111d43:	e8 24 f2 fe ff       	call   f0100f6c <cprintf>
f0111d48:	83 c4 10             	add    $0x10,%esp
	cprintf("		5.1: at the head\n\n") ;
f0111d4b:	83 ec 0c             	sub    $0xc,%esp
f0111d4e:	68 d4 b3 12 f0       	push   $0xf012b3d4
f0111d53:	e8 14 f2 fe ff       	call   f0100f6c <cprintf>
f0111d58:	83 c4 10             	add    $0x10,%esp
	blockIndex = 0 ;
f0111d5b:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f0111d62:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111d65:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111d6c:	83 ec 0c             	sub    $0xc,%esp
f0111d6f:	50                   	push   %eax
f0111d70:	e8 06 23 01 00       	call   f012407b <free_block>
f0111d75:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[0]+allocSizes[0];
f0111d78:	8b 15 b8 0d 18 f0    	mov    0xf0180db8,%edx
f0111d7e:	a1 b8 0d 18 f0       	mov    0xf0180db8,%eax
f0111d83:	01 d0                	add    %edx,%eax
f0111d85:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if (check_block(startVAs[blockIndex], startVAs[blockIndex], expected_size, 0) == 0)
f0111d88:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111d8b:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0111d92:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111d95:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111d9c:	6a 00                	push   $0x0
f0111d9e:	ff 75 b8             	pushl  -0x48(%ebp)
f0111da1:	52                   	push   %edx
f0111da2:	50                   	push   %eax
f0111da3:	e8 54 dc ff ff       	call   f010f9fc <check_block>
f0111da8:	83 c4 10             	add    $0x10,%esp
f0111dab:	85 c0                	test   %eax,%eax
f0111dad:	75 17                	jne    f0111dc6 <test_free_block_BF+0x772>
	{
		panic("5.1 Failed");
f0111daf:	83 ec 04             	sub    $0x4,%esp
f0111db2:	68 7d b7 12 f0       	push   $0xf012b77d
f0111db7:	68 3c 04 00 00       	push   $0x43c
f0111dbc:	68 34 a9 12 f0       	push   $0xf012a934
f0111dc1:	e8 54 e5 fe ff       	call   f010031a <_panic>
	}
	//====================================================================//
	/*free_block Scenario 5: Merge with next ONLY (between 2 blocks)*/
	cprintf("		5.2: between 2 blocks\n\n") ;
f0111dc6:	83 ec 0c             	sub    $0xc,%esp
f0111dc9:	68 e9 b3 12 f0       	push   $0xf012b3e9
f0111dce:	e8 99 f1 fe ff       	call   f0100f6c <cprintf>
f0111dd3:	83 c4 10             	add    $0x10,%esp
	blockIndex = 1*allocCntPerSize - 1 ;
f0111dd6:	c7 45 bc c7 00 00 00 	movl   $0xc7,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f0111ddd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111de0:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111de7:	83 ec 0c             	sub    $0xc,%esp
f0111dea:	50                   	push   %eax
f0111deb:	e8 8b 22 01 00       	call   f012407b <free_block>
f0111df0:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[0]+allocSizes[1];
f0111df3:	8b 15 b8 0d 18 f0    	mov    0xf0180db8,%edx
f0111df9:	a1 bc 0d 18 f0       	mov    0xf0180dbc,%eax
f0111dfe:	01 d0                	add    %edx,%eax
f0111e00:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if (check_block(startVAs[blockIndex], startVAs[blockIndex], expected_size, 0) == 0)
f0111e03:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111e06:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0111e0d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111e10:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111e17:	6a 00                	push   $0x0
f0111e19:	ff 75 b8             	pushl  -0x48(%ebp)
f0111e1c:	52                   	push   %edx
f0111e1d:	50                   	push   %eax
f0111e1e:	e8 d9 db ff ff       	call   f010f9fc <check_block>
f0111e23:	83 c4 10             	add    $0x10,%esp
f0111e26:	85 c0                	test   %eax,%eax
f0111e28:	75 17                	jne    f0111e41 <test_free_block_BF+0x7ed>
	{
		panic("5.2 Failed");
f0111e2a:	83 ec 04             	sub    $0x4,%esp
f0111e2d:	68 88 b7 12 f0       	push   $0xf012b788
f0111e32:	68 46 04 00 00       	push   $0x446
f0111e37:	68 34 a9 12 f0       	push   $0xf012a934
f0111e3c:	e8 d9 e4 fe ff       	call   f010031a <_panic>
	}
	//====================================================================//
	/*free_block Scenario 6: Merge with prev & next */
	cprintf("	6: Free some allocated blocks [Merge with previous & next]\n\n") ;
f0111e41:	83 ec 0c             	sub    $0xc,%esp
f0111e44:	68 04 b4 12 f0       	push   $0xf012b404
f0111e49:	e8 1e f1 fe ff       	call   f0100f6c <cprintf>
f0111e4e:	83 c4 10             	add    $0x10,%esp
	blockIndex = 4*allocCntPerSize - 2 ;
f0111e51:	c7 45 bc 1e 03 00 00 	movl   $0x31e,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f0111e58:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111e5b:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111e62:	83 ec 0c             	sub    $0xc,%esp
f0111e65:	50                   	push   %eax
f0111e66:	e8 10 22 01 00       	call   f012407b <free_block>
f0111e6b:	83 c4 10             	add    $0x10,%esp

	blockIndex = 4*allocCntPerSize - 1 ;
f0111e6e:	c7 45 bc 1f 03 00 00 	movl   $0x31f,-0x44(%ebp)
	free_block(startVAs[blockIndex]);
f0111e75:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111e78:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111e7f:	83 ec 0c             	sub    $0xc,%esp
f0111e82:	50                   	push   %eax
f0111e83:	e8 f3 21 01 00       	call   f012407b <free_block>
f0111e88:	83 c4 10             	add    $0x10,%esp
	expected_size = allocSizes[3]+allocSizes[3]+allocSizes[4];
f0111e8b:	8b 15 c4 0d 18 f0    	mov    0xf0180dc4,%edx
f0111e91:	a1 c4 0d 18 f0       	mov    0xf0180dc4,%eax
f0111e96:	01 c2                	add    %eax,%edx
f0111e98:	a1 c8 0d 18 f0       	mov    0xf0180dc8,%eax
f0111e9d:	01 d0                	add    %edx,%eax
f0111e9f:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if (check_block(startVAs[blockIndex-1], startVAs[blockIndex-1], expected_size, 0) == 0)
f0111ea2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111ea5:	48                   	dec    %eax
f0111ea6:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0111ead:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111eb0:	48                   	dec    %eax
f0111eb1:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0111eb8:	6a 00                	push   $0x0
f0111eba:	ff 75 b8             	pushl  -0x48(%ebp)
f0111ebd:	52                   	push   %edx
f0111ebe:	50                   	push   %eax
f0111ebf:	e8 38 db ff ff       	call   f010f9fc <check_block>
f0111ec4:	83 c4 10             	add    $0x10,%esp
f0111ec7:	85 c0                	test   %eax,%eax
f0111ec9:	75 17                	jne    f0111ee2 <test_free_block_BF+0x88e>
	{
		panic("6.1 Failed");
f0111ecb:	83 ec 04             	sub    $0x4,%esp
f0111ece:	68 93 b7 12 f0       	push   $0xf012b793
f0111ed3:	68 53 04 00 00       	push   $0x453
f0111ed8:	68 34 a9 12 f0       	push   $0xf012a934
f0111edd:	e8 38 e4 fe ff       	call   f010031a <_panic>
	}
	if (check_list_size(expectedNumOfFreeBlks) == 0)
f0111ee2:	83 ec 0c             	sub    $0xc,%esp
f0111ee5:	ff 75 c0             	pushl  -0x40(%ebp)
f0111ee8:	e8 97 db ff ff       	call   f010fa84 <check_list_size>
f0111eed:	83 c4 10             	add    $0x10,%esp
f0111ef0:	85 c0                	test   %eax,%eax
f0111ef2:	75 17                	jne    f0111f0b <test_free_block_BF+0x8b7>
	{
		panic("6.2 Failed");
f0111ef4:	83 ec 04             	sub    $0x4,%esp
f0111ef7:	68 9e b7 12 f0       	push   $0xf012b79e
f0111efc:	68 57 04 00 00       	push   $0x457
f0111f01:	68 34 a9 12 f0       	push   $0xf012a934
f0111f06:	e8 0f e4 fe ff       	call   f010031a <_panic>
	}
	//====================================================================//
	/*Allocate After Free Scenarios */
	void* expected = NULL;
f0111f0b:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	{
		//Consume 1st 7KB Block
		actualSize = 7*kilo - sizeOfMetaData ;
f0111f12:	c7 45 cc f8 1b 00 00 	movl   $0x1bf8,-0x34(%ebp)
		expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f0111f19:	c7 45 b0 02 00 00 00 	movl   $0x2,-0x50(%ebp)
f0111f20:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111f23:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111f26:	01 d0                	add    %edx,%eax
f0111f28:	83 c0 07             	add    $0x7,%eax
f0111f2b:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0111f2e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111f31:	ba 00 00 00 00       	mov    $0x0,%edx
f0111f36:	f7 75 b0             	divl   -0x50(%ebp)
f0111f39:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111f3c:	29 d0                	sub    %edx,%eax
f0111f3e:	89 45 b8             	mov    %eax,-0x48(%ebp)
		va = alloc_block(actualSize, DA_BF);
f0111f41:	83 ec 08             	sub    $0x8,%esp
f0111f44:	6a 03                	push   $0x3
f0111f46:	ff 75 cc             	pushl  -0x34(%ebp)
f0111f49:	e8 60 0f 01 00       	call   f0122eae <alloc_block>
f0111f4e:	83 c4 10             	add    $0x10,%esp
f0111f51:	89 45 c8             	mov    %eax,-0x38(%ebp)
		//Check returned va
		expected = (void*)(startVAs[6*allocCntPerSize]);
f0111f54:	a1 40 43 5c f0       	mov    0xf05c4340,%eax
f0111f59:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if (check_block(va, expected, expected_size, 1) == 0)
f0111f5c:	6a 01                	push   $0x1
f0111f5e:	ff 75 b8             	pushl  -0x48(%ebp)
f0111f61:	ff 75 b4             	pushl  -0x4c(%ebp)
f0111f64:	ff 75 c8             	pushl  -0x38(%ebp)
f0111f67:	e8 90 da ff ff       	call   f010f9fc <check_block>
f0111f6c:	83 c4 10             	add    $0x10,%esp
f0111f6f:	85 c0                	test   %eax,%eax
f0111f71:	75 17                	jne    f0111f8a <test_free_block_BF+0x936>
		{
			panic("6.3 Failed");
f0111f73:	83 ec 04             	sub    $0x4,%esp
f0111f76:	68 a9 b7 12 f0       	push   $0xf012b7a9
f0111f7b:	68 65 04 00 00       	push   $0x465
f0111f80:	68 34 a9 12 f0       	push   $0xf012a934
f0111f85:	e8 90 e3 fe ff       	call   f010031a <_panic>
		}
		expectedNumOfFreeBlks--;
f0111f8a:	ff 4d c0             	decl   -0x40(%ebp)
	}

	cprintf("	7: Allocate After Free [should be placed in coalesced blocks]\n\n") ;
f0111f8d:	83 ec 0c             	sub    $0xc,%esp
f0111f90:	68 44 b4 12 f0       	push   $0xf012b444
f0111f95:	e8 d2 ef fe ff       	call   f0100f6c <cprintf>
f0111f9a:	83 c4 10             	add    $0x10,%esp

	cprintf("		7.1: in block coalesces with PREV\n\n") ;
f0111f9d:	83 ec 0c             	sub    $0xc,%esp
f0111fa0:	68 b4 b7 12 f0       	push   $0xf012b7b4
f0111fa5:	e8 c2 ef fe ff       	call   f0100f6c <cprintf>
f0111faa:	83 c4 10             	add    $0x10,%esp
	actualSize = 2*kilo - sizeOfMetaData;
f0111fad:	c7 45 cc f8 07 00 00 	movl   $0x7f8,-0x34(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f0111fb4:	c7 45 a8 02 00 00 00 	movl   $0x2,-0x58(%ebp)
f0111fbb:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111fbe:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111fc1:	01 d0                	add    %edx,%eax
f0111fc3:	83 c0 07             	add    $0x7,%eax
f0111fc6:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0111fc9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0111fcc:	ba 00 00 00 00       	mov    $0x0,%edx
f0111fd1:	f7 75 a8             	divl   -0x58(%ebp)
f0111fd4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0111fd7:	29 d0                	sub    %edx,%eax
f0111fd9:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f0111fdc:	83 ec 08             	sub    $0x8,%esp
f0111fdf:	6a 03                	push   $0x3
f0111fe1:	ff 75 cc             	pushl  -0x34(%ebp)
f0111fe4:	e8 c5 0e 01 00       	call   f0122eae <alloc_block>
f0111fe9:	83 c4 10             	add    $0x10,%esp
f0111fec:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = startVAs[2*allocCntPerSize];
f0111fef:	a1 c0 36 5c f0       	mov    0xf05c36c0,%eax
f0111ff4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f0111ff7:	6a 01                	push   $0x1
f0111ff9:	ff 75 b8             	pushl  -0x48(%ebp)
f0111ffc:	ff 75 b4             	pushl  -0x4c(%ebp)
f0111fff:	ff 75 c8             	pushl  -0x38(%ebp)
f0112002:	e8 f5 d9 ff ff       	call   f010f9fc <check_block>
f0112007:	83 c4 10             	add    $0x10,%esp
f011200a:	85 c0                	test   %eax,%eax
f011200c:	75 17                	jne    f0112025 <test_free_block_BF+0x9d1>
	{
		panic("7.1 Failed");
f011200e:	83 ec 04             	sub    $0x4,%esp
f0112011:	68 da b7 12 f0       	push   $0xf012b7da
f0112016:	68 74 04 00 00       	push   $0x474
f011201b:	68 34 a9 12 f0       	push   $0xf012a934
f0112020:	e8 f5 e2 fe ff       	call   f010031a <_panic>
	}

	expectedNumOfFreeBlks--;
f0112025:	ff 4d c0             	decl   -0x40(%ebp)

	actualSize = 8*kilo;
f0112028:	c7 45 cc 00 20 00 00 	movl   $0x2000,-0x34(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f011202f:	c7 45 a0 02 00 00 00 	movl   $0x2,-0x60(%ebp)
f0112036:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0112039:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011203c:	01 d0                	add    %edx,%eax
f011203e:	83 c0 07             	add    $0x7,%eax
f0112041:	89 45 9c             	mov    %eax,-0x64(%ebp)
f0112044:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112047:	ba 00 00 00 00       	mov    $0x0,%edx
f011204c:	f7 75 a0             	divl   -0x60(%ebp)
f011204f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112052:	29 d0                	sub    %edx,%eax
f0112054:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f0112057:	83 ec 08             	sub    $0x8,%esp
f011205a:	6a 03                	push   $0x3
f011205c:	ff 75 cc             	pushl  -0x34(%ebp)
f011205f:	e8 4a 0e 01 00       	call   f0122eae <alloc_block>
f0112064:	83 c4 10             	add    $0x10,%esp
f0112067:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = startVAs[numOfAllocs*allocCntPerSize-1];
f011206a:	a1 5c 46 5c f0       	mov    0xf05c465c,%eax
f011206f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f0112072:	6a 01                	push   $0x1
f0112074:	ff 75 b8             	pushl  -0x48(%ebp)
f0112077:	ff 75 b4             	pushl  -0x4c(%ebp)
f011207a:	ff 75 c8             	pushl  -0x38(%ebp)
f011207d:	e8 7a d9 ff ff       	call   f010f9fc <check_block>
f0112082:	83 c4 10             	add    $0x10,%esp
f0112085:	85 c0                	test   %eax,%eax
f0112087:	75 17                	jne    f01120a0 <test_free_block_BF+0xa4c>
	{
		panic("7.2 Failed");
f0112089:	83 ec 04             	sub    $0x4,%esp
f011208c:	68 e5 b7 12 f0       	push   $0xf012b7e5
f0112091:	68 80 04 00 00       	push   $0x480
f0112096:	68 34 a9 12 f0       	push   $0xf012a934
f011209b:	e8 7a e2 fe ff       	call   f010031a <_panic>
	}

	cprintf("		7.2: in block coalesces with PREV & NEXT\n\n") ;
f01120a0:	83 ec 0c             	sub    $0xc,%esp
f01120a3:	68 28 b5 12 f0       	push   $0xf012b528
f01120a8:	e8 bf ee fe ff       	call   f0100f6c <cprintf>
f01120ad:	83 c4 10             	add    $0x10,%esp
	actualSize = 2*kilo + 1;
f01120b0:	c7 45 cc 01 08 00 00 	movl   $0x801,-0x34(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f01120b7:	c7 45 98 02 00 00 00 	movl   $0x2,-0x68(%ebp)
f01120be:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01120c1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01120c4:	01 d0                	add    %edx,%eax
f01120c6:	83 c0 07             	add    $0x7,%eax
f01120c9:	89 45 94             	mov    %eax,-0x6c(%ebp)
f01120cc:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01120cf:	ba 00 00 00 00       	mov    $0x0,%edx
f01120d4:	f7 75 98             	divl   -0x68(%ebp)
f01120d7:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01120da:	29 d0                	sub    %edx,%eax
f01120dc:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f01120df:	83 ec 08             	sub    $0x8,%esp
f01120e2:	6a 03                	push   $0x3
f01120e4:	ff 75 cc             	pushl  -0x34(%ebp)
f01120e7:	e8 c2 0d 01 00       	call   f0122eae <alloc_block>
f01120ec:	83 c4 10             	add    $0x10,%esp
f01120ef:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = startVAs[4*allocCntPerSize - 2];
f01120f2:	a1 f8 3c 5c f0       	mov    0xf05c3cf8,%eax
f01120f7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f01120fa:	6a 01                	push   $0x1
f01120fc:	ff 75 b8             	pushl  -0x48(%ebp)
f01120ff:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112102:	ff 75 c8             	pushl  -0x38(%ebp)
f0112105:	e8 f2 d8 ff ff       	call   f010f9fc <check_block>
f011210a:	83 c4 10             	add    $0x10,%esp
f011210d:	85 c0                	test   %eax,%eax
f011210f:	75 17                	jne    f0112128 <test_free_block_BF+0xad4>
	{
		panic("7.3 Failed");
f0112111:	83 ec 04             	sub    $0x4,%esp
f0112114:	68 f0 b7 12 f0       	push   $0xf012b7f0
f0112119:	68 8b 04 00 00       	push   $0x48b
f011211e:	68 34 a9 12 f0       	push   $0xf012a934
f0112123:	e8 f2 e1 fe ff       	call   f010031a <_panic>
	}

	cprintf("		7.3: in block coalesces with NEXT [INTERNAL FRAGMENTATION]\n\n") ;
f0112128:	83 ec 0c             	sub    $0xc,%esp
f011212b:	68 fc b7 12 f0       	push   $0xf012b7fc
f0112130:	e8 37 ee fe ff       	call   f0100f6c <cprintf>
f0112135:	83 c4 10             	add    $0x10,%esp
	actualSize = 4*kilo + 10;
f0112138:	c7 45 cc 0a 10 00 00 	movl   $0x100a,-0x34(%ebp)
	expected_size = allocSizes[0]+allocSizes[1]; //ROUNDUP(actualSize + sizeOfMetaData,2) ;
f011213f:	8b 15 b8 0d 18 f0    	mov    0xf0180db8,%edx
f0112145:	a1 bc 0d 18 f0       	mov    0xf0180dbc,%eax
f011214a:	01 d0                	add    %edx,%eax
f011214c:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f011214f:	83 ec 08             	sub    $0x8,%esp
f0112152:	6a 03                	push   $0x3
f0112154:	ff 75 cc             	pushl  -0x34(%ebp)
f0112157:	e8 52 0d 01 00       	call   f0122eae <alloc_block>
f011215c:	83 c4 10             	add    $0x10,%esp
f011215f:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = startVAs[1*allocCntPerSize - 1];
f0112162:	a1 9c 33 5c f0       	mov    0xf05c339c,%eax
f0112167:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f011216a:	6a 01                	push   $0x1
f011216c:	ff 75 b8             	pushl  -0x48(%ebp)
f011216f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112172:	ff 75 c8             	pushl  -0x38(%ebp)
f0112175:	e8 82 d8 ff ff       	call   f010f9fc <check_block>
f011217a:	83 c4 10             	add    $0x10,%esp
f011217d:	85 c0                	test   %eax,%eax
f011217f:	75 17                	jne    f0112198 <test_free_block_BF+0xb44>
	{
		panic("7.4 Failed");
f0112181:	83 ec 04             	sub    $0x4,%esp
f0112184:	68 3b b8 12 f0       	push   $0xf012b83b
f0112189:	68 96 04 00 00       	push   $0x496
f011218e:	68 34 a9 12 f0       	push   $0xf012a934
f0112193:	e8 82 e1 fe ff       	call   f010031a <_panic>
	}
	expectedNumOfFreeBlks--;
f0112198:	ff 4d c0             	decl   -0x40(%ebp)

	actualSize = 5*kilo - sizeOfMetaData;
f011219b:	c7 45 cc f8 13 00 00 	movl   $0x13f8,-0x34(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f01121a2:	c7 45 90 02 00 00 00 	movl   $0x2,-0x70(%ebp)
f01121a9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01121ac:	8b 45 90             	mov    -0x70(%ebp),%eax
f01121af:	01 d0                	add    %edx,%eax
f01121b1:	83 c0 07             	add    $0x7,%eax
f01121b4:	89 45 8c             	mov    %eax,-0x74(%ebp)
f01121b7:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01121ba:	ba 00 00 00 00       	mov    $0x0,%edx
f01121bf:	f7 75 90             	divl   -0x70(%ebp)
f01121c2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01121c5:	29 d0                	sub    %edx,%eax
f01121c7:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f01121ca:	83 ec 08             	sub    $0x8,%esp
f01121cd:	6a 03                	push   $0x3
f01121cf:	ff 75 cc             	pushl  -0x34(%ebp)
f01121d2:	e8 d7 0c 01 00       	call   f0122eae <alloc_block>
f01121d7:	83 c4 10             	add    $0x10,%esp
f01121da:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = (void*)(KERNEL_HEAP_START + sizeOfMetaData);
f01121dd:	c7 45 b4 08 00 00 f6 	movl   $0xf6000008,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f01121e4:	6a 01                	push   $0x1
f01121e6:	ff 75 b8             	pushl  -0x48(%ebp)
f01121e9:	ff 75 b4             	pushl  -0x4c(%ebp)
f01121ec:	ff 75 c8             	pushl  -0x38(%ebp)
f01121ef:	e8 08 d8 ff ff       	call   f010f9fc <check_block>
f01121f4:	83 c4 10             	add    $0x10,%esp
f01121f7:	85 c0                	test   %eax,%eax
f01121f9:	75 17                	jne    f0112212 <test_free_block_BF+0xbbe>
	{
		panic("7.5 Failed");
f01121fb:	83 ec 04             	sub    $0x4,%esp
f01121fe:	68 46 b8 12 f0       	push   $0xf012b846
f0112203:	68 a1 04 00 00       	push   $0x4a1
f0112208:	68 34 a9 12 f0       	push   $0xf012a934
f011220d:	e8 08 e1 fe ff       	call   f010031a <_panic>
	}

	actualSize = 3*kilo - sizeOfMetaData;
f0112212:	c7 45 cc f8 0b 00 00 	movl   $0xbf8,-0x34(%ebp)
	expected_size = ROUNDUP(actualSize + sizeOfMetaData,2) ;
f0112219:	c7 45 88 02 00 00 00 	movl   $0x2,-0x78(%ebp)
f0112220:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0112223:	8b 45 88             	mov    -0x78(%ebp),%eax
f0112226:	01 d0                	add    %edx,%eax
f0112228:	83 c0 07             	add    $0x7,%eax
f011222b:	89 45 84             	mov    %eax,-0x7c(%ebp)
f011222e:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0112231:	ba 00 00 00 00       	mov    $0x0,%edx
f0112236:	f7 75 88             	divl   -0x78(%ebp)
f0112239:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011223c:	29 d0                	sub    %edx,%eax
f011223e:	89 45 b8             	mov    %eax,-0x48(%ebp)
	va = alloc_block(actualSize, DA_BF);
f0112241:	83 ec 08             	sub    $0x8,%esp
f0112244:	6a 03                	push   $0x3
f0112246:	ff 75 cc             	pushl  -0x34(%ebp)
f0112249:	e8 60 0c 01 00       	call   f0122eae <alloc_block>
f011224e:	83 c4 10             	add    $0x10,%esp
f0112251:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//Check returned va
	expected = (void*)(KERNEL_HEAP_START + 5*kilo + sizeOfMetaData);
f0112254:	c7 45 b4 08 14 00 f6 	movl   $0xf6001408,-0x4c(%ebp)
	if (check_block(va, expected, expected_size, 1) == 0)
f011225b:	6a 01                	push   $0x1
f011225d:	ff 75 b8             	pushl  -0x48(%ebp)
f0112260:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112263:	ff 75 c8             	pushl  -0x38(%ebp)
f0112266:	e8 91 d7 ff ff       	call   f010f9fc <check_block>
f011226b:	83 c4 10             	add    $0x10,%esp
f011226e:	85 c0                	test   %eax,%eax
f0112270:	75 17                	jne    f0112289 <test_free_block_BF+0xc35>
	{
		panic("7.6 Failed");
f0112272:	83 ec 04             	sub    $0x4,%esp
f0112275:	68 51 b8 12 f0       	push   $0xf012b851
f011227a:	68 ab 04 00 00       	push   $0x4ab
f011227f:	68 34 a9 12 f0       	push   $0xf012a934
f0112284:	e8 91 e0 fe ff       	call   f010031a <_panic>
	}
	expectedNumOfFreeBlks--;
f0112289:	ff 4d c0             	decl   -0x40(%ebp)

	if (check_list_size(expectedNumOfFreeBlks) == 0)
f011228c:	83 ec 0c             	sub    $0xc,%esp
f011228f:	ff 75 c0             	pushl  -0x40(%ebp)
f0112292:	e8 ed d7 ff ff       	call   f010fa84 <check_list_size>
f0112297:	83 c4 10             	add    $0x10,%esp
f011229a:	85 c0                	test   %eax,%eax
f011229c:	75 17                	jne    f01122b5 <test_free_block_BF+0xc61>
	{
		panic("7.7 Failed");
f011229e:	83 ec 04             	sub    $0x4,%esp
f01122a1:	68 5c b8 12 f0       	push   $0xf012b85c
f01122a6:	68 b1 04 00 00       	push   $0x4b1
f01122ab:	68 34 a9 12 f0       	push   $0xf012a934
f01122b0:	e8 65 e0 fe ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");
f01122b5:	83 ec 0c             	sub    $0xc,%esp
f01122b8:	68 68 b8 12 f0       	push   $0xf012b868
f01122bd:	e8 aa ec fe ff       	call   f0100f6c <cprintf>
f01122c2:	83 c4 10             	add    $0x10,%esp

}
f01122c5:	90                   	nop
f01122c6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01122c9:	c9                   	leave  
f01122ca:	c3                   	ret    

f01122cb <test_free_block_NF>:

void test_free_block_NF()
{
f01122cb:	55                   	push   %ebp
f01122cc:	89 e5                	mov    %esp,%ebp
f01122ce:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f01122d1:	83 ec 04             	sub    $0x4,%esp
f01122d4:	68 b1 b8 12 f0       	push   $0xf012b8b1
f01122d9:	68 ba 04 00 00       	push   $0x4ba
f01122de:	68 34 a9 12 f0       	push   $0xf012a934
f01122e3:	e8 32 e0 fe ff       	call   f010031a <_panic>

f01122e8 <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f01122e8:	55                   	push   %ebp
f01122e9:	89 e5                	mov    %esp,%ebp
f01122eb:	81 ec 98 00 00 00    	sub    $0x98,%esp
#endif

	//TODO: [PROJECT'24.MS1 - #09] [3] DYNAMIC ALLOCATOR - test_realloc_block_FF()
	//CHECK MISSING CASES AND TRY TO TEST THEM !

	cprintf("===================================================\n");
f01122f1:	83 ec 0c             	sub    $0xc,%esp
f01122f4:	68 c4 b8 12 f0       	push   $0xf012b8c4
f01122f9:	e8 6e ec fe ff       	call   f0100f6c <cprintf>
f01122fe:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A PARTIAL TEST FOR REALLOC******\n") ;
f0112301:	83 ec 0c             	sub    $0xc,%esp
f0112304:	68 fc b8 12 f0       	push   $0xf012b8fc
f0112309:	e8 5e ec fe ff       	call   f0100f6c <cprintf>
f011230e:	83 c4 10             	add    $0x10,%esp
	cprintf("You need to pick-up the missing tests and test them\n") ;
f0112311:	83 ec 0c             	sub    $0xc,%esp
f0112314:	68 34 b9 12 f0       	push   $0xf012b934
f0112319:	e8 4e ec fe ff       	call   f0100f6c <cprintf>
f011231e:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f0112321:	83 ec 0c             	sub    $0xc,%esp
f0112324:	68 c4 b8 12 f0       	push   $0xf012b8c4
f0112329:	e8 3e ec fe ff       	call   f0100f6c <cprintf>
f011232e:	83 c4 10             	add    $0x10,%esp

	int eval = 0;
f0112331:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool is_correct;

	int initAllocatedSpace = 3*Mega;
f0112338:	c7 45 c8 00 00 30 00 	movl   $0x300000,-0x38(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f011233f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0112342:	83 ec 08             	sub    $0x8,%esp
f0112345:	50                   	push   %eax
f0112346:	68 00 00 00 f6       	push   $0xf6000000
f011234b:	e8 8b 0c 01 00       	call   f0122fdb <initialize_dynamic_allocator>
f0112350:	83 c4 10             	add    $0x10,%esp
	void * va, *expectedVA ;
	//====================================================================//
	//[1] Test calling realloc with VA = NULL. It should call malloc
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("1: Test calling realloc with VA = NULL.[10%]\n\n") ;
f0112353:	83 ec 0c             	sub    $0xc,%esp
f0112356:	68 6c b9 12 f0       	push   $0xf012b96c
f011235b:	e8 0c ec fe ff       	call   f0100f6c <cprintf>
f0112360:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0112363:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	int totalSizes = 0;
f011236a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f0112371:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0112378:	eb 2a                	jmp    f01123a4 <test_realloc_block_FF+0xbc>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f011237a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011237d:	8b 14 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%edx
f0112384:	89 d0                	mov    %edx,%eax
f0112386:	c1 e0 02             	shl    $0x2,%eax
f0112389:	01 d0                	add    %edx,%eax
f011238b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0112392:	01 d0                	add    %edx,%eax
f0112394:	c1 e0 03             	shl    $0x3,%eax
f0112397:	89 c2                	mov    %eax,%edx
f0112399:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011239c:	01 d0                	add    %edx,%eax
f011239e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	/* Try to allocate set of blocks with different sizes*/
	cprintf("1: Test calling realloc with VA = NULL.[10%]\n\n") ;
	is_correct = 1;

	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f01123a1:	ff 45 e8             	incl   -0x18(%ebp)
f01123a4:	83 7d e8 06          	cmpl   $0x6,-0x18(%ebp)
f01123a8:	7e d0                	jle    f011237a <test_realloc_block_FF+0x92>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
	}
	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ; //exclude size of "DA Begin & End" blocks
f01123aa:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01123ad:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01123b0:	83 e8 08             	sub    $0x8,%eax
f01123b3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if (remainSize <= 0)
f01123b6:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f01123ba:	7f 17                	jg     f01123d3 <test_realloc_block_FF+0xeb>
		panic("test_realloc_block_FF is not configured correctly. Consider updating the initial allocated space OR the required allocations");
f01123bc:	83 ec 04             	sub    $0x4,%esp
f01123bf:	68 9c b9 12 f0       	push   $0xf012b99c
f01123c4:	68 e1 04 00 00       	push   $0x4e1
f01123c9:	68 34 a9 12 f0       	push   $0xf012a934
f01123ce:	e8 47 df fe ff       	call   f010031a <_panic>

	int idx = 0;
f01123d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) /*BEG block*/ ;
f01123da:	c7 45 e0 04 00 00 f6 	movl   $0xf6000004,-0x20(%ebp)
	uint32 actualSize, expectedSize;
	for (int i = 0; i < numOfAllocs; ++i)
f01123e1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01123e8:	e9 2f 01 00 00       	jmp    f011251c <test_realloc_block_FF+0x234>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f01123ed:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01123f4:	e9 13 01 00 00       	jmp    f011250c <test_realloc_block_FF+0x224>
		{
			actualSize = allocSizes[i] - sizeOfMetaData;
f01123f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01123fc:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f0112403:	83 e8 08             	sub    $0x8,%eax
f0112406:	89 45 c0             	mov    %eax,-0x40(%ebp)
			expectedSize = ROUNDUP(actualSize + sizeOfMetaData, 2);
f0112409:	c7 45 bc 02 00 00 00 	movl   $0x2,-0x44(%ebp)
f0112410:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0112413:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112416:	01 d0                	add    %edx,%eax
f0112418:	83 c0 07             	add    $0x7,%eax
f011241b:	89 45 b8             	mov    %eax,-0x48(%ebp)
f011241e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112421:	ba 00 00 00 00       	mov    $0x0,%edx
f0112426:	f7 75 bc             	divl   -0x44(%ebp)
f0112429:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011242c:	29 d0                	sub    %edx,%eax
f011242e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			expectedVA = (curVA + sizeOfMetaData/2);
f0112431:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0112434:	83 c0 04             	add    $0x4,%eax
f0112437:	89 45 b0             	mov    %eax,-0x50(%ebp)
			va = startVAs[idx] = realloc_block_FF(NULL, actualSize);
f011243a:	83 ec 08             	sub    $0x8,%esp
f011243d:	ff 75 c0             	pushl  -0x40(%ebp)
f0112440:	6a 00                	push   $0x0
f0112442:	e8 f5 1c 01 00       	call   f012413c <realloc_block_FF>
f0112447:	83 c4 10             	add    $0x10,%esp
f011244a:	89 c2                	mov    %eax,%edx
f011244c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011244f:	89 14 85 80 30 5c f0 	mov    %edx,-0xfa3cf80(,%eax,4)
f0112456:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112459:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112460:	89 45 ac             	mov    %eax,-0x54(%ebp)
			midVAs[idx] = va + actualSize/2 ;
f0112463:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112466:	d1 e8                	shr    %eax
f0112468:	89 c2                	mov    %eax,%edx
f011246a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011246d:	01 c2                	add    %eax,%edx
f011246f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112472:	89 14 85 80 5c 5c f0 	mov    %edx,-0xfa3a380(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f0112479:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011247c:	8d 50 fe             	lea    -0x2(%eax),%edx
f011247f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112482:	01 c2                	add    %eax,%edx
f0112484:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112487:	89 14 85 80 46 5c f0 	mov    %edx,-0xfa3b980(,%eax,4)
			if (check_block(va, expectedVA, expectedSize, 1) == 0)
f011248e:	6a 01                	push   $0x1
f0112490:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112493:	ff 75 b0             	pushl  -0x50(%ebp)
f0112496:	ff 75 ac             	pushl  -0x54(%ebp)
f0112499:	e8 5e d5 ff ff       	call   f010f9fc <check_block>
f011249e:	83 c4 10             	add    $0x10,%esp
f01124a1:	85 c0                	test   %eax,%eax
f01124a3:	75 24                	jne    f01124c9 <test_realloc_block_FF+0x1e1>
			{
				panic("test_realloc_block_FF #1.1.%d: WRONG ALLOC - it return wrong address. Expected %x, Actual %x", idx, curVA + sizeOfMetaData ,va);
f01124a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01124a8:	83 c0 08             	add    $0x8,%eax
f01124ab:	83 ec 08             	sub    $0x8,%esp
f01124ae:	ff 75 ac             	pushl  -0x54(%ebp)
f01124b1:	50                   	push   %eax
f01124b2:	ff 75 e4             	pushl  -0x1c(%ebp)
f01124b5:	68 1c ba 12 f0       	push   $0xf012ba1c
f01124ba:	68 f2 04 00 00       	push   $0x4f2
f01124bf:	68 34 a9 12 f0       	push   $0xf012a934
f01124c4:	e8 51 de fe ff       	call   f010031a <_panic>
			}
			curVA += allocSizes[i] ;
f01124c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01124cc:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f01124d3:	01 45 e0             	add    %eax,-0x20(%ebp)
			*(startVAs[idx]) = idx ;
f01124d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01124d9:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f01124e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01124e3:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f01124e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01124e9:	8b 14 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%edx
f01124f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01124f3:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f01124f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01124f9:	8b 14 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%edx
f0112500:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112503:	66 89 02             	mov    %ax,(%edx)
			idx++;
f0112506:	ff 45 e4             	incl   -0x1c(%ebp)
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) /*BEG block*/ ;
	uint32 actualSize, expectedSize;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f0112509:	ff 45 d8             	incl   -0x28(%ebp)
f011250c:	81 7d d8 c7 00 00 00 	cmpl   $0xc7,-0x28(%ebp)
f0112513:	0f 8e e0 fe ff ff    	jle    f01123f9 <test_realloc_block_FF+0x111>
		panic("test_realloc_block_FF is not configured correctly. Consider updating the initial allocated space OR the required allocations");

	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) /*BEG block*/ ;
	uint32 actualSize, expectedSize;
	for (int i = 0; i < numOfAllocs; ++i)
f0112519:	ff 45 dc             	incl   -0x24(%ebp)
f011251c:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f0112520:	0f 8e c7 fe ff ff    	jle    f01123ed <test_realloc_block_FF+0x105>
		}
	}

	//====================================================================//
	/* Try to allocate a block with a size equal to the size of the first existing free block*/
	actualSize = remainSize - sizeOfMetaData;
f0112526:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0112529:	83 e8 08             	sub    $0x8,%eax
f011252c:	89 45 c0             	mov    %eax,-0x40(%ebp)
	expectedSize = ROUNDUP(actualSize + sizeOfMetaData, 2);
f011252f:	c7 45 a8 02 00 00 00 	movl   $0x2,-0x58(%ebp)
f0112536:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0112539:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011253c:	01 d0                	add    %edx,%eax
f011253e:	83 c0 07             	add    $0x7,%eax
f0112541:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0112544:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112547:	ba 00 00 00 00       	mov    $0x0,%edx
f011254c:	f7 75 a8             	divl   -0x58(%ebp)
f011254f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112552:	29 d0                	sub    %edx,%eax
f0112554:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	expectedVA = (curVA + sizeOfMetaData/2);
f0112557:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011255a:	83 c0 04             	add    $0x4,%eax
f011255d:	89 45 b0             	mov    %eax,-0x50(%ebp)

	va = startVAs[idx] = realloc_block_FF(NULL, actualSize);
f0112560:	83 ec 08             	sub    $0x8,%esp
f0112563:	ff 75 c0             	pushl  -0x40(%ebp)
f0112566:	6a 00                	push   $0x0
f0112568:	e8 cf 1b 01 00       	call   f012413c <realloc_block_FF>
f011256d:	83 c4 10             	add    $0x10,%esp
f0112570:	89 c2                	mov    %eax,%edx
f0112572:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112575:	89 14 85 80 30 5c f0 	mov    %edx,-0xfa3cf80(,%eax,4)
f011257c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011257f:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112586:	89 45 ac             	mov    %eax,-0x54(%ebp)

	midVAs[idx] = va + actualSize/2 ;
f0112589:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011258c:	d1 e8                	shr    %eax
f011258e:	89 c2                	mov    %eax,%edx
f0112590:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112593:	01 c2                	add    %eax,%edx
f0112595:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112598:	89 14 85 80 5c 5c f0 	mov    %edx,-0xfa3a380(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f011259f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01125a2:	8d 50 fe             	lea    -0x2(%eax),%edx
f01125a5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01125a8:	01 c2                	add    %eax,%edx
f01125aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01125ad:	89 14 85 80 46 5c f0 	mov    %edx,-0xfa3b980(,%eax,4)
	//Check returned va
	if (check_block(va, expectedVA, expectedSize, 1) == 0)
f01125b4:	6a 01                	push   $0x1
f01125b6:	ff 75 b4             	pushl  -0x4c(%ebp)
f01125b9:	ff 75 b0             	pushl  -0x50(%ebp)
f01125bc:	ff 75 ac             	pushl  -0x54(%ebp)
f01125bf:	e8 38 d4 ff ff       	call   f010f9fc <check_block>
f01125c4:	83 c4 10             	add    $0x10,%esp
f01125c7:	85 c0                	test   %eax,%eax
f01125c9:	75 17                	jne    f01125e2 <test_realloc_block_FF+0x2fa>
	{
		panic("test_realloc_block_FF #1.2.0: WRONG ALLOC - it return wrong address.");
f01125cb:	83 ec 04             	sub    $0x4,%esp
f01125ce:	68 7c ba 12 f0       	push   $0xf012ba7c
f01125d3:	68 09 05 00 00       	push   $0x509
f01125d8:	68 34 a9 12 f0       	push   $0xf012a934
f01125dd:	e8 38 dd fe ff       	call   f010031a <_panic>
	}
	*(startVAs[idx]) = idx ;
f01125e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01125e5:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f01125ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01125ef:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f01125f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01125f5:	8b 14 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%edx
f01125fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01125ff:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f0112602:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112605:	8b 14 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%edx
f011260c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011260f:	66 89 02             	mov    %ax,(%edx)

	//====================================================================//
	/* Check stored data inside each allocated block*/
	for (int i = 0; i < idx; ++i)
f0112612:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0112619:	eb 59                	jmp    f0112674 <test_realloc_block_FF+0x38c>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f011261b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011261e:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112625:	66 8b 00             	mov    (%eax),%ax
f0112628:	98                   	cwtl   
f0112629:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011262c:	75 26                	jne    f0112654 <test_realloc_block_FF+0x36c>
f011262e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0112631:	8b 04 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%eax
f0112638:	66 8b 00             	mov    (%eax),%ax
f011263b:	98                   	cwtl   
f011263c:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011263f:	75 13                	jne    f0112654 <test_realloc_block_FF+0x36c>
f0112641:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0112644:	8b 04 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%eax
f011264b:	66 8b 00             	mov    (%eax),%ax
f011264e:	98                   	cwtl   
f011264f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0112652:	74 1d                	je     f0112671 <test_realloc_block_FF+0x389>
			panic("test_realloc_block_FF #1.3.%d: WRONG! content of the block is not correct. Expected %d",i, i);
f0112654:	83 ec 0c             	sub    $0xc,%esp
f0112657:	ff 75 d4             	pushl  -0x2c(%ebp)
f011265a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011265d:	68 c4 ba 12 f0       	push   $0xf012bac4
f0112662:	68 14 05 00 00       	push   $0x514
f0112667:	68 34 a9 12 f0       	push   $0xf012a934
f011266c:	e8 a9 dc fe ff       	call   f010031a <_panic>
	*(midVAs[idx]) = idx ;
	*(endVAs[idx]) = idx ;

	//====================================================================//
	/* Check stored data inside each allocated block*/
	for (int i = 0; i < idx; ++i)
f0112671:	ff 45 d4             	incl   -0x2c(%ebp)
f0112674:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0112677:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011267a:	7c 9f                	jl     f011261b <test_realloc_block_FF+0x333>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
			panic("test_realloc_block_FF #1.3.%d: WRONG! content of the block is not correct. Expected %d",i, i);
	}

	if (is_correct)
f011267c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112680:	74 04                	je     f0112686 <test_realloc_block_FF+0x39e>
	{
		eval += 10;
f0112682:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	//====================================================================//
	//[2] Test krealloc by passing size = 0. It should call free
	//====================================================================//
	cprintf("2: Test calling realloc with SIZE = 0.[10%]\n\n") ;
f0112686:	83 ec 0c             	sub    $0xc,%esp
f0112689:	68 1c bb 12 f0       	push   $0xf012bb1c
f011268e:	e8 d9 e8 fe ff       	call   f0100f6c <cprintf>
f0112693:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0112696:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f011269d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01126a4:	e9 f1 00 00 00       	jmp    f011279a <test_realloc_block_FF+0x4b2>
	{
		va = realloc_block_FF(startVAs[i*allocCntPerSize], 0);
f01126a9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01126ac:	89 d0                	mov    %edx,%eax
f01126ae:	c1 e0 02             	shl    $0x2,%eax
f01126b1:	01 d0                	add    %edx,%eax
f01126b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01126ba:	01 d0                	add    %edx,%eax
f01126bc:	c1 e0 03             	shl    $0x3,%eax
f01126bf:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f01126c6:	83 ec 08             	sub    $0x8,%esp
f01126c9:	6a 00                	push   $0x0
f01126cb:	50                   	push   %eax
f01126cc:	e8 6b 1a 01 00       	call   f012413c <realloc_block_FF>
f01126d1:	83 c4 10             	add    $0x10,%esp
f01126d4:	89 45 ac             	mov    %eax,-0x54(%ebp)

		uint32 block_size = get_block_size(startVAs[i*allocCntPerSize]) ;
f01126d7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01126da:	89 d0                	mov    %edx,%eax
f01126dc:	c1 e0 02             	shl    $0x2,%eax
f01126df:	01 d0                	add    %edx,%eax
f01126e1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01126e8:	01 d0                	add    %edx,%eax
f01126ea:	c1 e0 03             	shl    $0x3,%eax
f01126ed:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f01126f4:	83 ec 0c             	sub    $0xc,%esp
f01126f7:	50                   	push   %eax
f01126f8:	e8 7a 07 01 00       	call   f0122e77 <get_block_size>
f01126fd:	83 c4 10             	add    $0x10,%esp
f0112700:	89 45 a0             	mov    %eax,-0x60(%ebp)
		expectedSize = allocSizes[i];
f0112703:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112706:	8b 04 85 b8 0d 18 f0 	mov    -0xfe7f248(,%eax,4),%eax
f011270d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		expectedVA = va;
f0112710:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112713:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if (check_block(startVAs[i*allocCntPerSize], startVAs[i*allocCntPerSize], expectedSize, 0) == 0)
f0112716:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0112719:	89 d0                	mov    %edx,%eax
f011271b:	c1 e0 02             	shl    $0x2,%eax
f011271e:	01 d0                	add    %edx,%eax
f0112720:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0112727:	01 d0                	add    %edx,%eax
f0112729:	c1 e0 03             	shl    $0x3,%eax
f011272c:	8b 14 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%edx
f0112733:	8b 4d d0             	mov    -0x30(%ebp),%ecx
f0112736:	89 c8                	mov    %ecx,%eax
f0112738:	c1 e0 02             	shl    $0x2,%eax
f011273b:	01 c8                	add    %ecx,%eax
f011273d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0112744:	01 c8                	add    %ecx,%eax
f0112746:	c1 e0 03             	shl    $0x3,%eax
f0112749:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112750:	6a 00                	push   $0x0
f0112752:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112755:	52                   	push   %edx
f0112756:	50                   	push   %eax
f0112757:	e8 a0 d2 ff ff       	call   f010f9fc <check_block>
f011275c:	83 c4 10             	add    $0x10,%esp
f011275f:	85 c0                	test   %eax,%eax
f0112761:	75 17                	jne    f011277a <test_realloc_block_FF+0x492>
		{
			panic("test_realloc_block_FF #2.1.%d: Failed.", i);
f0112763:	ff 75 d0             	pushl  -0x30(%ebp)
f0112766:	68 4c bb 12 f0       	push   $0xf012bb4c
f011276b:	68 2c 05 00 00       	push   $0x52c
f0112770:	68 34 a9 12 f0       	push   $0xf012a934
f0112775:	e8 a0 db fe ff       	call   f010031a <_panic>
		}
		if(va != NULL)
f011277a:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
f011277e:	74 17                	je     f0112797 <test_realloc_block_FF+0x4af>
			panic("test_realloc_block_FF #2.2.%d: it should return NULL.", i);
f0112780:	ff 75 d0             	pushl  -0x30(%ebp)
f0112783:	68 74 bb 12 f0       	push   $0xf012bb74
f0112788:	68 2f 05 00 00       	push   $0x52f
f011278d:	68 34 a9 12 f0       	push   $0xf012a934
f0112792:	e8 83 db fe ff       	call   f010031a <_panic>
	//====================================================================//
	cprintf("2: Test calling realloc with SIZE = 0.[10%]\n\n") ;
	is_correct = 1;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0112797:	ff 45 d0             	incl   -0x30(%ebp)
f011279a:	83 7d d0 06          	cmpl   $0x6,-0x30(%ebp)
f011279e:	0f 8e 05 ff ff ff    	jle    f01126a9 <test_realloc_block_FF+0x3c1>
		if(va != NULL)
			panic("test_realloc_block_FF #2.2.%d: it should return NULL.", i);
	}

	//test calling it with NULL & ZERO
	va = realloc_block_FF(NULL, 0);
f01127a4:	83 ec 08             	sub    $0x8,%esp
f01127a7:	6a 00                	push   $0x0
f01127a9:	6a 00                	push   $0x0
f01127ab:	e8 8c 19 01 00       	call   f012413c <realloc_block_FF>
f01127b0:	83 c4 10             	add    $0x10,%esp
f01127b3:	89 45 ac             	mov    %eax,-0x54(%ebp)
	if(va != NULL)
f01127b6:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
f01127ba:	74 17                	je     f01127d3 <test_realloc_block_FF+0x4eb>
		panic("test_realloc_block_FF #2.3.0: it should return NULL.");
f01127bc:	83 ec 04             	sub    $0x4,%esp
f01127bf:	68 ac bb 12 f0       	push   $0xf012bbac
f01127c4:	68 35 05 00 00       	push   $0x535
f01127c9:	68 34 a9 12 f0       	push   $0xf012a934
f01127ce:	e8 47 db fe ff       	call   f010031a <_panic>

	//====================================================================//
	/* Check stored data inside each allocated block*/
	for (int i = 0; i < idx; ++i)
f01127d3:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f01127da:	eb 6b                	jmp    f0112847 <test_realloc_block_FF+0x55f>
	{
		if (i % allocCntPerSize == 0)
f01127dc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01127df:	b9 c8 00 00 00       	mov    $0xc8,%ecx
f01127e4:	99                   	cltd   
f01127e5:	f7 f9                	idiv   %ecx
f01127e7:	89 d0                	mov    %edx,%eax
f01127e9:	85 c0                	test   %eax,%eax
f01127eb:	74 56                	je     f0112843 <test_realloc_block_FF+0x55b>
			continue;
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f01127ed:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01127f0:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f01127f7:	66 8b 00             	mov    (%eax),%ax
f01127fa:	98                   	cwtl   
f01127fb:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f01127fe:	75 26                	jne    f0112826 <test_realloc_block_FF+0x53e>
f0112800:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0112803:	8b 04 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%eax
f011280a:	66 8b 00             	mov    (%eax),%ax
f011280d:	98                   	cwtl   
f011280e:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0112811:	75 13                	jne    f0112826 <test_realloc_block_FF+0x53e>
f0112813:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0112816:	8b 04 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%eax
f011281d:	66 8b 00             	mov    (%eax),%ax
f0112820:	98                   	cwtl   
f0112821:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0112824:	74 1e                	je     f0112844 <test_realloc_block_FF+0x55c>
			panic("test_realloc_block_FF #2.4.%d: WRONG! content of the block is not correct. Expected %d",i, i);
f0112826:	83 ec 0c             	sub    $0xc,%esp
f0112829:	ff 75 cc             	pushl  -0x34(%ebp)
f011282c:	ff 75 cc             	pushl  -0x34(%ebp)
f011282f:	68 e4 bb 12 f0       	push   $0xf012bbe4
f0112834:	68 3e 05 00 00       	push   $0x53e
f0112839:	68 34 a9 12 f0       	push   $0xf012a934
f011283e:	e8 d7 da fe ff       	call   f010031a <_panic>
	//====================================================================//
	/* Check stored data inside each allocated block*/
	for (int i = 0; i < idx; ++i)
	{
		if (i % allocCntPerSize == 0)
			continue;
f0112843:	90                   	nop
	if(va != NULL)
		panic("test_realloc_block_FF #2.3.0: it should return NULL.");

	//====================================================================//
	/* Check stored data inside each allocated block*/
	for (int i = 0; i < idx; ++i)
f0112844:	ff 45 cc             	incl   -0x34(%ebp)
f0112847:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011284a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011284d:	7c 8d                	jl     f01127dc <test_realloc_block_FF+0x4f4>
			continue;
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
			panic("test_realloc_block_FF #2.4.%d: WRONG! content of the block is not correct. Expected %d",i, i);
	}

	uint32 expectedNumOfFreeBlks = numOfAllocs;
f011284f:	c7 45 9c 07 00 00 00 	movl   $0x7,-0x64(%ebp)
	if (check_list_size(expectedNumOfFreeBlks) == 0)
f0112856:	83 ec 0c             	sub    $0xc,%esp
f0112859:	ff 75 9c             	pushl  -0x64(%ebp)
f011285c:	e8 23 d2 ff ff       	call   f010fa84 <check_list_size>
f0112861:	83 c4 10             	add    $0x10,%esp
f0112864:	85 c0                	test   %eax,%eax
f0112866:	75 17                	jne    f011287f <test_realloc_block_FF+0x597>
	{
		panic("2.5 Failed");
f0112868:	83 ec 04             	sub    $0x4,%esp
f011286b:	68 3b bc 12 f0       	push   $0xf012bc3b
f0112870:	68 44 05 00 00       	push   $0x544
f0112875:	68 34 a9 12 f0       	push   $0xf012a934
f011287a:	e8 9b da fe ff       	call   f010031a <_panic>
	}

	if (is_correct)
f011287f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112883:	74 04                	je     f0112889 <test_realloc_block_FF+0x5a1>
	{
		eval += 10;
f0112885:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	//====================================================================//
	//[3] Test realloc with increased sizes
	//====================================================================//
	cprintf("3: Test calling realloc with increased sizes [50%].\n\n") ;
f0112889:	83 ec 0c             	sub    $0xc,%esp
f011288c:	68 48 bc 12 f0       	push   $0xf012bc48
f0112891:	e8 d6 e6 fe ff       	call   f0100f6c <cprintf>
f0112896:	83 c4 10             	add    $0x10,%esp
	int blockIndex, block_size, block_status, old_size, new_size, newBlockIndex;
	//[3.1] reallocate in same place (NO relocate - split)
	cprintf("	3.1: reallocate in same place (NO relocate - split)\n\n") ;
f0112899:	83 ec 0c             	sub    $0xc,%esp
f011289c:	68 80 bc 12 f0       	push   $0xf012bc80
f01128a1:	e8 c6 e6 fe ff       	call   f0100f6c <cprintf>
f01128a6:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01128a9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		blockIndex = 4*allocCntPerSize - 1 ;
f01128b0:	c7 45 98 1f 03 00 00 	movl   $0x31f,-0x68(%ebp)
		new_size = allocSizes[3] /*12+16 B*/ + allocSizes[4]/2 /*2KB/2*/ - sizeOfMetaData;
f01128b7:	a1 c4 0d 18 f0       	mov    0xf0180dc4,%eax
f01128bc:	8b 15 c8 0d 18 f0    	mov    0xf0180dc8,%edx
f01128c2:	d1 ea                	shr    %edx
f01128c4:	01 d0                	add    %edx,%eax
f01128c6:	83 e8 08             	sub    $0x8,%eax
f01128c9:	89 45 94             	mov    %eax,-0x6c(%ebp)
		expectedSize = ROUNDUP(new_size + sizeOfMetaData, 2);
f01128cc:	c7 45 90 02 00 00 00 	movl   $0x2,-0x70(%ebp)
f01128d3:	8b 55 94             	mov    -0x6c(%ebp),%edx
f01128d6:	8b 45 90             	mov    -0x70(%ebp),%eax
f01128d9:	01 d0                	add    %edx,%eax
f01128db:	83 c0 07             	add    $0x7,%eax
f01128de:	89 45 8c             	mov    %eax,-0x74(%ebp)
f01128e1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01128e4:	ba 00 00 00 00       	mov    $0x0,%edx
f01128e9:	f7 75 90             	divl   -0x70(%ebp)
f01128ec:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01128ef:	29 d0                	sub    %edx,%eax
f01128f1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		expectedVA = startVAs[blockIndex];
f01128f4:	8b 45 98             	mov    -0x68(%ebp),%eax
f01128f7:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f01128fe:	89 45 b0             	mov    %eax,-0x50(%ebp)

		va = realloc_block_FF(startVAs[blockIndex], new_size);
f0112901:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112904:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112907:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f011290e:	83 ec 08             	sub    $0x8,%esp
f0112911:	52                   	push   %edx
f0112912:	50                   	push   %eax
f0112913:	e8 24 18 01 00       	call   f012413c <realloc_block_FF>
f0112918:	83 c4 10             	add    $0x10,%esp
f011291b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		//check return address
		if (check_block(va, expectedVA, expectedSize, 1) == 0)
f011291e:	6a 01                	push   $0x1
f0112920:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112923:	ff 75 b0             	pushl  -0x50(%ebp)
f0112926:	ff 75 ac             	pushl  -0x54(%ebp)
f0112929:	e8 ce d0 ff ff       	call   f010f9fc <check_block>
f011292e:	83 c4 10             	add    $0x10,%esp
f0112931:	85 c0                	test   %eax,%eax
f0112933:	75 17                	jne    f011294c <test_realloc_block_FF+0x664>
		{
			is_correct = 0;
f0112935:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #3.1.1: Failed\n");
f011293c:	83 ec 0c             	sub    $0xc,%esp
f011293f:	68 b8 bc 12 f0       	push   $0xf012bcb8
f0112944:	e8 23 e6 fe ff       	call   f0100f6c <cprintf>
f0112949:	83 c4 10             	add    $0x10,%esp
		}
		//check content of reallocated block
		if (*(startVAs[blockIndex]) != blockIndex || *(midVAs[blockIndex]) != blockIndex ||	*(endVAs[blockIndex]) != blockIndex)
f011294c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011294f:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112956:	66 8b 00             	mov    (%eax),%ax
f0112959:	98                   	cwtl   
f011295a:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011295d:	75 26                	jne    f0112985 <test_realloc_block_FF+0x69d>
f011295f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112962:	8b 04 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%eax
f0112969:	66 8b 00             	mov    (%eax),%ax
f011296c:	98                   	cwtl   
f011296d:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112970:	75 13                	jne    f0112985 <test_realloc_block_FF+0x69d>
f0112972:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112975:	8b 04 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%eax
f011297c:	66 8b 00             	mov    (%eax),%ax
f011297f:	98                   	cwtl   
f0112980:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112983:	74 1a                	je     f011299f <test_realloc_block_FF+0x6b7>
		{
			is_correct = 0;
f0112985:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #3.1.2: WRONG REALLOC! content of the block is not correct. Expected %d\n", blockIndex);
f011298c:	83 ec 08             	sub    $0x8,%esp
f011298f:	ff 75 98             	pushl  -0x68(%ebp)
f0112992:	68 e0 bc 12 f0       	push   $0xf012bce0
f0112997:	e8 d0 e5 fe ff       	call   f0100f6c <cprintf>
f011299c:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (is_correct)
f011299f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01129a3:	74 04                	je     f01129a9 <test_realloc_block_FF+0x6c1>
	{
		eval += 25;
f01129a5:	83 45 f4 19          	addl   $0x19,-0xc(%ebp)
	}

	//[3.2] reallocate in same place (NO relocate - NO split)
	cprintf("	3.2: reallocate in same place (NO relocate - NO split)\n\n") ;
f01129a9:	83 ec 0c             	sub    $0xc,%esp
f01129ac:	68 40 bd 12 f0       	push   $0xf012bd40
f01129b1:	e8 b6 e5 fe ff       	call   f0100f6c <cprintf>
f01129b6:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01129b9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		blockIndex = 4*allocCntPerSize - 1 ;
f01129c0:	c7 45 98 1f 03 00 00 	movl   $0x31f,-0x68(%ebp)
		//new_size = allocSizes[3] /*12+16B + 2KB/2*/ + allocSizes[4]/2 /*2KB/2*/ - sizeOfMetaData;
		new_size = allocSizes[3] + allocSizes[4] - sizeOfMetaData;
f01129c7:	8b 15 c4 0d 18 f0    	mov    0xf0180dc4,%edx
f01129cd:	a1 c8 0d 18 f0       	mov    0xf0180dc8,%eax
f01129d2:	01 d0                	add    %edx,%eax
f01129d4:	83 e8 08             	sub    $0x8,%eax
f01129d7:	89 45 94             	mov    %eax,-0x6c(%ebp)
		expectedSize = ROUNDUP(new_size + sizeOfMetaData, 2);
f01129da:	c7 45 88 02 00 00 00 	movl   $0x2,-0x78(%ebp)
f01129e1:	8b 55 94             	mov    -0x6c(%ebp),%edx
f01129e4:	8b 45 88             	mov    -0x78(%ebp),%eax
f01129e7:	01 d0                	add    %edx,%eax
f01129e9:	83 c0 07             	add    $0x7,%eax
f01129ec:	89 45 84             	mov    %eax,-0x7c(%ebp)
f01129ef:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01129f2:	ba 00 00 00 00       	mov    $0x0,%edx
f01129f7:	f7 75 88             	divl   -0x78(%ebp)
f01129fa:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01129fd:	29 d0                	sub    %edx,%eax
f01129ff:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		expectedVA = startVAs[blockIndex];
f0112a02:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112a05:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112a0c:	89 45 b0             	mov    %eax,-0x50(%ebp)

		va = realloc_block_FF(startVAs[blockIndex], new_size);
f0112a0f:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112a12:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112a15:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112a1c:	83 ec 08             	sub    $0x8,%esp
f0112a1f:	52                   	push   %edx
f0112a20:	50                   	push   %eax
f0112a21:	e8 16 17 01 00       	call   f012413c <realloc_block_FF>
f0112a26:	83 c4 10             	add    $0x10,%esp
f0112a29:	89 45 ac             	mov    %eax,-0x54(%ebp)

		expectedNumOfFreeBlks--;
f0112a2c:	ff 4d 9c             	decl   -0x64(%ebp)

		if (check_block(va, expectedVA, expectedSize, 1) == 0)
f0112a2f:	6a 01                	push   $0x1
f0112a31:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112a34:	ff 75 b0             	pushl  -0x50(%ebp)
f0112a37:	ff 75 ac             	pushl  -0x54(%ebp)
f0112a3a:	e8 bd cf ff ff       	call   f010f9fc <check_block>
f0112a3f:	83 c4 10             	add    $0x10,%esp
f0112a42:	85 c0                	test   %eax,%eax
f0112a44:	75 17                	jne    f0112a5d <test_realloc_block_FF+0x775>
		{
			is_correct = 0;
f0112a46:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #3.2.1: Failed\n");
f0112a4d:	83 ec 0c             	sub    $0xc,%esp
f0112a50:	68 7c bd 12 f0       	push   $0xf012bd7c
f0112a55:	e8 12 e5 fe ff       	call   f0100f6c <cprintf>
f0112a5a:	83 c4 10             	add    $0x10,%esp
		}
		//check content of reallocated block
		if (*(startVAs[blockIndex]) != blockIndex || *(midVAs[blockIndex]) != blockIndex ||	*(endVAs[blockIndex]) != blockIndex)
f0112a5d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112a60:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112a67:	66 8b 00             	mov    (%eax),%ax
f0112a6a:	98                   	cwtl   
f0112a6b:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112a6e:	75 26                	jne    f0112a96 <test_realloc_block_FF+0x7ae>
f0112a70:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112a73:	8b 04 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%eax
f0112a7a:	66 8b 00             	mov    (%eax),%ax
f0112a7d:	98                   	cwtl   
f0112a7e:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112a81:	75 13                	jne    f0112a96 <test_realloc_block_FF+0x7ae>
f0112a83:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112a86:	8b 04 85 80 46 5c f0 	mov    -0xfa3b980(,%eax,4),%eax
f0112a8d:	66 8b 00             	mov    (%eax),%ax
f0112a90:	98                   	cwtl   
f0112a91:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112a94:	74 1a                	je     f0112ab0 <test_realloc_block_FF+0x7c8>
		{
			is_correct = 0;
f0112a96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #3.2.2: WRONG REALLOC! content of the block is not correct. Expected %d\n", blockIndex);
f0112a9d:	83 ec 08             	sub    $0x8,%esp
f0112aa0:	ff 75 98             	pushl  -0x68(%ebp)
f0112aa3:	68 a4 bd 12 f0       	push   $0xf012bda4
f0112aa8:	e8 bf e4 fe ff       	call   f0100f6c <cprintf>
f0112aad:	83 c4 10             	add    $0x10,%esp
		}

		if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f0112ab0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112ab4:	74 11                	je     f0112ac7 <test_realloc_block_FF+0x7df>
f0112ab6:	83 ec 0c             	sub    $0xc,%esp
f0112ab9:	ff 75 9c             	pushl  -0x64(%ebp)
f0112abc:	e8 c3 cf ff ff       	call   f010fa84 <check_list_size>
f0112ac1:	83 c4 10             	add    $0x10,%esp
f0112ac4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	}
	if (is_correct)
f0112ac7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112acb:	74 04                	je     f0112ad1 <test_realloc_block_FF+0x7e9>
	{
		eval += 25;
f0112acd:	83 45 f4 19          	addl   $0x19,-0xc(%ebp)
	}

	//====================================================================//
	//[4] Test realloc with decreased sizes
	//====================================================================//
	cprintf("4: Test calling realloc with decreased sizes.[30%]\n\n") ;
f0112ad1:	83 ec 0c             	sub    $0xc,%esp
f0112ad4:	68 04 be 12 f0       	push   $0xf012be04
f0112ad9:	e8 8e e4 fe ff       	call   f0100f6c <cprintf>
f0112ade:	83 c4 10             	add    $0x10,%esp
	//[4.1] next block is full (NO coalesce)
	cprintf("	4.1: next block is full (NO coalesce)\n\n") ;
f0112ae1:	83 ec 0c             	sub    $0xc,%esp
f0112ae4:	68 3c be 12 f0       	push   $0xf012be3c
f0112ae9:	e8 7e e4 fe ff       	call   f0100f6c <cprintf>
f0112aee:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0112af1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		blockIndex = 0*allocCntPerSize + 1; /*4KB*/
f0112af8:	c7 45 98 01 00 00 00 	movl   $0x1,-0x68(%ebp)
		old_size = allocSizes[0] - sizeOfMetaData; /*4KB - sizeOfMetaData*/;
f0112aff:	a1 b8 0d 18 f0       	mov    0xf0180db8,%eax
f0112b04:	83 e8 08             	sub    $0x8,%eax
f0112b07:	89 45 80             	mov    %eax,-0x80(%ebp)
		new_size = old_size - 1*kilo ;
f0112b0a:	8b 45 80             	mov    -0x80(%ebp),%eax
f0112b0d:	2d 00 04 00 00       	sub    $0x400,%eax
f0112b12:	89 45 94             	mov    %eax,-0x6c(%ebp)
		expectedSize = ROUNDUP(new_size + sizeOfMetaData, 2);
f0112b15:	c7 85 7c ff ff ff 02 	movl   $0x2,-0x84(%ebp)
f0112b1c:	00 00 00 
f0112b1f:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112b22:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f0112b28:	01 d0                	add    %edx,%eax
f0112b2a:	83 c0 07             	add    $0x7,%eax
f0112b2d:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0112b33:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0112b39:	ba 00 00 00 00       	mov    $0x0,%edx
f0112b3e:	f7 b5 7c ff ff ff    	divl   -0x84(%ebp)
f0112b44:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0112b4a:	29 d0                	sub    %edx,%eax
f0112b4c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		expectedVA = startVAs[blockIndex];
f0112b4f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112b52:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112b59:	89 45 b0             	mov    %eax,-0x50(%ebp)

		va = realloc_block_FF(startVAs[blockIndex], new_size);
f0112b5c:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112b5f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112b62:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112b69:	83 ec 08             	sub    $0x8,%esp
f0112b6c:	52                   	push   %edx
f0112b6d:	50                   	push   %eax
f0112b6e:	e8 c9 15 01 00       	call   f012413c <realloc_block_FF>
f0112b73:	83 c4 10             	add    $0x10,%esp
f0112b76:	89 45 ac             	mov    %eax,-0x54(%ebp)

		expectedNumOfFreeBlks++;
f0112b79:	ff 45 9c             	incl   -0x64(%ebp)

		if (check_block(va, expectedVA, expectedSize, 1) == 0)
f0112b7c:	6a 01                	push   $0x1
f0112b7e:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112b81:	ff 75 b0             	pushl  -0x50(%ebp)
f0112b84:	ff 75 ac             	pushl  -0x54(%ebp)
f0112b87:	e8 70 ce ff ff       	call   f010f9fc <check_block>
f0112b8c:	83 c4 10             	add    $0x10,%esp
f0112b8f:	85 c0                	test   %eax,%eax
f0112b91:	75 17                	jne    f0112baa <test_realloc_block_FF+0x8c2>
		{
			is_correct = 0;
f0112b93:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #4.1.1: Failed\n");
f0112b9a:	83 ec 0c             	sub    $0xc,%esp
f0112b9d:	68 68 be 12 f0       	push   $0xf012be68
f0112ba2:	e8 c5 e3 fe ff       	call   f0100f6c <cprintf>
f0112ba7:	83 c4 10             	add    $0x10,%esp
		}
		//check new free block
		struct BlockElement *newBlkAddr = (struct BlockElement *)(va + new_size + 2*sizeof(int));
f0112baa:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112bad:	8d 50 08             	lea    0x8(%eax),%edx
f0112bb0:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112bb3:	01 d0                	add    %edx,%eax
f0112bb5:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		cprintf("\nrealloc Test: newBlkAddr @va %x\n", newBlkAddr);
f0112bbb:	83 ec 08             	sub    $0x8,%esp
f0112bbe:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
f0112bc4:	68 90 be 12 f0       	push   $0xf012be90
f0112bc9:	e8 9e e3 fe ff       	call   f0100f6c <cprintf>
f0112bce:	83 c4 10             	add    $0x10,%esp
		expectedSize = 1*kilo ;
f0112bd1:	c7 45 b4 00 04 00 00 	movl   $0x400,-0x4c(%ebp)
		if (check_block(newBlkAddr, newBlkAddr, expectedSize, 0) == 0)
f0112bd8:	6a 00                	push   $0x0
f0112bda:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112bdd:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
f0112be3:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
f0112be9:	e8 0e ce ff ff       	call   f010f9fc <check_block>
f0112bee:	83 c4 10             	add    $0x10,%esp
f0112bf1:	85 c0                	test   %eax,%eax
f0112bf3:	75 17                	jne    f0112c0c <test_realloc_block_FF+0x924>
		{
			is_correct = 0;
f0112bf5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #4.1.2: Failed\n");
f0112bfc:	83 ec 0c             	sub    $0xc,%esp
f0112bff:	68 b4 be 12 f0       	push   $0xf012beb4
f0112c04:	e8 63 e3 fe ff       	call   f0100f6c <cprintf>
f0112c09:	83 c4 10             	add    $0x10,%esp
		}
		//check content of reallocated block
		if (*(startVAs[blockIndex]) != blockIndex || *(midVAs[blockIndex]) != blockIndex)
f0112c0c:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112c0f:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112c16:	66 8b 00             	mov    (%eax),%ax
f0112c19:	98                   	cwtl   
f0112c1a:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112c1d:	75 13                	jne    f0112c32 <test_realloc_block_FF+0x94a>
f0112c1f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112c22:	8b 04 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%eax
f0112c29:	66 8b 00             	mov    (%eax),%ax
f0112c2c:	98                   	cwtl   
f0112c2d:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112c30:	74 1a                	je     f0112c4c <test_realloc_block_FF+0x964>
		{
			is_correct = 0;
f0112c32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #4.1.3: WRONG REALLOC! content of the block is not correct. Expected %d\n", blockIndex);
f0112c39:	83 ec 08             	sub    $0x8,%esp
f0112c3c:	ff 75 98             	pushl  -0x68(%ebp)
f0112c3f:	68 dc be 12 f0       	push   $0xf012bedc
f0112c44:	e8 23 e3 fe ff       	call   f0100f6c <cprintf>
f0112c49:	83 c4 10             	add    $0x10,%esp
		}

		//Check # free blocks
		if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f0112c4c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112c50:	74 11                	je     f0112c63 <test_realloc_block_FF+0x97b>
f0112c52:	83 ec 0c             	sub    $0xc,%esp
f0112c55:	ff 75 9c             	pushl  -0x64(%ebp)
f0112c58:	e8 27 ce ff ff       	call   f010fa84 <check_list_size>
f0112c5d:	83 c4 10             	add    $0x10,%esp
f0112c60:	89 45 f0             	mov    %eax,-0x10(%ebp)

	}
	if (is_correct)
f0112c63:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112c67:	74 04                	je     f0112c6d <test_realloc_block_FF+0x985>
	{
		eval += 15;
f0112c69:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}
	cprintf("	4.2: next block is full (NO coalesce) [Internal Fragmentation]\n\n") ;
f0112c6d:	83 ec 0c             	sub    $0xc,%esp
f0112c70:	68 3c bf 12 f0       	push   $0xf012bf3c
f0112c75:	e8 f2 e2 fe ff       	call   f0100f6c <cprintf>
f0112c7a:	83 c4 10             	add    $0x10,%esp

	is_correct = 1;
f0112c7d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		blockIndex = 1*allocCntPerSize + 1;
f0112c84:	c7 45 98 c9 00 00 00 	movl   $0xc9,-0x68(%ebp)
		old_size = allocSizes[1] - sizeOfMetaData;/*20 B*/
f0112c8b:	a1 bc 0d 18 f0       	mov    0xf0180dbc,%eax
f0112c90:	83 e8 08             	sub    $0x8,%eax
f0112c93:	89 45 80             	mov    %eax,-0x80(%ebp)
		new_size = old_size - 6;
f0112c96:	8b 45 80             	mov    -0x80(%ebp),%eax
f0112c99:	83 e8 06             	sub    $0x6,%eax
f0112c9c:	89 45 94             	mov    %eax,-0x6c(%ebp)
		expectedSize = allocSizes[1]; /*Same block size [Internal Framgmentation]*/
f0112c9f:	a1 bc 0d 18 f0       	mov    0xf0180dbc,%eax
f0112ca4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		expectedVA = startVAs[blockIndex];
f0112ca7:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112caa:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112cb1:	89 45 b0             	mov    %eax,-0x50(%ebp)

		va = realloc_block_FF(startVAs[blockIndex], new_size);
f0112cb4:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0112cb7:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112cba:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112cc1:	83 ec 08             	sub    $0x8,%esp
f0112cc4:	52                   	push   %edx
f0112cc5:	50                   	push   %eax
f0112cc6:	e8 71 14 01 00       	call   f012413c <realloc_block_FF>
f0112ccb:	83 c4 10             	add    $0x10,%esp
f0112cce:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (check_block(va, expectedVA, expectedSize, 1) == 0)
f0112cd1:	6a 01                	push   $0x1
f0112cd3:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112cd6:	ff 75 b0             	pushl  -0x50(%ebp)
f0112cd9:	ff 75 ac             	pushl  -0x54(%ebp)
f0112cdc:	e8 1b cd ff ff       	call   f010f9fc <check_block>
f0112ce1:	83 c4 10             	add    $0x10,%esp
f0112ce4:	85 c0                	test   %eax,%eax
f0112ce6:	75 17                	jne    f0112cff <test_realloc_block_FF+0xa17>
		{
			is_correct = 0;
f0112ce8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #4.2.1: Failed\n");
f0112cef:	83 ec 0c             	sub    $0xc,%esp
f0112cf2:	68 80 bf 12 f0       	push   $0xf012bf80
f0112cf7:	e8 70 e2 fe ff       	call   f0100f6c <cprintf>
f0112cfc:	83 c4 10             	add    $0x10,%esp
		}
		//check content of reallocated block
		if (*(startVAs[blockIndex]) != blockIndex || *(midVAs[blockIndex]) != blockIndex)
f0112cff:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112d02:	8b 04 85 80 30 5c f0 	mov    -0xfa3cf80(,%eax,4),%eax
f0112d09:	66 8b 00             	mov    (%eax),%ax
f0112d0c:	98                   	cwtl   
f0112d0d:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112d10:	75 13                	jne    f0112d25 <test_realloc_block_FF+0xa3d>
f0112d12:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112d15:	8b 04 85 80 5c 5c f0 	mov    -0xfa3a380(,%eax,4),%eax
f0112d1c:	66 8b 00             	mov    (%eax),%ax
f0112d1f:	98                   	cwtl   
f0112d20:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0112d23:	74 1a                	je     f0112d3f <test_realloc_block_FF+0xa57>
		{
			is_correct = 0;
f0112d25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_realloc_block_FF #4.2.2: WRONG REALLOC! content of the block is not correct. Expected %d\n", blockIndex);
f0112d2c:	83 ec 08             	sub    $0x8,%esp
f0112d2f:	ff 75 98             	pushl  -0x68(%ebp)
f0112d32:	68 a8 bf 12 f0       	push   $0xf012bfa8
f0112d37:	e8 30 e2 fe ff       	call   f0100f6c <cprintf>
f0112d3c:	83 c4 10             	add    $0x10,%esp
		}

		//Check # free blocks
		if (is_correct) is_correct = check_list_size(expectedNumOfFreeBlks);
f0112d3f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112d43:	74 11                	je     f0112d56 <test_realloc_block_FF+0xa6e>
f0112d45:	83 ec 0c             	sub    $0xc,%esp
f0112d48:	ff 75 9c             	pushl  -0x64(%ebp)
f0112d4b:	e8 34 cd ff ff       	call   f010fa84 <check_list_size>
f0112d50:	83 c4 10             	add    $0x10,%esp
f0112d53:	89 45 f0             	mov    %eax,-0x10(%ebp)

	}
	if (is_correct)
f0112d56:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112d5a:	74 04                	je     f0112d60 <test_realloc_block_FF+0xa78>
	{
		eval += 15;
f0112d5c:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}

	cprintf("[PARTIAL] test realloc_block with FIRST FIT completed. Evaluation = %d%\n", eval);
f0112d60:	83 ec 08             	sub    $0x8,%esp
f0112d63:	ff 75 f4             	pushl  -0xc(%ebp)
f0112d66:	68 08 c0 12 f0       	push   $0xf012c008
f0112d6b:	e8 fc e1 fe ff       	call   f0100f6c <cprintf>
f0112d70:	83 c4 10             	add    $0x10,%esp

}
f0112d73:	90                   	nop
f0112d74:	c9                   	leave  
f0112d75:	c3                   	ret    

f0112d76 <test_realloc_block_FF_COMPLETE>:


void test_realloc_block_FF_COMPLETE()
{
f0112d76:	55                   	push   %ebp
f0112d77:	89 e5                	mov    %esp,%ebp
f0112d79:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	panic("this is UNSEEN test");
f0112d7c:	83 ec 04             	sub    $0x4,%esp
f0112d7f:	68 51 c0 12 f0       	push   $0xf012c051
f0112d84:	68 eb 05 00 00       	push   $0x5eb
f0112d89:	68 34 a9 12 f0       	push   $0xf012a934
f0112d8e:	e8 87 d5 fe ff       	call   f010031a <_panic>

f0112d93 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0112d93:	55                   	push   %ebp
f0112d94:	89 e5                	mov    %esp,%ebp
f0112d96:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0112d99:	e8 a7 79 ff ff       	call   f010a745 <get_cpu_proc>
f0112d9e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0112da1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112da5:	75 16                	jne    f0112dbd <sys_check_LRU_lists+0x2a>
f0112da7:	68 68 c0 12 f0       	push   $0xf012c068
f0112dac:	68 78 c0 12 f0       	push   $0xf012c078
f0112db1:	6a 10                	push   $0x10
f0112db3:	68 8d c0 12 f0       	push   $0xf012c08d
f0112db8:	e8 5d d5 fe ff       	call   f010031a <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f0112dbd:	83 ec 0c             	sub    $0xc,%esp
f0112dc0:	68 ac c0 12 f0       	push   $0xf012c0ac
f0112dc5:	e8 a2 e1 fe ff       	call   f0100f6c <cprintf>
f0112dca:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f0112dcd:	83 ec 0c             	sub    $0xc,%esp
f0112dd0:	ff 75 e0             	pushl  -0x20(%ebp)
f0112dd3:	e8 05 62 ff ff       	call   f0108fdd <env_page_ws_print>
f0112dd8:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f0112ddb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0112dde:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f0112de1:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f0112de8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0112def:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0112df3:	0f 84 a5 00 00 00    	je     f0112e9e <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f0112df9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0112e00:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112e03:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f0112e09:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0112e0c:	eb 4a                	jmp    f0112e58 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0112e0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112e11:	8b 00                	mov    (%eax),%eax
f0112e13:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0112e16:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112e19:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112e1e:	89 c2                	mov    %eax,%edx
f0112e20:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0112e23:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0112e2a:	8b 45 08             	mov    0x8(%ebp),%eax
f0112e2d:	01 c8                	add    %ecx,%eax
f0112e2f:	8b 00                	mov    (%eax),%eax
f0112e31:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0112e34:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0112e37:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112e3c:	39 c2                	cmp    %eax,%edx
f0112e3e:	74 09                	je     f0112e49 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0112e40:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0112e47:	eb 3e                	jmp    f0112e87 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f0112e49:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0112e4c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112e4f:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0112e55:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0112e58:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0112e5c:	74 08                	je     f0112e66 <sys_check_LRU_lists+0xd3>
f0112e5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112e61:	8b 40 10             	mov    0x10(%eax),%eax
f0112e64:	eb 05                	jmp    f0112e6b <sys_check_LRU_lists+0xd8>
f0112e66:	b8 00 00 00 00       	mov    $0x0,%eax
f0112e6b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0112e6e:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f0112e74:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112e77:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0112e7d:	85 c0                	test   %eax,%eax
f0112e7f:	75 8d                	jne    f0112e0e <sys_check_LRU_lists+0x7b>
f0112e81:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0112e85:	75 87                	jne    f0112e0e <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f0112e87:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112e8a:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f0112e90:	8b 45 10             	mov    0x10(%ebp),%eax
f0112e93:	39 c2                	cmp    %eax,%edx
f0112e95:	74 07                	je     f0112e9e <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f0112e97:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0112e9e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0112ea2:	0f 84 a5 00 00 00    	je     f0112f4d <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f0112ea8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0112eaf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112eb2:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f0112eb8:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0112ebb:	eb 4a                	jmp    f0112f07 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f0112ebd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112ec0:	8b 00                	mov    (%eax),%eax
f0112ec2:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0112ec5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112ec8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112ecd:	89 c2                	mov    %eax,%edx
f0112ecf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112ed2:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0112ed9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0112edc:	01 c8                	add    %ecx,%eax
f0112ede:	8b 00                	mov    (%eax),%eax
f0112ee0:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0112ee3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0112ee6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112eeb:	39 c2                	cmp    %eax,%edx
f0112eed:	74 09                	je     f0112ef8 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f0112eef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f0112ef6:	eb 3e                	jmp    f0112f36 <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f0112ef8:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0112efb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112efe:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0112f04:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0112f07:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0112f0b:	74 08                	je     f0112f15 <sys_check_LRU_lists+0x182>
f0112f0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112f10:	8b 40 10             	mov    0x10(%eax),%eax
f0112f13:	eb 05                	jmp    f0112f1a <sys_check_LRU_lists+0x187>
f0112f15:	b8 00 00 00 00       	mov    $0x0,%eax
f0112f1a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0112f1d:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f0112f23:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112f26:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0112f2c:	85 c0                	test   %eax,%eax
f0112f2e:	75 8d                	jne    f0112ebd <sys_check_LRU_lists+0x12a>
f0112f30:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0112f34:	75 87                	jne    f0112ebd <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f0112f36:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0112f39:	8b 90 2c da 01 00    	mov    0x1da2c(%eax),%edx
f0112f3f:	8b 45 14             	mov    0x14(%ebp),%eax
f0112f42:	39 c2                	cmp    %eax,%edx
f0112f44:	74 07                	je     f0112f4d <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f0112f46:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f0112f4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0112f50:	23 45 f0             	and    -0x10(%ebp),%eax
}
f0112f53:	c9                   	leave  
f0112f54:	c3                   	ret    

f0112f55 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f0112f55:	55                   	push   %ebp
f0112f56:	89 e5                	mov    %esp,%ebp
f0112f58:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0112f5b:	e8 e5 77 ff ff       	call   f010a745 <get_cpu_proc>
f0112f60:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0112f63:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0112f67:	75 16                	jne    f0112f7f <sys_check_LRU_lists_free+0x2a>
f0112f69:	68 68 c0 12 f0       	push   $0xf012c068
f0112f6e:	68 78 c0 12 f0       	push   $0xf012c078
f0112f73:	6a 45                	push   $0x45
f0112f75:	68 8d c0 12 f0       	push   $0xf012c08d
f0112f7a:	e8 9b d3 fe ff       	call   f010031a <_panic>
	struct Env* env = cur_env;
f0112f7f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0112f82:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0112f85:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0112f8c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0112f8f:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f0112f95:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0112f98:	eb 65                	jmp    f0112fff <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0112f9a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0112fa1:	eb 3a                	jmp    f0112fdd <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0112fa3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0112fa6:	8b 00                	mov    (%eax),%eax
f0112fa8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0112fab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0112fae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112fb3:	89 c2                	mov    %eax,%edx
f0112fb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112fb8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0112fbf:	8b 45 08             	mov    0x8(%ebp),%eax
f0112fc2:	01 c8                	add    %ecx,%eax
f0112fc4:	8b 00                	mov    (%eax),%eax
f0112fc6:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0112fc9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112fcc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112fd1:	39 c2                	cmp    %eax,%edx
f0112fd3:	75 05                	jne    f0112fda <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f0112fd5:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0112fd8:	eb 0b                	jmp    f0112fe5 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f0112fda:	ff 45 ec             	incl   -0x14(%ebp)
f0112fdd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0112fe0:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0112fe3:	7c be                	jl     f0112fa3 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0112fe5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0112fe9:	7e 08                	jle    f0112ff3 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f0112feb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0112fee:	e9 ed 00 00 00       	jmp    f01130e0 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0112ff3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0112ff6:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0112ffc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0112fff:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0113003:	74 08                	je     f011300d <sys_check_LRU_lists_free+0xb8>
f0113005:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0113008:	8b 40 10             	mov    0x10(%eax),%eax
f011300b:	eb 05                	jmp    f0113012 <sys_check_LRU_lists_free+0xbd>
f011300d:	b8 00 00 00 00       	mov    $0x0,%eax
f0113012:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0113015:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f011301b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011301e:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0113024:	85 c0                	test   %eax,%eax
f0113026:	0f 85 6e ff ff ff    	jne    f0112f9a <sys_check_LRU_lists_free+0x45>
f011302c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0113030:	0f 85 64 ff ff ff    	jne    f0112f9a <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0113036:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0113039:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f011303f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0113042:	eb 62                	jmp    f01130a6 <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0113044:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011304b:	eb 3a                	jmp    f0113087 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f011304d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0113050:	8b 00                	mov    (%eax),%eax
f0113052:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0113055:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0113058:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011305d:	89 c2                	mov    %eax,%edx
f011305f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0113062:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0113069:	8b 45 08             	mov    0x8(%ebp),%eax
f011306c:	01 c8                	add    %ecx,%eax
f011306e:	8b 00                	mov    (%eax),%eax
f0113070:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0113073:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0113076:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011307b:	39 c2                	cmp    %eax,%edx
f011307d:	75 05                	jne    f0113084 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f011307f:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0113082:	eb 0b                	jmp    f011308f <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0113084:	ff 45 e8             	incl   -0x18(%ebp)
f0113087:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011308a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011308d:	7c be                	jl     f011304d <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f011308f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0113093:	7e 05                	jle    f011309a <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0113095:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0113098:	eb 46                	jmp    f01130e0 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011309a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011309d:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f01130a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01130a6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01130aa:	74 08                	je     f01130b4 <sys_check_LRU_lists_free+0x15f>
f01130ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01130af:	8b 40 10             	mov    0x10(%eax),%eax
f01130b2:	eb 05                	jmp    f01130b9 <sys_check_LRU_lists_free+0x164>
f01130b4:	b8 00 00 00 00       	mov    $0x0,%eax
f01130b9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01130bc:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f01130c2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01130c5:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f01130cb:	85 c0                	test   %eax,%eax
f01130cd:	0f 85 71 ff ff ff    	jne    f0113044 <sys_check_LRU_lists_free+0xef>
f01130d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01130d7:	0f 85 67 ff ff ff    	jne    f0113044 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f01130dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01130e0:	c9                   	leave  
f01130e1:	c3                   	ret    

f01130e2 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f01130e2:	55                   	push   %ebp
f01130e3:	89 e5                	mov    %esp,%ebp
f01130e5:	83 ec 08             	sub    $0x8,%esp
		}
	}

	return WS_list_validation;
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
f01130e8:	83 ec 04             	sub    $0x4,%esp
f01130eb:	68 d4 c0 12 f0       	push   $0xf012c0d4
f01130f0:	68 ea 00 00 00       	push   $0xea
f01130f5:	68 8d c0 12 f0       	push   $0xf012c08d
f01130fa:	e8 1b d2 fe ff       	call   f010031a <_panic>

f01130ff <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f01130ff:	55                   	push   %ebp
f0113100:	89 e5                	mov    %esp,%ebp
f0113102:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f0113105:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f011310c:	8b 15 18 4b 5a f0    	mov    0xf05a4b18,%edx
f0113112:	8b 45 0c             	mov    0xc(%ebp),%eax
f0113115:	39 c2                	cmp    %eax,%edx
f0113117:	74 0a                	je     f0113123 <hasExpectedCommands+0x24>
		return 0;
f0113119:	b8 00 00 00 00       	mov    $0x0,%eax
f011311e:	e9 8b 00 00 00       	jmp    f01131ae <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f0113123:	a1 0c 4b 5a f0       	mov    0xf05a4b0c,%eax
f0113128:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011312b:	eb 55                	jmp    f0113182 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f011312d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0113134:	eb 2a                	jmp    f0113160 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f0113136:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0113139:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0113140:	8b 45 08             	mov    0x8(%ebp),%eax
f0113143:	01 d0                	add    %edx,%eax
f0113145:	8b 10                	mov    (%eax),%edx
f0113147:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011314a:	8b 00                	mov    (%eax),%eax
f011314c:	83 ec 08             	sub    $0x8,%esp
f011314f:	52                   	push   %edx
f0113150:	50                   	push   %eax
f0113151:	e8 c2 f3 00 00       	call   f0122518 <strcmp>
f0113156:	83 c4 10             	add    $0x10,%esp
f0113159:	85 c0                	test   %eax,%eax
f011315b:	74 0d                	je     f011316a <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f011315d:	ff 45 f0             	incl   -0x10(%ebp)
f0113160:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0113163:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0113166:	7c ce                	jl     f0113136 <hasExpectedCommands+0x37>
f0113168:	eb 01                	jmp    f011316b <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f011316a:	90                   	nop
		if (i == commandsCount)
f011316b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011316e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0113171:	75 07                	jne    f011317a <hasExpectedCommands+0x7b>
			return 0;
f0113173:	b8 00 00 00 00       	mov    $0x0,%eax
f0113178:	eb 34                	jmp    f01131ae <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f011317a:	a1 14 4b 5a f0       	mov    0xf05a4b14,%eax
f011317f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0113182:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0113186:	74 08                	je     f0113190 <hasExpectedCommands+0x91>
f0113188:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011318b:	8b 40 10             	mov    0x10(%eax),%eax
f011318e:	eb 05                	jmp    f0113195 <hasExpectedCommands+0x96>
f0113190:	b8 00 00 00 00       	mov    $0x0,%eax
f0113195:	a3 14 4b 5a f0       	mov    %eax,0xf05a4b14
f011319a:	a1 14 4b 5a f0       	mov    0xf05a4b14,%eax
f011319f:	85 c0                	test   %eax,%eax
f01131a1:	75 8a                	jne    f011312d <hasExpectedCommands+0x2e>
f01131a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01131a7:	75 84                	jne    f011312d <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f01131a9:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01131ae:	c9                   	leave  
f01131af:	c3                   	ret    

f01131b0 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f01131b0:	55                   	push   %ebp
f01131b1:	89 e5                	mov    %esp,%ebp
f01131b3:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01131b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01131bd:	eb 2e                	jmp    f01131ed <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f01131bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01131c2:	89 d0                	mov    %edx,%eax
f01131c4:	01 c0                	add    %eax,%eax
f01131c6:	01 d0                	add    %edx,%eax
f01131c8:	c1 e0 03             	shl    $0x3,%eax
f01131cb:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01131d0:	8b 00                	mov    (%eax),%eax
f01131d2:	83 ec 08             	sub    $0x8,%esp
f01131d5:	ff 75 08             	pushl  0x8(%ebp)
f01131d8:	50                   	push   %eax
f01131d9:	e8 3a f3 00 00       	call   f0122518 <strcmp>
f01131de:	83 c4 10             	add    $0x10,%esp
f01131e1:	85 c0                	test   %eax,%eax
f01131e3:	75 05                	jne    f01131ea <getIndexOfCommand+0x3a>
			return i;
f01131e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01131e8:	eb 14                	jmp    f01131fe <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01131ea:	ff 45 f4             	incl   -0xc(%ebp)
f01131ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01131f0:	a1 48 09 18 f0       	mov    0xf0180948,%eax
f01131f5:	39 c2                	cmp    %eax,%edx
f01131f7:	72 c6                	jb     f01131bf <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f01131f9:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f01131fe:	c9                   	leave  
f01131ff:	c3                   	ret    

f0113200 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0113200:	55                   	push   %ebp
f0113201:	89 e5                	mov    %esp,%ebp
f0113203:	57                   	push   %edi
f0113204:	56                   	push   %esi
f0113205:	53                   	push   %ebx
f0113206:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f011320c:	83 ec 0c             	sub    $0xc,%esp
f011320f:	68 20 c1 12 f0       	push   $0xf012c120
f0113214:	e8 53 dd fe ff       	call   f0100f6c <cprintf>
f0113219:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f011321c:	83 ec 0c             	sub    $0xc,%esp
f011321f:	68 44 c1 12 f0       	push   $0xf012c144
f0113224:	e8 43 dd fe ff       	call   f0100f6c <cprintf>
f0113229:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f011322c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f0113233:	c7 45 8c 5f c1 12 f0 	movl   $0xf012c15f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f011323a:	83 ec 08             	sub    $0x8,%esp
f011323d:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0113240:	50                   	push   %eax
f0113241:	6a 01                	push   $0x1
f0113243:	e8 69 ef fe ff       	call   f01021b1 <process_command>
f0113248:	83 c4 10             	add    $0x10,%esp
f011324b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f011324e:	83 ec 0c             	sub    $0xc,%esp
f0113251:	68 6c c1 12 f0       	push   $0xf012c16c
f0113256:	e8 11 dd fe ff       	call   f0100f6c <cprintf>
f011325b:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f011325e:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113261:	83 ec 0c             	sub    $0xc,%esp
f0113264:	50                   	push   %eax
f0113265:	e8 46 ff ff ff       	call   f01131b0 <getIndexOfCommand>
f011326a:	83 c4 10             	add    $0x10,%esp
f011326d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0113270:	75 0f                	jne    f0113281 <TestAutoCompleteCommand+0x81>
f0113272:	a1 0c 4b 5a f0       	mov    0xf05a4b0c,%eax
f0113277:	85 c0                	test   %eax,%eax
f0113279:	75 06                	jne    f0113281 <TestAutoCompleteCommand+0x81>
		eval += 15;
f011327b:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011327f:	eb 10                	jmp    f0113291 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0113281:	83 ec 0c             	sub    $0xc,%esp
f0113284:	68 9c c1 12 f0       	push   $0xf012c19c
f0113289:	e8 de dc fe ff       	call   f0100f6c <cprintf>
f011328e:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f0113291:	83 ec 0c             	sub    $0xc,%esp
f0113294:	68 ec c1 12 f0       	push   $0xf012c1ec
f0113299:	e8 ce dc fe ff       	call   f0100f6c <cprintf>
f011329e:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f01132a1:	c7 45 88 12 c2 12 f0 	movl   $0xf012c212,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f01132a8:	83 ec 08             	sub    $0x8,%esp
f01132ab:	8d 45 88             	lea    -0x78(%ebp),%eax
f01132ae:	50                   	push   %eax
f01132af:	6a 01                	push   $0x1
f01132b1:	e8 fb ee fe ff       	call   f01021b1 <process_command>
f01132b6:	83 c4 10             	add    $0x10,%esp
f01132b9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f01132bc:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01132c0:	75 30                	jne    f01132f2 <TestAutoCompleteCommand+0xf2>
f01132c2:	8d 45 90             	lea    -0x70(%ebp),%eax
f01132c5:	bb f0 c5 12 f0       	mov    $0xf012c5f0,%ebx
f01132ca:	ba 03 00 00 00       	mov    $0x3,%edx
f01132cf:	89 c7                	mov    %eax,%edi
f01132d1:	89 de                	mov    %ebx,%esi
f01132d3:	89 d1                	mov    %edx,%ecx
f01132d5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01132d7:	83 ec 08             	sub    $0x8,%esp
f01132da:	6a 03                	push   $0x3
f01132dc:	8d 45 90             	lea    -0x70(%ebp),%eax
f01132df:	50                   	push   %eax
f01132e0:	e8 1a fe ff ff       	call   f01130ff <hasExpectedCommands>
f01132e5:	83 c4 10             	add    $0x10,%esp
f01132e8:	85 c0                	test   %eax,%eax
f01132ea:	74 06                	je     f01132f2 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f01132ec:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01132f0:	eb 10                	jmp    f0113302 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01132f2:	83 ec 0c             	sub    $0xc,%esp
f01132f5:	68 18 c2 12 f0       	push   $0xf012c218
f01132fa:	e8 6d dc fe ff       	call   f0100f6c <cprintf>
f01132ff:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0113302:	83 ec 0c             	sub    $0xc,%esp
f0113305:	68 68 c2 12 f0       	push   $0xf012c268
f011330a:	e8 5d dc fe ff       	call   f0100f6c <cprintf>
f011330f:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f0113312:	c7 45 84 8d c2 12 f0 	movl   $0xf012c28d,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f0113319:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011331c:	83 ec 04             	sub    $0x4,%esp
f011331f:	50                   	push   %eax
f0113320:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0113323:	50                   	push   %eax
f0113324:	68 90 c2 12 f0       	push   $0xf012c290
f0113329:	e8 3e dc fe ff       	call   f0100f6c <cprintf>
f011332e:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f0113331:	83 ec 08             	sub    $0x8,%esp
f0113334:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0113337:	50                   	push   %eax
f0113338:	6a 01                	push   $0x1
f011333a:	e8 72 ee fe ff       	call   f01021b1 <process_command>
f011333f:	83 c4 10             	add    $0x10,%esp
f0113342:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f0113345:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0113349:	75 1b                	jne    f0113366 <TestAutoCompleteCommand+0x166>
f011334b:	83 ec 08             	sub    $0x8,%esp
f011334e:	6a 01                	push   $0x1
f0113350:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0113353:	50                   	push   %eax
f0113354:	e8 a6 fd ff ff       	call   f01130ff <hasExpectedCommands>
f0113359:	83 c4 10             	add    $0x10,%esp
f011335c:	85 c0                	test   %eax,%eax
f011335e:	74 06                	je     f0113366 <TestAutoCompleteCommand+0x166>
		eval += 15;
f0113360:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0113364:	eb 10                	jmp    f0113376 <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0113366:	83 ec 0c             	sub    $0xc,%esp
f0113369:	68 b0 c2 12 f0       	push   $0xf012c2b0
f011336e:	e8 f9 db fe ff       	call   f0100f6c <cprintf>
f0113373:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f0113376:	83 ec 0c             	sub    $0xc,%esp
f0113379:	68 08 c3 12 f0       	push   $0xf012c308
f011337e:	e8 e9 db fe ff       	call   f0100f6c <cprintf>
f0113383:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f0113386:	c7 45 80 2e c3 12 f0 	movl   $0xf012c32e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f011338d:	83 ec 08             	sub    $0x8,%esp
f0113390:	8d 45 80             	lea    -0x80(%ebp),%eax
f0113393:	50                   	push   %eax
f0113394:	6a 01                	push   $0x1
f0113396:	e8 16 ee fe ff       	call   f01021b1 <process_command>
f011339b:	83 c4 10             	add    $0x10,%esp
f011339e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f01133a1:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f01133a5:	75 0f                	jne    f01133b6 <TestAutoCompleteCommand+0x1b6>
f01133a7:	a1 18 4b 5a f0       	mov    0xf05a4b18,%eax
f01133ac:	85 c0                	test   %eax,%eax
f01133ae:	75 06                	jne    f01133b6 <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f01133b0:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01133b4:	eb 10                	jmp    f01133c6 <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01133b6:	83 ec 0c             	sub    $0xc,%esp
f01133b9:	68 34 c3 12 f0       	push   $0xf012c334
f01133be:	e8 a9 db fe ff       	call   f0100f6c <cprintf>
f01133c3:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f01133c6:	83 ec 0c             	sub    $0xc,%esp
f01133c9:	68 84 c3 12 f0       	push   $0xf012c384
f01133ce:	e8 99 db fe ff       	call   f0100f6c <cprintf>
f01133d3:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f01133d6:	c7 85 7c ff ff ff a9 	movl   $0xf012c3a9,-0x84(%ebp)
f01133dd:	c3 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f01133e0:	83 ec 08             	sub    $0x8,%esp
f01133e3:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f01133e9:	50                   	push   %eax
f01133ea:	6a 01                	push   $0x1
f01133ec:	e8 c0 ed fe ff       	call   f01021b1 <process_command>
f01133f1:	83 c4 10             	add    $0x10,%esp
f01133f4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f01133f7:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01133fb:	75 30                	jne    f011342d <TestAutoCompleteCommand+0x22d>
f01133fd:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0113400:	bb 80 c6 12 f0       	mov    $0xf012c680,%ebx
f0113405:	ba 0c 00 00 00       	mov    $0xc,%edx
f011340a:	89 c7                	mov    %eax,%edi
f011340c:	89 de                	mov    %ebx,%esi
f011340e:	89 d1                	mov    %edx,%ecx
f0113410:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0113412:	83 ec 08             	sub    $0x8,%esp
f0113415:	6a 0c                	push   $0xc
f0113417:	8d 45 9c             	lea    -0x64(%ebp),%eax
f011341a:	50                   	push   %eax
f011341b:	e8 df fc ff ff       	call   f01130ff <hasExpectedCommands>
f0113420:	83 c4 10             	add    $0x10,%esp
f0113423:	85 c0                	test   %eax,%eax
f0113425:	74 06                	je     f011342d <TestAutoCompleteCommand+0x22d>
		eval += 10;
f0113427:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f011342b:	eb 10                	jmp    f011343d <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f011342d:	83 ec 0c             	sub    $0xc,%esp
f0113430:	68 ac c3 12 f0       	push   $0xf012c3ac
f0113435:	e8 32 db fe ff       	call   f0100f6c <cprintf>
f011343a:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f011343d:	83 ec 0c             	sub    $0xc,%esp
f0113440:	68 04 c4 12 f0       	push   $0xf012c404
f0113445:	e8 22 db fe ff       	call   f0100f6c <cprintf>
f011344a:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f011344d:	c7 85 78 ff ff ff 29 	movl   $0xf012c429,-0x88(%ebp)
f0113454:	c4 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f0113457:	83 ec 08             	sub    $0x8,%esp
f011345a:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0113460:	50                   	push   %eax
f0113461:	6a 01                	push   $0x1
f0113463:	e8 49 ed fe ff       	call   f01021b1 <process_command>
f0113468:	83 c4 10             	add    $0x10,%esp
f011346b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f011346e:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0113472:	75 30                	jne    f01134a4 <TestAutoCompleteCommand+0x2a4>
f0113474:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0113477:	bb c8 c6 12 f0       	mov    $0xf012c6c8,%ebx
f011347c:	ba 05 00 00 00       	mov    $0x5,%edx
f0113481:	89 c7                	mov    %eax,%edi
f0113483:	89 de                	mov    %ebx,%esi
f0113485:	89 d1                	mov    %edx,%ecx
f0113487:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0113489:	83 ec 08             	sub    $0x8,%esp
f011348c:	6a 05                	push   $0x5
f011348e:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0113491:	50                   	push   %eax
f0113492:	e8 68 fc ff ff       	call   f01130ff <hasExpectedCommands>
f0113497:	83 c4 10             	add    $0x10,%esp
f011349a:	85 c0                	test   %eax,%eax
f011349c:	74 06                	je     f01134a4 <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f011349e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01134a2:	eb 10                	jmp    f01134b4 <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f01134a4:	83 ec 0c             	sub    $0xc,%esp
f01134a7:	68 2c c4 12 f0       	push   $0xf012c42c
f01134ac:	e8 bb da fe ff       	call   f0100f6c <cprintf>
f01134b1:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f01134b4:	83 ec 0c             	sub    $0xc,%esp
f01134b7:	68 84 c4 12 f0       	push   $0xf012c484
f01134bc:	e8 ab da fe ff       	call   f0100f6c <cprintf>
f01134c1:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f01134c4:	c7 85 70 ff ff ff b0 	movl   $0xf012c4b0,-0x90(%ebp)
f01134cb:	c4 12 f0 
f01134ce:	c7 85 74 ff ff ff b5 	movl   $0xf012c4b5,-0x8c(%ebp)
f01134d5:	c4 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f01134d8:	83 ec 08             	sub    $0x8,%esp
f01134db:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f01134e1:	50                   	push   %eax
f01134e2:	6a 02                	push   $0x2
f01134e4:	e8 c8 ec fe ff       	call   f01021b1 <process_command>
f01134e9:	83 c4 10             	add    $0x10,%esp
f01134ec:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f01134ef:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01134f5:	83 ec 0c             	sub    $0xc,%esp
f01134f8:	50                   	push   %eax
f01134f9:	e8 b2 fc ff ff       	call   f01131b0 <getIndexOfCommand>
f01134fe:	83 c4 10             	add    $0x10,%esp
f0113501:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0113504:	75 0f                	jne    f0113515 <TestAutoCompleteCommand+0x315>
f0113506:	a1 0c 4b 5a f0       	mov    0xf05a4b0c,%eax
f011350b:	85 c0                	test   %eax,%eax
f011350d:	75 06                	jne    f0113515 <TestAutoCompleteCommand+0x315>
		eval += 10;
f011350f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0113513:	eb 10                	jmp    f0113525 <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0113515:	83 ec 0c             	sub    $0xc,%esp
f0113518:	68 bc c4 12 f0       	push   $0xf012c4bc
f011351d:	e8 4a da fe ff       	call   f0100f6c <cprintf>
f0113522:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f0113525:	83 ec 0c             	sub    $0xc,%esp
f0113528:	68 0c c5 12 f0       	push   $0xf012c50c
f011352d:	e8 3a da fe ff       	call   f0100f6c <cprintf>
f0113532:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f0113535:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f011353b:	bb f0 c6 12 f0       	mov    $0xf012c6f0,%ebx
f0113540:	ba 03 00 00 00       	mov    $0x3,%edx
f0113545:	89 c7                	mov    %eax,%edi
f0113547:	89 de                	mov    %ebx,%esi
f0113549:	89 d1                	mov    %edx,%ecx
f011354b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f011354d:	83 ec 08             	sub    $0x8,%esp
f0113550:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0113556:	50                   	push   %eax
f0113557:	6a 03                	push   $0x3
f0113559:	e8 53 ec fe ff       	call   f01021b1 <process_command>
f011355e:	83 c4 10             	add    $0x10,%esp
f0113561:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0113564:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011356a:	83 ec 0c             	sub    $0xc,%esp
f011356d:	50                   	push   %eax
f011356e:	e8 3d fc ff ff       	call   f01131b0 <getIndexOfCommand>
f0113573:	83 c4 10             	add    $0x10,%esp
f0113576:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0113579:	75 0f                	jne    f011358a <TestAutoCompleteCommand+0x38a>
f011357b:	a1 0c 4b 5a f0       	mov    0xf05a4b0c,%eax
f0113580:	85 c0                	test   %eax,%eax
f0113582:	75 06                	jne    f011358a <TestAutoCompleteCommand+0x38a>
		eval += 10;
f0113584:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0113588:	eb 10                	jmp    f011359a <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011358a:	83 ec 0c             	sub    $0xc,%esp
f011358d:	68 40 c5 12 f0       	push   $0xf012c540
f0113592:	e8 d5 d9 fe ff       	call   f0100f6c <cprintf>
f0113597:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f011359a:	83 ec 08             	sub    $0x8,%esp
f011359d:	ff 75 e4             	pushl  -0x1c(%ebp)
f01135a0:	68 90 c5 12 f0       	push   $0xf012c590
f01135a5:	e8 c2 d9 fe ff       	call   f0100f6c <cprintf>
f01135aa:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f01135ad:	83 ec 0c             	sub    $0xc,%esp
f01135b0:	68 c0 c5 12 f0       	push   $0xf012c5c0
f01135b5:	e8 b2 d9 fe ff       	call   f0100f6c <cprintf>
f01135ba:	83 c4 10             	add    $0x10,%esp

	return 0;
f01135bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01135c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01135c5:	5b                   	pop    %ebx
f01135c6:	5e                   	pop    %esi
f01135c7:	5f                   	pop    %edi
f01135c8:	5d                   	pop    %ebp
f01135c9:	c3                   	ret    

f01135ca <test_str2lower_function>:

int test_str2lower_function()
{
f01135ca:	55                   	push   %ebp
f01135cb:	89 e5                	mov    %esp,%ebp
f01135cd:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f01135d3:	83 ec 0c             	sub    $0xc,%esp
f01135d6:	68 fc c6 12 f0       	push   $0xf012c6fc
f01135db:	e8 8c d9 fe ff       	call   f0100f6c <cprintf>
f01135e0:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f01135e3:	83 ec 0c             	sub    $0xc,%esp
f01135e6:	68 1d c7 12 f0       	push   $0xf012c71d
f01135eb:	e8 7c d9 fe ff       	call   f0100f6c <cprintf>
f01135f0:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f01135f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f01135fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0113601:	c7 45 ec 37 c7 12 f0 	movl   $0xf012c737,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0113608:	83 ec 08             	sub    $0x8,%esp
f011360b:	ff 75 ec             	pushl  -0x14(%ebp)
f011360e:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0113614:	50                   	push   %eax
f0113615:	e8 db f4 00 00       	call   f0122af5 <str2lower>
f011361a:	83 c4 10             	add    $0x10,%esp
f011361d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0113620:	83 ec 0c             	sub    $0xc,%esp
f0113623:	ff 75 e8             	pushl  -0x18(%ebp)
f0113626:	e8 e1 ed 00 00       	call   f012240c <strlen>
f011362b:	83 c4 10             	add    $0x10,%esp
f011362e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0113631:	83 ec 08             	sub    $0x8,%esp
f0113634:	68 42 c7 12 f0       	push   $0xf012c742
f0113639:	ff 75 e8             	pushl  -0x18(%ebp)
f011363c:	e8 d7 ee 00 00       	call   f0122518 <strcmp>
f0113641:	83 c4 10             	add    $0x10,%esp
f0113644:	85 c0                	test   %eax,%eax
f0113646:	75 13                	jne    f011365b <test_str2lower_function+0x91>
f0113648:	83 ec 0c             	sub    $0xc,%esp
f011364b:	ff 75 ec             	pushl  -0x14(%ebp)
f011364e:	e8 b9 ed 00 00       	call   f012240c <strlen>
f0113653:	83 c4 10             	add    $0x10,%esp
f0113656:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0113659:	74 15                	je     f0113670 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f011365b:	83 ec 08             	sub    $0x8,%esp
f011365e:	ff 75 e8             	pushl  -0x18(%ebp)
f0113661:	68 50 c7 12 f0       	push   $0xf012c750
f0113666:	e8 01 d9 fe ff       	call   f0100f6c <cprintf>
f011366b:	83 c4 10             	add    $0x10,%esp
f011366e:	eb 04                	jmp    f0113674 <test_str2lower_function+0xaa>
	else
		eval += 10;
f0113670:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0113674:	c7 45 e0 b2 c7 12 f0 	movl   $0xf012c7b2,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f011367b:	83 ec 08             	sub    $0x8,%esp
f011367e:	ff 75 e0             	pushl  -0x20(%ebp)
f0113681:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0113687:	50                   	push   %eax
f0113688:	e8 68 f4 00 00       	call   f0122af5 <str2lower>
f011368d:	83 c4 10             	add    $0x10,%esp
f0113690:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0113693:	83 ec 0c             	sub    $0xc,%esp
f0113696:	ff 75 e8             	pushl  -0x18(%ebp)
f0113699:	e8 6e ed 00 00       	call   f012240c <strlen>
f011369e:	83 c4 10             	add    $0x10,%esp
f01136a1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f01136a4:	83 ec 08             	sub    $0x8,%esp
f01136a7:	68 b2 c7 12 f0       	push   $0xf012c7b2
f01136ac:	ff 75 e8             	pushl  -0x18(%ebp)
f01136af:	e8 64 ee 00 00       	call   f0122518 <strcmp>
f01136b4:	83 c4 10             	add    $0x10,%esp
f01136b7:	85 c0                	test   %eax,%eax
f01136b9:	75 13                	jne    f01136ce <test_str2lower_function+0x104>
f01136bb:	83 ec 0c             	sub    $0xc,%esp
f01136be:	ff 75 e0             	pushl  -0x20(%ebp)
f01136c1:	e8 46 ed 00 00       	call   f012240c <strlen>
f01136c6:	83 c4 10             	add    $0x10,%esp
f01136c9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01136cc:	74 15                	je     f01136e3 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f01136ce:	83 ec 08             	sub    $0x8,%esp
f01136d1:	ff 75 e8             	pushl  -0x18(%ebp)
f01136d4:	68 b4 c7 12 f0       	push   $0xf012c7b4
f01136d9:	e8 8e d8 fe ff       	call   f0100f6c <cprintf>
f01136de:	83 c4 10             	add    $0x10,%esp
f01136e1:	eb 04                	jmp    f01136e7 <test_str2lower_function+0x11d>
	else
		eval += 10;
f01136e3:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f01136e7:	c7 45 dc 0c c8 12 f0 	movl   $0xf012c80c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f01136ee:	83 ec 08             	sub    $0x8,%esp
f01136f1:	ff 75 dc             	pushl  -0x24(%ebp)
f01136f4:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f01136fa:	50                   	push   %eax
f01136fb:	e8 f5 f3 00 00       	call   f0122af5 <str2lower>
f0113700:	83 c4 10             	add    $0x10,%esp
f0113703:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0113706:	83 ec 0c             	sub    $0xc,%esp
f0113709:	ff 75 e8             	pushl  -0x18(%ebp)
f011370c:	e8 fb ec 00 00       	call   f012240c <strlen>
f0113711:	83 c4 10             	add    $0x10,%esp
f0113714:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0113717:	83 ec 08             	sub    $0x8,%esp
f011371a:	68 0c c8 12 f0       	push   $0xf012c80c
f011371f:	ff 75 e8             	pushl  -0x18(%ebp)
f0113722:	e8 f1 ed 00 00       	call   f0122518 <strcmp>
f0113727:	83 c4 10             	add    $0x10,%esp
f011372a:	85 c0                	test   %eax,%eax
f011372c:	75 13                	jne    f0113741 <test_str2lower_function+0x177>
f011372e:	83 ec 0c             	sub    $0xc,%esp
f0113731:	ff 75 dc             	pushl  -0x24(%ebp)
f0113734:	e8 d3 ec 00 00       	call   f012240c <strlen>
f0113739:	83 c4 10             	add    $0x10,%esp
f011373c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011373f:	74 15                	je     f0113756 <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0113741:	83 ec 08             	sub    $0x8,%esp
f0113744:	ff 75 e8             	pushl  -0x18(%ebp)
f0113747:	68 18 c8 12 f0       	push   $0xf012c818
f011374c:	e8 1b d8 fe ff       	call   f0100f6c <cprintf>
f0113751:	83 c4 10             	add    $0x10,%esp
f0113754:	eb 04                	jmp    f011375a <test_str2lower_function+0x190>
	else
		eval += 15;
f0113756:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f011375a:	c7 45 d8 7b c8 12 f0 	movl   $0xf012c87b,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0113761:	83 ec 08             	sub    $0x8,%esp
f0113764:	ff 75 d8             	pushl  -0x28(%ebp)
f0113767:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f011376d:	50                   	push   %eax
f011376e:	e8 82 f3 00 00       	call   f0122af5 <str2lower>
f0113773:	83 c4 10             	add    $0x10,%esp
f0113776:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0113779:	83 ec 0c             	sub    $0xc,%esp
f011377c:	ff 75 e8             	pushl  -0x18(%ebp)
f011377f:	e8 88 ec 00 00       	call   f012240c <strlen>
f0113784:	83 c4 10             	add    $0x10,%esp
f0113787:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f011378a:	83 ec 08             	sub    $0x8,%esp
f011378d:	68 7b c8 12 f0       	push   $0xf012c87b
f0113792:	ff 75 e8             	pushl  -0x18(%ebp)
f0113795:	e8 7e ed 00 00       	call   f0122518 <strcmp>
f011379a:	83 c4 10             	add    $0x10,%esp
f011379d:	85 c0                	test   %eax,%eax
f011379f:	75 13                	jne    f01137b4 <test_str2lower_function+0x1ea>
f01137a1:	83 ec 0c             	sub    $0xc,%esp
f01137a4:	ff 75 d8             	pushl  -0x28(%ebp)
f01137a7:	e8 60 ec 00 00       	call   f012240c <strlen>
f01137ac:	83 c4 10             	add    $0x10,%esp
f01137af:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01137b2:	74 15                	je     f01137c9 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f01137b4:	83 ec 08             	sub    $0x8,%esp
f01137b7:	ff 75 e8             	pushl  -0x18(%ebp)
f01137ba:	68 88 c8 12 f0       	push   $0xf012c888
f01137bf:	e8 a8 d7 fe ff       	call   f0100f6c <cprintf>
f01137c4:	83 c4 10             	add    $0x10,%esp
f01137c7:	eb 04                	jmp    f01137cd <test_str2lower_function+0x203>
	else
		eval += 15;
f01137c9:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f01137cd:	c7 45 d4 ea c8 12 f0 	movl   $0xf012c8ea,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f01137d4:	83 ec 08             	sub    $0x8,%esp
f01137d7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01137da:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f01137e0:	50                   	push   %eax
f01137e1:	e8 0f f3 00 00       	call   f0122af5 <str2lower>
f01137e6:	83 c4 10             	add    $0x10,%esp
f01137e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01137ec:	83 ec 0c             	sub    $0xc,%esp
f01137ef:	ff 75 e8             	pushl  -0x18(%ebp)
f01137f2:	e8 15 ec 00 00       	call   f012240c <strlen>
f01137f7:	83 c4 10             	add    $0x10,%esp
f01137fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f01137fd:	83 ec 08             	sub    $0x8,%esp
f0113800:	68 00 c9 12 f0       	push   $0xf012c900
f0113805:	ff 75 e8             	pushl  -0x18(%ebp)
f0113808:	e8 0b ed 00 00       	call   f0122518 <strcmp>
f011380d:	83 c4 10             	add    $0x10,%esp
f0113810:	85 c0                	test   %eax,%eax
f0113812:	75 13                	jne    f0113827 <test_str2lower_function+0x25d>
f0113814:	83 ec 0c             	sub    $0xc,%esp
f0113817:	ff 75 d4             	pushl  -0x2c(%ebp)
f011381a:	e8 ed eb 00 00       	call   f012240c <strlen>
f011381f:	83 c4 10             	add    $0x10,%esp
f0113822:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0113825:	74 15                	je     f011383c <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0113827:	83 ec 08             	sub    $0x8,%esp
f011382a:	ff 75 e8             	pushl  -0x18(%ebp)
f011382d:	68 18 c9 12 f0       	push   $0xf012c918
f0113832:	e8 35 d7 fe ff       	call   f0100f6c <cprintf>
f0113837:	83 c4 10             	add    $0x10,%esp
f011383a:	eb 04                	jmp    f0113840 <test_str2lower_function+0x276>
	else
		eval += 15;
f011383c:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0113840:	c7 45 d0 85 c9 12 f0 	movl   $0xf012c985,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0113847:	83 ec 08             	sub    $0x8,%esp
f011384a:	ff 75 d0             	pushl  -0x30(%ebp)
f011384d:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0113853:	50                   	push   %eax
f0113854:	e8 9c f2 00 00       	call   f0122af5 <str2lower>
f0113859:	83 c4 10             	add    $0x10,%esp
f011385c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011385f:	83 ec 0c             	sub    $0xc,%esp
f0113862:	ff 75 e8             	pushl  -0x18(%ebp)
f0113865:	e8 a2 eb 00 00       	call   f012240c <strlen>
f011386a:	83 c4 10             	add    $0x10,%esp
f011386d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0113870:	83 ec 08             	sub    $0x8,%esp
f0113873:	68 91 c9 12 f0       	push   $0xf012c991
f0113878:	ff 75 e8             	pushl  -0x18(%ebp)
f011387b:	e8 98 ec 00 00       	call   f0122518 <strcmp>
f0113880:	83 c4 10             	add    $0x10,%esp
f0113883:	85 c0                	test   %eax,%eax
f0113885:	75 13                	jne    f011389a <test_str2lower_function+0x2d0>
f0113887:	83 ec 0c             	sub    $0xc,%esp
f011388a:	ff 75 d0             	pushl  -0x30(%ebp)
f011388d:	e8 7a eb 00 00       	call   f012240c <strlen>
f0113892:	83 c4 10             	add    $0x10,%esp
f0113895:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0113898:	74 15                	je     f01138af <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f011389a:	83 ec 08             	sub    $0x8,%esp
f011389d:	ff 75 e8             	pushl  -0x18(%ebp)
f01138a0:	68 a0 c9 12 f0       	push   $0xf012c9a0
f01138a5:	e8 c2 d6 fe ff       	call   f0100f6c <cprintf>
f01138aa:	83 c4 10             	add    $0x10,%esp
f01138ad:	eb 04                	jmp    f01138b3 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f01138af:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f01138b3:	c7 45 cc 03 ca 12 f0 	movl   $0xf012ca03,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f01138ba:	83 ec 08             	sub    $0x8,%esp
f01138bd:	ff 75 cc             	pushl  -0x34(%ebp)
f01138c0:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f01138c6:	50                   	push   %eax
f01138c7:	e8 29 f2 00 00       	call   f0122af5 <str2lower>
f01138cc:	83 c4 10             	add    $0x10,%esp
f01138cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01138d2:	83 ec 0c             	sub    $0xc,%esp
f01138d5:	ff 75 e8             	pushl  -0x18(%ebp)
f01138d8:	e8 2f eb 00 00       	call   f012240c <strlen>
f01138dd:	83 c4 10             	add    $0x10,%esp
f01138e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f01138e3:	83 ec 08             	sub    $0x8,%esp
f01138e6:	68 1e ca 12 f0       	push   $0xf012ca1e
f01138eb:	ff 75 e8             	pushl  -0x18(%ebp)
f01138ee:	e8 25 ec 00 00       	call   f0122518 <strcmp>
f01138f3:	83 c4 10             	add    $0x10,%esp
f01138f6:	85 c0                	test   %eax,%eax
f01138f8:	75 13                	jne    f011390d <test_str2lower_function+0x343>
f01138fa:	83 ec 0c             	sub    $0xc,%esp
f01138fd:	ff 75 cc             	pushl  -0x34(%ebp)
f0113900:	e8 07 eb 00 00       	call   f012240c <strlen>
f0113905:	83 c4 10             	add    $0x10,%esp
f0113908:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011390b:	74 15                	je     f0113922 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f011390d:	83 ec 08             	sub    $0x8,%esp
f0113910:	ff 75 e8             	pushl  -0x18(%ebp)
f0113913:	68 3c ca 12 f0       	push   $0xf012ca3c
f0113918:	e8 4f d6 fe ff       	call   f0100f6c <cprintf>
f011391d:	83 c4 10             	add    $0x10,%esp
f0113920:	eb 04                	jmp    f0113926 <test_str2lower_function+0x35c>
	else
		eval += 20;
f0113922:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0113926:	83 ec 08             	sub    $0x8,%esp
f0113929:	ff 75 f4             	pushl  -0xc(%ebp)
f011392c:	68 b0 ca 12 f0       	push   $0xf012cab0
f0113931:	e8 36 d6 fe ff       	call   f0100f6c <cprintf>
f0113936:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0113939:	83 ec 0c             	sub    $0xc,%esp
f011393c:	68 c0 c5 12 f0       	push   $0xf012c5c0
f0113941:	e8 26 d6 fe ff       	call   f0100f6c <cprintf>
f0113946:	83 c4 10             	add    $0x10,%esp
	return 0;
f0113949:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011394e:	c9                   	leave  
f011394f:	c3                   	ret    

f0113950 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0113950:	55                   	push   %ebp
f0113951:	89 e5                	mov    %esp,%ebp
f0113953:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0113956:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f011395d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0113964:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011396b:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113970:	ff 75 ec             	pushl  -0x14(%ebp)
f0113973:	ff 75 f0             	pushl  -0x10(%ebp)
f0113976:	ff 75 f4             	pushl  -0xc(%ebp)
f0113979:	50                   	push   %eax
f011397a:	e8 7e 51 ff ff       	call   f0108afd <pt_set_page_permissions>
f011397f:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113982:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113987:	ff 75 ec             	pushl  -0x14(%ebp)
f011398a:	ff 75 f0             	pushl  -0x10(%ebp)
f011398d:	ff 75 f4             	pushl  -0xc(%ebp)
f0113990:	50                   	push   %eax
f0113991:	e8 a0 4d 00 00       	call   f0118736 <CP>
f0113996:	83 c4 10             	add    $0x10,%esp
f0113999:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011399c:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01139a0:	74 17                	je     f01139b9 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f01139a2:	83 ec 04             	sub    $0x4,%esp
f01139a5:	68 e0 ca 12 f0       	push   $0xf012cae0
f01139aa:	68 23 01 00 00       	push   $0x123
f01139af:	68 02 cb 12 f0       	push   $0xf012cb02
f01139b4:	e8 61 c9 fe ff       	call   f010031a <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f01139b9:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f01139c0:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f01139c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01139ce:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f01139d3:	ff 75 ec             	pushl  -0x14(%ebp)
f01139d6:	ff 75 f0             	pushl  -0x10(%ebp)
f01139d9:	ff 75 f4             	pushl  -0xc(%ebp)
f01139dc:	50                   	push   %eax
f01139dd:	e8 1b 51 ff ff       	call   f0108afd <pt_set_page_permissions>
f01139e2:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01139e5:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f01139ea:	ff 75 ec             	pushl  -0x14(%ebp)
f01139ed:	ff 75 f0             	pushl  -0x10(%ebp)
f01139f0:	ff 75 f4             	pushl  -0xc(%ebp)
f01139f3:	50                   	push   %eax
f01139f4:	e8 3d 4d 00 00       	call   f0118736 <CP>
f01139f9:	83 c4 10             	add    $0x10,%esp
f01139fc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01139ff:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0113a03:	74 17                	je     f0113a1c <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0113a05:	83 ec 04             	sub    $0x4,%esp
f0113a08:	68 20 cb 12 f0       	push   $0xf012cb20
f0113a0d:	68 2f 01 00 00       	push   $0x12f
f0113a12:	68 02 cb 12 f0       	push   $0xf012cb02
f0113a17:	e8 fe c8 fe ff       	call   f010031a <_panic>
	}

	va = 0xEF800000;
f0113a1c:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0113a23:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0113a2a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113a31:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113a36:	ff 75 ec             	pushl  -0x14(%ebp)
f0113a39:	ff 75 f0             	pushl  -0x10(%ebp)
f0113a3c:	ff 75 f4             	pushl  -0xc(%ebp)
f0113a3f:	50                   	push   %eax
f0113a40:	e8 b8 50 ff ff       	call   f0108afd <pt_set_page_permissions>
f0113a45:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113a48:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113a4d:	ff 75 ec             	pushl  -0x14(%ebp)
f0113a50:	ff 75 f0             	pushl  -0x10(%ebp)
f0113a53:	ff 75 f4             	pushl  -0xc(%ebp)
f0113a56:	50                   	push   %eax
f0113a57:	e8 da 4c 00 00       	call   f0118736 <CP>
f0113a5c:	83 c4 10             	add    $0x10,%esp
f0113a5f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0113a62:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0113a66:	74 17                	je     f0113a7f <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0113a68:	83 ec 04             	sub    $0x4,%esp
f0113a6b:	68 44 cb 12 f0       	push   $0xf012cb44
f0113a70:	68 3a 01 00 00       	push   $0x13a
f0113a75:	68 02 cb 12 f0       	push   $0xf012cb02
f0113a7a:	e8 9b c8 fe ff       	call   f010031a <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0113a7f:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0113a86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0113a8d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113a94:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113a99:	ff 75 ec             	pushl  -0x14(%ebp)
f0113a9c:	ff 75 f0             	pushl  -0x10(%ebp)
f0113a9f:	ff 75 f4             	pushl  -0xc(%ebp)
f0113aa2:	50                   	push   %eax
f0113aa3:	e8 55 50 ff ff       	call   f0108afd <pt_set_page_permissions>
f0113aa8:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113aab:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113ab0:	ff 75 ec             	pushl  -0x14(%ebp)
f0113ab3:	ff 75 f0             	pushl  -0x10(%ebp)
f0113ab6:	ff 75 f4             	pushl  -0xc(%ebp)
f0113ab9:	50                   	push   %eax
f0113aba:	e8 77 4c 00 00       	call   f0118736 <CP>
f0113abf:	83 c4 10             	add    $0x10,%esp
f0113ac2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0113ac5:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0113ac9:	74 17                	je     f0113ae2 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0113acb:	83 ec 04             	sub    $0x4,%esp
f0113ace:	68 68 cb 12 f0       	push   $0xf012cb68
f0113ad3:	68 46 01 00 00       	push   $0x146
f0113ad8:	68 02 cb 12 f0       	push   $0xf012cb02
f0113add:	e8 38 c8 fe ff       	call   f010031a <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0113ae2:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0113ae9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0113af0:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113af7:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113afc:	ff 75 ec             	pushl  -0x14(%ebp)
f0113aff:	ff 75 f0             	pushl  -0x10(%ebp)
f0113b02:	ff 75 f4             	pushl  -0xc(%ebp)
f0113b05:	50                   	push   %eax
f0113b06:	e8 f2 4f ff ff       	call   f0108afd <pt_set_page_permissions>
f0113b0b:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113b0e:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113b13:	ff 75 ec             	pushl  -0x14(%ebp)
f0113b16:	ff 75 f0             	pushl  -0x10(%ebp)
f0113b19:	ff 75 f4             	pushl  -0xc(%ebp)
f0113b1c:	50                   	push   %eax
f0113b1d:	e8 14 4c 00 00       	call   f0118736 <CP>
f0113b22:	83 c4 10             	add    $0x10,%esp
f0113b25:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0113b28:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0113b2c:	74 17                	je     f0113b45 <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0113b2e:	83 ec 04             	sub    $0x4,%esp
f0113b31:	68 8c cb 12 f0       	push   $0xf012cb8c
f0113b36:	68 52 01 00 00       	push   $0x152
f0113b3b:	68 02 cb 12 f0       	push   $0xf012cb02
f0113b40:	e8 d5 c7 fe ff       	call   f010031a <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0113b45:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0113b4c:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0113b53:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113b5a:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113b5f:	ff 75 ec             	pushl  -0x14(%ebp)
f0113b62:	ff 75 f0             	pushl  -0x10(%ebp)
f0113b65:	ff 75 f4             	pushl  -0xc(%ebp)
f0113b68:	50                   	push   %eax
f0113b69:	e8 8f 4f ff ff       	call   f0108afd <pt_set_page_permissions>
f0113b6e:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113b71:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113b76:	ff 75 ec             	pushl  -0x14(%ebp)
f0113b79:	ff 75 f0             	pushl  -0x10(%ebp)
f0113b7c:	ff 75 f4             	pushl  -0xc(%ebp)
f0113b7f:	50                   	push   %eax
f0113b80:	e8 b1 4b 00 00       	call   f0118736 <CP>
f0113b85:	83 c4 10             	add    $0x10,%esp
f0113b88:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0113b8b:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0113b8f:	74 17                	je     f0113ba8 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0113b91:	83 ec 04             	sub    $0x4,%esp
f0113b94:	68 b0 cb 12 f0       	push   $0xf012cbb0
f0113b99:	68 5e 01 00 00       	push   $0x15e
f0113b9e:	68 02 cb 12 f0       	push   $0xf012cb02
f0113ba3:	e8 72 c7 fe ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0113ba8:	83 ec 0c             	sub    $0xc,%esp
f0113bab:	68 dc cb 12 f0       	push   $0xf012cbdc
f0113bb0:	e8 b7 d3 fe ff       	call   f0100f6c <cprintf>
f0113bb5:	83 c4 10             	add    $0x10,%esp
	return 0;
f0113bb8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113bbd:	c9                   	leave  
f0113bbe:	c3                   	ret    

f0113bbf <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0113bbf:	55                   	push   %ebp
f0113bc0:	89 e5                	mov    %esp,%ebp
f0113bc2:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0113bc5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0113bcc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0113bd3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0113bda:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113bdf:	ff 75 ec             	pushl  -0x14(%ebp)
f0113be2:	ff 75 f0             	pushl  -0x10(%ebp)
f0113be5:	ff 75 f4             	pushl  -0xc(%ebp)
f0113be8:	50                   	push   %eax
f0113be9:	e8 0f 4f ff ff       	call   f0108afd <pt_set_page_permissions>
f0113bee:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0113bf1:	83 ec 04             	sub    $0x4,%esp
f0113bf4:	68 2c cc 12 f0       	push   $0xf012cc2c
f0113bf9:	68 6b 01 00 00       	push   $0x16b
f0113bfe:	68 02 cb 12 f0       	push   $0xf012cb02
f0113c03:	e8 12 c7 fe ff       	call   f010031a <_panic>

f0113c08 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0113c08:	55                   	push   %ebp
f0113c09:	89 e5                	mov    %esp,%ebp
f0113c0b:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0113c0e:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0113c15:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113c1a:	83 ec 08             	sub    $0x8,%esp
f0113c1d:	ff 75 f4             	pushl  -0xc(%ebp)
f0113c20:	50                   	push   %eax
f0113c21:	e8 9b 4f ff ff       	call   f0108bc1 <pt_get_page_permissions>
f0113c26:	83 c4 10             	add    $0x10,%esp
f0113c29:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0113c2c:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0113c30:	74 17                	je     f0113c49 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0113c32:	83 ec 04             	sub    $0x4,%esp
f0113c35:	68 c8 cc 12 f0       	push   $0xf012ccc8
f0113c3a:	68 79 01 00 00       	push   $0x179
f0113c3f:	68 02 cb 12 f0       	push   $0xf012cb02
f0113c44:	e8 d1 c6 fe ff       	call   f010031a <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0113c49:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0113c50:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113c55:	83 ec 08             	sub    $0x8,%esp
f0113c58:	ff 75 f4             	pushl  -0xc(%ebp)
f0113c5b:	50                   	push   %eax
f0113c5c:	e8 60 4f ff ff       	call   f0108bc1 <pt_get_page_permissions>
f0113c61:	83 c4 10             	add    $0x10,%esp
f0113c64:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0113c67:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0113c6b:	74 17                	je     f0113c84 <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0113c6d:	83 ec 04             	sub    $0x4,%esp
f0113c70:	68 ec cc 12 f0       	push   $0xf012ccec
f0113c75:	68 81 01 00 00       	push   $0x181
f0113c7a:	68 02 cb 12 f0       	push   $0xf012cb02
f0113c7f:	e8 96 c6 fe ff       	call   f010031a <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0113c84:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0113c8b:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113c90:	83 ec 08             	sub    $0x8,%esp
f0113c93:	ff 75 f4             	pushl  -0xc(%ebp)
f0113c96:	50                   	push   %eax
f0113c97:	e8 25 4f ff ff       	call   f0108bc1 <pt_get_page_permissions>
f0113c9c:	83 c4 10             	add    $0x10,%esp
f0113c9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0113ca2:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0113ca6:	74 17                	je     f0113cbf <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0113ca8:	83 ec 04             	sub    $0x4,%esp
f0113cab:	68 10 cd 12 f0       	push   $0xf012cd10
f0113cb0:	68 89 01 00 00       	push   $0x189
f0113cb5:	68 02 cb 12 f0       	push   $0xf012cb02
f0113cba:	e8 5b c6 fe ff       	call   f010031a <_panic>
	}

	va = 0xF1000000;
f0113cbf:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0113cc6:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113ccb:	83 ec 08             	sub    $0x8,%esp
f0113cce:	ff 75 f4             	pushl  -0xc(%ebp)
f0113cd1:	50                   	push   %eax
f0113cd2:	e8 ea 4e ff ff       	call   f0108bc1 <pt_get_page_permissions>
f0113cd7:	83 c4 10             	add    $0x10,%esp
f0113cda:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0113cdd:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0113ce1:	74 17                	je     f0113cfa <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0113ce3:	83 ec 04             	sub    $0x4,%esp
f0113ce6:	68 34 cd 12 f0       	push   $0xf012cd34
f0113ceb:	68 90 01 00 00       	push   $0x190
f0113cf0:	68 02 cb 12 f0       	push   $0xf012cb02
f0113cf5:	e8 20 c6 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0001000;
f0113cfa:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0113d01:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113d06:	83 ec 08             	sub    $0x8,%esp
f0113d09:	ff 75 f4             	pushl  -0xc(%ebp)
f0113d0c:	50                   	push   %eax
f0113d0d:	e8 af 4e ff ff       	call   f0108bc1 <pt_get_page_permissions>
f0113d12:	83 c4 10             	add    $0x10,%esp
f0113d15:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0113d18:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0113d1c:	74 17                	je     f0113d35 <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0113d1e:	83 ec 04             	sub    $0x4,%esp
f0113d21:	68 58 cd 12 f0       	push   $0xf012cd58
f0113d26:	68 97 01 00 00       	push   $0x197
f0113d2b:	68 02 cb 12 f0       	push   $0xf012cb02
f0113d30:	e8 e5 c5 fe ff       	call   f010031a <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0113d35:	83 ec 0c             	sub    $0xc,%esp
f0113d38:	68 7c cd 12 f0       	push   $0xf012cd7c
f0113d3d:	e8 2a d2 fe ff       	call   f0100f6c <cprintf>
f0113d42:	83 c4 10             	add    $0x10,%esp
	return 0;
f0113d45:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113d4a:	c9                   	leave  
f0113d4b:	c3                   	ret    

f0113d4c <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0113d4c:	55                   	push   %ebp
f0113d4d:	89 e5                	mov    %esp,%ebp
f0113d4f:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0113d52:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0113d59:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113d5e:	83 ec 08             	sub    $0x8,%esp
f0113d61:	ff 75 f4             	pushl  -0xc(%ebp)
f0113d64:	50                   	push   %eax
f0113d65:	e8 a0 4e ff ff       	call   f0108c0a <pt_clear_page_table_entry>
f0113d6a:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0113d6d:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113d72:	83 ec 08             	sub    $0x8,%esp
f0113d75:	ff 75 f4             	pushl  -0xc(%ebp)
f0113d78:	50                   	push   %eax
f0113d79:	e8 14 49 00 00       	call   f0118692 <CE>
f0113d7e:	83 c4 10             	add    $0x10,%esp
f0113d81:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0113d84:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0113d88:	74 17                	je     f0113da1 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0113d8a:	83 ec 04             	sub    $0x4,%esp
f0113d8d:	68 c4 cd 12 f0       	push   $0xf012cdc4
f0113d92:	68 a7 01 00 00       	push   $0x1a7
f0113d97:	68 02 cb 12 f0       	push   $0xf012cb02
f0113d9c:	e8 79 c5 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0001000;
f0113da1:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0113da8:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113dad:	83 ec 08             	sub    $0x8,%esp
f0113db0:	ff 75 f4             	pushl  -0xc(%ebp)
f0113db3:	50                   	push   %eax
f0113db4:	e8 51 4e ff ff       	call   f0108c0a <pt_clear_page_table_entry>
f0113db9:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0113dbc:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113dc1:	83 ec 08             	sub    $0x8,%esp
f0113dc4:	ff 75 f4             	pushl  -0xc(%ebp)
f0113dc7:	50                   	push   %eax
f0113dc8:	e8 c5 48 00 00       	call   f0118692 <CE>
f0113dcd:	83 c4 10             	add    $0x10,%esp
f0113dd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0113dd3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0113dd7:	74 17                	je     f0113df0 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0113dd9:	83 ec 04             	sub    $0x4,%esp
f0113ddc:	68 f0 cd 12 f0       	push   $0xf012cdf0
f0113de1:	68 af 01 00 00       	push   $0x1af
f0113de6:	68 02 cb 12 f0       	push   $0xf012cb02
f0113deb:	e8 2a c5 fe ff       	call   f010031a <_panic>
	}

	va = 0xEF800000;
f0113df0:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0113df7:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113dfc:	83 ec 08             	sub    $0x8,%esp
f0113dff:	ff 75 f4             	pushl  -0xc(%ebp)
f0113e02:	50                   	push   %eax
f0113e03:	e8 02 4e ff ff       	call   f0108c0a <pt_clear_page_table_entry>
f0113e08:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0113e0b:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113e10:	83 ec 08             	sub    $0x8,%esp
f0113e13:	ff 75 f4             	pushl  -0xc(%ebp)
f0113e16:	50                   	push   %eax
f0113e17:	e8 76 48 00 00       	call   f0118692 <CE>
f0113e1c:	83 c4 10             	add    $0x10,%esp
f0113e1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0113e22:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0113e26:	74 17                	je     f0113e3f <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0113e28:	83 ec 04             	sub    $0x4,%esp
f0113e2b:	68 1c ce 12 f0       	push   $0xf012ce1c
f0113e30:	68 b7 01 00 00       	push   $0x1b7
f0113e35:	68 02 cb 12 f0       	push   $0xf012cb02
f0113e3a:	e8 db c4 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0000000;
f0113e3f:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0113e46:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113e4b:	83 ec 08             	sub    $0x8,%esp
f0113e4e:	ff 75 f4             	pushl  -0xc(%ebp)
f0113e51:	50                   	push   %eax
f0113e52:	e8 b3 4d ff ff       	call   f0108c0a <pt_clear_page_table_entry>
f0113e57:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0113e5a:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113e5f:	83 ec 08             	sub    $0x8,%esp
f0113e62:	ff 75 f4             	pushl  -0xc(%ebp)
f0113e65:	50                   	push   %eax
f0113e66:	e8 27 48 00 00       	call   f0118692 <CE>
f0113e6b:	83 c4 10             	add    $0x10,%esp
f0113e6e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0113e71:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0113e75:	74 17                	je     f0113e8e <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0113e77:	83 ec 04             	sub    $0x4,%esp
f0113e7a:	68 48 ce 12 f0       	push   $0xf012ce48
f0113e7f:	68 bf 01 00 00       	push   $0x1bf
f0113e84:	68 02 cb 12 f0       	push   $0xf012cb02
f0113e89:	e8 8c c4 fe ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f0113e8e:	83 ec 0c             	sub    $0xc,%esp
f0113e91:	68 74 ce 12 f0       	push   $0xf012ce74
f0113e96:	e8 d1 d0 fe ff       	call   f0100f6c <cprintf>
f0113e9b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0113e9e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113ea3:	c9                   	leave  
f0113ea4:	c3                   	ret    

f0113ea5 <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0113ea5:	55                   	push   %ebp
f0113ea6:	89 e5                	mov    %esp,%ebp
f0113ea8:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0113eab:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0113eb2:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0113eb7:	83 ec 08             	sub    $0x8,%esp
f0113eba:	ff 75 f4             	pushl  -0xc(%ebp)
f0113ebd:	50                   	push   %eax
f0113ebe:	e8 47 4d ff ff       	call   f0108c0a <pt_clear_page_table_entry>
f0113ec3:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0113ec6:	83 ec 04             	sub    $0x4,%esp
f0113ec9:	68 c0 ce 12 f0       	push   $0xf012cec0
f0113ece:	68 ca 01 00 00       	push   $0x1ca
f0113ed3:	68 02 cb 12 f0       	push   $0xf012cb02
f0113ed8:	e8 3d c4 fe ff       	call   f010031a <_panic>

f0113edd <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f0113edd:	55                   	push   %ebp
f0113ede:	89 e5                	mov    %esp,%ebp
f0113ee0:	57                   	push   %edi
f0113ee1:	56                   	push   %esi
f0113ee2:	53                   	push   %ebx
f0113ee3:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113ee9:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0113eef:	bb 04 d2 12 f0       	mov    $0xf012d204,%ebx
f0113ef4:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ef9:	89 c7                	mov    %eax,%edi
f0113efb:	89 de                	mov    %ebx,%esi
f0113efd:	89 d1                	mov    %edx,%ecx
f0113eff:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113f01:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0113f07:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113f0c:	b0 00                	mov    $0x0,%al
f0113f0e:	89 d7                	mov    %edx,%edi
f0113f10:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113f12:	6a 00                	push   $0x0
f0113f14:	6a 0a                	push   $0xa
f0113f16:	6a 14                	push   $0x14
f0113f18:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0113f1e:	50                   	push   %eax
f0113f1f:	e8 21 5b ff ff       	call   f0109a45 <env_create>
f0113f24:	83 c4 10             	add    $0x10,%esp
f0113f27:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113f2a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0113f2d:	8b 40 64             	mov    0x64(%eax),%eax
f0113f30:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0113f33:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0113f36:	8b 40 68             	mov    0x68(%eax),%eax
f0113f39:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0113f3c:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113f3f:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0113f42:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0113f49:	75 70 20 
f0113f4c:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0113f53:	00 00 00 
f0113f56:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0113f5c:	b9 03 00 00 00       	mov    $0x3,%ecx
f0113f61:	b8 00 00 00 00       	mov    $0x0,%eax
f0113f66:	89 d7                	mov    %edx,%edi
f0113f68:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0113f6a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0113f6d:	8b 40 10             	mov    0x10(%eax),%eax
f0113f70:	83 ec 08             	sub    $0x8,%esp
f0113f73:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0113f79:	52                   	push   %edx
f0113f7a:	50                   	push   %eax
f0113f7b:	e8 32 e9 00 00       	call   f01228b2 <ltostr>
f0113f80:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0113f83:	83 ec 04             	sub    $0x4,%esp
f0113f86:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0113f8c:	50                   	push   %eax
f0113f8d:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0113f93:	50                   	push   %eax
f0113f94:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0113f9a:	50                   	push   %eax
f0113f9b:	e8 eb e9 00 00       	call   f012298b <strcconcat>
f0113fa0:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0113fa3:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0113faa:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f0113fb1:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0113fb8:	83 ec 0c             	sub    $0xc,%esp
f0113fbb:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113fbe:	e8 d0 48 00 00       	call   f0118893 <ClearUserSpace>
f0113fc3:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0113fc6:	83 ec 04             	sub    $0x4,%esp
f0113fc9:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0113fcf:	50                   	push   %eax
f0113fd0:	68 56 cf 12 f0       	push   $0xf012cf56
f0113fd5:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0113fdb:	50                   	push   %eax
f0113fdc:	e8 aa e9 00 00       	call   f012298b <strcconcat>
f0113fe1:	83 c4 10             	add    $0x10,%esp
f0113fe4:	83 ec 0c             	sub    $0xc,%esp
f0113fe7:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0113fed:	50                   	push   %eax
f0113fee:	e8 e9 de fe ff       	call   f0101edc <execute_command>
f0113ff3:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f0113ff6:	83 ec 04             	sub    $0x4,%esp
f0113ff9:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0113fff:	50                   	push   %eax
f0114000:	68 61 cf 12 f0       	push   $0xf012cf61
f0114005:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011400b:	50                   	push   %eax
f011400c:	e8 7a e9 00 00       	call   f012298b <strcconcat>
f0114011:	83 c4 10             	add    $0x10,%esp
f0114014:	83 ec 0c             	sub    $0xc,%esp
f0114017:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f011401d:	50                   	push   %eax
f011401e:	e8 b9 de fe ff       	call   f0101edc <execute_command>
f0114023:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f0114026:	83 ec 04             	sub    $0x4,%esp
f0114029:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f011402f:	50                   	push   %eax
f0114030:	68 6c cf 12 f0       	push   $0xf012cf6c
f0114035:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011403b:	50                   	push   %eax
f011403c:	e8 4a e9 00 00       	call   f012298b <strcconcat>
f0114041:	83 c4 10             	add    $0x10,%esp
f0114044:	83 ec 0c             	sub    $0xc,%esp
f0114047:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f011404d:	50                   	push   %eax
f011404e:	e8 89 de fe ff       	call   f0101edc <execute_command>
f0114053:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0114056:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f011405d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114060:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0114063:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f011406a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011406d:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0114070:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0114077:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011407a:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f011407d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114080:	83 ec 08             	sub    $0x8,%esp
f0114083:	50                   	push   %eax
f0114084:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114087:	e8 6e 47 00 00       	call   f01187fa <GP>
f011408c:	83 c4 10             	add    $0x10,%esp
f011408f:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0114092:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0114099:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f01140a0:	e8 38 99 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01140a5:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f01140a8:	83 ec 0c             	sub    $0xc,%esp
f01140ab:	68 78 cf 12 f0       	push   $0xf012cf78
f01140b0:	e8 b7 ce fe ff       	call   f0100f6c <cprintf>
f01140b5:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f01140b8:	6a 03                	push   $0x3
f01140ba:	68 00 00 90 02       	push   $0x2900000
f01140bf:	68 00 00 80 02       	push   $0x2800000
f01140c4:	ff 75 d4             	pushl  -0x2c(%ebp)
f01140c7:	e8 d9 55 ff ff       	call   f01096a5 <cut_paste_pages>
f01140cc:	83 c4 10             	add    $0x10,%esp
f01140cf:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f01140d2:	e8 06 99 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01140d7:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f01140da:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f01140e1:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01140e5:	75 08                	jne    f01140ef <test_cut_paste_pages+0x212>
f01140e7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01140ea:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01140ed:	74 2b                	je     f011411a <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f01140ef:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01140f2:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01140f5:	83 ec 0c             	sub    $0xc,%esp
f01140f8:	50                   	push   %eax
f01140f9:	ff 75 b4             	pushl  -0x4c(%ebp)
f01140fc:	68 a8 cf 12 f0       	push   $0xf012cfa8
f0114101:	68 04 02 00 00       	push   $0x204
f0114106:	68 02 cb 12 f0       	push   $0xf012cb02
f011410b:	e8 a7 c3 fe ff       	call   f01004b7 <_warn>
f0114110:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0114113:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f011411a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011411e:	74 04                	je     f0114124 <test_cut_paste_pages+0x247>
f0114120:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0114124:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f011412b:	83 ec 08             	sub    $0x8,%esp
f011412e:	6a 00                	push   $0x0
f0114130:	6a 01                	push   $0x1
f0114132:	6a 00                	push   $0x0
f0114134:	68 ff 0f 00 00       	push   $0xfff
f0114139:	ff 75 bc             	pushl  -0x44(%ebp)
f011413c:	6a 01                	push   $0x1
f011413e:	68 00 30 00 00       	push   $0x3000
f0114143:	68 00 00 90 02       	push   $0x2900000
f0114148:	68 00 00 80 02       	push   $0x2800000
f011414d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114150:	e8 72 47 00 00       	call   f01188c7 <CCP>
f0114155:	83 c4 30             	add    $0x30,%esp
f0114158:	83 f8 01             	cmp    $0x1,%eax
f011415b:	74 21                	je     f011417e <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f011415d:	83 ec 04             	sub    $0x4,%esp
f0114160:	68 fc cf 12 f0       	push   $0xf012cffc
f0114165:	68 0c 02 00 00       	push   $0x20c
f011416a:	68 02 cb 12 f0       	push   $0xf012cb02
f011416f:	e8 43 c3 fe ff       	call   f01004b7 <_warn>
f0114174:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0114177:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f011417e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114182:	74 04                	je     f0114188 <test_cut_paste_pages+0x2ab>
f0114184:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0114188:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f011418f:	83 ec 04             	sub    $0x4,%esp
f0114192:	6a 00                	push   $0x0
f0114194:	68 00 00 90 02       	push   $0x2900000
f0114199:	ff 75 d4             	pushl  -0x2c(%ebp)
f011419c:	e8 b7 41 00 00       	call   f0118358 <CB>
f01141a1:	83 c4 10             	add    $0x10,%esp
f01141a4:	85 c0                	test   %eax,%eax
f01141a6:	0f 84 f6 00 00 00    	je     f01142a2 <test_cut_paste_pages+0x3c5>
f01141ac:	83 ec 04             	sub    $0x4,%esp
f01141af:	6a 00                	push   $0x0
f01141b1:	68 00 10 90 02       	push   $0x2901000
f01141b6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01141b9:	e8 9a 41 00 00       	call   f0118358 <CB>
f01141be:	83 c4 10             	add    $0x10,%esp
f01141c1:	85 c0                	test   %eax,%eax
f01141c3:	0f 84 d9 00 00 00    	je     f01142a2 <test_cut_paste_pages+0x3c5>
f01141c9:	83 ec 04             	sub    $0x4,%esp
f01141cc:	6a 00                	push   $0x0
f01141ce:	68 00 20 90 02       	push   $0x2902000
f01141d3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01141d6:	e8 7d 41 00 00       	call   f0118358 <CB>
f01141db:	83 c4 10             	add    $0x10,%esp
f01141de:	85 c0                	test   %eax,%eax
f01141e0:	0f 84 bc 00 00 00    	je     f01142a2 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f01141e6:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f01141ed:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f01141f4:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f01141fb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01141fe:	8a 00                	mov    (%eax),%al
f0114200:	3c 61                	cmp    $0x61,%al
f0114202:	75 12                	jne    f0114216 <test_cut_paste_pages+0x339>
f0114204:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114207:	8a 00                	mov    (%eax),%al
f0114209:	3c 62                	cmp    $0x62,%al
f011420b:	75 09                	jne    f0114216 <test_cut_paste_pages+0x339>
f011420d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0114210:	8a 00                	mov    (%eax),%al
f0114212:	3c 63                	cmp    $0x63,%al
f0114214:	74 21                	je     f0114237 <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0114216:	83 ec 04             	sub    $0x4,%esp
f0114219:	68 48 d0 12 f0       	push   $0xf012d048
f011421e:	68 19 02 00 00       	push   $0x219
f0114223:	68 02 cb 12 f0       	push   $0xf012cb02
f0114228:	e8 8a c2 fe ff       	call   f01004b7 <_warn>
f011422d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114230:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0114237:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011423b:	74 04                	je     f0114241 <test_cut_paste_pages+0x364>
f011423d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114241:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0114248:	83 ec 04             	sub    $0x4,%esp
f011424b:	6a 01                	push   $0x1
f011424d:	68 00 10 90 02       	push   $0x2901000
f0114252:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114255:	e8 fe 40 00 00       	call   f0118358 <CB>
f011425a:	83 c4 10             	add    $0x10,%esp
f011425d:	85 c0                	test   %eax,%eax
f011425f:	74 41                	je     f01142a2 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f0114261:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114264:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0114267:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011426a:	8a 00                	mov    (%eax),%al
f011426c:	3c 79                	cmp    $0x79,%al
f011426e:	74 21                	je     f0114291 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0114270:	83 ec 04             	sub    $0x4,%esp
f0114273:	68 48 d0 12 f0       	push   $0xf012d048
f0114278:	68 24 02 00 00       	push   $0x224
f011427d:	68 02 cb 12 f0       	push   $0xf012cb02
f0114282:	e8 30 c2 fe ff       	call   f01004b7 <_warn>
f0114287:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011428a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0114291:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114295:	74 04                	je     f011429b <test_cut_paste_pages+0x3be>
f0114297:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011429b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f01142a2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01142a5:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f01142a8:	6a 02                	push   $0x2
f01142aa:	68 00 f0 bf 02       	push   $0x2bff000
f01142af:	68 00 10 90 02       	push   $0x2901000
f01142b4:	ff 75 d4             	pushl  -0x2c(%ebp)
f01142b7:	e8 e9 53 ff ff       	call   f01096a5 <cut_paste_pages>
f01142bc:	83 c4 10             	add    $0x10,%esp
f01142bf:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01142c2:	e8 16 97 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01142c7:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f01142ca:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01142ce:	75 0b                	jne    f01142db <test_cut_paste_pages+0x3fe>
f01142d0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01142d3:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01142d6:	83 f8 01             	cmp    $0x1,%eax
f01142d9:	74 2b                	je     f0114306 <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f01142db:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01142de:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01142e1:	83 ec 0c             	sub    $0xc,%esp
f01142e4:	50                   	push   %eax
f01142e5:	ff 75 b4             	pushl  -0x4c(%ebp)
f01142e8:	68 a8 cf 12 f0       	push   $0xf012cfa8
f01142ed:	68 35 02 00 00       	push   $0x235
f01142f2:	68 02 cb 12 f0       	push   $0xf012cb02
f01142f7:	e8 bb c1 fe ff       	call   f01004b7 <_warn>
f01142fc:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01142ff:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0114306:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011430a:	74 04                	je     f0114310 <test_cut_paste_pages+0x433>
f011430c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0114310:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0114317:	83 ec 08             	sub    $0x8,%esp
f011431a:	6a 00                	push   $0x0
f011431c:	6a 01                	push   $0x1
f011431e:	6a 00                	push   $0x0
f0114320:	68 ff 0f 00 00       	push   $0xfff
f0114325:	ff 75 bc             	pushl  -0x44(%ebp)
f0114328:	6a 01                	push   $0x1
f011432a:	68 00 20 00 00       	push   $0x2000
f011432f:	68 00 f0 bf 02       	push   $0x2bff000
f0114334:	68 00 10 90 02       	push   $0x2901000
f0114339:	ff 75 d4             	pushl  -0x2c(%ebp)
f011433c:	e8 86 45 00 00       	call   f01188c7 <CCP>
f0114341:	83 c4 30             	add    $0x30,%esp
f0114344:	83 f8 01             	cmp    $0x1,%eax
f0114347:	74 21                	je     f011436a <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0114349:	83 ec 04             	sub    $0x4,%esp
f011434c:	68 fc cf 12 f0       	push   $0xf012cffc
f0114351:	68 3d 02 00 00       	push   $0x23d
f0114356:	68 02 cb 12 f0       	push   $0xf012cb02
f011435b:	e8 57 c1 fe ff       	call   f01004b7 <_warn>
f0114360:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0114363:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011436a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011436e:	74 04                	je     f0114374 <test_cut_paste_pages+0x497>
f0114370:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0114374:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f011437b:	83 ec 04             	sub    $0x4,%esp
f011437e:	6a 00                	push   $0x0
f0114380:	68 ff f7 bf 02       	push   $0x2bff7ff
f0114385:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114388:	e8 cb 3f 00 00       	call   f0118358 <CB>
f011438d:	83 c4 10             	add    $0x10,%esp
f0114390:	85 c0                	test   %eax,%eax
f0114392:	74 6b                	je     f01143ff <test_cut_paste_pages+0x522>
f0114394:	83 ec 04             	sub    $0x4,%esp
f0114397:	6a 00                	push   $0x0
f0114399:	68 ff 0f c0 02       	push   $0x2c00fff
f011439e:	ff 75 d4             	pushl  -0x2c(%ebp)
f01143a1:	e8 b2 3f 00 00       	call   f0118358 <CB>
f01143a6:	83 c4 10             	add    $0x10,%esp
f01143a9:	85 c0                	test   %eax,%eax
f01143ab:	74 52                	je     f01143ff <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f01143ad:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f01143b4:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f01143bb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01143be:	8a 00                	mov    (%eax),%al
f01143c0:	3c 79                	cmp    $0x79,%al
f01143c2:	75 09                	jne    f01143cd <test_cut_paste_pages+0x4f0>
f01143c4:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01143c7:	8a 00                	mov    (%eax),%al
f01143c9:	3c 63                	cmp    $0x63,%al
f01143cb:	74 21                	je     f01143ee <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01143cd:	83 ec 04             	sub    $0x4,%esp
f01143d0:	68 48 d0 12 f0       	push   $0xf012d048
f01143d5:	68 49 02 00 00       	push   $0x249
f01143da:	68 02 cb 12 f0       	push   $0xf012cb02
f01143df:	e8 d3 c0 fe ff       	call   f01004b7 <_warn>
f01143e4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01143e7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01143ee:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01143f2:	74 04                	je     f01143f8 <test_cut_paste_pages+0x51b>
f01143f4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01143f8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f01143ff:	83 ec 0c             	sub    $0xc,%esp
f0114402:	68 81 d0 12 f0       	push   $0xf012d081
f0114407:	e8 60 cb fe ff       	call   f0100f6c <cprintf>
f011440c:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f011440f:	83 ec 0c             	sub    $0xc,%esp
f0114412:	68 90 d0 12 f0       	push   $0xf012d090
f0114417:	e8 50 cb fe ff       	call   f0100f6c <cprintf>
f011441c:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f011441f:	83 ec 04             	sub    $0x4,%esp
f0114422:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0114428:	50                   	push   %eax
f0114429:	68 b9 d0 12 f0       	push   $0xf012d0b9
f011442e:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0114434:	50                   	push   %eax
f0114435:	e8 51 e5 00 00       	call   f012298b <strcconcat>
f011443a:	83 c4 10             	add    $0x10,%esp
f011443d:	83 ec 0c             	sub    $0xc,%esp
f0114440:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0114446:	50                   	push   %eax
f0114447:	e8 90 da fe ff       	call   f0101edc <execute_command>
f011444c:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f011444f:	83 ec 04             	sub    $0x4,%esp
f0114452:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0114458:	50                   	push   %eax
f0114459:	68 c4 d0 12 f0       	push   $0xf012d0c4
f011445e:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0114464:	50                   	push   %eax
f0114465:	e8 21 e5 00 00       	call   f012298b <strcconcat>
f011446a:	83 c4 10             	add    $0x10,%esp
f011446d:	83 ec 0c             	sub    $0xc,%esp
f0114470:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0114476:	50                   	push   %eax
f0114477:	e8 60 da fe ff       	call   f0101edc <execute_command>
f011447c:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f011447f:	83 ec 04             	sub    $0x4,%esp
f0114482:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0114488:	50                   	push   %eax
f0114489:	68 cf d0 12 f0       	push   $0xf012d0cf
f011448e:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0114494:	50                   	push   %eax
f0114495:	e8 f1 e4 00 00       	call   f012298b <strcconcat>
f011449a:	83 c4 10             	add    $0x10,%esp
f011449d:	83 ec 0c             	sub    $0xc,%esp
f01144a0:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01144a6:	50                   	push   %eax
f01144a7:	e8 30 da fe ff       	call   f0101edc <execute_command>
f01144ac:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f01144af:	83 ec 04             	sub    $0x4,%esp
f01144b2:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f01144b8:	50                   	push   %eax
f01144b9:	68 da d0 12 f0       	push   $0xf012d0da
f01144be:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01144c4:	50                   	push   %eax
f01144c5:	e8 c1 e4 00 00       	call   f012298b <strcconcat>
f01144ca:	83 c4 10             	add    $0x10,%esp
f01144cd:	83 ec 0c             	sub    $0xc,%esp
f01144d0:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f01144d6:	50                   	push   %eax
f01144d7:	e8 00 da fe ff       	call   f0101edc <execute_command>
f01144dc:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f01144df:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f01144e6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01144e9:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f01144ec:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f01144f3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01144f6:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f01144f9:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0114500:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114503:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f0114506:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f011450d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114510:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0114513:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f011451a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011451d:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0114520:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f0114527:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011452a:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f011452d:	83 ec 08             	sub    $0x8,%esp
f0114530:	68 00 00 c0 01       	push   $0x1c00000
f0114535:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114538:	e8 bd 42 00 00       	call   f01187fa <GP>
f011453d:	83 c4 10             	add    $0x10,%esp
f0114540:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0114543:	83 ec 08             	sub    $0x8,%esp
f0114546:	68 00 00 40 01       	push   $0x1400000
f011454b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011454e:	e8 a7 42 00 00       	call   f01187fa <GP>
f0114553:	83 c4 10             	add    $0x10,%esp
f0114556:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0114559:	e8 7f 94 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011455e:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0114561:	6a 01                	push   $0x1
f0114563:	68 00 00 40 01       	push   $0x1400000
f0114568:	68 00 00 c0 01       	push   $0x1c00000
f011456d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114570:	e8 30 51 ff ff       	call   f01096a5 <cut_paste_pages>
f0114575:	83 c4 10             	add    $0x10,%esp
f0114578:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f011457b:	e8 5d 94 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0114580:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0114583:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0114587:	75 08                	jne    f0114591 <test_cut_paste_pages+0x6b4>
f0114589:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011458c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011458f:	74 2b                	je     f01145bc <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0114591:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114594:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0114597:	83 ec 0c             	sub    $0xc,%esp
f011459a:	50                   	push   %eax
f011459b:	ff 75 b4             	pushl  -0x4c(%ebp)
f011459e:	68 e8 d0 12 f0       	push   $0xf012d0e8
f01145a3:	68 6c 02 00 00       	push   $0x26c
f01145a8:	68 02 cb 12 f0       	push   $0xf012cb02
f01145ad:	e8 05 bf fe ff       	call   f01004b7 <_warn>
f01145b2:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01145b5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01145bc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01145c0:	74 04                	je     f01145c6 <test_cut_paste_pages+0x6e9>
f01145c2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01145c6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f01145cd:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f01145d4:	83 ec 08             	sub    $0x8,%esp
f01145d7:	6a 00                	push   $0x0
f01145d9:	68 ff 0f 00 00       	push   $0xfff
f01145de:	ff 75 a4             	pushl  -0x5c(%ebp)
f01145e1:	68 ff 0f 00 00       	push   $0xfff
f01145e6:	ff 75 a0             	pushl  -0x60(%ebp)
f01145e9:	6a 01                	push   $0x1
f01145eb:	68 00 10 00 00       	push   $0x1000
f01145f0:	68 00 00 40 01       	push   $0x1400000
f01145f5:	68 00 00 c0 01       	push   $0x1c00000
f01145fa:	ff 75 d4             	pushl  -0x2c(%ebp)
f01145fd:	e8 c5 42 00 00       	call   f01188c7 <CCP>
f0114602:	83 c4 30             	add    $0x30,%esp
f0114605:	83 f8 01             	cmp    $0x1,%eax
f0114608:	74 28                	je     f0114632 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f011460a:	83 ec 04             	sub    $0x4,%esp
f011460d:	68 fc cf 12 f0       	push   $0xf012cffc
f0114612:	68 75 02 00 00       	push   $0x275
f0114617:	68 02 cb 12 f0       	push   $0xf012cb02
f011461c:	e8 96 be fe ff       	call   f01004b7 <_warn>
f0114621:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0114624:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f011462b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0114632:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114636:	74 04                	je     f011463c <test_cut_paste_pages+0x75f>
f0114638:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f011463c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0114643:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114647:	0f 84 92 00 00 00    	je     f01146df <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f011464d:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0114654:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f011465b:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0114662:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0114669:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0114670:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0114677:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011467a:	8a 00                	mov    (%eax),%al
f011467c:	3c 61                	cmp    $0x61,%al
f011467e:	75 2d                	jne    f01146ad <test_cut_paste_pages+0x7d0>
f0114680:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114683:	8a 00                	mov    (%eax),%al
f0114685:	3c 78                	cmp    $0x78,%al
f0114687:	75 24                	jne    f01146ad <test_cut_paste_pages+0x7d0>
f0114689:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011468c:	8a 00                	mov    (%eax),%al
f011468e:	3c 62                	cmp    $0x62,%al
f0114690:	75 1b                	jne    f01146ad <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0114692:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114695:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0114697:	3c 79                	cmp    $0x79,%al
f0114699:	75 12                	jne    f01146ad <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f011469b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011469e:	8a 00                	mov    (%eax),%al
f01146a0:	3c 63                	cmp    $0x63,%al
f01146a2:	75 09                	jne    f01146ad <test_cut_paste_pages+0x7d0>
f01146a4:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01146a7:	8a 00                	mov    (%eax),%al
f01146a9:	3c 7a                	cmp    $0x7a,%al
f01146ab:	74 21                	je     f01146ce <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01146ad:	83 ec 04             	sub    $0x4,%esp
f01146b0:	68 48 d0 12 f0       	push   $0xf012d048
f01146b5:	68 87 02 00 00       	push   $0x287
f01146ba:	68 02 cb 12 f0       	push   $0xf012cb02
f01146bf:	e8 f3 bd fe ff       	call   f01004b7 <_warn>
f01146c4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01146c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01146ce:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01146d2:	74 04                	je     f01146d8 <test_cut_paste_pages+0x7fb>
f01146d4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01146d8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f01146df:	e8 f9 92 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01146e4:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f01146e7:	6a 03                	push   $0x3
f01146e9:	68 00 f0 bf 01       	push   $0x1bff000
f01146ee:	68 00 00 40 01       	push   $0x1400000
f01146f3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01146f6:	e8 aa 4f ff ff       	call   f01096a5 <cut_paste_pages>
f01146fb:	83 c4 10             	add    $0x10,%esp
f01146fe:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0114701:	e8 d7 92 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0114706:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0114709:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f011470d:	75 08                	jne    f0114717 <test_cut_paste_pages+0x83a>
f011470f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114712:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0114715:	74 2b                	je     f0114742 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0114717:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011471a:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011471d:	83 ec 0c             	sub    $0xc,%esp
f0114720:	50                   	push   %eax
f0114721:	ff 75 b4             	pushl  -0x4c(%ebp)
f0114724:	68 e8 d0 12 f0       	push   $0xf012d0e8
f0114729:	68 96 02 00 00       	push   $0x296
f011472e:	68 02 cb 12 f0       	push   $0xf012cb02
f0114733:	e8 7f bd fe ff       	call   f01004b7 <_warn>
f0114738:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f011473b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0114742:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114746:	74 04                	je     f011474c <test_cut_paste_pages+0x86f>
f0114748:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f011474c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0114753:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f011475a:	83 ec 04             	sub    $0x4,%esp
f011475d:	6a 00                	push   $0x0
f011475f:	68 00 00 40 01       	push   $0x1400000
f0114764:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114767:	e8 ec 3b 00 00       	call   f0118358 <CB>
f011476c:	83 c4 10             	add    $0x10,%esp
f011476f:	83 f8 01             	cmp    $0x1,%eax
f0114772:	0f 85 80 00 00 00    	jne    f01147f8 <test_cut_paste_pages+0x91b>
f0114778:	83 ec 04             	sub    $0x4,%esp
f011477b:	6a 00                	push   $0x0
f011477d:	68 00 10 40 01       	push   $0x1401000
f0114782:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114785:	e8 ce 3b 00 00       	call   f0118358 <CB>
f011478a:	83 c4 10             	add    $0x10,%esp
f011478d:	83 f8 01             	cmp    $0x1,%eax
f0114790:	75 66                	jne    f01147f8 <test_cut_paste_pages+0x91b>
f0114792:	83 ec 04             	sub    $0x4,%esp
f0114795:	6a 00                	push   $0x0
f0114797:	68 00 20 40 01       	push   $0x1402000
f011479c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011479f:	e8 b4 3b 00 00       	call   f0118358 <CB>
f01147a4:	83 c4 10             	add    $0x10,%esp
f01147a7:	83 f8 01             	cmp    $0x1,%eax
f01147aa:	75 4c                	jne    f01147f8 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f01147ac:	83 ec 04             	sub    $0x4,%esp
f01147af:	6a 00                	push   $0x0
f01147b1:	68 00 f0 bf 01       	push   $0x1bff000
f01147b6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01147b9:	e8 9a 3b 00 00       	call   f0118358 <CB>
f01147be:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f01147c1:	85 c0                	test   %eax,%eax
f01147c3:	75 33                	jne    f01147f8 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f01147c5:	83 ec 04             	sub    $0x4,%esp
f01147c8:	6a 00                	push   $0x0
f01147ca:	68 00 00 c0 01       	push   $0x1c00000
f01147cf:	ff 75 d4             	pushl  -0x2c(%ebp)
f01147d2:	e8 81 3b 00 00       	call   f0118358 <CB>
f01147d7:	83 c4 10             	add    $0x10,%esp
f01147da:	83 f8 01             	cmp    $0x1,%eax
f01147dd:	75 19                	jne    f01147f8 <test_cut_paste_pages+0x91b>
f01147df:	83 ec 04             	sub    $0x4,%esp
f01147e2:	6a 00                	push   $0x0
f01147e4:	68 00 10 c0 01       	push   $0x1c01000
f01147e9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01147ec:	e8 67 3b 00 00       	call   f0118358 <CB>
f01147f1:	83 c4 10             	add    $0x10,%esp
f01147f4:	85 c0                	test   %eax,%eax
f01147f6:	74 28                	je     f0114820 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f01147f8:	83 ec 04             	sub    $0x4,%esp
f01147fb:	68 48 d1 12 f0       	push   $0xf012d148
f0114800:	68 9f 02 00 00       	push   $0x29f
f0114805:	68 02 cb 12 f0       	push   $0xf012cb02
f011480a:	e8 a8 bc fe ff       	call   f01004b7 <_warn>
f011480f:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0114812:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0114819:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0114820:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114824:	74 04                	je     f011482a <test_cut_paste_pages+0x94d>
f0114826:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f011482a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0114831:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114835:	0f 84 99 00 00 00    	je     f01148d4 <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f011483b:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0114842:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0114849:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0114850:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0114857:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f011485e:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0114865:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114868:	8a 00                	mov    (%eax),%al
f011486a:	3c 61                	cmp    $0x61,%al
f011486c:	75 2d                	jne    f011489b <test_cut_paste_pages+0x9be>
f011486e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114871:	8a 00                	mov    (%eax),%al
f0114873:	3c 78                	cmp    $0x78,%al
f0114875:	75 24                	jne    f011489b <test_cut_paste_pages+0x9be>
f0114877:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011487a:	8a 00                	mov    (%eax),%al
f011487c:	3c 62                	cmp    $0x62,%al
f011487e:	75 1b                	jne    f011489b <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0114880:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114883:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0114885:	3c 79                	cmp    $0x79,%al
f0114887:	75 12                	jne    f011489b <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0114889:	8b 45 98             	mov    -0x68(%ebp),%eax
f011488c:	8a 00                	mov    (%eax),%al
f011488e:	3c 63                	cmp    $0x63,%al
f0114890:	75 09                	jne    f011489b <test_cut_paste_pages+0x9be>
f0114892:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114895:	8a 00                	mov    (%eax),%al
f0114897:	3c 7a                	cmp    $0x7a,%al
f0114899:	74 28                	je     f01148c3 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f011489b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f01148a2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01148a9:	83 ec 04             	sub    $0x4,%esp
f01148ac:	68 48 d0 12 f0       	push   $0xf012d048
f01148b1:	68 b3 02 00 00       	push   $0x2b3
f01148b6:	68 02 cb 12 f0       	push   $0xf012cb02
f01148bb:	e8 f7 bb fe ff       	call   f01004b7 <_warn>
f01148c0:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f01148c3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01148c7:	74 04                	je     f01148cd <test_cut_paste_pages+0x9f0>
f01148c9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01148cd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f01148d4:	83 ec 0c             	sub    $0xc,%esp
f01148d7:	68 81 d1 12 f0       	push   $0xf012d181
f01148dc:	e8 8b c6 fe ff       	call   f0100f6c <cprintf>
f01148e1:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f01148e4:	83 ec 08             	sub    $0x8,%esp
f01148e7:	ff 75 e4             	pushl  -0x1c(%ebp)
f01148ea:	68 90 d1 12 f0       	push   $0xf012d190
f01148ef:	e8 78 c6 fe ff       	call   f0100f6c <cprintf>
f01148f4:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01148f7:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01148fb:	75 10                	jne    f011490d <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f01148fd:	83 ec 0c             	sub    $0xc,%esp
f0114900:	68 c4 d1 12 f0       	push   $0xf012d1c4
f0114905:	e8 62 c6 fe ff       	call   f0100f6c <cprintf>
f011490a:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f011490d:	a1 84 4b 5a f0       	mov    0xf05a4b84,%eax
f0114912:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0114915:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114918:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011491b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114920:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114923:	5b                   	pop    %ebx
f0114924:	5e                   	pop    %esi
f0114925:	5f                   	pop    %edi
f0114926:	5d                   	pop    %ebp
f0114927:	c3                   	ret    

f0114928 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0114928:	55                   	push   %ebp
f0114929:	89 e5                	mov    %esp,%ebp
f011492b:	57                   	push   %edi
f011492c:	56                   	push   %esi
f011492d:	53                   	push   %ebx
f011492e:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114934:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f011493a:	bb 04 d2 12 f0       	mov    $0xf012d204,%ebx
f011493f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114944:	89 c7                	mov    %eax,%edi
f0114946:	89 de                	mov    %ebx,%esi
f0114948:	89 d1                	mov    %edx,%ecx
f011494a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011494c:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0114952:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114957:	b0 00                	mov    $0x0,%al
f0114959:	89 d7                	mov    %edx,%edi
f011495b:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011495d:	6a 00                	push   $0x0
f011495f:	6a 0a                	push   $0xa
f0114961:	6a 14                	push   $0x14
f0114963:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0114969:	50                   	push   %eax
f011496a:	e8 d6 50 ff ff       	call   f0109a45 <env_create>
f011496f:	83 c4 10             	add    $0x10,%esp
f0114972:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114975:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0114978:	8b 40 64             	mov    0x64(%eax),%eax
f011497b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f011497e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0114981:	8b 40 68             	mov    0x68(%eax),%eax
f0114984:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f011498a:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0114990:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0114993:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f011499a:	75 70 20 
f011499d:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f01149a4:	00 00 00 
f01149a7:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01149ad:	b9 03 00 00 00       	mov    $0x3,%ecx
f01149b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01149b7:	89 d7                	mov    %edx,%edi
f01149b9:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01149bb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01149be:	8b 40 10             	mov    0x10(%eax),%eax
f01149c1:	83 ec 08             	sub    $0x8,%esp
f01149c4:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f01149ca:	52                   	push   %edx
f01149cb:	50                   	push   %eax
f01149cc:	e8 e1 de 00 00       	call   f01228b2 <ltostr>
f01149d1:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01149d4:	83 ec 04             	sub    $0x4,%esp
f01149d7:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01149dd:	50                   	push   %eax
f01149de:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f01149e4:	50                   	push   %eax
f01149e5:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f01149eb:	50                   	push   %eax
f01149ec:	e8 9a df 00 00       	call   f012298b <strcconcat>
f01149f1:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f01149f4:	83 ec 0c             	sub    $0xc,%esp
f01149f7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01149fa:	e8 94 3e 00 00       	call   f0118893 <ClearUserSpace>
f01149ff:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0114a02:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0114a09:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0114a10:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0114a17:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0114a1e:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114a25:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0114a2c:	83 ec 0c             	sub    $0xc,%esp
f0114a2f:	68 38 d2 12 f0       	push   $0xf012d238
f0114a34:	e8 33 c5 fe ff       	call   f0100f6c <cprintf>
f0114a39:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0114a3c:	83 ec 04             	sub    $0x4,%esp
f0114a3f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114a45:	50                   	push   %eax
f0114a46:	68 6e d2 12 f0       	push   $0xf012d26e
f0114a4b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114a51:	50                   	push   %eax
f0114a52:	e8 34 df 00 00       	call   f012298b <strcconcat>
f0114a57:	83 c4 10             	add    $0x10,%esp
f0114a5a:	83 ec 0c             	sub    $0xc,%esp
f0114a5d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114a63:	50                   	push   %eax
f0114a64:	e8 73 d4 fe ff       	call   f0101edc <execute_command>
f0114a69:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0114a6c:	83 ec 04             	sub    $0x4,%esp
f0114a6f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114a75:	50                   	push   %eax
f0114a76:	68 73 d2 12 f0       	push   $0xf012d273
f0114a7b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114a81:	50                   	push   %eax
f0114a82:	e8 04 df 00 00       	call   f012298b <strcconcat>
f0114a87:	83 c4 10             	add    $0x10,%esp
f0114a8a:	83 ec 0c             	sub    $0xc,%esp
f0114a8d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114a93:	50                   	push   %eax
f0114a94:	e8 43 d4 fe ff       	call   f0101edc <execute_command>
f0114a99:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0114a9c:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0114aa2:	bb 79 d5 12 f0       	mov    $0xf012d579,%ebx
f0114aa7:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114aac:	89 c7                	mov    %eax,%edi
f0114aae:	89 de                	mov    %ebx,%esi
f0114ab0:	89 d1                	mov    %edx,%ecx
f0114ab2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114ab4:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0114aba:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114abf:	b0 00                	mov    $0x0,%al
f0114ac1:	89 d7                	mov    %edx,%edi
f0114ac3:	f3 aa                	rep stos %al,%es:(%edi)
f0114ac5:	83 ec 0c             	sub    $0xc,%esp
f0114ac8:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0114ace:	50                   	push   %eax
f0114acf:	e8 08 d4 fe ff       	call   f0101edc <execute_command>
f0114ad4:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0114ad7:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0114add:	bb dd d5 12 f0       	mov    $0xf012d5dd,%ebx
f0114ae2:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114ae7:	89 c7                	mov    %eax,%edi
f0114ae9:	89 de                	mov    %ebx,%esi
f0114aeb:	89 d1                	mov    %edx,%ecx
f0114aed:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114aef:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0114af5:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114afa:	b0 00                	mov    $0x0,%al
f0114afc:	89 d7                	mov    %edx,%edi
f0114afe:	f3 aa                	rep stos %al,%es:(%edi)
f0114b00:	83 ec 0c             	sub    $0xc,%esp
f0114b03:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0114b09:	50                   	push   %eax
f0114b0a:	e8 cd d3 fe ff       	call   f0101edc <execute_command>
f0114b0f:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0114b12:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0114b18:	bb 41 d6 12 f0       	mov    $0xf012d641,%ebx
f0114b1d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114b22:	89 c7                	mov    %eax,%edi
f0114b24:	89 de                	mov    %ebx,%esi
f0114b26:	89 d1                	mov    %edx,%ecx
f0114b28:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114b2a:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0114b30:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114b35:	b0 00                	mov    $0x0,%al
f0114b37:	89 d7                	mov    %edx,%edi
f0114b39:	f3 aa                	rep stos %al,%es:(%edi)
f0114b3b:	83 ec 0c             	sub    $0xc,%esp
f0114b3e:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0114b44:	50                   	push   %eax
f0114b45:	e8 92 d3 fe ff       	call   f0101edc <execute_command>
f0114b4a:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0114b4d:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0114b53:	bb a5 d6 12 f0       	mov    $0xf012d6a5,%ebx
f0114b58:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114b5d:	89 c7                	mov    %eax,%edi
f0114b5f:	89 de                	mov    %ebx,%esi
f0114b61:	89 d1                	mov    %edx,%ecx
f0114b63:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114b65:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0114b6b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114b70:	b0 00                	mov    $0x0,%al
f0114b72:	89 d7                	mov    %edx,%edi
f0114b74:	f3 aa                	rep stos %al,%es:(%edi)
f0114b76:	83 ec 0c             	sub    $0xc,%esp
f0114b79:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0114b7f:	50                   	push   %eax
f0114b80:	e8 57 d3 fe ff       	call   f0101edc <execute_command>
f0114b85:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0114b88:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0114b8e:	bb 09 d7 12 f0       	mov    $0xf012d709,%ebx
f0114b93:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114b98:	89 c7                	mov    %eax,%edi
f0114b9a:	89 de                	mov    %ebx,%esi
f0114b9c:	89 d1                	mov    %edx,%ecx
f0114b9e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114ba0:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0114ba6:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114bab:	b0 00                	mov    $0x0,%al
f0114bad:	89 d7                	mov    %edx,%edi
f0114baf:	f3 aa                	rep stos %al,%es:(%edi)
f0114bb1:	83 ec 0c             	sub    $0xc,%esp
f0114bb4:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0114bba:	50                   	push   %eax
f0114bbb:	e8 1c d3 fe ff       	call   f0101edc <execute_command>
f0114bc0:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0114bc3:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0114bc9:	bb 6d d7 12 f0       	mov    $0xf012d76d,%ebx
f0114bce:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114bd3:	89 c7                	mov    %eax,%edi
f0114bd5:	89 de                	mov    %ebx,%esi
f0114bd7:	89 d1                	mov    %edx,%ecx
f0114bd9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114bdb:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0114be1:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114be6:	b0 00                	mov    $0x0,%al
f0114be8:	89 d7                	mov    %edx,%edi
f0114bea:	f3 aa                	rep stos %al,%es:(%edi)
f0114bec:	83 ec 0c             	sub    $0xc,%esp
f0114bef:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0114bf5:	50                   	push   %eax
f0114bf6:	e8 e1 d2 fe ff       	call   f0101edc <execute_command>
f0114bfb:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0114bfe:	83 ec 04             	sub    $0x4,%esp
f0114c01:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0114c07:	50                   	push   %eax
f0114c08:	68 7b d2 12 f0       	push   $0xf012d27b
f0114c0d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114c13:	50                   	push   %eax
f0114c14:	e8 72 dd 00 00       	call   f012298b <strcconcat>
f0114c19:	83 c4 10             	add    $0x10,%esp
f0114c1c:	83 ec 0c             	sub    $0xc,%esp
f0114c1f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0114c25:	50                   	push   %eax
f0114c26:	e8 b1 d2 fe ff       	call   f0101edc <execute_command>
f0114c2b:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0114c2e:	83 ec 04             	sub    $0x4,%esp
f0114c31:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0114c37:	50                   	push   %eax
f0114c38:	68 85 d2 12 f0       	push   $0xf012d285
f0114c3d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114c43:	50                   	push   %eax
f0114c44:	e8 42 dd 00 00       	call   f012298b <strcconcat>
f0114c49:	83 c4 10             	add    $0x10,%esp
f0114c4c:	83 ec 0c             	sub    $0xc,%esp
f0114c4f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0114c55:	50                   	push   %eax
f0114c56:	e8 81 d2 fe ff       	call   f0101edc <execute_command>
f0114c5b:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0114c5e:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0114c64:	bb d1 d7 12 f0       	mov    $0xf012d7d1,%ebx
f0114c69:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114c6e:	89 c7                	mov    %eax,%edi
f0114c70:	89 de                	mov    %ebx,%esi
f0114c72:	89 d1                	mov    %edx,%ecx
f0114c74:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114c76:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0114c7c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114c81:	b0 00                	mov    $0x0,%al
f0114c83:	89 d7                	mov    %edx,%edi
f0114c85:	f3 aa                	rep stos %al,%es:(%edi)
f0114c87:	83 ec 0c             	sub    $0xc,%esp
f0114c8a:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0114c90:	50                   	push   %eax
f0114c91:	e8 46 d2 fe ff       	call   f0101edc <execute_command>
f0114c96:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0114c99:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114c9f:	bb 35 d8 12 f0       	mov    $0xf012d835,%ebx
f0114ca4:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114ca9:	89 c7                	mov    %eax,%edi
f0114cab:	89 de                	mov    %ebx,%esi
f0114cad:	89 d1                	mov    %edx,%ecx
f0114caf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114cb1:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0114cb7:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114cbc:	b0 00                	mov    $0x0,%al
f0114cbe:	89 d7                	mov    %edx,%edi
f0114cc0:	f3 aa                	rep stos %al,%es:(%edi)
f0114cc2:	83 ec 0c             	sub    $0xc,%esp
f0114cc5:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114ccb:	50                   	push   %eax
f0114ccc:	e8 0b d2 fe ff       	call   f0101edc <execute_command>
f0114cd1:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0114cd4:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0114cda:	bb 99 d8 12 f0       	mov    $0xf012d899,%ebx
f0114cdf:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114ce4:	89 c7                	mov    %eax,%edi
f0114ce6:	89 de                	mov    %ebx,%esi
f0114ce8:	89 d1                	mov    %edx,%ecx
f0114cea:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114cec:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0114cf2:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114cf7:	b0 00                	mov    $0x0,%al
f0114cf9:	89 d7                	mov    %edx,%edi
f0114cfb:	f3 aa                	rep stos %al,%es:(%edi)
f0114cfd:	83 ec 0c             	sub    $0xc,%esp
f0114d00:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0114d06:	50                   	push   %eax
f0114d07:	e8 d0 d1 fe ff       	call   f0101edc <execute_command>
f0114d0c:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0114d0f:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0114d16:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0114d1d:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0114d24:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0114d2b:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0114d32:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0114d39:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0114d40:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0114d47:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0114d4e:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0114d55:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0114d5c:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0114d63:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0114d66:	8a 00                	mov    (%eax),%al
f0114d68:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0114d6e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114d71:	8a 00                	mov    (%eax),%al
f0114d73:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0114d79:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114d7c:	8a 00                	mov    (%eax),%al
f0114d7e:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114d84:	e8 54 8c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0114d89:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0114d8c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114d8f:	89 d0                	mov    %edx,%eax
f0114d91:	01 c0                	add    %eax,%eax
f0114d93:	01 d0                	add    %edx,%eax
f0114d95:	01 c0                	add    %eax,%eax
f0114d97:	50                   	push   %eax
f0114d98:	68 00 00 10 00       	push   $0x100000
f0114d9d:	6a 00                	push   $0x0
f0114d9f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114da2:	e8 18 49 ff ff       	call   f01096bf <copy_paste_chunk>
f0114da7:	83 c4 10             	add    $0x10,%esp
f0114daa:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114dad:	e8 2b 8c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0114db2:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0114db5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0114dbc:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f0114dc0:	75 08                	jne    f0114dca <test_copy_paste_chunk+0x4a2>
f0114dc2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0114dc5:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0114dc8:	74 2b                	je     f0114df5 <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114dca:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0114dcd:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0114dd0:	83 ec 0c             	sub    $0xc,%esp
f0114dd3:	50                   	push   %eax
f0114dd4:	ff 75 88             	pushl  -0x78(%ebp)
f0114dd7:	68 94 d2 12 f0       	push   $0xf012d294
f0114ddc:	68 06 03 00 00       	push   $0x306
f0114de1:	68 02 cb 12 f0       	push   $0xf012cb02
f0114de6:	e8 cc b6 fe ff       	call   f01004b7 <_warn>
f0114deb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114dee:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0114df5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114df9:	74 04                	je     f0114dff <test_copy_paste_chunk+0x4d7>
f0114dfb:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114dff:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f0114e06:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114e09:	8a 00                	mov    (%eax),%al
f0114e0b:	3c 61                	cmp    $0x61,%al
f0114e0d:	75 75                	jne    f0114e84 <test_copy_paste_chunk+0x55c>
f0114e0f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114e12:	8a 00                	mov    (%eax),%al
f0114e14:	3c 78                	cmp    $0x78,%al
f0114e16:	75 6c                	jne    f0114e84 <test_copy_paste_chunk+0x55c>
f0114e18:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114e1b:	8a 00                	mov    (%eax),%al
f0114e1d:	3c 62                	cmp    $0x62,%al
f0114e1f:	75 63                	jne    f0114e84 <test_copy_paste_chunk+0x55c>
f0114e21:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0114e24:	8a 00                	mov    (%eax),%al
f0114e26:	3c 79                	cmp    $0x79,%al
f0114e28:	75 5a                	jne    f0114e84 <test_copy_paste_chunk+0x55c>
f0114e2a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114e2d:	8a 00                	mov    (%eax),%al
f0114e2f:	3c 63                	cmp    $0x63,%al
f0114e31:	75 51                	jne    f0114e84 <test_copy_paste_chunk+0x55c>
f0114e33:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0114e36:	8a 00                	mov    (%eax),%al
f0114e38:	3c 7a                	cmp    $0x7a,%al
f0114e3a:	75 48                	jne    f0114e84 <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0114e3c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0114e3f:	8a 00                	mov    (%eax),%al
f0114e41:	3c 64                	cmp    $0x64,%al
f0114e43:	75 3f                	jne    f0114e84 <test_copy_paste_chunk+0x55c>
f0114e45:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0114e48:	8a 10                	mov    (%eax),%dl
f0114e4a:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0114e50:	38 c2                	cmp    %al,%dl
f0114e52:	75 30                	jne    f0114e84 <test_copy_paste_chunk+0x55c>
f0114e54:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114e57:	8a 00                	mov    (%eax),%al
f0114e59:	3c 65                	cmp    $0x65,%al
f0114e5b:	75 27                	jne    f0114e84 <test_copy_paste_chunk+0x55c>
f0114e5d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114e60:	8a 10                	mov    (%eax),%dl
f0114e62:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0114e68:	38 c2                	cmp    %al,%dl
f0114e6a:	75 18                	jne    f0114e84 <test_copy_paste_chunk+0x55c>
f0114e6c:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114e6f:	8a 00                	mov    (%eax),%al
f0114e71:	3c 66                	cmp    $0x66,%al
f0114e73:	75 0f                	jne    f0114e84 <test_copy_paste_chunk+0x55c>
f0114e75:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114e78:	8a 10                	mov    (%eax),%dl
f0114e7a:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0114e80:	38 c2                	cmp    %al,%dl
f0114e82:	74 21                	je     f0114ea5 <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114e84:	83 ec 04             	sub    $0x4,%esp
f0114e87:	68 f8 d2 12 f0       	push   $0xf012d2f8
f0114e8c:	68 0f 03 00 00       	push   $0x30f
f0114e91:	68 02 cb 12 f0       	push   $0xf012cb02
f0114e96:	e8 1c b6 fe ff       	call   f01004b7 <_warn>
f0114e9b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114e9e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0114ea5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114ea9:	74 04                	je     f0114eaf <test_copy_paste_chunk+0x587>
f0114eab:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114eaf:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f0114eb6:	83 ec 0c             	sub    $0xc,%esp
f0114eb9:	68 32 d3 12 f0       	push   $0xf012d332
f0114ebe:	e8 a9 c0 fe ff       	call   f0100f6c <cprintf>
f0114ec3:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0114ec6:	83 ec 0c             	sub    $0xc,%esp
f0114ec9:	68 44 d3 12 f0       	push   $0xf012d344
f0114ece:	e8 99 c0 fe ff       	call   f0100f6c <cprintf>
f0114ed3:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f0114ed6:	83 ec 04             	sub    $0x4,%esp
f0114ed9:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114edf:	50                   	push   %eax
f0114ee0:	68 7a d3 12 f0       	push   $0xf012d37a
f0114ee5:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114eeb:	50                   	push   %eax
f0114eec:	e8 9a da 00 00       	call   f012298b <strcconcat>
f0114ef1:	83 c4 10             	add    $0x10,%esp
f0114ef4:	83 ec 0c             	sub    $0xc,%esp
f0114ef7:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114efd:	50                   	push   %eax
f0114efe:	e8 d9 cf fe ff       	call   f0101edc <execute_command>
f0114f03:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f0114f06:	83 ec 04             	sub    $0x4,%esp
f0114f09:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114f0f:	50                   	push   %eax
f0114f10:	68 84 d3 12 f0       	push   $0xf012d384
f0114f15:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114f1b:	50                   	push   %eax
f0114f1c:	e8 6a da 00 00       	call   f012298b <strcconcat>
f0114f21:	83 c4 10             	add    $0x10,%esp
f0114f24:	83 ec 0c             	sub    $0xc,%esp
f0114f27:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0114f2d:	50                   	push   %eax
f0114f2e:	e8 a9 cf fe ff       	call   f0101edc <execute_command>
f0114f33:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f0114f36:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0114f3c:	bb fd d8 12 f0       	mov    $0xf012d8fd,%ebx
f0114f41:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114f46:	89 c7                	mov    %eax,%edi
f0114f48:	89 de                	mov    %ebx,%esi
f0114f4a:	89 d1                	mov    %edx,%ecx
f0114f4c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114f4e:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0114f54:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114f59:	b0 00                	mov    $0x0,%al
f0114f5b:	89 d7                	mov    %edx,%edi
f0114f5d:	f3 aa                	rep stos %al,%es:(%edi)
f0114f5f:	83 ec 0c             	sub    $0xc,%esp
f0114f62:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0114f68:	50                   	push   %eax
f0114f69:	e8 6e cf fe ff       	call   f0101edc <execute_command>
f0114f6e:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0114f71:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0114f77:	bb 61 d9 12 f0       	mov    $0xf012d961,%ebx
f0114f7c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114f81:	89 c7                	mov    %eax,%edi
f0114f83:	89 de                	mov    %ebx,%esi
f0114f85:	89 d1                	mov    %edx,%ecx
f0114f87:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114f89:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0114f8f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114f94:	b0 00                	mov    $0x0,%al
f0114f96:	89 d7                	mov    %edx,%edi
f0114f98:	f3 aa                	rep stos %al,%es:(%edi)
f0114f9a:	83 ec 0c             	sub    $0xc,%esp
f0114f9d:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0114fa3:	50                   	push   %eax
f0114fa4:	e8 33 cf fe ff       	call   f0101edc <execute_command>
f0114fa9:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0114fac:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0114fb2:	bb c5 d9 12 f0       	mov    $0xf012d9c5,%ebx
f0114fb7:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114fbc:	89 c7                	mov    %eax,%edi
f0114fbe:	89 de                	mov    %ebx,%esi
f0114fc0:	89 d1                	mov    %edx,%ecx
f0114fc2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114fc4:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0114fca:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114fcf:	b0 00                	mov    $0x0,%al
f0114fd1:	89 d7                	mov    %edx,%edi
f0114fd3:	f3 aa                	rep stos %al,%es:(%edi)
f0114fd5:	83 ec 0c             	sub    $0xc,%esp
f0114fd8:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0114fde:	50                   	push   %eax
f0114fdf:	e8 f8 ce fe ff       	call   f0101edc <execute_command>
f0114fe4:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f0114fe7:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0114fed:	bb 29 da 12 f0       	mov    $0xf012da29,%ebx
f0114ff2:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114ff7:	89 c7                	mov    %eax,%edi
f0114ff9:	89 de                	mov    %ebx,%esi
f0114ffb:	89 d1                	mov    %edx,%ecx
f0114ffd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114fff:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0115005:	b9 55 00 00 00       	mov    $0x55,%ecx
f011500a:	b0 00                	mov    $0x0,%al
f011500c:	89 d7                	mov    %edx,%edi
f011500e:	f3 aa                	rep stos %al,%es:(%edi)
f0115010:	83 ec 0c             	sub    $0xc,%esp
f0115013:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0115019:	50                   	push   %eax
f011501a:	e8 bd ce fe ff       	call   f0101edc <execute_command>
f011501f:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0115022:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0115028:	bb 8d da 12 f0       	mov    $0xf012da8d,%ebx
f011502d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115032:	89 c7                	mov    %eax,%edi
f0115034:	89 de                	mov    %ebx,%esi
f0115036:	89 d1                	mov    %edx,%ecx
f0115038:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011503a:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0115040:	b9 55 00 00 00       	mov    $0x55,%ecx
f0115045:	b0 00                	mov    $0x0,%al
f0115047:	89 d7                	mov    %edx,%edi
f0115049:	f3 aa                	rep stos %al,%es:(%edi)
f011504b:	83 ec 0c             	sub    $0xc,%esp
f011504e:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0115054:	50                   	push   %eax
f0115055:	e8 82 ce fe ff       	call   f0101edc <execute_command>
f011505a:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f011505d:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0115063:	bb f1 da 12 f0       	mov    $0xf012daf1,%ebx
f0115068:	ba 0f 00 00 00       	mov    $0xf,%edx
f011506d:	89 c7                	mov    %eax,%edi
f011506f:	89 de                	mov    %ebx,%esi
f0115071:	89 d1                	mov    %edx,%ecx
f0115073:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115075:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f011507b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0115080:	b0 00                	mov    $0x0,%al
f0115082:	89 d7                	mov    %edx,%edi
f0115084:	f3 aa                	rep stos %al,%es:(%edi)
f0115086:	83 ec 0c             	sub    $0xc,%esp
f0115089:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f011508f:	50                   	push   %eax
f0115090:	e8 47 ce fe ff       	call   f0101edc <execute_command>
f0115095:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0115098:	83 ec 04             	sub    $0x4,%esp
f011509b:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01150a1:	50                   	push   %eax
f01150a2:	68 8e d3 12 f0       	push   $0xf012d38e
f01150a7:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01150ad:	50                   	push   %eax
f01150ae:	e8 d8 d8 00 00       	call   f012298b <strcconcat>
f01150b3:	83 c4 10             	add    $0x10,%esp
f01150b6:	83 ec 0c             	sub    $0xc,%esp
f01150b9:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01150bf:	50                   	push   %eax
f01150c0:	e8 17 ce fe ff       	call   f0101edc <execute_command>
f01150c5:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f01150c8:	83 ec 04             	sub    $0x4,%esp
f01150cb:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01150d1:	50                   	push   %eax
f01150d2:	68 98 d3 12 f0       	push   $0xf012d398
f01150d7:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01150dd:	50                   	push   %eax
f01150de:	e8 a8 d8 00 00       	call   f012298b <strcconcat>
f01150e3:	83 c4 10             	add    $0x10,%esp
f01150e6:	83 ec 0c             	sub    $0xc,%esp
f01150e9:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01150ef:	50                   	push   %eax
f01150f0:	e8 e7 cd fe ff       	call   f0101edc <execute_command>
f01150f5:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f01150f8:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01150fe:	bb 55 db 12 f0       	mov    $0xf012db55,%ebx
f0115103:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115108:	89 c7                	mov    %eax,%edi
f011510a:	89 de                	mov    %ebx,%esi
f011510c:	89 d1                	mov    %edx,%ecx
f011510e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115110:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0115116:	b9 55 00 00 00       	mov    $0x55,%ecx
f011511b:	b0 00                	mov    $0x0,%al
f011511d:	89 d7                	mov    %edx,%edi
f011511f:	f3 aa                	rep stos %al,%es:(%edi)
f0115121:	83 ec 0c             	sub    $0xc,%esp
f0115124:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011512a:	50                   	push   %eax
f011512b:	e8 ac cd fe ff       	call   f0101edc <execute_command>
f0115130:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0115133:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0115139:	bb b9 db 12 f0       	mov    $0xf012dbb9,%ebx
f011513e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115143:	89 c7                	mov    %eax,%edi
f0115145:	89 de                	mov    %ebx,%esi
f0115147:	89 d1                	mov    %edx,%ecx
f0115149:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011514b:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0115151:	b9 55 00 00 00       	mov    $0x55,%ecx
f0115156:	b0 00                	mov    $0x0,%al
f0115158:	89 d7                	mov    %edx,%edi
f011515a:	f3 aa                	rep stos %al,%es:(%edi)
f011515c:	83 ec 0c             	sub    $0xc,%esp
f011515f:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0115165:	50                   	push   %eax
f0115166:	e8 71 cd fe ff       	call   f0101edc <execute_command>
f011516b:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f011516e:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0115174:	bb 1d dc 12 f0       	mov    $0xf012dc1d,%ebx
f0115179:	ba 0f 00 00 00       	mov    $0xf,%edx
f011517e:	89 c7                	mov    %eax,%edi
f0115180:	89 de                	mov    %ebx,%esi
f0115182:	89 d1                	mov    %edx,%ecx
f0115184:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115186:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f011518c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0115191:	b0 00                	mov    $0x0,%al
f0115193:	89 d7                	mov    %edx,%edi
f0115195:	f3 aa                	rep stos %al,%es:(%edi)
f0115197:	83 ec 0c             	sub    $0xc,%esp
f011519a:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01151a0:	50                   	push   %eax
f01151a1:	e8 36 cd fe ff       	call   f0101edc <execute_command>
f01151a6:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f01151a9:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f01151b0:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f01151b7:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f01151be:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f01151c5:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f01151cc:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f01151d3:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f01151da:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f01151e1:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f01151e8:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f01151ef:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f01151f6:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f01151fd:	8b 45 90             	mov    -0x70(%ebp),%eax
f0115200:	8a 00                	mov    (%eax),%al
f0115202:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115208:	e8 d0 87 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011520d:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0115210:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115213:	89 d0                	mov    %edx,%eax
f0115215:	01 c0                	add    %eax,%eax
f0115217:	01 d0                	add    %edx,%eax
f0115219:	01 c0                	add    %eax,%eax
f011521b:	50                   	push   %eax
f011521c:	68 00 00 40 00       	push   $0x400000
f0115221:	68 00 00 20 00       	push   $0x200000
f0115226:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115229:	e8 91 44 ff ff       	call   f01096bf <copy_paste_chunk>
f011522e:	83 c4 10             	add    $0x10,%esp
f0115231:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115234:	e8 a4 87 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0115239:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f011523c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0115243:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0115247:	75 08                	jne    f0115251 <test_copy_paste_chunk+0x929>
f0115249:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011524c:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011524f:	74 2b                	je     f011527c <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0115251:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0115254:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0115257:	83 ec 0c             	sub    $0xc,%esp
f011525a:	50                   	push   %eax
f011525b:	ff 75 80             	pushl  -0x80(%ebp)
f011525e:	68 a4 d3 12 f0       	push   $0xf012d3a4
f0115263:	68 3f 03 00 00       	push   $0x33f
f0115268:	68 02 cb 12 f0       	push   $0xf012cb02
f011526d:	e8 45 b2 fe ff       	call   f01004b7 <_warn>
f0115272:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115275:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011527c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0115280:	74 04                	je     f0115286 <test_copy_paste_chunk+0x95e>
f0115282:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115286:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f011528d:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0115294:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0115297:	83 ec 08             	sub    $0x8,%esp
f011529a:	6a 01                	push   $0x1
f011529c:	6a 07                	push   $0x7
f011529e:	6a 07                	push   $0x7
f01152a0:	6a 07                	push   $0x7
f01152a2:	6a 07                	push   $0x7
f01152a4:	6a 01                	push   $0x1
f01152a6:	68 00 20 00 00       	push   $0x2000
f01152ab:	68 00 00 40 00       	push   $0x400000
f01152b0:	68 00 00 20 00       	push   $0x200000
f01152b5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01152b8:	e8 0a 36 00 00       	call   f01188c7 <CCP>
f01152bd:	83 c4 30             	add    $0x30,%esp
f01152c0:	83 f8 01             	cmp    $0x1,%eax
f01152c3:	74 2b                	je     f01152f0 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f01152c5:	83 ec 04             	sub    $0x4,%esp
f01152c8:	68 f8 d3 12 f0       	push   $0xf012d3f8
f01152cd:	68 48 03 00 00       	push   $0x348
f01152d2:	68 02 cb 12 f0       	push   $0xf012cb02
f01152d7:	e8 db b1 fe ff       	call   f01004b7 <_warn>
f01152dc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01152df:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f01152e6:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f01152ed:	00 00 00 
		}
		if (correct) eval += 5 ;
f01152f0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01152f4:	74 04                	je     f01152fa <test_copy_paste_chunk+0x9d2>
f01152f6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01152fa:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0115301:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115304:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f0115307:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011530a:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f011530d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0115310:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0115313:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115316:	8a 00                	mov    (%eax),%al
f0115318:	3c 61                	cmp    $0x61,%al
f011531a:	75 69                	jne    f0115385 <test_copy_paste_chunk+0xa5d>
f011531c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011531f:	8a 00                	mov    (%eax),%al
f0115321:	3c 61                	cmp    $0x61,%al
f0115323:	75 60                	jne    f0115385 <test_copy_paste_chunk+0xa5d>
f0115325:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115328:	8a 00                	mov    (%eax),%al
f011532a:	3c 79                	cmp    $0x79,%al
f011532c:	75 57                	jne    f0115385 <test_copy_paste_chunk+0xa5d>
f011532e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0115331:	8a 00                	mov    (%eax),%al
f0115333:	3c 62                	cmp    $0x62,%al
f0115335:	75 4e                	jne    f0115385 <test_copy_paste_chunk+0xa5d>
f0115337:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011533a:	8a 00                	mov    (%eax),%al
f011533c:	3c 63                	cmp    $0x63,%al
f011533e:	75 45                	jne    f0115385 <test_copy_paste_chunk+0xa5d>
f0115340:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0115343:	8a 00                	mov    (%eax),%al
f0115345:	3c 7a                	cmp    $0x7a,%al
f0115347:	75 3c                	jne    f0115385 <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f0115349:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011534c:	8a 00                	mov    (%eax),%al
f011534e:	3c 77                	cmp    $0x77,%al
f0115350:	75 33                	jne    f0115385 <test_copy_paste_chunk+0xa5d>
f0115352:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0115355:	8a 00                	mov    (%eax),%al
f0115357:	3c 64                	cmp    $0x64,%al
f0115359:	75 2a                	jne    f0115385 <test_copy_paste_chunk+0xa5d>
f011535b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011535e:	8a 00                	mov    (%eax),%al
f0115360:	3c 65                	cmp    $0x65,%al
f0115362:	75 21                	jne    f0115385 <test_copy_paste_chunk+0xa5d>
f0115364:	8b 45 98             	mov    -0x68(%ebp),%eax
f0115367:	8a 00                	mov    (%eax),%al
f0115369:	3c 65                	cmp    $0x65,%al
f011536b:	75 18                	jne    f0115385 <test_copy_paste_chunk+0xa5d>
f011536d:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0115370:	8a 00                	mov    (%eax),%al
f0115372:	3c 66                	cmp    $0x66,%al
f0115374:	75 0f                	jne    f0115385 <test_copy_paste_chunk+0xa5d>
f0115376:	8b 45 90             	mov    -0x70(%ebp),%eax
f0115379:	8a 10                	mov    (%eax),%dl
f011537b:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0115381:	38 c2                	cmp    %al,%dl
f0115383:	74 21                	je     f01153a6 <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0115385:	83 ec 04             	sub    $0x4,%esp
f0115388:	68 f8 d2 12 f0       	push   $0xf012d2f8
f011538d:	68 56 03 00 00       	push   $0x356
f0115392:	68 02 cb 12 f0       	push   $0xf012cb02
f0115397:	e8 1b b1 fe ff       	call   f01004b7 <_warn>
f011539c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011539f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01153a6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01153aa:	74 04                	je     f01153b0 <test_copy_paste_chunk+0xa88>
f01153ac:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01153b0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f01153b7:	8b 45 98             	mov    -0x68(%ebp),%eax
f01153ba:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01153bd:	e8 1b 86 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01153c2:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f01153c5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01153c8:	89 c2                	mov    %eax,%edx
f01153ca:	01 d2                	add    %edx,%edx
f01153cc:	01 d0                	add    %edx,%eax
f01153ce:	50                   	push   %eax
f01153cf:	68 00 08 20 00       	push   $0x200800
f01153d4:	68 00 08 40 00       	push   $0x400800
f01153d9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01153dc:	e8 de 42 ff ff       	call   f01096bf <copy_paste_chunk>
f01153e1:	83 c4 10             	add    $0x10,%esp
f01153e4:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01153e7:	e8 f1 85 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01153ec:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01153ef:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01153f3:	75 08                	jne    f01153fd <test_copy_paste_chunk+0xad5>
f01153f5:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01153f8:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01153fb:	74 2b                	je     f0115428 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01153fd:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0115400:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0115403:	83 ec 0c             	sub    $0xc,%esp
f0115406:	50                   	push   %eax
f0115407:	ff 75 80             	pushl  -0x80(%ebp)
f011540a:	68 a4 d3 12 f0       	push   $0xf012d3a4
f011540f:	68 66 03 00 00       	push   $0x366
f0115414:	68 02 cb 12 f0       	push   $0xf012cb02
f0115419:	e8 99 b0 fe ff       	call   f01004b7 <_warn>
f011541e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115421:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0115428:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011542c:	74 04                	je     f0115432 <test_copy_paste_chunk+0xb0a>
f011542e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115432:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0115439:	83 ec 08             	sub    $0x8,%esp
f011543c:	6a 01                	push   $0x1
f011543e:	6a 07                	push   $0x7
f0115440:	6a 07                	push   $0x7
f0115442:	6a 07                	push   $0x7
f0115444:	6a 07                	push   $0x7
f0115446:	6a 01                	push   $0x1
f0115448:	68 00 20 00 00       	push   $0x2000
f011544d:	68 00 00 20 00       	push   $0x200000
f0115452:	68 00 00 40 00       	push   $0x400000
f0115457:	ff 75 d4             	pushl  -0x2c(%ebp)
f011545a:	e8 68 34 00 00       	call   f01188c7 <CCP>
f011545f:	83 c4 30             	add    $0x30,%esp
f0115462:	83 f8 01             	cmp    $0x1,%eax
f0115465:	74 21                	je     f0115488 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0115467:	83 ec 04             	sub    $0x4,%esp
f011546a:	68 44 d4 12 f0       	push   $0xf012d444
f011546f:	68 6e 03 00 00       	push   $0x36e
f0115474:	68 02 cb 12 f0       	push   $0xf012cb02
f0115479:	e8 39 b0 fe ff       	call   f01004b7 <_warn>
f011547e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115481:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0115488:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011548c:	74 04                	je     f0115492 <test_copy_paste_chunk+0xb6a>
f011548e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115492:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0115499:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011549c:	8a 00                	mov    (%eax),%al
f011549e:	3c 61                	cmp    $0x61,%al
f01154a0:	75 69                	jne    f011550b <test_copy_paste_chunk+0xbe3>
f01154a2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01154a5:	8a 00                	mov    (%eax),%al
f01154a7:	3c 61                	cmp    $0x61,%al
f01154a9:	75 60                	jne    f011550b <test_copy_paste_chunk+0xbe3>
f01154ab:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01154ae:	8a 00                	mov    (%eax),%al
f01154b0:	3c 79                	cmp    $0x79,%al
f01154b2:	75 57                	jne    f011550b <test_copy_paste_chunk+0xbe3>
f01154b4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01154b7:	8a 00                	mov    (%eax),%al
f01154b9:	3c 62                	cmp    $0x62,%al
f01154bb:	75 4e                	jne    f011550b <test_copy_paste_chunk+0xbe3>
f01154bd:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01154c0:	8a 00                	mov    (%eax),%al
f01154c2:	3c 7a                	cmp    $0x7a,%al
f01154c4:	75 45                	jne    f011550b <test_copy_paste_chunk+0xbe3>
f01154c6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01154c9:	8a 00                	mov    (%eax),%al
f01154cb:	3c 7a                	cmp    $0x7a,%al
f01154cd:	75 3c                	jne    f011550b <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f01154cf:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01154d2:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f01154d4:	3c 64                	cmp    $0x64,%al
f01154d6:	75 33                	jne    f011550b <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f01154d8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01154db:	8a 00                	mov    (%eax),%al
f01154dd:	3c 64                	cmp    $0x64,%al
f01154df:	75 2a                	jne    f011550b <test_copy_paste_chunk+0xbe3>
f01154e1:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01154e4:	8a 00                	mov    (%eax),%al
f01154e6:	3c 65                	cmp    $0x65,%al
f01154e8:	75 21                	jne    f011550b <test_copy_paste_chunk+0xbe3>
f01154ea:	8b 45 98             	mov    -0x68(%ebp),%eax
f01154ed:	8a 00                	mov    (%eax),%al
f01154ef:	3c 78                	cmp    $0x78,%al
f01154f1:	75 18                	jne    f011550b <test_copy_paste_chunk+0xbe3>
f01154f3:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01154f6:	8a 00                	mov    (%eax),%al
f01154f8:	3c 66                	cmp    $0x66,%al
f01154fa:	75 0f                	jne    f011550b <test_copy_paste_chunk+0xbe3>
f01154fc:	8b 45 90             	mov    -0x70(%ebp),%eax
f01154ff:	8a 10                	mov    (%eax),%dl
f0115501:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0115507:	38 c2                	cmp    %al,%dl
f0115509:	74 21                	je     f011552c <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011550b:	83 ec 04             	sub    $0x4,%esp
f011550e:	68 f8 d2 12 f0       	push   $0xf012d2f8
f0115513:	68 77 03 00 00       	push   $0x377
f0115518:	68 02 cb 12 f0       	push   $0xf012cb02
f011551d:	e8 95 af fe ff       	call   f01004b7 <_warn>
f0115522:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115525:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011552c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0115530:	74 04                	je     f0115536 <test_copy_paste_chunk+0xc0e>
f0115532:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115536:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f011553d:	83 ec 0c             	sub    $0xc,%esp
f0115540:	68 8f d4 12 f0       	push   $0xf012d48f
f0115545:	e8 22 ba fe ff       	call   f0100f6c <cprintf>
f011554a:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f011554d:	83 ec 0c             	sub    $0xc,%esp
f0115550:	68 a0 d4 12 f0       	push   $0xf012d4a0
f0115555:	e8 12 ba fe ff       	call   f0100f6c <cprintf>
f011555a:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f011555d:	83 ec 04             	sub    $0x4,%esp
f0115560:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0115566:	50                   	push   %eax
f0115567:	68 d4 d4 12 f0       	push   $0xf012d4d4
f011556c:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0115572:	50                   	push   %eax
f0115573:	e8 13 d4 00 00       	call   f012298b <strcconcat>
f0115578:	83 c4 10             	add    $0x10,%esp
f011557b:	83 ec 0c             	sub    $0xc,%esp
f011557e:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0115584:	50                   	push   %eax
f0115585:	e8 52 c9 fe ff       	call   f0101edc <execute_command>
f011558a:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f011558d:	83 ec 04             	sub    $0x4,%esp
f0115590:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0115596:	50                   	push   %eax
f0115597:	68 de d4 12 f0       	push   $0xf012d4de
f011559c:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01155a2:	50                   	push   %eax
f01155a3:	e8 e3 d3 00 00       	call   f012298b <strcconcat>
f01155a8:	83 c4 10             	add    $0x10,%esp
f01155ab:	83 ec 0c             	sub    $0xc,%esp
f01155ae:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01155b4:	50                   	push   %eax
f01155b5:	e8 22 c9 fe ff       	call   f0101edc <execute_command>
f01155ba:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f01155bd:	83 ec 04             	sub    $0x4,%esp
f01155c0:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01155c6:	50                   	push   %eax
f01155c7:	68 e8 d4 12 f0       	push   $0xf012d4e8
f01155cc:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01155d2:	50                   	push   %eax
f01155d3:	e8 b3 d3 00 00       	call   f012298b <strcconcat>
f01155d8:	83 c4 10             	add    $0x10,%esp
f01155db:	83 ec 0c             	sub    $0xc,%esp
f01155de:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01155e4:	50                   	push   %eax
f01155e5:	e8 f2 c8 fe ff       	call   f0101edc <execute_command>
f01155ea:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f01155ed:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01155f3:	bb 81 dc 12 f0       	mov    $0xf012dc81,%ebx
f01155f8:	ba 0f 00 00 00       	mov    $0xf,%edx
f01155fd:	89 c7                	mov    %eax,%edi
f01155ff:	89 de                	mov    %ebx,%esi
f0115601:	89 d1                	mov    %edx,%ecx
f0115603:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115605:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f011560b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0115610:	b0 00                	mov    $0x0,%al
f0115612:	89 d7                	mov    %edx,%edi
f0115614:	f3 aa                	rep stos %al,%es:(%edi)
f0115616:	83 ec 0c             	sub    $0xc,%esp
f0115619:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011561f:	50                   	push   %eax
f0115620:	e8 b7 c8 fe ff       	call   f0101edc <execute_command>
f0115625:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0115628:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011562e:	bb e5 dc 12 f0       	mov    $0xf012dce5,%ebx
f0115633:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115638:	89 c7                	mov    %eax,%edi
f011563a:	89 de                	mov    %ebx,%esi
f011563c:	89 d1                	mov    %edx,%ecx
f011563e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115640:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0115646:	b9 55 00 00 00       	mov    $0x55,%ecx
f011564b:	b0 00                	mov    $0x0,%al
f011564d:	89 d7                	mov    %edx,%edi
f011564f:	f3 aa                	rep stos %al,%es:(%edi)
f0115651:	83 ec 0c             	sub    $0xc,%esp
f0115654:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011565a:	50                   	push   %eax
f011565b:	e8 7c c8 fe ff       	call   f0101edc <execute_command>
f0115660:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0115663:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0115669:	bb 49 dd 12 f0       	mov    $0xf012dd49,%ebx
f011566e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115673:	89 c7                	mov    %eax,%edi
f0115675:	89 de                	mov    %ebx,%esi
f0115677:	89 d1                	mov    %edx,%ecx
f0115679:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011567b:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0115681:	b9 55 00 00 00       	mov    $0x55,%ecx
f0115686:	b0 00                	mov    $0x0,%al
f0115688:	89 d7                	mov    %edx,%edi
f011568a:	f3 aa                	rep stos %al,%es:(%edi)
f011568c:	83 ec 0c             	sub    $0xc,%esp
f011568f:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0115695:	50                   	push   %eax
f0115696:	e8 41 c8 fe ff       	call   f0101edc <execute_command>
f011569b:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011569e:	e8 3a 83 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01156a3:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f01156a6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01156a9:	89 d0                	mov    %edx,%eax
f01156ab:	01 c0                	add    %eax,%eax
f01156ad:	01 d0                	add    %edx,%eax
f01156af:	c1 e0 02             	shl    $0x2,%eax
f01156b2:	50                   	push   %eax
f01156b3:	68 00 00 90 00       	push   $0x900000
f01156b8:	68 00 00 80 00       	push   $0x800000
f01156bd:	ff 75 d4             	pushl  -0x2c(%ebp)
f01156c0:	e8 fa 3f ff ff       	call   f01096bf <copy_paste_chunk>
f01156c5:	83 c4 10             	add    $0x10,%esp
f01156c8:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01156ce:	e8 0a 83 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01156d3:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f01156d6:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f01156dd:	75 0b                	jne    f01156ea <test_copy_paste_chunk+0xdc2>
f01156df:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01156e2:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01156e5:	83 f8 03             	cmp    $0x3,%eax
f01156e8:	74 2e                	je     f0115718 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01156ea:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01156ed:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01156f0:	83 ec 0c             	sub    $0xc,%esp
f01156f3:	50                   	push   %eax
f01156f4:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f01156fa:	68 a4 d3 12 f0       	push   $0xf012d3a4
f01156ff:	68 95 03 00 00       	push   $0x395
f0115704:	68 02 cb 12 f0       	push   $0xf012cb02
f0115709:	e8 a9 ad fe ff       	call   f01004b7 <_warn>
f011570e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115711:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0115718:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011571c:	74 04                	je     f0115722 <test_copy_paste_chunk+0xdfa>
f011571e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115722:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0115729:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0115730:	83 ec 08             	sub    $0x8,%esp
f0115733:	6a 01                	push   $0x1
f0115735:	6a 07                	push   $0x7
f0115737:	6a 07                	push   $0x7
f0115739:	6a 07                	push   $0x7
f011573b:	6a 07                	push   $0x7
f011573d:	6a 01                	push   $0x1
f011573f:	68 00 30 00 00       	push   $0x3000
f0115744:	68 00 00 90 00       	push   $0x900000
f0115749:	68 00 00 80 00       	push   $0x800000
f011574e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115751:	e8 71 31 00 00       	call   f01188c7 <CCP>
f0115756:	83 c4 30             	add    $0x30,%esp
f0115759:	83 f8 01             	cmp    $0x1,%eax
f011575c:	74 28                	je     f0115786 <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f011575e:	83 ec 04             	sub    $0x4,%esp
f0115761:	68 44 d4 12 f0       	push   $0xf012d444
f0115766:	68 9e 03 00 00       	push   $0x39e
f011576b:	68 02 cb 12 f0       	push   $0xf012cb02
f0115770:	e8 42 ad fe ff       	call   f01004b7 <_warn>
f0115775:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115778:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f011577f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0115786:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011578a:	74 04                	je     f0115790 <test_copy_paste_chunk+0xe68>
f011578c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115790:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0115797:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011579b:	0f 84 9e 00 00 00    	je     f011583f <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f01157a1:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f01157a8:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f01157af:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f01157b6:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f01157bd:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f01157c4:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f01157cb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01157ce:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f01157d1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01157d4:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f01157d7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01157da:	8a 00                	mov    (%eax),%al
f01157dc:	3c 61                	cmp    $0x61,%al
f01157de:	75 2d                	jne    f011580d <test_copy_paste_chunk+0xee5>
f01157e0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01157e3:	8a 00                	mov    (%eax),%al
f01157e5:	3c 61                	cmp    $0x61,%al
f01157e7:	75 24                	jne    f011580d <test_copy_paste_chunk+0xee5>
f01157e9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01157ec:	8a 00                	mov    (%eax),%al
f01157ee:	3c 79                	cmp    $0x79,%al
f01157f0:	75 1b                	jne    f011580d <test_copy_paste_chunk+0xee5>
f01157f2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01157f5:	8a 00                	mov    (%eax),%al
f01157f7:	3c 62                	cmp    $0x62,%al
f01157f9:	75 12                	jne    f011580d <test_copy_paste_chunk+0xee5>
f01157fb:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01157fe:	8a 00                	mov    (%eax),%al
f0115800:	3c 63                	cmp    $0x63,%al
f0115802:	75 09                	jne    f011580d <test_copy_paste_chunk+0xee5>
f0115804:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0115807:	8a 00                	mov    (%eax),%al
f0115809:	3c 7a                	cmp    $0x7a,%al
f011580b:	74 21                	je     f011582e <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011580d:	83 ec 04             	sub    $0x4,%esp
f0115810:	68 f8 d2 12 f0       	push   $0xf012d2f8
f0115815:	68 b0 03 00 00       	push   $0x3b0
f011581a:	68 02 cb 12 f0       	push   $0xf012cb02
f011581f:	e8 93 ac fe ff       	call   f01004b7 <_warn>
f0115824:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0115827:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f011582e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0115832:	74 04                	je     f0115838 <test_copy_paste_chunk+0xf10>
f0115834:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0115838:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011583f:	e8 99 81 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0115844:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0115847:	6a 00                	push   $0x0
f0115849:	6a 02                	push   $0x2
f011584b:	68 00 10 90 00       	push   $0x901000
f0115850:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115853:	e8 b1 2b 00 00       	call   f0118409 <SB>
f0115858:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f011585b:	6a 00                	push   $0x0
f011585d:	6a 02                	push   $0x2
f011585f:	68 00 20 90 00       	push   $0x902000
f0115864:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115867:	e8 9d 2b 00 00       	call   f0118409 <SB>
f011586c:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f011586f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115872:	c1 e0 03             	shl    $0x3,%eax
f0115875:	50                   	push   %eax
f0115876:	68 00 f0 bf 00       	push   $0xbff000
f011587b:	68 00 10 90 00       	push   $0x901000
f0115880:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115883:	e8 37 3e ff ff       	call   f01096bf <copy_paste_chunk>
f0115888:	83 c4 10             	add    $0x10,%esp
f011588b:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115891:	e8 47 81 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0115896:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0115899:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f01158a0:	75 0b                	jne    f01158ad <test_copy_paste_chunk+0xf85>
f01158a2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01158a5:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01158a8:	83 f8 03             	cmp    $0x3,%eax
f01158ab:	74 2e                	je     f01158db <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01158ad:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01158b0:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01158b3:	83 ec 0c             	sub    $0xc,%esp
f01158b6:	50                   	push   %eax
f01158b7:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f01158bd:	68 a4 d3 12 f0       	push   $0xf012d3a4
f01158c2:	68 c0 03 00 00       	push   $0x3c0
f01158c7:	68 02 cb 12 f0       	push   $0xf012cb02
f01158cc:	e8 e6 ab fe ff       	call   f01004b7 <_warn>
f01158d1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158d4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01158db:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01158df:	74 04                	je     f01158e5 <test_copy_paste_chunk+0xfbd>
f01158e1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01158e5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f01158ec:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f01158f3:	83 ec 08             	sub    $0x8,%esp
f01158f6:	6a 01                	push   $0x1
f01158f8:	6a 07                	push   $0x7
f01158fa:	6a 03                	push   $0x3
f01158fc:	6a 07                	push   $0x7
f01158fe:	6a 03                	push   $0x3
f0115900:	6a 01                	push   $0x1
f0115902:	68 00 20 00 00       	push   $0x2000
f0115907:	68 00 f0 bf 00       	push   $0xbff000
f011590c:	68 00 10 90 00       	push   $0x901000
f0115911:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115914:	e8 ae 2f 00 00       	call   f01188c7 <CCP>
f0115919:	83 c4 30             	add    $0x30,%esp
f011591c:	83 f8 01             	cmp    $0x1,%eax
f011591f:	74 28                	je     f0115949 <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0115921:	83 ec 04             	sub    $0x4,%esp
f0115924:	68 44 d4 12 f0       	push   $0xf012d444
f0115929:	68 c9 03 00 00       	push   $0x3c9
f011592e:	68 02 cb 12 f0       	push   $0xf012cb02
f0115933:	e8 7f ab fe ff       	call   f01004b7 <_warn>
f0115938:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011593b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0115942:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0115949:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011594d:	74 04                	je     f0115953 <test_copy_paste_chunk+0x102b>
f011594f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115953:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f011595a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011595e:	74 72                	je     f01159d2 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0115960:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0115967:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f011596e:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0115975:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f011597c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011597f:	8a 00                	mov    (%eax),%al
f0115981:	3c 62                	cmp    $0x62,%al
f0115983:	75 1b                	jne    f01159a0 <test_copy_paste_chunk+0x1078>
f0115985:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115988:	8a 00                	mov    (%eax),%al
f011598a:	3c 62                	cmp    $0x62,%al
f011598c:	75 12                	jne    f01159a0 <test_copy_paste_chunk+0x1078>
f011598e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115991:	8a 00                	mov    (%eax),%al
f0115993:	3c 7a                	cmp    $0x7a,%al
f0115995:	75 09                	jne    f01159a0 <test_copy_paste_chunk+0x1078>
f0115997:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011599a:	8a 00                	mov    (%eax),%al
f011599c:	3c 7a                	cmp    $0x7a,%al
f011599e:	74 21                	je     f01159c1 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01159a0:	83 ec 04             	sub    $0x4,%esp
f01159a3:	68 f8 d2 12 f0       	push   $0xf012d2f8
f01159a8:	68 d5 03 00 00       	push   $0x3d5
f01159ad:	68 02 cb 12 f0       	push   $0xf012cb02
f01159b2:	e8 00 ab fe ff       	call   f01004b7 <_warn>
f01159b7:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01159ba:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01159c1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01159c5:	74 04                	je     f01159cb <test_copy_paste_chunk+0x10a3>
f01159c7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01159cb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f01159d2:	83 ec 0c             	sub    $0xc,%esp
f01159d5:	68 f2 d4 12 f0       	push   $0xf012d4f2
f01159da:	e8 8d b5 fe ff       	call   f0100f6c <cprintf>
f01159df:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f01159e2:	83 ec 08             	sub    $0x8,%esp
f01159e5:	ff 75 e4             	pushl  -0x1c(%ebp)
f01159e8:	68 04 d5 12 f0       	push   $0xf012d504
f01159ed:	e8 7a b5 fe ff       	call   f0100f6c <cprintf>
f01159f2:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01159f5:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01159f9:	75 10                	jne    f0115a0b <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f01159fb:	83 ec 0c             	sub    $0xc,%esp
f01159fe:	68 38 d5 12 f0       	push   $0xf012d538
f0115a03:	e8 64 b5 fe ff       	call   f0100f6c <cprintf>
f0115a08:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115a0b:	a1 84 4b 5a f0       	mov    0xf05a4b84,%eax
f0115a10:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0115a13:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115a16:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115a19:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115a1e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115a21:	5b                   	pop    %ebx
f0115a22:	5e                   	pop    %esi
f0115a23:	5f                   	pop    %edi
f0115a24:	5d                   	pop    %ebp
f0115a25:	c3                   	ret    

f0115a26 <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0115a26:	55                   	push   %ebp
f0115a27:	89 e5                	mov    %esp,%ebp
f0115a29:	57                   	push   %edi
f0115a2a:	56                   	push   %esi
f0115a2b:	53                   	push   %ebx
f0115a2c:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115a32:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0115a38:	bb 04 d2 12 f0       	mov    $0xf012d204,%ebx
f0115a3d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115a42:	89 c7                	mov    %eax,%edi
f0115a44:	89 de                	mov    %ebx,%esi
f0115a46:	89 d1                	mov    %edx,%ecx
f0115a48:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115a4a:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0115a50:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115a55:	b0 00                	mov    $0x0,%al
f0115a57:	89 d7                	mov    %edx,%edi
f0115a59:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115a5b:	6a 00                	push   $0x0
f0115a5d:	6a 0a                	push   $0xa
f0115a5f:	6a 14                	push   $0x14
f0115a61:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0115a67:	50                   	push   %eax
f0115a68:	e8 d8 3f ff ff       	call   f0109a45 <env_create>
f0115a6d:	83 c4 10             	add    $0x10,%esp
f0115a70:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115a73:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115a76:	8b 40 64             	mov    0x64(%eax),%eax
f0115a79:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0115a7c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115a7f:	8b 40 68             	mov    0x68(%eax),%eax
f0115a82:	89 45 80             	mov    %eax,-0x80(%ebp)
f0115a85:	8b 45 80             	mov    -0x80(%ebp),%eax
f0115a88:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0115a8b:	83 ec 0c             	sub    $0xc,%esp
f0115a8e:	ff 75 cc             	pushl  -0x34(%ebp)
f0115a91:	e8 fd 2d 00 00       	call   f0118893 <ClearUserSpace>
f0115a96:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115a99:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0115aa0:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0115aa7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0115aae:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0115ab2:	83 ec 0c             	sub    $0xc,%esp
f0115ab5:	68 b0 dd 12 f0       	push   $0xf012ddb0
f0115aba:	e8 ad b4 fe ff       	call   f0100f6c <cprintf>
f0115abf:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0115ac2:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0115ac9:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0115ad0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115ad3:	8a 00                	mov    (%eax),%al
f0115ad5:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0115adb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115ade:	8a 00                	mov    (%eax),%al
f0115ae0:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115ae6:	e8 f2 7e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0115aeb:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0115aee:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115af1:	89 d0                	mov    %edx,%eax
f0115af3:	01 c0                	add    %eax,%eax
f0115af5:	01 d0                	add    %edx,%eax
f0115af7:	01 c0                	add    %eax,%eax
f0115af9:	83 ec 0c             	sub    $0xc,%esp
f0115afc:	6a 02                	push   $0x2
f0115afe:	50                   	push   %eax
f0115aff:	68 00 40 10 f0       	push   $0xf0104000
f0115b04:	68 00 00 10 f0       	push   $0xf0100000
f0115b09:	ff 75 cc             	pushl  -0x34(%ebp)
f0115b0c:	e8 c8 3b ff ff       	call   f01096d9 <share_chunk>
f0115b11:	83 c4 20             	add    $0x20,%esp
f0115b14:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115b17:	e8 c1 7e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0115b1c:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0115b1f:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0115b23:	75 08                	jne    f0115b2d <test_share_chunk+0x107>
f0115b25:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115b28:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0115b2b:	74 28                	je     f0115b55 <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0115b2d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115b30:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115b33:	83 ec 0c             	sub    $0xc,%esp
f0115b36:	50                   	push   %eax
f0115b37:	ff 75 b0             	pushl  -0x50(%ebp)
f0115b3a:	68 dc dd 12 f0       	push   $0xf012dddc
f0115b3f:	68 11 04 00 00       	push   $0x411
f0115b44:	68 02 cb 12 f0       	push   $0xf012cb02
f0115b49:	e8 69 a9 fe ff       	call   f01004b7 <_warn>
f0115b4e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b51:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115b55:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b59:	74 04                	je     f0115b5f <test_share_chunk+0x139>
f0115b5b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115b5f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0115b63:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115b66:	c1 e0 03             	shl    $0x3,%eax
f0115b69:	83 ec 08             	sub    $0x8,%esp
f0115b6c:	68 fd 00 00 00       	push   $0xfd
f0115b71:	6a 07                	push   $0x7
f0115b73:	6a 03                	push   $0x3
f0115b75:	6a 07                	push   $0x7
f0115b77:	6a 03                	push   $0x3
f0115b79:	6a 01                	push   $0x1
f0115b7b:	50                   	push   %eax
f0115b7c:	68 00 40 10 f0       	push   $0xf0104000
f0115b81:	68 00 00 10 f0       	push   $0xf0100000
f0115b86:	ff 75 cc             	pushl  -0x34(%ebp)
f0115b89:	e8 39 2d 00 00       	call   f01188c7 <CCP>
f0115b8e:	83 c4 30             	add    $0x30,%esp
f0115b91:	85 c0                	test   %eax,%eax
f0115b93:	75 1e                	jne    f0115bb3 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115b95:	83 ec 04             	sub    $0x4,%esp
f0115b98:	68 38 de 12 f0       	push   $0xf012de38
f0115b9d:	68 19 04 00 00       	push   $0x419
f0115ba2:	68 02 cb 12 f0       	push   $0xf012cb02
f0115ba7:	e8 0b a9 fe ff       	call   f01004b7 <_warn>
f0115bac:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115baf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115bb3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115bb7:	74 04                	je     f0115bbd <test_share_chunk+0x197>
f0115bb9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0115bbd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115bc0:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0115bc3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115bc6:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0115bc9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115bcc:	8a 00                	mov    (%eax),%al
f0115bce:	3c 41                	cmp    $0x41,%al
f0115bd0:	75 09                	jne    f0115bdb <test_share_chunk+0x1b5>
f0115bd2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115bd5:	8a 00                	mov    (%eax),%al
f0115bd7:	3c 42                	cmp    $0x42,%al
f0115bd9:	74 1e                	je     f0115bf9 <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0115bdb:	83 ec 04             	sub    $0x4,%esp
f0115bde:	68 80 de 12 f0       	push   $0xf012de80
f0115be3:	68 23 04 00 00       	push   $0x423
f0115be8:	68 02 cb 12 f0       	push   $0xf012cb02
f0115bed:	e8 c5 a8 fe ff       	call   f01004b7 <_warn>
f0115bf2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115bf5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115bf9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115bfd:	74 04                	je     f0115c03 <test_share_chunk+0x1dd>
f0115bff:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115c03:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0115c07:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0115c0d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115c10:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0115c12:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0115c18:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115c1b:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0115c1d:	83 ec 0c             	sub    $0xc,%esp
f0115c20:	68 b5 de 12 f0       	push   $0xf012deb5
f0115c25:	e8 42 b3 fe ff       	call   f0100f6c <cprintf>
f0115c2a:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0115c2d:	83 ec 0c             	sub    $0xc,%esp
f0115c30:	68 c4 de 12 f0       	push   $0xf012dec4
f0115c35:	e8 32 b3 fe ff       	call   f0100f6c <cprintf>
f0115c3a:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115c3d:	e8 9b 7d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0115c42:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0115c45:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115c48:	c1 e0 05             	shl    $0x5,%eax
f0115c4b:	83 ec 0c             	sub    $0xc,%esp
f0115c4e:	68 02 0e 00 00       	push   $0xe02
f0115c53:	50                   	push   %eax
f0115c54:	68 00 00 00 40       	push   $0x40000000
f0115c59:	68 00 00 00 f0       	push   $0xf0000000
f0115c5e:	ff 75 cc             	pushl  -0x34(%ebp)
f0115c61:	e8 73 3a ff ff       	call   f01096d9 <share_chunk>
f0115c66:	83 c4 20             	add    $0x20,%esp
f0115c69:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115c6c:	e8 6c 7d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0115c71:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0115c74:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0115c78:	75 1f                	jne    f0115c99 <test_share_chunk+0x273>
f0115c7a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115c7d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115c80:	89 c1                	mov    %eax,%ecx
f0115c82:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115c85:	c1 e0 05             	shl    $0x5,%eax
f0115c88:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115c8b:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115c92:	99                   	cltd   
f0115c93:	f7 fb                	idiv   %ebx
f0115c95:	39 c1                	cmp    %eax,%ecx
f0115c97:	74 28                	je     f0115cc1 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0115c99:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115c9c:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115c9f:	83 ec 0c             	sub    $0xc,%esp
f0115ca2:	50                   	push   %eax
f0115ca3:	ff 75 a8             	pushl  -0x58(%ebp)
f0115ca6:	68 00 df 12 f0       	push   $0xf012df00
f0115cab:	68 3b 04 00 00       	push   $0x43b
f0115cb0:	68 02 cb 12 f0       	push   $0xf012cb02
f0115cb5:	e8 fd a7 fe ff       	call   f01004b7 <_warn>
f0115cba:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115cbd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115cc1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115cc5:	74 04                	je     f0115ccb <test_share_chunk+0x2a5>
f0115cc7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115ccb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0115ccf:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0115cd6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115cd9:	c1 e0 05             	shl    $0x5,%eax
f0115cdc:	83 ec 08             	sub    $0x8,%esp
f0115cdf:	6a 02                	push   $0x2
f0115ce1:	6a 07                	push   $0x7
f0115ce3:	6a 03                	push   $0x3
f0115ce5:	68 07 0e 00 00       	push   $0xe07
f0115cea:	68 03 0e 00 00       	push   $0xe03
f0115cef:	6a ff                	push   $0xffffffff
f0115cf1:	50                   	push   %eax
f0115cf2:	68 00 00 00 40       	push   $0x40000000
f0115cf7:	68 00 00 00 f0       	push   $0xf0000000
f0115cfc:	ff 75 cc             	pushl  -0x34(%ebp)
f0115cff:	e8 c3 2b 00 00       	call   f01188c7 <CCP>
f0115d04:	83 c4 30             	add    $0x30,%esp
f0115d07:	85 c0                	test   %eax,%eax
f0115d09:	75 25                	jne    f0115d30 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115d0b:	83 ec 04             	sub    $0x4,%esp
f0115d0e:	68 38 de 12 f0       	push   $0xf012de38
f0115d13:	68 44 04 00 00       	push   $0x444
f0115d18:	68 02 cb 12 f0       	push   $0xf012cb02
f0115d1d:	e8 95 a7 fe ff       	call   f01004b7 <_warn>
f0115d22:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115d25:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0115d29:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0115d30:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115d33:	89 d0                	mov    %edx,%eax
f0115d35:	01 c0                	add    %eax,%eax
f0115d37:	01 d0                	add    %edx,%eax
f0115d39:	c1 e0 02             	shl    $0x2,%eax
f0115d3c:	83 ec 08             	sub    $0x8,%esp
f0115d3f:	6a 02                	push   $0x2
f0115d41:	6a 07                	push   $0x7
f0115d43:	6a 03                	push   $0x3
f0115d45:	68 07 0e 00 00       	push   $0xe07
f0115d4a:	68 03 0e 00 00       	push   $0xe03
f0115d4f:	6a 02                	push   $0x2
f0115d51:	50                   	push   %eax
f0115d52:	68 00 00 00 40       	push   $0x40000000
f0115d57:	68 00 00 00 f0       	push   $0xf0000000
f0115d5c:	ff 75 cc             	pushl  -0x34(%ebp)
f0115d5f:	e8 63 2b 00 00       	call   f01188c7 <CCP>
f0115d64:	83 c4 30             	add    $0x30,%esp
f0115d67:	85 c0                	test   %eax,%eax
f0115d69:	75 1e                	jne    f0115d89 <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115d6b:	83 ec 04             	sub    $0x4,%esp
f0115d6e:	68 38 de 12 f0       	push   $0xf012de38
f0115d73:	68 4b 04 00 00       	push   $0x44b
f0115d78:	68 02 cb 12 f0       	push   $0xf012cb02
f0115d7d:	e8 35 a7 fe ff       	call   f01004b7 <_warn>
f0115d82:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115d85:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115d89:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d8d:	74 04                	je     f0115d93 <test_share_chunk+0x36d>
f0115d8f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115d93:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0115d97:	b8 30 74 5c f0       	mov    $0xf05c7430,%eax
f0115d9c:	05 00 00 00 10       	add    $0x10000000,%eax
f0115da1:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0115da4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0115da7:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0115dac:	83 ec 08             	sub    $0x8,%esp
f0115daf:	6a 02                	push   $0x2
f0115db1:	6a 07                	push   $0x7
f0115db3:	6a 03                	push   $0x3
f0115db5:	68 07 0e 00 00       	push   $0xe07
f0115dba:	68 03 0e 00 00       	push   $0xe03
f0115dbf:	6a 02                	push   $0x2
f0115dc1:	50                   	push   %eax
f0115dc2:	68 00 00 0a 40       	push   $0x400a0000
f0115dc7:	68 00 00 0a f0       	push   $0xf00a0000
f0115dcc:	ff 75 cc             	pushl  -0x34(%ebp)
f0115dcf:	e8 f3 2a 00 00       	call   f01188c7 <CCP>
f0115dd4:	83 c4 30             	add    $0x30,%esp
f0115dd7:	85 c0                	test   %eax,%eax
f0115dd9:	75 1e                	jne    f0115df9 <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115ddb:	83 ec 04             	sub    $0x4,%esp
f0115dde:	68 38 de 12 f0       	push   $0xf012de38
f0115de3:	68 55 04 00 00       	push   $0x455
f0115de8:	68 02 cb 12 f0       	push   $0xf012cb02
f0115ded:	e8 c5 a6 fe ff       	call   f01004b7 <_warn>
f0115df2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115df5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115df9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115dfd:	74 04                	je     f0115e03 <test_share_chunk+0x3dd>
f0115dff:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115e03:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0115e07:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0115e0b:	0f 84 a4 00 00 00    	je     f0115eb5 <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0115e11:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0115e18:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115e1b:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0115e1e:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f0115e25:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115e28:	8a 00                	mov    (%eax),%al
f0115e2a:	3c 41                	cmp    $0x41,%al
f0115e2c:	75 09                	jne    f0115e37 <test_share_chunk+0x411>
f0115e2e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115e31:	8a 00                	mov    (%eax),%al
f0115e33:	3c 41                	cmp    $0x41,%al
f0115e35:	74 1e                	je     f0115e55 <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0115e37:	83 ec 04             	sub    $0x4,%esp
f0115e3a:	68 80 de 12 f0       	push   $0xf012de80
f0115e3f:	68 62 04 00 00       	push   $0x462
f0115e44:	68 02 cb 12 f0       	push   $0xf012cb02
f0115e49:	e8 69 a6 fe ff       	call   f01004b7 <_warn>
f0115e4e:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0115e51:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0115e55:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e59:	74 04                	je     f0115e5f <test_share_chunk+0x439>
f0115e5b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0115e5f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0115e63:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0115e6a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115e6d:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0115e70:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0115e77:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115e7a:	8a 00                	mov    (%eax),%al
f0115e7c:	3c 43                	cmp    $0x43,%al
f0115e7e:	75 09                	jne    f0115e89 <test_share_chunk+0x463>
f0115e80:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115e83:	8a 00                	mov    (%eax),%al
f0115e85:	3c 43                	cmp    $0x43,%al
f0115e87:	74 1e                	je     f0115ea7 <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0115e89:	83 ec 04             	sub    $0x4,%esp
f0115e8c:	68 80 de 12 f0       	push   $0xf012de80
f0115e91:	68 6d 04 00 00       	push   $0x46d
f0115e96:	68 02 cb 12 f0       	push   $0xf012cb02
f0115e9b:	e8 17 a6 fe ff       	call   f01004b7 <_warn>
f0115ea0:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0115ea3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0115ea7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115eab:	74 04                	je     f0115eb1 <test_share_chunk+0x48b>
f0115ead:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0115eb1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0115eb5:	83 ec 0c             	sub    $0xc,%esp
f0115eb8:	68 8f d4 12 f0       	push   $0xf012d48f
f0115ebd:	e8 aa b0 fe ff       	call   f0100f6c <cprintf>
f0115ec2:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0115ec5:	83 ec 0c             	sub    $0xc,%esp
f0115ec8:	68 50 df 12 f0       	push   $0xf012df50
f0115ecd:	e8 9a b0 fe ff       	call   f0100f6c <cprintf>
f0115ed2:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115ed5:	e8 03 7b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0115eda:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f0115edd:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115ee0:	89 d0                	mov    %edx,%eax
f0115ee2:	c1 e0 03             	shl    $0x3,%eax
f0115ee5:	01 d0                	add    %edx,%eax
f0115ee7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0115eee:	01 d0                	add    %edx,%eax
f0115ef0:	c1 e0 03             	shl    $0x3,%eax
f0115ef3:	83 ec 0c             	sub    $0xc,%esp
f0115ef6:	6a 06                	push   $0x6
f0115ef8:	50                   	push   %eax
f0115ef9:	6a 00                	push   $0x0
f0115efb:	68 00 00 00 40       	push   $0x40000000
f0115f00:	ff 75 cc             	pushl  -0x34(%ebp)
f0115f03:	e8 d1 37 ff ff       	call   f01096d9 <share_chunk>
f0115f08:	83 c4 20             	add    $0x20,%esp
f0115f0b:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115f0e:	e8 ca 7a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0115f13:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0115f16:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0115f1a:	75 0b                	jne    f0115f27 <test_share_chunk+0x501>
f0115f1c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115f1f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115f22:	83 f8 01             	cmp    $0x1,%eax
f0115f25:	74 28                	je     f0115f4f <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0115f27:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115f2a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115f2d:	83 ec 0c             	sub    $0xc,%esp
f0115f30:	50                   	push   %eax
f0115f31:	ff 75 a0             	pushl  -0x60(%ebp)
f0115f34:	68 00 df 12 f0       	push   $0xf012df00
f0115f39:	68 83 04 00 00       	push   $0x483
f0115f3e:	68 02 cb 12 f0       	push   $0xf012cb02
f0115f43:	e8 6f a5 fe ff       	call   f01004b7 <_warn>
f0115f48:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f4b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f4f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f53:	74 04                	je     f0115f59 <test_share_chunk+0x533>
f0115f55:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f59:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0115f5d:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0115f64:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115f67:	05 00 80 02 00       	add    $0x28000,%eax
f0115f6c:	c1 e0 02             	shl    $0x2,%eax
f0115f6f:	83 ec 08             	sub    $0x8,%esp
f0115f72:	6a 02                	push   $0x2
f0115f74:	6a 07                	push   $0x7
f0115f76:	6a 03                	push   $0x3
f0115f78:	6a 07                	push   $0x7
f0115f7a:	6a 07                	push   $0x7
f0115f7c:	6a ff                	push   $0xffffffff
f0115f7e:	50                   	push   %eax
f0115f7f:	6a 00                	push   $0x0
f0115f81:	68 00 00 00 40       	push   $0x40000000
f0115f86:	ff 75 cc             	pushl  -0x34(%ebp)
f0115f89:	e8 39 29 00 00       	call   f01188c7 <CCP>
f0115f8e:	83 c4 30             	add    $0x30,%esp
f0115f91:	85 c0                	test   %eax,%eax
f0115f93:	75 25                	jne    f0115fba <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115f95:	83 ec 04             	sub    $0x4,%esp
f0115f98:	68 38 de 12 f0       	push   $0xf012de38
f0115f9d:	68 8c 04 00 00       	push   $0x48c
f0115fa2:	68 02 cb 12 f0       	push   $0xf012cb02
f0115fa7:	e8 0b a5 fe ff       	call   f01004b7 <_warn>
f0115fac:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115faf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0115fb3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0115fba:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115fbd:	89 d0                	mov    %edx,%eax
f0115fbf:	01 c0                	add    %eax,%eax
f0115fc1:	01 d0                	add    %edx,%eax
f0115fc3:	c1 e0 02             	shl    $0x2,%eax
f0115fc6:	83 ec 08             	sub    $0x8,%esp
f0115fc9:	6a 02                	push   $0x2
f0115fcb:	6a 07                	push   $0x7
f0115fcd:	6a 03                	push   $0x3
f0115fcf:	6a 07                	push   $0x7
f0115fd1:	6a 07                	push   $0x7
f0115fd3:	6a 03                	push   $0x3
f0115fd5:	50                   	push   %eax
f0115fd6:	6a 00                	push   $0x0
f0115fd8:	68 00 00 00 40       	push   $0x40000000
f0115fdd:	ff 75 cc             	pushl  -0x34(%ebp)
f0115fe0:	e8 e2 28 00 00       	call   f01188c7 <CCP>
f0115fe5:	83 c4 30             	add    $0x30,%esp
f0115fe8:	85 c0                	test   %eax,%eax
f0115fea:	75 1e                	jne    f011600a <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115fec:	83 ec 04             	sub    $0x4,%esp
f0115fef:	68 38 de 12 f0       	push   $0xf012de38
f0115ff4:	68 93 04 00 00       	push   $0x493
f0115ff9:	68 02 cb 12 f0       	push   $0xf012cb02
f0115ffe:	e8 b4 a4 fe ff       	call   f01004b7 <_warn>
f0116003:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116006:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011600a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011600e:	74 04                	je     f0116014 <test_share_chunk+0x5ee>
f0116010:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116014:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0116018:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011601b:	89 d0                	mov    %edx,%eax
f011601d:	01 c0                	add    %eax,%eax
f011601f:	01 d0                	add    %edx,%eax
f0116021:	c1 e0 02             	shl    $0x2,%eax
f0116024:	f7 d8                	neg    %eax
f0116026:	05 00 00 0a 00       	add    $0xa0000,%eax
f011602b:	83 ec 08             	sub    $0x8,%esp
f011602e:	6a 02                	push   $0x2
f0116030:	6a 07                	push   $0x7
f0116032:	6a 03                	push   $0x3
f0116034:	6a 07                	push   $0x7
f0116036:	6a 07                	push   $0x7
f0116038:	6a 02                	push   $0x2
f011603a:	50                   	push   %eax
f011603b:	68 00 30 00 00       	push   $0x3000
f0116040:	68 00 30 00 40       	push   $0x40003000
f0116045:	ff 75 cc             	pushl  -0x34(%ebp)
f0116048:	e8 7a 28 00 00       	call   f01188c7 <CCP>
f011604d:	83 c4 30             	add    $0x30,%esp
f0116050:	85 c0                	test   %eax,%eax
f0116052:	75 1e                	jne    f0116072 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0116054:	83 ec 04             	sub    $0x4,%esp
f0116057:	68 38 de 12 f0       	push   $0xf012de38
f011605c:	68 9b 04 00 00       	push   $0x49b
f0116061:	68 02 cb 12 f0       	push   $0xf012cb02
f0116066:	e8 4c a4 fe ff       	call   f01004b7 <_warn>
f011606b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011606e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116072:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116076:	74 04                	je     f011607c <test_share_chunk+0x656>
f0116078:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011607c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0116080:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116083:	c1 e0 02             	shl    $0x2,%eax
f0116086:	83 ec 08             	sub    $0x8,%esp
f0116089:	6a 02                	push   $0x2
f011608b:	6a 07                	push   $0x7
f011608d:	6a 03                	push   $0x3
f011608f:	6a 07                	push   $0x7
f0116091:	6a 07                	push   $0x7
f0116093:	6a 03                	push   $0x3
f0116095:	50                   	push   %eax
f0116096:	68 00 00 0a 00       	push   $0xa0000
f011609b:	68 00 00 0a 40       	push   $0x400a0000
f01160a0:	ff 75 cc             	pushl  -0x34(%ebp)
f01160a3:	e8 1f 28 00 00       	call   f01188c7 <CCP>
f01160a8:	83 c4 30             	add    $0x30,%esp
f01160ab:	85 c0                	test   %eax,%eax
f01160ad:	75 1e                	jne    f01160cd <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01160af:	83 ec 04             	sub    $0x4,%esp
f01160b2:	68 38 de 12 f0       	push   $0xf012de38
f01160b7:	68 a3 04 00 00       	push   $0x4a3
f01160bc:	68 02 cb 12 f0       	push   $0xf012cb02
f01160c1:	e8 f1 a3 fe ff       	call   f01004b7 <_warn>
f01160c6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01160c9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01160cd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01160d1:	74 04                	je     f01160d7 <test_share_chunk+0x6b1>
f01160d3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01160d7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01160db:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01160df:	0f 84 92 00 00 00    	je     f0116177 <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f01160e5:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f01160ec:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f01160f3:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f01160fa:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0116101:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116104:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f0116107:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f011610e:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0116115:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116118:	8a 00                	mov    (%eax),%al
f011611a:	3c 41                	cmp    $0x41,%al
f011611c:	75 2d                	jne    f011614b <test_share_chunk+0x725>
f011611e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116121:	8a 00                	mov    (%eax),%al
f0116123:	3c 41                	cmp    $0x41,%al
f0116125:	75 24                	jne    f011614b <test_share_chunk+0x725>
f0116127:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011612a:	8a 00                	mov    (%eax),%al
f011612c:	3c 41                	cmp    $0x41,%al
f011612e:	75 1b                	jne    f011614b <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0116130:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116133:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0116135:	3c 44                	cmp    $0x44,%al
f0116137:	75 12                	jne    f011614b <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0116139:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011613c:	8a 00                	mov    (%eax),%al
f011613e:	3c 44                	cmp    $0x44,%al
f0116140:	75 09                	jne    f011614b <test_share_chunk+0x725>
f0116142:	8b 45 90             	mov    -0x70(%ebp),%eax
f0116145:	8a 00                	mov    (%eax),%al
f0116147:	3c 44                	cmp    $0x44,%al
f0116149:	74 1e                	je     f0116169 <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011614b:	83 ec 04             	sub    $0x4,%esp
f011614e:	68 80 de 12 f0       	push   $0xf012de80
f0116153:	68 b5 04 00 00       	push   $0x4b5
f0116158:	68 02 cb 12 f0       	push   $0xf012cb02
f011615d:	e8 55 a3 fe ff       	call   f01004b7 <_warn>
f0116162:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0116165:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0116169:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011616d:	74 04                	je     f0116173 <test_share_chunk+0x74d>
f011616f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0116173:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0116177:	83 ec 0c             	sub    $0xc,%esp
f011617a:	68 f2 d4 12 f0       	push   $0xf012d4f2
f011617f:	e8 e8 ad fe ff       	call   f0100f6c <cprintf>
f0116184:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0116187:	83 ec 0c             	sub    $0xc,%esp
f011618a:	68 8c df 12 f0       	push   $0xf012df8c
f011618f:	e8 d8 ad fe ff       	call   f0100f6c <cprintf>
f0116194:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0116197:	e8 41 78 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011619c:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f011619f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01161a2:	89 d0                	mov    %edx,%eax
f01161a4:	01 c0                	add    %eax,%eax
f01161a6:	01 d0                	add    %edx,%eax
f01161a8:	01 c0                	add    %eax,%eax
f01161aa:	01 d0                	add    %edx,%eax
f01161ac:	83 ec 0c             	sub    $0xc,%esp
f01161af:	6a 04                	push   $0x4
f01161b1:	50                   	push   %eax
f01161b2:	68 00 fc 3f 00       	push   $0x3ffc00
f01161b7:	68 00 fc 09 00       	push   $0x9fc00
f01161bc:	ff 75 cc             	pushl  -0x34(%ebp)
f01161bf:	e8 15 35 ff ff       	call   f01096d9 <share_chunk>
f01161c4:	83 c4 20             	add    $0x20,%esp
f01161c7:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01161ca:	e8 0e 78 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01161cf:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f01161d2:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f01161d6:	75 0b                	jne    f01161e3 <test_share_chunk+0x7bd>
f01161d8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01161db:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01161de:	83 f8 01             	cmp    $0x1,%eax
f01161e1:	74 28                	je     f011620b <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01161e3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01161e6:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01161e9:	83 ec 0c             	sub    $0xc,%esp
f01161ec:	50                   	push   %eax
f01161ed:	ff 75 8c             	pushl  -0x74(%ebp)
f01161f0:	68 00 df 12 f0       	push   $0xf012df00
f01161f5:	68 cb 04 00 00       	push   $0x4cb
f01161fa:	68 02 cb 12 f0       	push   $0xf012cb02
f01161ff:	e8 b3 a2 fe ff       	call   f01004b7 <_warn>
f0116204:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116207:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011620b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011620f:	74 04                	je     f0116215 <test_share_chunk+0x7ef>
f0116211:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116215:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0116219:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0116220:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116223:	89 d0                	mov    %edx,%eax
f0116225:	01 c0                	add    %eax,%eax
f0116227:	01 d0                	add    %edx,%eax
f0116229:	c1 e0 02             	shl    $0x2,%eax
f011622c:	83 ec 08             	sub    $0x8,%esp
f011622f:	6a 02                	push   $0x2
f0116231:	6a 07                	push   $0x7
f0116233:	6a 07                	push   $0x7
f0116235:	6a 07                	push   $0x7
f0116237:	6a 05                	push   $0x5
f0116239:	6a ff                	push   $0xffffffff
f011623b:	50                   	push   %eax
f011623c:	68 00 f0 3f 00       	push   $0x3ff000
f0116241:	68 00 f0 09 00       	push   $0x9f000
f0116246:	ff 75 cc             	pushl  -0x34(%ebp)
f0116249:	e8 79 26 00 00       	call   f01188c7 <CCP>
f011624e:	83 c4 30             	add    $0x30,%esp
f0116251:	85 c0                	test   %eax,%eax
f0116253:	75 25                	jne    f011627a <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0116255:	83 ec 04             	sub    $0x4,%esp
f0116258:	68 38 de 12 f0       	push   $0xf012de38
f011625d:	68 d4 04 00 00       	push   $0x4d4
f0116262:	68 02 cb 12 f0       	push   $0xf012cb02
f0116267:	e8 4b a2 fe ff       	call   f01004b7 <_warn>
f011626c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011626f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0116273:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f011627a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011627e:	74 04                	je     f0116284 <test_share_chunk+0x85e>
f0116280:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116284:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0116288:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011628b:	c1 e0 02             	shl    $0x2,%eax
f011628e:	83 ec 08             	sub    $0x8,%esp
f0116291:	6a 02                	push   $0x2
f0116293:	6a 07                	push   $0x7
f0116295:	6a 07                	push   $0x7
f0116297:	6a 07                	push   $0x7
f0116299:	6a 05                	push   $0x5
f011629b:	6a 03                	push   $0x3
f011629d:	50                   	push   %eax
f011629e:	68 00 f0 3f 00       	push   $0x3ff000
f01162a3:	68 00 f0 09 00       	push   $0x9f000
f01162a8:	ff 75 cc             	pushl  -0x34(%ebp)
f01162ab:	e8 17 26 00 00       	call   f01188c7 <CCP>
f01162b0:	83 c4 30             	add    $0x30,%esp
f01162b3:	85 c0                	test   %eax,%eax
f01162b5:	75 1e                	jne    f01162d5 <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01162b7:	83 ec 04             	sub    $0x4,%esp
f01162ba:	68 38 de 12 f0       	push   $0xf012de38
f01162bf:	68 dd 04 00 00       	push   $0x4dd
f01162c4:	68 02 cb 12 f0       	push   $0xf012cb02
f01162c9:	e8 e9 a1 fe ff       	call   f01004b7 <_warn>
f01162ce:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01162d1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01162d5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01162d9:	74 04                	je     f01162df <test_share_chunk+0x8b9>
f01162db:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01162df:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01162e3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01162e6:	c1 e0 03             	shl    $0x3,%eax
f01162e9:	83 ec 08             	sub    $0x8,%esp
f01162ec:	6a 02                	push   $0x2
f01162ee:	6a 07                	push   $0x7
f01162f0:	6a 07                	push   $0x7
f01162f2:	6a 07                	push   $0x7
f01162f4:	6a 05                	push   $0x5
f01162f6:	6a 04                	push   $0x4
f01162f8:	50                   	push   %eax
f01162f9:	68 00 00 40 00       	push   $0x400000
f01162fe:	68 00 00 0a 00       	push   $0xa0000
f0116303:	ff 75 cc             	pushl  -0x34(%ebp)
f0116306:	e8 bc 25 00 00       	call   f01188c7 <CCP>
f011630b:	83 c4 30             	add    $0x30,%esp
f011630e:	85 c0                	test   %eax,%eax
f0116310:	75 1e                	jne    f0116330 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0116312:	83 ec 04             	sub    $0x4,%esp
f0116315:	68 38 de 12 f0       	push   $0xf012de38
f011631a:	68 e5 04 00 00       	push   $0x4e5
f011631f:	68 02 cb 12 f0       	push   $0xf012cb02
f0116324:	e8 8e a1 fe ff       	call   f01004b7 <_warn>
f0116329:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011632c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116330:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116334:	74 04                	je     f011633a <test_share_chunk+0x914>
f0116336:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011633a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f011633e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0116342:	0f 84 b2 00 00 00    	je     f01163fa <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f0116348:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f011634f:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f0116356:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f011635d:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0116364:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f011636b:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f0116372:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f0116379:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0116380:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116383:	8a 00                	mov    (%eax),%al
f0116385:	3c 44                	cmp    $0x44,%al
f0116387:	75 45                	jne    f01163ce <test_share_chunk+0x9a8>
f0116389:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011638c:	8a 00                	mov    (%eax),%al
f011638e:	3c 44                	cmp    $0x44,%al
f0116390:	75 3c                	jne    f01163ce <test_share_chunk+0x9a8>
f0116392:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116395:	8a 00                	mov    (%eax),%al
f0116397:	3c 44                	cmp    $0x44,%al
f0116399:	75 33                	jne    f01163ce <test_share_chunk+0x9a8>
f011639b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011639e:	8a 00                	mov    (%eax),%al
f01163a0:	3c 44                	cmp    $0x44,%al
f01163a2:	75 2a                	jne    f01163ce <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f01163a4:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01163a7:	8a 10                	mov    (%eax),%dl
f01163a9:	8b 45 90             	mov    -0x70(%ebp),%eax
f01163ac:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f01163ae:	38 c2                	cmp    %al,%dl
f01163b0:	75 1c                	jne    f01163ce <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f01163b2:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01163b5:	8a 10                	mov    (%eax),%dl
f01163b7:	8b 45 88             	mov    -0x78(%ebp),%eax
f01163ba:	8a 00                	mov    (%eax),%al
f01163bc:	38 c2                	cmp    %al,%dl
f01163be:	75 0e                	jne    f01163ce <test_share_chunk+0x9a8>
f01163c0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01163c3:	8a 10                	mov    (%eax),%dl
f01163c5:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01163c8:	8a 00                	mov    (%eax),%al
f01163ca:	38 c2                	cmp    %al,%dl
f01163cc:	74 1e                	je     f01163ec <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01163ce:	83 ec 04             	sub    $0x4,%esp
f01163d1:	68 80 de 12 f0       	push   $0xf012de80
f01163d6:	68 fa 04 00 00       	push   $0x4fa
f01163db:	68 02 cb 12 f0       	push   $0xf012cb02
f01163e0:	e8 d2 a0 fe ff       	call   f01004b7 <_warn>
f01163e5:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01163e8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01163ec:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01163f0:	74 04                	je     f01163f6 <test_share_chunk+0x9d0>
f01163f2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01163f6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f01163fa:	83 ec 0c             	sub    $0xc,%esp
f01163fd:	68 c4 df 12 f0       	push   $0xf012dfc4
f0116402:	e8 65 ab fe ff       	call   f0100f6c <cprintf>
f0116407:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f011640a:	83 ec 08             	sub    $0x8,%esp
f011640d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116410:	68 d4 df 12 f0       	push   $0xf012dfd4
f0116415:	e8 52 ab fe ff       	call   f0100f6c <cprintf>
f011641a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011641d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116421:	75 10                	jne    f0116433 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f0116423:	83 ec 0c             	sub    $0xc,%esp
f0116426:	68 04 e0 12 f0       	push   $0xf012e004
f011642b:	e8 3c ab fe ff       	call   f0100f6c <cprintf>
f0116430:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116433:	a1 84 4b 5a f0       	mov    0xf05a4b84,%eax
f0116438:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011643b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011643e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0116441:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116446:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116449:	5b                   	pop    %ebx
f011644a:	5e                   	pop    %esi
f011644b:	5f                   	pop    %edi
f011644c:	5d                   	pop    %ebp
f011644d:	c3                   	ret    

f011644e <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f011644e:	55                   	push   %ebp
f011644f:	89 e5                	mov    %esp,%ebp
f0116451:	57                   	push   %edi
f0116452:	56                   	push   %esi
f0116453:	53                   	push   %ebx
f0116454:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011645a:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0116460:	bb 04 d2 12 f0       	mov    $0xf012d204,%ebx
f0116465:	ba 0f 00 00 00       	mov    $0xf,%edx
f011646a:	89 c7                	mov    %eax,%edi
f011646c:	89 de                	mov    %ebx,%esi
f011646e:	89 d1                	mov    %edx,%ecx
f0116470:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116472:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0116478:	b9 23 00 00 00       	mov    $0x23,%ecx
f011647d:	b0 00                	mov    $0x0,%al
f011647f:	89 d7                	mov    %edx,%edi
f0116481:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0116483:	6a 00                	push   $0x0
f0116485:	6a 0a                	push   $0xa
f0116487:	6a 14                	push   $0x14
f0116489:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f011648f:	50                   	push   %eax
f0116490:	e8 b0 35 ff ff       	call   f0109a45 <env_create>
f0116495:	83 c4 10             	add    $0x10,%esp
f0116498:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011649b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011649e:	8b 40 64             	mov    0x64(%eax),%eax
f01164a1:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f01164a4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01164a7:	8b 40 68             	mov    0x68(%eax),%eax
f01164aa:	89 45 90             	mov    %eax,-0x70(%ebp)
f01164ad:	8b 45 90             	mov    -0x70(%ebp),%eax
f01164b0:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f01164b3:	83 ec 0c             	sub    $0xc,%esp
f01164b6:	ff 75 cc             	pushl  -0x34(%ebp)
f01164b9:	e8 d5 23 00 00       	call   f0118893 <ClearUserSpace>
f01164be:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01164c1:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f01164c8:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f01164cf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f01164d6:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f01164da:	83 ec 0c             	sub    $0xc,%esp
f01164dd:	68 40 e0 12 f0       	push   $0xf012e040
f01164e2:	e8 85 aa fe ff       	call   f0100f6c <cprintf>
f01164e7:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f01164ea:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f01164f1:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f01164f8:	eb 03                	jmp    f01164fd <test_allocate_chunk+0xaf>
f01164fa:	ff 4d e4             	decl   -0x1c(%ebp)
f01164fd:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0116504:	76 09                	jbe    f011650f <test_allocate_chunk+0xc1>
f0116506:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116509:	8a 00                	mov    (%eax),%al
f011650b:	84 c0                	test   %al,%al
f011650d:	74 eb                	je     f01164fa <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f011650f:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0116516:	75 06                	jne    f011651e <test_allocate_chunk+0xd0>
f0116518:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011651b:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f011651e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116521:	8a 00                	mov    (%eax),%al
f0116523:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f0116529:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011652c:	8a 00                	mov    (%eax),%al
f011652e:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f0116534:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116537:	8a 00                	mov    (%eax),%al
f0116539:	0f be c0             	movsbl %al,%eax
f011653c:	83 ec 08             	sub    $0x8,%esp
f011653f:	50                   	push   %eax
f0116540:	68 6a e0 12 f0       	push   $0xf012e06a
f0116545:	e8 22 aa fe ff       	call   f0100f6c <cprintf>
f011654a:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f011654d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116550:	8a 00                	mov    (%eax),%al
f0116552:	0f be c0             	movsbl %al,%eax
f0116555:	83 ec 08             	sub    $0x8,%esp
f0116558:	50                   	push   %eax
f0116559:	68 76 e0 12 f0       	push   $0xf012e076
f011655e:	e8 09 aa fe ff       	call   f0100f6c <cprintf>
f0116563:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0116566:	83 ec 08             	sub    $0x8,%esp
f0116569:	68 00 f0 bf ef       	push   $0xefbff000
f011656e:	ff 75 cc             	pushl  -0x34(%ebp)
f0116571:	e8 84 22 00 00       	call   f01187fa <GP>
f0116576:	83 c4 10             	add    $0x10,%esp
f0116579:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011657c:	e8 5c 74 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0116581:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0116584:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116587:	c1 e0 02             	shl    $0x2,%eax
f011658a:	6a 02                	push   $0x2
f011658c:	50                   	push   %eax
f011658d:	68 00 f0 bf ef       	push   $0xefbff000
f0116592:	ff 75 cc             	pushl  -0x34(%ebp)
f0116595:	e8 59 31 ff ff       	call   f01096f3 <allocate_chunk>
f011659a:	83 c4 10             	add    $0x10,%esp
f011659d:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01165a0:	e8 38 74 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01165a5:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f01165a8:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f01165ac:	75 08                	jne    f01165b6 <test_allocate_chunk+0x168>
f01165ae:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01165b1:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f01165b4:	74 2a                	je     f01165e0 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f01165b6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01165b9:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01165bc:	83 ec 08             	sub    $0x8,%esp
f01165bf:	6a 00                	push   $0x0
f01165c1:	50                   	push   %eax
f01165c2:	ff 75 b0             	pushl  -0x50(%ebp)
f01165c5:	68 84 e0 12 f0       	push   $0xf012e084
f01165ca:	68 3a 05 00 00       	push   $0x53a
f01165cf:	68 02 cb 12 f0       	push   $0xf012cb02
f01165d4:	e8 de 9e fe ff       	call   f01004b7 <_warn>
f01165d9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01165dc:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01165e0:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01165e4:	74 04                	je     f01165ea <test_allocate_chunk+0x19c>
f01165e6:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01165ea:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01165ee:	e8 ea 73 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01165f3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f01165f6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01165f9:	01 c0                	add    %eax,%eax
f01165fb:	89 c1                	mov    %eax,%ecx
f01165fd:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116600:	89 d0                	mov    %edx,%eax
f0116602:	c1 e0 02             	shl    $0x2,%eax
f0116605:	01 d0                	add    %edx,%eax
f0116607:	f7 d8                	neg    %eax
f0116609:	2d 00 00 40 10       	sub    $0x10400000,%eax
f011660e:	6a 02                	push   $0x2
f0116610:	51                   	push   %ecx
f0116611:	50                   	push   %eax
f0116612:	ff 75 cc             	pushl  -0x34(%ebp)
f0116615:	e8 d9 30 ff ff       	call   f01096f3 <allocate_chunk>
f011661a:	83 c4 10             	add    $0x10,%esp
f011661d:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0116620:	e8 b8 73 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0116625:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0116628:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f011662c:	75 08                	jne    f0116636 <test_allocate_chunk+0x1e8>
f011662e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116631:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0116634:	74 2a                	je     f0116660 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0116636:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116639:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011663c:	83 ec 08             	sub    $0x8,%esp
f011663f:	6a 00                	push   $0x0
f0116641:	50                   	push   %eax
f0116642:	ff 75 b0             	pushl  -0x50(%ebp)
f0116645:	68 84 e0 12 f0       	push   $0xf012e084
f011664a:	68 48 05 00 00       	push   $0x548
f011664f:	68 02 cb 12 f0       	push   $0xf012cb02
f0116654:	e8 5e 9e fe ff       	call   f01004b7 <_warn>
f0116659:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011665c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0116660:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116664:	74 04                	je     f011666a <test_allocate_chunk+0x21c>
f0116666:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011666a:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f011666e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116671:	c1 e0 02             	shl    $0x2,%eax
f0116674:	83 ec 08             	sub    $0x8,%esp
f0116677:	6a 03                	push   $0x3
f0116679:	6a 00                	push   $0x0
f011667b:	6a 00                	push   $0x0
f011667d:	68 ff 0f 00 00       	push   $0xfff
f0116682:	ff 75 b8             	pushl  -0x48(%ebp)
f0116685:	6a 01                	push   $0x1
f0116687:	50                   	push   %eax
f0116688:	68 00 f0 bf ef       	push   $0xefbff000
f011668d:	6a 00                	push   $0x0
f011668f:	ff 75 cc             	pushl  -0x34(%ebp)
f0116692:	e8 30 22 00 00       	call   f01188c7 <CCP>
f0116697:	83 c4 30             	add    $0x30,%esp
f011669a:	85 c0                	test   %eax,%eax
f011669c:	75 1e                	jne    f01166bc <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011669e:	83 ec 04             	sub    $0x4,%esp
f01166a1:	68 ec e0 12 f0       	push   $0xf012e0ec
f01166a6:	68 50 05 00 00       	push   $0x550
f01166ab:	68 02 cb 12 f0       	push   $0xf012cb02
f01166b0:	e8 02 9e fe ff       	call   f01004b7 <_warn>
f01166b5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01166b8:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01166bc:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01166c0:	74 04                	je     f01166c6 <test_allocate_chunk+0x278>
f01166c2:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01166c6:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f01166ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01166cd:	8a 10                	mov    (%eax),%dl
f01166cf:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f01166d5:	38 c2                	cmp    %al,%dl
f01166d7:	75 0f                	jne    f01166e8 <test_allocate_chunk+0x29a>
f01166d9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01166dc:	8a 10                	mov    (%eax),%dl
f01166de:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f01166e4:	38 c2                	cmp    %al,%dl
f01166e6:	74 1e                	je     f0116706 <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01166e8:	83 ec 04             	sub    $0x4,%esp
f01166eb:	68 38 e1 12 f0       	push   $0xf012e138
f01166f0:	68 58 05 00 00       	push   $0x558
f01166f5:	68 02 cb 12 f0       	push   $0xf012cb02
f01166fa:	e8 b8 9d fe ff       	call   f01004b7 <_warn>
f01166ff:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116702:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0116706:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011670a:	74 04                	je     f0116710 <test_allocate_chunk+0x2c2>
f011670c:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0116710:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0116714:	83 ec 0c             	sub    $0xc,%esp
f0116717:	68 b5 de 12 f0       	push   $0xf012deb5
f011671c:	e8 4b a8 fe ff       	call   f0100f6c <cprintf>
f0116721:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f0116724:	83 ec 0c             	sub    $0xc,%esp
f0116727:	68 70 e1 12 f0       	push   $0xf012e170
f011672c:	e8 3b a8 fe ff       	call   f0100f6c <cprintf>
f0116731:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0116734:	e8 a4 72 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0116739:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f011673c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011673f:	c1 e0 05             	shl    $0x5,%eax
f0116742:	68 02 0e 00 00       	push   $0xe02
f0116747:	50                   	push   %eax
f0116748:	6a 00                	push   $0x0
f011674a:	ff 75 cc             	pushl  -0x34(%ebp)
f011674d:	e8 a1 2f ff ff       	call   f01096f3 <allocate_chunk>
f0116752:	83 c4 10             	add    $0x10,%esp
f0116755:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0116758:	e8 80 72 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011675d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0116760:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0116764:	75 36                	jne    f011679c <test_allocate_chunk+0x34e>
f0116766:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116769:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011676c:	89 c1                	mov    %eax,%ecx
f011676e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116771:	c1 e0 05             	shl    $0x5,%eax
f0116774:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116777:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011677e:	99                   	cltd   
f011677f:	f7 fe                	idiv   %esi
f0116781:	89 c3                	mov    %eax,%ebx
f0116783:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116786:	c1 e0 05             	shl    $0x5,%eax
f0116789:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011678c:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0116793:	99                   	cltd   
f0116794:	f7 fe                	idiv   %esi
f0116796:	01 d8                	add    %ebx,%eax
f0116798:	39 c1                	cmp    %eax,%ecx
f011679a:	74 54                	je     f01167f0 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f011679c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011679f:	c1 e0 05             	shl    $0x5,%eax
f01167a2:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01167a5:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01167ac:	99                   	cltd   
f01167ad:	f7 ff                	idiv   %edi
f01167af:	89 c1                	mov    %eax,%ecx
f01167b1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01167b4:	c1 e0 05             	shl    $0x5,%eax
f01167b7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01167ba:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01167c1:	99                   	cltd   
f01167c2:	f7 fe                	idiv   %esi
f01167c4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01167c7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01167ca:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01167cd:	83 ec 08             	sub    $0x8,%esp
f01167d0:	52                   	push   %edx
f01167d1:	50                   	push   %eax
f01167d2:	ff 75 a8             	pushl  -0x58(%ebp)
f01167d5:	68 b0 e1 12 f0       	push   $0xf012e1b0
f01167da:	68 6d 05 00 00       	push   $0x56d
f01167df:	68 02 cb 12 f0       	push   $0xf012cb02
f01167e4:	e8 ce 9c fe ff       	call   f01004b7 <_warn>
f01167e9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01167ec:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01167f0:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01167f4:	74 04                	je     f01167fa <test_allocate_chunk+0x3ac>
f01167f6:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01167fa:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01167fe:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0116805:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116808:	c1 e0 05             	shl    $0x5,%eax
f011680b:	83 ec 08             	sub    $0x8,%esp
f011680e:	6a 03                	push   $0x3
f0116810:	6a 00                	push   $0x0
f0116812:	6a 00                	push   $0x0
f0116814:	68 07 0e 00 00       	push   $0xe07
f0116819:	68 03 0e 00 00       	push   $0xe03
f011681e:	6a 01                	push   $0x1
f0116820:	50                   	push   %eax
f0116821:	6a 00                	push   $0x0
f0116823:	6a 00                	push   $0x0
f0116825:	ff 75 cc             	pushl  -0x34(%ebp)
f0116828:	e8 9a 20 00 00       	call   f01188c7 <CCP>
f011682d:	83 c4 30             	add    $0x30,%esp
f0116830:	85 c0                	test   %eax,%eax
f0116832:	75 25                	jne    f0116859 <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0116834:	83 ec 04             	sub    $0x4,%esp
f0116837:	68 ec e0 12 f0       	push   $0xf012e0ec
f011683c:	68 76 05 00 00       	push   $0x576
f0116841:	68 02 cb 12 f0       	push   $0xf012cb02
f0116846:	e8 6c 9c fe ff       	call   f01004b7 <_warn>
f011684b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011684e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0116852:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0116859:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011685d:	74 04                	je     f0116863 <test_allocate_chunk+0x415>
f011685f:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0116863:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0116867:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011686b:	74 5a                	je     f01168c7 <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f011686d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116870:	01 c0                	add    %eax,%eax
f0116872:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0116875:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116878:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f011687b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011687e:	01 c0                	add    %eax,%eax
f0116880:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0116883:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116886:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0116889:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011688c:	8a 00                	mov    (%eax),%al
f011688e:	3c 4b                	cmp    $0x4b,%al
f0116890:	75 09                	jne    f011689b <test_allocate_chunk+0x44d>
f0116892:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116895:	8a 00                	mov    (%eax),%al
f0116897:	3c 4d                	cmp    $0x4d,%al
f0116899:	74 1e                	je     f01168b9 <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011689b:	83 ec 04             	sub    $0x4,%esp
f011689e:	68 38 e1 12 f0       	push   $0xf012e138
f01168a3:	68 84 05 00 00       	push   $0x584
f01168a8:	68 02 cb 12 f0       	push   $0xf012cb02
f01168ad:	e8 05 9c fe ff       	call   f01004b7 <_warn>
f01168b2:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01168b5:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01168b9:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01168bd:	74 04                	je     f01168c3 <test_allocate_chunk+0x475>
f01168bf:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f01168c3:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01168c7:	83 ec 0c             	sub    $0xc,%esp
f01168ca:	68 8f d4 12 f0       	push   $0xf012d48f
f01168cf:	e8 98 a6 fe ff       	call   f0100f6c <cprintf>
f01168d4:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f01168d7:	83 ec 0c             	sub    $0xc,%esp
f01168da:	68 10 e2 12 f0       	push   $0xf012e210
f01168df:	e8 88 a6 fe ff       	call   f0100f6c <cprintf>
f01168e4:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01168e7:	e8 f1 70 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01168ec:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f01168ef:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01168f2:	c1 e0 06             	shl    $0x6,%eax
f01168f5:	89 c2                	mov    %eax,%edx
f01168f7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01168fa:	c1 e0 05             	shl    $0x5,%eax
f01168fd:	6a 00                	push   $0x0
f01168ff:	52                   	push   %edx
f0116900:	50                   	push   %eax
f0116901:	ff 75 cc             	pushl  -0x34(%ebp)
f0116904:	e8 ea 2d ff ff       	call   f01096f3 <allocate_chunk>
f0116909:	83 c4 10             	add    $0x10,%esp
f011690c:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011690f:	e8 c9 70 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0116914:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0116917:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f011691b:	75 36                	jne    f0116953 <test_allocate_chunk+0x505>
f011691d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116920:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116923:	89 c1                	mov    %eax,%ecx
f0116925:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116928:	c1 e0 06             	shl    $0x6,%eax
f011692b:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011692e:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0116935:	99                   	cltd   
f0116936:	f7 ff                	idiv   %edi
f0116938:	89 c3                	mov    %eax,%ebx
f011693a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011693d:	c1 e0 06             	shl    $0x6,%eax
f0116940:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116943:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011694a:	99                   	cltd   
f011694b:	f7 fe                	idiv   %esi
f011694d:	01 d8                	add    %ebx,%eax
f011694f:	39 c1                	cmp    %eax,%ecx
f0116951:	74 54                	je     f01169a7 <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0116953:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116956:	c1 e0 06             	shl    $0x6,%eax
f0116959:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011695c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0116963:	99                   	cltd   
f0116964:	f7 fb                	idiv   %ebx
f0116966:	89 c1                	mov    %eax,%ecx
f0116968:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011696b:	c1 e0 06             	shl    $0x6,%eax
f011696e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116971:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0116978:	99                   	cltd   
f0116979:	f7 ff                	idiv   %edi
f011697b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f011697e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116981:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116984:	83 ec 08             	sub    $0x8,%esp
f0116987:	52                   	push   %edx
f0116988:	50                   	push   %eax
f0116989:	ff 75 a4             	pushl  -0x5c(%ebp)
f011698c:	68 b0 e1 12 f0       	push   $0xf012e1b0
f0116991:	68 9a 05 00 00       	push   $0x59a
f0116996:	68 02 cb 12 f0       	push   $0xf012cb02
f011699b:	e8 17 9b fe ff       	call   f01004b7 <_warn>
f01169a0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01169a3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01169a7:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01169ab:	74 04                	je     f01169b1 <test_allocate_chunk+0x563>
f01169ad:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01169b1:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01169b5:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01169bc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01169bf:	c1 e0 06             	shl    $0x6,%eax
f01169c2:	89 c2                	mov    %eax,%edx
f01169c4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01169c7:	c1 e0 05             	shl    $0x5,%eax
f01169ca:	83 ec 08             	sub    $0x8,%esp
f01169cd:	6a 03                	push   $0x3
f01169cf:	6a 00                	push   $0x0
f01169d1:	6a 00                	push   $0x0
f01169d3:	68 07 0e 00 00       	push   $0xe07
f01169d8:	6a 01                	push   $0x1
f01169da:	6a 01                	push   $0x1
f01169dc:	52                   	push   %edx
f01169dd:	50                   	push   %eax
f01169de:	6a 00                	push   $0x0
f01169e0:	ff 75 cc             	pushl  -0x34(%ebp)
f01169e3:	e8 df 1e 00 00       	call   f01188c7 <CCP>
f01169e8:	83 c4 30             	add    $0x30,%esp
f01169eb:	85 c0                	test   %eax,%eax
f01169ed:	75 25                	jne    f0116a14 <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01169ef:	83 ec 04             	sub    $0x4,%esp
f01169f2:	68 ec e0 12 f0       	push   $0xf012e0ec
f01169f7:	68 a3 05 00 00       	push   $0x5a3
f01169fc:	68 02 cb 12 f0       	push   $0xf012cb02
f0116a01:	e8 b1 9a fe ff       	call   f01004b7 <_warn>
f0116a06:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116a09:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0116a0d:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0116a14:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116a18:	74 04                	je     f0116a1e <test_allocate_chunk+0x5d0>
f0116a1a:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0116a1e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0116a22:	83 ec 0c             	sub    $0xc,%esp
f0116a25:	68 f2 d4 12 f0       	push   $0xf012d4f2
f0116a2a:	e8 3d a5 fe ff       	call   f0100f6c <cprintf>
f0116a2f:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0116a32:	83 ec 0c             	sub    $0xc,%esp
f0116a35:	68 50 e2 12 f0       	push   $0xf012e250
f0116a3a:	e8 2d a5 fe ff       	call   f0100f6c <cprintf>
f0116a3f:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0116a42:	e8 96 6f ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0116a47:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0116a4a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116a4d:	c1 e0 06             	shl    $0x6,%eax
f0116a50:	68 06 0e 00 00       	push   $0xe06
f0116a55:	50                   	push   %eax
f0116a56:	68 00 00 00 80       	push   $0x80000000
f0116a5b:	ff 75 cc             	pushl  -0x34(%ebp)
f0116a5e:	e8 90 2c ff ff       	call   f01096f3 <allocate_chunk>
f0116a63:	83 c4 10             	add    $0x10,%esp
f0116a66:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0116a69:	e8 6f 6f ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0116a6e:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0116a71:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0116a75:	75 36                	jne    f0116aad <test_allocate_chunk+0x65f>
f0116a77:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116a7a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116a7d:	89 c1                	mov    %eax,%ecx
f0116a7f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116a82:	c1 e0 06             	shl    $0x6,%eax
f0116a85:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116a88:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0116a8f:	99                   	cltd   
f0116a90:	f7 fb                	idiv   %ebx
f0116a92:	89 c3                	mov    %eax,%ebx
f0116a94:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116a97:	c1 e0 06             	shl    $0x6,%eax
f0116a9a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116a9d:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0116aa4:	99                   	cltd   
f0116aa5:	f7 fe                	idiv   %esi
f0116aa7:	01 d8                	add    %ebx,%eax
f0116aa9:	39 c1                	cmp    %eax,%ecx
f0116aab:	74 54                	je     f0116b01 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0116aad:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116ab0:	c1 e0 06             	shl    $0x6,%eax
f0116ab3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116ab6:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0116abd:	99                   	cltd   
f0116abe:	f7 ff                	idiv   %edi
f0116ac0:	89 c1                	mov    %eax,%ecx
f0116ac2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116ac5:	c1 e0 06             	shl    $0x6,%eax
f0116ac8:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116acb:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0116ad2:	99                   	cltd   
f0116ad3:	f7 fb                	idiv   %ebx
f0116ad5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0116ad8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116adb:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116ade:	83 ec 08             	sub    $0x8,%esp
f0116ae1:	52                   	push   %edx
f0116ae2:	50                   	push   %eax
f0116ae3:	ff 75 9c             	pushl  -0x64(%ebp)
f0116ae6:	68 b0 e1 12 f0       	push   $0xf012e1b0
f0116aeb:	68 b9 05 00 00       	push   $0x5b9
f0116af0:	68 02 cb 12 f0       	push   $0xf012cb02
f0116af5:	e8 bd 99 fe ff       	call   f01004b7 <_warn>
f0116afa:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116afd:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0116b01:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116b05:	74 04                	je     f0116b0b <test_allocate_chunk+0x6bd>
f0116b07:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0116b0b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0116b0f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0116b16:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116b19:	c1 e0 06             	shl    $0x6,%eax
f0116b1c:	83 ec 08             	sub    $0x8,%esp
f0116b1f:	6a 03                	push   $0x3
f0116b21:	6a 00                	push   $0x0
f0116b23:	6a 00                	push   $0x0
f0116b25:	68 07 0e 00 00       	push   $0xe07
f0116b2a:	68 07 0e 00 00       	push   $0xe07
f0116b2f:	6a 01                	push   $0x1
f0116b31:	50                   	push   %eax
f0116b32:	68 00 00 00 80       	push   $0x80000000
f0116b37:	6a 00                	push   $0x0
f0116b39:	ff 75 cc             	pushl  -0x34(%ebp)
f0116b3c:	e8 86 1d 00 00       	call   f01188c7 <CCP>
f0116b41:	83 c4 30             	add    $0x30,%esp
f0116b44:	85 c0                	test   %eax,%eax
f0116b46:	75 25                	jne    f0116b6d <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0116b48:	83 ec 04             	sub    $0x4,%esp
f0116b4b:	68 ec e0 12 f0       	push   $0xf012e0ec
f0116b50:	68 c2 05 00 00       	push   $0x5c2
f0116b55:	68 02 cb 12 f0       	push   $0xf012cb02
f0116b5a:	e8 58 99 fe ff       	call   f01004b7 <_warn>
f0116b5f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116b62:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0116b66:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0116b6d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116b71:	74 04                	je     f0116b77 <test_allocate_chunk+0x729>
f0116b73:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0116b77:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0116b7b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0116b7f:	74 6f                	je     f0116bf0 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0116b81:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116b84:	01 c0                	add    %eax,%eax
f0116b86:	05 00 00 00 80       	add    $0x80000000,%eax
f0116b8b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0116b8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116b91:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0116b94:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116b97:	89 d0                	mov    %edx,%eax
f0116b99:	c1 e0 02             	shl    $0x2,%eax
f0116b9c:	01 d0                	add    %edx,%eax
f0116b9e:	01 c0                	add    %eax,%eax
f0116ba0:	01 d0                	add    %edx,%eax
f0116ba2:	01 c0                	add    %eax,%eax
f0116ba4:	05 00 00 00 80       	add    $0x80000000,%eax
f0116ba9:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0116bac:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116baf:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0116bb2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116bb5:	8a 00                	mov    (%eax),%al
f0116bb7:	3c 4b                	cmp    $0x4b,%al
f0116bb9:	75 09                	jne    f0116bc4 <test_allocate_chunk+0x776>
f0116bbb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116bbe:	8a 00                	mov    (%eax),%al
f0116bc0:	3c 4d                	cmp    $0x4d,%al
f0116bc2:	74 1e                	je     f0116be2 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0116bc4:	83 ec 04             	sub    $0x4,%esp
f0116bc7:	68 38 e1 12 f0       	push   $0xf012e138
f0116bcc:	68 d0 05 00 00       	push   $0x5d0
f0116bd1:	68 02 cb 12 f0       	push   $0xf012cb02
f0116bd6:	e8 dc 98 fe ff       	call   f01004b7 <_warn>
f0116bdb:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0116bde:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0116be2:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116be6:	74 04                	je     f0116bec <test_allocate_chunk+0x79e>
f0116be8:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0116bec:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0116bf0:	83 ec 0c             	sub    $0xc,%esp
f0116bf3:	68 c4 df 12 f0       	push   $0xf012dfc4
f0116bf8:	e8 6f a3 fe ff       	call   f0100f6c <cprintf>
f0116bfd:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0116c00:	83 ec 0c             	sub    $0xc,%esp
f0116c03:	68 8c e2 12 f0       	push   $0xf012e28c
f0116c08:	e8 5f a3 fe ff       	call   f0100f6c <cprintf>
f0116c0d:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0116c10:	e8 c8 6d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0116c15:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0116c18:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116c1b:	89 d0                	mov    %edx,%eax
f0116c1d:	01 c0                	add    %eax,%eax
f0116c1f:	01 d0                	add    %edx,%eax
f0116c21:	01 c0                	add    %eax,%eax
f0116c23:	01 d0                	add    %edx,%eax
f0116c25:	68 04 0e 00 00       	push   $0xe04
f0116c2a:	50                   	push   %eax
f0116c2b:	68 00 fc 3f 40       	push   $0x403ffc00
f0116c30:	ff 75 cc             	pushl  -0x34(%ebp)
f0116c33:	e8 bb 2a ff ff       	call   f01096f3 <allocate_chunk>
f0116c38:	83 c4 10             	add    $0x10,%esp
f0116c3b:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0116c3e:	e8 9a 6d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0116c43:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0116c46:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0116c4a:	75 0b                	jne    f0116c57 <test_allocate_chunk+0x809>
f0116c4c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116c4f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116c52:	83 f8 05             	cmp    $0x5,%eax
f0116c55:	74 2a                	je     f0116c81 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0116c57:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116c5a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0116c5d:	83 ec 08             	sub    $0x8,%esp
f0116c60:	6a 05                	push   $0x5
f0116c62:	50                   	push   %eax
f0116c63:	ff 75 98             	pushl  -0x68(%ebp)
f0116c66:	68 b0 e1 12 f0       	push   $0xf012e1b0
f0116c6b:	68 e7 05 00 00       	push   $0x5e7
f0116c70:	68 02 cb 12 f0       	push   $0xf012cb02
f0116c75:	e8 3d 98 fe ff       	call   f01004b7 <_warn>
f0116c7a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116c7d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0116c81:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116c85:	74 04                	je     f0116c8b <test_allocate_chunk+0x83d>
f0116c87:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0116c8b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0116c8f:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0116c96:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0116c99:	89 d0                	mov    %edx,%eax
f0116c9b:	01 c0                	add    %eax,%eax
f0116c9d:	01 d0                	add    %edx,%eax
f0116c9f:	c1 e0 02             	shl    $0x2,%eax
f0116ca2:	83 ec 08             	sub    $0x8,%esp
f0116ca5:	6a 03                	push   $0x3
f0116ca7:	6a 00                	push   $0x0
f0116ca9:	6a 00                	push   $0x0
f0116cab:	68 07 0e 00 00       	push   $0xe07
f0116cb0:	68 05 0e 00 00       	push   $0xe05
f0116cb5:	6a 01                	push   $0x1
f0116cb7:	50                   	push   %eax
f0116cb8:	68 00 f0 3f 40       	push   $0x403ff000
f0116cbd:	6a 00                	push   $0x0
f0116cbf:	ff 75 cc             	pushl  -0x34(%ebp)
f0116cc2:	e8 00 1c 00 00       	call   f01188c7 <CCP>
f0116cc7:	83 c4 30             	add    $0x30,%esp
f0116cca:	85 c0                	test   %eax,%eax
f0116ccc:	75 25                	jne    f0116cf3 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0116cce:	83 ec 04             	sub    $0x4,%esp
f0116cd1:	68 ec e0 12 f0       	push   $0xf012e0ec
f0116cd6:	68 f0 05 00 00       	push   $0x5f0
f0116cdb:	68 02 cb 12 f0       	push   $0xf012cb02
f0116ce0:	e8 d2 97 fe ff       	call   f01004b7 <_warn>
f0116ce5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0116ce8:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0116cec:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f0116cf3:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0116cf7:	74 04                	je     f0116cfd <test_allocate_chunk+0x8af>
f0116cf9:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0116cfd:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f0116d01:	83 ec 0c             	sub    $0xc,%esp
f0116d04:	68 c3 e2 12 f0       	push   $0xf012e2c3
f0116d09:	e8 5e a2 fe ff       	call   f0100f6c <cprintf>
f0116d0e:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0116d11:	83 ec 08             	sub    $0x8,%esp
f0116d14:	ff 75 e0             	pushl  -0x20(%ebp)
f0116d17:	68 d4 e2 12 f0       	push   $0xf012e2d4
f0116d1c:	e8 4b a2 fe ff       	call   f0100f6c <cprintf>
f0116d21:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0116d24:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0116d28:	75 10                	jne    f0116d3a <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0116d2a:	83 ec 0c             	sub    $0xc,%esp
f0116d2d:	68 08 e3 12 f0       	push   $0xf012e308
f0116d32:	e8 35 a2 fe ff       	call   f0100f6c <cprintf>
f0116d37:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116d3a:	a1 84 4b 5a f0       	mov    0xf05a4b84,%eax
f0116d3f:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0116d42:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0116d45:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0116d48:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116d4d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116d50:	5b                   	pop    %ebx
f0116d51:	5e                   	pop    %esi
f0116d52:	5f                   	pop    %edi
f0116d53:	5d                   	pop    %ebp
f0116d54:	c3                   	ret    

f0116d55 <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0116d55:	55                   	push   %ebp
f0116d56:	89 e5                	mov    %esp,%ebp
f0116d58:	57                   	push   %edi
f0116d59:	56                   	push   %esi
f0116d5a:	53                   	push   %ebx
f0116d5b:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0116d61:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0116d64:	bb 04 d2 12 f0       	mov    $0xf012d204,%ebx
f0116d69:	ba 0f 00 00 00       	mov    $0xf,%edx
f0116d6e:	89 c7                	mov    %eax,%edi
f0116d70:	89 de                	mov    %ebx,%esi
f0116d72:	89 d1                	mov    %edx,%ecx
f0116d74:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116d76:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0116d79:	b9 23 00 00 00       	mov    $0x23,%ecx
f0116d7e:	b0 00                	mov    $0x0,%al
f0116d80:	89 d7                	mov    %edx,%edi
f0116d82:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0116d84:	6a 00                	push   $0x0
f0116d86:	6a 0a                	push   $0xa
f0116d88:	6a 14                	push   $0x14
f0116d8a:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0116d8d:	50                   	push   %eax
f0116d8e:	e8 b2 2c ff ff       	call   f0109a45 <env_create>
f0116d93:	83 c4 10             	add    $0x10,%esp
f0116d96:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0116d99:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116d9c:	8b 40 64             	mov    0x64(%eax),%eax
f0116d9f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0116da2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116da5:	8b 40 68             	mov    0x68(%eax),%eax
f0116da8:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0116dab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116dae:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0116db1:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0116db8:	75 70 20 
f0116dbb:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0116dc2:	00 00 00 
f0116dc5:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0116dc8:	b9 03 00 00 00       	mov    $0x3,%ecx
f0116dcd:	b8 00 00 00 00       	mov    $0x0,%eax
f0116dd2:	89 d7                	mov    %edx,%edi
f0116dd4:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0116dd6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116dd9:	8b 40 10             	mov    0x10(%eax),%eax
f0116ddc:	83 ec 08             	sub    $0x8,%esp
f0116ddf:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0116de5:	52                   	push   %edx
f0116de6:	50                   	push   %eax
f0116de7:	e8 c6 ba 00 00       	call   f01228b2 <ltostr>
f0116dec:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0116def:	83 ec 04             	sub    $0x4,%esp
f0116df2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116df8:	50                   	push   %eax
f0116df9:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0116dff:	50                   	push   %eax
f0116e00:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0116e06:	50                   	push   %eax
f0116e07:	e8 7f bb 00 00       	call   f012298b <strcconcat>
f0116e0c:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0116e0f:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0116e16:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0116e1d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f0116e24:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0116e2b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0116e2f:	83 ec 0c             	sub    $0xc,%esp
f0116e32:	ff 75 d8             	pushl  -0x28(%ebp)
f0116e35:	e8 59 1a 00 00       	call   f0118893 <ClearUserSpace>
f0116e3a:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0116e3d:	83 ec 0c             	sub    $0xc,%esp
f0116e40:	68 48 e3 12 f0       	push   $0xf012e348
f0116e45:	e8 22 a1 fe ff       	call   f0100f6c <cprintf>
f0116e4a:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0116e4d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116e50:	c1 e0 03             	shl    $0x3,%eax
f0116e53:	83 ec 04             	sub    $0x4,%esp
f0116e56:	50                   	push   %eax
f0116e57:	6a 00                	push   $0x0
f0116e59:	ff 75 d8             	pushl  -0x28(%ebp)
f0116e5c:	e8 c6 28 ff ff       	call   f0109727 <calculate_required_frames>
f0116e61:	83 c4 10             	add    $0x10,%esp
f0116e64:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0116e67:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0116e6b:	74 23                	je     f0116e90 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0116e6d:	83 ec 0c             	sub    $0xc,%esp
f0116e70:	6a 03                	push   $0x3
f0116e72:	ff 75 c8             	pushl  -0x38(%ebp)
f0116e75:	68 7c e3 12 f0       	push   $0xf012e37c
f0116e7a:	68 29 06 00 00       	push   $0x629
f0116e7f:	68 02 cb 12 f0       	push   $0xf012cb02
f0116e84:	e8 2e 96 fe ff       	call   f01004b7 <_warn>
f0116e89:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116e8c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116e90:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116e94:	74 04                	je     f0116e9a <test_calculate_required_frames+0x145>
f0116e96:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116e9a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0116e9e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116ea1:	c1 e0 02             	shl    $0x2,%eax
f0116ea4:	83 ec 04             	sub    $0x4,%esp
f0116ea7:	50                   	push   %eax
f0116ea8:	6a 00                	push   $0x0
f0116eaa:	ff 75 d8             	pushl  -0x28(%ebp)
f0116ead:	e8 75 28 ff ff       	call   f0109727 <calculate_required_frames>
f0116eb2:	83 c4 10             	add    $0x10,%esp
f0116eb5:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0116eb8:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0116ebf:	74 26                	je     f0116ee7 <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f0116ec1:	83 ec 0c             	sub    $0xc,%esp
f0116ec4:	68 01 04 00 00       	push   $0x401
f0116ec9:	ff 75 c8             	pushl  -0x38(%ebp)
f0116ecc:	68 7c e3 12 f0       	push   $0xf012e37c
f0116ed1:	68 33 06 00 00       	push   $0x633
f0116ed6:	68 02 cb 12 f0       	push   $0xf012cb02
f0116edb:	e8 d7 95 fe ff       	call   f01004b7 <_warn>
f0116ee0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116ee3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116ee7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116eeb:	74 04                	je     f0116ef1 <test_calculate_required_frames+0x19c>
f0116eed:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116ef1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0116ef5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116ef8:	c1 e0 0a             	shl    $0xa,%eax
f0116efb:	83 ec 04             	sub    $0x4,%esp
f0116efe:	50                   	push   %eax
f0116eff:	6a 00                	push   $0x0
f0116f01:	ff 75 d8             	pushl  -0x28(%ebp)
f0116f04:	e8 1e 28 ff ff       	call   f0109727 <calculate_required_frames>
f0116f09:	83 c4 10             	add    $0x10,%esp
f0116f0c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0116f0f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116f12:	c1 e0 0a             	shl    $0xa,%eax
f0116f15:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116f18:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0116f1f:	99                   	cltd   
f0116f20:	f7 fb                	idiv   %ebx
f0116f22:	89 c1                	mov    %eax,%ecx
f0116f24:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116f27:	c1 e0 0a             	shl    $0xa,%eax
f0116f2a:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0116f2d:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0116f34:	99                   	cltd   
f0116f35:	f7 fe                	idiv   %esi
f0116f37:	01 c8                	add    %ecx,%eax
f0116f39:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116f3c:	74 4c                	je     f0116f8a <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0116f3e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116f41:	c1 e0 0a             	shl    $0xa,%eax
f0116f44:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116f47:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0116f4e:	99                   	cltd   
f0116f4f:	f7 fb                	idiv   %ebx
f0116f51:	89 c1                	mov    %eax,%ecx
f0116f53:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116f56:	c1 e0 0a             	shl    $0xa,%eax
f0116f59:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0116f5c:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0116f63:	99                   	cltd   
f0116f64:	f7 fe                	idiv   %esi
f0116f66:	01 c8                	add    %ecx,%eax
f0116f68:	83 ec 0c             	sub    $0xc,%esp
f0116f6b:	50                   	push   %eax
f0116f6c:	ff 75 c8             	pushl  -0x38(%ebp)
f0116f6f:	68 7c e3 12 f0       	push   $0xf012e37c
f0116f74:	68 3d 06 00 00       	push   $0x63d
f0116f79:	68 02 cb 12 f0       	push   $0xf012cb02
f0116f7e:	e8 34 95 fe ff       	call   f01004b7 <_warn>
f0116f83:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116f86:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116f8a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116f8e:	74 04                	je     f0116f94 <test_calculate_required_frames+0x23f>
f0116f90:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116f94:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0116f98:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0116f9b:	89 d0                	mov    %edx,%eax
f0116f9d:	01 c0                	add    %eax,%eax
f0116f9f:	01 d0                	add    %edx,%eax
f0116fa1:	01 c0                	add    %eax,%eax
f0116fa3:	83 ec 04             	sub    $0x4,%esp
f0116fa6:	50                   	push   %eax
f0116fa7:	68 00 10 00 00       	push   $0x1000
f0116fac:	ff 75 d8             	pushl  -0x28(%ebp)
f0116faf:	e8 73 27 ff ff       	call   f0109727 <calculate_required_frames>
f0116fb4:	83 c4 10             	add    $0x10,%esp
f0116fb7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0116fba:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0116fbe:	74 23                	je     f0116fe3 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0116fc0:	83 ec 0c             	sub    $0xc,%esp
f0116fc3:	6a 03                	push   $0x3
f0116fc5:	ff 75 c8             	pushl  -0x38(%ebp)
f0116fc8:	68 7c e3 12 f0       	push   $0xf012e37c
f0116fcd:	68 49 06 00 00       	push   $0x649
f0116fd2:	68 02 cb 12 f0       	push   $0xf012cb02
f0116fd7:	e8 db 94 fe ff       	call   f01004b7 <_warn>
f0116fdc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116fdf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116fe3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116fe7:	74 04                	je     f0116fed <test_calculate_required_frames+0x298>
f0116fe9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116fed:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0116ff1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116ff4:	89 c2                	mov    %eax,%edx
f0116ff6:	01 d2                	add    %edx,%edx
f0116ff8:	01 d0                	add    %edx,%eax
f0116ffa:	83 ec 04             	sub    $0x4,%esp
f0116ffd:	50                   	push   %eax
f0116ffe:	68 00 18 00 00       	push   $0x1800
f0117003:	ff 75 d8             	pushl  -0x28(%ebp)
f0117006:	e8 1c 27 ff ff       	call   f0109727 <calculate_required_frames>
f011700b:	83 c4 10             	add    $0x10,%esp
f011700e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0117011:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0117015:	74 23                	je     f011703a <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0117017:	83 ec 0c             	sub    $0xc,%esp
f011701a:	6a 03                	push   $0x3
f011701c:	ff 75 c8             	pushl  -0x38(%ebp)
f011701f:	68 7c e3 12 f0       	push   $0xf012e37c
f0117024:	68 53 06 00 00       	push   $0x653
f0117029:	68 02 cb 12 f0       	push   $0xf012cb02
f011702e:	e8 84 94 fe ff       	call   f01004b7 <_warn>
f0117033:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117036:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011703a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011703e:	74 04                	je     f0117044 <test_calculate_required_frames+0x2ef>
f0117040:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117044:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0117048:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011704b:	89 d0                	mov    %edx,%eax
f011704d:	c1 e0 02             	shl    $0x2,%eax
f0117050:	01 d0                	add    %edx,%eax
f0117052:	01 c0                	add    %eax,%eax
f0117054:	83 ec 04             	sub    $0x4,%esp
f0117057:	50                   	push   %eax
f0117058:	68 00 00 40 00       	push   $0x400000
f011705d:	ff 75 d8             	pushl  -0x28(%ebp)
f0117060:	e8 c2 26 ff ff       	call   f0109727 <calculate_required_frames>
f0117065:	83 c4 10             	add    $0x10,%esp
f0117068:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f011706b:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0117072:	74 26                	je     f011709a <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0117074:	83 ec 0c             	sub    $0xc,%esp
f0117077:	68 03 0a 00 00       	push   $0xa03
f011707c:	ff 75 c8             	pushl  -0x38(%ebp)
f011707f:	68 7c e3 12 f0       	push   $0xf012e37c
f0117084:	68 5d 06 00 00       	push   $0x65d
f0117089:	68 02 cb 12 f0       	push   $0xf012cb02
f011708e:	e8 24 94 fe ff       	call   f01004b7 <_warn>
f0117093:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117096:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011709a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011709e:	74 04                	je     f01170a4 <test_calculate_required_frames+0x34f>
f01170a0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01170a4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f01170a8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01170ab:	01 c0                	add    %eax,%eax
f01170ad:	83 ec 04             	sub    $0x4,%esp
f01170b0:	50                   	push   %eax
f01170b1:	68 00 00 70 00       	push   $0x700000
f01170b6:	ff 75 d8             	pushl  -0x28(%ebp)
f01170b9:	e8 69 26 ff ff       	call   f0109727 <calculate_required_frames>
f01170be:	83 c4 10             	add    $0x10,%esp
f01170c1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f01170c4:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f01170cb:	74 26                	je     f01170f3 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f01170cd:	83 ec 0c             	sub    $0xc,%esp
f01170d0:	68 02 02 00 00       	push   $0x202
f01170d5:	ff 75 c8             	pushl  -0x38(%ebp)
f01170d8:	68 7c e3 12 f0       	push   $0xf012e37c
f01170dd:	68 69 06 00 00       	push   $0x669
f01170e2:	68 02 cb 12 f0       	push   $0xf012cb02
f01170e7:	e8 cb 93 fe ff       	call   f01004b7 <_warn>
f01170ec:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01170ef:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01170f3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01170f7:	74 04                	je     f01170fd <test_calculate_required_frames+0x3a8>
f01170f9:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01170fd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0117101:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117104:	83 ec 04             	sub    $0x4,%esp
f0117107:	50                   	push   %eax
f0117108:	68 ff ff 3f 00       	push   $0x3fffff
f011710d:	ff 75 d8             	pushl  -0x28(%ebp)
f0117110:	e8 12 26 ff ff       	call   f0109727 <calculate_required_frames>
f0117115:	83 c4 10             	add    $0x10,%esp
f0117118:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f011711b:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f011711f:	74 23                	je     f0117144 <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0117121:	83 ec 0c             	sub    $0xc,%esp
f0117124:	6a 04                	push   $0x4
f0117126:	ff 75 c8             	pushl  -0x38(%ebp)
f0117129:	68 7c e3 12 f0       	push   $0xf012e37c
f011712e:	68 73 06 00 00       	push   $0x673
f0117133:	68 02 cb 12 f0       	push   $0xf012cb02
f0117138:	e8 7a 93 fe ff       	call   f01004b7 <_warn>
f011713d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117140:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0117144:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117148:	74 04                	je     f011714e <test_calculate_required_frames+0x3f9>
f011714a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011714e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0117152:	83 ec 0c             	sub    $0xc,%esp
f0117155:	68 b5 de 12 f0       	push   $0xf012deb5
f011715a:	e8 0d 9e fe ff       	call   f0100f6c <cprintf>
f011715f:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0117162:	83 ec 0c             	sub    $0xc,%esp
f0117165:	68 d4 e3 12 f0       	push   $0xf012e3d4
f011716a:	e8 fd 9d fe ff       	call   f0100f6c <cprintf>
f011716f:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0117172:	83 ec 04             	sub    $0x4,%esp
f0117175:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f011717b:	50                   	push   %eax
f011717c:	68 6e d2 12 f0       	push   $0xf012d26e
f0117181:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117187:	50                   	push   %eax
f0117188:	e8 fe b7 00 00       	call   f012298b <strcconcat>
f011718d:	83 c4 10             	add    $0x10,%esp
f0117190:	83 ec 0c             	sub    $0xc,%esp
f0117193:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0117199:	50                   	push   %eax
f011719a:	e8 3d ad fe ff       	call   f0101edc <execute_command>
f011719f:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f01171a2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01171a5:	c1 e0 03             	shl    $0x3,%eax
f01171a8:	83 ec 04             	sub    $0x4,%esp
f01171ab:	50                   	push   %eax
f01171ac:	6a 00                	push   $0x0
f01171ae:	ff 75 d8             	pushl  -0x28(%ebp)
f01171b1:	e8 71 25 ff ff       	call   f0109727 <calculate_required_frames>
f01171b6:	83 c4 10             	add    $0x10,%esp
f01171b9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01171bc:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01171c3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01171c6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01171c9:	74 24                	je     f01171ef <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01171cb:	83 ec 0c             	sub    $0xc,%esp
f01171ce:	ff 75 c4             	pushl  -0x3c(%ebp)
f01171d1:	ff 75 c8             	pushl  -0x38(%ebp)
f01171d4:	68 7c e3 12 f0       	push   $0xf012e37c
f01171d9:	68 87 06 00 00       	push   $0x687
f01171de:	68 02 cb 12 f0       	push   $0xf012cb02
f01171e3:	e8 cf 92 fe ff       	call   f01004b7 <_warn>
f01171e8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01171eb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01171ef:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01171f3:	74 04                	je     f01171f9 <test_calculate_required_frames+0x4a4>
f01171f5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01171f9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f01171fd:	83 ec 04             	sub    $0x4,%esp
f0117200:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0117206:	50                   	push   %eax
f0117207:	68 7b d2 12 f0       	push   $0xf012d27b
f011720c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117212:	50                   	push   %eax
f0117213:	e8 73 b7 00 00       	call   f012298b <strcconcat>
f0117218:	83 c4 10             	add    $0x10,%esp
f011721b:	83 ec 0c             	sub    $0xc,%esp
f011721e:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0117224:	50                   	push   %eax
f0117225:	e8 b2 ac fe ff       	call   f0101edc <execute_command>
f011722a:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f011722d:	83 ec 04             	sub    $0x4,%esp
f0117230:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0117236:	50                   	push   %eax
f0117237:	68 08 e4 12 f0       	push   $0xf012e408
f011723c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117242:	50                   	push   %eax
f0117243:	e8 43 b7 00 00       	call   f012298b <strcconcat>
f0117248:	83 c4 10             	add    $0x10,%esp
f011724b:	83 ec 0c             	sub    $0xc,%esp
f011724e:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0117254:	50                   	push   %eax
f0117255:	e8 82 ac fe ff       	call   f0101edc <execute_command>
f011725a:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f011725d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117260:	c1 e0 03             	shl    $0x3,%eax
f0117263:	83 ec 04             	sub    $0x4,%esp
f0117266:	50                   	push   %eax
f0117267:	6a 00                	push   $0x0
f0117269:	ff 75 d8             	pushl  -0x28(%ebp)
f011726c:	e8 b6 24 ff ff       	call   f0109727 <calculate_required_frames>
f0117271:	83 c4 10             	add    $0x10,%esp
f0117274:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0117277:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f011727e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0117281:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117284:	74 24                	je     f01172aa <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0117286:	83 ec 0c             	sub    $0xc,%esp
f0117289:	ff 75 c4             	pushl  -0x3c(%ebp)
f011728c:	ff 75 c8             	pushl  -0x38(%ebp)
f011728f:	68 7c e3 12 f0       	push   $0xf012e37c
f0117294:	68 95 06 00 00       	push   $0x695
f0117299:	68 02 cb 12 f0       	push   $0xf012cb02
f011729e:	e8 14 92 fe ff       	call   f01004b7 <_warn>
f01172a3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01172a6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01172aa:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01172ae:	74 04                	je     f01172b4 <test_calculate_required_frames+0x55f>
f01172b0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01172b4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01172b8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01172bb:	c1 e0 0a             	shl    $0xa,%eax
f01172be:	83 ec 04             	sub    $0x4,%esp
f01172c1:	50                   	push   %eax
f01172c2:	6a 00                	push   $0x0
f01172c4:	ff 75 d8             	pushl  -0x28(%ebp)
f01172c7:	e8 5b 24 ff ff       	call   f0109727 <calculate_required_frames>
f01172cc:	83 c4 10             	add    $0x10,%esp
f01172cf:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f01172d2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01172d5:	c1 e0 0a             	shl    $0xa,%eax
f01172d8:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01172db:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01172e2:	99                   	cltd   
f01172e3:	f7 fb                	idiv   %ebx
f01172e5:	89 c1                	mov    %eax,%ecx
f01172e7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01172ea:	c1 e0 0a             	shl    $0xa,%eax
f01172ed:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01172f0:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01172f7:	99                   	cltd   
f01172f8:	f7 fe                	idiv   %esi
f01172fa:	01 c8                	add    %ecx,%eax
f01172fc:	83 e8 05             	sub    $0x5,%eax
f01172ff:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0117302:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0117305:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117308:	74 24                	je     f011732e <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011730a:	83 ec 0c             	sub    $0xc,%esp
f011730d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0117310:	ff 75 c8             	pushl  -0x38(%ebp)
f0117313:	68 7c e3 12 f0       	push   $0xf012e37c
f0117318:	68 a0 06 00 00       	push   $0x6a0
f011731d:	68 02 cb 12 f0       	push   $0xf012cb02
f0117322:	e8 90 91 fe ff       	call   f01004b7 <_warn>
f0117327:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011732a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011732e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117332:	74 04                	je     f0117338 <test_calculate_required_frames+0x5e3>
f0117334:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117338:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f011733c:	83 ec 04             	sub    $0x4,%esp
f011733f:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0117345:	50                   	push   %eax
f0117346:	68 14 e4 12 f0       	push   $0xf012e414
f011734b:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117351:	50                   	push   %eax
f0117352:	e8 34 b6 00 00       	call   f012298b <strcconcat>
f0117357:	83 c4 10             	add    $0x10,%esp
f011735a:	83 ec 0c             	sub    $0xc,%esp
f011735d:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0117363:	50                   	push   %eax
f0117364:	e8 73 ab fe ff       	call   f0101edc <execute_command>
f0117369:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f011736c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011736f:	89 c2                	mov    %eax,%edx
f0117371:	01 d2                	add    %edx,%edx
f0117373:	01 d0                	add    %edx,%eax
f0117375:	83 ec 04             	sub    $0x4,%esp
f0117378:	50                   	push   %eax
f0117379:	68 00 18 00 00       	push   $0x1800
f011737e:	ff 75 d8             	pushl  -0x28(%ebp)
f0117381:	e8 a1 23 ff ff       	call   f0109727 <calculate_required_frames>
f0117386:	83 c4 10             	add    $0x10,%esp
f0117389:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f011738c:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0117393:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0117396:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117399:	74 24                	je     f01173bf <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011739b:	83 ec 0c             	sub    $0xc,%esp
f011739e:	ff 75 c4             	pushl  -0x3c(%ebp)
f01173a1:	ff 75 c8             	pushl  -0x38(%ebp)
f01173a4:	68 7c e3 12 f0       	push   $0xf012e37c
f01173a9:	68 af 06 00 00       	push   $0x6af
f01173ae:	68 02 cb 12 f0       	push   $0xf012cb02
f01173b3:	e8 ff 90 fe ff       	call   f01004b7 <_warn>
f01173b8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01173bb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01173bf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01173c3:	74 04                	je     f01173c9 <test_calculate_required_frames+0x674>
f01173c5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01173c9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f01173cd:	83 ec 04             	sub    $0x4,%esp
f01173d0:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01173d6:	50                   	push   %eax
f01173d7:	68 d4 d4 12 f0       	push   $0xf012d4d4
f01173dc:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01173e2:	50                   	push   %eax
f01173e3:	e8 a3 b5 00 00       	call   f012298b <strcconcat>
f01173e8:	83 c4 10             	add    $0x10,%esp
f01173eb:	83 ec 0c             	sub    $0xc,%esp
f01173ee:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01173f4:	50                   	push   %eax
f01173f5:	e8 e2 aa fe ff       	call   f0101edc <execute_command>
f01173fa:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01173fd:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0117400:	89 d0                	mov    %edx,%eax
f0117402:	c1 e0 02             	shl    $0x2,%eax
f0117405:	01 d0                	add    %edx,%eax
f0117407:	01 c0                	add    %eax,%eax
f0117409:	83 ec 04             	sub    $0x4,%esp
f011740c:	50                   	push   %eax
f011740d:	68 00 00 40 00       	push   $0x400000
f0117412:	ff 75 d8             	pushl  -0x28(%ebp)
f0117415:	e8 0d 23 ff ff       	call   f0109727 <calculate_required_frames>
f011741a:	83 c4 10             	add    $0x10,%esp
f011741d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0117420:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f0117427:	74 26                	je     f011744f <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0117429:	83 ec 0c             	sub    $0xc,%esp
f011742c:	68 03 0a 00 00       	push   $0xa03
f0117431:	ff 75 c8             	pushl  -0x38(%ebp)
f0117434:	68 7c e3 12 f0       	push   $0xf012e37c
f0117439:	68 bb 06 00 00       	push   $0x6bb
f011743e:	68 02 cb 12 f0       	push   $0xf012cb02
f0117443:	e8 6f 90 fe ff       	call   f01004b7 <_warn>
f0117448:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011744b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011744f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117453:	74 04                	je     f0117459 <test_calculate_required_frames+0x704>
f0117455:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117459:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f011745d:	83 ec 04             	sub    $0x4,%esp
f0117460:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0117466:	50                   	push   %eax
f0117467:	68 de d4 12 f0       	push   $0xf012d4de
f011746c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117472:	50                   	push   %eax
f0117473:	e8 13 b5 00 00       	call   f012298b <strcconcat>
f0117478:	83 c4 10             	add    $0x10,%esp
f011747b:	83 ec 0c             	sub    $0xc,%esp
f011747e:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0117484:	50                   	push   %eax
f0117485:	e8 52 aa fe ff       	call   f0101edc <execute_command>
f011748a:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f011748d:	83 ec 04             	sub    $0x4,%esp
f0117490:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0117496:	50                   	push   %eax
f0117497:	68 1c e4 12 f0       	push   $0xf012e41c
f011749c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01174a2:	50                   	push   %eax
f01174a3:	e8 e3 b4 00 00       	call   f012298b <strcconcat>
f01174a8:	83 c4 10             	add    $0x10,%esp
f01174ab:	83 ec 0c             	sub    $0xc,%esp
f01174ae:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01174b4:	50                   	push   %eax
f01174b5:	e8 22 aa fe ff       	call   f0101edc <execute_command>
f01174ba:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f01174bd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01174c0:	01 c0                	add    %eax,%eax
f01174c2:	83 ec 04             	sub    $0x4,%esp
f01174c5:	50                   	push   %eax
f01174c6:	68 00 00 70 00       	push   $0x700000
f01174cb:	ff 75 d8             	pushl  -0x28(%ebp)
f01174ce:	e8 54 22 ff ff       	call   f0109727 <calculate_required_frames>
f01174d3:	83 c4 10             	add    $0x10,%esp
f01174d6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f01174d9:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f01174e0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01174e3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01174e6:	74 24                	je     f011750c <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01174e8:	83 ec 0c             	sub    $0xc,%esp
f01174eb:	ff 75 c4             	pushl  -0x3c(%ebp)
f01174ee:	ff 75 c8             	pushl  -0x38(%ebp)
f01174f1:	68 7c e3 12 f0       	push   $0xf012e37c
f01174f6:	68 cb 06 00 00       	push   $0x6cb
f01174fb:	68 02 cb 12 f0       	push   $0xf012cb02
f0117500:	e8 b2 8f fe ff       	call   f01004b7 <_warn>
f0117505:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117508:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011750c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117510:	74 04                	je     f0117516 <test_calculate_required_frames+0x7c1>
f0117512:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117516:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f011751a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011751d:	83 ec 04             	sub    $0x4,%esp
f0117520:	50                   	push   %eax
f0117521:	68 ff ff 3f 00       	push   $0x3fffff
f0117526:	ff 75 d8             	pushl  -0x28(%ebp)
f0117529:	e8 f9 21 ff ff       	call   f0109727 <calculate_required_frames>
f011752e:	83 c4 10             	add    $0x10,%esp
f0117531:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f0117534:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f011753b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011753e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117541:	74 24                	je     f0117567 <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0117543:	83 ec 0c             	sub    $0xc,%esp
f0117546:	ff 75 c4             	pushl  -0x3c(%ebp)
f0117549:	ff 75 c8             	pushl  -0x38(%ebp)
f011754c:	68 7c e3 12 f0       	push   $0xf012e37c
f0117551:	68 d6 06 00 00       	push   $0x6d6
f0117556:	68 02 cb 12 f0       	push   $0xf012cb02
f011755b:	e8 57 8f fe ff       	call   f01004b7 <_warn>
f0117560:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117563:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0117567:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011756b:	74 04                	je     f0117571 <test_calculate_required_frames+0x81c>
f011756d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117571:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0117575:	83 ec 0c             	sub    $0xc,%esp
f0117578:	68 8f d4 12 f0       	push   $0xf012d48f
f011757d:	e8 ea 99 fe ff       	call   f0100f6c <cprintf>
f0117582:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0117585:	83 ec 08             	sub    $0x8,%esp
f0117588:	ff 75 e4             	pushl  -0x1c(%ebp)
f011758b:	68 28 e4 12 f0       	push   $0xf012e428
f0117590:	e8 d7 99 fe ff       	call   f0100f6c <cprintf>
f0117595:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0117598:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f011759c:	75 10                	jne    f01175ae <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f011759e:	83 ec 0c             	sub    $0xc,%esp
f01175a1:	68 68 e4 12 f0       	push   $0xf012e468
f01175a6:	e8 c1 99 fe ff       	call   f0100f6c <cprintf>
f01175ab:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01175ae:	a1 84 4b 5a f0       	mov    0xf05a4b84,%eax
f01175b3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01175b6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01175b9:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01175bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01175c1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01175c4:	5b                   	pop    %ebx
f01175c5:	5e                   	pop    %esi
f01175c6:	5f                   	pop    %edi
f01175c7:	5d                   	pop    %ebp
f01175c8:	c3                   	ret    

f01175c9 <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f01175c9:	55                   	push   %ebp
f01175ca:	89 e5                	mov    %esp,%ebp
f01175cc:	57                   	push   %edi
f01175cd:	56                   	push   %esi
f01175ce:	53                   	push   %ebx
f01175cf:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01175d5:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01175d8:	bb 04 d2 12 f0       	mov    $0xf012d204,%ebx
f01175dd:	ba 0f 00 00 00       	mov    $0xf,%edx
f01175e2:	89 c7                	mov    %eax,%edi
f01175e4:	89 de                	mov    %ebx,%esi
f01175e6:	89 d1                	mov    %edx,%ecx
f01175e8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01175ea:	8d 55 9d             	lea    -0x63(%ebp),%edx
f01175ed:	b9 23 00 00 00       	mov    $0x23,%ecx
f01175f2:	b0 00                	mov    $0x0,%al
f01175f4:	89 d7                	mov    %edx,%edi
f01175f6:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01175f8:	6a 00                	push   $0x0
f01175fa:	6a 0a                	push   $0xa
f01175fc:	6a 14                	push   $0x14
f01175fe:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0117601:	50                   	push   %eax
f0117602:	e8 3e 24 ff ff       	call   f0109a45 <env_create>
f0117607:	83 c4 10             	add    $0x10,%esp
f011760a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011760d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117610:	8b 40 64             	mov    0x64(%eax),%eax
f0117613:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0117616:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117619:	8b 40 68             	mov    0x68(%eax),%eax
f011761c:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011761f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117622:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0117625:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f011762c:	75 70 20 
f011762f:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0117636:	00 00 00 
f0117639:	8d 55 82             	lea    -0x7e(%ebp),%edx
f011763c:	b9 03 00 00 00       	mov    $0x3,%ecx
f0117641:	b8 00 00 00 00       	mov    $0x0,%eax
f0117646:	89 d7                	mov    %edx,%edi
f0117648:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f011764a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011764d:	8b 40 10             	mov    0x10(%eax),%eax
f0117650:	83 ec 08             	sub    $0x8,%esp
f0117653:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0117659:	52                   	push   %edx
f011765a:	50                   	push   %eax
f011765b:	e8 52 b2 00 00       	call   f01228b2 <ltostr>
f0117660:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0117663:	83 ec 04             	sub    $0x4,%esp
f0117666:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011766c:	50                   	push   %eax
f011766d:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0117673:	50                   	push   %eax
f0117674:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f011767a:	50                   	push   %eax
f011767b:	e8 0b b3 00 00       	call   f012298b <strcconcat>
f0117680:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0117683:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011768a:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0117691:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0117698:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f011769c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01176a3:	00 00 00 
	uint32 num_tables = 0;
f01176a6:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01176ad:	00 00 00 
	ClearUserSpace(proc_directory);
f01176b0:	83 ec 0c             	sub    $0xc,%esp
f01176b3:	ff 75 d8             	pushl  -0x28(%ebp)
f01176b6:	e8 d8 11 00 00       	call   f0118893 <ClearUserSpace>
f01176bb:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f01176be:	83 ec 0c             	sub    $0xc,%esp
f01176c1:	68 48 e3 12 f0       	push   $0xf012e348
f01176c6:	e8 a1 98 fe ff       	call   f0100f6c <cprintf>
f01176cb:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f01176ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01176d1:	c1 e0 03             	shl    $0x3,%eax
f01176d4:	89 c2                	mov    %eax,%edx
f01176d6:	83 ec 0c             	sub    $0xc,%esp
f01176d9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01176df:	50                   	push   %eax
f01176e0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01176e6:	50                   	push   %eax
f01176e7:	52                   	push   %edx
f01176e8:	6a 00                	push   $0x0
f01176ea:	ff 75 d8             	pushl  -0x28(%ebp)
f01176ed:	e8 1b 20 ff ff       	call   f010970d <calculate_allocated_space>
f01176f2:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01176f5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01176fb:	85 c0                	test   %eax,%eax
f01176fd:	74 27                	je     f0117726 <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01176ff:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117705:	83 ec 0c             	sub    $0xc,%esp
f0117708:	6a 00                	push   $0x0
f011770a:	50                   	push   %eax
f011770b:	68 b4 e4 12 f0       	push   $0xf012e4b4
f0117710:	68 0b 07 00 00       	push   $0x70b
f0117715:	68 02 cb 12 f0       	push   $0xf012cb02
f011771a:	e8 98 8d fe ff       	call   f01004b7 <_warn>
f011771f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117722:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0117726:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011772c:	85 c0                	test   %eax,%eax
f011772e:	74 27                	je     f0117757 <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0117730:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117736:	83 ec 0c             	sub    $0xc,%esp
f0117739:	6a 00                	push   $0x0
f011773b:	50                   	push   %eax
f011773c:	68 14 e5 12 f0       	push   $0xf012e514
f0117741:	68 10 07 00 00       	push   $0x710
f0117746:	68 02 cb 12 f0       	push   $0xf012cb02
f011774b:	e8 67 8d fe ff       	call   f01004b7 <_warn>
f0117750:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117753:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117757:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011775b:	74 04                	je     f0117761 <test_calculate_allocated_space+0x198>
f011775d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117761:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0117765:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011776c:	00 00 00 
		num_pages = 0;
f011776f:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117776:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0117779:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011777c:	c1 e0 02             	shl    $0x2,%eax
f011777f:	89 c2                	mov    %eax,%edx
f0117781:	83 ec 0c             	sub    $0xc,%esp
f0117784:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011778a:	50                   	push   %eax
f011778b:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117791:	50                   	push   %eax
f0117792:	52                   	push   %edx
f0117793:	6a 00                	push   $0x0
f0117795:	ff 75 d8             	pushl  -0x28(%ebp)
f0117798:	e8 70 1f ff ff       	call   f010970d <calculate_allocated_space>
f011779d:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01177a0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01177a6:	85 c0                	test   %eax,%eax
f01177a8:	74 27                	je     f01177d1 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01177aa:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01177b0:	83 ec 0c             	sub    $0xc,%esp
f01177b3:	6a 00                	push   $0x0
f01177b5:	50                   	push   %eax
f01177b6:	68 b4 e4 12 f0       	push   $0xf012e4b4
f01177bb:	68 1c 07 00 00       	push   $0x71c
f01177c0:	68 02 cb 12 f0       	push   $0xf012cb02
f01177c5:	e8 ed 8c fe ff       	call   f01004b7 <_warn>
f01177ca:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01177cd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01177d1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01177d7:	85 c0                	test   %eax,%eax
f01177d9:	74 27                	je     f0117802 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01177db:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01177e1:	83 ec 0c             	sub    $0xc,%esp
f01177e4:	6a 00                	push   $0x0
f01177e6:	50                   	push   %eax
f01177e7:	68 14 e5 12 f0       	push   $0xf012e514
f01177ec:	68 21 07 00 00       	push   $0x721
f01177f1:	68 02 cb 12 f0       	push   $0xf012cb02
f01177f6:	e8 bc 8c fe ff       	call   f01004b7 <_warn>
f01177fb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01177fe:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117802:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117806:	74 04                	je     f011780c <test_calculate_allocated_space+0x243>
f0117808:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011780c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0117810:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117817:	00 00 00 
		num_pages = 0;
f011781a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117821:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0117824:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117827:	c1 e0 0a             	shl    $0xa,%eax
f011782a:	89 c2                	mov    %eax,%edx
f011782c:	83 ec 0c             	sub    $0xc,%esp
f011782f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117835:	50                   	push   %eax
f0117836:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011783c:	50                   	push   %eax
f011783d:	52                   	push   %edx
f011783e:	6a 00                	push   $0x0
f0117840:	ff 75 d8             	pushl  -0x28(%ebp)
f0117843:	e8 c5 1e ff ff       	call   f010970d <calculate_allocated_space>
f0117848:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011784b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117851:	85 c0                	test   %eax,%eax
f0117853:	74 27                	je     f011787c <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0117855:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011785b:	83 ec 0c             	sub    $0xc,%esp
f011785e:	6a 00                	push   $0x0
f0117860:	50                   	push   %eax
f0117861:	68 b4 e4 12 f0       	push   $0xf012e4b4
f0117866:	68 2d 07 00 00       	push   $0x72d
f011786b:	68 02 cb 12 f0       	push   $0xf012cb02
f0117870:	e8 42 8c fe ff       	call   f01004b7 <_warn>
f0117875:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117878:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011787c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117882:	85 c0                	test   %eax,%eax
f0117884:	74 27                	je     f01178ad <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0117886:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011788c:	83 ec 0c             	sub    $0xc,%esp
f011788f:	6a 00                	push   $0x0
f0117891:	50                   	push   %eax
f0117892:	68 14 e5 12 f0       	push   $0xf012e514
f0117897:	68 32 07 00 00       	push   $0x732
f011789c:	68 02 cb 12 f0       	push   $0xf012cb02
f01178a1:	e8 11 8c fe ff       	call   f01004b7 <_warn>
f01178a6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01178a9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01178ad:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01178b1:	74 04                	je     f01178b7 <test_calculate_allocated_space+0x2ee>
f01178b3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01178b7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f01178bb:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01178c2:	00 00 00 
		num_pages = 0;
f01178c5:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01178cc:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f01178cf:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01178d2:	89 d0                	mov    %edx,%eax
f01178d4:	01 c0                	add    %eax,%eax
f01178d6:	01 d0                	add    %edx,%eax
f01178d8:	01 c0                	add    %eax,%eax
f01178da:	05 00 10 00 00       	add    $0x1000,%eax
f01178df:	89 c2                	mov    %eax,%edx
f01178e1:	83 ec 0c             	sub    $0xc,%esp
f01178e4:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01178ea:	50                   	push   %eax
f01178eb:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01178f1:	50                   	push   %eax
f01178f2:	52                   	push   %edx
f01178f3:	68 00 10 00 00       	push   $0x1000
f01178f8:	ff 75 d8             	pushl  -0x28(%ebp)
f01178fb:	e8 0d 1e ff ff       	call   f010970d <calculate_allocated_space>
f0117900:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0117903:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117909:	85 c0                	test   %eax,%eax
f011790b:	74 27                	je     f0117934 <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011790d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117913:	83 ec 0c             	sub    $0xc,%esp
f0117916:	6a 00                	push   $0x0
f0117918:	50                   	push   %eax
f0117919:	68 b4 e4 12 f0       	push   $0xf012e4b4
f011791e:	68 3f 07 00 00       	push   $0x73f
f0117923:	68 02 cb 12 f0       	push   $0xf012cb02
f0117928:	e8 8a 8b fe ff       	call   f01004b7 <_warn>
f011792d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117930:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0117934:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011793a:	85 c0                	test   %eax,%eax
f011793c:	74 27                	je     f0117965 <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011793e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117944:	83 ec 0c             	sub    $0xc,%esp
f0117947:	6a 00                	push   $0x0
f0117949:	50                   	push   %eax
f011794a:	68 14 e5 12 f0       	push   $0xf012e514
f011794f:	68 44 07 00 00       	push   $0x744
f0117954:	68 02 cb 12 f0       	push   $0xf012cb02
f0117959:	e8 59 8b fe ff       	call   f01004b7 <_warn>
f011795e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117961:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117965:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117969:	74 04                	je     f011796f <test_calculate_allocated_space+0x3a6>
f011796b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011796f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0117973:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011797a:	00 00 00 
		num_pages = 0;
f011797d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117984:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0117987:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011798a:	89 c2                	mov    %eax,%edx
f011798c:	01 d2                	add    %edx,%edx
f011798e:	01 d0                	add    %edx,%eax
f0117990:	05 00 18 00 00       	add    $0x1800,%eax
f0117995:	89 c2                	mov    %eax,%edx
f0117997:	83 ec 0c             	sub    $0xc,%esp
f011799a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01179a0:	50                   	push   %eax
f01179a1:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01179a7:	50                   	push   %eax
f01179a8:	52                   	push   %edx
f01179a9:	68 00 18 00 00       	push   $0x1800
f01179ae:	ff 75 d8             	pushl  -0x28(%ebp)
f01179b1:	e8 57 1d ff ff       	call   f010970d <calculate_allocated_space>
f01179b6:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01179b9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01179bf:	85 c0                	test   %eax,%eax
f01179c1:	74 27                	je     f01179ea <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01179c3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01179c9:	83 ec 0c             	sub    $0xc,%esp
f01179cc:	6a 00                	push   $0x0
f01179ce:	50                   	push   %eax
f01179cf:	68 b4 e4 12 f0       	push   $0xf012e4b4
f01179d4:	68 50 07 00 00       	push   $0x750
f01179d9:	68 02 cb 12 f0       	push   $0xf012cb02
f01179de:	e8 d4 8a fe ff       	call   f01004b7 <_warn>
f01179e3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01179e6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01179ea:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01179f0:	85 c0                	test   %eax,%eax
f01179f2:	74 27                	je     f0117a1b <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01179f4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01179fa:	83 ec 0c             	sub    $0xc,%esp
f01179fd:	6a 00                	push   $0x0
f01179ff:	50                   	push   %eax
f0117a00:	68 14 e5 12 f0       	push   $0xf012e514
f0117a05:	68 55 07 00 00       	push   $0x755
f0117a0a:	68 02 cb 12 f0       	push   $0xf012cb02
f0117a0f:	e8 a3 8a fe ff       	call   f01004b7 <_warn>
f0117a14:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117a17:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117a1b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117a1f:	74 04                	je     f0117a25 <test_calculate_allocated_space+0x45c>
f0117a21:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117a25:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0117a29:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117a30:	00 00 00 
		num_pages = 0;
f0117a33:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117a3a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0117a3d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0117a40:	89 d0                	mov    %edx,%eax
f0117a42:	c1 e0 02             	shl    $0x2,%eax
f0117a45:	01 d0                	add    %edx,%eax
f0117a47:	01 c0                	add    %eax,%eax
f0117a49:	05 00 00 40 00       	add    $0x400000,%eax
f0117a4e:	89 c2                	mov    %eax,%edx
f0117a50:	83 ec 0c             	sub    $0xc,%esp
f0117a53:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117a59:	50                   	push   %eax
f0117a5a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117a60:	50                   	push   %eax
f0117a61:	52                   	push   %edx
f0117a62:	68 00 00 40 00       	push   $0x400000
f0117a67:	ff 75 d8             	pushl  -0x28(%ebp)
f0117a6a:	e8 9e 1c ff ff       	call   f010970d <calculate_allocated_space>
f0117a6f:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0117a72:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117a78:	85 c0                	test   %eax,%eax
f0117a7a:	74 27                	je     f0117aa3 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0117a7c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117a82:	83 ec 0c             	sub    $0xc,%esp
f0117a85:	6a 00                	push   $0x0
f0117a87:	50                   	push   %eax
f0117a88:	68 b4 e4 12 f0       	push   $0xf012e4b4
f0117a8d:	68 61 07 00 00       	push   $0x761
f0117a92:	68 02 cb 12 f0       	push   $0xf012cb02
f0117a97:	e8 1b 8a fe ff       	call   f01004b7 <_warn>
f0117a9c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117a9f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0117aa3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117aa9:	85 c0                	test   %eax,%eax
f0117aab:	74 27                	je     f0117ad4 <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0117aad:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117ab3:	83 ec 0c             	sub    $0xc,%esp
f0117ab6:	6a 00                	push   $0x0
f0117ab8:	50                   	push   %eax
f0117ab9:	68 14 e5 12 f0       	push   $0xf012e514
f0117abe:	68 66 07 00 00       	push   $0x766
f0117ac3:	68 02 cb 12 f0       	push   $0xf012cb02
f0117ac8:	e8 ea 89 fe ff       	call   f01004b7 <_warn>
f0117acd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117ad0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117ad4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117ad8:	74 04                	je     f0117ade <test_calculate_allocated_space+0x515>
f0117ada:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117ade:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0117ae2:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117ae9:	00 00 00 
		num_pages = 0;
f0117aec:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117af3:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0117af6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117af9:	05 00 00 38 00       	add    $0x380000,%eax
f0117afe:	01 c0                	add    %eax,%eax
f0117b00:	89 c2                	mov    %eax,%edx
f0117b02:	83 ec 0c             	sub    $0xc,%esp
f0117b05:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117b0b:	50                   	push   %eax
f0117b0c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117b12:	50                   	push   %eax
f0117b13:	52                   	push   %edx
f0117b14:	68 00 00 70 00       	push   $0x700000
f0117b19:	ff 75 d8             	pushl  -0x28(%ebp)
f0117b1c:	e8 ec 1b ff ff       	call   f010970d <calculate_allocated_space>
f0117b21:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0117b24:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117b2a:	85 c0                	test   %eax,%eax
f0117b2c:	74 27                	je     f0117b55 <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0117b2e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117b34:	83 ec 0c             	sub    $0xc,%esp
f0117b37:	6a 00                	push   $0x0
f0117b39:	50                   	push   %eax
f0117b3a:	68 b4 e4 12 f0       	push   $0xf012e4b4
f0117b3f:	68 73 07 00 00       	push   $0x773
f0117b44:	68 02 cb 12 f0       	push   $0xf012cb02
f0117b49:	e8 69 89 fe ff       	call   f01004b7 <_warn>
f0117b4e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117b51:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0117b55:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117b5b:	85 c0                	test   %eax,%eax
f0117b5d:	74 27                	je     f0117b86 <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0117b5f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117b65:	83 ec 0c             	sub    $0xc,%esp
f0117b68:	6a 00                	push   $0x0
f0117b6a:	50                   	push   %eax
f0117b6b:	68 14 e5 12 f0       	push   $0xf012e514
f0117b70:	68 78 07 00 00       	push   $0x778
f0117b75:	68 02 cb 12 f0       	push   $0xf012cb02
f0117b7a:	e8 38 89 fe ff       	call   f01004b7 <_warn>
f0117b7f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117b82:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0117b86:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117b8a:	74 04                	je     f0117b90 <test_calculate_allocated_space+0x5c7>
f0117b8c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117b90:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0117b94:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117b9b:	00 00 00 
		num_pages = 0;
f0117b9e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117ba5:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0117ba8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117bab:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0117bb0:	89 c2                	mov    %eax,%edx
f0117bb2:	83 ec 0c             	sub    $0xc,%esp
f0117bb5:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117bbb:	50                   	push   %eax
f0117bbc:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117bc2:	50                   	push   %eax
f0117bc3:	52                   	push   %edx
f0117bc4:	68 ff ff 3f 00       	push   $0x3fffff
f0117bc9:	ff 75 d8             	pushl  -0x28(%ebp)
f0117bcc:	e8 3c 1b ff ff       	call   f010970d <calculate_allocated_space>
f0117bd1:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0117bd4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117bda:	85 c0                	test   %eax,%eax
f0117bdc:	74 27                	je     f0117c05 <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0117bde:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117be4:	83 ec 0c             	sub    $0xc,%esp
f0117be7:	6a 00                	push   $0x0
f0117be9:	50                   	push   %eax
f0117bea:	68 b4 e4 12 f0       	push   $0xf012e4b4
f0117bef:	68 84 07 00 00       	push   $0x784
f0117bf4:	68 02 cb 12 f0       	push   $0xf012cb02
f0117bf9:	e8 b9 88 fe ff       	call   f01004b7 <_warn>
f0117bfe:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117c01:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0117c05:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117c0b:	85 c0                	test   %eax,%eax
f0117c0d:	74 27                	je     f0117c36 <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0117c0f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117c15:	83 ec 0c             	sub    $0xc,%esp
f0117c18:	6a 00                	push   $0x0
f0117c1a:	50                   	push   %eax
f0117c1b:	68 14 e5 12 f0       	push   $0xf012e514
f0117c20:	68 89 07 00 00       	push   $0x789
f0117c25:	68 02 cb 12 f0       	push   $0xf012cb02
f0117c2a:	e8 88 88 fe ff       	call   f01004b7 <_warn>
f0117c2f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117c32:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0117c36:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117c3a:	74 04                	je     f0117c40 <test_calculate_allocated_space+0x677>
f0117c3c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117c40:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0117c44:	83 ec 0c             	sub    $0xc,%esp
f0117c47:	68 b5 de 12 f0       	push   $0xf012deb5
f0117c4c:	e8 1b 93 fe ff       	call   f0100f6c <cprintf>
f0117c51:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0117c54:	83 ec 0c             	sub    $0xc,%esp
f0117c57:	68 d4 e3 12 f0       	push   $0xf012e3d4
f0117c5c:	e8 0b 93 fe ff       	call   f0100f6c <cprintf>
f0117c61:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0117c64:	83 ec 04             	sub    $0x4,%esp
f0117c67:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0117c6d:	50                   	push   %eax
f0117c6e:	68 6e d2 12 f0       	push   $0xf012d26e
f0117c73:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117c79:	50                   	push   %eax
f0117c7a:	e8 0c ad 00 00       	call   f012298b <strcconcat>
f0117c7f:	83 c4 10             	add    $0x10,%esp
f0117c82:	83 ec 0c             	sub    $0xc,%esp
f0117c85:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0117c8b:	50                   	push   %eax
f0117c8c:	e8 4b a2 fe ff       	call   f0101edc <execute_command>
f0117c91:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0117c94:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117c9b:	00 00 00 
		num_pages = 0;
f0117c9e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117ca5:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0117ca8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117cab:	c1 e0 03             	shl    $0x3,%eax
f0117cae:	89 c2                	mov    %eax,%edx
f0117cb0:	83 ec 0c             	sub    $0xc,%esp
f0117cb3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117cb9:	50                   	push   %eax
f0117cba:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117cc0:	50                   	push   %eax
f0117cc1:	52                   	push   %edx
f0117cc2:	6a 00                	push   $0x0
f0117cc4:	ff 75 d8             	pushl  -0x28(%ebp)
f0117cc7:	e8 41 1a ff ff       	call   f010970d <calculate_allocated_space>
f0117ccc:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0117ccf:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0117cd6:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0117cdd:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117ce3:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0117ce6:	74 28                	je     f0117d10 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0117ce8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117cee:	83 ec 0c             	sub    $0xc,%esp
f0117cf1:	ff 75 c8             	pushl  -0x38(%ebp)
f0117cf4:	50                   	push   %eax
f0117cf5:	68 b4 e4 12 f0       	push   $0xf012e4b4
f0117cfa:	68 a0 07 00 00       	push   $0x7a0
f0117cff:	68 02 cb 12 f0       	push   $0xf012cb02
f0117d04:	e8 ae 87 fe ff       	call   f01004b7 <_warn>
f0117d09:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117d0c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0117d10:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117d16:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117d19:	74 28                	je     f0117d43 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0117d1b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117d21:	83 ec 0c             	sub    $0xc,%esp
f0117d24:	ff 75 c4             	pushl  -0x3c(%ebp)
f0117d27:	50                   	push   %eax
f0117d28:	68 14 e5 12 f0       	push   $0xf012e514
f0117d2d:	68 a5 07 00 00       	push   $0x7a5
f0117d32:	68 02 cb 12 f0       	push   $0xf012cb02
f0117d37:	e8 7b 87 fe ff       	call   f01004b7 <_warn>
f0117d3c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117d3f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117d43:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117d47:	74 04                	je     f0117d4d <test_calculate_allocated_space+0x784>
f0117d49:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117d4d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0117d51:	83 ec 04             	sub    $0x4,%esp
f0117d54:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0117d5a:	50                   	push   %eax
f0117d5b:	68 7b d2 12 f0       	push   $0xf012d27b
f0117d60:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117d66:	50                   	push   %eax
f0117d67:	e8 1f ac 00 00       	call   f012298b <strcconcat>
f0117d6c:	83 c4 10             	add    $0x10,%esp
f0117d6f:	83 ec 0c             	sub    $0xc,%esp
f0117d72:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0117d78:	50                   	push   %eax
f0117d79:	e8 5e a1 fe ff       	call   f0101edc <execute_command>
f0117d7e:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0117d81:	83 ec 04             	sub    $0x4,%esp
f0117d84:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0117d8a:	50                   	push   %eax
f0117d8b:	68 08 e4 12 f0       	push   $0xf012e408
f0117d90:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117d96:	50                   	push   %eax
f0117d97:	e8 ef ab 00 00       	call   f012298b <strcconcat>
f0117d9c:	83 c4 10             	add    $0x10,%esp
f0117d9f:	83 ec 0c             	sub    $0xc,%esp
f0117da2:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0117da8:	50                   	push   %eax
f0117da9:	e8 2e a1 fe ff       	call   f0101edc <execute_command>
f0117dae:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f0117db1:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117db8:	00 00 00 
		num_pages = 0;
f0117dbb:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117dc2:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0117dc5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117dc8:	c1 e0 03             	shl    $0x3,%eax
f0117dcb:	89 c2                	mov    %eax,%edx
f0117dcd:	83 ec 0c             	sub    $0xc,%esp
f0117dd0:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117dd6:	50                   	push   %eax
f0117dd7:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117ddd:	50                   	push   %eax
f0117dde:	52                   	push   %edx
f0117ddf:	6a 00                	push   $0x0
f0117de1:	ff 75 d8             	pushl  -0x28(%ebp)
f0117de4:	e8 24 19 ff ff       	call   f010970d <calculate_allocated_space>
f0117de9:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0117dec:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f0117df3:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0117dfa:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117e00:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0117e03:	74 28                	je     f0117e2d <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0117e05:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117e0b:	83 ec 0c             	sub    $0xc,%esp
f0117e0e:	ff 75 c8             	pushl  -0x38(%ebp)
f0117e11:	50                   	push   %eax
f0117e12:	68 b4 e4 12 f0       	push   $0xf012e4b4
f0117e17:	68 b6 07 00 00       	push   $0x7b6
f0117e1c:	68 02 cb 12 f0       	push   $0xf012cb02
f0117e21:	e8 91 86 fe ff       	call   f01004b7 <_warn>
f0117e26:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117e29:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0117e2d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117e33:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117e36:	74 28                	je     f0117e60 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0117e38:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117e3e:	83 ec 0c             	sub    $0xc,%esp
f0117e41:	ff 75 c4             	pushl  -0x3c(%ebp)
f0117e44:	50                   	push   %eax
f0117e45:	68 14 e5 12 f0       	push   $0xf012e514
f0117e4a:	68 bb 07 00 00       	push   $0x7bb
f0117e4f:	68 02 cb 12 f0       	push   $0xf012cb02
f0117e54:	e8 5e 86 fe ff       	call   f01004b7 <_warn>
f0117e59:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117e5c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117e60:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117e64:	74 04                	je     f0117e6a <test_calculate_allocated_space+0x8a1>
f0117e66:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117e6a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0117e6e:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117e75:	00 00 00 
		num_pages = 0;
f0117e78:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117e7f:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0117e82:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117e85:	c1 e0 0a             	shl    $0xa,%eax
f0117e88:	89 c2                	mov    %eax,%edx
f0117e8a:	83 ec 0c             	sub    $0xc,%esp
f0117e8d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117e93:	50                   	push   %eax
f0117e94:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117e9a:	50                   	push   %eax
f0117e9b:	52                   	push   %edx
f0117e9c:	6a 00                	push   $0x0
f0117e9e:	ff 75 d8             	pushl  -0x28(%ebp)
f0117ea1:	e8 67 18 ff ff       	call   f010970d <calculate_allocated_space>
f0117ea6:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0117ea9:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f0117eb0:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0117eb7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117ebd:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0117ec0:	74 28                	je     f0117eea <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0117ec2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117ec8:	83 ec 0c             	sub    $0xc,%esp
f0117ecb:	ff 75 c8             	pushl  -0x38(%ebp)
f0117ece:	50                   	push   %eax
f0117ecf:	68 b4 e4 12 f0       	push   $0xf012e4b4
f0117ed4:	68 c9 07 00 00       	push   $0x7c9
f0117ed9:	68 02 cb 12 f0       	push   $0xf012cb02
f0117ede:	e8 d4 85 fe ff       	call   f01004b7 <_warn>
f0117ee3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117ee6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0117eea:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117ef0:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117ef3:	74 28                	je     f0117f1d <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0117ef5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117efb:	83 ec 0c             	sub    $0xc,%esp
f0117efe:	ff 75 c4             	pushl  -0x3c(%ebp)
f0117f01:	50                   	push   %eax
f0117f02:	68 14 e5 12 f0       	push   $0xf012e514
f0117f07:	68 ce 07 00 00       	push   $0x7ce
f0117f0c:	68 02 cb 12 f0       	push   $0xf012cb02
f0117f11:	e8 a1 85 fe ff       	call   f01004b7 <_warn>
f0117f16:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117f19:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0117f1d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117f21:	74 04                	je     f0117f27 <test_calculate_allocated_space+0x95e>
f0117f23:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117f27:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0117f2b:	83 ec 04             	sub    $0x4,%esp
f0117f2e:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0117f34:	50                   	push   %eax
f0117f35:	68 14 e4 12 f0       	push   $0xf012e414
f0117f3a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117f40:	50                   	push   %eax
f0117f41:	e8 45 aa 00 00       	call   f012298b <strcconcat>
f0117f46:	83 c4 10             	add    $0x10,%esp
f0117f49:	83 ec 0c             	sub    $0xc,%esp
f0117f4c:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0117f52:	50                   	push   %eax
f0117f53:	e8 84 9f fe ff       	call   f0101edc <execute_command>
f0117f58:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0117f5b:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117f62:	00 00 00 
		num_pages = 0;
f0117f65:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117f6c:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0117f6f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117f72:	89 c2                	mov    %eax,%edx
f0117f74:	01 d2                	add    %edx,%edx
f0117f76:	01 d0                	add    %edx,%eax
f0117f78:	05 00 18 00 00       	add    $0x1800,%eax
f0117f7d:	89 c2                	mov    %eax,%edx
f0117f7f:	83 ec 0c             	sub    $0xc,%esp
f0117f82:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0117f88:	50                   	push   %eax
f0117f89:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0117f8f:	50                   	push   %eax
f0117f90:	52                   	push   %edx
f0117f91:	68 00 18 00 00       	push   $0x1800
f0117f96:	ff 75 d8             	pushl  -0x28(%ebp)
f0117f99:	e8 6f 17 ff ff       	call   f010970d <calculate_allocated_space>
f0117f9e:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0117fa1:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0117fa8:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0117faf:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117fb5:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0117fb8:	74 28                	je     f0117fe2 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0117fba:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117fc0:	83 ec 0c             	sub    $0xc,%esp
f0117fc3:	ff 75 c8             	pushl  -0x38(%ebp)
f0117fc6:	50                   	push   %eax
f0117fc7:	68 b4 e4 12 f0       	push   $0xf012e4b4
f0117fcc:	68 df 07 00 00       	push   $0x7df
f0117fd1:	68 02 cb 12 f0       	push   $0xf012cb02
f0117fd6:	e8 dc 84 fe ff       	call   f01004b7 <_warn>
f0117fdb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117fde:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0117fe2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117fe8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117feb:	74 28                	je     f0118015 <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0117fed:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117ff3:	83 ec 0c             	sub    $0xc,%esp
f0117ff6:	ff 75 c4             	pushl  -0x3c(%ebp)
f0117ff9:	50                   	push   %eax
f0117ffa:	68 14 e5 12 f0       	push   $0xf012e514
f0117fff:	68 e4 07 00 00       	push   $0x7e4
f0118004:	68 02 cb 12 f0       	push   $0xf012cb02
f0118009:	e8 a9 84 fe ff       	call   f01004b7 <_warn>
f011800e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0118011:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0118015:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0118019:	74 04                	je     f011801f <test_calculate_allocated_space+0xa56>
f011801b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011801f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0118023:	83 ec 04             	sub    $0x4,%esp
f0118026:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011802c:	50                   	push   %eax
f011802d:	68 d4 d4 12 f0       	push   $0xf012d4d4
f0118032:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0118038:	50                   	push   %eax
f0118039:	e8 4d a9 00 00       	call   f012298b <strcconcat>
f011803e:	83 c4 10             	add    $0x10,%esp
f0118041:	83 ec 0c             	sub    $0xc,%esp
f0118044:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011804a:	50                   	push   %eax
f011804b:	e8 8c 9e fe ff       	call   f0101edc <execute_command>
f0118050:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0118053:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011805a:	00 00 00 
		num_pages = 0;
f011805d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0118064:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0118067:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011806a:	89 d0                	mov    %edx,%eax
f011806c:	c1 e0 02             	shl    $0x2,%eax
f011806f:	01 d0                	add    %edx,%eax
f0118071:	01 c0                	add    %eax,%eax
f0118073:	05 00 00 40 00       	add    $0x400000,%eax
f0118078:	89 c2                	mov    %eax,%edx
f011807a:	83 ec 0c             	sub    $0xc,%esp
f011807d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0118083:	50                   	push   %eax
f0118084:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011808a:	50                   	push   %eax
f011808b:	52                   	push   %edx
f011808c:	68 00 00 40 00       	push   $0x400000
f0118091:	ff 75 d8             	pushl  -0x28(%ebp)
f0118094:	e8 74 16 ff ff       	call   f010970d <calculate_allocated_space>
f0118099:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011809c:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f01180a3:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01180aa:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01180b0:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01180b3:	74 28                	je     f01180dd <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01180b5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01180bb:	83 ec 0c             	sub    $0xc,%esp
f01180be:	ff 75 c8             	pushl  -0x38(%ebp)
f01180c1:	50                   	push   %eax
f01180c2:	68 b4 e4 12 f0       	push   $0xf012e4b4
f01180c7:	68 f4 07 00 00       	push   $0x7f4
f01180cc:	68 02 cb 12 f0       	push   $0xf012cb02
f01180d1:	e8 e1 83 fe ff       	call   f01004b7 <_warn>
f01180d6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01180d9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01180dd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01180e3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01180e6:	74 28                	je     f0118110 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01180e8:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01180ee:	83 ec 0c             	sub    $0xc,%esp
f01180f1:	ff 75 c4             	pushl  -0x3c(%ebp)
f01180f4:	50                   	push   %eax
f01180f5:	68 14 e5 12 f0       	push   $0xf012e514
f01180fa:	68 f9 07 00 00       	push   $0x7f9
f01180ff:	68 02 cb 12 f0       	push   $0xf012cb02
f0118104:	e8 ae 83 fe ff       	call   f01004b7 <_warn>
f0118109:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011810c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0118110:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0118114:	74 04                	je     f011811a <test_calculate_allocated_space+0xb51>
f0118116:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011811a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f011811e:	83 ec 04             	sub    $0x4,%esp
f0118121:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0118127:	50                   	push   %eax
f0118128:	68 de d4 12 f0       	push   $0xf012d4de
f011812d:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0118133:	50                   	push   %eax
f0118134:	e8 52 a8 00 00       	call   f012298b <strcconcat>
f0118139:	83 c4 10             	add    $0x10,%esp
f011813c:	83 ec 0c             	sub    $0xc,%esp
f011813f:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0118145:	50                   	push   %eax
f0118146:	e8 91 9d fe ff       	call   f0101edc <execute_command>
f011814b:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f011814e:	83 ec 04             	sub    $0x4,%esp
f0118151:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0118157:	50                   	push   %eax
f0118158:	68 1c e4 12 f0       	push   $0xf012e41c
f011815d:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0118163:	50                   	push   %eax
f0118164:	e8 22 a8 00 00       	call   f012298b <strcconcat>
f0118169:	83 c4 10             	add    $0x10,%esp
f011816c:	83 ec 0c             	sub    $0xc,%esp
f011816f:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0118175:	50                   	push   %eax
f0118176:	e8 61 9d fe ff       	call   f0101edc <execute_command>
f011817b:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f011817e:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0118185:	00 00 00 
		num_pages = 0;
f0118188:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011818f:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0118192:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118195:	05 00 00 38 00       	add    $0x380000,%eax
f011819a:	01 c0                	add    %eax,%eax
f011819c:	89 c2                	mov    %eax,%edx
f011819e:	83 ec 0c             	sub    $0xc,%esp
f01181a1:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01181a7:	50                   	push   %eax
f01181a8:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01181ae:	50                   	push   %eax
f01181af:	52                   	push   %edx
f01181b0:	68 00 00 70 00       	push   $0x700000
f01181b5:	ff 75 d8             	pushl  -0x28(%ebp)
f01181b8:	e8 50 15 ff ff       	call   f010970d <calculate_allocated_space>
f01181bd:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01181c0:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f01181c7:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01181ce:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01181d4:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01181d7:	74 28                	je     f0118201 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01181d9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01181df:	83 ec 0c             	sub    $0xc,%esp
f01181e2:	ff 75 c8             	pushl  -0x38(%ebp)
f01181e5:	50                   	push   %eax
f01181e6:	68 b4 e4 12 f0       	push   $0xf012e4b4
f01181eb:	68 0b 08 00 00       	push   $0x80b
f01181f0:	68 02 cb 12 f0       	push   $0xf012cb02
f01181f5:	e8 bd 82 fe ff       	call   f01004b7 <_warn>
f01181fa:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01181fd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0118201:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0118207:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011820a:	74 28                	je     f0118234 <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011820c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0118212:	83 ec 0c             	sub    $0xc,%esp
f0118215:	ff 75 c4             	pushl  -0x3c(%ebp)
f0118218:	50                   	push   %eax
f0118219:	68 14 e5 12 f0       	push   $0xf012e514
f011821e:	68 10 08 00 00       	push   $0x810
f0118223:	68 02 cb 12 f0       	push   $0xf012cb02
f0118228:	e8 8a 82 fe ff       	call   f01004b7 <_warn>
f011822d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0118230:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0118234:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0118238:	74 04                	je     f011823e <test_calculate_allocated_space+0xc75>
f011823a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011823e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f0118242:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0118249:	00 00 00 
		num_pages = 0;
f011824c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0118253:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0118256:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0118259:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f011825e:	89 c2                	mov    %eax,%edx
f0118260:	83 ec 0c             	sub    $0xc,%esp
f0118263:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0118269:	50                   	push   %eax
f011826a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0118270:	50                   	push   %eax
f0118271:	52                   	push   %edx
f0118272:	68 ff ff 3f 00       	push   $0x3fffff
f0118277:	ff 75 d8             	pushl  -0x28(%ebp)
f011827a:	e8 8e 14 ff ff       	call   f010970d <calculate_allocated_space>
f011827f:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0118282:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f0118289:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0118290:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0118296:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0118299:	74 28                	je     f01182c3 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011829b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01182a1:	83 ec 0c             	sub    $0xc,%esp
f01182a4:	ff 75 c8             	pushl  -0x38(%ebp)
f01182a7:	50                   	push   %eax
f01182a8:	68 b4 e4 12 f0       	push   $0xf012e4b4
f01182ad:	68 1e 08 00 00       	push   $0x81e
f01182b2:	68 02 cb 12 f0       	push   $0xf012cb02
f01182b7:	e8 fb 81 fe ff       	call   f01004b7 <_warn>
f01182bc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01182bf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01182c3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01182c9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01182cc:	74 28                	je     f01182f6 <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01182ce:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01182d4:	83 ec 0c             	sub    $0xc,%esp
f01182d7:	ff 75 c4             	pushl  -0x3c(%ebp)
f01182da:	50                   	push   %eax
f01182db:	68 14 e5 12 f0       	push   $0xf012e514
f01182e0:	68 23 08 00 00       	push   $0x823
f01182e5:	68 02 cb 12 f0       	push   $0xf012cb02
f01182ea:	e8 c8 81 fe ff       	call   f01004b7 <_warn>
f01182ef:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01182f2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01182f6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01182fa:	74 04                	je     f0118300 <test_calculate_allocated_space+0xd37>
f01182fc:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0118300:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0118304:	83 ec 0c             	sub    $0xc,%esp
f0118307:	68 8f d4 12 f0       	push   $0xf012d48f
f011830c:	e8 5b 8c fe ff       	call   f0100f6c <cprintf>
f0118311:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f0118314:	83 ec 08             	sub    $0x8,%esp
f0118317:	ff 75 e4             	pushl  -0x1c(%ebp)
f011831a:	68 70 e5 12 f0       	push   $0xf012e570
f011831f:	e8 48 8c fe ff       	call   f0100f6c <cprintf>
f0118324:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0118327:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f011832b:	75 10                	jne    f011833d <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f011832d:	83 ec 0c             	sub    $0xc,%esp
f0118330:	68 b0 e5 12 f0       	push   $0xf012e5b0
f0118335:	e8 32 8c fe ff       	call   f0100f6c <cprintf>
f011833a:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f011833d:	a1 84 4b 5a f0       	mov    0xf05a4b84,%eax
f0118342:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0118345:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0118348:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011834b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0118350:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0118353:	5b                   	pop    %ebx
f0118354:	5e                   	pop    %esi
f0118355:	5f                   	pop    %edi
f0118356:	5d                   	pop    %ebp
f0118357:	c3                   	ret    

f0118358 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f0118358:	55                   	push   %ebp
f0118359:	89 e5                	mov    %esp,%ebp
f011835b:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f011835e:	8b 45 10             	mov    0x10(%ebp),%eax
f0118361:	ba 01 00 00 00       	mov    $0x1,%edx
f0118366:	88 c1                	mov    %al,%cl
f0118368:	d3 e2                	shl    %cl,%edx
f011836a:	89 d0                	mov    %edx,%eax
f011836c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f011836f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118372:	c1 e8 16             	shr    $0x16,%eax
f0118375:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011837c:	8b 45 08             	mov    0x8(%ebp),%eax
f011837f:	01 d0                	add    %edx,%eax
f0118381:	8b 00                	mov    (%eax),%eax
f0118383:	83 e0 01             	and    $0x1,%eax
f0118386:	85 c0                	test   %eax,%eax
f0118388:	75 07                	jne    f0118391 <CB+0x39>
f011838a:	b8 00 00 00 00       	mov    $0x0,%eax
f011838f:	eb 76                	jmp    f0118407 <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0118391:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118394:	c1 e8 16             	shr    $0x16,%eax
f0118397:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011839e:	8b 45 08             	mov    0x8(%ebp),%eax
f01183a1:	01 d0                	add    %edx,%eax
f01183a3:	8b 00                	mov    (%eax),%eax
f01183a5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01183aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01183ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01183b0:	c1 e8 0c             	shr    $0xc,%eax
f01183b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01183b6:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f01183bb:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01183be:	72 17                	jb     f01183d7 <CB+0x7f>
f01183c0:	ff 75 f0             	pushl  -0x10(%ebp)
f01183c3:	68 fc e5 12 f0       	push   $0xf012e5fc
f01183c8:	68 3e 08 00 00       	push   $0x83e
f01183cd:	68 02 cb 12 f0       	push   $0xf012cb02
f01183d2:	e8 43 7f fe ff       	call   f010031a <_panic>
f01183d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01183da:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01183df:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f01183e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01183e5:	c1 e8 0c             	shr    $0xc,%eax
f01183e8:	25 ff 03 00 00       	and    $0x3ff,%eax
f01183ed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01183f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01183f7:	01 d0                	add    %edx,%eax
f01183f9:	8b 00                	mov    (%eax),%eax
f01183fb:	23 45 f4             	and    -0xc(%ebp),%eax
f01183fe:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118401:	0f 94 c0             	sete   %al
f0118404:	0f b6 c0             	movzbl %al,%eax
}
f0118407:	c9                   	leave  
f0118408:	c3                   	ret    

f0118409 <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f0118409:	55                   	push   %ebp
f011840a:	89 e5                	mov    %esp,%ebp
f011840c:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f011840f:	8b 45 10             	mov    0x10(%ebp),%eax
f0118412:	ba 01 00 00 00       	mov    $0x1,%edx
f0118417:	88 c1                	mov    %al,%cl
f0118419:	d3 e2                	shl    %cl,%edx
f011841b:	89 d0                	mov    %edx,%eax
f011841d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0118420:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118423:	c1 e8 16             	shr    $0x16,%eax
f0118426:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011842d:	8b 45 08             	mov    0x8(%ebp),%eax
f0118430:	01 d0                	add    %edx,%eax
f0118432:	8b 00                	mov    (%eax),%eax
f0118434:	83 e0 01             	and    $0x1,%eax
f0118437:	85 c0                	test   %eax,%eax
f0118439:	75 0a                	jne    f0118445 <SB+0x3c>
f011843b:	b8 00 00 00 00       	mov    $0x0,%eax
f0118440:	e9 cd 00 00 00       	jmp    f0118512 <SB+0x109>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0118445:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118448:	c1 e8 16             	shr    $0x16,%eax
f011844b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118452:	8b 45 08             	mov    0x8(%ebp),%eax
f0118455:	01 d0                	add    %edx,%eax
f0118457:	8b 00                	mov    (%eax),%eax
f0118459:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011845e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118461:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118464:	c1 e8 0c             	shr    $0xc,%eax
f0118467:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011846a:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f011846f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0118472:	72 17                	jb     f011848b <SB+0x82>
f0118474:	ff 75 f0             	pushl  -0x10(%ebp)
f0118477:	68 fc e5 12 f0       	push   $0xf012e5fc
f011847c:	68 46 08 00 00       	push   $0x846
f0118481:	68 02 cb 12 f0       	push   $0xf012cb02
f0118486:	e8 8f 7e fe ff       	call   f010031a <_panic>
f011848b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011848e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0118493:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
f0118496:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
f011849a:	74 3c                	je     f01184d8 <SB+0xcf>
f011849c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011849f:	c1 e8 0c             	shr    $0xc,%eax
f01184a2:	25 ff 03 00 00       	and    $0x3ff,%eax
f01184a7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01184ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01184b1:	01 d0                	add    %edx,%eax
f01184b3:	8b 55 0c             	mov    0xc(%ebp),%edx
f01184b6:	c1 ea 0c             	shr    $0xc,%edx
f01184b9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01184bf:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f01184c6:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01184c9:	01 ca                	add    %ecx,%edx
f01184cb:	8b 12                	mov    (%edx),%edx
f01184cd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01184d0:	f7 d1                	not    %ecx
f01184d2:	21 ca                	and    %ecx,%edx
f01184d4:	89 10                	mov    %edx,(%eax)
f01184d6:	eb 35                	jmp    f011850d <SB+0x104>
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
f01184d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01184db:	c1 e8 0c             	shr    $0xc,%eax
f01184de:	25 ff 03 00 00       	and    $0x3ff,%eax
f01184e3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01184ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01184ed:	01 c2                	add    %eax,%edx
f01184ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f01184f2:	c1 e8 0c             	shr    $0xc,%eax
f01184f5:	25 ff 03 00 00       	and    $0x3ff,%eax
f01184fa:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0118501:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118504:	01 c8                	add    %ecx,%eax
f0118506:	8b 00                	mov    (%eax),%eax
f0118508:	0b 45 f4             	or     -0xc(%ebp),%eax
f011850b:	89 02                	mov    %eax,(%edx)
	return 0;
f011850d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0118512:	c9                   	leave  
f0118513:	c3                   	ret    

f0118514 <CPs>:
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0118514:	55                   	push   %ebp
f0118515:	89 e5                	mov    %esp,%ebp
f0118517:	83 ec 28             	sub    $0x28,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f011851a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011851d:	c1 e8 16             	shr    $0x16,%eax
f0118520:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118527:	8b 45 08             	mov    0x8(%ebp),%eax
f011852a:	01 d0                	add    %edx,%eax
f011852c:	8b 00                	mov    (%eax),%eax
f011852e:	83 e0 01             	and    $0x1,%eax
f0118531:	85 c0                	test   %eax,%eax
f0118533:	75 0a                	jne    f011853f <CPs+0x2b>
f0118535:	b8 00 00 00 00       	mov    $0x0,%eax
f011853a:	e9 b8 00 00 00       	jmp    f01185f7 <CPs+0xe3>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f011853f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118542:	c1 e8 16             	shr    $0x16,%eax
f0118545:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011854c:	8b 45 08             	mov    0x8(%ebp),%eax
f011854f:	01 d0                	add    %edx,%eax
f0118551:	8b 00                	mov    (%eax),%eax
f0118553:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0118558:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011855b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011855e:	c1 e8 0c             	shr    $0xc,%eax
f0118561:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0118564:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0118569:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011856c:	72 17                	jb     f0118585 <CPs+0x71>
f011856e:	ff 75 f0             	pushl  -0x10(%ebp)
f0118571:	68 fc e5 12 f0       	push   $0xf012e5fc
f0118576:	68 4f 08 00 00       	push   $0x84f
f011857b:	68 02 cb 12 f0       	push   $0xf012cb02
f0118580:	e8 95 7d fe ff       	call   f010031a <_panic>
f0118585:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118588:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011858d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for (int i = 0 ; i < 12 ; i++)
f0118590:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118597:	eb 53                	jmp    f01185ec <CPs+0xd8>
	{
		uint32 mask = 1<<i;
f0118599:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011859c:	ba 01 00 00 00       	mov    $0x1,%edx
f01185a1:	88 c1                	mov    %al,%cl
f01185a3:	d3 e2                	shl    %cl,%edx
f01185a5:	89 d0                	mov    %edx,%eax
f01185a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (!(which & mask))	continue ;
f01185aa:	8b 45 14             	mov    0x14(%ebp),%eax
f01185ad:	23 45 e4             	and    -0x1c(%ebp),%eax
f01185b0:	85 c0                	test   %eax,%eax
f01185b2:	74 34                	je     f01185e8 <CPs+0xd4>
		uint8 c = (table[((((uint32) (va)) >> 12) & 0x3FF)] & mask) == (perms & mask) ? 1 :  0;
f01185b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01185b7:	c1 e8 0c             	shr    $0xc,%eax
f01185ba:	25 ff 03 00 00       	and    $0x3ff,%eax
f01185bf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01185c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01185c9:	01 d0                	add    %edx,%eax
f01185cb:	8b 00                	mov    (%eax),%eax
f01185cd:	33 45 10             	xor    0x10(%ebp),%eax
f01185d0:	23 45 e4             	and    -0x1c(%ebp),%eax
f01185d3:	85 c0                	test   %eax,%eax
f01185d5:	0f 94 c0             	sete   %al
f01185d8:	88 45 e3             	mov    %al,-0x1d(%ebp)
		if (!c) return 0;
f01185db:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01185df:	75 08                	jne    f01185e9 <CPs+0xd5>
f01185e1:	b8 00 00 00 00       	mov    $0x0,%eax
f01185e6:	eb 0f                	jmp    f01185f7 <CPs+0xe3>
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	for (int i = 0 ; i < 12 ; i++)
	{
		uint32 mask = 1<<i;
		if (!(which & mask))	continue ;
f01185e8:	90                   	nop
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	for (int i = 0 ; i < 12 ; i++)
f01185e9:	ff 45 f4             	incl   -0xc(%ebp)
f01185ec:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
f01185f0:	7e a7                	jle    f0118599 <CPs+0x85>
		uint32 mask = 1<<i;
		if (!(which & mask))	continue ;
		uint8 c = (table[((((uint32) (va)) >> 12) & 0x3FF)] & mask) == (perms & mask) ? 1 :  0;
		if (!c) return 0;
	}
	return 1;
f01185f2:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01185f7:	c9                   	leave  
f01185f8:	c3                   	ret    

f01185f9 <CA>:

int CA(uint32 *ptr_dir, uint32 va)
{
f01185f9:	55                   	push   %ebp
f01185fa:	89 e5                	mov    %esp,%ebp
f01185fc:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01185ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118602:	c1 e8 16             	shr    $0x16,%eax
f0118605:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011860c:	8b 45 08             	mov    0x8(%ebp),%eax
f011860f:	01 d0                	add    %edx,%eax
f0118611:	8b 00                	mov    (%eax),%eax
f0118613:	83 e0 01             	and    $0x1,%eax
f0118616:	85 c0                	test   %eax,%eax
f0118618:	75 07                	jne    f0118621 <CA+0x28>
f011861a:	b8 00 00 00 00       	mov    $0x0,%eax
f011861f:	eb 6f                	jmp    f0118690 <CA+0x97>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0118621:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118624:	c1 e8 16             	shr    $0x16,%eax
f0118627:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011862e:	8b 45 08             	mov    0x8(%ebp),%eax
f0118631:	01 d0                	add    %edx,%eax
f0118633:	8b 00                	mov    (%eax),%eax
f0118635:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011863a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011863d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118640:	c1 e8 0c             	shr    $0xc,%eax
f0118643:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118646:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f011864b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f011864e:	72 17                	jb     f0118667 <CA+0x6e>
f0118650:	ff 75 f4             	pushl  -0xc(%ebp)
f0118653:	68 fc e5 12 f0       	push   $0xf012e5fc
f0118658:	68 5e 08 00 00       	push   $0x85e
f011865d:	68 02 cb 12 f0       	push   $0xf012cb02
f0118662:	e8 b3 7c fe ff       	call   f010031a <_panic>
f0118667:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011866a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011866f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
f0118672:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118675:	c1 e8 0c             	shr    $0xc,%eax
f0118678:	25 ff 03 00 00       	and    $0x3ff,%eax
f011867d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118684:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118687:	01 d0                	add    %edx,%eax
f0118689:	8b 00                	mov    (%eax),%eax
f011868b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0118690:	c9                   	leave  
f0118691:	c3                   	ret    

f0118692 <CE>:

int CE(uint32 *_d, uint32 va)
{
f0118692:	55                   	push   %ebp
f0118693:	89 e5                	mov    %esp,%ebp
f0118695:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0118698:	8b 45 0c             	mov    0xc(%ebp),%eax
f011869b:	c1 e8 16             	shr    $0x16,%eax
f011869e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01186a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01186a8:	01 d0                	add    %edx,%eax
f01186aa:	8b 00                	mov    (%eax),%eax
f01186ac:	83 e0 01             	and    $0x1,%eax
f01186af:	85 c0                	test   %eax,%eax
f01186b1:	75 07                	jne    f01186ba <CE+0x28>
f01186b3:	b8 00 00 00 00       	mov    $0x0,%eax
f01186b8:	eb 7a                	jmp    f0118734 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01186ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f01186bd:	c1 e8 16             	shr    $0x16,%eax
f01186c0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01186c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01186ca:	01 d0                	add    %edx,%eax
f01186cc:	8b 00                	mov    (%eax),%eax
f01186ce:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01186d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01186d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01186d9:	c1 e8 0c             	shr    $0xc,%eax
f01186dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01186df:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f01186e4:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f01186e7:	72 17                	jb     f0118700 <CE+0x6e>
f01186e9:	ff 75 f4             	pushl  -0xc(%ebp)
f01186ec:	68 fc e5 12 f0       	push   $0xf012e5fc
f01186f1:	68 65 08 00 00       	push   $0x865
f01186f6:	68 02 cb 12 f0       	push   $0xf012cb02
f01186fb:	e8 1a 7c fe ff       	call   f010031a <_panic>
f0118700:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118703:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0118708:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f011870b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011870e:	c1 e8 0c             	shr    $0xc,%eax
f0118711:	25 ff 03 00 00       	and    $0x3ff,%eax
f0118716:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011871d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118720:	01 d0                	add    %edx,%eax
f0118722:	8b 00                	mov    (%eax),%eax
f0118724:	85 c0                	test   %eax,%eax
f0118726:	74 07                	je     f011872f <CE+0x9d>
f0118728:	b8 00 00 00 00       	mov    $0x0,%eax
f011872d:	eb 05                	jmp    f0118734 <CE+0xa2>
	return 1;
f011872f:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0118734:	c9                   	leave  
f0118735:	c3                   	ret    

f0118736 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0118736:	55                   	push   %ebp
f0118737:	89 e5                	mov    %esp,%ebp
f0118739:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	uint32 pd_entry = pd[((((uint32) (va)) >> 22) & 0x3FF)];
f011873c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011873f:	c1 e8 16             	shr    $0x16,%eax
f0118742:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118749:	8b 45 08             	mov    0x8(%ebp),%eax
f011874c:	01 d0                	add    %edx,%eax
f011874e:	8b 00                	mov    (%eax),%eax
f0118750:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if ( (pd_entry & 1) == 1)
f0118753:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118756:	83 e0 01             	and    $0x1,%eax
f0118759:	85 c0                	test   %eax,%eax
f011875b:	0f 84 92 00 00 00    	je     f01187f3 <CP+0xbd>
	{
		uint32 *t = NULL;
f0118761:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		t = (STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(pd_entry)));
f0118768:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011876b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0118770:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0118773:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118776:	c1 e8 0c             	shr    $0xc,%eax
f0118779:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011877c:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0118781:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0118784:	72 17                	jb     f011879d <CP+0x67>
f0118786:	ff 75 ec             	pushl  -0x14(%ebp)
f0118789:	68 fc e5 12 f0       	push   $0xf012e5fc
f011878e:	68 71 08 00 00       	push   $0x871
f0118793:	68 02 cb 12 f0       	push   $0xf012cb02
f0118798:	e8 7d 7b fe ff       	call   f010031a <_panic>
f011879d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01187a0:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01187a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf("va =%x, ENTRY after PERM = %x, perm to set = %x, perm to clear = %x\n", va, t[PTX(va)]&0x00000FFF, ps, pc);

		if (((t[((((uint32) (va)) >> 12) & 0x3FF)]&ps) == ps)&&((~(t[((((uint32) (va)) >> 12) & 0x3FF)])&pc) == pc))
f01187a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01187ab:	c1 e8 0c             	shr    $0xc,%eax
f01187ae:	25 ff 03 00 00       	and    $0x3ff,%eax
f01187b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01187ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01187bd:	01 d0                	add    %edx,%eax
f01187bf:	8b 00                	mov    (%eax),%eax
f01187c1:	23 45 10             	and    0x10(%ebp),%eax
f01187c4:	3b 45 10             	cmp    0x10(%ebp),%eax
f01187c7:	75 2a                	jne    f01187f3 <CP+0xbd>
f01187c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01187cc:	c1 e8 0c             	shr    $0xc,%eax
f01187cf:	25 ff 03 00 00       	and    $0x3ff,%eax
f01187d4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01187db:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01187de:	01 d0                	add    %edx,%eax
f01187e0:	8b 00                	mov    (%eax),%eax
f01187e2:	f7 d0                	not    %eax
f01187e4:	23 45 14             	and    0x14(%ebp),%eax
f01187e7:	3b 45 14             	cmp    0x14(%ebp),%eax
f01187ea:	75 07                	jne    f01187f3 <CP+0xbd>
			return 1;
f01187ec:	b8 01 00 00 00       	mov    $0x1,%eax
f01187f1:	eb 05                	jmp    f01187f8 <CP+0xc2>
	}
	return 0;
f01187f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01187f8:	c9                   	leave  
f01187f9:	c3                   	ret    

f01187fa <GP>:

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f01187fa:	55                   	push   %ebp
f01187fb:	89 e5                	mov    %esp,%ebp
f01187fd:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0118800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118803:	c1 e8 16             	shr    $0x16,%eax
f0118806:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011880d:	8b 45 08             	mov    0x8(%ebp),%eax
f0118810:	01 d0                	add    %edx,%eax
f0118812:	8b 00                	mov    (%eax),%eax
f0118814:	83 e0 01             	and    $0x1,%eax
f0118817:	85 c0                	test   %eax,%eax
f0118819:	75 07                	jne    f0118822 <GP+0x28>
f011881b:	b8 00 00 00 00       	mov    $0x0,%eax
f0118820:	eb 6f                	jmp    f0118891 <GP+0x97>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0118822:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118825:	c1 e8 16             	shr    $0x16,%eax
f0118828:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011882f:	8b 45 08             	mov    0x8(%ebp),%eax
f0118832:	01 d0                	add    %edx,%eax
f0118834:	8b 00                	mov    (%eax),%eax
f0118836:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011883b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011883e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118841:	c1 e8 0c             	shr    $0xc,%eax
f0118844:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118847:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f011884c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f011884f:	72 17                	jb     f0118868 <GP+0x6e>
f0118851:	ff 75 f4             	pushl  -0xc(%ebp)
f0118854:	68 fc e5 12 f0       	push   $0xf012e5fc
f0118859:	68 7e 08 00 00       	push   $0x87e
f011885e:	68 02 cb 12 f0       	push   $0xf012cb02
f0118863:	e8 b2 7a fe ff       	call   f010031a <_panic>
f0118868:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011886b:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0118870:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
f0118873:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118876:	c1 e8 0c             	shr    $0xc,%eax
f0118879:	25 ff 03 00 00       	and    $0x3ff,%eax
f011887e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118885:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118888:	01 d0                	add    %edx,%eax
f011888a:	8b 00                	mov    (%eax),%eax
f011888c:	25 ff 0f 00 00       	and    $0xfff,%eax
}
f0118891:	c9                   	leave  
f0118892:	c3                   	ret    

f0118893 <ClearUserSpace>:

void ClearUserSpace(uint32 *ptr_dir)
{
f0118893:	55                   	push   %ebp
f0118894:	89 e5                	mov    %esp,%ebp
f0118896:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0118899:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01188a0:	eb 18                	jmp    f01188ba <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f01188a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01188a5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01188ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01188af:	01 d0                	add    %edx,%eax
f01188b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01188b7:	ff 45 fc             	incl   -0x4(%ebp)
f01188ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01188bd:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f01188c2:	76 de                	jbe    f01188a2 <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f01188c4:	90                   	nop
f01188c5:	c9                   	leave  
f01188c6:	c3                   	ret    

f01188c7 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f01188c7:	55                   	push   %ebp
f01188c8:	89 e5                	mov    %esp,%ebp
f01188ca:	83 ec 38             	sub    $0x38,%esp
f01188cd:	8b 45 2c             	mov    0x2c(%ebp),%eax
f01188d0:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f01188d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01188d6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01188db:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f01188de:	8b 45 10             	mov    0x10(%ebp),%eax
f01188e1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01188e6:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f01188e9:	e9 ea 01 00 00       	jmp    f0118ad8 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f01188ee:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f01188f2:	74 44                	je     f0118938 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f01188f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01188f7:	83 ec 04             	sub    $0x4,%esp
f01188fa:	8d 55 dc             	lea    -0x24(%ebp),%edx
f01188fd:	52                   	push   %edx
f01188fe:	50                   	push   %eax
f01188ff:	ff 75 08             	pushl  0x8(%ebp)
f0118902:	e8 98 fd fe ff       	call   f010869f <get_frame_info>
f0118907:	83 c4 10             	add    $0x10,%esp
f011890a:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f011890d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118910:	85 c0                	test   %eax,%eax
f0118912:	75 24                	jne    f0118938 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0118914:	83 ec 04             	sub    $0x4,%esp
f0118917:	68 2c e6 12 f0       	push   $0xf012e62c
f011891c:	68 99 08 00 00       	push   $0x899
f0118921:	68 02 cb 12 f0       	push   $0xf012cb02
f0118926:	e8 8c 7b fe ff       	call   f01004b7 <_warn>
f011892b:	83 c4 10             	add    $0x10,%esp
				return 0;
f011892e:	b8 00 00 00 00       	mov    $0x0,%eax
f0118933:	e9 b6 01 00 00       	jmp    f0118aee <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0118938:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011893b:	83 ec 04             	sub    $0x4,%esp
f011893e:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0118941:	52                   	push   %edx
f0118942:	50                   	push   %eax
f0118943:	ff 75 08             	pushl  0x8(%ebp)
f0118946:	e8 54 fd fe ff       	call   f010869f <get_frame_info>
f011894b:	83 c4 10             	add    $0x10,%esp
f011894e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0118951:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0118954:	85 c0                	test   %eax,%eax
f0118956:	75 24                	jne    f011897c <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0118958:	83 ec 04             	sub    $0x4,%esp
f011895b:	68 58 e6 12 f0       	push   $0xf012e658
f0118960:	68 a0 08 00 00       	push   $0x8a0
f0118965:	68 02 cb 12 f0       	push   $0xf012cb02
f011896a:	e8 48 7b fe ff       	call   f01004b7 <_warn>
f011896f:	83 c4 10             	add    $0x10,%esp
			return 0;
f0118972:	b8 00 00 00 00       	mov    $0x0,%eax
f0118977:	e9 72 01 00 00       	jmp    f0118aee <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f011897c:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0118980:	75 70                	jne    f01189f2 <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0118982:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118985:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118988:	c1 ea 0c             	shr    $0xc,%edx
f011898b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0118991:	c1 e2 02             	shl    $0x2,%edx
f0118994:	01 d0                	add    %edx,%eax
f0118996:	8b 00                	mov    (%eax),%eax
f0118998:	c1 e8 0c             	shr    $0xc,%eax
f011899b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f011899e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01189a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01189a4:	c1 ea 0c             	shr    $0xc,%edx
f01189a7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01189ad:	c1 e2 02             	shl    $0x2,%edx
f01189b0:	01 d0                	add    %edx,%eax
f01189b2:	8b 00                	mov    (%eax),%eax
f01189b4:	c1 e8 0c             	shr    $0xc,%eax
f01189b7:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f01189ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01189bd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01189c0:	74 30                	je     f01189f2 <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f01189c2:	83 ec 04             	sub    $0x4,%esp
f01189c5:	ff 75 e4             	pushl  -0x1c(%ebp)
f01189c8:	ff 75 e8             	pushl  -0x18(%ebp)
f01189cb:	ff 75 f0             	pushl  -0x10(%ebp)
f01189ce:	ff 75 f4             	pushl  -0xc(%ebp)
f01189d1:	68 84 e6 12 f0       	push   $0xf012e684
f01189d6:	68 aa 08 00 00       	push   $0x8aa
f01189db:	68 02 cb 12 f0       	push   $0xf012cb02
f01189e0:	e8 d2 7a fe ff       	call   f01004b7 <_warn>
f01189e5:	83 c4 20             	add    $0x20,%esp
				return 0;
f01189e8:	b8 00 00 00 00       	mov    $0x0,%eax
f01189ed:	e9 fc 00 00 00       	jmp    f0118aee <CCP+0x227>
			}
		}
		if (ref != -1)
f01189f2:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f01189f6:	74 52                	je     f0118a4a <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f01189f8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01189fc:	74 0e                	je     f0118a0c <CCP+0x145>
f01189fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118a01:	8b 40 08             	mov    0x8(%eax),%eax
f0118a04:	0f b7 c0             	movzwl %ax,%eax
f0118a07:	3b 45 18             	cmp    0x18(%ebp),%eax
f0118a0a:	74 3e                	je     f0118a4a <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0118a0c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0118a10:	74 0b                	je     f0118a1d <CCP+0x156>
f0118a12:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118a15:	8b 40 08             	mov    0x8(%eax),%eax
f0118a18:	0f b7 c0             	movzwl %ax,%eax
f0118a1b:	eb 05                	jmp    f0118a22 <CCP+0x15b>
f0118a1d:	b8 00 00 00 00       	mov    $0x0,%eax
f0118a22:	83 ec 0c             	sub    $0xc,%esp
f0118a25:	50                   	push   %eax
f0118a26:	ff 75 f0             	pushl  -0x10(%ebp)
f0118a29:	68 e0 e6 12 f0       	push   $0xf012e6e0
f0118a2e:	68 b2 08 00 00       	push   $0x8b2
f0118a33:	68 02 cb 12 f0       	push   $0xf012cb02
f0118a38:	e8 7a 7a fe ff       	call   f01004b7 <_warn>
f0118a3d:	83 c4 20             	add    $0x20,%esp
				return 0;
f0118a40:	b8 00 00 00 00       	mov    $0x0,%eax
f0118a45:	e9 a4 00 00 00       	jmp    f0118aee <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0118a4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118a4d:	ff 75 20             	pushl  0x20(%ebp)
f0118a50:	ff 75 1c             	pushl  0x1c(%ebp)
f0118a53:	50                   	push   %eax
f0118a54:	ff 75 08             	pushl  0x8(%ebp)
f0118a57:	e8 b8 fa ff ff       	call   f0118514 <CPs>
f0118a5c:	83 c4 10             	add    $0x10,%esp
f0118a5f:	85 c0                	test   %eax,%eax
f0118a61:	7f 21                	jg     f0118a84 <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0118a63:	83 ec 04             	sub    $0x4,%esp
f0118a66:	68 50 e7 12 f0       	push   $0xf012e750
f0118a6b:	68 b8 08 00 00       	push   $0x8b8
f0118a70:	68 02 cb 12 f0       	push   $0xf012cb02
f0118a75:	e8 3d 7a fe ff       	call   f01004b7 <_warn>
f0118a7a:	83 c4 10             	add    $0x10,%esp
			return 0;
f0118a7d:	b8 00 00 00 00       	mov    $0x0,%eax
f0118a82:	eb 6a                	jmp    f0118aee <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0118a84:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0118a88:	74 3a                	je     f0118ac4 <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0118a8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118a8d:	ff 75 28             	pushl  0x28(%ebp)
f0118a90:	ff 75 24             	pushl  0x24(%ebp)
f0118a93:	50                   	push   %eax
f0118a94:	ff 75 08             	pushl  0x8(%ebp)
f0118a97:	e8 78 fa ff ff       	call   f0118514 <CPs>
f0118a9c:	83 c4 10             	add    $0x10,%esp
f0118a9f:	85 c0                	test   %eax,%eax
f0118aa1:	7f 21                	jg     f0118ac4 <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0118aa3:	83 ec 04             	sub    $0x4,%esp
f0118aa6:	68 98 e7 12 f0       	push   $0xf012e798
f0118aab:	68 bf 08 00 00       	push   $0x8bf
f0118ab0:	68 02 cb 12 f0       	push   $0xf012cb02
f0118ab5:	e8 fd 79 fe ff       	call   f01004b7 <_warn>
f0118aba:	83 c4 10             	add    $0x10,%esp
				return 0;
f0118abd:	b8 00 00 00 00       	mov    $0x0,%eax
f0118ac2:	eb 2a                	jmp    f0118aee <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0118ac4:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0118ac8:	74 07                	je     f0118ad1 <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0118aca:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0118ad1:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0118ad8:	8b 55 10             	mov    0x10(%ebp),%edx
f0118adb:	8b 45 14             	mov    0x14(%ebp),%eax
f0118ade:	01 d0                	add    %edx,%eax
f0118ae0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118ae3:	0f 87 05 fe ff ff    	ja     f01188ee <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0118ae9:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0118aee:	c9                   	leave  
f0118aef:	c3                   	ret    

f0118af0 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0118af0:	55                   	push   %ebp
f0118af1:	89 e5                	mov    %esp,%ebp
f0118af3:	57                   	push   %edi
f0118af4:	56                   	push   %esi
f0118af5:	53                   	push   %ebx
f0118af6:	81 ec 4c 03 00 00    	sub    $0x34c,%esp
#if USE_KHEAP
	panic("not handled yet");
#else
	if(firstTime)
f0118afc:	a0 d4 0d 18 f0       	mov    0xf0180dd4,%al
f0118b01:	84 c0                	test   %al,%al
f0118b03:	0f 84 38 0a 00 00    	je     f0119541 <test_priority_normal_and_higher+0xa51>
		uint32 fact_WS[15];
		uint32 fact_TimeStamp[15];
		uint32 hello_WS[10];
		uint32 hello_TimeStamp[10];

		firstTime = 0;
f0118b09:	c6 05 d4 0d 18 f0 00 	movb   $0x0,0xf0180dd4
		char command[100] = "load fos_add 20";
f0118b10:	8d 85 14 fe ff ff    	lea    -0x1ec(%ebp),%eax
f0118b16:	bb 54 ea 12 f0       	mov    $0xf012ea54,%ebx
f0118b1b:	ba 04 00 00 00       	mov    $0x4,%edx
f0118b20:	89 c7                	mov    %eax,%edi
f0118b22:	89 de                	mov    %ebx,%esi
f0118b24:	89 d1                	mov    %edx,%ecx
f0118b26:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0118b28:	8d 95 24 fe ff ff    	lea    -0x1dc(%ebp),%edx
f0118b2e:	b9 15 00 00 00       	mov    $0x15,%ecx
f0118b33:	b8 00 00 00 00       	mov    $0x0,%eax
f0118b38:	89 d7                	mov    %edx,%edi
f0118b3a:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command);
f0118b3c:	83 ec 0c             	sub    $0xc,%esp
f0118b3f:	8d 85 14 fe ff ff    	lea    -0x1ec(%ebp),%eax
f0118b45:	50                   	push   %eax
f0118b46:	e8 91 93 fe ff       	call   f0101edc <execute_command>
f0118b4b:	83 c4 10             	add    $0x10,%esp
		char command2[100] = "load fact 15";
f0118b4e:	8d 85 78 fe ff ff    	lea    -0x188(%ebp),%eax
f0118b54:	bb b8 ea 12 f0       	mov    $0xf012eab8,%ebx
f0118b59:	ba 0d 00 00 00       	mov    $0xd,%edx
f0118b5e:	89 c7                	mov    %eax,%edi
f0118b60:	89 de                	mov    %ebx,%esi
f0118b62:	89 d1                	mov    %edx,%ecx
f0118b64:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0118b66:	8d 95 85 fe ff ff    	lea    -0x17b(%ebp),%edx
f0118b6c:	b9 57 00 00 00       	mov    $0x57,%ecx
f0118b71:	b0 00                	mov    $0x0,%al
f0118b73:	89 d7                	mov    %edx,%edi
f0118b75:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command2);
f0118b77:	83 ec 0c             	sub    $0xc,%esp
f0118b7a:	8d 85 78 fe ff ff    	lea    -0x188(%ebp),%eax
f0118b80:	50                   	push   %eax
f0118b81:	e8 56 93 fe ff       	call   f0101edc <execute_command>
f0118b86:	83 c4 10             	add    $0x10,%esp
		char command3[100] = "load fos_helloWorld 10";
f0118b89:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f0118b8f:	bb 1c eb 12 f0       	mov    $0xf012eb1c,%ebx
f0118b94:	ba 17 00 00 00       	mov    $0x17,%edx
f0118b99:	89 c7                	mov    %eax,%edi
f0118b9b:	89 de                	mov    %ebx,%esi
f0118b9d:	89 d1                	mov    %edx,%ecx
f0118b9f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0118ba1:	8d 95 f3 fe ff ff    	lea    -0x10d(%ebp),%edx
f0118ba7:	b9 4d 00 00 00       	mov    $0x4d,%ecx
f0118bac:	b0 00                	mov    $0x0,%al
f0118bae:	89 d7                	mov    %edx,%edi
f0118bb0:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command3);
f0118bb2:	83 ec 0c             	sub    $0xc,%esp
f0118bb5:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f0118bbb:	50                   	push   %eax
f0118bbc:	e8 1b 93 fe ff       	call   f0101edc <execute_command>
f0118bc1:	83 c4 10             	add    $0x10,%esp

		struct Env * addEnv;
		struct Env * factEnv;
		struct Env * helloEnv;
		envid2env(16, &addEnv, 0);
f0118bc4:	83 ec 04             	sub    $0x4,%esp
f0118bc7:	6a 00                	push   $0x0
f0118bc9:	8d 45 ac             	lea    -0x54(%ebp),%eax
f0118bcc:	50                   	push   %eax
f0118bcd:	6a 10                	push   $0x10
f0118bcf:	e8 c1 1b ff ff       	call   f010a795 <envid2env>
f0118bd4:	83 c4 10             	add    $0x10,%esp
		envid2env(17, &factEnv, 0);
f0118bd7:	83 ec 04             	sub    $0x4,%esp
f0118bda:	6a 00                	push   $0x0
f0118bdc:	8d 45 a8             	lea    -0x58(%ebp),%eax
f0118bdf:	50                   	push   %eax
f0118be0:	6a 11                	push   $0x11
f0118be2:	e8 ae 1b ff ff       	call   f010a795 <envid2env>
f0118be7:	83 c4 10             	add    $0x10,%esp
		envid2env(18, &helloEnv, 0);
f0118bea:	83 ec 04             	sub    $0x4,%esp
f0118bed:	6a 00                	push   $0x0
f0118bef:	8d 45 a4             	lea    -0x5c(%ebp),%eax
f0118bf2:	50                   	push   %eax
f0118bf3:	6a 12                	push   $0x12
f0118bf5:	e8 9b 1b ff ff       	call   f010a795 <envid2env>
f0118bfa:	83 c4 10             	add    $0x10,%esp

		if(addEnv == NULL || factEnv == NULL || helloEnv == NULL)
f0118bfd:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118c00:	85 c0                	test   %eax,%eax
f0118c02:	74 0e                	je     f0118c12 <test_priority_normal_and_higher+0x122>
f0118c04:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118c07:	85 c0                	test   %eax,%eax
f0118c09:	74 07                	je     f0118c12 <test_priority_normal_and_higher+0x122>
f0118c0b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118c0e:	85 c0                	test   %eax,%eax
f0118c10:	75 14                	jne    f0118c26 <test_priority_normal_and_higher+0x136>
			panic("Loading programs failed\n");
f0118c12:	83 ec 04             	sub    $0x4,%esp
f0118c15:	68 d8 e7 12 f0       	push   $0xf012e7d8
f0118c1a:	6a 29                	push   $0x29
f0118c1c:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118c21:	e8 f4 76 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0118c26:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118c29:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118c2f:	83 f8 14             	cmp    $0x14,%eax
f0118c32:	75 1c                	jne    f0118c50 <test_priority_normal_and_higher+0x160>
f0118c34:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118c37:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118c3d:	83 f8 0f             	cmp    $0xf,%eax
f0118c40:	75 0e                	jne    f0118c50 <test_priority_normal_and_higher+0x160>
f0118c42:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118c45:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118c4b:	83 f8 0a             	cmp    $0xa,%eax
f0118c4e:	74 32                	je     f0118c82 <test_priority_normal_and_higher+0x192>
			panic("The programs should be initially loaded with the given working set size. add: %d, fact: %d, hello: %d\n", addEnv->page_WS_max_size , factEnv->page_WS_max_size , helloEnv->page_WS_max_size );
f0118c50:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118c53:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f0118c59:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118c5c:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0118c62:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118c65:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118c6b:	83 ec 08             	sub    $0x8,%esp
f0118c6e:	51                   	push   %ecx
f0118c6f:	52                   	push   %edx
f0118c70:	50                   	push   %eax
f0118c71:	68 0c e8 12 f0       	push   $0xf012e80c
f0118c76:	6a 2c                	push   $0x2c
f0118c78:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118c7d:	e8 98 76 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 20; i++)
f0118c82:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0118c89:	eb 47                	jmp    f0118cd2 <test_priority_normal_and_higher+0x1e2>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
f0118c8b:	8b 4d ac             	mov    -0x54(%ebp),%ecx
f0118c8e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118c91:	89 d0                	mov    %edx,%eax
f0118c93:	01 c0                	add    %eax,%eax
f0118c95:	01 d0                	add    %edx,%eax
f0118c97:	c1 e0 03             	shl    $0x3,%eax
f0118c9a:	01 c8                	add    %ecx,%eax
f0118c9c:	05 88 00 00 00       	add    $0x88,%eax
f0118ca1:	8b 10                	mov    (%eax),%edx
f0118ca3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118ca6:	89 94 85 74 fd ff ff 	mov    %edx,-0x28c(%ebp,%eax,4)
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
f0118cad:	8b 4d ac             	mov    -0x54(%ebp),%ecx
f0118cb0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118cb3:	89 d0                	mov    %edx,%eax
f0118cb5:	01 c0                	add    %eax,%eax
f0118cb7:	01 d0                	add    %edx,%eax
f0118cb9:	c1 e0 03             	shl    $0x3,%eax
f0118cbc:	01 c8                	add    %ecx,%eax
f0118cbe:	05 90 00 00 00       	add    $0x90,%eax
f0118cc3:	8b 10                	mov    (%eax),%edx
f0118cc5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118cc8:	89 94 85 c4 fd ff ff 	mov    %edx,-0x23c(%ebp,%eax,4)
			panic("Loading programs failed\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
			panic("The programs should be initially loaded with the given working set size. add: %d, fact: %d, hello: %d\n", addEnv->page_WS_max_size , factEnv->page_WS_max_size , helloEnv->page_WS_max_size );

		for(int i = 0; i < 20; i++)
f0118ccf:	ff 45 e4             	incl   -0x1c(%ebp)
f0118cd2:	83 7d e4 13          	cmpl   $0x13,-0x1c(%ebp)
f0118cd6:	7e b3                	jle    f0118c8b <test_priority_normal_and_higher+0x19b>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 15; i++)
f0118cd8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0118cdf:	eb 47                	jmp    f0118d28 <test_priority_normal_and_higher+0x238>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
f0118ce1:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f0118ce4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118ce7:	89 d0                	mov    %edx,%eax
f0118ce9:	01 c0                	add    %eax,%eax
f0118ceb:	01 d0                	add    %edx,%eax
f0118ced:	c1 e0 03             	shl    $0x3,%eax
f0118cf0:	01 c8                	add    %ecx,%eax
f0118cf2:	05 88 00 00 00       	add    $0x88,%eax
f0118cf7:	8b 10                	mov    (%eax),%edx
f0118cf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118cfc:	89 94 85 fc fc ff ff 	mov    %edx,-0x304(%ebp,%eax,4)
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
f0118d03:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f0118d06:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118d09:	89 d0                	mov    %edx,%eax
f0118d0b:	01 c0                	add    %eax,%eax
f0118d0d:	01 d0                	add    %edx,%eax
f0118d0f:	c1 e0 03             	shl    $0x3,%eax
f0118d12:	01 c8                	add    %ecx,%eax
f0118d14:	05 90 00 00 00       	add    $0x90,%eax
f0118d19:	8b 10                	mov    (%eax),%edx
f0118d1b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118d1e:	89 94 85 38 fd ff ff 	mov    %edx,-0x2c8(%ebp,%eax,4)
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 15; i++)
f0118d25:	ff 45 e0             	incl   -0x20(%ebp)
f0118d28:	83 7d e0 0e          	cmpl   $0xe,-0x20(%ebp)
f0118d2c:	7e b3                	jle    f0118ce1 <test_priority_normal_and_higher+0x1f1>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 10; i++)
f0118d2e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0118d35:	eb 47                	jmp    f0118d7e <test_priority_normal_and_higher+0x28e>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
f0118d37:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0118d3a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0118d3d:	89 d0                	mov    %edx,%eax
f0118d3f:	01 c0                	add    %eax,%eax
f0118d41:	01 d0                	add    %edx,%eax
f0118d43:	c1 e0 03             	shl    $0x3,%eax
f0118d46:	01 c8                	add    %ecx,%eax
f0118d48:	05 88 00 00 00       	add    $0x88,%eax
f0118d4d:	8b 10                	mov    (%eax),%edx
f0118d4f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118d52:	89 94 85 ac fc ff ff 	mov    %edx,-0x354(%ebp,%eax,4)
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
f0118d59:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0118d5c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0118d5f:	89 d0                	mov    %edx,%eax
f0118d61:	01 c0                	add    %eax,%eax
f0118d63:	01 d0                	add    %edx,%eax
f0118d65:	c1 e0 03             	shl    $0x3,%eax
f0118d68:	01 c8                	add    %ecx,%eax
f0118d6a:	05 90 00 00 00       	add    $0x90,%eax
f0118d6f:	8b 10                	mov    (%eax),%edx
f0118d71:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118d74:	89 94 85 d4 fc ff ff 	mov    %edx,-0x32c(%ebp,%eax,4)
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 10; i++)
f0118d7b:	ff 45 dc             	incl   -0x24(%ebp)
f0118d7e:	83 7d dc 09          	cmpl   $0x9,-0x24(%ebp)
f0118d82:	7e b3                	jle    f0118d37 <test_priority_normal_and_higher+0x247>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		int freeFrames = sys_calculate_free_frames();
f0118d84:	e8 54 4c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0118d89:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		int freeDiskFrames = pf_calculate_free_frames();
f0118d8c:	e8 84 ba fe ff       	call   f0104815 <pf_calculate_free_frames>
f0118d91:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set Priority To Normal // Should change nothing
		set_program_priority(addEnv, 3);
f0118d94:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118d97:	83 ec 08             	sub    $0x8,%esp
f0118d9a:	6a 03                	push   $0x3
f0118d9c:	50                   	push   %eax
f0118d9d:	e8 e2 30 ff ff       	call   f010be84 <set_program_priority>
f0118da2:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 3);
f0118da5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118da8:	83 ec 08             	sub    $0x8,%esp
f0118dab:	6a 03                	push   $0x3
f0118dad:	50                   	push   %eax
f0118dae:	e8 d1 30 ff ff       	call   f010be84 <set_program_priority>
f0118db3:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 3);
f0118db6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118db9:	83 ec 08             	sub    $0x8,%esp
f0118dbc:	6a 03                	push   $0x3
f0118dbe:	50                   	push   %eax
f0118dbf:	e8 c0 30 ff ff       	call   f010be84 <set_program_priority>
f0118dc4:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0118dc7:	e8 49 ba fe ff       	call   f0104815 <pf_calculate_free_frames>
f0118dcc:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0118dcf:	74 14                	je     f0118de5 <test_priority_normal_and_higher+0x2f5>
f0118dd1:	83 ec 04             	sub    $0x4,%esp
f0118dd4:	68 74 e8 12 f0       	push   $0xf012e874
f0118dd9:	6a 48                	push   $0x48
f0118ddb:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118de0:	e8 35 75 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0118de5:	e8 f3 4b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0118dea:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0118ded:	74 14                	je     f0118e03 <test_priority_normal_and_higher+0x313>
f0118def:	83 ec 04             	sub    $0x4,%esp
f0118df2:	68 74 e8 12 f0       	push   $0xf012e874
f0118df7:	6a 49                	push   $0x49
f0118df9:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118dfe:	e8 17 75 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0118e03:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118e06:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118e0c:	83 f8 14             	cmp    $0x14,%eax
f0118e0f:	75 1c                	jne    f0118e2d <test_priority_normal_and_higher+0x33d>
f0118e11:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118e14:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118e1a:	83 f8 0f             	cmp    $0xf,%eax
f0118e1d:	75 0e                	jne    f0118e2d <test_priority_normal_and_higher+0x33d>
f0118e1f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118e22:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118e28:	83 f8 0a             	cmp    $0xa,%eax
f0118e2b:	74 14                	je     f0118e41 <test_priority_normal_and_higher+0x351>
			panic("The programs' working set size should not change after setting priority to normal\n");
f0118e2d:	83 ec 04             	sub    $0x4,%esp
f0118e30:	68 a0 e8 12 f0       	push   $0xf012e8a0
f0118e35:	6a 4c                	push   $0x4c
f0118e37:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118e3c:	e8 d9 74 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f0118e41:	e8 97 4b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0118e46:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118e49:	e8 c7 b9 fe ff       	call   f0104815 <pf_calculate_free_frames>
f0118e4e:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set Priority To Above Normal // Should change only helloWorld as none of the rest is full
		set_program_priority(addEnv, 4);
f0118e51:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118e54:	83 ec 08             	sub    $0x8,%esp
f0118e57:	6a 04                	push   $0x4
f0118e59:	50                   	push   %eax
f0118e5a:	e8 25 30 ff ff       	call   f010be84 <set_program_priority>
f0118e5f:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 4);
f0118e62:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118e65:	83 ec 08             	sub    $0x8,%esp
f0118e68:	6a 04                	push   $0x4
f0118e6a:	50                   	push   %eax
f0118e6b:	e8 14 30 ff ff       	call   f010be84 <set_program_priority>
f0118e70:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f0118e73:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118e76:	83 ec 08             	sub    $0x8,%esp
f0118e79:	6a 04                	push   $0x4
f0118e7b:	50                   	push   %eax
f0118e7c:	e8 03 30 ff ff       	call   f010be84 <set_program_priority>
f0118e81:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0118e84:	e8 8c b9 fe ff       	call   f0104815 <pf_calculate_free_frames>
f0118e89:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0118e8c:	74 14                	je     f0118ea2 <test_priority_normal_and_higher+0x3b2>
f0118e8e:	83 ec 04             	sub    $0x4,%esp
f0118e91:	68 74 e8 12 f0       	push   $0xf012e874
f0118e96:	6a 56                	push   $0x56
f0118e98:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118e9d:	e8 78 74 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly%x\n");
f0118ea2:	e8 36 4b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0118ea7:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0118eaa:	74 14                	je     f0118ec0 <test_priority_normal_and_higher+0x3d0>
f0118eac:	83 ec 04             	sub    $0x4,%esp
f0118eaf:	68 f4 e8 12 f0       	push   $0xf012e8f4
f0118eb4:	6a 57                	push   $0x57
f0118eb6:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118ebb:	e8 5a 74 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0118ec0:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118ec3:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118ec9:	83 f8 14             	cmp    $0x14,%eax
f0118ecc:	75 1c                	jne    f0118eea <test_priority_normal_and_higher+0x3fa>
f0118ece:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118ed1:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118ed7:	83 f8 0f             	cmp    $0xf,%eax
f0118eda:	75 0e                	jne    f0118eea <test_priority_normal_and_higher+0x3fa>
f0118edc:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118edf:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118ee5:	83 f8 14             	cmp    $0x14,%eax
f0118ee8:	74 14                	je     f0118efe <test_priority_normal_and_higher+0x40e>
			panic("The programs' working set size should be doubled only if it is full\n");
f0118eea:	83 ec 04             	sub    $0x4,%esp
f0118eed:	68 24 e9 12 f0       	push   $0xf012e924
f0118ef2:	6a 5a                	push   $0x5a
f0118ef4:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118ef9:	e8 1c 74 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f0118efe:	e8 da 4a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0118f03:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118f06:	e8 0a b9 fe ff       	call   f0104815 <pf_calculate_free_frames>
f0118f0b:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set priority to above normal --> nothing should change (1 time only)
		set_program_priority(helloEnv, 4);
f0118f0e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118f11:	83 ec 08             	sub    $0x8,%esp
f0118f14:	6a 04                	push   $0x4
f0118f16:	50                   	push   %eax
f0118f17:	e8 68 2f ff ff       	call   f010be84 <set_program_priority>
f0118f1c:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0118f1f:	e8 f1 b8 fe ff       	call   f0104815 <pf_calculate_free_frames>
f0118f24:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0118f27:	74 14                	je     f0118f3d <test_priority_normal_and_higher+0x44d>
f0118f29:	83 ec 04             	sub    $0x4,%esp
f0118f2c:	68 74 e8 12 f0       	push   $0xf012e874
f0118f31:	6a 62                	push   $0x62
f0118f33:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118f38:	e8 dd 73 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0118f3d:	e8 9b 4a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0118f42:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0118f45:	74 14                	je     f0118f5b <test_priority_normal_and_higher+0x46b>
f0118f47:	83 ec 04             	sub    $0x4,%esp
f0118f4a:	68 74 e8 12 f0       	push   $0xf012e874
f0118f4f:	6a 63                	push   $0x63
f0118f51:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118f56:	e8 bf 73 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0118f5b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118f5e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118f64:	83 f8 14             	cmp    $0x14,%eax
f0118f67:	75 1c                	jne    f0118f85 <test_priority_normal_and_higher+0x495>
f0118f69:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118f6c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118f72:	83 f8 0f             	cmp    $0xf,%eax
f0118f75:	75 0e                	jne    f0118f85 <test_priority_normal_and_higher+0x495>
f0118f77:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118f7a:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118f80:	83 f8 14             	cmp    $0x14,%eax
f0118f83:	74 14                	je     f0118f99 <test_priority_normal_and_higher+0x4a9>
			panic("The programs' working set size should be doubled only once\n");
f0118f85:	83 ec 04             	sub    $0x4,%esp
f0118f88:	68 6c e9 12 f0       	push   $0xf012e96c
f0118f8d:	6a 66                	push   $0x66
f0118f8f:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118f94:	e8 81 73 fe ff       	call   f010031a <_panic>


		// Manipulate WS to seem as full
		for(int i = 10; i < 20; i++)
f0118f99:	c7 45 d8 0a 00 00 00 	movl   $0xa,-0x28(%ebp)
f0118fa0:	eb 1c                	jmp    f0118fbe <test_priority_normal_and_higher+0x4ce>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
f0118fa2:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0118fa5:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0118fa8:	89 d0                	mov    %edx,%eax
f0118faa:	01 c0                	add    %eax,%eax
f0118fac:	01 d0                	add    %edx,%eax
f0118fae:	c1 e0 03             	shl    $0x3,%eax
f0118fb1:	01 c8                	add    %ecx,%eax
f0118fb3:	05 8c 00 00 00       	add    $0x8c,%eax
f0118fb8:	c6 00 00             	movb   $0x0,(%eax)
		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
			panic("The programs' working set size should be doubled only once\n");


		// Manipulate WS to seem as full
		for(int i = 10; i < 20; i++)
f0118fbb:	ff 45 d8             	incl   -0x28(%ebp)
f0118fbe:	83 7d d8 13          	cmpl   $0x13,-0x28(%ebp)
f0118fc2:	7e de                	jle    f0118fa2 <test_priority_normal_and_higher+0x4b2>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f0118fc4:	e8 14 4a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0118fc9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118fcc:	e8 44 b8 fe ff       	call   f0104815 <pf_calculate_free_frames>
f0118fd1:	89 45 b0             	mov    %eax,-0x50(%ebp)

		set_program_priority(helloEnv, 4);
f0118fd4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118fd7:	83 ec 08             	sub    $0x8,%esp
f0118fda:	6a 04                	push   $0x4
f0118fdc:	50                   	push   %eax
f0118fdd:	e8 a2 2e ff ff       	call   f010be84 <set_program_priority>
f0118fe2:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0118fe5:	e8 2b b8 fe ff       	call   f0104815 <pf_calculate_free_frames>
f0118fea:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0118fed:	74 14                	je     f0119003 <test_priority_normal_and_higher+0x513>
f0118fef:	83 ec 04             	sub    $0x4,%esp
f0118ff2:	68 74 e8 12 f0       	push   $0xf012e874
f0118ff7:	6a 73                	push   $0x73
f0118ff9:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0118ffe:	e8 17 73 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0119003:	e8 d5 49 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0119008:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011900b:	74 14                	je     f0119021 <test_priority_normal_and_higher+0x531>
f011900d:	83 ec 04             	sub    $0x4,%esp
f0119010:	68 74 e8 12 f0       	push   $0xf012e874
f0119015:	6a 74                	push   $0x74
f0119017:	68 f1 e7 12 f0       	push   $0xf012e7f1
f011901c:	e8 f9 72 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0119021:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0119024:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011902a:	83 f8 14             	cmp    $0x14,%eax
f011902d:	75 1c                	jne    f011904b <test_priority_normal_and_higher+0x55b>
f011902f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119032:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119038:	83 f8 0f             	cmp    $0xf,%eax
f011903b:	75 0e                	jne    f011904b <test_priority_normal_and_higher+0x55b>
f011903d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119040:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119046:	83 f8 14             	cmp    $0x14,%eax
f0119049:	74 14                	je     f011905f <test_priority_normal_and_higher+0x56f>
			panic("The programs' working set size should be doubled only once\n");
f011904b:	83 ec 04             	sub    $0x4,%esp
f011904e:	68 6c e9 12 f0       	push   $0xf012e96c
f0119053:	6a 77                	push   $0x77
f0119055:	68 f1 e7 12 f0       	push   $0xf012e7f1
f011905a:	e8 bb 72 fe ff       	call   f010031a <_panic>

		for(int i = 10; i < 15; i++)
f011905f:	c7 45 d4 0a 00 00 00 	movl   $0xa,-0x2c(%ebp)
f0119066:	eb 1c                	jmp    f0119084 <test_priority_normal_and_higher+0x594>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
f0119068:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f011906b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011906e:	89 d0                	mov    %edx,%eax
f0119070:	01 c0                	add    %eax,%eax
f0119072:	01 d0                	add    %edx,%eax
f0119074:	c1 e0 03             	shl    $0x3,%eax
f0119077:	01 c8                	add    %ecx,%eax
f0119079:	05 8c 00 00 00       	add    $0x8c,%eax
f011907e:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
			panic("The programs' working set size should be doubled only once\n");

		for(int i = 10; i < 15; i++)
f0119081:	ff 45 d4             	incl   -0x2c(%ebp)
f0119084:	83 7d d4 0e          	cmpl   $0xe,-0x2c(%ebp)
f0119088:	7e de                	jle    f0119068 <test_priority_normal_and_higher+0x578>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f011908a:	e8 4e 49 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011908f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119092:	e8 7e b7 fe ff       	call   f0104815 <pf_calculate_free_frames>
f0119097:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f011909a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011909d:	83 ec 08             	sub    $0x8,%esp
f01190a0:	6a 05                	push   $0x5
f01190a2:	50                   	push   %eax
f01190a3:	e8 dc 2d ff ff       	call   f010be84 <set_program_priority>
f01190a8:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 5);
f01190ab:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01190ae:	83 ec 08             	sub    $0x8,%esp
f01190b1:	6a 05                	push   $0x5
f01190b3:	50                   	push   %eax
f01190b4:	e8 cb 2d ff ff       	call   f010be84 <set_program_priority>
f01190b9:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f01190bc:	e8 54 b7 fe ff       	call   f0104815 <pf_calculate_free_frames>
f01190c1:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01190c4:	74 17                	je     f01190dd <test_priority_normal_and_higher+0x5ed>
f01190c6:	83 ec 04             	sub    $0x4,%esp
f01190c9:	68 74 e8 12 f0       	push   $0xf012e874
f01190ce:	68 82 00 00 00       	push   $0x82
f01190d3:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01190d8:	e8 3d 72 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f01190dd:	e8 fb 48 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01190e2:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01190e5:	74 17                	je     f01190fe <test_priority_normal_and_higher+0x60e>
f01190e7:	83 ec 04             	sub    $0x4,%esp
f01190ea:	68 74 e8 12 f0       	push   $0xf012e874
f01190ef:	68 83 00 00 00       	push   $0x83
f01190f4:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01190f9:	e8 1c 72 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f01190fe:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0119101:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119107:	83 f8 14             	cmp    $0x14,%eax
f011910a:	75 1c                	jne    f0119128 <test_priority_normal_and_higher+0x638>
f011910c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011910f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119115:	83 f8 1e             	cmp    $0x1e,%eax
f0119118:	75 0e                	jne    f0119128 <test_priority_normal_and_higher+0x638>
f011911a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011911d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119123:	83 f8 28             	cmp    $0x28,%eax
f0119126:	74 17                	je     f011913f <test_priority_normal_and_higher+0x64f>
			panic("The programs' working set size should be doubled if full\n");
f0119128:	83 ec 04             	sub    $0x4,%esp
f011912b:	68 a8 e9 12 f0       	push   $0xf012e9a8
f0119130:	68 86 00 00 00       	push   $0x86
f0119135:	68 f1 e7 12 f0       	push   $0xf012e7f1
f011913a:	e8 db 71 fe ff       	call   f010031a <_panic>

		for(int i = 20; i < 40; i++)
f011913f:	c7 45 d0 14 00 00 00 	movl   $0x14,-0x30(%ebp)
f0119146:	eb 1c                	jmp    f0119164 <test_priority_normal_and_higher+0x674>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
f0119148:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f011914b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011914e:	89 d0                	mov    %edx,%eax
f0119150:	01 c0                	add    %eax,%eax
f0119152:	01 d0                	add    %edx,%eax
f0119154:	c1 e0 03             	shl    $0x3,%eax
f0119157:	01 c8                	add    %ecx,%eax
f0119159:	05 8c 00 00 00       	add    $0x8c,%eax
f011915e:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 20; i < 40; i++)
f0119161:	ff 45 d0             	incl   -0x30(%ebp)
f0119164:	83 7d d0 27          	cmpl   $0x27,-0x30(%ebp)
f0119168:	7e de                	jle    f0119148 <test_priority_normal_and_higher+0x658>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f011916a:	e8 6e 48 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011916f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119172:	e8 9e b6 fe ff       	call   f0104815 <pf_calculate_free_frames>
f0119177:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f011917a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011917d:	83 ec 08             	sub    $0x8,%esp
f0119180:	6a 05                	push   $0x5
f0119182:	50                   	push   %eax
f0119183:	e8 fc 2c ff ff       	call   f010be84 <set_program_priority>
f0119188:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f011918b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011918e:	83 ec 08             	sub    $0x8,%esp
f0119191:	6a 04                	push   $0x4
f0119193:	50                   	push   %eax
f0119194:	e8 eb 2c ff ff       	call   f010be84 <set_program_priority>
f0119199:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f011919c:	e8 74 b6 fe ff       	call   f0104815 <pf_calculate_free_frames>
f01191a1:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01191a4:	74 17                	je     f01191bd <test_priority_normal_and_higher+0x6cd>
f01191a6:	83 ec 04             	sub    $0x4,%esp
f01191a9:	68 74 e8 12 f0       	push   $0xf012e874
f01191ae:	68 91 00 00 00       	push   $0x91
f01191b3:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01191b8:	e8 5d 71 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f01191bd:	e8 1b 48 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01191c2:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01191c5:	74 17                	je     f01191de <test_priority_normal_and_higher+0x6ee>
f01191c7:	83 ec 04             	sub    $0x4,%esp
f01191ca:	68 74 e8 12 f0       	push   $0xf012e874
f01191cf:	68 92 00 00 00       	push   $0x92
f01191d4:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01191d9:	e8 3c 71 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f01191de:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01191e1:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01191e7:	83 f8 14             	cmp    $0x14,%eax
f01191ea:	75 1c                	jne    f0119208 <test_priority_normal_and_higher+0x718>
f01191ec:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01191ef:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01191f5:	83 f8 1e             	cmp    $0x1e,%eax
f01191f8:	75 0e                	jne    f0119208 <test_priority_normal_and_higher+0x718>
f01191fa:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01191fd:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119203:	83 f8 28             	cmp    $0x28,%eax
f0119206:	74 17                	je     f011921f <test_priority_normal_and_higher+0x72f>
			panic("The programs' working set size should be doubled if full\n");
f0119208:	83 ec 04             	sub    $0x4,%esp
f011920b:	68 a8 e9 12 f0       	push   $0xf012e9a8
f0119210:	68 95 00 00 00       	push   $0x95
f0119215:	68 f1 e7 12 f0       	push   $0xf012e7f1
f011921a:	e8 fb 70 fe ff       	call   f010031a <_panic>

		for(int i = 15; i < 30; i++)
f011921f:	c7 45 cc 0f 00 00 00 	movl   $0xf,-0x34(%ebp)
f0119226:	eb 1c                	jmp    f0119244 <test_priority_normal_and_higher+0x754>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
f0119228:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f011922b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011922e:	89 d0                	mov    %edx,%eax
f0119230:	01 c0                	add    %eax,%eax
f0119232:	01 d0                	add    %edx,%eax
f0119234:	c1 e0 03             	shl    $0x3,%eax
f0119237:	01 c8                	add    %ecx,%eax
f0119239:	05 8c 00 00 00       	add    $0x8c,%eax
f011923e:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 15; i < 30; i++)
f0119241:	ff 45 cc             	incl   -0x34(%ebp)
f0119244:	83 7d cc 1d          	cmpl   $0x1d,-0x34(%ebp)
f0119248:	7e de                	jle    f0119228 <test_priority_normal_and_higher+0x738>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f011924a:	e8 8e 47 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011924f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119252:	e8 be b5 fe ff       	call   f0104815 <pf_calculate_free_frames>
f0119257:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f011925a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011925d:	83 ec 08             	sub    $0x8,%esp
f0119260:	6a 05                	push   $0x5
f0119262:	50                   	push   %eax
f0119263:	e8 1c 2c ff ff       	call   f010be84 <set_program_priority>
f0119268:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f011926b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011926e:	83 ec 08             	sub    $0x8,%esp
f0119271:	6a 04                	push   $0x4
f0119273:	50                   	push   %eax
f0119274:	e8 0b 2c ff ff       	call   f010be84 <set_program_priority>
f0119279:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f011927c:	e8 94 b5 fe ff       	call   f0104815 <pf_calculate_free_frames>
f0119281:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0119284:	74 17                	je     f011929d <test_priority_normal_and_higher+0x7ad>
f0119286:	83 ec 04             	sub    $0x4,%esp
f0119289:	68 74 e8 12 f0       	push   $0xf012e874
f011928e:	68 a0 00 00 00       	push   $0xa0
f0119293:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119298:	e8 7d 70 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f011929d:	e8 3b 47 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01192a2:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01192a5:	74 17                	je     f01192be <test_priority_normal_and_higher+0x7ce>
f01192a7:	83 ec 04             	sub    $0x4,%esp
f01192aa:	68 74 e8 12 f0       	push   $0xf012e874
f01192af:	68 a1 00 00 00       	push   $0xa1
f01192b4:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01192b9:	e8 5c 70 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 60 || helloEnv->page_WS_max_size != 40)
f01192be:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01192c1:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01192c7:	83 f8 14             	cmp    $0x14,%eax
f01192ca:	75 1c                	jne    f01192e8 <test_priority_normal_and_higher+0x7f8>
f01192cc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01192cf:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01192d5:	83 f8 3c             	cmp    $0x3c,%eax
f01192d8:	75 0e                	jne    f01192e8 <test_priority_normal_and_higher+0x7f8>
f01192da:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01192dd:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01192e3:	83 f8 28             	cmp    $0x28,%eax
f01192e6:	74 17                	je     f01192ff <test_priority_normal_and_higher+0x80f>
			panic("The programs' working set size should be doubled if full\n");
f01192e8:	83 ec 04             	sub    $0x4,%esp
f01192eb:	68 a8 e9 12 f0       	push   $0xf012e9a8
f01192f0:	68 a4 00 00 00       	push   $0xa4
f01192f5:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01192fa:	e8 1b 70 fe ff       	call   f010031a <_panic>

		for(int i = 15; i < 60; i++)
f01192ff:	c7 45 c8 0f 00 00 00 	movl   $0xf,-0x38(%ebp)
f0119306:	eb 1c                	jmp    f0119324 <test_priority_normal_and_higher+0x834>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
f0119308:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f011930b:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011930e:	89 d0                	mov    %edx,%eax
f0119310:	01 c0                	add    %eax,%eax
f0119312:	01 d0                	add    %edx,%eax
f0119314:	c1 e0 03             	shl    $0x3,%eax
f0119317:	01 c8                	add    %ecx,%eax
f0119319:	05 8c 00 00 00       	add    $0x8c,%eax
f011931e:	c6 00 01             	movb   $0x1,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 60 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 15; i < 60; i++)
f0119321:	ff 45 c8             	incl   -0x38(%ebp)
f0119324:	83 7d c8 3b          	cmpl   $0x3b,-0x38(%ebp)
f0119328:	7e de                	jle    f0119308 <test_priority_normal_and_higher+0x818>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
		}
		for(int i = 10; i < 40; i++)
f011932a:	c7 45 c4 0a 00 00 00 	movl   $0xa,-0x3c(%ebp)
f0119331:	eb 1c                	jmp    f011934f <test_priority_normal_and_higher+0x85f>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
f0119333:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0119336:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0119339:	89 d0                	mov    %edx,%eax
f011933b:	01 c0                	add    %eax,%eax
f011933d:	01 d0                	add    %edx,%eax
f011933f:	c1 e0 03             	shl    $0x3,%eax
f0119342:	01 c8                	add    %ecx,%eax
f0119344:	05 8c 00 00 00       	add    $0x8c,%eax
f0119349:	c6 00 01             	movb   $0x1,(%eax)

		for(int i = 15; i < 60; i++)
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
		}
		for(int i = 10; i < 40; i++)
f011934c:	ff 45 c4             	incl   -0x3c(%ebp)
f011934f:	83 7d c4 27          	cmpl   $0x27,-0x3c(%ebp)
f0119353:	7e de                	jle    f0119333 <test_priority_normal_and_higher+0x843>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
		}

		for(int i = 0; i < 20; i++)
f0119355:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f011935c:	eb 7d                	jmp    f01193db <test_priority_normal_and_higher+0x8eb>
		{
			if(add_WS[i] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f011935e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119361:	8b 8c 85 74 fd ff ff 	mov    -0x28c(%ebp,%eax,4),%ecx
f0119368:	8b 5d ac             	mov    -0x54(%ebp),%ebx
f011936b:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011936e:	89 d0                	mov    %edx,%eax
f0119370:	01 c0                	add    %eax,%eax
f0119372:	01 d0                	add    %edx,%eax
f0119374:	c1 e0 03             	shl    $0x3,%eax
f0119377:	01 d8                	add    %ebx,%eax
f0119379:	05 88 00 00 00       	add    $0x88,%eax
f011937e:	8b 00                	mov    (%eax),%eax
f0119380:	39 c1                	cmp    %eax,%ecx
f0119382:	74 17                	je     f011939b <test_priority_normal_and_higher+0x8ab>
				panic("Working set should be moved properly to the new one");
f0119384:	83 ec 04             	sub    $0x4,%esp
f0119387:	68 e4 e9 12 f0       	push   $0xf012e9e4
f011938c:	68 b2 00 00 00       	push   $0xb2
f0119391:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119396:	e8 7f 6f fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f011939b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011939e:	8b 8c 85 c4 fd ff ff 	mov    -0x23c(%ebp,%eax,4),%ecx
f01193a5:	8b 5d ac             	mov    -0x54(%ebp),%ebx
f01193a8:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01193ab:	89 d0                	mov    %edx,%eax
f01193ad:	01 c0                	add    %eax,%eax
f01193af:	01 d0                	add    %edx,%eax
f01193b1:	c1 e0 03             	shl    $0x3,%eax
f01193b4:	01 d8                	add    %ebx,%eax
f01193b6:	05 90 00 00 00       	add    $0x90,%eax
f01193bb:	8b 00                	mov    (%eax),%eax
f01193bd:	39 c1                	cmp    %eax,%ecx
f01193bf:	74 17                	je     f01193d8 <test_priority_normal_and_higher+0x8e8>
				panic("Working set should be moved properly to the new one");
f01193c1:	83 ec 04             	sub    $0x4,%esp
f01193c4:	68 e4 e9 12 f0       	push   $0xf012e9e4
f01193c9:	68 b5 00 00 00       	push   $0xb5
f01193ce:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01193d3:	e8 42 6f fe ff       	call   f010031a <_panic>
		for(int i = 10; i < 40; i++)
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
		}

		for(int i = 0; i < 20; i++)
f01193d8:	ff 45 c0             	incl   -0x40(%ebp)
f01193db:	83 7d c0 13          	cmpl   $0x13,-0x40(%ebp)
f01193df:	0f 8e 79 ff ff ff    	jle    f011935e <test_priority_normal_and_higher+0x86e>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f01193e5:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f01193ec:	eb 7d                	jmp    f011946b <test_priority_normal_and_higher+0x97b>
		{
			if(fact_WS[i] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f01193ee:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01193f1:	8b 8c 85 fc fc ff ff 	mov    -0x304(%ebp,%eax,4),%ecx
f01193f8:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f01193fb:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01193fe:	89 d0                	mov    %edx,%eax
f0119400:	01 c0                	add    %eax,%eax
f0119402:	01 d0                	add    %edx,%eax
f0119404:	c1 e0 03             	shl    $0x3,%eax
f0119407:	01 d8                	add    %ebx,%eax
f0119409:	05 88 00 00 00       	add    $0x88,%eax
f011940e:	8b 00                	mov    (%eax),%eax
f0119410:	39 c1                	cmp    %eax,%ecx
f0119412:	74 17                	je     f011942b <test_priority_normal_and_higher+0x93b>
				panic("Working set should be moved properly to the new one");
f0119414:	83 ec 04             	sub    $0x4,%esp
f0119417:	68 e4 e9 12 f0       	push   $0xf012e9e4
f011941c:	68 bb 00 00 00       	push   $0xbb
f0119421:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119426:	e8 ef 6e fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f011942b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011942e:	8b 8c 85 38 fd ff ff 	mov    -0x2c8(%ebp,%eax,4),%ecx
f0119435:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119438:	8b 55 bc             	mov    -0x44(%ebp),%edx
f011943b:	89 d0                	mov    %edx,%eax
f011943d:	01 c0                	add    %eax,%eax
f011943f:	01 d0                	add    %edx,%eax
f0119441:	c1 e0 03             	shl    $0x3,%eax
f0119444:	01 d8                	add    %ebx,%eax
f0119446:	05 90 00 00 00       	add    $0x90,%eax
f011944b:	8b 00                	mov    (%eax),%eax
f011944d:	39 c1                	cmp    %eax,%ecx
f011944f:	74 17                	je     f0119468 <test_priority_normal_and_higher+0x978>
				panic("Working set should be moved properly to the new one");
f0119451:	83 ec 04             	sub    $0x4,%esp
f0119454:	68 e4 e9 12 f0       	push   $0xf012e9e4
f0119459:	68 be 00 00 00       	push   $0xbe
f011945e:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119463:	e8 b2 6e fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f0119468:	ff 45 bc             	incl   -0x44(%ebp)
f011946b:	83 7d bc 0e          	cmpl   $0xe,-0x44(%ebp)
f011946f:	0f 8e 79 ff ff ff    	jle    f01193ee <test_priority_normal_and_higher+0x8fe>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f0119475:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f011947c:	eb 7d                	jmp    f01194fb <test_priority_normal_and_higher+0xa0b>
		{
			if(hello_WS[i] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f011947e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119481:	8b 8c 85 ac fc ff ff 	mov    -0x354(%ebp,%eax,4),%ecx
f0119488:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f011948b:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011948e:	89 d0                	mov    %edx,%eax
f0119490:	01 c0                	add    %eax,%eax
f0119492:	01 d0                	add    %edx,%eax
f0119494:	c1 e0 03             	shl    $0x3,%eax
f0119497:	01 d8                	add    %ebx,%eax
f0119499:	05 88 00 00 00       	add    $0x88,%eax
f011949e:	8b 00                	mov    (%eax),%eax
f01194a0:	39 c1                	cmp    %eax,%ecx
f01194a2:	74 17                	je     f01194bb <test_priority_normal_and_higher+0x9cb>
				panic("Working set should be moved properly to the new one");
f01194a4:	83 ec 04             	sub    $0x4,%esp
f01194a7:	68 e4 e9 12 f0       	push   $0xf012e9e4
f01194ac:	68 c4 00 00 00       	push   $0xc4
f01194b1:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01194b6:	e8 5f 6e fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f01194bb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01194be:	8b 8c 85 d4 fc ff ff 	mov    -0x32c(%ebp,%eax,4),%ecx
f01194c5:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f01194c8:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01194cb:	89 d0                	mov    %edx,%eax
f01194cd:	01 c0                	add    %eax,%eax
f01194cf:	01 d0                	add    %edx,%eax
f01194d1:	c1 e0 03             	shl    $0x3,%eax
f01194d4:	01 d8                	add    %ebx,%eax
f01194d6:	05 90 00 00 00       	add    $0x90,%eax
f01194db:	8b 00                	mov    (%eax),%eax
f01194dd:	39 c1                	cmp    %eax,%ecx
f01194df:	74 17                	je     f01194f8 <test_priority_normal_and_higher+0xa08>
				panic("Working set should be moved properly to the new one");
f01194e1:	83 ec 04             	sub    $0x4,%esp
f01194e4:	68 e4 e9 12 f0       	push   $0xf012e9e4
f01194e9:	68 c7 00 00 00       	push   $0xc7
f01194ee:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01194f3:	e8 22 6e fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f01194f8:	ff 45 b8             	incl   -0x48(%ebp)
f01194fb:	83 7d b8 09          	cmpl   $0x9,-0x48(%ebp)
f01194ff:	0f 8e 79 ff ff ff    	jle    f011947e <test_priority_normal_and_higher+0x98e>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		char command4[100] = "runall";
f0119505:	c7 85 40 ff ff ff 72 	movl   $0x616e7572,-0xc0(%ebp)
f011950c:	75 6e 61 
f011950f:	c7 85 44 ff ff ff 6c 	movl   $0x6c6c,-0xbc(%ebp)
f0119516:	6c 00 00 
f0119519:	8d 95 48 ff ff ff    	lea    -0xb8(%ebp),%edx
f011951f:	b9 17 00 00 00       	mov    $0x17,%ecx
f0119524:	b8 00 00 00 00       	mov    $0x0,%eax
f0119529:	89 d7                	mov    %edx,%edi
f011952b:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command4);
f011952d:	83 ec 0c             	sub    $0xc,%esp
f0119530:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
f0119536:	50                   	push   %eax
f0119537:	e8 a0 89 fe ff       	call   f0101edc <execute_command>
f011953c:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nCongratulations!! test priority 1 completed successfully.\n");
	}
#endif
}
f011953f:	eb 10                	jmp    f0119551 <test_priority_normal_and_higher+0xa61>
		char command4[100] = "runall";
		execute_command(command4);
	}
	else
	{
		cprintf("\nCongratulations!! test priority 1 completed successfully.\n");
f0119541:	83 ec 0c             	sub    $0xc,%esp
f0119544:	68 18 ea 12 f0       	push   $0xf012ea18
f0119549:	e8 1e 7a fe ff       	call   f0100f6c <cprintf>
f011954e:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f0119551:	90                   	nop
f0119552:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0119555:	5b                   	pop    %ebx
f0119556:	5e                   	pop    %esi
f0119557:	5f                   	pop    %edi
f0119558:	5d                   	pop    %ebp
f0119559:	c3                   	ret    

f011955a <test_priority_normal_and_lower>:

void test_priority_normal_and_lower()
{
f011955a:	55                   	push   %ebp
f011955b:	89 e5                	mov    %esp,%ebp
f011955d:	57                   	push   %edi
f011955e:	56                   	push   %esi
f011955f:	53                   	push   %ebx
f0119560:	81 ec ac 04 00 00    	sub    $0x4ac,%esp
#if USE_KHEAP
	panic("not handled yet");
#else
	if(firstTime)
f0119566:	a0 d4 0d 18 f0       	mov    0xf0180dd4,%al
f011956b:	84 c0                	test   %al,%al
f011956d:	0f 84 1b 0a 00 00    	je     f0119f8e <test_priority_normal_and_lower+0xa34>
		uint32 fact_WS[30];
		uint32 fact_TimeStamp[30];
		uint32 hello_WS[40];
		uint32 hello_TimeStamp[40];

		firstTime = 0;
f0119573:	c6 05 d4 0d 18 f0 00 	movb   $0x0,0xf0180dd4
		char command[100] = "load fos_add 20";
f011957a:	8d 85 f0 fb ff ff    	lea    -0x410(%ebp),%eax
f0119580:	bb 54 ea 12 f0       	mov    $0xf012ea54,%ebx
f0119585:	ba 04 00 00 00       	mov    $0x4,%edx
f011958a:	89 c7                	mov    %eax,%edi
f011958c:	89 de                	mov    %ebx,%esi
f011958e:	89 d1                	mov    %edx,%ecx
f0119590:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0119592:	8d 95 00 fc ff ff    	lea    -0x400(%ebp),%edx
f0119598:	b9 15 00 00 00       	mov    $0x15,%ecx
f011959d:	b8 00 00 00 00       	mov    $0x0,%eax
f01195a2:	89 d7                	mov    %edx,%edi
f01195a4:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command);
f01195a6:	83 ec 0c             	sub    $0xc,%esp
f01195a9:	8d 85 f0 fb ff ff    	lea    -0x410(%ebp),%eax
f01195af:	50                   	push   %eax
f01195b0:	e8 27 89 fe ff       	call   f0101edc <execute_command>
f01195b5:	83 c4 10             	add    $0x10,%esp
		char command2[100] = "load fact 30";
f01195b8:	8d 85 54 fc ff ff    	lea    -0x3ac(%ebp),%eax
f01195be:	bb 5c ed 12 f0       	mov    $0xf012ed5c,%ebx
f01195c3:	ba 0d 00 00 00       	mov    $0xd,%edx
f01195c8:	89 c7                	mov    %eax,%edi
f01195ca:	89 de                	mov    %ebx,%esi
f01195cc:	89 d1                	mov    %edx,%ecx
f01195ce:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01195d0:	8d 95 61 fc ff ff    	lea    -0x39f(%ebp),%edx
f01195d6:	b9 57 00 00 00       	mov    $0x57,%ecx
f01195db:	b0 00                	mov    $0x0,%al
f01195dd:	89 d7                	mov    %edx,%edi
f01195df:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command2);
f01195e1:	83 ec 0c             	sub    $0xc,%esp
f01195e4:	8d 85 54 fc ff ff    	lea    -0x3ac(%ebp),%eax
f01195ea:	50                   	push   %eax
f01195eb:	e8 ec 88 fe ff       	call   f0101edc <execute_command>
f01195f0:	83 c4 10             	add    $0x10,%esp
		char command3[100] = "load fos_helloWorld 40";
f01195f3:	8d 85 b8 fc ff ff    	lea    -0x348(%ebp),%eax
f01195f9:	bb c0 ed 12 f0       	mov    $0xf012edc0,%ebx
f01195fe:	ba 17 00 00 00       	mov    $0x17,%edx
f0119603:	89 c7                	mov    %eax,%edi
f0119605:	89 de                	mov    %ebx,%esi
f0119607:	89 d1                	mov    %edx,%ecx
f0119609:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011960b:	8d 95 cf fc ff ff    	lea    -0x331(%ebp),%edx
f0119611:	b9 4d 00 00 00       	mov    $0x4d,%ecx
f0119616:	b0 00                	mov    $0x0,%al
f0119618:	89 d7                	mov    %edx,%edi
f011961a:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command3);
f011961c:	83 ec 0c             	sub    $0xc,%esp
f011961f:	8d 85 b8 fc ff ff    	lea    -0x348(%ebp),%eax
f0119625:	50                   	push   %eax
f0119626:	e8 b1 88 fe ff       	call   f0101edc <execute_command>
f011962b:	83 c4 10             	add    $0x10,%esp

		struct Env * addEnv;
		struct Env * factEnv;
		struct Env * helloEnv;
		envid2env(4096, &addEnv, 0);
f011962e:	83 ec 04             	sub    $0x4,%esp
f0119631:	6a 00                	push   $0x0
f0119633:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0119636:	50                   	push   %eax
f0119637:	68 00 10 00 00       	push   $0x1000
f011963c:	e8 54 11 ff ff       	call   f010a795 <envid2env>
f0119641:	83 c4 10             	add    $0x10,%esp
		envid2env(4097, &factEnv, 0);
f0119644:	83 ec 04             	sub    $0x4,%esp
f0119647:	6a 00                	push   $0x0
f0119649:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011964c:	50                   	push   %eax
f011964d:	68 01 10 00 00       	push   $0x1001
f0119652:	e8 3e 11 ff ff       	call   f010a795 <envid2env>
f0119657:	83 c4 10             	add    $0x10,%esp
		envid2env(4098, &helloEnv, 0);
f011965a:	83 ec 04             	sub    $0x4,%esp
f011965d:	6a 00                	push   $0x0
f011965f:	8d 45 b0             	lea    -0x50(%ebp),%eax
f0119662:	50                   	push   %eax
f0119663:	68 02 10 00 00       	push   $0x1002
f0119668:	e8 28 11 ff ff       	call   f010a795 <envid2env>
f011966d:	83 c4 10             	add    $0x10,%esp

		if(addEnv == NULL || factEnv == NULL || helloEnv == NULL)
f0119670:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119673:	85 c0                	test   %eax,%eax
f0119675:	74 0e                	je     f0119685 <test_priority_normal_and_lower+0x12b>
f0119677:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011967a:	85 c0                	test   %eax,%eax
f011967c:	74 07                	je     f0119685 <test_priority_normal_and_lower+0x12b>
f011967e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119681:	85 c0                	test   %eax,%eax
f0119683:	75 17                	jne    f011969c <test_priority_normal_and_lower+0x142>
			panic("Loading programs failed\n");
f0119685:	83 ec 04             	sub    $0x4,%esp
f0119688:	68 d8 e7 12 f0       	push   $0xf012e7d8
f011968d:	68 f2 00 00 00       	push   $0xf2
f0119692:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119697:	e8 7e 6c fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f011969c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011969f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01196a5:	83 f8 14             	cmp    $0x14,%eax
f01196a8:	75 1c                	jne    f01196c6 <test_priority_normal_and_lower+0x16c>
f01196aa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01196ad:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01196b3:	83 f8 1e             	cmp    $0x1e,%eax
f01196b6:	75 0e                	jne    f01196c6 <test_priority_normal_and_lower+0x16c>
f01196b8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01196bb:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01196c1:	83 f8 28             	cmp    $0x28,%eax
f01196c4:	74 17                	je     f01196dd <test_priority_normal_and_lower+0x183>
			panic("The programs should be initially loaded with the given working set size\n");
f01196c6:	83 ec 04             	sub    $0x4,%esp
f01196c9:	68 80 eb 12 f0       	push   $0xf012eb80
f01196ce:	68 f5 00 00 00       	push   $0xf5
f01196d3:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01196d8:	e8 3d 6c fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 20; i++)
f01196dd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01196e4:	eb 47                	jmp    f011972d <test_priority_normal_and_lower+0x1d3>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
f01196e6:	8b 4d b8             	mov    -0x48(%ebp),%ecx
f01196e9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01196ec:	89 d0                	mov    %edx,%eax
f01196ee:	01 c0                	add    %eax,%eax
f01196f0:	01 d0                	add    %edx,%eax
f01196f2:	c1 e0 03             	shl    $0x3,%eax
f01196f5:	01 c8                	add    %ecx,%eax
f01196f7:	05 88 00 00 00       	add    $0x88,%eax
f01196fc:	8b 10                	mov    (%eax),%edx
f01196fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119701:	89 94 85 50 fb ff ff 	mov    %edx,-0x4b0(%ebp,%eax,4)
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
f0119708:	8b 4d b8             	mov    -0x48(%ebp),%ecx
f011970b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011970e:	89 d0                	mov    %edx,%eax
f0119710:	01 c0                	add    %eax,%eax
f0119712:	01 d0                	add    %edx,%eax
f0119714:	c1 e0 03             	shl    $0x3,%eax
f0119717:	01 c8                	add    %ecx,%eax
f0119719:	05 90 00 00 00       	add    $0x90,%eax
f011971e:	8b 10                	mov    (%eax),%edx
f0119720:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119723:	89 94 85 a0 fb ff ff 	mov    %edx,-0x460(%ebp,%eax,4)
			panic("Loading programs failed\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs should be initially loaded with the given working set size\n");

		for(int i = 0; i < 20; i++)
f011972a:	ff 45 e4             	incl   -0x1c(%ebp)
f011972d:	83 7d e4 13          	cmpl   $0x13,-0x1c(%ebp)
f0119731:	7e b3                	jle    f01196e6 <test_priority_normal_and_lower+0x18c>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 30; i++)
f0119733:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011973a:	eb 47                	jmp    f0119783 <test_priority_normal_and_lower+0x229>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
f011973c:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
f011973f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0119742:	89 d0                	mov    %edx,%eax
f0119744:	01 c0                	add    %eax,%eax
f0119746:	01 d0                	add    %edx,%eax
f0119748:	c1 e0 03             	shl    $0x3,%eax
f011974b:	01 c8                	add    %ecx,%eax
f011974d:	05 88 00 00 00       	add    $0x88,%eax
f0119752:	8b 10                	mov    (%eax),%edx
f0119754:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119757:	89 94 85 80 fd ff ff 	mov    %edx,-0x280(%ebp,%eax,4)
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
f011975e:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
f0119761:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0119764:	89 d0                	mov    %edx,%eax
f0119766:	01 c0                	add    %eax,%eax
f0119768:	01 d0                	add    %edx,%eax
f011976a:	c1 e0 03             	shl    $0x3,%eax
f011976d:	01 c8                	add    %ecx,%eax
f011976f:	05 90 00 00 00       	add    $0x90,%eax
f0119774:	8b 10                	mov    (%eax),%edx
f0119776:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119779:	89 94 85 f8 fd ff ff 	mov    %edx,-0x208(%ebp,%eax,4)
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 30; i++)
f0119780:	ff 45 e0             	incl   -0x20(%ebp)
f0119783:	83 7d e0 1d          	cmpl   $0x1d,-0x20(%ebp)
f0119787:	7e b3                	jle    f011973c <test_priority_normal_and_lower+0x1e2>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 40; i++)
f0119789:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0119790:	eb 47                	jmp    f01197d9 <test_priority_normal_and_lower+0x27f>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
f0119792:	8b 4d b0             	mov    -0x50(%ebp),%ecx
f0119795:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0119798:	89 d0                	mov    %edx,%eax
f011979a:	01 c0                	add    %eax,%eax
f011979c:	01 d0                	add    %edx,%eax
f011979e:	c1 e0 03             	shl    $0x3,%eax
f01197a1:	01 c8                	add    %ecx,%eax
f01197a3:	05 88 00 00 00       	add    $0x88,%eax
f01197a8:	8b 10                	mov    (%eax),%edx
f01197aa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01197ad:	89 94 85 70 fe ff ff 	mov    %edx,-0x190(%ebp,%eax,4)
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
f01197b4:	8b 4d b0             	mov    -0x50(%ebp),%ecx
f01197b7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01197ba:	89 d0                	mov    %edx,%eax
f01197bc:	01 c0                	add    %eax,%eax
f01197be:	01 d0                	add    %edx,%eax
f01197c0:	c1 e0 03             	shl    $0x3,%eax
f01197c3:	01 c8                	add    %ecx,%eax
f01197c5:	05 90 00 00 00       	add    $0x90,%eax
f01197ca:	8b 10                	mov    (%eax),%edx
f01197cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01197cf:	89 94 85 10 ff ff ff 	mov    %edx,-0xf0(%ebp,%eax,4)
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 40; i++)
f01197d6:	ff 45 dc             	incl   -0x24(%ebp)
f01197d9:	83 7d dc 27          	cmpl   $0x27,-0x24(%ebp)
f01197dd:	7e b3                	jle    f0119792 <test_priority_normal_and_lower+0x238>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		int freeFrames = sys_calculate_free_frames();
f01197df:	e8 f9 41 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01197e4:	89 45 c0             	mov    %eax,-0x40(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f01197e7:	e8 29 b0 fe ff       	call   f0104815 <pf_calculate_free_frames>
f01197ec:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Normal // Should change nothing
		set_program_priority(addEnv, 3);
f01197ef:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01197f2:	83 ec 08             	sub    $0x8,%esp
f01197f5:	6a 03                	push   $0x3
f01197f7:	50                   	push   %eax
f01197f8:	e8 87 26 ff ff       	call   f010be84 <set_program_priority>
f01197fd:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 3);
f0119800:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119803:	83 ec 08             	sub    $0x8,%esp
f0119806:	6a 03                	push   $0x3
f0119808:	50                   	push   %eax
f0119809:	e8 76 26 ff ff       	call   f010be84 <set_program_priority>
f011980e:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 3);
f0119811:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119814:	83 ec 08             	sub    $0x8,%esp
f0119817:	6a 03                	push   $0x3
f0119819:	50                   	push   %eax
f011981a:	e8 65 26 ff ff       	call   f010be84 <set_program_priority>
f011981f:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0119822:	e8 ee af fe ff       	call   f0104815 <pf_calculate_free_frames>
f0119827:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f011982a:	74 17                	je     f0119843 <test_priority_normal_and_lower+0x2e9>
f011982c:	83 ec 04             	sub    $0x4,%esp
f011982f:	68 74 e8 12 f0       	push   $0xf012e874
f0119834:	68 11 01 00 00       	push   $0x111
f0119839:	68 f1 e7 12 f0       	push   $0xf012e7f1
f011983e:	e8 d7 6a fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0119843:	e8 95 41 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0119848:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f011984b:	74 17                	je     f0119864 <test_priority_normal_and_lower+0x30a>
f011984d:	83 ec 04             	sub    $0x4,%esp
f0119850:	68 74 e8 12 f0       	push   $0xf012e874
f0119855:	68 12 01 00 00       	push   $0x112
f011985a:	68 f1 e7 12 f0       	push   $0xf012e7f1
f011985f:	e8 b6 6a fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f0119864:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119867:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011986d:	83 f8 14             	cmp    $0x14,%eax
f0119870:	75 1c                	jne    f011988e <test_priority_normal_and_lower+0x334>
f0119872:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119875:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011987b:	83 f8 1e             	cmp    $0x1e,%eax
f011987e:	75 0e                	jne    f011988e <test_priority_normal_and_lower+0x334>
f0119880:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119883:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119889:	83 f8 28             	cmp    $0x28,%eax
f011988c:	74 17                	je     f01198a5 <test_priority_normal_and_lower+0x34b>
			panic("The programs' working set size should not change after setting priority to normal\n");
f011988e:	83 ec 04             	sub    $0x4,%esp
f0119891:	68 a0 e8 12 f0       	push   $0xf012e8a0
f0119896:	68 15 01 00 00       	push   $0x115
f011989b:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01198a0:	e8 75 6a fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f01198a5:	e8 33 41 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01198aa:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01198ad:	e8 63 af fe ff       	call   f0104815 <pf_calculate_free_frames>
f01198b2:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Below Normal // Should change only if half is free
		set_program_priority(addEnv, 2);
f01198b5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01198b8:	83 ec 08             	sub    $0x8,%esp
f01198bb:	6a 02                	push   $0x2
f01198bd:	50                   	push   %eax
f01198be:	e8 c1 25 ff ff       	call   f010be84 <set_program_priority>
f01198c3:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 2);
f01198c6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01198c9:	83 ec 08             	sub    $0x8,%esp
f01198cc:	6a 02                	push   $0x2
f01198ce:	50                   	push   %eax
f01198cf:	e8 b0 25 ff ff       	call   f010be84 <set_program_priority>
f01198d4:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 2);
f01198d7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01198da:	83 ec 08             	sub    $0x8,%esp
f01198dd:	6a 02                	push   $0x2
f01198df:	50                   	push   %eax
f01198e0:	e8 9f 25 ff ff       	call   f010be84 <set_program_priority>
f01198e5:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f01198e8:	e8 28 af fe ff       	call   f0104815 <pf_calculate_free_frames>
f01198ed:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f01198f0:	74 17                	je     f0119909 <test_priority_normal_and_lower+0x3af>
f01198f2:	83 ec 04             	sub    $0x4,%esp
f01198f5:	68 74 e8 12 f0       	push   $0xf012e874
f01198fa:	68 1f 01 00 00       	push   $0x11f
f01198ff:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119904:	e8 11 6a fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));
f0119909:	e8 cf 40 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011990e:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0119911:	74 21                	je     f0119934 <test_priority_normal_and_lower+0x3da>
f0119913:	e8 c5 40 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0119918:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011991b:	29 c2                	sub    %eax,%edx
f011991d:	89 d0                	mov    %edx,%eax
f011991f:	50                   	push   %eax
f0119920:	68 f4 e8 12 f0       	push   $0xf012e8f4
f0119925:	68 20 01 00 00       	push   $0x120
f011992a:	68 f1 e7 12 f0       	push   $0xf012e7f1
f011992f:	e8 e6 69 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0119934:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119937:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011993d:	83 f8 0a             	cmp    $0xa,%eax
f0119940:	75 1c                	jne    f011995e <test_priority_normal_and_lower+0x404>
f0119942:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119945:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011994b:	83 f8 0f             	cmp    $0xf,%eax
f011994e:	75 0e                	jne    f011995e <test_priority_normal_and_lower+0x404>
f0119950:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119953:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119959:	83 f8 14             	cmp    $0x14,%eax
f011995c:	74 17                	je     f0119975 <test_priority_normal_and_lower+0x41b>
			panic("The programs' working set size should be doubled only if it is full\n");
f011995e:	83 ec 04             	sub    $0x4,%esp
f0119961:	68 24 e9 12 f0       	push   $0xf012e924
f0119966:	68 23 01 00 00       	push   $0x123
f011996b:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119970:	e8 a5 69 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f0119975:	e8 63 40 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011997a:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011997d:	e8 93 ae fe ff       	call   f0104815 <pf_calculate_free_frames>
f0119982:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Below Normal // Should change only if half is free
		set_program_priority(addEnv, 2);
f0119985:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119988:	83 ec 08             	sub    $0x8,%esp
f011998b:	6a 02                	push   $0x2
f011998d:	50                   	push   %eax
f011998e:	e8 f1 24 ff ff       	call   f010be84 <set_program_priority>
f0119993:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 2);
f0119996:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119999:	83 ec 08             	sub    $0x8,%esp
f011999c:	6a 02                	push   $0x2
f011999e:	50                   	push   %eax
f011999f:	e8 e0 24 ff ff       	call   f010be84 <set_program_priority>
f01199a4:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 2);
f01199a7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01199aa:	83 ec 08             	sub    $0x8,%esp
f01199ad:	6a 02                	push   $0x2
f01199af:	50                   	push   %eax
f01199b0:	e8 cf 24 ff ff       	call   f010be84 <set_program_priority>
f01199b5:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f01199b8:	e8 58 ae fe ff       	call   f0104815 <pf_calculate_free_frames>
f01199bd:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f01199c0:	74 17                	je     f01199d9 <test_priority_normal_and_lower+0x47f>
f01199c2:	83 ec 04             	sub    $0x4,%esp
f01199c5:	68 74 e8 12 f0       	push   $0xf012e874
f01199ca:	68 2d 01 00 00       	push   $0x12d
f01199cf:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01199d4:	e8 41 69 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));
f01199d9:	e8 ff 3f ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01199de:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f01199e1:	74 21                	je     f0119a04 <test_priority_normal_and_lower+0x4aa>
f01199e3:	e8 f5 3f ff ff       	call   f010d9dd <sys_calculate_free_frames>
f01199e8:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01199eb:	29 c2                	sub    %eax,%edx
f01199ed:	89 d0                	mov    %edx,%eax
f01199ef:	50                   	push   %eax
f01199f0:	68 f4 e8 12 f0       	push   $0xf012e8f4
f01199f5:	68 2e 01 00 00       	push   $0x12e
f01199fa:	68 f1 e7 12 f0       	push   $0xf012e7f1
f01199ff:	e8 16 69 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0119a04:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119a07:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119a0d:	83 f8 0a             	cmp    $0xa,%eax
f0119a10:	75 1c                	jne    f0119a2e <test_priority_normal_and_lower+0x4d4>
f0119a12:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119a15:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119a1b:	83 f8 0f             	cmp    $0xf,%eax
f0119a1e:	75 0e                	jne    f0119a2e <test_priority_normal_and_lower+0x4d4>
f0119a20:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119a23:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119a29:	83 f8 0a             	cmp    $0xa,%eax
f0119a2c:	74 17                	je     f0119a45 <test_priority_normal_and_lower+0x4eb>
			panic("The programs' working set size should be doubled only if it is full\n");
f0119a2e:	83 ec 04             	sub    $0x4,%esp
f0119a31:	68 24 e9 12 f0       	push   $0xf012e924
f0119a36:	68 31 01 00 00       	push   $0x131
f0119a3b:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119a40:	e8 d5 68 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 10; i++)
f0119a45:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0119a4c:	eb 7d                	jmp    f0119acb <test_priority_normal_and_lower+0x571>
		{
			if(add_WS[i] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f0119a4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119a51:	8b 8c 85 50 fb ff ff 	mov    -0x4b0(%ebp,%eax,4),%ecx
f0119a58:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0119a5b:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0119a5e:	89 d0                	mov    %edx,%eax
f0119a60:	01 c0                	add    %eax,%eax
f0119a62:	01 d0                	add    %edx,%eax
f0119a64:	c1 e0 03             	shl    $0x3,%eax
f0119a67:	01 d8                	add    %ebx,%eax
f0119a69:	05 88 00 00 00       	add    $0x88,%eax
f0119a6e:	8b 00                	mov    (%eax),%eax
f0119a70:	39 c1                	cmp    %eax,%ecx
f0119a72:	74 17                	je     f0119a8b <test_priority_normal_and_lower+0x531>
				panic("Working set should be moved properly to the new one");
f0119a74:	83 ec 04             	sub    $0x4,%esp
f0119a77:	68 e4 e9 12 f0       	push   $0xf012e9e4
f0119a7c:	68 36 01 00 00       	push   $0x136
f0119a81:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119a86:	e8 8f 68 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f0119a8b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119a8e:	8b 8c 85 a0 fb ff ff 	mov    -0x460(%ebp,%eax,4),%ecx
f0119a95:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0119a98:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0119a9b:	89 d0                	mov    %edx,%eax
f0119a9d:	01 c0                	add    %eax,%eax
f0119a9f:	01 d0                	add    %edx,%eax
f0119aa1:	c1 e0 03             	shl    $0x3,%eax
f0119aa4:	01 d8                	add    %ebx,%eax
f0119aa6:	05 90 00 00 00       	add    $0x90,%eax
f0119aab:	8b 00                	mov    (%eax),%eax
f0119aad:	39 c1                	cmp    %eax,%ecx
f0119aaf:	74 17                	je     f0119ac8 <test_priority_normal_and_lower+0x56e>
				panic("Working set should be moved properly to the new one");
f0119ab1:	83 ec 04             	sub    $0x4,%esp
f0119ab4:	68 e4 e9 12 f0       	push   $0xf012e9e4
f0119ab9:	68 39 01 00 00       	push   $0x139
f0119abe:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119ac3:	e8 52 68 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
			panic("The programs' working set size should be doubled only if it is full\n");

		for(int i = 0; i < 10; i++)
f0119ac8:	ff 45 d8             	incl   -0x28(%ebp)
f0119acb:	83 7d d8 09          	cmpl   $0x9,-0x28(%ebp)
f0119acf:	0f 8e 79 ff ff ff    	jle    f0119a4e <test_priority_normal_and_lower+0x4f4>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f0119ad5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0119adc:	eb 7d                	jmp    f0119b5b <test_priority_normal_and_lower+0x601>
		{
			if(fact_WS[i] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f0119ade:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0119ae1:	8b 8c 85 80 fd ff ff 	mov    -0x280(%ebp,%eax,4),%ecx
f0119ae8:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0119aeb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0119aee:	89 d0                	mov    %edx,%eax
f0119af0:	01 c0                	add    %eax,%eax
f0119af2:	01 d0                	add    %edx,%eax
f0119af4:	c1 e0 03             	shl    $0x3,%eax
f0119af7:	01 d8                	add    %ebx,%eax
f0119af9:	05 88 00 00 00       	add    $0x88,%eax
f0119afe:	8b 00                	mov    (%eax),%eax
f0119b00:	39 c1                	cmp    %eax,%ecx
f0119b02:	74 17                	je     f0119b1b <test_priority_normal_and_lower+0x5c1>
				panic("Working set should be moved properly to the new one");
f0119b04:	83 ec 04             	sub    $0x4,%esp
f0119b07:	68 e4 e9 12 f0       	push   $0xf012e9e4
f0119b0c:	68 3f 01 00 00       	push   $0x13f
f0119b11:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119b16:	e8 ff 67 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f0119b1b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0119b1e:	8b 8c 85 f8 fd ff ff 	mov    -0x208(%ebp,%eax,4),%ecx
f0119b25:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0119b28:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0119b2b:	89 d0                	mov    %edx,%eax
f0119b2d:	01 c0                	add    %eax,%eax
f0119b2f:	01 d0                	add    %edx,%eax
f0119b31:	c1 e0 03             	shl    $0x3,%eax
f0119b34:	01 d8                	add    %ebx,%eax
f0119b36:	05 90 00 00 00       	add    $0x90,%eax
f0119b3b:	8b 00                	mov    (%eax),%eax
f0119b3d:	39 c1                	cmp    %eax,%ecx
f0119b3f:	74 17                	je     f0119b58 <test_priority_normal_and_lower+0x5fe>
				panic("Working set should be moved properly to the new one");
f0119b41:	83 ec 04             	sub    $0x4,%esp
f0119b44:	68 e4 e9 12 f0       	push   $0xf012e9e4
f0119b49:	68 42 01 00 00       	push   $0x142
f0119b4e:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119b53:	e8 c2 67 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f0119b58:	ff 45 d4             	incl   -0x2c(%ebp)
f0119b5b:	83 7d d4 0e          	cmpl   $0xe,-0x2c(%ebp)
f0119b5f:	0f 8e 79 ff ff ff    	jle    f0119ade <test_priority_normal_and_lower+0x584>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f0119b65:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0119b6c:	eb 7d                	jmp    f0119beb <test_priority_normal_and_lower+0x691>
		{
			if(hello_WS[i] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f0119b6e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119b71:	8b 8c 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%ecx
f0119b78:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0119b7b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0119b7e:	89 d0                	mov    %edx,%eax
f0119b80:	01 c0                	add    %eax,%eax
f0119b82:	01 d0                	add    %edx,%eax
f0119b84:	c1 e0 03             	shl    $0x3,%eax
f0119b87:	01 d8                	add    %ebx,%eax
f0119b89:	05 88 00 00 00       	add    $0x88,%eax
f0119b8e:	8b 00                	mov    (%eax),%eax
f0119b90:	39 c1                	cmp    %eax,%ecx
f0119b92:	74 17                	je     f0119bab <test_priority_normal_and_lower+0x651>
				panic("Working set should be moved properly to the new one");
f0119b94:	83 ec 04             	sub    $0x4,%esp
f0119b97:	68 e4 e9 12 f0       	push   $0xf012e9e4
f0119b9c:	68 48 01 00 00       	push   $0x148
f0119ba1:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119ba6:	e8 6f 67 fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f0119bab:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119bae:	8b 8c 85 10 ff ff ff 	mov    -0xf0(%ebp,%eax,4),%ecx
f0119bb5:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0119bb8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0119bbb:	89 d0                	mov    %edx,%eax
f0119bbd:	01 c0                	add    %eax,%eax
f0119bbf:	01 d0                	add    %edx,%eax
f0119bc1:	c1 e0 03             	shl    $0x3,%eax
f0119bc4:	01 d8                	add    %ebx,%eax
f0119bc6:	05 90 00 00 00       	add    $0x90,%eax
f0119bcb:	8b 00                	mov    (%eax),%eax
f0119bcd:	39 c1                	cmp    %eax,%ecx
f0119bcf:	74 17                	je     f0119be8 <test_priority_normal_and_lower+0x68e>
				panic("Working set should be moved properly to the new one");
f0119bd1:	83 ec 04             	sub    $0x4,%esp
f0119bd4:	68 e4 e9 12 f0       	push   $0xf012e9e4
f0119bd9:	68 4b 01 00 00       	push   $0x14b
f0119bde:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119be3:	e8 32 67 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f0119be8:	ff 45 d0             	incl   -0x30(%ebp)
f0119beb:	83 7d d0 09          	cmpl   $0x9,-0x30(%ebp)
f0119bef:	0f 8e 79 ff ff ff    	jle    f0119b6e <test_priority_normal_and_lower+0x614>
			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		// Set priority to low
		freeFrames = sys_calculate_free_frames();
f0119bf5:	e8 e3 3d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0119bfa:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119bfd:	e8 13 ac fe ff       	call   f0104815 <pf_calculate_free_frames>
f0119c02:	89 45 bc             	mov    %eax,-0x44(%ebp)
		set_program_priority(addEnv, 1);
f0119c05:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119c08:	83 ec 08             	sub    $0x8,%esp
f0119c0b:	6a 01                	push   $0x1
f0119c0d:	50                   	push   %eax
f0119c0e:	e8 71 22 ff ff       	call   f010be84 <set_program_priority>
f0119c13:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 1);
f0119c16:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119c19:	83 ec 08             	sub    $0x8,%esp
f0119c1c:	6a 01                	push   $0x1
f0119c1e:	50                   	push   %eax
f0119c1f:	e8 60 22 ff ff       	call   f010be84 <set_program_priority>
f0119c24:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 1);
f0119c27:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119c2a:	83 ec 08             	sub    $0x8,%esp
f0119c2d:	6a 01                	push   $0x1
f0119c2f:	50                   	push   %eax
f0119c30:	e8 4f 22 ff ff       	call   f010be84 <set_program_priority>
f0119c35:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0119c38:	e8 d8 ab fe ff       	call   f0104815 <pf_calculate_free_frames>
f0119c3d:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0119c40:	74 17                	je     f0119c59 <test_priority_normal_and_lower+0x6ff>
f0119c42:	83 ec 04             	sub    $0x4,%esp
f0119c45:	68 74 e8 12 f0       	push   $0xf012e874
f0119c4a:	68 54 01 00 00       	push   $0x154
f0119c4f:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119c54:	e8 c1 66 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != (5+3+5)) panic("Old working set and extra pages in WS should be removed properly %d\n");
f0119c59:	e8 7f 3d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0119c5e:	2b 45 c0             	sub    -0x40(%ebp),%eax
f0119c61:	83 f8 0d             	cmp    $0xd,%eax
f0119c64:	74 17                	je     f0119c7d <test_priority_normal_and_lower+0x723>
f0119c66:	83 ec 04             	sub    $0x4,%esp
f0119c69:	68 cc eb 12 f0       	push   $0xf012ebcc
f0119c6e:	68 55 01 00 00       	push   $0x155
f0119c73:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119c78:	e8 9d 66 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 5 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
f0119c7d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119c80:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119c86:	83 f8 05             	cmp    $0x5,%eax
f0119c89:	75 1c                	jne    f0119ca7 <test_priority_normal_and_lower+0x74d>
f0119c8b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119c8e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119c94:	83 f8 07             	cmp    $0x7,%eax
f0119c97:	75 0e                	jne    f0119ca7 <test_priority_normal_and_lower+0x74d>
f0119c99:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119c9c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119ca2:	83 f8 05             	cmp    $0x5,%eax
f0119ca5:	74 17                	je     f0119cbe <test_priority_normal_and_lower+0x764>
			panic("The programs' working set size should be half\n");
f0119ca7:	83 ec 04             	sub    $0x4,%esp
f0119caa:	68 14 ec 12 f0       	push   $0xf012ec14
f0119caf:	68 58 01 00 00       	push   $0x158
f0119cb4:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119cb9:	e8 5c 66 fe ff       	call   f010031a <_panic>


		freeFrames = sys_calculate_free_frames();
f0119cbe:	e8 1a 3d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0119cc3:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119cc6:	e8 4a ab fe ff       	call   f0104815 <pf_calculate_free_frames>
f0119ccb:	89 45 bc             	mov    %eax,-0x44(%ebp)
		set_program_priority(addEnv, 1);
f0119cce:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119cd1:	83 ec 08             	sub    $0x8,%esp
f0119cd4:	6a 01                	push   $0x1
f0119cd6:	50                   	push   %eax
f0119cd7:	e8 a8 21 ff ff       	call   f010be84 <set_program_priority>
f0119cdc:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0119cdf:	e8 31 ab fe ff       	call   f0104815 <pf_calculate_free_frames>
f0119ce4:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0119ce7:	74 17                	je     f0119d00 <test_priority_normal_and_lower+0x7a6>
f0119ce9:	83 ec 04             	sub    $0x4,%esp
f0119cec:	68 74 e8 12 f0       	push   $0xf012e874
f0119cf1:	68 5e 01 00 00       	push   $0x15e
f0119cf6:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119cfb:	e8 1a 66 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 3) panic("Old working set should be removed properly\n");
f0119d00:	e8 d8 3c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f0119d05:	2b 45 c0             	sub    -0x40(%ebp),%eax
f0119d08:	83 f8 03             	cmp    $0x3,%eax
f0119d0b:	74 17                	je     f0119d24 <test_priority_normal_and_lower+0x7ca>
f0119d0d:	83 ec 04             	sub    $0x4,%esp
f0119d10:	68 74 e8 12 f0       	push   $0xf012e874
f0119d15:	68 5f 01 00 00       	push   $0x15f
f0119d1a:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119d1f:	e8 f6 65 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 2 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
f0119d24:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119d27:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119d2d:	83 f8 02             	cmp    $0x2,%eax
f0119d30:	75 1c                	jne    f0119d4e <test_priority_normal_and_lower+0x7f4>
f0119d32:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119d35:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119d3b:	83 f8 07             	cmp    $0x7,%eax
f0119d3e:	75 0e                	jne    f0119d4e <test_priority_normal_and_lower+0x7f4>
f0119d40:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119d43:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0119d49:	83 f8 05             	cmp    $0x5,%eax
f0119d4c:	74 17                	je     f0119d65 <test_priority_normal_and_lower+0x80b>
			panic("The programs' working set size should be doubled if full\n");
f0119d4e:	83 ec 04             	sub    $0x4,%esp
f0119d51:	68 a8 e9 12 f0       	push   $0xf012e9a8
f0119d56:	68 62 01 00 00       	push   $0x162
f0119d5b:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119d60:	e8 b5 65 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 2; i++)
f0119d65:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0119d6c:	e9 83 00 00 00       	jmp    f0119df4 <test_priority_normal_and_lower+0x89a>
		{
			if(add_WS[i+8] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f0119d71:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119d74:	83 c0 08             	add    $0x8,%eax
f0119d77:	8b 8c 85 50 fb ff ff 	mov    -0x4b0(%ebp,%eax,4),%ecx
f0119d7e:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0119d81:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0119d84:	89 d0                	mov    %edx,%eax
f0119d86:	01 c0                	add    %eax,%eax
f0119d88:	01 d0                	add    %edx,%eax
f0119d8a:	c1 e0 03             	shl    $0x3,%eax
f0119d8d:	01 d8                	add    %ebx,%eax
f0119d8f:	05 88 00 00 00       	add    $0x88,%eax
f0119d94:	8b 00                	mov    (%eax),%eax
f0119d96:	39 c1                	cmp    %eax,%ecx
f0119d98:	74 17                	je     f0119db1 <test_priority_normal_and_lower+0x857>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0119d9a:	83 ec 04             	sub    $0x4,%esp
f0119d9d:	68 44 ec 12 f0       	push   $0xf012ec44
f0119da2:	68 67 01 00 00       	push   $0x167
f0119da7:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119dac:	e8 69 65 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f0119db1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119db4:	83 c0 08             	add    $0x8,%eax
f0119db7:	8b 8c 85 a0 fb ff ff 	mov    -0x460(%ebp,%eax,4),%ecx
f0119dbe:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0119dc1:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0119dc4:	89 d0                	mov    %edx,%eax
f0119dc6:	01 c0                	add    %eax,%eax
f0119dc8:	01 d0                	add    %edx,%eax
f0119dca:	c1 e0 03             	shl    $0x3,%eax
f0119dcd:	01 d8                	add    %ebx,%eax
f0119dcf:	05 90 00 00 00       	add    $0x90,%eax
f0119dd4:	8b 00                	mov    (%eax),%eax
f0119dd6:	39 c1                	cmp    %eax,%ecx
f0119dd8:	74 17                	je     f0119df1 <test_priority_normal_and_lower+0x897>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0119dda:	83 ec 04             	sub    $0x4,%esp
f0119ddd:	68 44 ec 12 f0       	push   $0xf012ec44
f0119de2:	68 6a 01 00 00       	push   $0x16a
f0119de7:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119dec:	e8 29 65 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 3) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 2 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 0; i < 2; i++)
f0119df1:	ff 45 cc             	incl   -0x34(%ebp)
f0119df4:	83 7d cc 01          	cmpl   $0x1,-0x34(%ebp)
f0119df8:	0f 8e 73 ff ff ff    	jle    f0119d71 <test_priority_normal_and_lower+0x817>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 7; i++)
f0119dfe:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f0119e05:	e9 83 00 00 00       	jmp    f0119e8d <test_priority_normal_and_lower+0x933>
		{
			if(fact_WS[i+3] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f0119e0a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119e0d:	83 c0 03             	add    $0x3,%eax
f0119e10:	8b 8c 85 80 fd ff ff 	mov    -0x280(%ebp,%eax,4),%ecx
f0119e17:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0119e1a:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0119e1d:	89 d0                	mov    %edx,%eax
f0119e1f:	01 c0                	add    %eax,%eax
f0119e21:	01 d0                	add    %edx,%eax
f0119e23:	c1 e0 03             	shl    $0x3,%eax
f0119e26:	01 d8                	add    %ebx,%eax
f0119e28:	05 88 00 00 00       	add    $0x88,%eax
f0119e2d:	8b 00                	mov    (%eax),%eax
f0119e2f:	39 c1                	cmp    %eax,%ecx
f0119e31:	74 17                	je     f0119e4a <test_priority_normal_and_lower+0x8f0>
				panic("%d Working set should be moved properly to the new one, removed pages are chosen based on replacement policy", i);
f0119e33:	ff 75 c8             	pushl  -0x38(%ebp)
f0119e36:	68 b0 ec 12 f0       	push   $0xf012ecb0
f0119e3b:	68 70 01 00 00       	push   $0x170
f0119e40:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119e45:	e8 d0 64 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f0119e4a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119e4d:	83 c0 03             	add    $0x3,%eax
f0119e50:	8b 8c 85 f8 fd ff ff 	mov    -0x208(%ebp,%eax,4),%ecx
f0119e57:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0119e5a:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0119e5d:	89 d0                	mov    %edx,%eax
f0119e5f:	01 c0                	add    %eax,%eax
f0119e61:	01 d0                	add    %edx,%eax
f0119e63:	c1 e0 03             	shl    $0x3,%eax
f0119e66:	01 d8                	add    %ebx,%eax
f0119e68:	05 90 00 00 00       	add    $0x90,%eax
f0119e6d:	8b 00                	mov    (%eax),%eax
f0119e6f:	39 c1                	cmp    %eax,%ecx
f0119e71:	74 17                	je     f0119e8a <test_priority_normal_and_lower+0x930>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0119e73:	83 ec 04             	sub    $0x4,%esp
f0119e76:	68 44 ec 12 f0       	push   $0xf012ec44
f0119e7b:	68 73 01 00 00       	push   $0x173
f0119e80:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119e85:	e8 90 64 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 7; i++)
f0119e8a:	ff 45 c8             	incl   -0x38(%ebp)
f0119e8d:	83 7d c8 06          	cmpl   $0x6,-0x38(%ebp)
f0119e91:	0f 8e 73 ff ff ff    	jle    f0119e0a <test_priority_normal_and_lower+0x8b0>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 5; i++)
f0119e97:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0119e9e:	e9 83 00 00 00       	jmp    f0119f26 <test_priority_normal_and_lower+0x9cc>
		{
			if(hello_WS[i+5] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f0119ea3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119ea6:	83 c0 05             	add    $0x5,%eax
f0119ea9:	8b 8c 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%ecx
f0119eb0:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0119eb3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0119eb6:	89 d0                	mov    %edx,%eax
f0119eb8:	01 c0                	add    %eax,%eax
f0119eba:	01 d0                	add    %edx,%eax
f0119ebc:	c1 e0 03             	shl    $0x3,%eax
f0119ebf:	01 d8                	add    %ebx,%eax
f0119ec1:	05 88 00 00 00       	add    $0x88,%eax
f0119ec6:	8b 00                	mov    (%eax),%eax
f0119ec8:	39 c1                	cmp    %eax,%ecx
f0119eca:	74 17                	je     f0119ee3 <test_priority_normal_and_lower+0x989>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0119ecc:	83 ec 04             	sub    $0x4,%esp
f0119ecf:	68 44 ec 12 f0       	push   $0xf012ec44
f0119ed4:	68 79 01 00 00       	push   $0x179
f0119ed9:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119ede:	e8 37 64 fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i+5] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f0119ee3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119ee6:	83 c0 05             	add    $0x5,%eax
f0119ee9:	8b 8c 85 10 ff ff ff 	mov    -0xf0(%ebp,%eax,4),%ecx
f0119ef0:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0119ef3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0119ef6:	89 d0                	mov    %edx,%eax
f0119ef8:	01 c0                	add    %eax,%eax
f0119efa:	01 d0                	add    %edx,%eax
f0119efc:	c1 e0 03             	shl    $0x3,%eax
f0119eff:	01 d8                	add    %ebx,%eax
f0119f01:	05 90 00 00 00       	add    $0x90,%eax
f0119f06:	8b 00                	mov    (%eax),%eax
f0119f08:	39 c1                	cmp    %eax,%ecx
f0119f0a:	74 17                	je     f0119f23 <test_priority_normal_and_lower+0x9c9>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0119f0c:	83 ec 04             	sub    $0x4,%esp
f0119f0f:	68 44 ec 12 f0       	push   $0xf012ec44
f0119f14:	68 7c 01 00 00       	push   $0x17c
f0119f19:	68 f1 e7 12 f0       	push   $0xf012e7f1
f0119f1e:	e8 f7 63 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 5; i++)
f0119f23:	ff 45 c4             	incl   -0x3c(%ebp)
f0119f26:	83 7d c4 04          	cmpl   $0x4,-0x3c(%ebp)
f0119f2a:	0f 8e 73 ff ff ff    	jle    f0119ea3 <test_priority_normal_and_lower+0x949>

			if(hello_TimeStamp[i+5] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		set_program_priority(addEnv, 5);
f0119f30:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119f33:	83 ec 08             	sub    $0x8,%esp
f0119f36:	6a 05                	push   $0x5
f0119f38:	50                   	push   %eax
f0119f39:	e8 46 1f ff ff       	call   f010be84 <set_program_priority>
f0119f3e:	83 c4 10             	add    $0x10,%esp
		set_program_priority(addEnv, 5);
f0119f41:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119f44:	83 ec 08             	sub    $0x8,%esp
f0119f47:	6a 05                	push   $0x5
f0119f49:	50                   	push   %eax
f0119f4a:	e8 35 1f ff ff       	call   f010be84 <set_program_priority>
f0119f4f:	83 c4 10             	add    $0x10,%esp

		char command4[100] = "runall";
f0119f52:	c7 85 1c fd ff ff 72 	movl   $0x616e7572,-0x2e4(%ebp)
f0119f59:	75 6e 61 
f0119f5c:	c7 85 20 fd ff ff 6c 	movl   $0x6c6c,-0x2e0(%ebp)
f0119f63:	6c 00 00 
f0119f66:	8d 95 24 fd ff ff    	lea    -0x2dc(%ebp),%edx
f0119f6c:	b9 17 00 00 00       	mov    $0x17,%ecx
f0119f71:	b8 00 00 00 00       	mov    $0x0,%eax
f0119f76:	89 d7                	mov    %edx,%edi
f0119f78:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command4);
f0119f7a:	83 ec 0c             	sub    $0xc,%esp
f0119f7d:	8d 85 1c fd ff ff    	lea    -0x2e4(%ebp),%eax
f0119f83:	50                   	push   %eax
f0119f84:	e8 53 7f fe ff       	call   f0101edc <execute_command>
f0119f89:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nCongratulations!! test priority 2 completed successfully.\n");
	}
#endif
}
f0119f8c:	eb 10                	jmp    f0119f9e <test_priority_normal_and_lower+0xa44>
		char command4[100] = "runall";
		execute_command(command4);
	}
	else
	{
		cprintf("\nCongratulations!! test priority 2 completed successfully.\n");
f0119f8e:	83 ec 0c             	sub    $0xc,%esp
f0119f91:	68 20 ed 12 f0       	push   $0xf012ed20
f0119f96:	e8 d1 6f fe ff       	call   f0100f6c <cprintf>
f0119f9b:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f0119f9e:	90                   	nop
f0119f9f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0119fa2:	5b                   	pop    %ebx
f0119fa3:	5e                   	pop    %esi
f0119fa4:	5f                   	pop    %edi
f0119fa5:	5d                   	pop    %ebp
f0119fa6:	c3                   	ret    

f0119fa7 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0119fa7:	55                   	push   %ebp
f0119fa8:	89 e5                	mov    %esp,%ebp
f0119faa:	57                   	push   %edi
f0119fab:	53                   	push   %ebx
f0119fac:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119fb2:	83 ec 0c             	sub    $0xc,%esp
f0119fb5:	68 40 ee 12 f0       	push   $0xf012ee40
f0119fba:	e8 ad 6f fe ff       	call   f0100f6c <cprintf>
f0119fbf:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0119fc2:	83 ec 0c             	sub    $0xc,%esp
f0119fc5:	68 70 ee 12 f0       	push   $0xf012ee70
f0119fca:	e8 9d 6f fe ff       	call   f0100f6c <cprintf>
f0119fcf:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0119fd2:	83 ec 0c             	sub    $0xc,%esp
f0119fd5:	68 40 ee 12 f0       	push   $0xf012ee40
f0119fda:	e8 8d 6f fe ff       	call   f0100f6c <cprintf>
f0119fdf:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0119fe2:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f0119fe6:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0119fea:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f0119ff0:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f0119ff6:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0119ffd:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f011a004:	e8 d4 39 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a009:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f011a00c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011a013:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f011a01a:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f011a020:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a025:	b8 00 00 00 00       	mov    $0x0,%eax
f011a02a:	89 d7                	mov    %edx,%edi
f011a02c:	f3 ab                	rep stos %eax,%es:(%edi)
	correct = 1 ;
f011a02e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f011a035:	e8 a3 39 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a03a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a03d:	e8 d3 a7 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a042:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f011a045:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f011a04c:	83 ec 0c             	sub    $0xc,%esp
f011a04f:	ff 75 cc             	pushl  -0x34(%ebp)
f011a052:	e8 34 ea fe ff       	call   f0108a8b <kmalloc>
f011a057:	83 c4 10             	add    $0x10,%esp
f011a05a:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f011a060:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011a066:	85 c0                	test   %eax,%eax
f011a068:	74 17                	je     f011a081 <test_kmalloc+0xda>
f011a06a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a071:	83 ec 0c             	sub    $0xc,%esp
f011a074:	68 cc ee 12 f0       	push   $0xf012eecc
f011a079:	e8 ee 6e fe ff       	call   f0100f6c <cprintf>
f011a07e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a081:	e8 8f a7 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a086:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a089:	74 17                	je     f011a0a2 <test_kmalloc+0xfb>
f011a08b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a092:	83 ec 0c             	sub    $0xc,%esp
f011a095:	68 00 ef 12 f0       	push   $0xf012ef00
f011a09a:	e8 cd 6e fe ff       	call   f0100f6c <cprintf>
f011a09f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a0a2:	e8 36 39 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a0a7:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011a0aa:	74 17                	je     f011a0c3 <test_kmalloc+0x11c>
f011a0ac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a0b3:	83 ec 0c             	sub    $0xc,%esp
f011a0b6:	68 6c ef 12 f0       	push   $0xf012ef6c
f011a0bb:	e8 ac 6e fe ff       	call   f0100f6c <cprintf>
f011a0c0:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a0c3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a0c7:	74 04                	je     f011a0cd <test_kmalloc+0x126>
f011a0c9:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011a0cd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a0d4:	e8 04 39 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a0d9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a0dc:	e8 34 a7 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a0e1:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011a0e4:	83 ec 0c             	sub    $0xc,%esp
f011a0e7:	68 00 fc 1f 00       	push   $0x1ffc00
f011a0ec:	e8 9a e9 fe ff       	call   f0108a8b <kmalloc>
f011a0f1:	83 c4 10             	add    $0x10,%esp
f011a0f4:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a0fa:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011a100:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a105:	74 17                	je     f011a11e <test_kmalloc+0x177>
f011a107:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a10e:	83 ec 0c             	sub    $0xc,%esp
f011a111:	68 b0 ef 12 f0       	push   $0xf012efb0
f011a116:	e8 51 6e fe ff       	call   f0100f6c <cprintf>
f011a11b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a11e:	e8 f2 a6 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a123:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a126:	74 17                	je     f011a13f <test_kmalloc+0x198>
f011a128:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a12f:	83 ec 0c             	sub    $0xc,%esp
f011a132:	68 00 ef 12 f0       	push   $0xf012ef00
f011a137:	e8 30 6e fe ff       	call   f0100f6c <cprintf>
f011a13c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a13f:	e8 99 38 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a144:	89 c2                	mov    %eax,%edx
f011a146:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a149:	29 d0                	sub    %edx,%eax
f011a14b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a150:	7f 17                	jg     f011a169 <test_kmalloc+0x1c2>
f011a152:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a159:	83 ec 0c             	sub    $0xc,%esp
f011a15c:	68 6c ef 12 f0       	push   $0xf012ef6c
f011a161:	e8 06 6e fe ff       	call   f0100f6c <cprintf>
f011a166:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a169:	e8 6f 38 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a16e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a171:	e8 9f a6 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a176:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011a179:	83 ec 0c             	sub    $0xc,%esp
f011a17c:	68 00 fc 1f 00       	push   $0x1ffc00
f011a181:	e8 05 e9 fe ff       	call   f0108a8b <kmalloc>
f011a186:	83 c4 10             	add    $0x10,%esp
f011a189:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a18f:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011a195:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011a19a:	74 17                	je     f011a1b3 <test_kmalloc+0x20c>
f011a19c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a1a3:	83 ec 0c             	sub    $0xc,%esp
f011a1a6:	68 b0 ef 12 f0       	push   $0xf012efb0
f011a1ab:	e8 bc 6d fe ff       	call   f0100f6c <cprintf>
f011a1b0:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a1b3:	e8 5d a6 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a1b8:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a1bb:	74 17                	je     f011a1d4 <test_kmalloc+0x22d>
f011a1bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a1c4:	83 ec 0c             	sub    $0xc,%esp
f011a1c7:	68 00 ef 12 f0       	push   $0xf012ef00
f011a1cc:	e8 9b 6d fe ff       	call   f0100f6c <cprintf>
f011a1d1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a1d4:	e8 04 38 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a1d9:	89 c2                	mov    %eax,%edx
f011a1db:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a1de:	29 d0                	sub    %edx,%eax
f011a1e0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a1e5:	7f 17                	jg     f011a1fe <test_kmalloc+0x257>
f011a1e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a1ee:	83 ec 0c             	sub    $0xc,%esp
f011a1f1:	68 6c ef 12 f0       	push   $0xf012ef6c
f011a1f6:	e8 71 6d fe ff       	call   f0100f6c <cprintf>
f011a1fb:	83 c4 10             	add    $0x10,%esp

		//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f011a1fe:	e8 da 37 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a203:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a206:	e8 0a a6 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a20b:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[2] = kmalloc(2*kilo-1);
f011a20e:	83 ec 0c             	sub    $0xc,%esp
f011a211:	68 ff 07 00 00       	push   $0x7ff
f011a216:	e8 70 e8 fe ff       	call   f0108a8b <kmalloc>
f011a21b:	83 c4 10             	add    $0x10,%esp
f011a21e:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011a224:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011a22a:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a22f:	76 28                	jbe    f011a259 <test_kmalloc+0x2b2>
f011a231:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f011a237:	83 ec 0c             	sub    $0xc,%esp
f011a23a:	6a 00                	push   $0x0
f011a23c:	e8 40 e8 fe ff       	call   f0108a81 <sbrk>
f011a241:	83 c4 10             	add    $0x10,%esp
f011a244:	39 c3                	cmp    %eax,%ebx
f011a246:	73 11                	jae    f011a259 <test_kmalloc+0x2b2>
f011a248:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011a24e:	89 c2                	mov    %eax,%edx
f011a250:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011a255:	39 c2                	cmp    %eax,%edx
f011a257:	72 17                	jb     f011a270 <test_kmalloc+0x2c9>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a259:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a260:	83 ec 0c             	sub    $0xc,%esp
f011a263:	68 00 f0 12 f0       	push   $0xf012f000
f011a268:	e8 ff 6c fe ff       	call   f0100f6c <cprintf>
f011a26d:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a270:	e8 a0 a5 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a275:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a278:	74 17                	je     f011a291 <test_kmalloc+0x2ea>
f011a27a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a281:	83 ec 0c             	sub    $0xc,%esp
f011a284:	68 00 ef 12 f0       	push   $0xf012ef00
f011a289:	e8 de 6c fe ff       	call   f0100f6c <cprintf>
f011a28e:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f011a291:	e8 47 37 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a296:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a299:	e8 77 a5 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a29e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo-1);
f011a2a1:	83 ec 0c             	sub    $0xc,%esp
f011a2a4:	68 ff 07 00 00       	push   $0x7ff
f011a2a9:	e8 dd e7 fe ff       	call   f0108a8b <kmalloc>
f011a2ae:	83 c4 10             	add    $0x10,%esp
f011a2b1:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011a2b7:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011a2bd:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a2c2:	76 28                	jbe    f011a2ec <test_kmalloc+0x345>
f011a2c4:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f011a2ca:	83 ec 0c             	sub    $0xc,%esp
f011a2cd:	6a 00                	push   $0x0
f011a2cf:	e8 ad e7 fe ff       	call   f0108a81 <sbrk>
f011a2d4:	83 c4 10             	add    $0x10,%esp
f011a2d7:	39 c3                	cmp    %eax,%ebx
f011a2d9:	73 11                	jae    f011a2ec <test_kmalloc+0x345>
f011a2db:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011a2e1:	89 c2                	mov    %eax,%edx
f011a2e3:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011a2e8:	39 c2                	cmp    %eax,%edx
f011a2ea:	72 17                	jb     f011a303 <test_kmalloc+0x35c>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a2ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a2f3:	83 ec 0c             	sub    $0xc,%esp
f011a2f6:	68 00 f0 12 f0       	push   $0xf012f000
f011a2fb:	e8 6c 6c fe ff       	call   f0100f6c <cprintf>
f011a300:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a303:	e8 0d a5 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a308:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a30b:	74 17                	je     f011a324 <test_kmalloc+0x37d>
f011a30d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a314:	83 ec 0c             	sub    $0xc,%esp
f011a317:	68 00 ef 12 f0       	push   $0xf012ef00
f011a31c:	e8 4b 6c fe ff       	call   f0100f6c <cprintf>
f011a321:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a324:	e8 b4 36 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a329:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a32c:	e8 e4 a4 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a331:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f011a334:	83 ec 0c             	sub    $0xc,%esp
f011a337:	68 00 1c 00 00       	push   $0x1c00
f011a33c:	e8 4a e7 fe ff       	call   f0108a8b <kmalloc>
f011a341:	83 c4 10             	add    $0x10,%esp
f011a344:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a34a:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011a350:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011a355:	74 17                	je     f011a36e <test_kmalloc+0x3c7>
f011a357:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a35e:	83 ec 0c             	sub    $0xc,%esp
f011a361:	68 b0 ef 12 f0       	push   $0xf012efb0
f011a366:	e8 01 6c fe ff       	call   f0100f6c <cprintf>
f011a36b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a36e:	e8 a2 a4 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a373:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a376:	74 17                	je     f011a38f <test_kmalloc+0x3e8>
f011a378:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a37f:	83 ec 0c             	sub    $0xc,%esp
f011a382:	68 00 ef 12 f0       	push   $0xf012ef00
f011a387:	e8 e0 6b fe ff       	call   f0100f6c <cprintf>
f011a38c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a38f:	e8 49 36 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a394:	89 c2                	mov    %eax,%edx
f011a396:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a399:	29 d0                	sub    %edx,%eax
f011a39b:	83 f8 01             	cmp    $0x1,%eax
f011a39e:	7f 17                	jg     f011a3b7 <test_kmalloc+0x410>
f011a3a0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a3a7:	83 ec 0c             	sub    $0xc,%esp
f011a3aa:	68 6c ef 12 f0       	push   $0xf012ef6c
f011a3af:	e8 b8 6b fe ff       	call   f0100f6c <cprintf>
f011a3b4:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a3b7:	e8 21 36 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a3bc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a3bf:	e8 51 a4 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a3c4:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011a3c7:	83 ec 0c             	sub    $0xc,%esp
f011a3ca:	68 00 fc 2f 00       	push   $0x2ffc00
f011a3cf:	e8 b7 e6 fe ff       	call   f0108a8b <kmalloc>
f011a3d4:	83 c4 10             	add    $0x10,%esp
f011a3d7:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a3dd:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011a3e3:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011a3e8:	74 17                	je     f011a401 <test_kmalloc+0x45a>
f011a3ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a3f1:	83 ec 0c             	sub    $0xc,%esp
f011a3f4:	68 b0 ef 12 f0       	push   $0xf012efb0
f011a3f9:	e8 6e 6b fe ff       	call   f0100f6c <cprintf>
f011a3fe:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a401:	e8 0f a4 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a406:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a409:	74 17                	je     f011a422 <test_kmalloc+0x47b>
f011a40b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a412:	83 ec 0c             	sub    $0xc,%esp
f011a415:	68 00 ef 12 f0       	push   $0xf012ef00
f011a41a:	e8 4d 6b fe ff       	call   f0100f6c <cprintf>
f011a41f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a422:	e8 b6 35 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a427:	89 c2                	mov    %eax,%edx
f011a429:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a42c:	29 d0                	sub    %edx,%eax
f011a42e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a433:	7f 17                	jg     f011a44c <test_kmalloc+0x4a5>
f011a435:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a43c:	83 ec 0c             	sub    $0xc,%esp
f011a43f:	68 6c ef 12 f0       	push   $0xf012ef6c
f011a444:	e8 23 6b fe ff       	call   f0100f6c <cprintf>
f011a449:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a44c:	e8 8c 35 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a451:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a454:	e8 bc a3 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a459:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011a45c:	83 ec 0c             	sub    $0xc,%esp
f011a45f:	68 00 fc 5f 00       	push   $0x5ffc00
f011a464:	e8 22 e6 fe ff       	call   f0108a8b <kmalloc>
f011a469:	83 c4 10             	add    $0x10,%esp
f011a46c:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a472:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011a478:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011a47d:	74 17                	je     f011a496 <test_kmalloc+0x4ef>
f011a47f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a486:	83 ec 0c             	sub    $0xc,%esp
f011a489:	68 b0 ef 12 f0       	push   $0xf012efb0
f011a48e:	e8 d9 6a fe ff       	call   f0100f6c <cprintf>
f011a493:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a496:	e8 7a a3 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a49b:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a49e:	74 17                	je     f011a4b7 <test_kmalloc+0x510>
f011a4a0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a4a7:	83 ec 0c             	sub    $0xc,%esp
f011a4aa:	68 00 ef 12 f0       	push   $0xf012ef00
f011a4af:	e8 b8 6a fe ff       	call   f0100f6c <cprintf>
f011a4b4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a4b7:	e8 21 35 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a4bc:	89 c2                	mov    %eax,%edx
f011a4be:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a4c1:	29 d0                	sub    %edx,%eax
f011a4c3:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a4c8:	7f 17                	jg     f011a4e1 <test_kmalloc+0x53a>
f011a4ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a4d1:	83 ec 0c             	sub    $0xc,%esp
f011a4d4:	68 6c ef 12 f0       	push   $0xf012ef6c
f011a4d9:	e8 8e 6a fe ff       	call   f0100f6c <cprintf>
f011a4de:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a4e1:	e8 f7 34 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a4e6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a4e9:	e8 27 a3 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a4ee:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f011a4f1:	83 ec 0c             	sub    $0xc,%esp
f011a4f4:	68 00 38 00 00       	push   $0x3800
f011a4f9:	e8 8d e5 fe ff       	call   f0108a8b <kmalloc>
f011a4fe:	83 c4 10             	add    $0x10,%esp
f011a501:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a507:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011a50d:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011a512:	74 17                	je     f011a52b <test_kmalloc+0x584>
f011a514:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a51b:	83 ec 0c             	sub    $0xc,%esp
f011a51e:	68 b0 ef 12 f0       	push   $0xf012efb0
f011a523:	e8 44 6a fe ff       	call   f0100f6c <cprintf>
f011a528:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a52b:	e8 e5 a2 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a530:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a533:	74 17                	je     f011a54c <test_kmalloc+0x5a5>
f011a535:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a53c:	83 ec 0c             	sub    $0xc,%esp
f011a53f:	68 00 ef 12 f0       	push   $0xf012ef00
f011a544:	e8 23 6a fe ff       	call   f0100f6c <cprintf>
f011a549:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a54c:	e8 8c 34 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a551:	89 c2                	mov    %eax,%edx
f011a553:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011a556:	29 d0                	sub    %edx,%eax
f011a558:	83 f8 03             	cmp    $0x3,%eax
f011a55b:	7f 17                	jg     f011a574 <test_kmalloc+0x5cd>
f011a55d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a564:	83 ec 0c             	sub    $0xc,%esp
f011a567:	68 6c ef 12 f0       	push   $0xf012ef6c
f011a56c:	e8 fb 69 fe ff       	call   f0100f6c <cprintf>
f011a571:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f011a574:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a578:	74 04                	je     f011a57e <test_kmalloc+0x5d7>
f011a57a:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f011a57e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	{

		freeFrames = (int)sys_calculate_free_frames() ;
f011a585:	e8 53 34 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a58a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a58d:	e8 83 a2 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a592:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f011a595:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f011a59c:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011a5a2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f011a5a5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a5a8:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011a5ab:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f011a5ad:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011a5b0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a5b3:	01 c2                	add    %eax,%edx
f011a5b5:	8a 45 ea             	mov    -0x16(%ebp),%al
f011a5b8:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f011a5ba:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011a5c0:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f011a5c3:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f011a5ca:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011a5cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a5d0:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f011a5d3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a5d6:	01 c0                	add    %eax,%eax
f011a5d8:	89 c2                	mov    %eax,%edx
f011a5da:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a5dd:	01 c2                	add    %eax,%edx
f011a5df:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011a5e3:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f011a5e6:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011a5ec:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f011a5ef:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f011a5f6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011a5f9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011a5fc:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f011a5fe:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011a601:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a608:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011a60b:	01 c2                	add    %eax,%edx
f011a60d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011a610:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f011a612:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011a618:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f011a61b:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f011a622:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011a625:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011a628:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f011a62a:	8b 55 ac             	mov    -0x54(%ebp),%edx
f011a62d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011a630:	01 c2                	add    %eax,%edx
f011a632:	8a 45 ea             	mov    -0x16(%ebp),%al
f011a635:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f011a637:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011a63d:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f011a640:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f011a647:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a64a:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011a64d:	88 10                	mov    %dl,(%eax)
f011a64f:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011a652:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a655:	66 89 42 02          	mov    %ax,0x2(%edx)
f011a659:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a65c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011a65f:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f011a662:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011a665:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011a66c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a66f:	01 c2                	add    %eax,%edx
f011a671:	8a 45 ea             	mov    -0x16(%ebp),%al
f011a674:	88 02                	mov    %al,(%edx)
f011a676:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011a679:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011a680:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a683:	01 c2                	add    %eax,%edx
f011a685:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011a689:	66 89 42 02          	mov    %ax,0x2(%edx)
f011a68d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011a690:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011a697:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a69a:	01 c2                	add    %eax,%edx
f011a69c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011a69f:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f011a6a2:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f011a6a9:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011a6af:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f011a6b2:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011a6b5:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011a6b8:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f011a6ba:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011a6bd:	89 c2                	mov    %eax,%edx
f011a6bf:	c1 ea 1f             	shr    $0x1f,%edx
f011a6c2:	01 d0                	add    %edx,%eax
f011a6c4:	d1 f8                	sar    %eax
f011a6c6:	89 c2                	mov    %eax,%edx
f011a6c8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011a6cb:	01 c2                	add    %eax,%edx
f011a6cd:	8a 45 ea             	mov    -0x16(%ebp),%al
f011a6d0:	88 c1                	mov    %al,%cl
f011a6d2:	c0 e9 07             	shr    $0x7,%cl
f011a6d5:	01 c8                	add    %ecx,%eax
f011a6d7:	d0 f8                	sar    %al
f011a6d9:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f011a6db:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011a6de:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011a6e1:	01 c2                	add    %eax,%edx
f011a6e3:	8a 45 ea             	mov    -0x16(%ebp),%al
f011a6e6:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f011a6e8:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011a6ee:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f011a6f1:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f011a6f8:	8b 55 98             	mov    -0x68(%ebp),%edx
f011a6fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a6fe:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f011a701:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a704:	01 c0                	add    %eax,%eax
f011a706:	89 c2                	mov    %eax,%edx
f011a708:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a70b:	01 c2                	add    %eax,%edx
f011a70d:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011a711:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a714:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a717:	8a 00                	mov    (%eax),%al
f011a719:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011a71c:	75 0f                	jne    f011a72d <test_kmalloc+0x786>
f011a71e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011a721:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a724:	01 d0                	add    %edx,%eax
f011a726:	8a 00                	mov    (%eax),%al
f011a728:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011a72b:	74 17                	je     f011a744 <test_kmalloc+0x79d>
f011a72d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a734:	83 ec 0c             	sub    $0xc,%esp
f011a737:	68 88 f0 12 f0       	push   $0xf012f088
f011a73c:	e8 2b 68 fe ff       	call   f0100f6c <cprintf>
f011a741:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a744:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a747:	66 8b 00             	mov    (%eax),%ax
f011a74a:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f011a74e:	75 15                	jne    f011a765 <test_kmalloc+0x7be>
f011a750:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a753:	01 c0                	add    %eax,%eax
f011a755:	89 c2                	mov    %eax,%edx
f011a757:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a75a:	01 d0                	add    %edx,%eax
f011a75c:	66 8b 00             	mov    (%eax),%ax
f011a75f:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011a763:	74 17                	je     f011a77c <test_kmalloc+0x7d5>
f011a765:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a76c:	83 ec 0c             	sub    $0xc,%esp
f011a76f:	68 88 f0 12 f0       	push   $0xf012f088
f011a774:	e8 f3 67 fe ff       	call   f0100f6c <cprintf>
f011a779:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a77c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011a77f:	8b 00                	mov    (%eax),%eax
f011a781:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011a784:	75 16                	jne    f011a79c <test_kmalloc+0x7f5>
f011a786:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011a789:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a790:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011a793:	01 d0                	add    %edx,%eax
f011a795:	8b 00                	mov    (%eax),%eax
f011a797:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011a79a:	74 17                	je     f011a7b3 <test_kmalloc+0x80c>
f011a79c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a7a3:	83 ec 0c             	sub    $0xc,%esp
f011a7a6:	68 88 f0 12 f0       	push   $0xf012f088
f011a7ab:	e8 bc 67 fe ff       	call   f0100f6c <cprintf>
f011a7b0:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a7b3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011a7b6:	8a 00                	mov    (%eax),%al
f011a7b8:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011a7bb:	75 0f                	jne    f011a7cc <test_kmalloc+0x825>
f011a7bd:	8b 55 ac             	mov    -0x54(%ebp),%edx
f011a7c0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011a7c3:	01 d0                	add    %edx,%eax
f011a7c5:	8a 00                	mov    (%eax),%al
f011a7c7:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011a7ca:	74 17                	je     f011a7e3 <test_kmalloc+0x83c>
f011a7cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a7d3:	83 ec 0c             	sub    $0xc,%esp
f011a7d6:	68 88 f0 12 f0       	push   $0xf012f088
f011a7db:	e8 8c 67 fe ff       	call   f0100f6c <cprintf>
f011a7e0:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a7e3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a7e6:	8a 00                	mov    (%eax),%al
f011a7e8:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011a7eb:	75 16                	jne    f011a803 <test_kmalloc+0x85c>
f011a7ed:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011a7f0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011a7f7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a7fa:	01 d0                	add    %edx,%eax
f011a7fc:	8a 00                	mov    (%eax),%al
f011a7fe:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011a801:	74 17                	je     f011a81a <test_kmalloc+0x873>
f011a803:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a80a:	83 ec 0c             	sub    $0xc,%esp
f011a80d:	68 88 f0 12 f0       	push   $0xf012f088
f011a812:	e8 55 67 fe ff       	call   f0100f6c <cprintf>
f011a817:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a81a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a81d:	66 8b 40 02          	mov    0x2(%eax),%ax
f011a821:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f011a825:	75 19                	jne    f011a840 <test_kmalloc+0x899>
f011a827:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011a82a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011a831:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a834:	01 d0                	add    %edx,%eax
f011a836:	66 8b 40 02          	mov    0x2(%eax),%ax
f011a83a:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011a83e:	74 17                	je     f011a857 <test_kmalloc+0x8b0>
f011a840:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a847:	83 ec 0c             	sub    $0xc,%esp
f011a84a:	68 88 f0 12 f0       	push   $0xf012f088
f011a84f:	e8 18 67 fe ff       	call   f0100f6c <cprintf>
f011a854:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a857:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a85a:	8b 40 04             	mov    0x4(%eax),%eax
f011a85d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011a860:	75 17                	jne    f011a879 <test_kmalloc+0x8d2>
f011a862:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011a865:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011a86c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011a86f:	01 d0                	add    %edx,%eax
f011a871:	8b 40 04             	mov    0x4(%eax),%eax
f011a874:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011a877:	74 17                	je     f011a890 <test_kmalloc+0x8e9>
f011a879:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a880:	83 ec 0c             	sub    $0xc,%esp
f011a883:	68 88 f0 12 f0       	push   $0xf012f088
f011a888:	e8 df 66 fe ff       	call   f0100f6c <cprintf>
f011a88d:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a890:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011a893:	8a 00                	mov    (%eax),%al
f011a895:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011a898:	75 34                	jne    f011a8ce <test_kmalloc+0x927>
f011a89a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011a89d:	89 c2                	mov    %eax,%edx
f011a89f:	c1 ea 1f             	shr    $0x1f,%edx
f011a8a2:	01 d0                	add    %edx,%eax
f011a8a4:	d1 f8                	sar    %eax
f011a8a6:	89 c2                	mov    %eax,%edx
f011a8a8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011a8ab:	01 d0                	add    %edx,%eax
f011a8ad:	8a 10                	mov    (%eax),%dl
f011a8af:	8a 45 ea             	mov    -0x16(%ebp),%al
f011a8b2:	88 c1                	mov    %al,%cl
f011a8b4:	c0 e9 07             	shr    $0x7,%cl
f011a8b7:	01 c8                	add    %ecx,%eax
f011a8b9:	d0 f8                	sar    %al
f011a8bb:	38 c2                	cmp    %al,%dl
f011a8bd:	75 0f                	jne    f011a8ce <test_kmalloc+0x927>
f011a8bf:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011a8c2:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011a8c5:	01 d0                	add    %edx,%eax
f011a8c7:	8a 00                	mov    (%eax),%al
f011a8c9:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011a8cc:	74 17                	je     f011a8e5 <test_kmalloc+0x93e>
f011a8ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a8d5:	83 ec 0c             	sub    $0xc,%esp
f011a8d8:	68 88 f0 12 f0       	push   $0xf012f088
f011a8dd:	e8 8a 66 fe ff       	call   f0100f6c <cprintf>
f011a8e2:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011a8e5:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a8e8:	66 8b 00             	mov    (%eax),%ax
f011a8eb:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f011a8ef:	75 15                	jne    f011a906 <test_kmalloc+0x95f>
f011a8f1:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a8f4:	01 c0                	add    %eax,%eax
f011a8f6:	89 c2                	mov    %eax,%edx
f011a8f8:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a8fb:	01 d0                	add    %edx,%eax
f011a8fd:	66 8b 00             	mov    (%eax),%ax
f011a900:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011a904:	74 17                	je     f011a91d <test_kmalloc+0x976>
f011a906:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a90d:	83 ec 0c             	sub    $0xc,%esp
f011a910:	68 88 f0 12 f0       	push   $0xf012f088
f011a915:	e8 52 66 fe ff       	call   f0100f6c <cprintf>
f011a91a:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a91d:	e8 bb 30 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a922:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011a925:	74 17                	je     f011a93e <test_kmalloc+0x997>
f011a927:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a92e:	83 ec 0c             	sub    $0xc,%esp
f011a931:	68 6c ef 12 f0       	push   $0xf012ef6c
f011a936:	e8 31 66 fe ff       	call   f0100f6c <cprintf>
f011a93b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a93e:	e8 d2 9e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a943:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a946:	74 17                	je     f011a95f <test_kmalloc+0x9b8>
f011a948:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a94f:	83 ec 0c             	sub    $0xc,%esp
f011a952:	68 00 ef 12 f0       	push   $0xf012ef00
f011a957:	e8 10 66 fe ff       	call   f0100f6c <cprintf>
f011a95c:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f011a95f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a963:	74 04                	je     f011a969 <test_kmalloc+0x9c2>
f011a965:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f011a969:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f011a970:	e8 68 30 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a975:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a978:	e8 98 9e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a97d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 2*PAGE_SIZE) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo) ;
f011a980:	c7 45 90 00 a0 2f 07 	movl   $0x72fa000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap);
f011a987:	83 ec 0c             	sub    $0xc,%esp
f011a98a:	ff 75 90             	pushl  -0x70(%ebp)
f011a98d:	e8 f9 e0 fe ff       	call   f0108a8b <kmalloc>
f011a992:	83 c4 10             	add    $0x10,%esp
f011a995:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f011a99b:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011a9a1:	85 c0                	test   %eax,%eax
f011a9a3:	74 17                	je     f011a9bc <test_kmalloc+0xa15>
f011a9a5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a9ac:	83 ec 0c             	sub    $0xc,%esp
f011a9af:	68 cc ee 12 f0       	push   $0xf012eecc
f011a9b4:	e8 b3 65 fe ff       	call   f0100f6c <cprintf>
f011a9b9:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a9bc:	e8 54 9e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011a9c1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a9c4:	74 17                	je     f011a9dd <test_kmalloc+0xa36>
f011a9c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a9cd:	83 ec 0c             	sub    $0xc,%esp
f011a9d0:	68 00 ef 12 f0       	push   $0xf012ef00
f011a9d5:	e8 92 65 fe ff       	call   f0100f6c <cprintf>
f011a9da:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a9dd:	e8 fb 2f ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011a9e2:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011a9e5:	74 17                	je     f011a9fe <test_kmalloc+0xa57>
f011a9e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a9ee:	83 ec 0c             	sub    $0xc,%esp
f011a9f1:	68 6c ef 12 f0       	push   $0xf012ef6c
f011a9f6:	e8 71 65 fe ff       	call   f0100f6c <cprintf>
f011a9fb:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a9fe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011aa02:	74 04                	je     f011aa08 <test_kmalloc+0xa61>
f011aa04:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011aa08:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f011aa0f:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011aa15:	05 00 40 00 00       	add    $0x4000,%eax
f011aa1a:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011aa1d:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f011aa24:	eb 6a                	jmp    f011aa90 <test_kmalloc+0xae9>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f011aa26:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f011aa2b:	83 ec 04             	sub    $0x4,%esp
f011aa2e:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f011aa34:	52                   	push   %edx
f011aa35:	ff 75 ec             	pushl  -0x14(%ebp)
f011aa38:	50                   	push   %eax
f011aa39:	e8 a4 d9 fe ff       	call   f01083e2 <get_page_table>
f011aa3e:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f011aa41:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011aa47:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011aa4a:	c1 ea 0c             	shr    $0xc,%edx
f011aa4d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011aa53:	c1 e2 02             	shl    $0x2,%edx
f011aa56:	01 d0                	add    %edx,%eax
f011aa58:	8b 00                	mov    (%eax),%eax
f011aa5a:	25 ff 0f 00 00       	and    $0xfff,%eax
f011aa5f:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f011aa62:	8b 45 88             	mov    -0x78(%ebp),%eax
f011aa65:	83 e0 04             	and    $0x4,%eax
f011aa68:	85 c0                	test   %eax,%eax
f011aa6a:	74 1d                	je     f011aa89 <test_kmalloc+0xae2>
			{
				if (correct)
f011aa6c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011aa70:	74 17                	je     f011aa89 <test_kmalloc+0xae2>
				{
					correct = 0; cprintf("Wrong permissions: pages should be mapped with Supervisor permission only\n");
f011aa72:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011aa79:	83 ec 0c             	sub    $0xc,%esp
f011aa7c:	68 c0 f0 12 f0       	push   $0xf012f0c0
f011aa81:	e8 e6 64 fe ff       	call   f0100f6c <cprintf>
f011aa86:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//permissions
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011aa89:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f011aa90:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011aa93:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011aa96:	72 8e                	jb     f011aa26 <test_kmalloc+0xa7f>
					correct = 0; cprintf("Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011aa98:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011aa9c:	74 04                	je     f011aaa2 <test_kmalloc+0xafb>
f011aa9e:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f011aaa2:	83 ec 08             	sub    $0x8,%esp
f011aaa5:	ff 75 f4             	pushl  -0xc(%ebp)
f011aaa8:	68 0c f1 12 f0       	push   $0xf012f10c
f011aaad:	e8 ba 64 fe ff       	call   f0100f6c <cprintf>
f011aab2:	83 c4 10             	add    $0x10,%esp

	return 1;
f011aab5:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011aaba:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011aabd:	5b                   	pop    %ebx
f011aabe:	5f                   	pop    %edi
f011aabf:	5d                   	pop    %ebp
f011aac0:	c3                   	ret    

f011aac1 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f011aac1:	55                   	push   %ebp
f011aac2:	89 e5                	mov    %esp,%ebp
f011aac4:	57                   	push   %edi
f011aac5:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011aac8:	83 ec 0c             	sub    $0xc,%esp
f011aacb:	68 40 ee 12 f0       	push   $0xf012ee40
f011aad0:	e8 97 64 fe ff       	call   f0100f6c <cprintf>
f011aad5:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011aad8:	83 ec 0c             	sub    $0xc,%esp
f011aadb:	68 70 ee 12 f0       	push   $0xf012ee70
f011aae0:	e8 87 64 fe ff       	call   f0100f6c <cprintf>
f011aae5:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011aae8:	83 ec 0c             	sub    $0xc,%esp
f011aaeb:	68 40 ee 12 f0       	push   $0xf012ee40
f011aaf0:	e8 77 64 fe ff       	call   f0100f6c <cprintf>
f011aaf5:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f011aaf8:	8d 55 98             	lea    -0x68(%ebp),%edx
f011aafb:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ab00:	b8 00 00 00 00       	mov    $0x0,%eax
f011ab05:	89 d7                	mov    %edx,%edi
f011ab07:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 freeFrames;
	uint32 freeDiskFrames;
	int eval = 0;
f011ab09:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011ab10:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f011ab17:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011ab1e:	e8 ba 2e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ab23:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ab26:	e8 ea 9c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ab2b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f011ab2e:	83 ec 0c             	sub    $0xc,%esp
f011ab31:	68 00 fc 0f 00       	push   $0xffc00
f011ab36:	e8 50 df fe ff       	call   f0108a8b <kmalloc>
f011ab3b:	83 c4 10             	add    $0x10,%esp
f011ab3e:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011ab41:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ab44:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011ab49:	74 17                	je     f011ab62 <test_kmalloc_firstfit1+0xa1>
f011ab4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ab52:	83 ec 0c             	sub    $0xc,%esp
f011ab55:	68 38 f1 12 f0       	push   $0xf012f138
f011ab5a:	e8 0d 64 fe ff       	call   f0100f6c <cprintf>
f011ab5f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab62:	e8 ae 9c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ab67:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ab6a:	74 17                	je     f011ab83 <test_kmalloc_firstfit1+0xc2>
f011ab6c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ab73:	83 ec 0c             	sub    $0xc,%esp
f011ab76:	68 00 ef 12 f0       	push   $0xf012ef00
f011ab7b:	e8 ec 63 fe ff       	call   f0100f6c <cprintf>
f011ab80:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011ab83:	e8 55 2e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ab88:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ab8b:	29 c2                	sub    %eax,%edx
f011ab8d:	89 d0                	mov    %edx,%eax
f011ab8f:	3d ff 00 00 00       	cmp    $0xff,%eax
f011ab94:	77 17                	ja     f011abad <test_kmalloc_firstfit1+0xec>
f011ab96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ab9d:	83 ec 0c             	sub    $0xc,%esp
f011aba0:	68 69 f1 12 f0       	push   $0xf012f169
f011aba5:	e8 c2 63 fe ff       	call   f0100f6c <cprintf>
f011abaa:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011abad:	e8 2b 2e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011abb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011abb5:	e8 5b 9c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011abba:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f011abbd:	83 ec 0c             	sub    $0xc,%esp
f011abc0:	68 00 fc 0f 00       	push   $0xffc00
f011abc5:	e8 c1 de fe ff       	call   f0108a8b <kmalloc>
f011abca:	83 c4 10             	add    $0x10,%esp
f011abcd:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011abd0:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011abd3:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f011abd8:	74 17                	je     f011abf1 <test_kmalloc_firstfit1+0x130>
f011abda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011abe1:	83 ec 0c             	sub    $0xc,%esp
f011abe4:	68 38 f1 12 f0       	push   $0xf012f138
f011abe9:	e8 7e 63 fe ff       	call   f0100f6c <cprintf>
f011abee:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011abf1:	e8 1f 9c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011abf6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011abf9:	74 17                	je     f011ac12 <test_kmalloc_firstfit1+0x151>
f011abfb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ac02:	83 ec 0c             	sub    $0xc,%esp
f011ac05:	68 00 ef 12 f0       	push   $0xf012ef00
f011ac0a:	e8 5d 63 fe ff       	call   f0100f6c <cprintf>
f011ac0f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011ac12:	e8 c6 2d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ac17:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ac1a:	29 c2                	sub    %eax,%edx
f011ac1c:	89 d0                	mov    %edx,%eax
f011ac1e:	3d ff 00 00 00       	cmp    $0xff,%eax
f011ac23:	77 17                	ja     f011ac3c <test_kmalloc_firstfit1+0x17b>
f011ac25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ac2c:	83 ec 0c             	sub    $0xc,%esp
f011ac2f:	68 69 f1 12 f0       	push   $0xf012f169
f011ac34:	e8 33 63 fe ff       	call   f0100f6c <cprintf>
f011ac39:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011ac3c:	e8 9c 2d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ac41:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ac44:	e8 cc 9b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ac49:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f011ac4c:	83 ec 0c             	sub    $0xc,%esp
f011ac4f:	68 00 fc 0f 00       	push   $0xffc00
f011ac54:	e8 32 de fe ff       	call   f0108a8b <kmalloc>
f011ac59:	83 c4 10             	add    $0x10,%esp
f011ac5c:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011ac5f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ac62:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011ac67:	74 17                	je     f011ac80 <test_kmalloc_firstfit1+0x1bf>
f011ac69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ac70:	83 ec 0c             	sub    $0xc,%esp
f011ac73:	68 38 f1 12 f0       	push   $0xf012f138
f011ac78:	e8 ef 62 fe ff       	call   f0100f6c <cprintf>
f011ac7d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ac80:	e8 90 9b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ac85:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ac88:	74 17                	je     f011aca1 <test_kmalloc_firstfit1+0x1e0>
f011ac8a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ac91:	83 ec 0c             	sub    $0xc,%esp
f011ac94:	68 00 ef 12 f0       	push   $0xf012ef00
f011ac99:	e8 ce 62 fe ff       	call   f0100f6c <cprintf>
f011ac9e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011aca1:	e8 37 2d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011aca6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011aca9:	29 c2                	sub    %eax,%edx
f011acab:	89 d0                	mov    %edx,%eax
f011acad:	3d ff 00 00 00       	cmp    $0xff,%eax
f011acb2:	77 17                	ja     f011accb <test_kmalloc_firstfit1+0x20a>
f011acb4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011acbb:	83 ec 0c             	sub    $0xc,%esp
f011acbe:	68 69 f1 12 f0       	push   $0xf012f169
f011acc3:	e8 a4 62 fe ff       	call   f0100f6c <cprintf>
f011acc8:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011accb:	e8 0d 2d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011acd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011acd3:	e8 3d 9b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011acd8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f011acdb:	83 ec 0c             	sub    $0xc,%esp
f011acde:	68 00 fc 0f 00       	push   $0xffc00
f011ace3:	e8 a3 dd fe ff       	call   f0108a8b <kmalloc>
f011ace8:	83 c4 10             	add    $0x10,%esp
f011aceb:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011acee:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011acf1:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011acf6:	74 17                	je     f011ad0f <test_kmalloc_firstfit1+0x24e>
f011acf8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011acff:	83 ec 0c             	sub    $0xc,%esp
f011ad02:	68 38 f1 12 f0       	push   $0xf012f138
f011ad07:	e8 60 62 fe ff       	call   f0100f6c <cprintf>
f011ad0c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ad0f:	e8 01 9b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ad14:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ad17:	74 17                	je     f011ad30 <test_kmalloc_firstfit1+0x26f>
f011ad19:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ad20:	83 ec 0c             	sub    $0xc,%esp
f011ad23:	68 00 ef 12 f0       	push   $0xf012ef00
f011ad28:	e8 3f 62 fe ff       	call   f0100f6c <cprintf>
f011ad2d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011ad30:	e8 a8 2c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ad35:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ad38:	29 c2                	sub    %eax,%edx
f011ad3a:	89 d0                	mov    %edx,%eax
f011ad3c:	3d ff 00 00 00       	cmp    $0xff,%eax
f011ad41:	77 17                	ja     f011ad5a <test_kmalloc_firstfit1+0x299>
f011ad43:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ad4a:	83 ec 0c             	sub    $0xc,%esp
f011ad4d:	68 69 f1 12 f0       	push   $0xf012f169
f011ad52:	e8 15 62 fe ff       	call   f0100f6c <cprintf>
f011ad57:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011ad5a:	e8 7e 2c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ad5f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ad62:	e8 ae 9a fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ad67:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f011ad6a:	83 ec 0c             	sub    $0xc,%esp
f011ad6d:	68 00 fc 1f 00       	push   $0x1ffc00
f011ad72:	e8 14 dd fe ff       	call   f0108a8b <kmalloc>
f011ad77:	83 c4 10             	add    $0x10,%esp
f011ad7a:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011ad7d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011ad80:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011ad85:	74 17                	je     f011ad9e <test_kmalloc_firstfit1+0x2dd>
f011ad87:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ad8e:	83 ec 0c             	sub    $0xc,%esp
f011ad91:	68 38 f1 12 f0       	push   $0xf012f138
f011ad96:	e8 d1 61 fe ff       	call   f0100f6c <cprintf>
f011ad9b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ad9e:	e8 72 9a fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ada3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ada6:	74 17                	je     f011adbf <test_kmalloc_firstfit1+0x2fe>
f011ada8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011adaf:	83 ec 0c             	sub    $0xc,%esp
f011adb2:	68 00 ef 12 f0       	push   $0xf012ef00
f011adb7:	e8 b0 61 fe ff       	call   f0100f6c <cprintf>
f011adbc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011adbf:	e8 19 2c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011adc4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011adc7:	29 c2                	sub    %eax,%edx
f011adc9:	89 d0                	mov    %edx,%eax
f011adcb:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011add0:	77 17                	ja     f011ade9 <test_kmalloc_firstfit1+0x328>
f011add2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011add9:	83 ec 0c             	sub    $0xc,%esp
f011addc:	68 69 f1 12 f0       	push   $0xf012f169
f011ade1:	e8 86 61 fe ff       	call   f0100f6c <cprintf>
f011ade6:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011ade9:	e8 ef 2b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011adee:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011adf1:	e8 1f 9a fe ff       	call   f0104815 <pf_calculate_free_frames>
f011adf6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f011adf9:	83 ec 0c             	sub    $0xc,%esp
f011adfc:	68 00 fc 1f 00       	push   $0x1ffc00
f011ae01:	e8 85 dc fe ff       	call   f0108a8b <kmalloc>
f011ae06:	83 c4 10             	add    $0x10,%esp
f011ae09:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011ae0c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011ae0f:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f011ae14:	74 17                	je     f011ae2d <test_kmalloc_firstfit1+0x36c>
f011ae16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ae1d:	83 ec 0c             	sub    $0xc,%esp
f011ae20:	68 38 f1 12 f0       	push   $0xf012f138
f011ae25:	e8 42 61 fe ff       	call   f0100f6c <cprintf>
f011ae2a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae2d:	e8 e3 99 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ae32:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ae35:	74 17                	je     f011ae4e <test_kmalloc_firstfit1+0x38d>
f011ae37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ae3e:	83 ec 0c             	sub    $0xc,%esp
f011ae41:	68 00 ef 12 f0       	push   $0xf012ef00
f011ae46:	e8 21 61 fe ff       	call   f0100f6c <cprintf>
f011ae4b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011ae4e:	e8 8a 2b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ae53:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ae56:	29 c2                	sub    %eax,%edx
f011ae58:	89 d0                	mov    %edx,%eax
f011ae5a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ae5f:	77 17                	ja     f011ae78 <test_kmalloc_firstfit1+0x3b7>
f011ae61:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ae68:	83 ec 0c             	sub    $0xc,%esp
f011ae6b:	68 69 f1 12 f0       	push   $0xf012f169
f011ae70:	e8 f7 60 fe ff       	call   f0100f6c <cprintf>
f011ae75:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011ae78:	e8 60 2b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ae7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ae80:	e8 90 99 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ae85:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011ae88:	83 ec 0c             	sub    $0xc,%esp
f011ae8b:	68 00 fc 2f 00       	push   $0x2ffc00
f011ae90:	e8 f6 db fe ff       	call   f0108a8b <kmalloc>
f011ae95:	83 c4 10             	add    $0x10,%esp
f011ae98:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011ae9b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011ae9e:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f011aea3:	74 17                	je     f011aebc <test_kmalloc_firstfit1+0x3fb>
f011aea5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011aeac:	83 ec 0c             	sub    $0xc,%esp
f011aeaf:	68 38 f1 12 f0       	push   $0xf012f138
f011aeb4:	e8 b3 60 fe ff       	call   f0100f6c <cprintf>
f011aeb9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aebc:	e8 54 99 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011aec1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011aec4:	74 17                	je     f011aedd <test_kmalloc_firstfit1+0x41c>
f011aec6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011aecd:	83 ec 0c             	sub    $0xc,%esp
f011aed0:	68 00 ef 12 f0       	push   $0xf012ef00
f011aed5:	e8 92 60 fe ff       	call   f0100f6c <cprintf>
f011aeda:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: \n"); }
f011aedd:	e8 fb 2a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011aee2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011aee5:	29 c2                	sub    %eax,%edx
f011aee7:	89 d0                	mov    %edx,%eax
f011aee9:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011aeee:	77 17                	ja     f011af07 <test_kmalloc_firstfit1+0x446>
f011aef0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011aef7:	83 ec 0c             	sub    $0xc,%esp
f011aefa:	68 69 f1 12 f0       	push   $0xf012f169
f011aeff:	e8 68 60 fe ff       	call   f0100f6c <cprintf>
f011af04:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011af07:	e8 d1 2a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011af0c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011af0f:	e8 01 99 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011af14:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f011af17:	83 ec 0c             	sub    $0xc,%esp
f011af1a:	68 00 fc 2f 00       	push   $0x2ffc00
f011af1f:	e8 67 db fe ff       	call   f0108a8b <kmalloc>
f011af24:	83 c4 10             	add    $0x10,%esp
f011af27:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011af2a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011af2d:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f011af32:	74 17                	je     f011af4b <test_kmalloc_firstfit1+0x48a>
f011af34:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011af3b:	83 ec 0c             	sub    $0xc,%esp
f011af3e:	68 38 f1 12 f0       	push   $0xf012f138
f011af43:	e8 24 60 fe ff       	call   f0100f6c <cprintf>
f011af48:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af4b:	e8 c5 98 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011af50:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011af53:	74 17                	je     f011af6c <test_kmalloc_firstfit1+0x4ab>
f011af55:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011af5c:	83 ec 0c             	sub    $0xc,%esp
f011af5f:	68 00 ef 12 f0       	push   $0xf012ef00
f011af64:	e8 03 60 fe ff       	call   f0100f6c <cprintf>
f011af69:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: \n"); }
f011af6c:	e8 6c 2a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011af71:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011af74:	29 c2                	sub    %eax,%edx
f011af76:	89 d0                	mov    %edx,%eax
f011af78:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011af7d:	77 17                	ja     f011af96 <test_kmalloc_firstfit1+0x4d5>
f011af7f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011af86:	83 ec 0c             	sub    $0xc,%esp
f011af89:	68 69 f1 12 f0       	push   $0xf012f169
f011af8e:	e8 d9 5f fe ff       	call   f0100f6c <cprintf>
f011af93:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011af96:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011af9a:	74 04                	je     f011afa0 <test_kmalloc_firstfit1+0x4df>
f011af9c:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011afa0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011afa7:	e8 31 2a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011afac:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011afaf:	e8 61 98 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011afb4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f011afb7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011afba:	83 ec 0c             	sub    $0xc,%esp
f011afbd:	50                   	push   %eax
f011afbe:	e8 e2 da fe ff       	call   f0108aa5 <kfree>
f011afc3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011afc6:	e8 4a 98 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011afcb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011afce:	74 17                	je     f011afe7 <test_kmalloc_firstfit1+0x526>
f011afd0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011afd7:	83 ec 0c             	sub    $0xc,%esp
f011afda:	68 00 ef 12 f0       	push   $0xf012ef00
f011afdf:	e8 88 5f fe ff       	call   f0100f6c <cprintf>
f011afe4:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f011afe7:	e8 f1 29 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011afec:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011afef:	3d ff 00 00 00       	cmp    $0xff,%eax
f011aff4:	77 17                	ja     f011b00d <test_kmalloc_firstfit1+0x54c>
f011aff6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011affd:	83 ec 0c             	sub    $0xc,%esp
f011b000:	68 7d f1 12 f0       	push   $0xf012f17d
f011b005:	e8 62 5f fe ff       	call   f0100f6c <cprintf>
f011b00a:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b00d:	e8 cb 29 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b012:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b015:	e8 fb 97 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b01a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f011b01d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011b020:	83 ec 0c             	sub    $0xc,%esp
f011b023:	50                   	push   %eax
f011b024:	e8 7c da fe ff       	call   f0108aa5 <kfree>
f011b029:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b02c:	e8 e4 97 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b031:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b034:	74 17                	je     f011b04d <test_kmalloc_firstfit1+0x58c>
f011b036:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b03d:	83 ec 0c             	sub    $0xc,%esp
f011b040:	68 00 ef 12 f0       	push   $0xf012ef00
f011b045:	e8 22 5f fe ff       	call   f0100f6c <cprintf>
f011b04a:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f011b04d:	e8 8b 29 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b052:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011b055:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b05a:	77 17                	ja     f011b073 <test_kmalloc_firstfit1+0x5b2>
f011b05c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b063:	83 ec 0c             	sub    $0xc,%esp
f011b066:	68 7d f1 12 f0       	push   $0xf012f17d
f011b06b:	e8 fc 5e fe ff       	call   f0100f6c <cprintf>
f011b070:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b073:	e8 65 29 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b078:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b07b:	e8 95 97 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b080:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f011b083:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011b086:	83 ec 0c             	sub    $0xc,%esp
f011b089:	50                   	push   %eax
f011b08a:	e8 16 da fe ff       	call   f0108aa5 <kfree>
f011b08f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b092:	e8 7e 97 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b097:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b09a:	74 17                	je     f011b0b3 <test_kmalloc_firstfit1+0x5f2>
f011b09c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b0a3:	83 ec 0c             	sub    $0xc,%esp
f011b0a6:	68 00 ef 12 f0       	push   $0xf012ef00
f011b0ab:	e8 bc 5e fe ff       	call   f0100f6c <cprintf>
f011b0b0:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("Wrong free: \n"); }
f011b0b3:	e8 25 29 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b0b8:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011b0bb:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b0c0:	77 17                	ja     f011b0d9 <test_kmalloc_firstfit1+0x618>
f011b0c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b0c9:	83 ec 0c             	sub    $0xc,%esp
f011b0cc:	68 7d f1 12 f0       	push   $0xf012f17d
f011b0d1:	e8 96 5e fe ff       	call   f0100f6c <cprintf>
f011b0d6:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011b0d9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b0dd:	74 04                	je     f011b0e3 <test_kmalloc_firstfit1+0x622>
f011b0df:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011b0e3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b0ea:	e8 ee 28 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b0ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b0f2:	e8 1e 97 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b0f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f011b0fa:	83 ec 0c             	sub    $0xc,%esp
f011b0fd:	68 00 fc 07 00       	push   $0x7fc00
f011b102:	e8 84 d9 fe ff       	call   f0108a8b <kmalloc>
f011b107:	83 c4 10             	add    $0x10,%esp
f011b10a:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b10d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011b110:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f011b115:	74 17                	je     f011b12e <test_kmalloc_firstfit1+0x66d>
f011b117:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b11e:	83 ec 0c             	sub    $0xc,%esp
f011b121:	68 38 f1 12 f0       	push   $0xf012f138
f011b126:	e8 41 5e fe ff       	call   f0100f6c <cprintf>
f011b12b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b12e:	e8 e2 96 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b133:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b136:	74 17                	je     f011b14f <test_kmalloc_firstfit1+0x68e>
f011b138:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b13f:	83 ec 0c             	sub    $0xc,%esp
f011b142:	68 00 ef 12 f0       	push   $0xf012ef00
f011b147:	e8 20 5e fe ff       	call   f0100f6c <cprintf>
f011b14c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b14f:	e8 89 28 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b154:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b157:	29 c2                	sub    %eax,%edx
f011b159:	89 d0                	mov    %edx,%eax
f011b15b:	83 f8 7f             	cmp    $0x7f,%eax
f011b15e:	77 17                	ja     f011b177 <test_kmalloc_firstfit1+0x6b6>
f011b160:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b167:	83 ec 0c             	sub    $0xc,%esp
f011b16a:	68 69 f1 12 f0       	push   $0xf012f169
f011b16f:	e8 f8 5d fe ff       	call   f0100f6c <cprintf>
f011b174:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b177:	e8 61 28 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b17c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b17f:	e8 91 96 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b184:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f011b187:	83 ec 0c             	sub    $0xc,%esp
f011b18a:	68 00 fc 0f 00       	push   $0xffc00
f011b18f:	e8 f7 d8 fe ff       	call   f0108a8b <kmalloc>
f011b194:	83 c4 10             	add    $0x10,%esp
f011b197:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b19a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011b19d:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b1a2:	74 17                	je     f011b1bb <test_kmalloc_firstfit1+0x6fa>
f011b1a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b1ab:	83 ec 0c             	sub    $0xc,%esp
f011b1ae:	68 38 f1 12 f0       	push   $0xf012f138
f011b1b3:	e8 b4 5d fe ff       	call   f0100f6c <cprintf>
f011b1b8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b1bb:	e8 55 96 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b1c0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b1c3:	74 17                	je     f011b1dc <test_kmalloc_firstfit1+0x71b>
f011b1c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b1cc:	83 ec 0c             	sub    $0xc,%esp
f011b1cf:	68 00 ef 12 f0       	push   $0xf012ef00
f011b1d4:	e8 93 5d fe ff       	call   f0100f6c <cprintf>
f011b1d9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b1dc:	e8 fc 27 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b1e1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b1e4:	29 c2                	sub    %eax,%edx
f011b1e6:	89 d0                	mov    %edx,%eax
f011b1e8:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b1ed:	77 17                	ja     f011b206 <test_kmalloc_firstfit1+0x745>
f011b1ef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b1f6:	83 ec 0c             	sub    $0xc,%esp
f011b1f9:	68 69 f1 12 f0       	push   $0xf012f169
f011b1fe:	e8 69 5d fe ff       	call   f0100f6c <cprintf>
f011b203:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b206:	e8 d2 27 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b20b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b20e:	e8 02 96 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b213:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f011b216:	83 ec 0c             	sub    $0xc,%esp
f011b219:	68 00 fc 03 00       	push   $0x3fc00
f011b21e:	e8 68 d8 fe ff       	call   f0108a8b <kmalloc>
f011b223:	83 c4 10             	add    $0x10,%esp
f011b226:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b229:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b22c:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f011b231:	74 17                	je     f011b24a <test_kmalloc_firstfit1+0x789>
f011b233:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b23a:	83 ec 0c             	sub    $0xc,%esp
f011b23d:	68 38 f1 12 f0       	push   $0xf012f138
f011b242:	e8 25 5d fe ff       	call   f0100f6c <cprintf>
f011b247:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b24a:	e8 c6 95 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b24f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b252:	74 17                	je     f011b26b <test_kmalloc_firstfit1+0x7aa>
f011b254:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b25b:	83 ec 0c             	sub    $0xc,%esp
f011b25e:	68 00 ef 12 f0       	push   $0xf012ef00
f011b263:	e8 04 5d fe ff       	call   f0100f6c <cprintf>
f011b268:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b26b:	e8 6d 27 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b270:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b273:	29 c2                	sub    %eax,%edx
f011b275:	89 d0                	mov    %edx,%eax
f011b277:	83 f8 3f             	cmp    $0x3f,%eax
f011b27a:	77 17                	ja     f011b293 <test_kmalloc_firstfit1+0x7d2>
f011b27c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b283:	83 ec 0c             	sub    $0xc,%esp
f011b286:	68 69 f1 12 f0       	push   $0xf012f169
f011b28b:	e8 dc 5c fe ff       	call   f0100f6c <cprintf>
f011b290:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b293:	e8 45 27 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b298:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b29b:	e8 75 95 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b2a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f011b2a3:	83 ec 0c             	sub    $0xc,%esp
f011b2a6:	68 00 00 20 00       	push   $0x200000
f011b2ab:	e8 db d7 fe ff       	call   f0108a8b <kmalloc>
f011b2b0:	83 c4 10             	add    $0x10,%esp
f011b2b3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b2b6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b2b9:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f011b2be:	74 17                	je     f011b2d7 <test_kmalloc_firstfit1+0x816>
f011b2c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b2c7:	83 ec 0c             	sub    $0xc,%esp
f011b2ca:	68 38 f1 12 f0       	push   $0xf012f138
f011b2cf:	e8 98 5c fe ff       	call   f0100f6c <cprintf>
f011b2d4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b2d7:	e8 01 27 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b2dc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b2df:	29 c2                	sub    %eax,%edx
f011b2e1:	89 d0                	mov    %edx,%eax
f011b2e3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b2e8:	77 17                	ja     f011b301 <test_kmalloc_firstfit1+0x840>
f011b2ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b2f1:	83 ec 0c             	sub    $0xc,%esp
f011b2f4:	68 69 f1 12 f0       	push   $0xf012f169
f011b2f9:	e8 6e 5c fe ff       	call   f0100f6c <cprintf>
f011b2fe:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b301:	e8 0f 95 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b306:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b309:	74 17                	je     f011b322 <test_kmalloc_firstfit1+0x861>
f011b30b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b312:	83 ec 0c             	sub    $0xc,%esp
f011b315:	68 00 ef 12 f0       	push   $0xf012ef00
f011b31a:	e8 4d 5c fe ff       	call   f0100f6c <cprintf>
f011b31f:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f011b322:	e8 b6 26 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b327:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b32a:	e8 e6 94 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b32f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f011b332:	83 ec 0c             	sub    $0xc,%esp
f011b335:	68 00 fc 3f 00       	push   $0x3ffc00
f011b33a:	e8 4c d7 fe ff       	call   f0108a8b <kmalloc>
f011b33f:	83 c4 10             	add    $0x10,%esp
f011b342:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b345:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b348:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f011b34d:	74 17                	je     f011b366 <test_kmalloc_firstfit1+0x8a5>
f011b34f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b356:	83 ec 0c             	sub    $0xc,%esp
f011b359:	68 38 f1 12 f0       	push   $0xf012f138
f011b35e:	e8 09 5c fe ff       	call   f0100f6c <cprintf>
f011b363:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b366:	e8 aa 94 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b36b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b36e:	74 17                	je     f011b387 <test_kmalloc_firstfit1+0x8c6>
f011b370:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b377:	83 ec 0c             	sub    $0xc,%esp
f011b37a:	68 00 ef 12 f0       	push   $0xf012ef00
f011b37f:	e8 e8 5b fe ff       	call   f0100f6c <cprintf>
f011b384:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b387:	e8 51 26 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b38c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b38f:	29 c2                	sub    %eax,%edx
f011b391:	89 d0                	mov    %edx,%eax
f011b393:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f011b398:	77 17                	ja     f011b3b1 <test_kmalloc_firstfit1+0x8f0>
f011b39a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b3a1:	83 ec 0c             	sub    $0xc,%esp
f011b3a4:	68 69 f1 12 f0       	push   $0xf012f169
f011b3a9:	e8 be 5b fe ff       	call   f0100f6c <cprintf>
f011b3ae:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f011b3b1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b3b5:	74 04                	je     f011b3bb <test_kmalloc_firstfit1+0x8fa>
f011b3b7:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f011b3bb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b3c2:	e8 16 26 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b3c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b3ca:	e8 46 94 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b3cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f011b3d2:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b3d5:	83 ec 0c             	sub    $0xc,%esp
f011b3d8:	50                   	push   %eax
f011b3d9:	e8 c7 d6 fe ff       	call   f0108aa5 <kfree>
f011b3de:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b3e1:	e8 2f 94 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b3e6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b3e9:	74 17                	je     f011b402 <test_kmalloc_firstfit1+0x941>
f011b3eb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b3f2:	83 ec 0c             	sub    $0xc,%esp
f011b3f5:	68 00 ef 12 f0       	push   $0xf012ef00
f011b3fa:	e8 6d 5b fe ff       	call   f0100f6c <cprintf>
f011b3ff:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f011b402:	e8 d6 25 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b407:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011b40a:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b40f:	77 17                	ja     f011b428 <test_kmalloc_firstfit1+0x967>
f011b411:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b418:	83 ec 0c             	sub    $0xc,%esp
f011b41b:	68 7d f1 12 f0       	push   $0xf012f17d
f011b420:	e8 47 5b fe ff       	call   f0100f6c <cprintf>
f011b425:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f011b428:	e8 b0 25 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b42d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b430:	e8 e0 93 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b435:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f011b438:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011b43b:	83 ec 0c             	sub    $0xc,%esp
f011b43e:	50                   	push   %eax
f011b43f:	e8 61 d6 fe ff       	call   f0108aa5 <kfree>
f011b444:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b447:	e8 c9 93 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b44c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b44f:	74 17                	je     f011b468 <test_kmalloc_firstfit1+0x9a7>
f011b451:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b458:	83 ec 0c             	sub    $0xc,%esp
f011b45b:	68 00 ef 12 f0       	push   $0xf012ef00
f011b460:	e8 07 5b fe ff       	call   f0100f6c <cprintf>
f011b465:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f011b468:	e8 70 25 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b46d:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011b470:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b475:	77 17                	ja     f011b48e <test_kmalloc_firstfit1+0x9cd>
f011b477:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b47e:	83 ec 0c             	sub    $0xc,%esp
f011b481:	68 7d f1 12 f0       	push   $0xf012f17d
f011b486:	e8 e1 5a fe ff       	call   f0100f6c <cprintf>
f011b48b:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011b48e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b492:	74 04                	je     f011b498 <test_kmalloc_firstfit1+0x9d7>
f011b494:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011b498:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b49f:	e8 39 25 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b4a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b4a7:	e8 69 93 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b4ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f011b4af:	83 ec 0c             	sub    $0xc,%esp
f011b4b2:	68 00 00 10 00       	push   $0x100000
f011b4b7:	e8 cf d5 fe ff       	call   f0108a8b <kmalloc>
f011b4bc:	83 c4 10             	add    $0x10,%esp
f011b4bf:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b4c2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011b4c5:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f011b4ca:	74 17                	je     f011b4e3 <test_kmalloc_firstfit1+0xa22>
f011b4cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b4d3:	83 ec 0c             	sub    $0xc,%esp
f011b4d6:	68 38 f1 12 f0       	push   $0xf012f138
f011b4db:	e8 8c 5a fe ff       	call   f0100f6c <cprintf>
f011b4e0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b4e3:	e8 2d 93 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b4e8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b4eb:	74 17                	je     f011b504 <test_kmalloc_firstfit1+0xa43>
f011b4ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b4f4:	83 ec 0c             	sub    $0xc,%esp
f011b4f7:	68 00 ef 12 f0       	push   $0xf012ef00
f011b4fc:	e8 6b 5a fe ff       	call   f0100f6c <cprintf>
f011b501:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b504:	e8 d4 24 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b509:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b50c:	29 c2                	sub    %eax,%edx
f011b50e:	89 d0                	mov    %edx,%eax
f011b510:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b515:	77 17                	ja     f011b52e <test_kmalloc_firstfit1+0xa6d>
f011b517:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b51e:	83 ec 0c             	sub    $0xc,%esp
f011b521:	68 69 f1 12 f0       	push   $0xf012f169
f011b526:	e8 41 5a fe ff       	call   f0100f6c <cprintf>
f011b52b:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f011b52e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b532:	74 04                	je     f011b538 <test_kmalloc_firstfit1+0xa77>
f011b534:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f011b538:	83 ec 08             	sub    $0x8,%esp
f011b53b:	ff 75 f4             	pushl  -0xc(%ebp)
f011b53e:	68 8c f1 12 f0       	push   $0xf012f18c
f011b543:	e8 24 5a fe ff       	call   f0100f6c <cprintf>
f011b548:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b54b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011b550:	8b 7d fc             	mov    -0x4(%ebp),%edi
f011b553:	c9                   	leave  
f011b554:	c3                   	ret    

f011b555 <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f011b555:	55                   	push   %ebp
f011b556:	89 e5                	mov    %esp,%ebp
f011b558:	57                   	push   %edi
f011b559:	53                   	push   %ebx
f011b55a:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011b55d:	83 ec 0c             	sub    $0xc,%esp
f011b560:	68 40 ee 12 f0       	push   $0xf012ee40
f011b565:	e8 02 5a fe ff       	call   f0100f6c <cprintf>
f011b56a:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011b56d:	83 ec 0c             	sub    $0xc,%esp
f011b570:	68 70 ee 12 f0       	push   $0xf012ee70
f011b575:	e8 f2 59 fe ff       	call   f0100f6c <cprintf>
f011b57a:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011b57d:	83 ec 0c             	sub    $0xc,%esp
f011b580:	68 40 ee 12 f0       	push   $0xf012ee40
f011b585:	e8 e2 59 fe ff       	call   f0100f6c <cprintf>
f011b58a:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f011b58d:	8d 55 98             	lea    -0x68(%ebp),%edx
f011b590:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b595:	b8 00 00 00 00       	mov    $0x0,%eax
f011b59a:	89 d7                	mov    %edx,%edi
f011b59c:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 freeFrames;
	uint32 freeDiskFrames;
	int eval = 0;
f011b59e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011b5a5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f011b5ac:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f011b5b3:	83 ec 0c             	sub    $0xc,%esp
f011b5b6:	68 01 e0 ff 07       	push   $0x7ffe001
f011b5bb:	e8 cb d4 fe ff       	call   f0108a8b <kmalloc>
f011b5c0:	83 c4 10             	add    $0x10,%esp
f011b5c3:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f011b5c6:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b5c9:	85 c0                	test   %eax,%eax
f011b5cb:	74 17                	je     f011b5e4 <test_kmalloc_firstfit2+0x8f>
f011b5cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b5d4:	83 ec 0c             	sub    $0xc,%esp
f011b5d7:	68 c4 f1 12 f0       	push   $0xf012f1c4
f011b5dc:	e8 8b 59 fe ff       	call   f0100f6c <cprintf>
f011b5e1:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011b5e4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011b5e8:	74 04                	je     f011b5ee <test_kmalloc_firstfit2+0x99>
f011b5ea:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011b5ee:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011b5f5:	e8 e3 23 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b5fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b5fd:	e8 13 92 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b602:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011b605:	83 ec 0c             	sub    $0xc,%esp
f011b608:	68 00 fc 1f 00       	push   $0x1ffc00
f011b60d:	e8 79 d4 fe ff       	call   f0108a8b <kmalloc>
f011b612:	83 c4 10             	add    $0x10,%esp
f011b615:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b618:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b61b:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b620:	74 17                	je     f011b639 <test_kmalloc_firstfit2+0xe4>
f011b622:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b629:	83 ec 0c             	sub    $0xc,%esp
f011b62c:	68 38 f1 12 f0       	push   $0xf012f138
f011b631:	e8 36 59 fe ff       	call   f0100f6c <cprintf>
f011b636:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b639:	e8 d7 91 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b63e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b641:	74 17                	je     f011b65a <test_kmalloc_firstfit2+0x105>
f011b643:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b64a:	83 ec 0c             	sub    $0xc,%esp
f011b64d:	68 00 ef 12 f0       	push   $0xf012ef00
f011b652:	e8 15 59 fe ff       	call   f0100f6c <cprintf>
f011b657:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b65a:	e8 7e 23 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b65f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b662:	29 c2                	sub    %eax,%edx
f011b664:	89 d0                	mov    %edx,%eax
f011b666:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b66b:	77 17                	ja     f011b684 <test_kmalloc_firstfit2+0x12f>
f011b66d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b674:	83 ec 0c             	sub    $0xc,%esp
f011b677:	68 69 f1 12 f0       	push   $0xf012f169
f011b67c:	e8 eb 58 fe ff       	call   f0100f6c <cprintf>
f011b681:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011b684:	e8 54 23 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b689:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b68c:	e8 84 91 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b691:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011b694:	83 ec 0c             	sub    $0xc,%esp
f011b697:	68 00 fc 1f 00       	push   $0x1ffc00
f011b69c:	e8 ea d3 fe ff       	call   f0108a8b <kmalloc>
f011b6a1:	83 c4 10             	add    $0x10,%esp
f011b6a4:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b6a7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011b6aa:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011b6af:	74 17                	je     f011b6c8 <test_kmalloc_firstfit2+0x173>
f011b6b1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b6b8:	83 ec 0c             	sub    $0xc,%esp
f011b6bb:	68 38 f1 12 f0       	push   $0xf012f138
f011b6c0:	e8 a7 58 fe ff       	call   f0100f6c <cprintf>
f011b6c5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b6c8:	e8 48 91 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b6cd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b6d0:	74 17                	je     f011b6e9 <test_kmalloc_firstfit2+0x194>
f011b6d2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b6d9:	83 ec 0c             	sub    $0xc,%esp
f011b6dc:	68 00 ef 12 f0       	push   $0xf012ef00
f011b6e1:	e8 86 58 fe ff       	call   f0100f6c <cprintf>
f011b6e6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b6e9:	e8 ef 22 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b6ee:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b6f1:	29 c2                	sub    %eax,%edx
f011b6f3:	89 d0                	mov    %edx,%eax
f011b6f5:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b6fa:	77 17                	ja     f011b713 <test_kmalloc_firstfit2+0x1be>
f011b6fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b703:	83 ec 0c             	sub    $0xc,%esp
f011b706:	68 69 f1 12 f0       	push   $0xf012f169
f011b70b:	e8 5c 58 fe ff       	call   f0100f6c <cprintf>
f011b710:	83 c4 10             	add    $0x10,%esp

		//1 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b713:	e8 c5 22 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b718:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b71b:	e8 f5 90 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b720:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*kilo);
f011b723:	83 ec 0c             	sub    $0xc,%esp
f011b726:	68 00 04 00 00       	push   $0x400
f011b72b:	e8 5b d3 fe ff       	call   f0108a8b <kmalloc>
f011b730:	83 c4 10             	add    $0x10,%esp
f011b733:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011b736:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b739:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b73e:	76 22                	jbe    f011b762 <test_kmalloc_firstfit2+0x20d>
f011b740:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f011b743:	83 ec 0c             	sub    $0xc,%esp
f011b746:	6a 00                	push   $0x0
f011b748:	e8 34 d3 fe ff       	call   f0108a81 <sbrk>
f011b74d:	83 c4 10             	add    $0x10,%esp
f011b750:	39 c3                	cmp    %eax,%ebx
f011b752:	73 0e                	jae    f011b762 <test_kmalloc_firstfit2+0x20d>
f011b754:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b757:	89 c2                	mov    %eax,%edx
f011b759:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011b75e:	39 c2                	cmp    %eax,%edx
f011b760:	72 17                	jb     f011b779 <test_kmalloc_firstfit2+0x224>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b762:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b769:	83 ec 0c             	sub    $0xc,%esp
f011b76c:	68 00 f0 12 f0       	push   $0xf012f000
f011b771:	e8 f6 57 fe ff       	call   f0100f6c <cprintf>
f011b776:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b779:	e8 97 90 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b77e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b781:	74 17                	je     f011b79a <test_kmalloc_firstfit2+0x245>
f011b783:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b78a:	83 ec 0c             	sub    $0xc,%esp
f011b78d:	68 00 ef 12 f0       	push   $0xf012ef00
f011b792:	e8 d5 57 fe ff       	call   f0100f6c <cprintf>
f011b797:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//2 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b79a:	e8 3e 22 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b79f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b7a2:	e8 6e 90 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b7a7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo);
f011b7aa:	83 ec 0c             	sub    $0xc,%esp
f011b7ad:	68 00 08 00 00       	push   $0x800
f011b7b2:	e8 d4 d2 fe ff       	call   f0108a8b <kmalloc>
f011b7b7:	83 c4 10             	add    $0x10,%esp
f011b7ba:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011b7bd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011b7c0:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b7c5:	76 22                	jbe    f011b7e9 <test_kmalloc_firstfit2+0x294>
f011b7c7:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f011b7ca:	83 ec 0c             	sub    $0xc,%esp
f011b7cd:	6a 00                	push   $0x0
f011b7cf:	e8 ad d2 fe ff       	call   f0108a81 <sbrk>
f011b7d4:	83 c4 10             	add    $0x10,%esp
f011b7d7:	39 c3                	cmp    %eax,%ebx
f011b7d9:	73 0e                	jae    f011b7e9 <test_kmalloc_firstfit2+0x294>
f011b7db:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011b7de:	89 c2                	mov    %eax,%edx
f011b7e0:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011b7e5:	39 c2                	cmp    %eax,%edx
f011b7e7:	72 17                	jb     f011b800 <test_kmalloc_firstfit2+0x2ab>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b7e9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b7f0:	83 ec 0c             	sub    $0xc,%esp
f011b7f3:	68 00 f0 12 f0       	push   $0xf012f000
f011b7f8:	e8 6f 57 fe ff       	call   f0100f6c <cprintf>
f011b7fd:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b800:	e8 10 90 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b805:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b808:	74 17                	je     f011b821 <test_kmalloc_firstfit2+0x2cc>
f011b80a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b811:	83 ec 0c             	sub    $0xc,%esp
f011b814:	68 00 ef 12 f0       	push   $0xf012ef00
f011b819:	e8 4e 57 fe ff       	call   f0100f6c <cprintf>
f011b81e:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//1 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b821:	e8 b7 21 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b826:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b829:	e8 e7 8f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b82e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(1*kilo);
f011b831:	83 ec 0c             	sub    $0xc,%esp
f011b834:	68 00 04 00 00       	push   $0x400
f011b839:	e8 4d d2 fe ff       	call   f0108a8b <kmalloc>
f011b83e:	83 c4 10             	add    $0x10,%esp
f011b841:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011b844:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011b847:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b84c:	76 22                	jbe    f011b870 <test_kmalloc_firstfit2+0x31b>
f011b84e:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b851:	83 ec 0c             	sub    $0xc,%esp
f011b854:	6a 00                	push   $0x0
f011b856:	e8 26 d2 fe ff       	call   f0108a81 <sbrk>
f011b85b:	83 c4 10             	add    $0x10,%esp
f011b85e:	39 c3                	cmp    %eax,%ebx
f011b860:	73 0e                	jae    f011b870 <test_kmalloc_firstfit2+0x31b>
f011b862:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011b865:	89 c2                	mov    %eax,%edx
f011b867:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011b86c:	39 c2                	cmp    %eax,%edx
f011b86e:	72 17                	jb     f011b887 <test_kmalloc_firstfit2+0x332>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b870:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b877:	83 ec 0c             	sub    $0xc,%esp
f011b87a:	68 00 f0 12 f0       	push   $0xf012f000
f011b87f:	e8 e8 56 fe ff       	call   f0100f6c <cprintf>
f011b884:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b887:	e8 89 8f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b88c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b88f:	74 17                	je     f011b8a8 <test_kmalloc_firstfit2+0x353>
f011b891:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b898:	83 ec 0c             	sub    $0xc,%esp
f011b89b:	68 00 ef 12 f0       	push   $0xf012ef00
f011b8a0:	e8 c7 56 fe ff       	call   f0100f6c <cprintf>
f011b8a5:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//1 KB Hole in Dynamic Allocator Area
		freeFrames = (int)sys_calculate_free_frames() ;
f011b8a8:	e8 30 21 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b8ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b8b0:	e8 60 8f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b8b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f011b8b8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b8bb:	83 ec 0c             	sub    $0xc,%esp
f011b8be:	50                   	push   %eax
f011b8bf:	e8 e1 d1 fe ff       	call   f0108aa5 <kfree>
f011b8c4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b8c7:	e8 49 8f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b8cc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b8cf:	74 17                	je     f011b8e8 <test_kmalloc_firstfit2+0x393>
f011b8d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b8d8:	83 ec 0c             	sub    $0xc,%esp
f011b8db:	68 00 ef 12 f0       	push   $0xf012ef00
f011b8e0:	e8 87 56 fe ff       	call   f0100f6c <cprintf>
f011b8e5:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011b8e8:	e8 f0 20 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b8ed:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011b8f0:	74 17                	je     f011b909 <test_kmalloc_firstfit2+0x3b4>
f011b8f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b8f9:	83 ec 0c             	sub    $0xc,%esp
f011b8fc:	68 0c f2 12 f0       	push   $0xf012f20c
f011b901:	e8 66 56 fe ff       	call   f0100f6c <cprintf>
f011b906:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011b909:	e8 cf 20 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b90e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b911:	e8 ff 8e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b916:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011b919:	83 ec 0c             	sub    $0xc,%esp
f011b91c:	68 00 1c 00 00       	push   $0x1c00
f011b921:	e8 65 d1 fe ff       	call   f0108a8b <kmalloc>
f011b926:	83 c4 10             	add    $0x10,%esp
f011b929:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011b92c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011b92f:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b934:	74 17                	je     f011b94d <test_kmalloc_firstfit2+0x3f8>
f011b936:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b93d:	83 ec 0c             	sub    $0xc,%esp
f011b940:	68 38 f1 12 f0       	push   $0xf012f138
f011b945:	e8 22 56 fe ff       	call   f0100f6c <cprintf>
f011b94a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b94d:	e8 c3 8e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b952:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b955:	74 17                	je     f011b96e <test_kmalloc_firstfit2+0x419>
f011b957:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b95e:	83 ec 0c             	sub    $0xc,%esp
f011b961:	68 00 ef 12 f0       	push   $0xf012ef00
f011b966:	e8 01 56 fe ff       	call   f0100f6c <cprintf>
f011b96b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: \n"); }
f011b96e:	e8 6a 20 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b973:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b976:	29 c2                	sub    %eax,%edx
f011b978:	89 d0                	mov    %edx,%eax
f011b97a:	83 f8 01             	cmp    $0x1,%eax
f011b97d:	77 17                	ja     f011b996 <test_kmalloc_firstfit2+0x441>
f011b97f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b986:	83 ec 0c             	sub    $0xc,%esp
f011b989:	68 69 f1 12 f0       	push   $0xf012f169
f011b98e:	e8 d9 55 fe ff       	call   f0100f6c <cprintf>
f011b993:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011b996:	e8 42 20 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b99b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b99e:	e8 72 8e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b9a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f011b9a6:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b9a9:	83 ec 0c             	sub    $0xc,%esp
f011b9ac:	50                   	push   %eax
f011b9ad:	e8 f3 d0 fe ff       	call   f0108aa5 <kfree>
f011b9b2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b9b5:	e8 5b 8e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011b9ba:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011b9bd:	74 17                	je     f011b9d6 <test_kmalloc_firstfit2+0x481>
f011b9bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b9c6:	83 ec 0c             	sub    $0xc,%esp
f011b9c9:	68 00 ef 12 f0       	push   $0xf012ef00
f011b9ce:	e8 99 55 fe ff       	call   f0100f6c <cprintf>
f011b9d3:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f011b9d6:	e8 02 20 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011b9db:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011b9de:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b9e3:	77 17                	ja     f011b9fc <test_kmalloc_firstfit2+0x4a7>
f011b9e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011b9ec:	83 ec 0c             	sub    $0xc,%esp
f011b9ef:	68 7d f1 12 f0       	push   $0xf012f17d
f011b9f4:	e8 73 55 fe ff       	call   f0100f6c <cprintf>
f011b9f9:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011b9fc:	e8 dc 1f ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ba01:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ba04:	e8 0c 8e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ba09:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011ba0c:	83 ec 0c             	sub    $0xc,%esp
f011ba0f:	68 00 fc 2f 00       	push   $0x2ffc00
f011ba14:	e8 72 d0 fe ff       	call   f0108a8b <kmalloc>
f011ba19:	83 c4 10             	add    $0x10,%esp
f011ba1c:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011ba1f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011ba22:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011ba27:	74 17                	je     f011ba40 <test_kmalloc_firstfit2+0x4eb>
f011ba29:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ba30:	83 ec 0c             	sub    $0xc,%esp
f011ba33:	68 38 f1 12 f0       	push   $0xf012f138
f011ba38:	e8 2f 55 fe ff       	call   f0100f6c <cprintf>
f011ba3d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba40:	e8 d0 8d fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ba45:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ba48:	74 17                	je     f011ba61 <test_kmalloc_firstfit2+0x50c>
f011ba4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ba51:	83 ec 0c             	sub    $0xc,%esp
f011ba54:	68 00 ef 12 f0       	push   $0xf012ef00
f011ba59:	e8 0e 55 fe ff       	call   f0100f6c <cprintf>
f011ba5e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f011ba61:	e8 77 1f ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ba66:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ba69:	29 c2                	sub    %eax,%edx
f011ba6b:	89 d0                	mov    %edx,%eax
f011ba6d:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011ba72:	77 17                	ja     f011ba8b <test_kmalloc_firstfit2+0x536>
f011ba74:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ba7b:	83 ec 0c             	sub    $0xc,%esp
f011ba7e:	68 69 f1 12 f0       	push   $0xf012f169
f011ba83:	e8 e4 54 fe ff       	call   f0100f6c <cprintf>
f011ba88:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011ba8b:	e8 4d 1f ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ba90:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ba93:	e8 7d 8d fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ba98:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f011ba9b:	83 ec 0c             	sub    $0xc,%esp
f011ba9e:	68 00 18 20 00       	push   $0x201800
f011baa3:	e8 e3 cf fe ff       	call   f0108a8b <kmalloc>
f011baa8:	83 c4 10             	add    $0x10,%esp
f011baab:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011baae:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011bab1:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011bab6:	74 17                	je     f011bacf <test_kmalloc_firstfit2+0x57a>
f011bab8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011babf:	83 ec 0c             	sub    $0xc,%esp
f011bac2:	68 38 f1 12 f0       	push   $0xf012f138
f011bac7:	e8 a0 54 fe ff       	call   f0100f6c <cprintf>
f011bacc:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bacf:	e8 41 8d fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bad4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bad7:	74 17                	je     f011baf0 <test_kmalloc_firstfit2+0x59b>
f011bad9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bae0:	83 ec 0c             	sub    $0xc,%esp
f011bae3:	68 00 ef 12 f0       	push   $0xf012ef00
f011bae8:	e8 7f 54 fe ff       	call   f0100f6c <cprintf>
f011baed:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("Wrong allocation: \n"); }
f011baf0:	e8 e8 1e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011baf5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011baf8:	29 c2                	sub    %eax,%edx
f011bafa:	89 d0                	mov    %edx,%eax
f011bafc:	3d 01 02 00 00       	cmp    $0x201,%eax
f011bb01:	77 17                	ja     f011bb1a <test_kmalloc_firstfit2+0x5c5>
f011bb03:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bb0a:	83 ec 0c             	sub    $0xc,%esp
f011bb0d:	68 69 f1 12 f0       	push   $0xf012f169
f011bb12:	e8 55 54 fe ff       	call   f0100f6c <cprintf>
f011bb17:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011bb1a:	e8 be 1e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bb1f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bb22:	e8 ee 8c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bb27:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f011bb2a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011bb2d:	83 ec 0c             	sub    $0xc,%esp
f011bb30:	50                   	push   %eax
f011bb31:	e8 6f cf fe ff       	call   f0108aa5 <kfree>
f011bb36:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bb39:	e8 d7 8c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bb3e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bb41:	74 17                	je     f011bb5a <test_kmalloc_firstfit2+0x605>
f011bb43:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bb4a:	83 ec 0c             	sub    $0xc,%esp
f011bb4d:	68 00 ef 12 f0       	push   $0xf012ef00
f011bb52:	e8 15 54 fe ff       	call   f0100f6c <cprintf>
f011bb57:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("Wrong free: \n"); }
f011bb5a:	e8 7e 1e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bb5f:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011bb62:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011bb67:	77 17                	ja     f011bb80 <test_kmalloc_firstfit2+0x62b>
f011bb69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bb70:	83 ec 0c             	sub    $0xc,%esp
f011bb73:	68 7d f1 12 f0       	push   $0xf012f17d
f011bb78:	e8 ef 53 fe ff       	call   f0100f6c <cprintf>
f011bb7d:	83 c4 10             	add    $0x10,%esp

		//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f011bb80:	e8 58 1e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bb85:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bb88:	e8 88 8c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bb8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f011bb90:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011bb93:	83 ec 0c             	sub    $0xc,%esp
f011bb96:	50                   	push   %eax
f011bb97:	e8 09 cf fe ff       	call   f0108aa5 <kfree>
f011bb9c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bb9f:	e8 71 8c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bba4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bba7:	74 17                	je     f011bbc0 <test_kmalloc_firstfit2+0x66b>
f011bba9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bbb0:	83 ec 0c             	sub    $0xc,%esp
f011bbb3:	68 00 ef 12 f0       	push   $0xf012ef00
f011bbb8:	e8 af 53 fe ff       	call   f0100f6c <cprintf>
f011bbbd:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011bbc0:	e8 18 1e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bbc5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011bbc8:	74 17                	je     f011bbe1 <test_kmalloc_firstfit2+0x68c>
f011bbca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bbd1:	83 ec 0c             	sub    $0xc,%esp
f011bbd4:	68 0c f2 12 f0       	push   $0xf012f20c
f011bbd9:	e8 8e 53 fe ff       	call   f0100f6c <cprintf>
f011bbde:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f011bbe1:	e8 f7 1d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bbe6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bbe9:	e8 27 8c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bbee:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f011bbf1:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011bbf4:	83 ec 0c             	sub    $0xc,%esp
f011bbf7:	50                   	push   %eax
f011bbf8:	e8 a8 ce fe ff       	call   f0108aa5 <kfree>
f011bbfd:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f011bc00:	e8 d8 1d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bc05:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011bc08:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bc0d:	77 17                	ja     f011bc26 <test_kmalloc_firstfit2+0x6d1>
f011bc0f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bc16:	83 ec 0c             	sub    $0xc,%esp
f011bc19:	68 7d f1 12 f0       	push   $0xf012f17d
f011bc1e:	e8 49 53 fe ff       	call   f0100f6c <cprintf>
f011bc23:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc26:	e8 ea 8b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bc2b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bc2e:	74 17                	je     f011bc47 <test_kmalloc_firstfit2+0x6f2>
f011bc30:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bc37:	83 ec 0c             	sub    $0xc,%esp
f011bc3a:	68 00 ef 12 f0       	push   $0xf012ef00
f011bc3f:	e8 28 53 fe ff       	call   f0100f6c <cprintf>
f011bc44:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011bc47:	e8 91 1d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bc4c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bc4f:	e8 c1 8b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bc54:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f011bc57:	83 ec 0c             	sub    $0xc,%esp
f011bc5a:	68 00 fc 4f 00       	push   $0x4ffc00
f011bc5f:	e8 27 ce fe ff       	call   f0108a8b <kmalloc>
f011bc64:	83 c4 10             	add    $0x10,%esp
f011bc67:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011bc6a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011bc6d:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f011bc72:	74 17                	je     f011bc8b <test_kmalloc_firstfit2+0x736>
f011bc74:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bc7b:	83 ec 0c             	sub    $0xc,%esp
f011bc7e:	68 38 f1 12 f0       	push   $0xf012f138
f011bc83:	e8 e4 52 fe ff       	call   f0100f6c <cprintf>
f011bc88:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc8b:	e8 85 8b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bc90:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bc93:	74 17                	je     f011bcac <test_kmalloc_firstfit2+0x757>
f011bc95:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bc9c:	83 ec 0c             	sub    $0xc,%esp
f011bc9f:	68 00 ef 12 f0       	push   $0xf012ef00
f011bca4:	e8 c3 52 fe ff       	call   f0100f6c <cprintf>
f011bca9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f011bcac:	e8 2c 1d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bcb1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011bcb4:	29 c2                	sub    %eax,%edx
f011bcb6:	89 d0                	mov    %edx,%eax
f011bcb8:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f011bcbd:	77 17                	ja     f011bcd6 <test_kmalloc_firstfit2+0x781>
f011bcbf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bcc6:	83 ec 0c             	sub    $0xc,%esp
f011bcc9:	68 69 f1 12 f0       	push   $0xf012f169
f011bcce:	e8 99 52 fe ff       	call   f0100f6c <cprintf>
f011bcd3:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f011bcd6:	e8 02 1d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bcdb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bcde:	e8 32 8b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bce3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f011bce6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011bce9:	83 ec 0c             	sub    $0xc,%esp
f011bcec:	50                   	push   %eax
f011bced:	e8 b3 cd fe ff       	call   f0108aa5 <kfree>
f011bcf2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bcf5:	e8 1b 8b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bcfa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bcfd:	74 17                	je     f011bd16 <test_kmalloc_firstfit2+0x7c1>
f011bcff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bd06:	83 ec 0c             	sub    $0xc,%esp
f011bd09:	68 00 ef 12 f0       	push   $0xf012ef00
f011bd0e:	e8 59 52 fe ff       	call   f0100f6c <cprintf>
f011bd13:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("Wrong free: \n"); }
f011bd16:	e8 c2 1c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bd1b:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011bd1e:	83 f8 01             	cmp    $0x1,%eax
f011bd21:	77 17                	ja     f011bd3a <test_kmalloc_firstfit2+0x7e5>
f011bd23:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bd2a:	83 ec 0c             	sub    $0xc,%esp
f011bd2d:	68 7d f1 12 f0       	push   $0xf012f17d
f011bd32:	e8 35 52 fe ff       	call   f0100f6c <cprintf>
f011bd37:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011bd3a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011bd3e:	74 04                	je     f011bd44 <test_kmalloc_firstfit2+0x7ef>
f011bd40:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011bd44:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011bd4b:	e8 8d 1c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bd50:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bd53:	e8 bd 8a fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bd58:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f011bd5b:	83 ec 0c             	sub    $0xc,%esp
f011bd5e:	68 00 04 70 00       	push   $0x700400
f011bd63:	e8 23 cd fe ff       	call   f0108a8b <kmalloc>
f011bd68:	83 c4 10             	add    $0x10,%esp
f011bd6b:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011bd6e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011bd71:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011bd76:	74 17                	je     f011bd8f <test_kmalloc_firstfit2+0x83a>
f011bd78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bd7f:	83 ec 0c             	sub    $0xc,%esp
f011bd82:	68 38 f1 12 f0       	push   $0xf012f138
f011bd87:	e8 e0 51 fe ff       	call   f0100f6c <cprintf>
f011bd8c:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd8f:	e8 81 8a fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bd94:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bd97:	74 17                	je     f011bdb0 <test_kmalloc_firstfit2+0x85b>
f011bd99:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bda0:	83 ec 0c             	sub    $0xc,%esp
f011bda3:	68 00 ef 12 f0       	push   $0xf012ef00
f011bda8:	e8 bf 51 fe ff       	call   f0100f6c <cprintf>
f011bdad:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f011bdb0:	e8 28 1c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bdb5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011bdb8:	29 c2                	sub    %eax,%edx
f011bdba:	89 d0                	mov    %edx,%eax
f011bdbc:	3d 00 07 00 00       	cmp    $0x700,%eax
f011bdc1:	77 17                	ja     f011bdda <test_kmalloc_firstfit2+0x885>
f011bdc3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bdca:	83 ec 0c             	sub    $0xc,%esp
f011bdcd:	68 69 f1 12 f0       	push   $0xf012f169
f011bdd2:	e8 95 51 fe ff       	call   f0100f6c <cprintf>
f011bdd7:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011bdda:	e8 fe 1b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bddf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bde2:	e8 2e 8a fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bde7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f011bdea:	83 ec 0c             	sub    $0xc,%esp
f011bded:	68 00 0c 00 00       	push   $0xc00
f011bdf2:	e8 94 cc fe ff       	call   f0108a8b <kmalloc>
f011bdf7:	83 c4 10             	add    $0x10,%esp
f011bdfa:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011bdfd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011be00:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f011be05:	74 17                	je     f011be1e <test_kmalloc_firstfit2+0x8c9>
f011be07:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011be0e:	83 ec 0c             	sub    $0xc,%esp
f011be11:	68 38 f1 12 f0       	push   $0xf012f138
f011be16:	e8 51 51 fe ff       	call   f0100f6c <cprintf>
f011be1b:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011be1e:	e8 f2 89 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011be23:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011be26:	74 17                	je     f011be3f <test_kmalloc_firstfit2+0x8ea>
f011be28:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011be2f:	83 ec 0c             	sub    $0xc,%esp
f011be32:	68 00 ef 12 f0       	push   $0xf012ef00
f011be37:	e8 30 51 fe ff       	call   f0100f6c <cprintf>
f011be3c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("Wrong allocation: \n"); }
f011be3f:	e8 99 1b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011be44:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011be47:	75 17                	jne    f011be60 <test_kmalloc_firstfit2+0x90b>
f011be49:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011be50:	83 ec 0c             	sub    $0xc,%esp
f011be53:	68 69 f1 12 f0       	push   $0xf012f169
f011be58:	e8 0f 51 fe ff       	call   f0100f6c <cprintf>
f011be5d:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f011be60:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011be64:	74 04                	je     f011be6a <test_kmalloc_firstfit2+0x915>
f011be66:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	correct = 1 ;
f011be6a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011be71:	e8 67 1b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011be76:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011be79:	e8 97 89 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011be7e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(1*kilo);
f011be81:	83 ec 0c             	sub    $0xc,%esp
f011be84:	68 00 04 00 00       	push   $0x400
f011be89:	e8 fd cb fe ff       	call   f0108a8b <kmalloc>
f011be8e:	83 c4 10             	add    $0x10,%esp
f011be91:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((ptr_allocations[11] < ptr_allocations[2]) || (ptr_allocations[11] > (ptr_allocations[2] + 1*kilo)))
f011be94:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011be97:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011be9a:	39 c2                	cmp    %eax,%edx
f011be9c:	72 10                	jb     f011beae <test_kmalloc_firstfit2+0x959>
f011be9e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011bea1:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011bea4:	81 c2 00 04 00 00    	add    $0x400,%edx
f011beaa:	39 d0                	cmp    %edx,%eax
f011beac:	76 17                	jbe    f011bec5 <test_kmalloc_firstfit2+0x970>
		{ correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011beae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011beb5:	83 ec 0c             	sub    $0xc,%esp
f011beb8:	68 38 f1 12 f0       	push   $0xf012f138
f011bebd:	e8 aa 50 fe ff       	call   f0100f6c <cprintf>
f011bec2:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bec5:	e8 4b 89 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011beca:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011becd:	74 17                	je     f011bee6 <test_kmalloc_firstfit2+0x991>
f011becf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bed6:	83 ec 0c             	sub    $0xc,%esp
f011bed9:	68 00 ef 12 f0       	push   $0xf012ef00
f011bede:	e8 89 50 fe ff       	call   f0100f6c <cprintf>
f011bee3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: \n"); }
f011bee6:	e8 f2 1a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011beeb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011beee:	74 17                	je     f011bf07 <test_kmalloc_firstfit2+0x9b2>
f011bef0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bef7:	83 ec 0c             	sub    $0xc,%esp
f011befa:	68 69 f1 12 f0       	push   $0xf012f169
f011beff:	e8 68 50 fe ff       	call   f0100f6c <cprintf>
f011bf04:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011bf07:	e8 d1 1a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bf0c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bf0f:	e8 01 89 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bf14:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f011bf17:	83 ec 0c             	sub    $0xc,%esp
f011bf1a:	68 00 04 00 00       	push   $0x400
f011bf1f:	e8 67 cb fe ff       	call   f0108a8b <kmalloc>
f011bf24:	83 c4 10             	add    $0x10,%esp
f011bf27:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((ptr_allocations[12] < ptr_allocations[2] + 1*kilo) || (ptr_allocations[12] > (ptr_allocations[2] + 2*kilo)))
f011bf2a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011bf2d:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011bf30:	81 c2 00 04 00 00    	add    $0x400,%edx
f011bf36:	39 d0                	cmp    %edx,%eax
f011bf38:	72 10                	jb     f011bf4a <test_kmalloc_firstfit2+0x9f5>
f011bf3a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011bf3d:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011bf40:	81 c2 00 08 00 00    	add    $0x800,%edx
f011bf46:	39 d0                	cmp    %edx,%eax
f011bf48:	76 17                	jbe    f011bf61 <test_kmalloc_firstfit2+0xa0c>
		{ correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011bf4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bf51:	83 ec 0c             	sub    $0xc,%esp
f011bf54:	68 38 f1 12 f0       	push   $0xf012f138
f011bf59:	e8 0e 50 fe ff       	call   f0100f6c <cprintf>
f011bf5e:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bf61:	e8 af 88 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011bf66:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011bf69:	74 17                	je     f011bf82 <test_kmalloc_firstfit2+0xa2d>
f011bf6b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bf72:	83 ec 0c             	sub    $0xc,%esp
f011bf75:	68 00 ef 12 f0       	push   $0xf012ef00
f011bf7a:	e8 ed 4f fe ff       	call   f0100f6c <cprintf>
f011bf7f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: \n"); }
f011bf82:	e8 56 1a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011bf87:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011bf8a:	74 17                	je     f011bfa3 <test_kmalloc_firstfit2+0xa4e>
f011bf8c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bf93:	83 ec 0c             	sub    $0xc,%esp
f011bf96:	68 69 f1 12 f0       	push   $0xf012f169
f011bf9b:	e8 cc 4f fe ff       	call   f0100f6c <cprintf>
f011bfa0:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f011bfa3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011bfa7:	74 04                	je     f011bfad <test_kmalloc_firstfit2+0xa58>
f011bfa9:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	correct = 1 ;
f011bfad:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f011bfb4:	83 ec 0c             	sub    $0xc,%esp
f011bfb7:	68 00 e0 1f 07       	push   $0x71fe000
f011bfbc:	e8 ca ca fe ff       	call   f0108a8b <kmalloc>
f011bfc1:	83 c4 10             	add    $0x10,%esp
f011bfc4:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f011bfc7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011bfca:	85 c0                	test   %eax,%eax
f011bfcc:	74 17                	je     f011bfe5 <test_kmalloc_firstfit2+0xa90>
f011bfce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011bfd5:	83 ec 0c             	sub    $0xc,%esp
f011bfd8:	68 68 f2 12 f0       	push   $0xf012f268
f011bfdd:	e8 8a 4f fe ff       	call   f0100f6c <cprintf>
f011bfe2:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f011bfe5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011bfe9:	74 04                	je     f011bfef <test_kmalloc_firstfit2+0xa9a>
f011bfeb:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f011bfef:	83 ec 08             	sub    $0x8,%esp
f011bff2:	ff 75 f4             	pushl  -0xc(%ebp)
f011bff5:	68 cc f2 12 f0       	push   $0xf012f2cc
f011bffa:	e8 6d 4f fe ff       	call   f0100f6c <cprintf>
f011bfff:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c002:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011c007:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011c00a:	5b                   	pop    %ebx
f011c00b:	5f                   	pop    %edi
f011c00c:	5d                   	pop    %ebp
f011c00d:	c3                   	ret    

f011c00e <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f011c00e:	55                   	push   %ebp
f011c00f:	89 e5                	mov    %esp,%ebp
f011c011:	57                   	push   %edi
f011c012:	53                   	push   %ebx
f011c013:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011c019:	83 ec 0c             	sub    $0xc,%esp
f011c01c:	68 40 ee 12 f0       	push   $0xf012ee40
f011c021:	e8 46 4f fe ff       	call   f0100f6c <cprintf>
f011c026:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011c029:	83 ec 0c             	sub    $0xc,%esp
f011c02c:	68 70 ee 12 f0       	push   $0xf012ee70
f011c031:	e8 36 4f fe ff       	call   f0100f6c <cprintf>
f011c036:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011c039:	83 ec 0c             	sub    $0xc,%esp
f011c03c:	68 40 ee 12 f0       	push   $0xf012ee40
f011c041:	e8 26 4f fe ff       	call   f0100f6c <cprintf>
f011c046:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011c049:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f011c04d:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f011c051:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f011c057:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f011c05d:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011c064:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011c06b:	e8 6d 19 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c070:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011c073:	8d 95 68 ff ff ff    	lea    -0x98(%ebp),%edx
f011c079:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c07e:	b8 00 00 00 00       	mov    $0x0,%eax
f011c083:	89 d7                	mov    %edx,%edi
f011c085:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011c087:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f011c08d:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c092:	b8 00 00 00 00       	mov    $0x0,%eax
f011c097:	89 d7                	mov    %edx,%edi
f011c099:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011c09b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011c0a2:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f011c0a9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011c0b0:	8d 95 c8 fe ff ff    	lea    -0x138(%ebp),%edx
f011c0b6:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c0bb:	b8 00 00 00 00       	mov    $0x0,%eax
f011c0c0:	89 d7                	mov    %edx,%edi
f011c0c2:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//[BLOCK ALLOCATOR]
		{
			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011c0c4:	e8 14 19 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c0c9:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c0cc:	e8 44 87 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c0d1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f011c0d4:	83 ec 0c             	sub    $0xc,%esp
f011c0d7:	68 00 08 00 00       	push   $0x800
f011c0dc:	e8 aa c9 fe ff       	call   f0108a8b <kmalloc>
f011c0e1:	83 c4 10             	add    $0x10,%esp
f011c0e4:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011c0ea:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011c0f0:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c0f5:	76 28                	jbe    f011c11f <test_kfree_bestfirstfit+0x111>
f011c0f7:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f011c0fd:	83 ec 0c             	sub    $0xc,%esp
f011c100:	6a 00                	push   $0x0
f011c102:	e8 7a c9 fe ff       	call   f0108a81 <sbrk>
f011c107:	83 c4 10             	add    $0x10,%esp
f011c10a:	39 c3                	cmp    %eax,%ebx
f011c10c:	73 11                	jae    f011c11f <test_kfree_bestfirstfit+0x111>
f011c10e:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011c114:	89 c2                	mov    %eax,%edx
f011c116:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011c11b:	39 c2                	cmp    %eax,%edx
f011c11d:	72 17                	jb     f011c136 <test_kfree_bestfirstfit+0x128>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c11f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c126:	83 ec 0c             	sub    $0xc,%esp
f011c129:	68 00 f0 12 f0       	push   $0xf012f000
f011c12e:	e8 39 4e fe ff       	call   f0100f6c <cprintf>
f011c133:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c136:	e8 da 86 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c13b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c13e:	74 17                	je     f011c157 <test_kfree_bestfirstfit+0x149>
f011c140:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c147:	83 ec 0c             	sub    $0xc,%esp
f011c14a:	68 00 ef 12 f0       	push   $0xf012ef00
f011c14f:	e8 18 4e fe ff       	call   f0100f6c <cprintf>
f011c154:	83 c4 10             	add    $0x10,%esp
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f011c157:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f011c15e:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f011c161:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011c167:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f011c16a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c171:	eb 0e                	jmp    f011c181 <test_kfree_bestfirstfit+0x173>
			{
				ptr[i] = 2 ;
f011c173:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c176:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c179:	01 d0                	add    %edx,%eax
f011c17b:	c6 00 02             	movb   $0x2,(%eax)
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f011c17e:	ff 45 f4             	incl   -0xc(%ebp)
f011c181:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011c187:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c18a:	7f e7                	jg     f011c173 <test_kfree_bestfirstfit+0x165>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011c18c:	e8 4c 18 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c191:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c194:	e8 7c 86 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c199:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011c19c:	83 ec 0c             	sub    $0xc,%esp
f011c19f:	68 00 08 00 00       	push   $0x800
f011c1a4:	e8 e2 c8 fe ff       	call   f0108a8b <kmalloc>
f011c1a9:	83 c4 10             	add    $0x10,%esp
f011c1ac:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011c1b2:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011c1b8:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c1bd:	76 28                	jbe    f011c1e7 <test_kfree_bestfirstfit+0x1d9>
f011c1bf:	8b 9d d4 fe ff ff    	mov    -0x12c(%ebp),%ebx
f011c1c5:	83 ec 0c             	sub    $0xc,%esp
f011c1c8:	6a 00                	push   $0x0
f011c1ca:	e8 b2 c8 fe ff       	call   f0108a81 <sbrk>
f011c1cf:	83 c4 10             	add    $0x10,%esp
f011c1d2:	39 c3                	cmp    %eax,%ebx
f011c1d4:	73 11                	jae    f011c1e7 <test_kfree_bestfirstfit+0x1d9>
f011c1d6:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011c1dc:	89 c2                	mov    %eax,%edx
f011c1de:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011c1e3:	39 c2                	cmp    %eax,%edx
f011c1e5:	72 17                	jb     f011c1fe <test_kfree_bestfirstfit+0x1f0>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c1e7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c1ee:	83 ec 0c             	sub    $0xc,%esp
f011c1f1:	68 00 f0 12 f0       	push   $0xf012f000
f011c1f6:	e8 71 4d fe ff       	call   f0100f6c <cprintf>
f011c1fb:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c1fe:	e8 12 86 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c203:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c206:	74 17                	je     f011c21f <test_kfree_bestfirstfit+0x211>
f011c208:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c20f:	83 ec 0c             	sub    $0xc,%esp
f011c212:	68 00 ef 12 f0       	push   $0xf012ef00
f011c217:	e8 50 4d fe ff       	call   f0100f6c <cprintf>
f011c21c:	83 c4 10             	add    $0x10,%esp
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f011c21f:	c7 85 74 ff ff ff ff 	movl   $0x7ff,-0x8c(%ebp)
f011c226:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f011c229:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011c22f:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f011c232:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c239:	eb 0e                	jmp    f011c249 <test_kfree_bestfirstfit+0x23b>
			{
				ptr[i] = 3 ;
f011c23b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c23e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c241:	01 d0                	add    %edx,%eax
f011c243:	c6 00 03             	movb   $0x3,(%eax)
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f011c246:	ff 45 f4             	incl   -0xc(%ebp)
f011c249:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011c24f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c252:	7f e7                	jg     f011c23b <test_kfree_bestfirstfit+0x22d>
		}

		//[PAGE ALLOCATOR]
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011c254:	e8 84 17 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c259:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c25c:	e8 b4 85 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c261:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011c264:	83 ec 0c             	sub    $0xc,%esp
f011c267:	68 00 fc 1f 00       	push   $0x1ffc00
f011c26c:	e8 1a c8 fe ff       	call   f0108a8b <kmalloc>
f011c271:	83 c4 10             	add    $0x10,%esp
f011c274:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c27a:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011c280:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011c285:	74 17                	je     f011c29e <test_kfree_bestfirstfit+0x290>
f011c287:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c28e:	83 ec 0c             	sub    $0xc,%esp
f011c291:	68 b0 ef 12 f0       	push   $0xf012efb0
f011c296:	e8 d1 4c fe ff       	call   f0100f6c <cprintf>
f011c29b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c29e:	e8 72 85 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c2a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c2a6:	74 17                	je     f011c2bf <test_kfree_bestfirstfit+0x2b1>
f011c2a8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c2af:	83 ec 0c             	sub    $0xc,%esp
f011c2b2:	68 00 ef 12 f0       	push   $0xf012ef00
f011c2b7:	e8 b0 4c fe ff       	call   f0100f6c <cprintf>
f011c2bc:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c2bf:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c2c2:	e8 16 17 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c2c7:	29 c3                	sub    %eax,%ebx
f011c2c9:	89 d8                	mov    %ebx,%eax
f011c2cb:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c2d0:	77 17                	ja     f011c2e9 <test_kfree_bestfirstfit+0x2db>
f011c2d2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c2d9:	83 ec 0c             	sub    $0xc,%esp
f011c2dc:	68 6c ef 12 f0       	push   $0xf012ef6c
f011c2e1:	e8 86 4c fe ff       	call   f0100f6c <cprintf>
f011c2e6:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f011c2e9:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f011c2f0:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011c2f3:	e8 e5 16 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c2f8:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c2fb:	e8 15 85 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c300:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011c303:	83 ec 0c             	sub    $0xc,%esp
f011c306:	68 00 fc 1f 00       	push   $0x1ffc00
f011c30b:	e8 7b c7 fe ff       	call   f0108a8b <kmalloc>
f011c310:	83 c4 10             	add    $0x10,%esp
f011c313:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c319:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011c31f:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011c324:	74 17                	je     f011c33d <test_kfree_bestfirstfit+0x32f>
f011c326:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c32d:	83 ec 0c             	sub    $0xc,%esp
f011c330:	68 b0 ef 12 f0       	push   $0xf012efb0
f011c335:	e8 32 4c fe ff       	call   f0100f6c <cprintf>
f011c33a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c33d:	e8 d3 84 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c342:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c345:	74 17                	je     f011c35e <test_kfree_bestfirstfit+0x350>
f011c347:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c34e:	83 ec 0c             	sub    $0xc,%esp
f011c351:	68 00 ef 12 f0       	push   $0xf012ef00
f011c356:	e8 11 4c fe ff       	call   f0100f6c <cprintf>
f011c35b:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c35e:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c361:	e8 77 16 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c366:	29 c3                	sub    %eax,%ebx
f011c368:	89 d8                	mov    %ebx,%eax
f011c36a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c36f:	77 17                	ja     f011c388 <test_kfree_bestfirstfit+0x37a>
f011c371:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c378:	83 ec 0c             	sub    $0xc,%esp
f011c37b:	68 6c ef 12 f0       	push   $0xf012ef6c
f011c380:	e8 e7 4b fe ff       	call   f0100f6c <cprintf>
f011c385:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f011c388:	c7 85 6c ff ff ff ff 	movl   $0x1ffbff,-0x94(%ebp)
f011c38f:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f011c392:	e8 46 16 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c397:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c39a:	e8 76 84 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c39f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f011c3a2:	83 ec 0c             	sub    $0xc,%esp
f011c3a5:	68 00 1c 00 00       	push   $0x1c00
f011c3aa:	e8 dc c6 fe ff       	call   f0108a8b <kmalloc>
f011c3af:	83 c4 10             	add    $0x10,%esp
f011c3b2:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c3b8:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011c3be:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011c3c3:	74 17                	je     f011c3dc <test_kfree_bestfirstfit+0x3ce>
f011c3c5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c3cc:	83 ec 0c             	sub    $0xc,%esp
f011c3cf:	68 b0 ef 12 f0       	push   $0xf012efb0
f011c3d4:	e8 93 4b fe ff       	call   f0100f6c <cprintf>
f011c3d9:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c3dc:	e8 34 84 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c3e1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c3e4:	74 17                	je     f011c3fd <test_kfree_bestfirstfit+0x3ef>
f011c3e6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c3ed:	83 ec 0c             	sub    $0xc,%esp
f011c3f0:	68 00 ef 12 f0       	push   $0xf012ef00
f011c3f5:	e8 72 4b fe ff       	call   f0100f6c <cprintf>
f011c3fa:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c3fd:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c400:	e8 d8 15 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c405:	29 c3                	sub    %eax,%ebx
f011c407:	89 d8                	mov    %ebx,%eax
f011c409:	83 f8 01             	cmp    $0x1,%eax
f011c40c:	77 17                	ja     f011c425 <test_kfree_bestfirstfit+0x417>
f011c40e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c415:	83 ec 0c             	sub    $0xc,%esp
f011c418:	68 6c ef 12 f0       	push   $0xf012ef6c
f011c41d:	e8 4a 4b fe ff       	call   f0100f6c <cprintf>
f011c422:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f011c425:	c7 85 78 ff ff ff ff 	movl   $0x1bff,-0x88(%ebp)
f011c42c:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f011c42f:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011c435:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f011c438:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c43f:	eb 0e                	jmp    f011c44f <test_kfree_bestfirstfit+0x441>
			{
				ptr[i] = 4 ;
f011c441:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c444:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c447:	01 d0                	add    %edx,%eax
f011c449:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f011c44c:	ff 45 f4             	incl   -0xc(%ebp)
f011c44f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c455:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c458:	7f e7                	jg     f011c441 <test_kfree_bestfirstfit+0x433>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f011c45a:	e8 7e 15 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c45f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c462:	e8 ae 83 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c467:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011c46a:	83 ec 0c             	sub    $0xc,%esp
f011c46d:	68 00 fc 2f 00       	push   $0x2ffc00
f011c472:	e8 14 c6 fe ff       	call   f0108a8b <kmalloc>
f011c477:	83 c4 10             	add    $0x10,%esp
f011c47a:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c480:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011c486:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011c48b:	74 17                	je     f011c4a4 <test_kfree_bestfirstfit+0x496>
f011c48d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c494:	83 ec 0c             	sub    $0xc,%esp
f011c497:	68 b0 ef 12 f0       	push   $0xf012efb0
f011c49c:	e8 cb 4a fe ff       	call   f0100f6c <cprintf>
f011c4a1:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c4a4:	e8 6c 83 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c4a9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c4ac:	74 17                	je     f011c4c5 <test_kfree_bestfirstfit+0x4b7>
f011c4ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c4b5:	83 ec 0c             	sub    $0xc,%esp
f011c4b8:	68 00 ef 12 f0       	push   $0xf012ef00
f011c4bd:	e8 aa 4a fe ff       	call   f0100f6c <cprintf>
f011c4c2:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c4c5:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c4c8:	e8 10 15 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c4cd:	29 c3                	sub    %eax,%ebx
f011c4cf:	89 d8                	mov    %ebx,%eax
f011c4d1:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011c4d6:	77 17                	ja     f011c4ef <test_kfree_bestfirstfit+0x4e1>
f011c4d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c4df:	83 ec 0c             	sub    $0xc,%esp
f011c4e2:	68 6c ef 12 f0       	push   $0xf012ef6c
f011c4e7:	e8 80 4a fe ff       	call   f0100f6c <cprintf>
f011c4ec:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f011c4ef:	c7 85 7c ff ff ff ff 	movl   $0x2ffbff,-0x84(%ebp)
f011c4f6:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f011c4f9:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011c4ff:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f011c502:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c509:	eb 0e                	jmp    f011c519 <test_kfree_bestfirstfit+0x50b>
			{
				ptr[i] = 5 ;
f011c50b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c50e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c511:	01 d0                	add    %edx,%eax
f011c513:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f011c516:	ff 45 f4             	incl   -0xc(%ebp)
f011c519:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c51f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c522:	7f e7                	jg     f011c50b <test_kfree_bestfirstfit+0x4fd>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f011c524:	e8 b4 14 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c529:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c52c:	e8 e4 82 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c531:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011c534:	83 ec 0c             	sub    $0xc,%esp
f011c537:	68 00 fc 5f 00       	push   $0x5ffc00
f011c53c:	e8 4a c5 fe ff       	call   f0108a8b <kmalloc>
f011c541:	83 c4 10             	add    $0x10,%esp
f011c544:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c54a:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011c550:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011c555:	74 17                	je     f011c56e <test_kfree_bestfirstfit+0x560>
f011c557:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c55e:	83 ec 0c             	sub    $0xc,%esp
f011c561:	68 b0 ef 12 f0       	push   $0xf012efb0
f011c566:	e8 01 4a fe ff       	call   f0100f6c <cprintf>
f011c56b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c56e:	e8 a2 82 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c573:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c576:	74 17                	je     f011c58f <test_kfree_bestfirstfit+0x581>
f011c578:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c57f:	83 ec 0c             	sub    $0xc,%esp
f011c582:	68 00 ef 12 f0       	push   $0xf012ef00
f011c587:	e8 e0 49 fe ff       	call   f0100f6c <cprintf>
f011c58c:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c58f:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c592:	e8 46 14 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c597:	29 c3                	sub    %eax,%ebx
f011c599:	89 d8                	mov    %ebx,%eax
f011c59b:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c5a0:	77 17                	ja     f011c5b9 <test_kfree_bestfirstfit+0x5ab>
f011c5a2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c5a9:	83 ec 0c             	sub    $0xc,%esp
f011c5ac:	68 6c ef 12 f0       	push   $0xf012ef6c
f011c5b1:	e8 b6 49 fe ff       	call   f0100f6c <cprintf>
f011c5b6:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f011c5b9:	c7 45 80 ff fb 5f 00 	movl   $0x5ffbff,-0x80(%ebp)

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f011c5c0:	e8 18 14 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c5c5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c5c8:	e8 48 82 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c5cd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f011c5d0:	83 ec 0c             	sub    $0xc,%esp
f011c5d3:	68 00 38 00 00       	push   $0x3800
f011c5d8:	e8 ae c4 fe ff       	call   f0108a8b <kmalloc>
f011c5dd:	83 c4 10             	add    $0x10,%esp
f011c5e0:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c5e6:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011c5ec:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011c5f1:	74 17                	je     f011c60a <test_kfree_bestfirstfit+0x5fc>
f011c5f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c5fa:	83 ec 0c             	sub    $0xc,%esp
f011c5fd:	68 b0 ef 12 f0       	push   $0xf012efb0
f011c602:	e8 65 49 fe ff       	call   f0100f6c <cprintf>
f011c607:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c60a:	e8 06 82 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c60f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011c612:	74 17                	je     f011c62b <test_kfree_bestfirstfit+0x61d>
f011c614:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c61b:	83 ec 0c             	sub    $0xc,%esp
f011c61e:	68 00 ef 12 f0       	push   $0xf012ef00
f011c623:	e8 44 49 fe ff       	call   f0100f6c <cprintf>
f011c628:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c62b:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011c62e:	e8 aa 13 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c633:	29 c3                	sub    %eax,%ebx
f011c635:	89 d8                	mov    %ebx,%eax
f011c637:	83 f8 03             	cmp    $0x3,%eax
f011c63a:	77 17                	ja     f011c653 <test_kfree_bestfirstfit+0x645>
f011c63c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c643:	83 ec 0c             	sub    $0xc,%esp
f011c646:	68 6c ef 12 f0       	push   $0xf012ef6c
f011c64b:	e8 1c 49 fe ff       	call   f0100f6c <cprintf>
f011c650:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f011c653:	c7 45 84 ff 37 00 00 	movl   $0x37ff,-0x7c(%ebp)
			ptr = (char*)ptr_allocations[7];
f011c65a:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011c660:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f011c663:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c66a:	eb 0e                	jmp    f011c67a <test_kfree_bestfirstfit+0x66c>
			{
				ptr[i] = 7 ;
f011c66c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c66f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c672:	01 d0                	add    %edx,%eax
f011c674:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f011c677:	ff 45 f4             	incl   -0xc(%ebp)
f011c67a:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011c67d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c680:	7f ea                	jg     f011c66c <test_kfree_bestfirstfit+0x65e>
	}

	//kfree some of the allocated spaces [10%]
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c682:	e8 56 13 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c687:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c68a:	e8 86 81 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c68f:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f011c692:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011c698:	83 ec 0c             	sub    $0xc,%esp
f011c69b:	50                   	push   %eax
f011c69c:	e8 04 c4 fe ff       	call   f0108aa5 <kfree>
f011c6a1:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c6a4:	e8 6c 81 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c6a9:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011c6ac:	74 17                	je     f011c6c5 <test_kfree_bestfirstfit+0x6b7>
f011c6ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c6b5:	83 ec 0c             	sub    $0xc,%esp
f011c6b8:	68 00 ef 12 f0       	push   $0xf012ef00
f011c6bd:	e8 aa 48 fe ff       	call   f0100f6c <cprintf>
f011c6c2:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c6c5:	e8 13 13 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c6ca:	89 c2                	mov    %eax,%edx
f011c6cc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c6cf:	29 c2                	sub    %eax,%edx
f011c6d1:	89 d0                	mov    %edx,%eax
f011c6d3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c6d8:	77 17                	ja     f011c6f1 <test_kfree_bestfirstfit+0x6e3>
f011c6da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c6e1:	83 ec 0c             	sub    $0xc,%esp
f011c6e4:	68 04 f3 12 f0       	push   $0xf012f304
f011c6e9:	e8 7e 48 fe ff       	call   f0100f6c <cprintf>
f011c6ee:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB
		freeFrames = sys_calculate_free_frames() ;
f011c6f1:	e8 e7 12 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c6f6:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c6f9:	e8 17 81 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c6fe:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f011c701:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011c707:	83 ec 0c             	sub    $0xc,%esp
f011c70a:	50                   	push   %eax
f011c70b:	e8 95 c3 fe ff       	call   f0108aa5 <kfree>
f011c710:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c713:	e8 fd 80 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c718:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011c71b:	74 17                	je     f011c734 <test_kfree_bestfirstfit+0x726>
f011c71d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c724:	83 ec 0c             	sub    $0xc,%esp
f011c727:	68 00 ef 12 f0       	push   $0xf012ef00
f011c72c:	e8 3b 48 fe ff       	call   f0100f6c <cprintf>
f011c731:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011c734:	e8 a4 12 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c739:	89 c2                	mov    %eax,%edx
f011c73b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c73e:	39 c2                	cmp    %eax,%edx
f011c740:	74 17                	je     f011c759 <test_kfree_bestfirstfit+0x74b>
f011c742:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c749:	83 ec 0c             	sub    $0xc,%esp
f011c74c:	68 0c f2 12 f0       	push   $0xf012f20c
f011c751:	e8 16 48 fe ff       	call   f0100f6c <cprintf>
f011c756:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c759:	e8 7f 12 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c75e:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c761:	e8 af 80 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c766:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f011c769:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011c76f:	83 ec 0c             	sub    $0xc,%esp
f011c772:	50                   	push   %eax
f011c773:	e8 2d c3 fe ff       	call   f0108aa5 <kfree>
f011c778:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c77b:	e8 95 80 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c780:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011c783:	74 17                	je     f011c79c <test_kfree_bestfirstfit+0x78e>
f011c785:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c78c:	83 ec 0c             	sub    $0xc,%esp
f011c78f:	68 00 ef 12 f0       	push   $0xf012ef00
f011c794:	e8 d3 47 fe ff       	call   f0100f6c <cprintf>
f011c799:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c79c:	e8 3c 12 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c7a1:	89 c2                	mov    %eax,%edx
f011c7a3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c7a6:	29 c2                	sub    %eax,%edx
f011c7a8:	89 d0                	mov    %edx,%eax
f011c7aa:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c7af:	77 17                	ja     f011c7c8 <test_kfree_bestfirstfit+0x7ba>
f011c7b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c7b8:	83 ec 0c             	sub    $0xc,%esp
f011c7bb:	68 04 f3 12 f0       	push   $0xf012f304
f011c7c0:	e8 a7 47 fe ff       	call   f0100f6c <cprintf>
f011c7c5:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c7c8:	e8 10 12 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c7cd:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c7d0:	e8 40 80 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c7d5:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f011c7d8:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011c7de:	83 ec 0c             	sub    $0xc,%esp
f011c7e1:	50                   	push   %eax
f011c7e2:	e8 be c2 fe ff       	call   f0108aa5 <kfree>
f011c7e7:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c7ea:	e8 26 80 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011c7ef:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011c7f2:	74 17                	je     f011c80b <test_kfree_bestfirstfit+0x7fd>
f011c7f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c7fb:	83 ec 0c             	sub    $0xc,%esp
f011c7fe:	68 00 ef 12 f0       	push   $0xf012ef00
f011c803:	e8 64 47 fe ff       	call   f0100f6c <cprintf>
f011c808:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c80b:	e8 cd 11 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c810:	89 c2                	mov    %eax,%edx
f011c812:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c815:	29 c2                	sub    %eax,%edx
f011c817:	89 d0                	mov    %edx,%eax
f011c819:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c81e:	77 17                	ja     f011c837 <test_kfree_bestfirstfit+0x829>
f011c820:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c827:	83 ec 0c             	sub    $0xc,%esp
f011c82a:	68 04 f3 12 f0       	push   $0xf012f304
f011c82f:	e8 38 47 fe ff       	call   f0100f6c <cprintf>
f011c834:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011c837:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c83b:	74 04                	je     f011c841 <test_kfree_bestfirstfit+0x833>
f011c83d:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011c841:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access after kfree [10%]
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f011c848:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011c84e:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f011c851:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c858:	eb 1e                	jmp    f011c878 <test_kfree_bestfirstfit+0x86a>
		{
			sums[3] += ptr[i] ;
f011c85a:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011c860:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011c863:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c866:	01 c8                	add    %ecx,%eax
f011c868:	8a 00                	mov    (%eax),%al
f011c86a:	0f be c0             	movsbl %al,%eax
f011c86d:	01 d0                	add    %edx,%eax
f011c86f:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
	correct = 1 ;
	//Check memory access after kfree [10%]
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f011c875:	ff 45 f4             	incl   -0xc(%ebp)
f011c878:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011c87e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c881:	7f d7                	jg     f011c85a <test_kfree_bestfirstfit+0x84c>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011c883:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011c889:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011c88f:	89 c1                	mov    %eax,%ecx
f011c891:	01 c9                	add    %ecx,%ecx
f011c893:	01 c8                	add    %ecx,%eax
f011c895:	39 c2                	cmp    %eax,%edx
f011c897:	74 17                	je     f011c8b0 <test_kfree_bestfirstfit+0x8a2>
f011c899:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c8a0:	83 ec 0c             	sub    $0xc,%esp
f011c8a3:	68 3c f3 12 f0       	push   $0xf012f33c
f011c8a8:	e8 bf 46 fe ff       	call   f0100f6c <cprintf>
f011c8ad:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f011c8b0:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011c8b6:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f011c8b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c8c0:	eb 1e                	jmp    f011c8e0 <test_kfree_bestfirstfit+0x8d2>
		{
			sums[4] += ptr[i] ;
f011c8c2:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011c8c8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011c8cb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c8ce:	01 c8                	add    %ecx,%eax
f011c8d0:	8a 00                	mov    (%eax),%al
f011c8d2:	0f be c0             	movsbl %al,%eax
f011c8d5:	01 d0                	add    %edx,%eax
f011c8d7:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f011c8dd:	ff 45 f4             	incl   -0xc(%ebp)
f011c8e0:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c8e6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c8e9:	7f d7                	jg     f011c8c2 <test_kfree_bestfirstfit+0x8b4>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011c8eb:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f011c8f1:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011c8f7:	c1 e2 02             	shl    $0x2,%edx
f011c8fa:	39 d0                	cmp    %edx,%eax
f011c8fc:	74 17                	je     f011c915 <test_kfree_bestfirstfit+0x907>
f011c8fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c905:	83 ec 0c             	sub    $0xc,%esp
f011c908:	68 3c f3 12 f0       	push   $0xf012f33c
f011c90d:	e8 5a 46 fe ff       	call   f0100f6c <cprintf>
f011c912:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f011c915:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011c91b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f011c91e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c925:	eb 1e                	jmp    f011c945 <test_kfree_bestfirstfit+0x937>
		{
			sums[5] += ptr[i] ;
f011c927:	8b 95 2c ff ff ff    	mov    -0xd4(%ebp),%edx
f011c92d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011c930:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c933:	01 c8                	add    %ecx,%eax
f011c935:	8a 00                	mov    (%eax),%al
f011c937:	0f be c0             	movsbl %al,%eax
f011c93a:	01 d0                	add    %edx,%eax
f011c93c:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011c942:	ff 45 f4             	incl   -0xc(%ebp)
f011c945:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c94b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c94e:	7f d7                	jg     f011c927 <test_kfree_bestfirstfit+0x919>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011c950:	8b 8d 2c ff ff ff    	mov    -0xd4(%ebp),%ecx
f011c956:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
f011c95c:	89 d0                	mov    %edx,%eax
f011c95e:	c1 e0 02             	shl    $0x2,%eax
f011c961:	01 d0                	add    %edx,%eax
f011c963:	39 c1                	cmp    %eax,%ecx
f011c965:	74 17                	je     f011c97e <test_kfree_bestfirstfit+0x970>
f011c967:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c96e:	83 ec 0c             	sub    $0xc,%esp
f011c971:	68 3c f3 12 f0       	push   $0xf012f33c
f011c976:	e8 f1 45 fe ff       	call   f0100f6c <cprintf>
f011c97b:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011c97e:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011c984:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011c987:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c98e:	eb 1e                	jmp    f011c9ae <test_kfree_bestfirstfit+0x9a0>
		{
			sums[7] += ptr[i] ;
f011c990:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
f011c996:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011c999:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011c99c:	01 c8                	add    %ecx,%eax
f011c99e:	8a 00                	mov    (%eax),%al
f011c9a0:	0f be c0             	movsbl %al,%eax
f011c9a3:	01 d0                	add    %edx,%eax
f011c9a5:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011c9ab:	ff 45 f4             	incl   -0xc(%ebp)
f011c9ae:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011c9b1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011c9b4:	7f da                	jg     f011c990 <test_kfree_bestfirstfit+0x982>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011c9b6:	8b 8d 34 ff ff ff    	mov    -0xcc(%ebp),%ecx
f011c9bc:	8b 55 84             	mov    -0x7c(%ebp),%edx
f011c9bf:	89 d0                	mov    %edx,%eax
f011c9c1:	01 c0                	add    %eax,%eax
f011c9c3:	01 d0                	add    %edx,%eax
f011c9c5:	01 c0                	add    %eax,%eax
f011c9c7:	01 d0                	add    %edx,%eax
f011c9c9:	39 c1                	cmp    %eax,%ecx
f011c9cb:	74 17                	je     f011c9e4 <test_kfree_bestfirstfit+0x9d6>
f011c9cd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c9d4:	83 ec 0c             	sub    $0xc,%esp
f011c9d7:	68 3c f3 12 f0       	push   $0xf012f33c
f011c9dc:	e8 8b 45 fe ff       	call   f0100f6c <cprintf>
f011c9e1:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011c9e4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c9e8:	74 04                	je     f011c9ee <test_kfree_bestfirstfit+0x9e0>
f011c9ea:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011c9ee:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	{
		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011c9f5:	e8 e3 0f ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011c9fa:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c9fd:	e8 13 7e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ca02:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011ca05:	83 ec 0c             	sub    $0xc,%esp
f011ca08:	68 00 00 30 00       	push   $0x300000
f011ca0d:	e8 79 c0 fe ff       	call   f0108a8b <kmalloc>
f011ca12:	83 c4 10             	add    $0x10,%esp
f011ca15:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ca1b:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011ca21:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011ca26:	74 17                	je     f011ca3f <test_kfree_bestfirstfit+0xa31>
f011ca28:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ca2f:	83 ec 0c             	sub    $0xc,%esp
f011ca32:	68 b0 ef 12 f0       	push   $0xf012efb0
f011ca37:	e8 30 45 fe ff       	call   f0100f6c <cprintf>
f011ca3c:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ca3f:	e8 d1 7d fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ca44:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ca47:	74 17                	je     f011ca60 <test_kfree_bestfirstfit+0xa52>
f011ca49:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ca50:	83 ec 0c             	sub    $0xc,%esp
f011ca53:	68 00 ef 12 f0       	push   $0xf012ef00
f011ca58:	e8 0f 45 fe ff       	call   f0100f6c <cprintf>
f011ca5d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ca60:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011ca63:	e8 75 0f ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ca68:	29 c3                	sub    %eax,%ebx
f011ca6a:	89 d8                	mov    %ebx,%eax
f011ca6c:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011ca71:	77 17                	ja     f011ca8a <test_kfree_bestfirstfit+0xa7c>
f011ca73:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ca7a:	83 ec 0c             	sub    $0xc,%esp
f011ca7d:	68 6c ef 12 f0       	push   $0xf012ef6c
f011ca82:	e8 e5 44 fe ff       	call   f0100f6c <cprintf>
f011ca87:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011ca8a:	c7 45 88 ff ff 2f 00 	movl   $0x2fffff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[8];
f011ca91:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011ca97:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011ca9a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011caa1:	eb 0e                	jmp    f011cab1 <test_kfree_bestfirstfit+0xaa3>
		{
			ptr[i] = 8 ;
f011caa3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011caa6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011caa9:	01 d0                	add    %edx,%eax
f011caab:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011caae:	ff 45 f4             	incl   -0xc(%ebp)
f011cab1:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cab4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011cab7:	7f ea                	jg     f011caa3 <test_kfree_bestfirstfit+0xa95>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011cab9:	e8 1f 0f ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cabe:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cac1:	e8 4f 7d fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cac6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011cac9:	83 ec 0c             	sub    $0xc,%esp
f011cacc:	68 00 00 10 00       	push   $0x100000
f011cad1:	e8 b5 bf fe ff       	call   f0108a8b <kmalloc>
f011cad6:	83 c4 10             	add    $0x10,%esp
f011cad9:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011cadf:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011cae5:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011caea:	74 17                	je     f011cb03 <test_kfree_bestfirstfit+0xaf5>
f011caec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011caf3:	83 ec 0c             	sub    $0xc,%esp
f011caf6:	68 b0 ef 12 f0       	push   $0xf012efb0
f011cafb:	e8 6c 44 fe ff       	call   f0100f6c <cprintf>
f011cb00:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cb03:	e8 0d 7d fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cb08:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cb0b:	74 17                	je     f011cb24 <test_kfree_bestfirstfit+0xb16>
f011cb0d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cb14:	83 ec 0c             	sub    $0xc,%esp
f011cb17:	68 00 ef 12 f0       	push   $0xf012ef00
f011cb1c:	e8 4b 44 fe ff       	call   f0100f6c <cprintf>
f011cb21:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011cb24:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011cb27:	e8 b1 0e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cb2c:	29 c3                	sub    %eax,%ebx
f011cb2e:	89 d8                	mov    %ebx,%eax
f011cb30:	3d ff 00 00 00       	cmp    $0xff,%eax
f011cb35:	77 17                	ja     f011cb4e <test_kfree_bestfirstfit+0xb40>
f011cb37:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cb3e:	83 ec 0c             	sub    $0xc,%esp
f011cb41:	68 6c ef 12 f0       	push   $0xf012ef6c
f011cb46:	e8 21 44 fe ff       	call   f0100f6c <cprintf>
f011cb4b:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011cb4e:	c7 45 90 ff ff 0f 00 	movl   $0xfffff,-0x70(%ebp)
		ptr = (char*)ptr_allocations[10];
f011cb55:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011cb5b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011cb5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cb65:	eb 0e                	jmp    f011cb75 <test_kfree_bestfirstfit+0xb67>
		{
			ptr[i] = 10 ;
f011cb67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011cb6a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011cb6d:	01 d0                	add    %edx,%eax
f011cb6f:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011cb72:	ff 45 f4             	incl   -0xc(%ebp)
f011cb75:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cb78:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011cb7b:	7f ea                	jg     f011cb67 <test_kfree_bestfirstfit+0xb59>
		{
			ptr[i] = 10 ;
		}

		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011cb7d:	e8 5b 0e ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cb82:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cb85:	e8 8b 7c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cb8a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011cb8d:	83 ec 0c             	sub    $0xc,%esp
f011cb90:	68 00 04 00 00       	push   $0x400
f011cb95:	e8 f1 be fe ff       	call   f0108a8b <kmalloc>
f011cb9a:	83 c4 10             	add    $0x10,%esp
f011cb9d:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((ptr_allocations[9] < ptr_allocations[2]) || (ptr_allocations[9] > (ptr_allocations[2] + 1*kilo)))
f011cba3:	8b 95 ec fe ff ff    	mov    -0x114(%ebp),%edx
f011cba9:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011cbaf:	39 c2                	cmp    %eax,%edx
f011cbb1:	72 16                	jb     f011cbc9 <test_kfree_bestfirstfit+0xbbb>
f011cbb3:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011cbb9:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011cbbf:	81 c2 00 04 00 00    	add    $0x400,%edx
f011cbc5:	39 d0                	cmp    %edx,%eax
f011cbc7:	76 17                	jbe    f011cbe0 <test_kfree_bestfirstfit+0xbd2>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011cbc9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cbd0:	83 ec 0c             	sub    $0xc,%esp
f011cbd3:	68 b0 ef 12 f0       	push   $0xf012efb0
f011cbd8:	e8 8f 43 fe ff       	call   f0100f6c <cprintf>
f011cbdd:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cbe0:	e8 30 7c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cbe5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cbe8:	74 17                	je     f011cc01 <test_kfree_bestfirstfit+0xbf3>
f011cbea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cbf1:	83 ec 0c             	sub    $0xc,%esp
f011cbf4:	68 00 ef 12 f0       	push   $0xf012ef00
f011cbf9:	e8 6e 43 fe ff       	call   f0100f6c <cprintf>
f011cbfe:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011cc01:	e8 d7 0d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cc06:	89 c2                	mov    %eax,%edx
f011cc08:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cc0b:	39 c2                	cmp    %eax,%edx
f011cc0d:	74 17                	je     f011cc26 <test_kfree_bestfirstfit+0xc18>
f011cc0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cc16:	83 ec 0c             	sub    $0xc,%esp
f011cc19:	68 70 f3 12 f0       	push   $0xf012f370
f011cc1e:	e8 49 43 fe ff       	call   f0100f6c <cprintf>
f011cc23:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011cc26:	c7 45 8c ff 03 00 00 	movl   $0x3ff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[9];
f011cc2d:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011cc33:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011cc36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cc3d:	eb 0e                	jmp    f011cc4d <test_kfree_bestfirstfit+0xc3f>
		{
			ptr[i] = 9 ;
f011cc3f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011cc42:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011cc45:	01 d0                	add    %edx,%eax
f011cc47:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011cc4a:	ff 45 f4             	incl   -0xc(%ebp)
f011cc4d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011cc50:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011cc53:	7f ea                	jg     f011cc3f <test_kfree_bestfirstfit+0xc31>
		{
			ptr[i] = 9 ;
		}

	}
	if (correct)	eval+=15 ;
f011cc55:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011cc59:	74 04                	je     f011cc5f <test_kfree_bestfirstfit+0xc51>
f011cc5b:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011cc5f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	{
		//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
		freeFrames = sys_calculate_free_frames() ;
f011cc66:	e8 72 0d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cc6b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cc6e:	e8 a2 7b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cc73:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[5]);
f011cc76:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011cc7c:	83 ec 0c             	sub    $0xc,%esp
f011cc7f:	50                   	push   %eax
f011cc80:	e8 20 be fe ff       	call   f0108aa5 <kfree>
f011cc85:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cc88:	e8 88 7b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cc8d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cc90:	74 17                	je     f011cca9 <test_kfree_bestfirstfit+0xc9b>
f011cc92:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cc99:	83 ec 0c             	sub    $0xc,%esp
f011cc9c:	68 00 ef 12 f0       	push   $0xf012ef00
f011cca1:	e8 c6 42 fe ff       	call   f0100f6c <cprintf>
f011cca6:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011cca9:	e8 2f 0d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ccae:	89 c2                	mov    %eax,%edx
f011ccb0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ccb3:	29 c2                	sub    %eax,%edx
f011ccb5:	89 d0                	mov    %edx,%eax
f011ccb7:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011ccbc:	77 17                	ja     f011ccd5 <test_kfree_bestfirstfit+0xcc7>
f011ccbe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ccc5:	83 ec 0c             	sub    $0xc,%esp
f011ccc8:	68 04 f3 12 f0       	push   $0xf012f304
f011cccd:	e8 9a 42 fe ff       	call   f0100f6c <cprintf>
f011ccd2:	83 c4 10             	add    $0x10,%esp

		//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
		freeFrames = sys_calculate_free_frames() ;
f011ccd5:	e8 03 0d ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ccda:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ccdd:	e8 33 7b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cce2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[4]);
f011cce5:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011cceb:	83 ec 0c             	sub    $0xc,%esp
f011ccee:	50                   	push   %eax
f011ccef:	e8 b1 bd fe ff       	call   f0108aa5 <kfree>
f011ccf4:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ccf7:	e8 19 7b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ccfc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ccff:	74 17                	je     f011cd18 <test_kfree_bestfirstfit+0xd0a>
f011cd01:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cd08:	83 ec 0c             	sub    $0xc,%esp
f011cd0b:	68 00 ef 12 f0       	push   $0xf012ef00
f011cd10:	e8 57 42 fe ff       	call   f0100f6c <cprintf>
f011cd15:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011cd18:	e8 c0 0c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cd1d:	89 c2                	mov    %eax,%edx
f011cd1f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cd22:	29 c2                	sub    %eax,%edx
f011cd24:	89 d0                	mov    %edx,%eax
f011cd26:	83 f8 01             	cmp    $0x1,%eax
f011cd29:	77 17                	ja     f011cd42 <test_kfree_bestfirstfit+0xd34>
f011cd2b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cd32:	83 ec 0c             	sub    $0xc,%esp
f011cd35:	68 04 f3 12 f0       	push   $0xf012f304
f011cd3a:	e8 2d 42 fe ff       	call   f0100f6c <cprintf>
f011cd3f:	83 c4 10             	add    $0x10,%esp

		//kfree 1 KB [DYNAMIC ALLOCATOR]
		freeFrames = sys_calculate_free_frames() ;
f011cd42:	e8 96 0c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cd47:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cd4a:	e8 c6 7a fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cd4f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[9]);
f011cd52:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011cd58:	83 ec 0c             	sub    $0xc,%esp
f011cd5b:	50                   	push   %eax
f011cd5c:	e8 44 bd fe ff       	call   f0108aa5 <kfree>
f011cd61:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cd64:	e8 ac 7a fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cd69:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cd6c:	74 17                	je     f011cd85 <test_kfree_bestfirstfit+0xd77>
f011cd6e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cd75:	83 ec 0c             	sub    $0xc,%esp
f011cd78:	68 00 ef 12 f0       	push   $0xf012ef00
f011cd7d:	e8 ea 41 fe ff       	call   f0100f6c <cprintf>
f011cd82:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011cd85:	e8 53 0c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cd8a:	89 c2                	mov    %eax,%edx
f011cd8c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cd8f:	39 c2                	cmp    %eax,%edx
f011cd91:	74 17                	je     f011cdaa <test_kfree_bestfirstfit+0xd9c>
f011cd93:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cd9a:	83 ec 0c             	sub    $0xc,%esp
f011cd9d:	68 04 f3 12 f0       	push   $0xf012f304
f011cda2:	e8 c5 41 fe ff       	call   f0100f6c <cprintf>
f011cda7:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
		freeFrames = sys_calculate_free_frames() ;
f011cdaa:	e8 2e 0c ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cdaf:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cdb2:	e8 5e 7a fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cdb7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[3]);
f011cdba:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011cdc0:	83 ec 0c             	sub    $0xc,%esp
f011cdc3:	50                   	push   %eax
f011cdc4:	e8 dc bc fe ff       	call   f0108aa5 <kfree>
f011cdc9:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cdcc:	e8 44 7a fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cdd1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cdd4:	74 17                	je     f011cded <test_kfree_bestfirstfit+0xddf>
f011cdd6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cddd:	83 ec 0c             	sub    $0xc,%esp
f011cde0:	68 00 ef 12 f0       	push   $0xf012ef00
f011cde5:	e8 82 41 fe ff       	call   f0100f6c <cprintf>
f011cdea:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011cded:	e8 eb 0b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cdf2:	89 c2                	mov    %eax,%edx
f011cdf4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cdf7:	39 c2                	cmp    %eax,%edx
f011cdf9:	74 17                	je     f011ce12 <test_kfree_bestfirstfit+0xe04>
f011cdfb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ce02:	83 ec 0c             	sub    $0xc,%esp
f011ce05:	68 0c f2 12 f0       	push   $0xf012f20c
f011ce0a:	e8 5d 41 fe ff       	call   f0100f6c <cprintf>
f011ce0f:	83 c4 10             	add    $0x10,%esp

		//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
		freeFrames = sys_calculate_free_frames() ;
f011ce12:	e8 c6 0b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ce17:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ce1a:	e8 f6 79 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ce1f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[7]);
f011ce22:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011ce28:	83 ec 0c             	sub    $0xc,%esp
f011ce2b:	50                   	push   %eax
f011ce2c:	e8 74 bc fe ff       	call   f0108aa5 <kfree>
f011ce31:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ce34:	e8 dc 79 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ce39:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ce3c:	74 17                	je     f011ce55 <test_kfree_bestfirstfit+0xe47>
f011ce3e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ce45:	83 ec 0c             	sub    $0xc,%esp
f011ce48:	68 00 ef 12 f0       	push   $0xf012ef00
f011ce4d:	e8 1a 41 fe ff       	call   f0100f6c <cprintf>
f011ce52:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011ce55:	e8 83 0b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ce5a:	89 c2                	mov    %eax,%edx
f011ce5c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ce5f:	29 c2                	sub    %eax,%edx
f011ce61:	89 d0                	mov    %edx,%eax
f011ce63:	83 f8 03             	cmp    $0x3,%eax
f011ce66:	77 17                	ja     f011ce7f <test_kfree_bestfirstfit+0xe71>
f011ce68:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ce6f:	83 ec 0c             	sub    $0xc,%esp
f011ce72:	68 04 f3 12 f0       	push   $0xf012f304
f011ce77:	e8 f0 40 fe ff       	call   f0100f6c <cprintf>
f011ce7c:	83 c4 10             	add    $0x10,%esp

		//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
		freeFrames = sys_calculate_free_frames() ;
f011ce7f:	e8 59 0b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011ce84:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ce87:	e8 89 79 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ce8c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[10]);
f011ce8f:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011ce95:	83 ec 0c             	sub    $0xc,%esp
f011ce98:	50                   	push   %eax
f011ce99:	e8 07 bc fe ff       	call   f0108aa5 <kfree>
f011ce9e:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cea1:	e8 6f 79 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cea6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cea9:	74 17                	je     f011cec2 <test_kfree_bestfirstfit+0xeb4>
f011ceab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ceb2:	83 ec 0c             	sub    $0xc,%esp
f011ceb5:	68 00 ef 12 f0       	push   $0xf012ef00
f011ceba:	e8 ad 40 fe ff       	call   f0100f6c <cprintf>
f011cebf:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011cec2:	e8 16 0b ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cec7:	89 c2                	mov    %eax,%edx
f011cec9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cecc:	29 c2                	sub    %eax,%edx
f011cece:	89 d0                	mov    %edx,%eax
f011ced0:	3d ff 00 00 00       	cmp    $0xff,%eax
f011ced5:	77 17                	ja     f011ceee <test_kfree_bestfirstfit+0xee0>
f011ced7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cede:	83 ec 0c             	sub    $0xc,%esp
f011cee1:	68 04 f3 12 f0       	push   $0xf012f304
f011cee6:	e8 81 40 fe ff       	call   f0100f6c <cprintf>
f011ceeb:	83 c4 10             	add    $0x10,%esp

		//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
		freeFrames = sys_calculate_free_frames() ;
f011ceee:	e8 ea 0a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cef3:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cef6:	e8 1a 79 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cefb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[8]);
f011cefe:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011cf04:	83 ec 0c             	sub    $0xc,%esp
f011cf07:	50                   	push   %eax
f011cf08:	e8 98 bb fe ff       	call   f0108aa5 <kfree>
f011cf0d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cf10:	e8 00 79 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011cf15:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011cf18:	74 17                	je     f011cf31 <test_kfree_bestfirstfit+0xf23>
f011cf1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cf21:	83 ec 0c             	sub    $0xc,%esp
f011cf24:	68 00 ef 12 f0       	push   $0xf012ef00
f011cf29:	e8 3e 40 fe ff       	call   f0100f6c <cprintf>
f011cf2e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011cf31:	e8 a7 0a ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011cf36:	89 c2                	mov    %eax,%edx
f011cf38:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cf3b:	29 c2                	sub    %eax,%edx
f011cf3d:	89 d0                	mov    %edx,%eax
f011cf3f:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011cf44:	77 17                	ja     f011cf5d <test_kfree_bestfirstfit+0xf4f>
f011cf46:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cf4d:	83 ec 0c             	sub    $0xc,%esp
f011cf50:	68 04 f3 12 f0       	push   $0xf012f304
f011cf55:	e8 12 40 fe ff       	call   f0100f6c <cprintf>
f011cf5a:	83 c4 10             	add    $0x10,%esp

		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011cf5d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011cf61:	74 04                	je     f011cf67 <test_kfree_bestfirstfit+0xf59>
f011cf63:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011cf67:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access after kfree [15%]
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011cf6e:	83 ec 0c             	sub    $0xc,%esp
f011cf71:	6a 03                	push   $0x3
f011cf73:	e8 7c 0e ff ff       	call   f010ddf4 <sys_bypassPageFault>
f011cf78:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011cf7b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cf82:	e9 af 00 00 00       	jmp    f011d036 <test_kfree_bestfirstfit+0x1028>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011cf87:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011cf8b:	0f 84 a1 00 00 00    	je     f011d032 <test_kfree_bestfirstfit+0x1024>
f011cf91:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011cf95:	0f 84 97 00 00 00    	je     f011d032 <test_kfree_bestfirstfit+0x1024>
f011cf9b:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011cf9f:	0f 84 8d 00 00 00    	je     f011d032 <test_kfree_bestfirstfit+0x1024>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011cfa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011cfa8:	8b 84 85 c8 fe ff ff 	mov    -0x138(%ebp,%eax,4),%eax
f011cfaf:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011cfb2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011cfb5:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011cfb8:	e8 25 0e ff ff       	call   f010dde2 <sys_rcr2>
f011cfbd:	89 c2                	mov    %eax,%edx
f011cfbf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011cfc2:	39 c2                	cmp    %eax,%edx
f011cfc4:	74 1d                	je     f011cfe3 <test_kfree_bestfirstfit+0xfd5>
				if (correct)
f011cfc6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011cfca:	74 17                	je     f011cfe3 <test_kfree_bestfirstfit+0xfd5>
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
f011cfcc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cfd3:	83 ec 0c             	sub    $0xc,%esp
f011cfd6:	68 e8 f3 12 f0       	push   $0xf012f3e8
f011cfdb:	e8 8c 3f fe ff       	call   f0100f6c <cprintf>
f011cfe0:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011cfe3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011cfe6:	8b 84 85 68 ff ff ff 	mov    -0x98(%ebp,%eax,4),%eax
f011cfed:	89 c2                	mov    %eax,%edx
f011cfef:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011cff2:	01 d0                	add    %edx,%eax
f011cff4:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011cff7:	e8 e6 0d ff ff       	call   f010dde2 <sys_rcr2>
f011cffc:	89 c2                	mov    %eax,%edx
f011cffe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d001:	8b 84 85 68 ff ff ff 	mov    -0x98(%ebp,%eax,4),%eax
f011d008:	89 c1                	mov    %eax,%ecx
f011d00a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d00d:	01 c8                	add    %ecx,%eax
f011d00f:	39 c2                	cmp    %eax,%edx
f011d011:	74 20                	je     f011d033 <test_kfree_bestfirstfit+0x1025>
				if (correct)
f011d013:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d017:	74 1a                	je     f011d033 <test_kfree_bestfirstfit+0x1025>
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
f011d019:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d020:	83 ec 0c             	sub    $0xc,%esp
f011d023:	68 e8 f3 12 f0       	push   $0xf012f3e8
f011d028:	e8 3f 3f fe ff       	call   f0100f6c <cprintf>
f011d02d:	83 c4 10             	add    $0x10,%esp
f011d030:	eb 01                	jmp    f011d033 <test_kfree_bestfirstfit+0x1025>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011d032:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011d033:	ff 45 f4             	incl   -0xc(%ebp)
f011d036:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011d03a:	0f 8e 47 ff ff ff    	jle    f011cf87 <test_kfree_bestfirstfit+0xf79>
				if (correct)
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011d040:	83 ec 0c             	sub    $0xc,%esp
f011d043:	6a 00                	push   $0x0
f011d045:	e8 aa 0d ff ff       	call   f010ddf4 <sys_bypassPageFault>
f011d04a:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011d04d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d051:	74 04                	je     f011d057 <test_kfree_bestfirstfit+0x1049>
f011d053:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011d057:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	//Allocate after kfree ALL [30%]
	{
		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//1 KB
		freeFrames = sys_calculate_free_frames() ;
f011d05e:	e8 7a 09 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d063:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d066:	e8 aa 77 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d06b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[11] = kmalloc(1*kilo);
f011d06e:	83 ec 0c             	sub    $0xc,%esp
f011d071:	68 00 04 00 00       	push   $0x400
f011d076:	e8 10 ba fe ff       	call   f0108a8b <kmalloc>
f011d07b:	83 c4 10             	add    $0x10,%esp
f011d07e:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
		if ((ptr_allocations[11] < ptr_allocations[2]) || (ptr_allocations[11] > (ptr_allocations[2] + 1*kilo)))
f011d084:	8b 95 f4 fe ff ff    	mov    -0x10c(%ebp),%edx
f011d08a:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011d090:	39 c2                	cmp    %eax,%edx
f011d092:	72 16                	jb     f011d0aa <test_kfree_bestfirstfit+0x109c>
f011d094:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011d09a:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d0a0:	81 c2 00 04 00 00    	add    $0x400,%edx
f011d0a6:	39 d0                	cmp    %edx,%eax
f011d0a8:	76 17                	jbe    f011d0c1 <test_kfree_bestfirstfit+0x10b3>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011d0aa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d0b1:	83 ec 0c             	sub    $0xc,%esp
f011d0b4:	68 b0 ef 12 f0       	push   $0xf012efb0
f011d0b9:	e8 ae 3e fe ff       	call   f0100f6c <cprintf>
f011d0be:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d0c1:	e8 4f 77 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d0c6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011d0c9:	74 17                	je     f011d0e2 <test_kfree_bestfirstfit+0x10d4>
f011d0cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d0d2:	83 ec 0c             	sub    $0xc,%esp
f011d0d5:	68 00 ef 12 f0       	push   $0xf012ef00
f011d0da:	e8 8d 3e fe ff       	call   f0100f6c <cprintf>
f011d0df:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011d0e2:	e8 f6 08 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d0e7:	89 c2                	mov    %eax,%edx
f011d0e9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d0ec:	39 c2                	cmp    %eax,%edx
f011d0ee:	74 17                	je     f011d107 <test_kfree_bestfirstfit+0x10f9>
f011d0f0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d0f7:	83 ec 0c             	sub    $0xc,%esp
f011d0fa:	68 70 f3 12 f0       	push   $0xf012f370
f011d0ff:	e8 68 3e fe ff       	call   f0100f6c <cprintf>
f011d104:	83 c4 10             	add    $0x10,%esp
		lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011d107:	c7 45 94 ff 03 00 00 	movl   $0x3ff,-0x6c(%ebp)
		ptr = (char*)ptr_allocations[11];
f011d10e:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011d114:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[11]; ++i)
f011d117:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d11e:	eb 0e                	jmp    f011d12e <test_kfree_bestfirstfit+0x1120>
		{
			ptr[i] = 11 ;
f011d120:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d123:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d126:	01 d0                	add    %edx,%eax
f011d128:	c6 00 0b             	movb   $0xb,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[11] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[11];
		for (i = 0; i < lastIndices[11]; ++i)
f011d12b:	ff 45 f4             	incl   -0xc(%ebp)
f011d12e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011d131:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d134:	7f ea                	jg     f011d120 <test_kfree_bestfirstfit+0x1112>
			ptr[i] = 11 ;
		}

		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f011d136:	e8 a2 08 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d13b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d13e:	e8 d2 76 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d143:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[12] = kmalloc(2*kilo);
f011d146:	83 ec 0c             	sub    $0xc,%esp
f011d149:	68 00 08 00 00       	push   $0x800
f011d14e:	e8 38 b9 fe ff       	call   f0108a8b <kmalloc>
f011d153:	83 c4 10             	add    $0x10,%esp
f011d156:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
		//expected = ptr_allocations[2] + 1*kilo + sizeOfMetaData();
		//if (ptr_allocations[12] != expected)
		if ((ptr_allocations[12] < ptr_allocations[2] + 1*kilo) || (ptr_allocations[12] > (ptr_allocations[2] + 2*kilo)))
f011d15c:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011d162:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d168:	81 c2 00 04 00 00    	add    $0x400,%edx
f011d16e:	39 d0                	cmp    %edx,%eax
f011d170:	72 16                	jb     f011d188 <test_kfree_bestfirstfit+0x117a>
f011d172:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011d178:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d17e:	81 c2 00 08 00 00    	add    $0x800,%edx
f011d184:	39 d0                	cmp    %edx,%eax
f011d186:	76 35                	jbe    f011d1bd <test_kfree_bestfirstfit+0x11af>
		{
			correct = 0;
f011d188:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
			cprintf("Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011d18f:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011d195:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d19b:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011d1a1:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d1a7:	81 c2 00 04 00 00    	add    $0x400,%edx
f011d1ad:	50                   	push   %eax
f011d1ae:	51                   	push   %ecx
f011d1af:	52                   	push   %edx
f011d1b0:	68 30 f4 12 f0       	push   $0xf012f430
f011d1b5:	e8 b2 3d fe ff       	call   f0100f6c <cprintf>
f011d1ba:	83 c4 10             	add    $0x10,%esp
		}
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d1bd:	e8 53 76 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d1c2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011d1c5:	74 17                	je     f011d1de <test_kfree_bestfirstfit+0x11d0>
f011d1c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d1ce:	83 ec 0c             	sub    $0xc,%esp
f011d1d1:	68 00 ef 12 f0       	push   $0xf012ef00
f011d1d6:	e8 91 3d fe ff       	call   f0100f6c <cprintf>
f011d1db:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011d1de:	e8 fa 07 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d1e3:	89 c2                	mov    %eax,%edx
f011d1e5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d1e8:	39 c2                	cmp    %eax,%edx
f011d1ea:	74 17                	je     f011d203 <test_kfree_bestfirstfit+0x11f5>
f011d1ec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d1f3:	83 ec 0c             	sub    $0xc,%esp
f011d1f6:	68 70 f3 12 f0       	push   $0xf012f370
f011d1fb:	e8 6c 3d fe ff       	call   f0100f6c <cprintf>
f011d200:	83 c4 10             	add    $0x10,%esp
		lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011d203:	c7 45 98 ff 07 00 00 	movl   $0x7ff,-0x68(%ebp)
		ptr = (char*)ptr_allocations[12];
f011d20a:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011d210:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[12]; ++i)
f011d213:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d21a:	eb 0e                	jmp    f011d22a <test_kfree_bestfirstfit+0x121c>
		{
			ptr[i] = 12 ;
f011d21c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d21f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d222:	01 d0                	add    %edx,%eax
f011d224:	c6 00 0c             	movb   $0xc,(%eax)
		}
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[12] = (2*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[12];
		for (i = 0; i < lastIndices[12]; ++i)
f011d227:	ff 45 f4             	incl   -0xc(%ebp)
f011d22a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011d22d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d230:	7f ea                	jg     f011d21c <test_kfree_bestfirstfit+0x120e>
			ptr[i] = 12 ;
		}

		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//1.5 KB
		freeFrames = sys_calculate_free_frames() ;
f011d232:	e8 a6 07 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d237:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d23a:	e8 d6 75 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d23f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[13] = kmalloc(3*kilo/2);
f011d242:	83 ec 0c             	sub    $0xc,%esp
f011d245:	68 00 06 00 00       	push   $0x600
f011d24a:	e8 3c b8 fe ff       	call   f0108a8b <kmalloc>
f011d24f:	83 c4 10             	add    $0x10,%esp
f011d252:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
		//if (ptr_allocations[13] != ptr_allocations[12] + 2*kilo + sizeOfMetaData())
		if ((ptr_allocations[13] < ptr_allocations[2] + 3*kilo) || (ptr_allocations[13] > (ptr_allocations[2] + 4*kilo)))
f011d258:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011d25e:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d264:	81 c2 00 0c 00 00    	add    $0xc00,%edx
f011d26a:	39 d0                	cmp    %edx,%eax
f011d26c:	72 16                	jb     f011d284 <test_kfree_bestfirstfit+0x1276>
f011d26e:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011d274:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011d27a:	81 c2 00 10 00 00    	add    $0x1000,%edx
f011d280:	39 d0                	cmp    %edx,%eax
f011d282:	76 17                	jbe    f011d29b <test_kfree_bestfirstfit+0x128d>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011d284:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d28b:	83 ec 0c             	sub    $0xc,%esp
f011d28e:	68 b0 ef 12 f0       	push   $0xf012efb0
f011d293:	e8 d4 3c fe ff       	call   f0100f6c <cprintf>
f011d298:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d29b:	e8 75 75 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d2a0:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011d2a3:	74 17                	je     f011d2bc <test_kfree_bestfirstfit+0x12ae>
f011d2a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d2ac:	83 ec 0c             	sub    $0xc,%esp
f011d2af:	68 00 ef 12 f0       	push   $0xf012ef00
f011d2b4:	e8 b3 3c fe ff       	call   f0100f6c <cprintf>
f011d2b9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011d2bc:	e8 1c 07 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d2c1:	89 c2                	mov    %eax,%edx
f011d2c3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d2c6:	39 c2                	cmp    %eax,%edx
f011d2c8:	74 17                	je     f011d2e1 <test_kfree_bestfirstfit+0x12d3>
f011d2ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d2d1:	83 ec 0c             	sub    $0xc,%esp
f011d2d4:	68 70 f3 12 f0       	push   $0xf012f370
f011d2d9:	e8 8e 3c fe ff       	call   f0100f6c <cprintf>
f011d2de:	83 c4 10             	add    $0x10,%esp
		lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011d2e1:	c7 45 9c ff 05 00 00 	movl   $0x5ff,-0x64(%ebp)
		ptr = (char*)ptr_allocations[13];
f011d2e8:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011d2ee:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[13]; ++i)
f011d2f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d2f8:	eb 0e                	jmp    f011d308 <test_kfree_bestfirstfit+0x12fa>
		{
			ptr[i] = 13 ;
f011d2fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d2fd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d300:	01 d0                	add    %edx,%eax
f011d302:	c6 00 0d             	movb   $0xd,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[13];
		for (i = 0; i < lastIndices[13]; ++i)
f011d305:	ff 45 f4             	incl   -0xc(%ebp)
f011d308:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011d30b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d30e:	7f ea                	jg     f011d2fa <test_kfree_bestfirstfit+0x12ec>
			ptr[i] = 13 ;
		}

		//[PAGE ALLOCATOR] Allocate in merged freed space
		//30 MB
		freeFrames = sys_calculate_free_frames() ;
f011d310:	e8 c8 06 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d315:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d318:	e8 f8 74 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d31d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(30*Mega);
f011d320:	83 ec 0c             	sub    $0xc,%esp
f011d323:	68 00 00 e0 01       	push   $0x1e00000
f011d328:	e8 5e b7 fe ff       	call   f0108a8b <kmalloc>
f011d32d:	83 c4 10             	add    $0x10,%esp
f011d330:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011d336:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011d33c:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011d341:	74 17                	je     f011d35a <test_kfree_bestfirstfit+0x134c>
f011d343:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d34a:	83 ec 0c             	sub    $0xc,%esp
f011d34d:	68 b0 ef 12 f0       	push   $0xf012efb0
f011d352:	e8 15 3c fe ff       	call   f0100f6c <cprintf>
f011d357:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d35a:	e8 b6 74 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d35f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011d362:	74 17                	je     f011d37b <test_kfree_bestfirstfit+0x136d>
f011d364:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d36b:	83 ec 0c             	sub    $0xc,%esp
f011d36e:	68 00 ef 12 f0       	push   $0xf012ef00
f011d373:	e8 f4 3b fe ff       	call   f0100f6c <cprintf>
f011d378:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011d37b:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011d37e:	e8 5a 06 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d383:	29 c3                	sub    %eax,%ebx
f011d385:	89 d8                	mov    %ebx,%eax
f011d387:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011d38c:	77 17                	ja     f011d3a5 <test_kfree_bestfirstfit+0x1397>
f011d38e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d395:	83 ec 0c             	sub    $0xc,%esp
f011d398:	68 6c ef 12 f0       	push   $0xf012ef6c
f011d39d:	e8 ca 3b fe ff       	call   f0100f6c <cprintf>
f011d3a2:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011d3a5:	c7 45 90 ff ff df 01 	movl   $0x1dfffff,-0x70(%ebp)
		ptr = (char*)ptr_allocations[10];
f011d3ac:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011d3b2:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011d3b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d3bc:	eb 0e                	jmp    f011d3cc <test_kfree_bestfirstfit+0x13be>
		{
			ptr[i] = 10 ;
f011d3be:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d3c1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d3c4:	01 d0                	add    %edx,%eax
f011d3c6:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (30*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011d3c9:	ff 45 f4             	incl   -0xc(%ebp)
f011d3cc:	8b 45 90             	mov    -0x70(%ebp),%eax
f011d3cf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d3d2:	7f ea                	jg     f011d3be <test_kfree_bestfirstfit+0x13b0>
			ptr[i] = 10 ;
		}


		//30 MB
		ptr = (char*)ptr_allocations[10];
f011d3d4:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011d3da:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011d3dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d3e4:	eb 1e                	jmp    f011d404 <test_kfree_bestfirstfit+0x13f6>
		{
			sums[10] += ptr[i] ;
f011d3e6:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011d3ec:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011d3ef:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d3f2:	01 c8                	add    %ecx,%eax
f011d3f4:	8a 00                	mov    (%eax),%al
f011d3f6:	0f be c0             	movsbl %al,%eax
f011d3f9:	01 d0                	add    %edx,%eax
f011d3fb:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		}


		//30 MB
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011d401:	ff 45 f4             	incl   -0xc(%ebp)
f011d404:	8b 45 90             	mov    -0x70(%ebp),%eax
f011d407:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d40a:	7f da                	jg     f011d3e6 <test_kfree_bestfirstfit+0x13d8>
		{
			sums[10] += ptr[i] ;
		}
		if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011d40c:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011d412:	8b 55 90             	mov    -0x70(%ebp),%edx
f011d415:	89 d0                	mov    %edx,%eax
f011d417:	c1 e0 02             	shl    $0x2,%eax
f011d41a:	01 d0                	add    %edx,%eax
f011d41c:	01 c0                	add    %eax,%eax
f011d41e:	39 c1                	cmp    %eax,%ecx
f011d420:	74 17                	je     f011d439 <test_kfree_bestfirstfit+0x142b>
f011d422:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d429:	83 ec 0c             	sub    $0xc,%esp
f011d42c:	68 a0 f4 12 f0       	push   $0xf012f4a0
f011d431:	e8 36 3b fe ff       	call   f0100f6c <cprintf>
f011d436:	83 c4 10             	add    $0x10,%esp

		//1 KB
		ptr = (char*)ptr_allocations[11];
f011d439:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011d43f:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[11]; ++i)
f011d442:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d449:	eb 1e                	jmp    f011d469 <test_kfree_bestfirstfit+0x145b>
		{
			sums[11] += ptr[i] ;
f011d44b:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011d451:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011d454:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d457:	01 c8                	add    %ecx,%eax
f011d459:	8a 00                	mov    (%eax),%al
f011d45b:	0f be c0             	movsbl %al,%eax
f011d45e:	01 d0                	add    %edx,%eax
f011d460:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		}
		if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//1 KB
		ptr = (char*)ptr_allocations[11];
		for (i = 0; i < lastIndices[11]; ++i)
f011d466:	ff 45 f4             	incl   -0xc(%ebp)
f011d469:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011d46c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d46f:	7f da                	jg     f011d44b <test_kfree_bestfirstfit+0x143d>
		{
			sums[11] += ptr[i] ;
		}
		if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011d471:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011d477:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011d47a:	89 d0                	mov    %edx,%eax
f011d47c:	c1 e0 02             	shl    $0x2,%eax
f011d47f:	01 d0                	add    %edx,%eax
f011d481:	01 c0                	add    %eax,%eax
f011d483:	01 d0                	add    %edx,%eax
f011d485:	39 c1                	cmp    %eax,%ecx
f011d487:	74 17                	je     f011d4a0 <test_kfree_bestfirstfit+0x1492>
f011d489:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d490:	83 ec 0c             	sub    $0xc,%esp
f011d493:	68 a0 f4 12 f0       	push   $0xf012f4a0
f011d498:	e8 cf 3a fe ff       	call   f0100f6c <cprintf>
f011d49d:	83 c4 10             	add    $0x10,%esp

		//2 KB
		ptr = (char*)ptr_allocations[12];
f011d4a0:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011d4a6:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[12]; ++i)
f011d4a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d4b0:	eb 1e                	jmp    f011d4d0 <test_kfree_bestfirstfit+0x14c2>
		{
			sums[12] += ptr[i] ;
f011d4b2:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011d4b8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011d4bb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d4be:	01 c8                	add    %ecx,%eax
f011d4c0:	8a 00                	mov    (%eax),%al
f011d4c2:	0f be c0             	movsbl %al,%eax
f011d4c5:	01 d0                	add    %edx,%eax
f011d4c7:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		}
		if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//2 KB
		ptr = (char*)ptr_allocations[12];
		for (i = 0; i < lastIndices[12]; ++i)
f011d4cd:	ff 45 f4             	incl   -0xc(%ebp)
f011d4d0:	8b 45 98             	mov    -0x68(%ebp),%eax
f011d4d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d4d6:	7f da                	jg     f011d4b2 <test_kfree_bestfirstfit+0x14a4>
		{
			sums[12] += ptr[i] ;
		}
		if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011d4d8:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011d4de:	8b 55 98             	mov    -0x68(%ebp),%edx
f011d4e1:	89 d0                	mov    %edx,%eax
f011d4e3:	01 c0                	add    %eax,%eax
f011d4e5:	01 d0                	add    %edx,%eax
f011d4e7:	c1 e0 02             	shl    $0x2,%eax
f011d4ea:	39 c1                	cmp    %eax,%ecx
f011d4ec:	74 17                	je     f011d505 <test_kfree_bestfirstfit+0x14f7>
f011d4ee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d4f5:	83 ec 0c             	sub    $0xc,%esp
f011d4f8:	68 a0 f4 12 f0       	push   $0xf012f4a0
f011d4fd:	e8 6a 3a fe ff       	call   f0100f6c <cprintf>
f011d502:	83 c4 10             	add    $0x10,%esp

		//1.5 KB
		ptr = (char*)ptr_allocations[13];
f011d505:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011d50b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[13]; ++i)
f011d50e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d515:	eb 1e                	jmp    f011d535 <test_kfree_bestfirstfit+0x1527>
		{
			sums[13] += ptr[i] ;
f011d517:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f011d51d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011d520:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d523:	01 c8                	add    %ecx,%eax
f011d525:	8a 00                	mov    (%eax),%al
f011d527:	0f be c0             	movsbl %al,%eax
f011d52a:	01 d0                	add    %edx,%eax
f011d52c:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		}
		if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//1.5 KB
		ptr = (char*)ptr_allocations[13];
		for (i = 0; i < lastIndices[13]; ++i)
f011d532:	ff 45 f4             	incl   -0xc(%ebp)
f011d535:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011d538:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d53b:	7f da                	jg     f011d517 <test_kfree_bestfirstfit+0x1509>
		{
			sums[13] += ptr[i] ;
		}
		if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011d53d:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f011d543:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011d546:	89 d0                	mov    %edx,%eax
f011d548:	01 c0                	add    %eax,%eax
f011d54a:	01 d0                	add    %edx,%eax
f011d54c:	c1 e0 02             	shl    $0x2,%eax
f011d54f:	01 d0                	add    %edx,%eax
f011d551:	39 c1                	cmp    %eax,%ecx
f011d553:	74 17                	je     f011d56c <test_kfree_bestfirstfit+0x155e>
f011d555:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d55c:	83 ec 0c             	sub    $0xc,%esp
f011d55f:	68 a0 f4 12 f0       	push   $0xf012f4a0
f011d564:	e8 03 3a fe ff       	call   f0100f6c <cprintf>
f011d569:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f011d56c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d570:	74 04                	je     f011d576 <test_kfree_bestfirstfit+0x1568>
f011d572:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011d576:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011d57d:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011d584:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d58b:	eb 4e                	jmp    f011d5db <test_kfree_bestfirstfit+0x15cd>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011d58d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011d590:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f011d595:	83 ec 04             	sub    $0x4,%esp
f011d598:	8d 8d c4 fe ff ff    	lea    -0x13c(%ebp),%ecx
f011d59e:	51                   	push   %ecx
f011d59f:	52                   	push   %edx
f011d5a0:	50                   	push   %eax
f011d5a1:	e8 3c ae fe ff       	call   f01083e2 <get_page_table>
f011d5a6:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011d5a9:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011d5af:	85 c0                	test   %eax,%eax
f011d5b1:	75 1d                	jne    f011d5d0 <test_kfree_bestfirstfit+0x15c2>
			{
				if (correct)
f011d5b3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d5b7:	74 17                	je     f011d5d0 <test_kfree_bestfirstfit+0x15c2>
				{ correct = 0; cprintf("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011d5b9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d5c0:	83 ec 0c             	sub    $0xc,%esp
f011d5c3:	68 cc f4 12 f0       	push   $0xf012f4cc
f011d5c8:	e8 9f 39 fe ff       	call   f0100f6c <cprintf>
f011d5cd:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//check tables	[5%]
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011d5d0:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011d5d7:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011d5db:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d5df:	78 ac                	js     f011d58d <test_kfree_bestfirstfit+0x157f>
f011d5e1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d5e5:	7f 09                	jg     f011d5f0 <test_kfree_bestfirstfit+0x15e2>
f011d5e7:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011d5ee:	76 9d                	jbe    f011d58d <test_kfree_bestfirstfit+0x157f>
				if (correct)
				{ correct = 0; cprintf("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011d5f0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d5f4:	74 04                	je     f011d5fa <test_kfree_bestfirstfit+0x15ec>
f011d5f6:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011d5fa:	83 ec 08             	sub    $0x8,%esp
f011d5fd:	ff 75 f0             	pushl  -0x10(%ebp)
f011d600:	68 34 f5 12 f0       	push   $0xf012f534
f011d605:	e8 62 39 fe ff       	call   f0100f6c <cprintf>
f011d60a:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d60d:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011d612:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011d615:	5b                   	pop    %ebx
f011d616:	5f                   	pop    %edi
f011d617:	5d                   	pop    %ebp
f011d618:	c3                   	ret    

f011d619 <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011d619:	55                   	push   %ebp
f011d61a:	89 e5                	mov    %esp,%ebp
f011d61c:	57                   	push   %edi
f011d61d:	53                   	push   %ebx
f011d61e:	81 ec b0 35 00 00    	sub    $0x35b0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011d624:	83 ec 0c             	sub    $0xc,%esp
f011d627:	68 40 ee 12 f0       	push   $0xf012ee40
f011d62c:	e8 3b 39 fe ff       	call   f0100f6c <cprintf>
f011d631:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011d634:	83 ec 0c             	sub    $0xc,%esp
f011d637:	68 70 ee 12 f0       	push   $0xf012ee70
f011d63c:	e8 2b 39 fe ff       	call   f0100f6c <cprintf>
f011d641:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011d644:	83 ec 0c             	sub    $0xc,%esp
f011d647:	68 40 ee 12 f0       	push   $0xf012ee40
f011d64c:	e8 1b 39 fe ff       	call   f0100f6c <cprintf>
f011d651:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011d654:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011d658:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011d65c:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011d662:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011d668:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011d66f:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011d676:	e8 62 03 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d67b:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011d67e:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f011d684:	b9 14 00 00 00       	mov    $0x14,%ecx
f011d689:	b8 00 00 00 00       	mov    $0x0,%eax
f011d68e:	89 d7                	mov    %edx,%edi
f011d690:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011d692:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f011d698:	b9 14 00 00 00       	mov    $0x14,%ecx
f011d69d:	b8 00 00 00 00       	mov    $0x0,%eax
f011d6a2:	89 d7                	mov    %edx,%edi
f011d6a4:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011d6a6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011d6ad:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011d6b4:	8d 95 74 fe ff ff    	lea    -0x18c(%ebp),%edx
f011d6ba:	b9 14 00 00 00       	mov    $0x14,%ecx
f011d6bf:	b8 00 00 00 00       	mov    $0x0,%eax
f011d6c4:	89 d7                	mov    %edx,%edi
f011d6c6:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011d6c8:	e8 10 03 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d6cd:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d6d0:	e8 40 71 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d6d5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011d6d8:	83 ec 0c             	sub    $0xc,%esp
f011d6db:	68 00 fc 1f 00       	push   $0x1ffc00
f011d6e0:	e8 a6 b3 fe ff       	call   f0108a8b <kmalloc>
f011d6e5:	83 c4 10             	add    $0x10,%esp
f011d6e8:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011d6ee:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011d6f4:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011d6f9:	74 17                	je     f011d712 <test_kheap_phys_addr+0xf9>
f011d6fb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d702:	83 ec 0c             	sub    $0xc,%esp
f011d705:	68 b0 ef 12 f0       	push   $0xf012efb0
f011d70a:	e8 5d 38 fe ff       	call   f0100f6c <cprintf>
f011d70f:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d712:	e8 fe 70 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d717:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011d71a:	74 17                	je     f011d733 <test_kheap_phys_addr+0x11a>
f011d71c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d723:	83 ec 0c             	sub    $0xc,%esp
f011d726:	68 00 ef 12 f0       	push   $0xf012ef00
f011d72b:	e8 3c 38 fe ff       	call   f0100f6c <cprintf>
f011d730:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011d733:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011d736:	e8 a2 02 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d73b:	29 c3                	sub    %eax,%ebx
f011d73d:	89 d8                	mov    %ebx,%eax
f011d73f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011d744:	77 17                	ja     f011d75d <test_kheap_phys_addr+0x144>
f011d746:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d74d:	83 ec 0c             	sub    $0xc,%esp
f011d750:	68 6c ef 12 f0       	push   $0xf012ef6c
f011d755:	e8 12 38 fe ff       	call   f0100f6c <cprintf>
f011d75a:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011d75d:	e8 7b 02 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d762:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d765:	e8 ab 70 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d76a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011d76d:	83 ec 0c             	sub    $0xc,%esp
f011d770:	68 00 fc 1f 00       	push   $0x1ffc00
f011d775:	e8 11 b3 fe ff       	call   f0108a8b <kmalloc>
f011d77a:	83 c4 10             	add    $0x10,%esp
f011d77d:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011d783:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011d789:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011d78e:	74 17                	je     f011d7a7 <test_kheap_phys_addr+0x18e>
f011d790:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d797:	83 ec 0c             	sub    $0xc,%esp
f011d79a:	68 b0 ef 12 f0       	push   $0xf012efb0
f011d79f:	e8 c8 37 fe ff       	call   f0100f6c <cprintf>
f011d7a4:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d7a7:	e8 69 70 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d7ac:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011d7af:	74 17                	je     f011d7c8 <test_kheap_phys_addr+0x1af>
f011d7b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d7b8:	83 ec 0c             	sub    $0xc,%esp
f011d7bb:	68 00 ef 12 f0       	push   $0xf012ef00
f011d7c0:	e8 a7 37 fe ff       	call   f0100f6c <cprintf>
f011d7c5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011d7c8:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011d7cb:	e8 0d 02 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d7d0:	29 c3                	sub    %eax,%ebx
f011d7d2:	89 d8                	mov    %ebx,%eax
f011d7d4:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011d7d9:	77 17                	ja     f011d7f2 <test_kheap_phys_addr+0x1d9>
f011d7db:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d7e2:	83 ec 0c             	sub    $0xc,%esp
f011d7e5:	68 6c ef 12 f0       	push   $0xf012ef6c
f011d7ea:	e8 7d 37 fe ff       	call   f0100f6c <cprintf>
f011d7ef:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011d7f2:	e8 e6 01 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d7f7:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011d7fa:	e8 16 70 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d7ff:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011d802:	83 ec 0c             	sub    $0xc,%esp
f011d805:	68 00 04 00 00       	push   $0x400
f011d80a:	e8 7c b2 fe ff       	call   f0108a8b <kmalloc>
f011d80f:	83 c4 10             	add    $0x10,%esp
f011d812:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011d818:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011d81e:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011d823:	76 28                	jbe    f011d84d <test_kheap_phys_addr+0x234>
f011d825:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011d82b:	83 ec 0c             	sub    $0xc,%esp
f011d82e:	6a 00                	push   $0x0
f011d830:	e8 4c b2 fe ff       	call   f0108a81 <sbrk>
f011d835:	83 c4 10             	add    $0x10,%esp
f011d838:	39 c3                	cmp    %eax,%ebx
f011d83a:	73 11                	jae    f011d84d <test_kheap_phys_addr+0x234>
f011d83c:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011d842:	89 c2                	mov    %eax,%edx
f011d844:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011d849:	39 c2                	cmp    %eax,%edx
f011d84b:	72 17                	jb     f011d864 <test_kheap_phys_addr+0x24b>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011d84d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d854:	83 ec 0c             	sub    $0xc,%esp
f011d857:	68 00 f0 12 f0       	push   $0xf012f000
f011d85c:	e8 0b 37 fe ff       	call   f0100f6c <cprintf>
f011d861:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d864:	e8 ac 6f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d869:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011d86c:	74 17                	je     f011d885 <test_kheap_phys_addr+0x26c>
f011d86e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d875:	83 ec 0c             	sub    $0xc,%esp
f011d878:	68 00 ef 12 f0       	push   $0xf012ef00
f011d87d:	e8 ea 36 fe ff       	call   f0100f6c <cprintf>
f011d882:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011d885:	e8 53 01 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d88a:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011d88d:	e8 83 6f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d892:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011d895:	83 ec 0c             	sub    $0xc,%esp
f011d898:	68 00 08 00 00       	push   $0x800
f011d89d:	e8 e9 b1 fe ff       	call   f0108a8b <kmalloc>
f011d8a2:	83 c4 10             	add    $0x10,%esp
f011d8a5:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011d8ab:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011d8b1:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011d8b6:	76 28                	jbe    f011d8e0 <test_kheap_phys_addr+0x2c7>
f011d8b8:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011d8be:	83 ec 0c             	sub    $0xc,%esp
f011d8c1:	6a 00                	push   $0x0
f011d8c3:	e8 b9 b1 fe ff       	call   f0108a81 <sbrk>
f011d8c8:	83 c4 10             	add    $0x10,%esp
f011d8cb:	39 c3                	cmp    %eax,%ebx
f011d8cd:	73 11                	jae    f011d8e0 <test_kheap_phys_addr+0x2c7>
f011d8cf:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011d8d5:	89 c2                	mov    %eax,%edx
f011d8d7:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011d8dc:	39 c2                	cmp    %eax,%edx
f011d8de:	72 17                	jb     f011d8f7 <test_kheap_phys_addr+0x2de>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011d8e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d8e7:	83 ec 0c             	sub    $0xc,%esp
f011d8ea:	68 00 f0 12 f0       	push   $0xf012f000
f011d8ef:	e8 78 36 fe ff       	call   f0100f6c <cprintf>
f011d8f4:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d8f7:	e8 19 6f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d8fc:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011d8ff:	74 17                	je     f011d918 <test_kheap_phys_addr+0x2ff>
f011d901:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d908:	83 ec 0c             	sub    $0xc,%esp
f011d90b:	68 00 ef 12 f0       	push   $0xf012ef00
f011d910:	e8 57 36 fe ff       	call   f0100f6c <cprintf>
f011d915:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011d918:	e8 c0 00 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d91d:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011d920:	e8 f0 6e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d925:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011d928:	83 ec 0c             	sub    $0xc,%esp
f011d92b:	68 00 06 00 00       	push   $0x600
f011d930:	e8 56 b1 fe ff       	call   f0108a8b <kmalloc>
f011d935:	83 c4 10             	add    $0x10,%esp
f011d938:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011d93e:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011d944:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011d949:	76 28                	jbe    f011d973 <test_kheap_phys_addr+0x35a>
f011d94b:	8b 9d 84 fe ff ff    	mov    -0x17c(%ebp),%ebx
f011d951:	83 ec 0c             	sub    $0xc,%esp
f011d954:	6a 00                	push   $0x0
f011d956:	e8 26 b1 fe ff       	call   f0108a81 <sbrk>
f011d95b:	83 c4 10             	add    $0x10,%esp
f011d95e:	39 c3                	cmp    %eax,%ebx
f011d960:	73 11                	jae    f011d973 <test_kheap_phys_addr+0x35a>
f011d962:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011d968:	89 c2                	mov    %eax,%edx
f011d96a:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011d96f:	39 c2                	cmp    %eax,%edx
f011d971:	72 17                	jb     f011d98a <test_kheap_phys_addr+0x371>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011d973:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d97a:	83 ec 0c             	sub    $0xc,%esp
f011d97d:	68 00 f0 12 f0       	push   $0xf012f000
f011d982:	e8 e5 35 fe ff       	call   f0100f6c <cprintf>
f011d987:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d98a:	e8 86 6e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d98f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011d992:	74 17                	je     f011d9ab <test_kheap_phys_addr+0x392>
f011d994:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d99b:	83 ec 0c             	sub    $0xc,%esp
f011d99e:	68 00 ef 12 f0       	push   $0xf012ef00
f011d9a3:	e8 c4 35 fe ff       	call   f0100f6c <cprintf>
f011d9a8:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011d9ab:	e8 2d 00 ff ff       	call   f010d9dd <sys_calculate_free_frames>
f011d9b0:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011d9b3:	e8 5d 6e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d9b8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011d9bb:	83 ec 0c             	sub    $0xc,%esp
f011d9be:	68 00 1c 00 00       	push   $0x1c00
f011d9c3:	e8 c3 b0 fe ff       	call   f0108a8b <kmalloc>
f011d9c8:	83 c4 10             	add    $0x10,%esp
f011d9cb:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011d9d1:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011d9d7:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011d9dc:	74 17                	je     f011d9f5 <test_kheap_phys_addr+0x3dc>
f011d9de:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d9e5:	83 ec 0c             	sub    $0xc,%esp
f011d9e8:	68 b0 ef 12 f0       	push   $0xf012efb0
f011d9ed:	e8 7a 35 fe ff       	call   f0100f6c <cprintf>
f011d9f2:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d9f5:	e8 1b 6e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011d9fa:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011d9fd:	74 17                	je     f011da16 <test_kheap_phys_addr+0x3fd>
f011d9ff:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011da06:	83 ec 0c             	sub    $0xc,%esp
f011da09:	68 00 ef 12 f0       	push   $0xf012ef00
f011da0e:	e8 59 35 fe ff       	call   f0100f6c <cprintf>
f011da13:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011da16:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011da19:	e8 bf ff fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011da1e:	29 c3                	sub    %eax,%ebx
f011da20:	89 d8                	mov    %ebx,%eax
f011da22:	83 f8 01             	cmp    $0x1,%eax
f011da25:	77 17                	ja     f011da3e <test_kheap_phys_addr+0x425>
f011da27:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011da2e:	83 ec 0c             	sub    $0xc,%esp
f011da31:	68 6c ef 12 f0       	push   $0xf012ef6c
f011da36:	e8 31 35 fe ff       	call   f0100f6c <cprintf>
f011da3b:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011da3e:	e8 9a ff fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011da43:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011da46:	e8 ca 6d fe ff       	call   f0104815 <pf_calculate_free_frames>
f011da4b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011da4e:	83 ec 0c             	sub    $0xc,%esp
f011da51:	68 00 fc 2f 00       	push   $0x2ffc00
f011da56:	e8 30 b0 fe ff       	call   f0108a8b <kmalloc>
f011da5b:	83 c4 10             	add    $0x10,%esp
f011da5e:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011da64:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011da6a:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011da6f:	74 17                	je     f011da88 <test_kheap_phys_addr+0x46f>
f011da71:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011da78:	83 ec 0c             	sub    $0xc,%esp
f011da7b:	68 b0 ef 12 f0       	push   $0xf012efb0
f011da80:	e8 e7 34 fe ff       	call   f0100f6c <cprintf>
f011da85:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011da88:	e8 88 6d fe ff       	call   f0104815 <pf_calculate_free_frames>
f011da8d:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011da90:	74 17                	je     f011daa9 <test_kheap_phys_addr+0x490>
f011da92:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011da99:	83 ec 0c             	sub    $0xc,%esp
f011da9c:	68 00 ef 12 f0       	push   $0xf012ef00
f011daa1:	e8 c6 34 fe ff       	call   f0100f6c <cprintf>
f011daa6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011daa9:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011daac:	e8 2c ff fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011dab1:	29 c3                	sub    %eax,%ebx
f011dab3:	89 d8                	mov    %ebx,%eax
f011dab5:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011daba:	77 17                	ja     f011dad3 <test_kheap_phys_addr+0x4ba>
f011dabc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dac3:	83 ec 0c             	sub    $0xc,%esp
f011dac6:	68 6c ef 12 f0       	push   $0xf012ef6c
f011dacb:	e8 9c 34 fe ff       	call   f0100f6c <cprintf>
f011dad0:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011dad3:	e8 05 ff fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011dad8:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011dadb:	e8 35 6d fe ff       	call   f0104815 <pf_calculate_free_frames>
f011dae0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011dae3:	83 ec 0c             	sub    $0xc,%esp
f011dae6:	68 00 fc 5f 00       	push   $0x5ffc00
f011daeb:	e8 9b af fe ff       	call   f0108a8b <kmalloc>
f011daf0:	83 c4 10             	add    $0x10,%esp
f011daf3:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011daf9:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011daff:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011db04:	74 17                	je     f011db1d <test_kheap_phys_addr+0x504>
f011db06:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011db0d:	83 ec 0c             	sub    $0xc,%esp
f011db10:	68 b0 ef 12 f0       	push   $0xf012efb0
f011db15:	e8 52 34 fe ff       	call   f0100f6c <cprintf>
f011db1a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011db1d:	e8 f3 6c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011db22:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011db25:	74 17                	je     f011db3e <test_kheap_phys_addr+0x525>
f011db27:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011db2e:	83 ec 0c             	sub    $0xc,%esp
f011db31:	68 00 ef 12 f0       	push   $0xf012ef00
f011db36:	e8 31 34 fe ff       	call   f0100f6c <cprintf>
f011db3b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011db3e:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011db41:	e8 97 fe fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011db46:	29 c3                	sub    %eax,%ebx
f011db48:	89 d8                	mov    %ebx,%eax
f011db4a:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011db4f:	77 17                	ja     f011db68 <test_kheap_phys_addr+0x54f>
f011db51:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011db58:	83 ec 0c             	sub    $0xc,%esp
f011db5b:	68 6c ef 12 f0       	push   $0xf012ef6c
f011db60:	e8 07 34 fe ff       	call   f0100f6c <cprintf>
f011db65:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011db68:	e8 70 fe fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011db6d:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011db70:	e8 a0 6c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011db75:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011db78:	83 ec 0c             	sub    $0xc,%esp
f011db7b:	68 00 38 00 00       	push   $0x3800
f011db80:	e8 06 af fe ff       	call   f0108a8b <kmalloc>
f011db85:	83 c4 10             	add    $0x10,%esp
f011db88:	89 85 94 fe ff ff    	mov    %eax,-0x16c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011db8e:	8b 85 94 fe ff ff    	mov    -0x16c(%ebp),%eax
f011db94:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011db99:	74 17                	je     f011dbb2 <test_kheap_phys_addr+0x599>
f011db9b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dba2:	83 ec 0c             	sub    $0xc,%esp
f011dba5:	68 b0 ef 12 f0       	push   $0xf012efb0
f011dbaa:	e8 bd 33 fe ff       	call   f0100f6c <cprintf>
f011dbaf:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011dbb2:	e8 5e 6c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011dbb7:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011dbba:	74 17                	je     f011dbd3 <test_kheap_phys_addr+0x5ba>
f011dbbc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dbc3:	83 ec 0c             	sub    $0xc,%esp
f011dbc6:	68 00 ef 12 f0       	push   $0xf012ef00
f011dbcb:	e8 9c 33 fe ff       	call   f0100f6c <cprintf>
f011dbd0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011dbd3:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011dbd6:	e8 02 fe fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011dbdb:	29 c3                	sub    %eax,%ebx
f011dbdd:	89 d8                	mov    %ebx,%eax
f011dbdf:	83 f8 03             	cmp    $0x3,%eax
f011dbe2:	77 17                	ja     f011dbfb <test_kheap_phys_addr+0x5e2>
f011dbe4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dbeb:	83 ec 0c             	sub    $0xc,%esp
f011dbee:	68 6c ef 12 f0       	push   $0xf012ef6c
f011dbf3:	e8 74 33 fe ff       	call   f0100f6c <cprintf>
f011dbf8:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011dbfb:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011dc02:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011dc09:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011dc10:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011dc15:	05 00 10 00 00       	add    $0x1000,%eax
f011dc1a:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011dc1d:	8b 45 98             	mov    -0x68(%ebp),%eax
f011dc20:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011dc23:	eb 2e                	jmp    f011dc53 <test_kheap_phys_addr+0x63a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011dc25:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011dc28:	8d 43 01             	lea    0x1(%ebx),%eax
f011dc2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011dc2e:	83 ec 0c             	sub    $0xc,%esp
f011dc31:	ff 75 e8             	pushl  -0x18(%ebp)
f011dc34:	e8 a0 ae fe ff       	call   f0108ad9 <kheap_physical_address>
f011dc39:	83 c4 10             	add    $0x10,%esp
f011dc3c:	89 84 9d 48 ca ff ff 	mov    %eax,-0x35b8(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011dc43:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011dc46:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dc49:	01 d0                	add    %edx,%eax
f011dc4b:	05 00 10 00 00       	add    $0x1000,%eax
f011dc50:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011dc53:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dc56:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011dc59:	72 ca                	jb     f011dc25 <test_kheap_phys_addr+0x60c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011dc5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dc5e:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011dc61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011dc68:	8b 45 98             	mov    -0x68(%ebp),%eax
f011dc6b:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011dc6e:	e9 ce 00 00 00       	jmp    f011dd41 <test_kheap_phys_addr+0x728>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011dc73:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f011dc78:	83 ec 04             	sub    $0x4,%esp
f011dc7b:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011dc81:	52                   	push   %edx
f011dc82:	ff 75 e8             	pushl  -0x18(%ebp)
f011dc85:	50                   	push   %eax
f011dc86:	e8 57 a7 fe ff       	call   f01083e2 <get_page_table>
f011dc8b:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011dc8e:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011dc94:	85 c0                	test   %eax,%eax
f011dc96:	75 1e                	jne    f011dcb6 <test_kheap_phys_addr+0x69d>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011dc98:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dc9f:	83 ec 04             	sub    $0x4,%esp
f011dca2:	68 58 f5 12 f0       	push   $0xf012f558
f011dca7:	68 30 05 00 00       	push   $0x530
f011dcac:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011dcb1:	e8 64 26 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011dcb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dcb9:	c1 e8 0c             	shr    $0xc,%eax
f011dcbc:	25 ff 03 00 00       	and    $0x3ff,%eax
f011dcc1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011dcc4:	eb 62                	jmp    f011dd28 <test_kheap_phys_addr+0x70f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011dcc6:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011dccc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011dccf:	c1 e2 02             	shl    $0x2,%edx
f011dcd2:	01 d0                	add    %edx,%eax
f011dcd4:	8b 00                	mov    (%eax),%eax
f011dcd6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011dcdb:	89 c2                	mov    %eax,%edx
f011dcdd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dce0:	25 ff 0f 00 00       	and    $0xfff,%eax
f011dce5:	01 c2                	add    %eax,%edx
f011dce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dcea:	8b 84 85 48 ca ff ff 	mov    -0x35b8(%ebp,%eax,4),%eax
f011dcf1:	39 c2                	cmp    %eax,%edx
f011dcf3:	74 1d                	je     f011dd12 <test_kheap_phys_addr+0x6f9>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011dcf5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011dcf9:	74 17                	je     f011dd12 <test_kheap_phys_addr+0x6f9>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011dcfb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011dd02:	83 ec 0c             	sub    $0xc,%esp
f011dd05:	68 ca f5 12 f0       	push   $0xf012f5ca
f011dd0a:	e8 5d 32 fe ff       	call   f0100f6c <cprintf>
f011dd0f:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011dd12:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011dd15:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dd18:	01 d0                	add    %edx,%eax
f011dd1a:	05 00 10 00 00       	add    $0x1000,%eax
f011dd1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011dd22:	ff 45 e4             	incl   -0x1c(%ebp)
f011dd25:	ff 45 f4             	incl   -0xc(%ebp)
f011dd28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dd2b:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011dd2e:	7d 11                	jge    f011dd41 <test_kheap_phys_addr+0x728>
f011dd30:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011dd37:	7f 08                	jg     f011dd41 <test_kheap_phys_addr+0x728>
f011dd39:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dd3c:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011dd3f:	72 85                	jb     f011dcc6 <test_kheap_phys_addr+0x6ad>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011dd41:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dd44:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011dd47:	0f 82 26 ff ff ff    	jb     f011dc73 <test_kheap_phys_addr+0x65a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011dd4d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011dd51:	74 04                	je     f011dd57 <test_kheap_phys_addr+0x73e>
f011dd53:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011dd57:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011dd5e:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011dd65:	e9 b0 00 00 00       	jmp    f011de1a <test_kheap_phys_addr+0x801>
		{
			va = (uint32)ptr_allocations[i];
f011dd6a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011dd6d:	8b 84 85 74 fe ff ff 	mov    -0x18c(%ebp,%eax,4),%eax
f011dd74:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011dd77:	83 ec 0c             	sub    $0xc,%esp
f011dd7a:	ff 75 90             	pushl  -0x70(%ebp)
f011dd7d:	e8 57 ad fe ff       	call   f0108ad9 <kheap_physical_address>
f011dd82:	83 c4 10             	add    $0x10,%esp
f011dd85:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011dd88:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f011dd8d:	83 ec 04             	sub    $0x4,%esp
f011dd90:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011dd96:	52                   	push   %edx
f011dd97:	ff 75 90             	pushl  -0x70(%ebp)
f011dd9a:	50                   	push   %eax
f011dd9b:	e8 42 a6 fe ff       	call   f01083e2 <get_page_table>
f011dda0:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011dda3:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011dda9:	85 c0                	test   %eax,%eax
f011ddab:	75 1e                	jne    f011ddcb <test_kheap_phys_addr+0x7b2>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ddad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ddb4:	83 ec 04             	sub    $0x4,%esp
f011ddb7:	68 58 f5 12 f0       	push   $0xf012f558
f011ddbc:	68 4c 05 00 00       	push   $0x54c
f011ddc1:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011ddc6:	e8 4f 25 fe ff       	call   f010031a <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011ddcb:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011ddd1:	8b 55 90             	mov    -0x70(%ebp),%edx
f011ddd4:	c1 ea 0c             	shr    $0xc,%edx
f011ddd7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011dddd:	c1 e2 02             	shl    $0x2,%edx
f011dde0:	01 d0                	add    %edx,%eax
f011dde2:	8b 00                	mov    (%eax),%eax
f011dde4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011dde9:	89 c2                	mov    %eax,%edx
f011ddeb:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ddee:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ddf3:	01 d0                	add    %edx,%eax
f011ddf5:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011ddf8:	74 1d                	je     f011de17 <test_kheap_phys_addr+0x7fe>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011ddfa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ddfe:	74 17                	je     f011de17 <test_kheap_phys_addr+0x7fe>
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011de00:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011de07:	83 ec 0c             	sub    $0xc,%esp
f011de0a:	68 ca f5 12 f0       	push   $0xf012f5ca
f011de0f:	e8 58 31 fe ff       	call   f0100f6c <cprintf>
f011de14:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011de17:	ff 45 e0             	incl   -0x20(%ebp)
f011de1a:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011de1e:	0f 8e 46 ff ff ff    	jle    f011dd6a <test_kheap_phys_addr+0x751>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011de24:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011de28:	74 04                	je     f011de2e <test_kheap_phys_addr+0x815>
f011de2a:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011de2e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011de35:	e8 a3 fb fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011de3a:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011de3d:	e8 d3 69 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011de42:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011de45:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011de4b:	83 ec 0c             	sub    $0xc,%esp
f011de4e:	50                   	push   %eax
f011de4f:	e8 51 ac fe ff       	call   f0108aa5 <kfree>
f011de54:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011de57:	e8 b9 69 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011de5c:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011de5f:	74 17                	je     f011de78 <test_kheap_phys_addr+0x85f>
f011de61:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011de68:	83 ec 0c             	sub    $0xc,%esp
f011de6b:	68 00 ef 12 f0       	push   $0xf012ef00
f011de70:	e8 f7 30 fe ff       	call   f0100f6c <cprintf>
f011de75:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011de78:	e8 60 fb fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011de7d:	89 c2                	mov    %eax,%edx
f011de7f:	8b 45 88             	mov    -0x78(%ebp),%eax
f011de82:	29 c2                	sub    %eax,%edx
f011de84:	89 d0                	mov    %edx,%eax
f011de86:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011de8b:	77 17                	ja     f011dea4 <test_kheap_phys_addr+0x88b>
f011de8d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011de94:	83 ec 0c             	sub    $0xc,%esp
f011de97:	68 04 f3 12 f0       	push   $0xf012f304
f011de9c:	e8 cb 30 fe ff       	call   f0100f6c <cprintf>
f011dea1:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011dea4:	e8 34 fb fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011dea9:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011deac:	e8 64 69 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011deb1:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011deb4:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011deba:	83 ec 0c             	sub    $0xc,%esp
f011debd:	50                   	push   %eax
f011debe:	e8 e2 ab fe ff       	call   f0108aa5 <kfree>
f011dec3:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011dec6:	e8 4a 69 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011decb:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011dece:	74 17                	je     f011dee7 <test_kheap_phys_addr+0x8ce>
f011ded0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ded7:	83 ec 0c             	sub    $0xc,%esp
f011deda:	68 00 ef 12 f0       	push   $0xf012ef00
f011dedf:	e8 88 30 fe ff       	call   f0100f6c <cprintf>
f011dee4:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011dee7:	e8 f1 fa fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011deec:	89 c2                	mov    %eax,%edx
f011deee:	8b 45 88             	mov    -0x78(%ebp),%eax
f011def1:	29 c2                	sub    %eax,%edx
f011def3:	89 d0                	mov    %edx,%eax
f011def5:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011defa:	77 17                	ja     f011df13 <test_kheap_phys_addr+0x8fa>
f011defc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011df03:	83 ec 0c             	sub    $0xc,%esp
f011df06:	68 04 f3 12 f0       	push   $0xf012f304
f011df0b:	e8 5c 30 fe ff       	call   f0100f6c <cprintf>
f011df10:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011df13:	e8 c5 fa fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011df18:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011df1b:	e8 f5 68 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011df20:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011df23:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011df29:	83 ec 0c             	sub    $0xc,%esp
f011df2c:	50                   	push   %eax
f011df2d:	e8 73 ab fe ff       	call   f0108aa5 <kfree>
f011df32:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011df35:	e8 db 68 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011df3a:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011df3d:	74 17                	je     f011df56 <test_kheap_phys_addr+0x93d>
f011df3f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011df46:	83 ec 0c             	sub    $0xc,%esp
f011df49:	68 00 ef 12 f0       	push   $0xf012ef00
f011df4e:	e8 19 30 fe ff       	call   f0100f6c <cprintf>
f011df53:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011df56:	e8 82 fa fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011df5b:	89 c2                	mov    %eax,%edx
f011df5d:	8b 45 88             	mov    -0x78(%ebp),%eax
f011df60:	29 c2                	sub    %eax,%edx
f011df62:	89 d0                	mov    %edx,%eax
f011df64:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011df69:	77 17                	ja     f011df82 <test_kheap_phys_addr+0x969>
f011df6b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011df72:	83 ec 0c             	sub    $0xc,%esp
f011df75:	68 04 f3 12 f0       	push   $0xf012f304
f011df7a:	e8 ed 2f fe ff       	call   f0100f6c <cprintf>
f011df7f:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011df82:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011df89:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011df90:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011df95:	05 00 10 00 00       	add    $0x1000,%eax
f011df9a:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011dfa0:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011dfa6:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011dfa9:	eb 25                	jmp    f011dfd0 <test_kheap_phys_addr+0x9b7>
		{
			allPAs[i++] = kheap_physical_address(va);
f011dfab:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011dfae:	8d 43 01             	lea    0x1(%ebx),%eax
f011dfb1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011dfb4:	83 ec 0c             	sub    $0xc,%esp
f011dfb7:	ff 75 dc             	pushl  -0x24(%ebp)
f011dfba:	e8 1a ab fe ff       	call   f0108ad9 <kheap_physical_address>
f011dfbf:	83 c4 10             	add    $0x10,%esp
f011dfc2:	89 84 9d 48 ca ff ff 	mov    %eax,-0x35b8(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 startVA = da_limit + PAGE_SIZE;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011dfc9:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011dfd0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dfd3:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011dfd6:	72 d3                	jb     f011dfab <test_kheap_phys_addr+0x992>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011dfd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dfdb:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
		i = 0;
f011dfe1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011dfe8:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011dfee:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011dff1:	e9 f1 00 00 00       	jmp    f011e0e7 <test_kheap_phys_addr+0xace>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011dff6:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f011dffb:	83 ec 04             	sub    $0x4,%esp
f011dffe:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011e004:	52                   	push   %edx
f011e005:	ff 75 dc             	pushl  -0x24(%ebp)
f011e008:	50                   	push   %eax
f011e009:	e8 d4 a3 fe ff       	call   f01083e2 <get_page_table>
f011e00e:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011e011:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011e017:	85 c0                	test   %eax,%eax
f011e019:	75 24                	jne    f011e03f <test_kheap_phys_addr+0xa26>
				if (correct)
f011e01b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e01f:	74 1e                	je     f011e03f <test_kheap_phys_addr+0xa26>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011e021:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e028:	83 ec 04             	sub    $0x4,%esp
f011e02b:	68 58 f5 12 f0       	push   $0xf012f558
f011e030:	68 86 05 00 00       	push   $0x586
f011e035:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011e03a:	e8 db 22 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011e03f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e042:	c1 e8 0c             	shr    $0xc,%eax
f011e045:	25 ff 03 00 00       	and    $0x3ff,%eax
f011e04a:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011e04d:	eb 78                	jmp    f011e0c7 <test_kheap_phys_addr+0xaae>
			{
				if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
f011e04f:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011e055:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011e058:	c1 e2 02             	shl    $0x2,%edx
f011e05b:	01 d0                	add    %edx,%eax
f011e05d:	8b 00                	mov    (%eax),%eax
f011e05f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011e064:	89 c1                	mov    %eax,%ecx
f011e066:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011e06c:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011e06f:	c1 e2 02             	shl    $0x2,%edx
f011e072:	01 d0                	add    %edx,%eax
f011e074:	8b 00                	mov    (%eax),%eax
f011e076:	83 e0 01             	and    $0x1,%eax
f011e079:	85 c0                	test   %eax,%eax
f011e07b:	74 0a                	je     f011e087 <test_kheap_phys_addr+0xa6e>
f011e07d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e080:	25 ff 0f 00 00       	and    $0xfff,%eax
f011e085:	eb 05                	jmp    f011e08c <test_kheap_phys_addr+0xa73>
f011e087:	b8 00 00 00 00       	mov    $0x0,%eax
f011e08c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f011e08f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e092:	8b 84 85 48 ca ff ff 	mov    -0x35b8(%ebp,%eax,4),%eax
f011e099:	39 c2                	cmp    %eax,%edx
f011e09b:	74 1d                	je     f011e0ba <test_kheap_phys_addr+0xaa1>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011e09d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e0a1:	74 17                	je     f011e0ba <test_kheap_phys_addr+0xaa1>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011e0a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e0aa:	83 ec 0c             	sub    $0xc,%esp
f011e0ad:	68 ca f5 12 f0       	push   $0xf012f5ca
f011e0b2:	e8 b5 2e fe ff       	call   f0100f6c <cprintf>
f011e0b7:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011e0ba:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011e0c1:	ff 45 d8             	incl   -0x28(%ebp)
f011e0c4:	ff 45 f4             	incl   -0xc(%ebp)
f011e0c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e0ca:	3b 85 78 ff ff ff    	cmp    -0x88(%ebp),%eax
f011e0d0:	7d 15                	jge    f011e0e7 <test_kheap_phys_addr+0xace>
f011e0d2:	81 7d d8 ff 03 00 00 	cmpl   $0x3ff,-0x28(%ebp)
f011e0d9:	7f 0c                	jg     f011e0e7 <test_kheap_phys_addr+0xace>
f011e0db:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e0de:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011e0e1:	0f 82 68 ff ff ff    	jb     f011e04f <test_kheap_phys_addr+0xa36>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011e0e7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e0ea:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011e0ed:	0f 82 03 ff ff ff    	jb     f011dff6 <test_kheap_phys_addr+0x9dd>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011e0f3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e0f7:	74 04                	je     f011e0fd <test_kheap_phys_addr+0xae4>
f011e0f9:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011e0fd:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011e104:	c7 45 d4 00 00 00 f6 	movl   $0xf6000000,-0x2c(%ebp)
f011e10b:	e9 af 00 00 00       	jmp    f011e1bf <test_kheap_phys_addr+0xba6>
		{
			pa = kheap_physical_address(va);
f011e110:	83 ec 0c             	sub    $0xc,%esp
f011e113:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e116:	e8 be a9 fe ff       	call   f0108ad9 <kheap_physical_address>
f011e11b:	83 c4 10             	add    $0x10,%esp
f011e11e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011e124:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f011e129:	83 ec 04             	sub    $0x4,%esp
f011e12c:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011e132:	52                   	push   %edx
f011e133:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e136:	50                   	push   %eax
f011e137:	e8 a6 a2 fe ff       	call   f01083e2 <get_page_table>
f011e13c:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011e13f:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011e145:	85 c0                	test   %eax,%eax
f011e147:	75 24                	jne    f011e16d <test_kheap_phys_addr+0xb54>
				if (correct)
f011e149:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e14d:	74 1e                	je     f011e16d <test_kheap_phys_addr+0xb54>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011e14f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e156:	83 ec 04             	sub    $0x4,%esp
f011e159:	68 58 f5 12 f0       	push   $0xf012f558
f011e15e:	68 a1 05 00 00       	push   $0x5a1
f011e163:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011e168:	e8 ad 21 fe ff       	call   f010031a <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011e16d:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011e173:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e176:	c1 ea 0c             	shr    $0xc,%edx
f011e179:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011e17f:	c1 e2 02             	shl    $0x2,%edx
f011e182:	01 d0                	add    %edx,%eax
f011e184:	8b 00                	mov    (%eax),%eax
f011e186:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011e18b:	89 c2                	mov    %eax,%edx
f011e18d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e190:	25 ff 0f 00 00       	and    $0xfff,%eax
f011e195:	01 d0                	add    %edx,%eax
f011e197:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011e19d:	74 1d                	je     f011e1bc <test_kheap_phys_addr+0xba3>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011e19f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e1a3:	74 17                	je     f011e1bc <test_kheap_phys_addr+0xba3>
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011e1a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e1ac:	83 ec 0c             	sub    $0xc,%esp
f011e1af:	68 ca f5 12 f0       	push   $0xf012f5ca
f011e1b4:	e8 b3 2d fe ff       	call   f0100f6c <cprintf>
f011e1b9:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011e1bc:	ff 45 d4             	incl   -0x2c(%ebp)
f011e1bf:	83 ec 0c             	sub    $0xc,%esp
f011e1c2:	6a 00                	push   $0x0
f011e1c4:	e8 b8 a8 fe ff       	call   f0108a81 <sbrk>
f011e1c9:	83 c4 10             	add    $0x10,%esp
f011e1cc:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011e1cf:	0f 87 3b ff ff ff    	ja     f011e110 <test_kheap_phys_addr+0xaf7>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011e1d5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e1d9:	74 04                	je     f011e1df <test_kheap_phys_addr+0xbc6>
f011e1db:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011e1df:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011e1e6:	c7 85 70 ff ff ff 00 	movl   $0xf9001000,-0x90(%ebp)
f011e1ed:	10 00 f9 
		i = 0;
f011e1f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011e1f7:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011e1fd:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011e200:	eb 0a                	jmp    f011e20c <test_kheap_phys_addr+0xbf3>
		{
			i++;
f011e202:	ff 45 f4             	incl   -0xc(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011e205:	81 45 d0 00 10 00 00 	addl   $0x1000,-0x30(%ebp)
f011e20c:	81 7d d0 ff ef ff ff 	cmpl   $0xffffefff,-0x30(%ebp)
f011e213:	76 ed                	jbe    f011e202 <test_kheap_phys_addr+0xbe9>
		{
			i++;
		}
		int ii = i ;
f011e215:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e218:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
		i = 0;
f011e21e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011e225:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011e22b:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011e22e:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011e235:	e9 13 01 00 00       	jmp    f011e34d <test_kheap_phys_addr+0xd34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011e23a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011e23d:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f011e242:	83 ec 04             	sub    $0x4,%esp
f011e245:	8d 8d 60 fe ff ff    	lea    -0x1a0(%ebp),%ecx
f011e24b:	51                   	push   %ecx
f011e24c:	52                   	push   %edx
f011e24d:	50                   	push   %eax
f011e24e:	e8 8f a1 fe ff       	call   f01083e2 <get_page_table>
f011e253:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011e256:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011e25c:	85 c0                	test   %eax,%eax
f011e25e:	75 24                	jne    f011e284 <test_kheap_phys_addr+0xc6b>
			{
				if (correct)
f011e260:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e264:	74 1e                	je     f011e284 <test_kheap_phys_addr+0xc6b>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011e266:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e26d:	83 ec 04             	sub    $0x4,%esp
f011e270:	68 58 f5 12 f0       	push   $0xf012f558
f011e275:	68 c2 05 00 00       	push   $0x5c2
f011e27a:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011e27f:	e8 96 20 fe ff       	call   f010031a <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011e284:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f011e28b:	e9 9a 00 00 00       	jmp    f011e32a <test_kheap_phys_addr+0xd11>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011e290:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e293:	c1 e0 0c             	shl    $0xc,%eax
f011e296:	89 c2                	mov    %eax,%edx
f011e298:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011e29e:	01 d0                	add    %edx,%eax
f011e2a0:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011e2a6:	83 ec 0c             	sub    $0xc,%esp
f011e2a9:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
f011e2af:	e8 25 a8 fe ff       	call   f0108ad9 <kheap_physical_address>
f011e2b4:	83 c4 10             	add    $0x10,%esp
f011e2b7:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
f011e2bd:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011e2c3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011e2c6:	c1 e2 02             	shl    $0x2,%edx
f011e2c9:	01 d0                	add    %edx,%eax
f011e2cb:	8b 00                	mov    (%eax),%eax
f011e2cd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011e2d2:	89 c1                	mov    %eax,%ecx
f011e2d4:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011e2da:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011e2dd:	c1 e2 02             	shl    $0x2,%edx
f011e2e0:	01 d0                	add    %edx,%eax
f011e2e2:	8b 00                	mov    (%eax),%eax
f011e2e4:	83 e0 01             	and    $0x1,%eax
f011e2e7:	85 c0                	test   %eax,%eax
f011e2e9:	74 0d                	je     f011e2f8 <test_kheap_phys_addr+0xcdf>
f011e2eb:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f011e2f1:	25 ff 0f 00 00       	and    $0xfff,%eax
f011e2f6:	eb 05                	jmp    f011e2fd <test_kheap_phys_addr+0xce4>
f011e2f8:	b8 00 00 00 00       	mov    $0x0,%eax
f011e2fd:	01 c8                	add    %ecx,%eax
f011e2ff:	3b 85 64 ff ff ff    	cmp    -0x9c(%ebp),%eax
f011e305:	74 1d                	je     f011e324 <test_kheap_phys_addr+0xd0b>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011e307:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e30b:	74 17                	je     f011e324 <test_kheap_phys_addr+0xd0b>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011e30d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e314:	83 ec 0c             	sub    $0xc,%esp
f011e317:	68 ca f5 12 f0       	push   $0xf012f5ca
f011e31c:	e8 4b 2c fe ff       	call   f0100f6c <cprintf>
f011e321:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011e324:	ff 45 cc             	incl   -0x34(%ebp)
f011e327:	ff 45 f4             	incl   -0xc(%ebp)
f011e32a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e32d:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f011e333:	7d 0d                	jge    f011e342 <test_kheap_phys_addr+0xd29>
f011e335:	81 7d cc ff 03 00 00 	cmpl   $0x3ff,-0x34(%ebp)
f011e33c:	0f 8e 4e ff ff ff    	jle    f011e290 <test_kheap_phys_addr+0xc77>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011e342:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011e349:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011e34d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011e351:	0f 88 e3 fe ff ff    	js     f011e23a <test_kheap_phys_addr+0xc21>
f011e357:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011e35b:	7f 0d                	jg     f011e36a <test_kheap_phys_addr+0xd51>
f011e35d:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011e364:	0f 86 d0 fe ff ff    	jbe    f011e23a <test_kheap_phys_addr+0xc21>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011e36a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e36e:	74 04                	je     f011e374 <test_kheap_phys_addr+0xd5b>
f011e370:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011e374:	83 ec 08             	sub    $0x8,%esp
f011e377:	ff 75 f0             	pushl  -0x10(%ebp)
f011e37a:	68 e8 f5 12 f0       	push   $0xf012f5e8
f011e37f:	e8 e8 2b fe ff       	call   f0100f6c <cprintf>
f011e384:	83 c4 10             	add    $0x10,%esp

	return 1;
f011e387:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011e38c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011e38f:	5b                   	pop    %ebx
f011e390:	5f                   	pop    %edi
f011e391:	5d                   	pop    %ebp
f011e392:	c3                   	ret    

f011e393 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011e393:	55                   	push   %ebp
f011e394:	89 e5                	mov    %esp,%ebp
f011e396:	57                   	push   %edi
f011e397:	56                   	push   %esi
f011e398:	53                   	push   %ebx
f011e399:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011e39f:	89 e0                	mov    %esp,%eax
f011e3a1:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011e3a3:	83 ec 0c             	sub    $0xc,%esp
f011e3a6:	68 40 ee 12 f0       	push   $0xf012ee40
f011e3ab:	e8 bc 2b fe ff       	call   f0100f6c <cprintf>
f011e3b0:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011e3b3:	83 ec 0c             	sub    $0xc,%esp
f011e3b6:	68 70 ee 12 f0       	push   $0xf012ee70
f011e3bb:	e8 ac 2b fe ff       	call   f0100f6c <cprintf>
f011e3c0:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011e3c3:	83 ec 0c             	sub    $0xc,%esp
f011e3c6:	68 40 ee 12 f0       	push   $0xf012ee40
f011e3cb:	e8 9c 2b fe ff       	call   f0100f6c <cprintf>
f011e3d0:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011e3d3:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011e3d7:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011e3db:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011e3e1:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011e3e7:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011e3ee:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011e3f5:	e8 e3 f5 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e3fa:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011e3fd:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011e403:	b9 14 00 00 00       	mov    $0x14,%ecx
f011e408:	b8 00 00 00 00       	mov    $0x0,%eax
f011e40d:	89 d7                	mov    %edx,%edi
f011e40f:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011e411:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011e417:	b9 14 00 00 00       	mov    $0x14,%ecx
f011e41c:	b8 00 00 00 00       	mov    $0x0,%eax
f011e421:	89 d7                	mov    %edx,%edi
f011e423:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011e425:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011e42c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011e433:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011e439:	b9 14 00 00 00       	mov    $0x14,%ecx
f011e43e:	b8 00 00 00 00       	mov    $0x0,%eax
f011e443:	89 d7                	mov    %edx,%edi
f011e445:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011e447:	e8 91 f5 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e44c:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e44f:	e8 c1 63 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e454:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011e457:	83 ec 0c             	sub    $0xc,%esp
f011e45a:	68 00 fc 1f 00       	push   $0x1ffc00
f011e45f:	e8 27 a6 fe ff       	call   f0108a8b <kmalloc>
f011e464:	83 c4 10             	add    $0x10,%esp
f011e467:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011e46d:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011e473:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011e478:	74 17                	je     f011e491 <test_kheap_virt_addr+0xfe>
f011e47a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e481:	83 ec 0c             	sub    $0xc,%esp
f011e484:	68 b0 ef 12 f0       	push   $0xf012efb0
f011e489:	e8 de 2a fe ff       	call   f0100f6c <cprintf>
f011e48e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e491:	e8 7f 63 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e496:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e499:	74 17                	je     f011e4b2 <test_kheap_virt_addr+0x11f>
f011e49b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e4a2:	83 ec 0c             	sub    $0xc,%esp
f011e4a5:	68 00 ef 12 f0       	push   $0xf012ef00
f011e4aa:	e8 bd 2a fe ff       	call   f0100f6c <cprintf>
f011e4af:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011e4b2:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011e4b5:	e8 23 f5 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e4ba:	29 c3                	sub    %eax,%ebx
f011e4bc:	89 d8                	mov    %ebx,%eax
f011e4be:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011e4c3:	77 17                	ja     f011e4dc <test_kheap_virt_addr+0x149>
f011e4c5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e4cc:	83 ec 0c             	sub    $0xc,%esp
f011e4cf:	68 6c ef 12 f0       	push   $0xf012ef6c
f011e4d4:	e8 93 2a fe ff       	call   f0100f6c <cprintf>
f011e4d9:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011e4dc:	e8 fc f4 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e4e1:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e4e4:	e8 2c 63 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e4e9:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011e4ec:	83 ec 0c             	sub    $0xc,%esp
f011e4ef:	68 00 fc 1f 00       	push   $0x1ffc00
f011e4f4:	e8 92 a5 fe ff       	call   f0108a8b <kmalloc>
f011e4f9:	83 c4 10             	add    $0x10,%esp
f011e4fc:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011e502:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011e508:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011e50d:	74 17                	je     f011e526 <test_kheap_virt_addr+0x193>
f011e50f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e516:	83 ec 0c             	sub    $0xc,%esp
f011e519:	68 b0 ef 12 f0       	push   $0xf012efb0
f011e51e:	e8 49 2a fe ff       	call   f0100f6c <cprintf>
f011e523:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e526:	e8 ea 62 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e52b:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e52e:	74 17                	je     f011e547 <test_kheap_virt_addr+0x1b4>
f011e530:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e537:	83 ec 0c             	sub    $0xc,%esp
f011e53a:	68 00 ef 12 f0       	push   $0xf012ef00
f011e53f:	e8 28 2a fe ff       	call   f0100f6c <cprintf>
f011e544:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011e547:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011e54a:	e8 8e f4 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e54f:	29 c3                	sub    %eax,%ebx
f011e551:	89 d8                	mov    %ebx,%eax
f011e553:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011e558:	77 17                	ja     f011e571 <test_kheap_virt_addr+0x1de>
f011e55a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e561:	83 ec 0c             	sub    $0xc,%esp
f011e564:	68 6c ef 12 f0       	push   $0xf012ef6c
f011e569:	e8 fe 29 fe ff       	call   f0100f6c <cprintf>
f011e56e:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011e571:	e8 67 f4 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e576:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011e579:	e8 97 62 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e57e:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011e581:	83 ec 0c             	sub    $0xc,%esp
f011e584:	68 00 04 00 00       	push   $0x400
f011e589:	e8 fd a4 fe ff       	call   f0108a8b <kmalloc>
f011e58e:	83 c4 10             	add    $0x10,%esp
f011e591:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011e597:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011e59d:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011e5a2:	76 28                	jbe    f011e5cc <test_kheap_virt_addr+0x239>
f011e5a4:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011e5aa:	83 ec 0c             	sub    $0xc,%esp
f011e5ad:	6a 00                	push   $0x0
f011e5af:	e8 cd a4 fe ff       	call   f0108a81 <sbrk>
f011e5b4:	83 c4 10             	add    $0x10,%esp
f011e5b7:	39 c3                	cmp    %eax,%ebx
f011e5b9:	73 11                	jae    f011e5cc <test_kheap_virt_addr+0x239>
f011e5bb:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011e5c1:	89 c2                	mov    %eax,%edx
f011e5c3:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011e5c8:	39 c2                	cmp    %eax,%edx
f011e5ca:	72 17                	jb     f011e5e3 <test_kheap_virt_addr+0x250>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011e5cc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e5d3:	83 ec 0c             	sub    $0xc,%esp
f011e5d6:	68 00 f0 12 f0       	push   $0xf012f000
f011e5db:	e8 8c 29 fe ff       	call   f0100f6c <cprintf>
f011e5e0:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e5e3:	e8 2d 62 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e5e8:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e5eb:	74 17                	je     f011e604 <test_kheap_virt_addr+0x271>
f011e5ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e5f4:	83 ec 0c             	sub    $0xc,%esp
f011e5f7:	68 00 ef 12 f0       	push   $0xf012ef00
f011e5fc:	e8 6b 29 fe ff       	call   f0100f6c <cprintf>
f011e601:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011e604:	e8 d4 f3 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e609:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011e60c:	e8 04 62 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e611:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011e614:	83 ec 0c             	sub    $0xc,%esp
f011e617:	68 00 08 00 00       	push   $0x800
f011e61c:	e8 6a a4 fe ff       	call   f0108a8b <kmalloc>
f011e621:	83 c4 10             	add    $0x10,%esp
f011e624:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011e62a:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011e630:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011e635:	76 28                	jbe    f011e65f <test_kheap_virt_addr+0x2cc>
f011e637:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011e63d:	83 ec 0c             	sub    $0xc,%esp
f011e640:	6a 00                	push   $0x0
f011e642:	e8 3a a4 fe ff       	call   f0108a81 <sbrk>
f011e647:	83 c4 10             	add    $0x10,%esp
f011e64a:	39 c3                	cmp    %eax,%ebx
f011e64c:	73 11                	jae    f011e65f <test_kheap_virt_addr+0x2cc>
f011e64e:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011e654:	89 c2                	mov    %eax,%edx
f011e656:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011e65b:	39 c2                	cmp    %eax,%edx
f011e65d:	72 17                	jb     f011e676 <test_kheap_virt_addr+0x2e3>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011e65f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e666:	83 ec 0c             	sub    $0xc,%esp
f011e669:	68 00 f0 12 f0       	push   $0xf012f000
f011e66e:	e8 f9 28 fe ff       	call   f0100f6c <cprintf>
f011e673:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e676:	e8 9a 61 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e67b:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e67e:	74 17                	je     f011e697 <test_kheap_virt_addr+0x304>
f011e680:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e687:	83 ec 0c             	sub    $0xc,%esp
f011e68a:	68 00 ef 12 f0       	push   $0xf012ef00
f011e68f:	e8 d8 28 fe ff       	call   f0100f6c <cprintf>
f011e694:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011e697:	e8 41 f3 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e69c:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011e69f:	e8 71 61 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e6a4:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011e6a7:	83 ec 0c             	sub    $0xc,%esp
f011e6aa:	68 00 06 00 00       	push   $0x600
f011e6af:	e8 d7 a3 fe ff       	call   f0108a8b <kmalloc>
f011e6b4:	83 c4 10             	add    $0x10,%esp
f011e6b7:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011e6bd:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011e6c3:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011e6c8:	76 28                	jbe    f011e6f2 <test_kheap_virt_addr+0x35f>
f011e6ca:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011e6d0:	83 ec 0c             	sub    $0xc,%esp
f011e6d3:	6a 00                	push   $0x0
f011e6d5:	e8 a7 a3 fe ff       	call   f0108a81 <sbrk>
f011e6da:	83 c4 10             	add    $0x10,%esp
f011e6dd:	39 c3                	cmp    %eax,%ebx
f011e6df:	73 11                	jae    f011e6f2 <test_kheap_virt_addr+0x35f>
f011e6e1:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011e6e7:	89 c2                	mov    %eax,%edx
f011e6e9:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011e6ee:	39 c2                	cmp    %eax,%edx
f011e6f0:	72 17                	jb     f011e709 <test_kheap_virt_addr+0x376>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011e6f2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e6f9:	83 ec 0c             	sub    $0xc,%esp
f011e6fc:	68 00 f0 12 f0       	push   $0xf012f000
f011e701:	e8 66 28 fe ff       	call   f0100f6c <cprintf>
f011e706:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e709:	e8 07 61 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e70e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e711:	74 17                	je     f011e72a <test_kheap_virt_addr+0x397>
f011e713:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e71a:	83 ec 0c             	sub    $0xc,%esp
f011e71d:	68 00 ef 12 f0       	push   $0xf012ef00
f011e722:	e8 45 28 fe ff       	call   f0100f6c <cprintf>
f011e727:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011e72a:	e8 ae f2 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e72f:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e732:	e8 de 60 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e737:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011e73a:	83 ec 0c             	sub    $0xc,%esp
f011e73d:	68 00 1c 00 00       	push   $0x1c00
f011e742:	e8 44 a3 fe ff       	call   f0108a8b <kmalloc>
f011e747:	83 c4 10             	add    $0x10,%esp
f011e74a:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011e750:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011e756:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011e75b:	74 17                	je     f011e774 <test_kheap_virt_addr+0x3e1>
f011e75d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e764:	83 ec 0c             	sub    $0xc,%esp
f011e767:	68 b0 ef 12 f0       	push   $0xf012efb0
f011e76c:	e8 fb 27 fe ff       	call   f0100f6c <cprintf>
f011e771:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e774:	e8 9c 60 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e779:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e77c:	74 17                	je     f011e795 <test_kheap_virt_addr+0x402>
f011e77e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e785:	83 ec 0c             	sub    $0xc,%esp
f011e788:	68 00 ef 12 f0       	push   $0xf012ef00
f011e78d:	e8 da 27 fe ff       	call   f0100f6c <cprintf>
f011e792:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011e795:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011e798:	e8 40 f2 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e79d:	29 c3                	sub    %eax,%ebx
f011e79f:	89 d8                	mov    %ebx,%eax
f011e7a1:	83 f8 01             	cmp    $0x1,%eax
f011e7a4:	77 17                	ja     f011e7bd <test_kheap_virt_addr+0x42a>
f011e7a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e7ad:	83 ec 0c             	sub    $0xc,%esp
f011e7b0:	68 6c ef 12 f0       	push   $0xf012ef6c
f011e7b5:	e8 b2 27 fe ff       	call   f0100f6c <cprintf>
f011e7ba:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011e7bd:	e8 1b f2 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e7c2:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e7c5:	e8 4b 60 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e7ca:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011e7cd:	83 ec 0c             	sub    $0xc,%esp
f011e7d0:	68 00 fc 2f 00       	push   $0x2ffc00
f011e7d5:	e8 b1 a2 fe ff       	call   f0108a8b <kmalloc>
f011e7da:	83 c4 10             	add    $0x10,%esp
f011e7dd:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011e7e3:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011e7e9:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011e7ee:	74 17                	je     f011e807 <test_kheap_virt_addr+0x474>
f011e7f0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e7f7:	83 ec 0c             	sub    $0xc,%esp
f011e7fa:	68 b0 ef 12 f0       	push   $0xf012efb0
f011e7ff:	e8 68 27 fe ff       	call   f0100f6c <cprintf>
f011e804:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e807:	e8 09 60 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e80c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e80f:	74 17                	je     f011e828 <test_kheap_virt_addr+0x495>
f011e811:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e818:	83 ec 0c             	sub    $0xc,%esp
f011e81b:	68 00 ef 12 f0       	push   $0xf012ef00
f011e820:	e8 47 27 fe ff       	call   f0100f6c <cprintf>
f011e825:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011e828:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011e82b:	e8 ad f1 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e830:	29 c3                	sub    %eax,%ebx
f011e832:	89 d8                	mov    %ebx,%eax
f011e834:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011e839:	77 17                	ja     f011e852 <test_kheap_virt_addr+0x4bf>
f011e83b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e842:	83 ec 0c             	sub    $0xc,%esp
f011e845:	68 6c ef 12 f0       	push   $0xf012ef6c
f011e84a:	e8 1d 27 fe ff       	call   f0100f6c <cprintf>
f011e84f:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011e852:	e8 86 f1 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e857:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e85a:	e8 b6 5f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e85f:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011e862:	83 ec 0c             	sub    $0xc,%esp
f011e865:	68 00 fc 5f 00       	push   $0x5ffc00
f011e86a:	e8 1c a2 fe ff       	call   f0108a8b <kmalloc>
f011e86f:	83 c4 10             	add    $0x10,%esp
f011e872:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011e878:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011e87e:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011e883:	74 17                	je     f011e89c <test_kheap_virt_addr+0x509>
f011e885:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e88c:	83 ec 0c             	sub    $0xc,%esp
f011e88f:	68 b0 ef 12 f0       	push   $0xf012efb0
f011e894:	e8 d3 26 fe ff       	call   f0100f6c <cprintf>
f011e899:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e89c:	e8 74 5f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e8a1:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e8a4:	74 17                	je     f011e8bd <test_kheap_virt_addr+0x52a>
f011e8a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e8ad:	83 ec 0c             	sub    $0xc,%esp
f011e8b0:	68 00 ef 12 f0       	push   $0xf012ef00
f011e8b5:	e8 b2 26 fe ff       	call   f0100f6c <cprintf>
f011e8ba:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011e8bd:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011e8c0:	e8 18 f1 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e8c5:	29 c3                	sub    %eax,%ebx
f011e8c7:	89 d8                	mov    %ebx,%eax
f011e8c9:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011e8ce:	77 17                	ja     f011e8e7 <test_kheap_virt_addr+0x554>
f011e8d0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e8d7:	83 ec 0c             	sub    $0xc,%esp
f011e8da:	68 6c ef 12 f0       	push   $0xf012ef6c
f011e8df:	e8 88 26 fe ff       	call   f0100f6c <cprintf>
f011e8e4:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011e8e7:	e8 f1 f0 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e8ec:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011e8ef:	e8 21 5f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e8f4:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011e8f7:	83 ec 0c             	sub    $0xc,%esp
f011e8fa:	68 00 38 00 00       	push   $0x3800
f011e8ff:	e8 87 a1 fe ff       	call   f0108a8b <kmalloc>
f011e904:	83 c4 10             	add    $0x10,%esp
f011e907:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011e90d:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011e913:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011e918:	74 17                	je     f011e931 <test_kheap_virt_addr+0x59e>
f011e91a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e921:	83 ec 0c             	sub    $0xc,%esp
f011e924:	68 b0 ef 12 f0       	push   $0xf012efb0
f011e929:	e8 3e 26 fe ff       	call   f0100f6c <cprintf>
f011e92e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011e931:	e8 df 5e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011e936:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011e939:	74 17                	je     f011e952 <test_kheap_virt_addr+0x5bf>
f011e93b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e942:	83 ec 0c             	sub    $0xc,%esp
f011e945:	68 00 ef 12 f0       	push   $0xf012ef00
f011e94a:	e8 1d 26 fe ff       	call   f0100f6c <cprintf>
f011e94f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011e952:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011e955:	e8 83 f0 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011e95a:	29 c3                	sub    %eax,%ebx
f011e95c:	89 d8                	mov    %ebx,%eax
f011e95e:	83 f8 03             	cmp    $0x3,%eax
f011e961:	77 17                	ja     f011e97a <test_kheap_virt_addr+0x5e7>
f011e963:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011e96a:	83 ec 0c             	sub    $0xc,%esp
f011e96d:	68 6c ef 12 f0       	push   $0xf012ef6c
f011e972:	e8 f5 25 fe ff       	call   f0100f6c <cprintf>
f011e977:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011e97a:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011e981:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011e984:	c1 e8 0c             	shr    $0xc,%eax
f011e987:	89 c2                	mov    %eax,%edx
f011e989:	4a                   	dec    %edx
f011e98a:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011e98d:	c1 e0 02             	shl    $0x2,%eax
f011e990:	8d 50 03             	lea    0x3(%eax),%edx
f011e993:	b8 10 00 00 00       	mov    $0x10,%eax
f011e998:	48                   	dec    %eax
f011e999:	01 d0                	add    %edx,%eax
f011e99b:	bf 10 00 00 00       	mov    $0x10,%edi
f011e9a0:	ba 00 00 00 00       	mov    $0x0,%edx
f011e9a5:	f7 f7                	div    %edi
f011e9a7:	6b c0 10             	imul   $0x10,%eax,%eax
f011e9aa:	29 c4                	sub    %eax,%esp
f011e9ac:	89 e0                	mov    %esp,%eax
f011e9ae:	83 c0 03             	add    $0x3,%eax
f011e9b1:	c1 e8 02             	shr    $0x2,%eax
f011e9b4:	c1 e0 02             	shl    $0x2,%eax
f011e9b7:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011e9ba:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011e9bd:	c1 e8 0c             	shr    $0xc,%eax
f011e9c0:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011e9c3:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011e9ca:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011e9cf:	05 00 10 00 00       	add    $0x1000,%eax
f011e9d4:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011e9d7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011e9de:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011e9e1:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011e9e4:	e9 2d 01 00 00       	jmp    f011eb16 <test_kheap_virt_addr+0x783>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011e9e9:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f011e9ee:	83 ec 04             	sub    $0x4,%esp
f011e9f1:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011e9f7:	52                   	push   %edx
f011e9f8:	ff 75 dc             	pushl  -0x24(%ebp)
f011e9fb:	50                   	push   %eax
f011e9fc:	e8 e1 99 fe ff       	call   f01083e2 <get_page_table>
f011ea01:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ea04:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011ea0a:	85 c0                	test   %eax,%eax
f011ea0c:	75 1e                	jne    f011ea2c <test_kheap_virt_addr+0x699>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ea0e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ea15:	83 ec 04             	sub    $0x4,%esp
f011ea18:	68 58 f5 12 f0       	push   $0xf012f558
f011ea1d:	68 5e 06 00 00       	push   $0x65e
f011ea22:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011ea27:	e8 ee 18 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011ea2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ea2f:	c1 e8 0c             	shr    $0xc,%eax
f011ea32:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ea37:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011ea3a:	e9 ba 00 00 00       	jmp    f011eaf9 <test_kheap_virt_addr+0x766>
			{
				uint32 offset = j;
f011ea3f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ea42:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011ea45:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011ea4b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ea4e:	c1 e2 02             	shl    $0x2,%edx
f011ea51:	01 d0                	add    %edx,%eax
f011ea53:	8b 00                	mov    (%eax),%eax
f011ea55:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ea5a:	89 c2                	mov    %eax,%edx
f011ea5c:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ea5f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011ea62:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ea65:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ea68:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011ea6b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ea6e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ea71:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ea74:	83 ec 0c             	sub    $0xc,%esp
f011ea77:	50                   	push   %eax
f011ea78:	e8 42 a0 fe ff       	call   f0108abf <kheap_virtual_address>
f011ea7d:	83 c4 10             	add    $0x10,%esp
f011ea80:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011ea83:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011ea86:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ea89:	01 d0                	add    %edx,%eax
f011ea8b:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011ea8e:	74 5c                	je     f011eaec <test_kheap_virt_addr+0x759>
				{
					if (correct)
f011ea90:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ea94:	74 56                	je     f011eaec <test_kheap_virt_addr+0x759>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011ea96:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ea99:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ea9c:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ea9f:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011eaa5:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011eaa8:	c1 e1 02             	shl    $0x2,%ecx
f011eaab:	01 ca                	add    %ecx,%edx
f011eaad:	8b 12                	mov    (%edx),%edx
f011eaaf:	89 d1                	mov    %edx,%ecx
f011eab1:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011eab7:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011eaba:	8b 55 90             	mov    -0x70(%ebp),%edx
f011eabd:	01 da                	add    %ebx,%edx
f011eabf:	83 ec 0c             	sub    $0xc,%esp
f011eac2:	50                   	push   %eax
f011eac3:	51                   	push   %ecx
f011eac4:	52                   	push   %edx
f011eac5:	ff 75 8c             	pushl  -0x74(%ebp)
f011eac8:	68 1c f6 12 f0       	push   $0xf012f61c
f011eacd:	e8 9a 24 fe ff       	call   f0100f6c <cprintf>
f011ead2:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011ead5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011eadc:	83 ec 0c             	sub    $0xc,%esp
f011eadf:	68 5f f6 12 f0       	push   $0xf012f65f
f011eae4:	e8 83 24 fe ff       	call   f0100f6c <cprintf>
f011eae9:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011eaec:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011eaf3:	ff 45 d4             	incl   -0x2c(%ebp)
f011eaf6:	ff 45 d8             	incl   -0x28(%ebp)
f011eaf9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011eafc:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011eaff:	7d 15                	jge    f011eb16 <test_kheap_virt_addr+0x783>
f011eb01:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011eb08:	7f 0c                	jg     f011eb16 <test_kheap_virt_addr+0x783>
f011eb0a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011eb0d:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011eb10:	0f 82 29 ff ff ff    	jb     f011ea3f <test_kheap_virt_addr+0x6ac>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011eb16:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011eb19:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011eb1c:	0f 82 c7 fe ff ff    	jb     f011e9e9 <test_kheap_virt_addr+0x656>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011eb22:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011eb26:	74 04                	je     f011eb2c <test_kheap_virt_addr+0x799>
f011eb28:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011eb2c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011eb33:	e8 a5 ee fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011eb38:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011eb3b:	e8 d5 5c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011eb40:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011eb43:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011eb49:	83 ec 0c             	sub    $0xc,%esp
f011eb4c:	50                   	push   %eax
f011eb4d:	e8 53 9f fe ff       	call   f0108aa5 <kfree>
f011eb52:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011eb55:	e8 bb 5c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011eb5a:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011eb5d:	74 17                	je     f011eb76 <test_kheap_virt_addr+0x7e3>
f011eb5f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011eb66:	83 ec 0c             	sub    $0xc,%esp
f011eb69:	68 00 ef 12 f0       	push   $0xf012ef00
f011eb6e:	e8 f9 23 fe ff       	call   f0100f6c <cprintf>
f011eb73:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011eb76:	e8 62 ee fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011eb7b:	89 c2                	mov    %eax,%edx
f011eb7d:	8b 45 88             	mov    -0x78(%ebp),%eax
f011eb80:	29 c2                	sub    %eax,%edx
f011eb82:	89 d0                	mov    %edx,%eax
f011eb84:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011eb89:	77 17                	ja     f011eba2 <test_kheap_virt_addr+0x80f>
f011eb8b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011eb92:	83 ec 0c             	sub    $0xc,%esp
f011eb95:	68 04 f3 12 f0       	push   $0xf012f304
f011eb9a:	e8 cd 23 fe ff       	call   f0100f6c <cprintf>
f011eb9f:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011eba2:	e8 36 ee fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011eba7:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ebaa:	e8 66 5c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ebaf:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011ebb2:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011ebb8:	83 ec 0c             	sub    $0xc,%esp
f011ebbb:	50                   	push   %eax
f011ebbc:	e8 e4 9e fe ff       	call   f0108aa5 <kfree>
f011ebc1:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ebc4:	e8 4c 5c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ebc9:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ebcc:	74 17                	je     f011ebe5 <test_kheap_virt_addr+0x852>
f011ebce:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ebd5:	83 ec 0c             	sub    $0xc,%esp
f011ebd8:	68 00 ef 12 f0       	push   $0xf012ef00
f011ebdd:	e8 8a 23 fe ff       	call   f0100f6c <cprintf>
f011ebe2:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011ebe5:	e8 f3 ed fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011ebea:	89 c2                	mov    %eax,%edx
f011ebec:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ebef:	29 c2                	sub    %eax,%edx
f011ebf1:	89 d0                	mov    %edx,%eax
f011ebf3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ebf8:	77 17                	ja     f011ec11 <test_kheap_virt_addr+0x87e>
f011ebfa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ec01:	83 ec 0c             	sub    $0xc,%esp
f011ec04:	68 04 f3 12 f0       	push   $0xf012f304
f011ec09:	e8 5e 23 fe ff       	call   f0100f6c <cprintf>
f011ec0e:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011ec11:	e8 c7 ed fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011ec16:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ec19:	e8 f7 5b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ec1e:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011ec21:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011ec27:	83 ec 0c             	sub    $0xc,%esp
f011ec2a:	50                   	push   %eax
f011ec2b:	e8 75 9e fe ff       	call   f0108aa5 <kfree>
f011ec30:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ec33:	e8 dd 5b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011ec38:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ec3b:	74 17                	je     f011ec54 <test_kheap_virt_addr+0x8c1>
f011ec3d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ec44:	83 ec 0c             	sub    $0xc,%esp
f011ec47:	68 00 ef 12 f0       	push   $0xf012ef00
f011ec4c:	e8 1b 23 fe ff       	call   f0100f6c <cprintf>
f011ec51:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011ec54:	e8 84 ed fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011ec59:	89 c2                	mov    %eax,%edx
f011ec5b:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ec5e:	29 c2                	sub    %eax,%edx
f011ec60:	89 d0                	mov    %edx,%eax
f011ec62:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011ec67:	77 17                	ja     f011ec80 <test_kheap_virt_addr+0x8ed>
f011ec69:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ec70:	83 ec 0c             	sub    $0xc,%esp
f011ec73:	68 04 f3 12 f0       	push   $0xf012f304
f011ec78:	e8 ef 22 fe ff       	call   f0100f6c <cprintf>
f011ec7d:	83 c4 10             	add    $0x10,%esp


	//test kheap_virtual_address after kmalloc and kfree [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011ec80:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011ec87:	a1 d8 0d 18 f0       	mov    0xf0180dd8,%eax
f011ec8c:	05 00 10 00 00       	add    $0x1000,%eax
f011ec91:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011ec97:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011ec9e:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011eca5:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011eca8:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ecae:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011ecb1:	eb 44                	jmp    f011ecf7 <test_kheap_virt_addr+0x964>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011ecb3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ecb6:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011ecb9:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ecbc:	83 ec 0c             	sub    $0xc,%esp
f011ecbf:	50                   	push   %eax
f011ecc0:	e8 fa 9d fe ff       	call   f0108abf <kheap_virtual_address>
f011ecc5:	83 c4 10             	add    $0x10,%esp
f011ecc8:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011ecce:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011ecd5:	74 1d                	je     f011ecf4 <test_kheap_virt_addr+0x961>
			{
				if (correct)
f011ecd7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ecdb:	74 17                	je     f011ecf4 <test_kheap_virt_addr+0x961>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011ecdd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ece4:	83 ec 0c             	sub    $0xc,%esp
f011ece7:	68 5f f6 12 f0       	push   $0xf012f65f
f011ecec:	e8 7b 22 fe ff       	call   f0100f6c <cprintf>
f011ecf1:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011ecf4:	ff 45 d0             	incl   -0x30(%ebp)
f011ecf7:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ecfd:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011ed03:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ed06:	39 c2                	cmp    %eax,%edx
f011ed08:	77 a9                	ja     f011ecb3 <test_kheap_virt_addr+0x920>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011ed0a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ed10:	05 00 04 00 00       	add    $0x400,%eax
f011ed15:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011ed18:	eb 64                	jmp    f011ed7e <test_kheap_virt_addr+0x9eb>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011ed1a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ed1d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011ed20:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ed23:	83 ec 0c             	sub    $0xc,%esp
f011ed26:	50                   	push   %eax
f011ed27:	e8 93 9d fe ff       	call   f0108abf <kheap_virtual_address>
f011ed2c:	83 c4 10             	add    $0x10,%esp
f011ed2f:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011ed35:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ed38:	c1 e0 0c             	shl    $0xc,%eax
f011ed3b:	89 c2                	mov    %eax,%edx
f011ed3d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011ed43:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011ed46:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ed49:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011ed4c:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ed4f:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ed54:	01 c8                	add    %ecx,%eax
f011ed56:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011ed5c:	74 1d                	je     f011ed7b <test_kheap_virt_addr+0x9e8>
			{
				if (correct)
f011ed5e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ed62:	74 17                	je     f011ed7b <test_kheap_virt_addr+0x9e8>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011ed64:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ed6b:	83 ec 0c             	sub    $0xc,%esp
f011ed6e:	68 5f f6 12 f0       	push   $0xf012f65f
f011ed73:	e8 f4 21 fe ff       	call   f0100f6c <cprintf>
f011ed78:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011ed7b:	ff 45 d0             	incl   -0x30(%ebp)
f011ed7e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ed84:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011ed8a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ed8d:	39 c2                	cmp    %eax,%edx
f011ed8f:	77 89                	ja     f011ed1a <test_kheap_virt_addr+0x987>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011ed91:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ed97:	05 02 07 00 00       	add    $0x702,%eax
f011ed9c:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011ed9f:	eb 44                	jmp    f011ede5 <test_kheap_virt_addr+0xa52>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011eda1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eda4:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011eda7:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011edaa:	83 ec 0c             	sub    $0xc,%esp
f011edad:	50                   	push   %eax
f011edae:	e8 0c 9d fe ff       	call   f0108abf <kheap_virtual_address>
f011edb3:	83 c4 10             	add    $0x10,%esp
f011edb6:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011edbc:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011edc3:	74 1d                	je     f011ede2 <test_kheap_virt_addr+0xa4f>
			{
				if (correct)
f011edc5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011edc9:	74 17                	je     f011ede2 <test_kheap_virt_addr+0xa4f>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011edcb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011edd2:	83 ec 0c             	sub    $0xc,%esp
f011edd5:	68 5f f6 12 f0       	push   $0xf012f65f
f011edda:	e8 8d 21 fe ff       	call   f0100f6c <cprintf>
f011eddf:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011ede2:	ff 45 d0             	incl   -0x30(%ebp)
f011ede5:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011edeb:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011edf1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011edf4:	39 c2                	cmp    %eax,%edx
f011edf6:	77 a9                	ja     f011eda1 <test_kheap_virt_addr+0xa0e>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011edf8:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011edfe:	05 02 0d 00 00       	add    $0xd02,%eax
f011ee03:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011ee06:	eb 64                	jmp    f011ee6c <test_kheap_virt_addr+0xad9>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011ee08:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ee0b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011ee0e:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ee11:	83 ec 0c             	sub    $0xc,%esp
f011ee14:	50                   	push   %eax
f011ee15:	e8 a5 9c fe ff       	call   f0108abf <kheap_virtual_address>
f011ee1a:	83 c4 10             	add    $0x10,%esp
f011ee1d:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011ee23:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ee26:	c1 e0 0c             	shl    $0xc,%eax
f011ee29:	89 c2                	mov    %eax,%edx
f011ee2b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011ee31:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011ee34:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ee37:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011ee3a:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ee3d:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ee42:	01 c8                	add    %ecx,%eax
f011ee44:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011ee4a:	74 1d                	je     f011ee69 <test_kheap_virt_addr+0xad6>
			{
				if (correct)
f011ee4c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ee50:	74 17                	je     f011ee69 <test_kheap_virt_addr+0xad6>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011ee52:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ee59:	83 ec 0c             	sub    $0xc,%esp
f011ee5c:	68 5f f6 12 f0       	push   $0xf012f65f
f011ee61:	e8 06 21 fe ff       	call   f0100f6c <cprintf>
f011ee66:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011ee69:	ff 45 d0             	incl   -0x30(%ebp)
f011ee6c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ee72:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011ee78:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ee7b:	39 c2                	cmp    %eax,%edx
f011ee7d:	77 89                	ja     f011ee08 <test_kheap_virt_addr+0xa75>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011ee7f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ee83:	74 04                	je     f011ee89 <test_kheap_virt_addr+0xaf6>
f011ee85:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011ee89:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011ee90:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011ee97:	e9 d1 00 00 00       	jmp    f011ef6d <test_kheap_virt_addr+0xbda>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ee9c:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f011eea1:	83 ec 04             	sub    $0x4,%esp
f011eea4:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011eeaa:	52                   	push   %edx
f011eeab:	ff 75 cc             	pushl  -0x34(%ebp)
f011eeae:	50                   	push   %eax
f011eeaf:	e8 2e 95 fe ff       	call   f01083e2 <get_page_table>
f011eeb4:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011eeb7:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011eebd:	85 c0                	test   %eax,%eax
f011eebf:	75 1e                	jne    f011eedf <test_kheap_virt_addr+0xb4c>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011eec1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011eec8:	83 ec 04             	sub    $0x4,%esp
f011eecb:	68 58 f5 12 f0       	push   $0xf012f558
f011eed0:	68 cb 06 00 00       	push   $0x6cb
f011eed5:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011eeda:	e8 3b 14 fe ff       	call   f010031a <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011eedf:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011eee5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011eee8:	c1 ea 0c             	shr    $0xc,%edx
f011eeeb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011eef1:	c1 e2 02             	shl    $0x2,%edx
f011eef4:	01 d0                	add    %edx,%eax
f011eef6:	8b 00                	mov    (%eax),%eax
f011eef8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011eefd:	89 c2                	mov    %eax,%edx
f011eeff:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ef02:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ef07:	01 d0                	add    %edx,%eax
f011ef09:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011ef0f:	83 ec 0c             	sub    $0xc,%esp
f011ef12:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011ef18:	e8 a2 9b fe ff       	call   f0108abf <kheap_virtual_address>
f011ef1d:	83 c4 10             	add    $0x10,%esp
f011ef20:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011ef26:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011ef2c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011ef2f:	74 39                	je     f011ef6a <test_kheap_virt_addr+0xbd7>
			{
				if (correct)
f011ef31:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ef35:	74 33                	je     f011ef6a <test_kheap_virt_addr+0xbd7>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011ef37:	ff 75 cc             	pushl  -0x34(%ebp)
f011ef3a:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011ef40:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011ef46:	68 7c f6 12 f0       	push   $0xf012f67c
f011ef4b:	e8 1c 20 fe ff       	call   f0100f6c <cprintf>
f011ef50:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011ef53:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ef5a:	83 ec 0c             	sub    $0xc,%esp
f011ef5d:	68 5f f6 12 f0       	push   $0xf012f65f
f011ef62:	e8 05 20 fe ff       	call   f0100f6c <cprintf>
f011ef67:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011ef6a:	ff 45 cc             	incl   -0x34(%ebp)
f011ef6d:	83 ec 0c             	sub    $0xc,%esp
f011ef70:	6a 00                	push   $0x0
f011ef72:	e8 0a 9b fe ff       	call   f0108a81 <sbrk>
f011ef77:	83 c4 10             	add    $0x10,%esp
f011ef7a:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011ef7d:	0f 87 19 ff ff ff    	ja     f011ee9c <test_kheap_virt_addr+0xb09>
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011ef83:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ef87:	74 04                	je     f011ef8d <test_kheap_virt_addr+0xbfa>
f011ef89:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011ef8d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011ef94:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011ef9b:	eb 5a                	jmp    f011eff7 <test_kheap_virt_addr+0xc64>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011ef9d:	83 ec 0c             	sub    $0xc,%esp
f011efa0:	ff 75 c8             	pushl  -0x38(%ebp)
f011efa3:	e8 17 9b fe ff       	call   f0108abf <kheap_virtual_address>
f011efa8:	83 c4 10             	add    $0x10,%esp
f011efab:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011efb1:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011efb8:	74 36                	je     f011eff0 <test_kheap_virt_addr+0xc5d>
			{
				if (correct)
f011efba:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011efbe:	74 30                	je     f011eff0 <test_kheap_virt_addr+0xc5d>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011efc0:	83 ec 04             	sub    $0x4,%esp
f011efc3:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011efc9:	ff 75 c8             	pushl  -0x38(%ebp)
f011efcc:	68 a8 f6 12 f0       	push   $0xf012f6a8
f011efd1:	e8 96 1f fe ff       	call   f0100f6c <cprintf>
f011efd6:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011efd9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011efe0:	83 ec 0c             	sub    $0xc,%esp
f011efe3:	68 5f f6 12 f0       	push   $0xf012f65f
f011efe8:	e8 7f 1f fe ff       	call   f0100f6c <cprintf>
f011efed:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011eff0:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011eff7:	b8 30 74 5c 00       	mov    $0x5c7430,%eax
f011effc:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011efff:	72 9c                	jb     f011ef9d <test_kheap_virt_addr+0xc0a>
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011f001:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f005:	74 04                	je     f011f00b <test_kheap_virt_addr+0xc78>
f011f007:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011f00b:	83 ec 08             	sub    $0x8,%esp
f011f00e:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f011:	68 c4 f6 12 f0       	push   $0xf012f6c4
f011f016:	e8 51 1f fe ff       	call   f0100f6c <cprintf>
f011f01b:	83 c4 10             	add    $0x10,%esp

	return 1;
f011f01e:	b8 01 00 00 00       	mov    $0x1,%eax
f011f023:	89 f4                	mov    %esi,%esp

}
f011f025:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011f028:	5b                   	pop    %ebx
f011f029:	5e                   	pop    %esi
f011f02a:	5f                   	pop    %edi
f011f02b:	5d                   	pop    %ebp
f011f02c:	c3                   	ret    

f011f02d <test_ksbrk>:


// 2023
int test_ksbrk()
{
f011f02d:	55                   	push   %ebp
f011f02e:	89 e5                	mov    %esp,%ebp
f011f030:	57                   	push   %edi
f011f031:	56                   	push   %esi
f011f032:	53                   	push   %ebx
f011f033:	81 ec 1c 01 00 00    	sub    $0x11c,%esp

	// malloc some spaces
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	// int lastIndices[20] = {0};
	int sums[20] = {0};
f011f039:	8d 95 7c ff ff ff    	lea    -0x84(%ebp),%edx
f011f03f:	b9 14 00 00 00       	mov    $0x14,%ecx
f011f044:	b8 00 00 00 00       	mov    $0x0,%eax
f011f049:	89 d7                	mov    %edx,%edi
f011f04b:	f3 ab                	rep stos %eax,%es:(%edi)
	void *ptr_allocations[20] = {0};
f011f04d:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011f053:	b9 14 00 00 00       	mov    $0x14,%ecx
f011f058:	b8 00 00 00 00       	mov    $0x0,%eax
f011f05d:	89 d7                	mov    %edx,%edi
f011f05f:	f3 ab                	rep stos %eax,%es:(%edi)

	// uint32 inputIncrementValues[] = {0, kilo, 2*kilo, -512, -2 * kilo, -2* kilo, 128, kilo};
	uint32 expectedVAs[] = {
f011f061:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011f067:	bb 60 fc 12 f0       	mov    $0xf012fc60,%ebx
f011f06c:	ba 0a 00 00 00       	mov    $0xa,%edx
f011f071:	89 c7                	mov    %eax,%edi
f011f073:	89 de                	mov    %ebx,%esi
f011f075:	89 d1                	mov    %edx,%ecx
f011f077:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1E00, // 128
			KERNEL_HEAP_START + 0x2000, // kilo
			KERNEL_HEAP_START + 0x0C00, // -9*kilo
			KERNEL_HEAP_START + 0x0C00, // +6*kilo
	};
	uint32 expectedSbrks[] = {
f011f079:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f011f07f:	bb a0 fc 12 f0       	mov    $0xf012fca0,%ebx
f011f084:	ba 0a 00 00 00       	mov    $0xa,%edx
f011f089:	89 c7                	mov    %eax,%edi
f011f08b:	89 de                	mov    %ebx,%esi
f011f08d:	89 d1                	mov    %edx,%ecx
f011f08f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x3000, // kilo
			KERNEL_HEAP_START + 0x0C00, // -9*kilo
			KERNEL_HEAP_START + 0x4000, // +10*kilo
	};
	uint32 oldBrk, newBrk;
	int eval = 0;
f011f091:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011f098:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	cprintf("STEP A: checking increment with ZERO\n");
f011f09f:	83 ec 0c             	sub    $0xc,%esp
f011f0a2:	68 f8 f6 12 f0       	push   $0xf012f6f8
f011f0a7:	e8 c0 1e fe ff       	call   f0100f6c <cprintf>
f011f0ac:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames();
f011f0af:	e8 29 e9 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f0b4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f0b7:	e8 59 57 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f0bc:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[0] = sbrk(0);
f011f0bf:	83 ec 0c             	sub    $0xc,%esp
f011f0c2:	6a 00                	push   $0x0
f011f0c4:	e8 b8 99 fe ff       	call   f0108a81 <sbrk>
f011f0c9:	83 c4 10             	add    $0x10,%esp
f011f0cc:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f0d2:	e8 3e 57 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f0d7:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f0da:	74 17                	je     f011f0f3 <test_ksbrk+0xc6>
		{
			correct = 0;
f011f0dc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f0e3:	83 ec 0c             	sub    $0xc,%esp
f011f0e6:	68 20 f7 12 f0       	push   $0xf012f720
f011f0eb:	e8 7c 1e fe ff       	call   f0100f6c <cprintf>
f011f0f0:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011f0f3:	e8 e5 e8 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f0f8:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011f0fb:	74 17                	je     f011f114 <test_ksbrk+0xe7>
		{
			correct = 0;
f011f0fd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f104:	83 ec 0c             	sub    $0xc,%esp
f011f107:	68 88 f7 12 f0       	push   $0xf012f788
f011f10c:	e8 5b 1e fe ff       	call   f0100f6c <cprintf>
f011f111:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[0] != expectedVAs[0])
f011f114:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011f11a:	89 c2                	mov    %eax,%edx
f011f11c:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f011f122:	39 c2                	cmp    %eax,%edx
f011f124:	74 25                	je     f011f14b <test_ksbrk+0x11e>
		{
			correct = 0;
f011f126:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[0], ptr_allocations[0]);
f011f12d:	8b 95 2c ff ff ff    	mov    -0xd4(%ebp),%edx
f011f133:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f011f139:	83 ec 04             	sub    $0x4,%esp
f011f13c:	52                   	push   %edx
f011f13d:	50                   	push   %eax
f011f13e:	68 c8 f7 12 f0       	push   $0xf012f7c8
f011f143:	e8 24 1e fe ff       	call   f0100f6c <cprintf>
f011f148:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f14b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f14f:	74 04                	je     f011f155 <test_ksbrk+0x128>
			eval += 5;
f011f151:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	cprintf("STEP B: checking increment with +ve value\n");
f011f155:	83 ec 0c             	sub    $0xc,%esp
f011f158:	68 f8 f7 12 f0       	push   $0xf012f7f8
f011f15d:	e8 0a 1e fe ff       	call   f0100f6c <cprintf>
f011f162:	83 c4 10             	add    $0x10,%esp
	{ // +1 KB
		freeFrames = (int)sys_calculate_free_frames();
f011f165:	e8 73 e8 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f16a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f16d:	e8 a3 56 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f172:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f175:	83 ec 0c             	sub    $0xc,%esp
f011f178:	6a 00                	push   $0x0
f011f17a:	e8 02 99 fe ff       	call   f0108a81 <sbrk>
f011f17f:	83 c4 10             	add    $0x10,%esp
f011f182:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[1] = sbrk(kilo);
f011f185:	83 ec 0c             	sub    $0xc,%esp
f011f188:	68 00 04 00 00       	push   $0x400
f011f18d:	e8 ef 98 fe ff       	call   f0108a81 <sbrk>
f011f192:	83 c4 10             	add    $0x10,%esp
f011f195:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		newBrk = (uint32)sbrk(0);
f011f19b:	83 ec 0c             	sub    $0xc,%esp
f011f19e:	6a 00                	push   $0x0
f011f1a0:	e8 dc 98 fe ff       	call   f0108a81 <sbrk>
f011f1a5:	83 c4 10             	add    $0x10,%esp
f011f1a8:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f1ab:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f1b2:	e8 5e 56 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f1b7:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f1ba:	74 17                	je     f011f1d3 <test_ksbrk+0x1a6>
		{
			correct = 0;
f011f1bc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f1c3:	83 ec 0c             	sub    $0xc,%esp
f011f1c6:	68 20 f7 12 f0       	push   $0xf012f720
f011f1cb:	e8 9c 1d fe ff       	call   f0100f6c <cprintf>
f011f1d0:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011f1d3:	e8 05 e8 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f1d8:	89 c2                	mov    %eax,%edx
f011f1da:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f1dd:	29 d0                	sub    %edx,%eax
f011f1df:	83 f8 01             	cmp    $0x1,%eax
f011f1e2:	74 17                	je     f011f1fb <test_ksbrk+0x1ce>
		{
			correct = 0;
f011f1e4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f1eb:	83 ec 0c             	sub    $0xc,%esp
f011f1ee:	68 88 f7 12 f0       	push   $0xf012f788
f011f1f3:	e8 74 1d fe ff       	call   f0100f6c <cprintf>
f011f1f8:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[1] != expectedVAs[1])
f011f1fb:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011f201:	89 c2                	mov    %eax,%edx
f011f203:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011f209:	39 c2                	cmp    %eax,%edx
f011f20b:	74 25                	je     f011f232 <test_ksbrk+0x205>
		{
			correct = 0;
f011f20d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[1], ptr_allocations[1]);
f011f214:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011f21a:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011f220:	83 ec 04             	sub    $0x4,%esp
f011f223:	52                   	push   %edx
f011f224:	50                   	push   %eax
f011f225:	68 c8 f7 12 f0       	push   $0xf012f7c8
f011f22a:	e8 3d 1d fe ff       	call   f0100f6c <cprintf>
f011f22f:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[1])
f011f232:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011f238:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f23b:	74 21                	je     f011f25e <test_ksbrk+0x231>
		{
			correct = 0;
f011f23d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[1]);
f011f244:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011f24a:	83 ec 04             	sub    $0x4,%esp
f011f24d:	50                   	push   %eax
f011f24e:	ff 75 d0             	pushl  -0x30(%ebp)
f011f251:	68 24 f8 12 f0       	push   $0xf012f824
f011f256:	e8 11 1d fe ff       	call   f0100f6c <cprintf>
f011f25b:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f25e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f262:	74 04                	je     f011f268 <test_ksbrk+0x23b>
			eval += 5;
f011f264:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	{ // +2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011f268:	e8 70 e7 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f26d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f270:	e8 a0 55 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f275:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f278:	83 ec 0c             	sub    $0xc,%esp
f011f27b:	6a 00                	push   $0x0
f011f27d:	e8 ff 97 fe ff       	call   f0108a81 <sbrk>
f011f282:	83 c4 10             	add    $0x10,%esp
f011f285:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[2] = sbrk(2 * kilo);
f011f288:	83 ec 0c             	sub    $0xc,%esp
f011f28b:	68 00 08 00 00       	push   $0x800
f011f290:	e8 ec 97 fe ff       	call   f0108a81 <sbrk>
f011f295:	83 c4 10             	add    $0x10,%esp
f011f298:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
		newBrk = (uint32)sbrk(0);
f011f29e:	83 ec 0c             	sub    $0xc,%esp
f011f2a1:	6a 00                	push   $0x0
f011f2a3:	e8 d9 97 fe ff       	call   f0108a81 <sbrk>
f011f2a8:	83 c4 10             	add    $0x10,%esp
f011f2ab:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f2ae:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f2b5:	e8 5b 55 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f2ba:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f2bd:	74 17                	je     f011f2d6 <test_ksbrk+0x2a9>
		{
			correct = 0;
f011f2bf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f2c6:	83 ec 0c             	sub    $0xc,%esp
f011f2c9:	68 20 f7 12 f0       	push   $0xf012f720
f011f2ce:	e8 99 1c fe ff       	call   f0100f6c <cprintf>
f011f2d3:	83 c4 10             	add    $0x10,%esp
		}
		int x = (freeFrames - (int)sys_calculate_free_frames());
f011f2d6:	e8 02 e7 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f2db:	89 c2                	mov    %eax,%edx
f011f2dd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f2e0:	29 d0                	sub    %edx,%eax
f011f2e2:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011f2e5:	e8 f3 e6 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f2ea:	89 c2                	mov    %eax,%edx
f011f2ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f2ef:	29 d0                	sub    %edx,%eax
f011f2f1:	83 f8 01             	cmp    $0x1,%eax
f011f2f4:	74 17                	je     f011f30d <test_ksbrk+0x2e0>
		{
			correct = 0;
f011f2f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f2fd:	83 ec 0c             	sub    $0xc,%esp
f011f300:	68 88 f7 12 f0       	push   $0xf012f788
f011f305:	e8 62 1c fe ff       	call   f0100f6c <cprintf>
f011f30a:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[2] != expectedVAs[2])
f011f30d:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011f313:	89 c2                	mov    %eax,%edx
f011f315:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f011f31b:	39 c2                	cmp    %eax,%edx
f011f31d:	74 25                	je     f011f344 <test_ksbrk+0x317>
		{
			correct = 0;
f011f31f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[2], ptr_allocations[2]);
f011f326:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
f011f32c:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f011f332:	83 ec 04             	sub    $0x4,%esp
f011f335:	52                   	push   %edx
f011f336:	50                   	push   %eax
f011f337:	68 c8 f7 12 f0       	push   $0xf012f7c8
f011f33c:	e8 2b 1c fe ff       	call   f0100f6c <cprintf>
f011f341:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[2])
f011f344:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011f34a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f34d:	74 21                	je     f011f370 <test_ksbrk+0x343>
		{
			correct = 0;
f011f34f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[2]);
f011f356:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011f35c:	83 ec 04             	sub    $0x4,%esp
f011f35f:	50                   	push   %eax
f011f360:	ff 75 d0             	pushl  -0x30(%ebp)
f011f363:	68 24 f8 12 f0       	push   $0xf012f824
f011f368:	e8 ff 1b fe ff       	call   f0100f6c <cprintf>
f011f36d:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f370:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f374:	74 04                	je     f011f37a <test_ksbrk+0x34d>
			eval += 5;
f011f376:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	cprintf("STEP C: checking increment with -ve value [No Frames to be Deallocated]\n");
f011f37a:	83 ec 0c             	sub    $0xc,%esp
f011f37d:	68 50 f8 12 f0       	push   $0xf012f850
f011f382:	e8 e5 1b fe ff       	call   f0100f6c <cprintf>
f011f387:	83 c4 10             	add    $0x10,%esp
	{ // -512 Bytes
		freeFrames = (int)sys_calculate_free_frames();
f011f38a:	e8 4e e6 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f38f:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f392:	e8 7e 54 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f397:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f39a:	83 ec 0c             	sub    $0xc,%esp
f011f39d:	6a 00                	push   $0x0
f011f39f:	e8 dd 96 fe ff       	call   f0108a81 <sbrk>
f011f3a4:	83 c4 10             	add    $0x10,%esp
f011f3a7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[3] = sbrk(-512);
f011f3aa:	83 ec 0c             	sub    $0xc,%esp
f011f3ad:	68 00 fe ff ff       	push   $0xfffffe00
f011f3b2:	e8 ca 96 fe ff       	call   f0108a81 <sbrk>
f011f3b7:	83 c4 10             	add    $0x10,%esp
f011f3ba:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		newBrk = (uint32)sbrk(0);
f011f3c0:	83 ec 0c             	sub    $0xc,%esp
f011f3c3:	6a 00                	push   $0x0
f011f3c5:	e8 b7 96 fe ff       	call   f0108a81 <sbrk>
f011f3ca:	83 c4 10             	add    $0x10,%esp
f011f3cd:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f3d0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f3d7:	e8 39 54 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f3dc:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f3df:	74 17                	je     f011f3f8 <test_ksbrk+0x3cb>
		{
			correct = 0;
f011f3e1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f3e8:	83 ec 0c             	sub    $0xc,%esp
f011f3eb:	68 20 f7 12 f0       	push   $0xf012f720
f011f3f0:	e8 77 1b fe ff       	call   f0100f6c <cprintf>
f011f3f5:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011f3f8:	e8 e0 e5 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f3fd:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011f400:	74 17                	je     f011f419 <test_ksbrk+0x3ec>
		{
			correct = 0;
f011f402:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f409:	83 ec 0c             	sub    $0xc,%esp
f011f40c:	68 88 f7 12 f0       	push   $0xf012f788
f011f411:	e8 56 1b fe ff       	call   f0100f6c <cprintf>
f011f416:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[3] != expectedVAs[3])
f011f419:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011f41f:	89 c2                	mov    %eax,%edx
f011f421:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011f427:	39 c2                	cmp    %eax,%edx
f011f429:	74 25                	je     f011f450 <test_ksbrk+0x423>
		{
			correct = 0;
f011f42b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[3], ptr_allocations[3]);
f011f432:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f011f438:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011f43e:	83 ec 04             	sub    $0x4,%esp
f011f441:	52                   	push   %edx
f011f442:	50                   	push   %eax
f011f443:	68 c8 f7 12 f0       	push   $0xf012f7c8
f011f448:	e8 1f 1b fe ff       	call   f0100f6c <cprintf>
f011f44d:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[3])
f011f450:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011f456:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f459:	74 21                	je     f011f47c <test_ksbrk+0x44f>
		{
			correct = 0;
f011f45b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[3]);
f011f462:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011f468:	83 ec 04             	sub    $0x4,%esp
f011f46b:	50                   	push   %eax
f011f46c:	ff 75 d0             	pushl  -0x30(%ebp)
f011f46f:	68 24 f8 12 f0       	push   $0xf012f824
f011f474:	e8 f3 1a fe ff       	call   f0100f6c <cprintf>
f011f479:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f47c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f480:	74 04                	je     f011f486 <test_ksbrk+0x459>
			eval += 10;
f011f482:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	{ // -2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011f486:	e8 52 e5 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f48b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f48e:	e8 82 53 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f493:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f496:	83 ec 0c             	sub    $0xc,%esp
f011f499:	6a 00                	push   $0x0
f011f49b:	e8 e1 95 fe ff       	call   f0108a81 <sbrk>
f011f4a0:	83 c4 10             	add    $0x10,%esp
f011f4a3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[4] = sbrk(-2 * kilo);
f011f4a6:	83 ec 0c             	sub    $0xc,%esp
f011f4a9:	68 00 f8 ff ff       	push   $0xfffff800
f011f4ae:	e8 ce 95 fe ff       	call   f0108a81 <sbrk>
f011f4b3:	83 c4 10             	add    $0x10,%esp
f011f4b6:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		newBrk = (uint32)sbrk(0);
f011f4bc:	83 ec 0c             	sub    $0xc,%esp
f011f4bf:	6a 00                	push   $0x0
f011f4c1:	e8 bb 95 fe ff       	call   f0108a81 <sbrk>
f011f4c6:	83 c4 10             	add    $0x10,%esp
f011f4c9:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f4cc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f4d3:	e8 3d 53 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f4d8:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f4db:	74 17                	je     f011f4f4 <test_ksbrk+0x4c7>
		{
			correct = 0;
f011f4dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f4e4:	83 ec 0c             	sub    $0xc,%esp
f011f4e7:	68 20 f7 12 f0       	push   $0xf012f720
f011f4ec:	e8 7b 1a fe ff       	call   f0100f6c <cprintf>
f011f4f1:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011f4f4:	e8 e4 e4 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f4f9:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011f4fc:	74 17                	je     f011f515 <test_ksbrk+0x4e8>
		{
			correct = 0;
f011f4fe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f505:	83 ec 0c             	sub    $0xc,%esp
f011f508:	68 88 f7 12 f0       	push   $0xf012f788
f011f50d:	e8 5a 1a fe ff       	call   f0100f6c <cprintf>
f011f512:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[4] != expectedVAs[4])
f011f515:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011f51b:	89 c2                	mov    %eax,%edx
f011f51d:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011f523:	39 c2                	cmp    %eax,%edx
f011f525:	74 25                	je     f011f54c <test_ksbrk+0x51f>
		{
			correct = 0;
f011f527:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[4], ptr_allocations[4]);
f011f52e:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011f534:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011f53a:	83 ec 04             	sub    $0x4,%esp
f011f53d:	52                   	push   %edx
f011f53e:	50                   	push   %eax
f011f53f:	68 c8 f7 12 f0       	push   $0xf012f7c8
f011f544:	e8 23 1a fe ff       	call   f0100f6c <cprintf>
f011f549:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[4])
f011f54c:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011f552:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f555:	74 21                	je     f011f578 <test_ksbrk+0x54b>
		{
			correct = 0;
f011f557:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[4]);
f011f55e:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011f564:	83 ec 04             	sub    $0x4,%esp
f011f567:	50                   	push   %eax
f011f568:	ff 75 d0             	pushl  -0x30(%ebp)
f011f56b:	68 24 f8 12 f0       	push   $0xf012f824
f011f570:	e8 f7 19 fe ff       	call   f0100f6c <cprintf>
f011f575:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f578:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f57c:	74 04                	je     f011f582 <test_ksbrk+0x555>
			eval += 10;
f011f57e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("STEP D: checking increment with -ve value [ONE Frame should be Deallocated]\n");
f011f582:	83 ec 0c             	sub    $0xc,%esp
f011f585:	68 9c f8 12 f0       	push   $0xf012f89c
f011f58a:	e8 dd 19 fe ff       	call   f0100f6c <cprintf>
f011f58f:	83 c4 10             	add    $0x10,%esp
	{ // -2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011f592:	e8 46 e4 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f597:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f59a:	e8 76 52 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f59f:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f5a2:	83 ec 0c             	sub    $0xc,%esp
f011f5a5:	6a 00                	push   $0x0
f011f5a7:	e8 d5 94 fe ff       	call   f0108a81 <sbrk>
f011f5ac:	83 c4 10             	add    $0x10,%esp
f011f5af:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[5] = sbrk(-2 * kilo);
f011f5b2:	83 ec 0c             	sub    $0xc,%esp
f011f5b5:	68 00 f8 ff ff       	push   $0xfffff800
f011f5ba:	e8 c2 94 fe ff       	call   f0108a81 <sbrk>
f011f5bf:	83 c4 10             	add    $0x10,%esp
f011f5c2:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		newBrk = (uint32)sbrk(0);
f011f5c8:	83 ec 0c             	sub    $0xc,%esp
f011f5cb:	6a 00                	push   $0x0
f011f5cd:	e8 af 94 fe ff       	call   f0108a81 <sbrk>
f011f5d2:	83 c4 10             	add    $0x10,%esp
f011f5d5:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f5d8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)(int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f5df:	e8 31 52 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f5e4:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f5e7:	74 17                	je     f011f600 <test_ksbrk+0x5d3>
		{
			correct = 0;
f011f5e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f5f0:	83 ec 0c             	sub    $0xc,%esp
f011f5f3:	68 20 f7 12 f0       	push   $0xf012f720
f011f5f8:	e8 6f 19 fe ff       	call   f0100f6c <cprintf>
f011f5fd:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 1)
f011f600:	e8 d8 e3 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f605:	2b 45 dc             	sub    -0x24(%ebp),%eax
f011f608:	83 f8 01             	cmp    $0x1,%eax
f011f60b:	74 17                	je     f011f624 <test_ksbrk+0x5f7>
		{
			correct = 0;
f011f60d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f614:	83 ec 0c             	sub    $0xc,%esp
f011f617:	68 88 f7 12 f0       	push   $0xf012f788
f011f61c:	e8 4b 19 fe ff       	call   f0100f6c <cprintf>
f011f621:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[5] != expectedVAs[5])
f011f624:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011f62a:	89 c2                	mov    %eax,%edx
f011f62c:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011f632:	39 c2                	cmp    %eax,%edx
f011f634:	74 25                	je     f011f65b <test_ksbrk+0x62e>
		{
			correct = 0;
f011f636:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[5], ptr_allocations[5]);
f011f63d:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011f643:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011f649:	83 ec 04             	sub    $0x4,%esp
f011f64c:	52                   	push   %edx
f011f64d:	50                   	push   %eax
f011f64e:	68 c8 f7 12 f0       	push   $0xf012f7c8
f011f653:	e8 14 19 fe ff       	call   f0100f6c <cprintf>
f011f658:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[5])
f011f65b:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011f661:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f664:	74 21                	je     f011f687 <test_ksbrk+0x65a>
		{
			correct = 0;
f011f666:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[5]);
f011f66d:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011f673:	83 ec 04             	sub    $0x4,%esp
f011f676:	50                   	push   %eax
f011f677:	ff 75 d0             	pushl  -0x30(%ebp)
f011f67a:	68 24 f8 12 f0       	push   $0xf012f824
f011f67f:	e8 e8 18 fe ff       	call   f0100f6c <cprintf>
f011f684:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f687:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f68b:	74 04                	je     f011f691 <test_ksbrk+0x664>
			eval += 15;
f011f68d:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP E: checking increment with +ve value [No Frames to be Allocated]\n");
f011f691:	83 ec 0c             	sub    $0xc,%esp
f011f694:	68 ec f8 12 f0       	push   $0xf012f8ec
f011f699:	e8 ce 18 fe ff       	call   f0100f6c <cprintf>
f011f69e:	83 c4 10             	add    $0x10,%esp
	{ // 128 Bytes
		freeFrames = (int)(int)sys_calculate_free_frames();
f011f6a1:	e8 37 e3 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f6a6:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)(int)pf_calculate_free_frames();
f011f6a9:	e8 67 51 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f6ae:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f6b1:	83 ec 0c             	sub    $0xc,%esp
f011f6b4:	6a 00                	push   $0x0
f011f6b6:	e8 c6 93 fe ff       	call   f0108a81 <sbrk>
f011f6bb:	83 c4 10             	add    $0x10,%esp
f011f6be:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[6] = sbrk(128);
f011f6c1:	83 ec 0c             	sub    $0xc,%esp
f011f6c4:	68 80 00 00 00       	push   $0x80
f011f6c9:	e8 b3 93 fe ff       	call   f0108a81 <sbrk>
f011f6ce:	83 c4 10             	add    $0x10,%esp
f011f6d1:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		newBrk = (uint32)sbrk(0);
f011f6d7:	83 ec 0c             	sub    $0xc,%esp
f011f6da:	6a 00                	push   $0x0
f011f6dc:	e8 a0 93 fe ff       	call   f0108a81 <sbrk>
f011f6e1:	83 c4 10             	add    $0x10,%esp
f011f6e4:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f6e7:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f6ee:	e8 22 51 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f6f3:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f6f6:	74 17                	je     f011f70f <test_ksbrk+0x6e2>
		{
			correct = 0;
f011f6f8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f6ff:	83 ec 0c             	sub    $0xc,%esp
f011f702:	68 20 f7 12 f0       	push   $0xf012f720
f011f707:	e8 60 18 fe ff       	call   f0100f6c <cprintf>
f011f70c:	83 c4 10             	add    $0x10,%esp
		}
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 0)
f011f70f:	e8 c9 e2 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f714:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011f717:	74 17                	je     f011f730 <test_ksbrk+0x703>
		{
			correct = 0;
f011f719:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011f720:	83 ec 0c             	sub    $0xc,%esp
f011f723:	68 88 f7 12 f0       	push   $0xf012f788
f011f728:	e8 3f 18 fe ff       	call   f0100f6c <cprintf>
f011f72d:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[6] != expectedVAs[6])
f011f730:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011f736:	89 c2                	mov    %eax,%edx
f011f738:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f011f73e:	39 c2                	cmp    %eax,%edx
f011f740:	74 25                	je     f011f767 <test_ksbrk+0x73a>
		{
			correct = 0;
f011f742:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[6], ptr_allocations[6]);
f011f749:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011f74f:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f011f755:	83 ec 04             	sub    $0x4,%esp
f011f758:	52                   	push   %edx
f011f759:	50                   	push   %eax
f011f75a:	68 c8 f7 12 f0       	push   $0xf012f7c8
f011f75f:	e8 08 18 fe ff       	call   f0100f6c <cprintf>
f011f764:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[6])
f011f767:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011f76d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f770:	74 21                	je     f011f793 <test_ksbrk+0x766>
		{
			correct = 0;
f011f772:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[6]);
f011f779:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011f77f:	83 ec 04             	sub    $0x4,%esp
f011f782:	50                   	push   %eax
f011f783:	ff 75 d0             	pushl  -0x30(%ebp)
f011f786:	68 24 f8 12 f0       	push   $0xf012f824
f011f78b:	e8 dc 17 fe ff       	call   f0100f6c <cprintf>
f011f790:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f793:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f797:	74 04                	je     f011f79d <test_ksbrk+0x770>
			eval += 15;
f011f799:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP F: checking increment with +ve value [ONE Frame should be Allocated]\n");
f011f79d:	83 ec 0c             	sub    $0xc,%esp
f011f7a0:	68 34 f9 12 f0       	push   $0xf012f934
f011f7a5:	e8 c2 17 fe ff       	call   f0100f6c <cprintf>
f011f7aa:	83 c4 10             	add    $0x10,%esp
	{ // 1 KB
		freeFrames = (int)(int)sys_calculate_free_frames();
f011f7ad:	e8 2b e2 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f7b2:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f7b5:	e8 5b 50 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f7ba:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f7bd:	83 ec 0c             	sub    $0xc,%esp
f011f7c0:	6a 00                	push   $0x0
f011f7c2:	e8 ba 92 fe ff       	call   f0108a81 <sbrk>
f011f7c7:	83 c4 10             	add    $0x10,%esp
f011f7ca:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[7] = sbrk(kilo);
f011f7cd:	83 ec 0c             	sub    $0xc,%esp
f011f7d0:	68 00 04 00 00       	push   $0x400
f011f7d5:	e8 a7 92 fe ff       	call   f0108a81 <sbrk>
f011f7da:	83 c4 10             	add    $0x10,%esp
f011f7dd:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		newBrk = (uint32)sbrk(0);
f011f7e3:	83 ec 0c             	sub    $0xc,%esp
f011f7e6:	6a 00                	push   $0x0
f011f7e8:	e8 94 92 fe ff       	call   f0108a81 <sbrk>
f011f7ed:	83 c4 10             	add    $0x10,%esp
f011f7f0:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f7f3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f7fa:	e8 16 50 fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f7ff:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f802:	74 17                	je     f011f81b <test_ksbrk+0x7ee>
		{
			correct = 0;
f011f804:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f80b:	83 ec 0c             	sub    $0xc,%esp
f011f80e:	68 20 f7 12 f0       	push   $0xf012f720
f011f813:	e8 54 17 fe ff       	call   f0100f6c <cprintf>
f011f818:	83 c4 10             	add    $0x10,%esp
		}
		//cprintf("((int)(int)sys_calculate_free_frames() - freeFrames) = %d\n", ((int)(int)sys_calculate_free_frames() - freeFrames));
		if ((freeFrames - (int)(int)sys_calculate_free_frames()) != 1)
f011f81b:	e8 bd e1 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f820:	89 c2                	mov    %eax,%edx
f011f822:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f825:	29 d0                	sub    %edx,%eax
f011f827:	83 f8 01             	cmp    $0x1,%eax
f011f82a:	74 17                	je     f011f843 <test_ksbrk+0x816>
		{
			correct = 0;
f011f82c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong allocation: pages are not loaded successfully into memory");
f011f833:	83 ec 0c             	sub    $0xc,%esp
f011f836:	68 80 f9 12 f0       	push   $0xf012f980
f011f83b:	e8 2c 17 fe ff       	call   f0100f6c <cprintf>
f011f840:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[7] != expectedVAs[7])
f011f843:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011f849:	89 c2                	mov    %eax,%edx
f011f84b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011f851:	39 c2                	cmp    %eax,%edx
f011f853:	74 25                	je     f011f87a <test_ksbrk+0x84d>
		{
			correct = 0;
f011f855:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[7], ptr_allocations[7]);
f011f85c:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011f862:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011f868:	83 ec 04             	sub    $0x4,%esp
f011f86b:	52                   	push   %edx
f011f86c:	50                   	push   %eax
f011f86d:	68 c4 f9 12 f0       	push   $0xf012f9c4
f011f872:	e8 f5 16 fe ff       	call   f0100f6c <cprintf>
f011f877:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[7])
f011f87a:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011f880:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f883:	74 21                	je     f011f8a6 <test_ksbrk+0x879>
		{
			correct = 0;
f011f885:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[7]);
f011f88c:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011f892:	83 ec 04             	sub    $0x4,%esp
f011f895:	50                   	push   %eax
f011f896:	ff 75 d0             	pushl  -0x30(%ebp)
f011f899:	68 f8 f9 12 f0       	push   $0xf012f9f8
f011f89e:	e8 c9 16 fe ff       	call   f0100f6c <cprintf>
f011f8a3:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f8a6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f8aa:	74 04                	je     f011f8b0 <test_ksbrk+0x883>
			eval += 15;
f011f8ac:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP G: checking increment with -ve value [TWO Frames should be Deallocated]\n");
f011f8b0:	83 ec 0c             	sub    $0xc,%esp
f011f8b3:	68 28 fa 12 f0       	push   $0xf012fa28
f011f8b8:	e8 af 16 fe ff       	call   f0100f6c <cprintf>
f011f8bd:	83 c4 10             	add    $0x10,%esp
	{ // -9 KB
		freeFrames = (int)sys_calculate_free_frames();
f011f8c0:	e8 18 e1 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f8c5:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f8c8:	e8 48 4f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f8cd:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f8d0:	83 ec 0c             	sub    $0xc,%esp
f011f8d3:	6a 00                	push   $0x0
f011f8d5:	e8 a7 91 fe ff       	call   f0108a81 <sbrk>
f011f8da:	83 c4 10             	add    $0x10,%esp
f011f8dd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[8] = sbrk(-9 * kilo);
f011f8e0:	83 ec 0c             	sub    $0xc,%esp
f011f8e3:	68 00 dc ff ff       	push   $0xffffdc00
f011f8e8:	e8 94 91 fe ff       	call   f0108a81 <sbrk>
f011f8ed:	83 c4 10             	add    $0x10,%esp
f011f8f0:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		newBrk = (uint32)sbrk(0);
f011f8f6:	83 ec 0c             	sub    $0xc,%esp
f011f8f9:	6a 00                	push   $0x0
f011f8fb:	e8 81 91 fe ff       	call   f0108a81 <sbrk>
f011f900:	83 c4 10             	add    $0x10,%esp
f011f903:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011f906:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)(int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011f90d:	e8 03 4f fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f912:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f915:	74 17                	je     f011f92e <test_ksbrk+0x901>
		{
			correct = 0;
f011f917:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011f91e:	83 ec 0c             	sub    $0xc,%esp
f011f921:	68 20 f7 12 f0       	push   $0xf012f720
f011f926:	e8 41 16 fe ff       	call   f0100f6c <cprintf>
f011f92b:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 2)
f011f92e:	e8 aa e0 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f933:	2b 45 dc             	sub    -0x24(%ebp),%eax
f011f936:	83 f8 02             	cmp    $0x2,%eax
f011f939:	74 17                	je     f011f952 <test_ksbrk+0x925>
		{
			correct = 0;
f011f93b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong allocation: pages are not loaded successfully into memory");
f011f942:	83 ec 0c             	sub    $0xc,%esp
f011f945:	68 78 fa 12 f0       	push   $0xf012fa78
f011f94a:	e8 1d 16 fe ff       	call   f0100f6c <cprintf>
f011f94f:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[8] != expectedVAs[8])
f011f952:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011f958:	89 c2                	mov    %eax,%edx
f011f95a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011f960:	39 c2                	cmp    %eax,%edx
f011f962:	74 25                	je     f011f989 <test_ksbrk+0x95c>
		{
			correct = 0;
f011f964:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[5], ptr_allocations[5]);
f011f96b:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011f971:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011f977:	83 ec 04             	sub    $0x4,%esp
f011f97a:	52                   	push   %edx
f011f97b:	50                   	push   %eax
f011f97c:	68 bc fa 12 f0       	push   $0xf012fabc
f011f981:	e8 e6 15 fe ff       	call   f0100f6c <cprintf>
f011f986:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[8])
f011f989:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011f98f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011f992:	74 21                	je     f011f9b5 <test_ksbrk+0x988>
		{
			correct = 0;
f011f994:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[5]);
f011f99b:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011f9a1:	83 ec 04             	sub    $0x4,%esp
f011f9a4:	50                   	push   %eax
f011f9a5:	ff 75 d0             	pushl  -0x30(%ebp)
f011f9a8:	68 f0 fa 12 f0       	push   $0xf012faf0
f011f9ad:	e8 ba 15 fe ff       	call   f0100f6c <cprintf>
f011f9b2:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011f9b5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f9b9:	74 04                	je     f011f9bf <test_ksbrk+0x992>
			eval += 10;
f011f9bb:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("STEP H: checking increment with +ve value [THREE Frames should be Allocated]\n");
f011f9bf:	83 ec 0c             	sub    $0xc,%esp
f011f9c2:	68 20 fb 12 f0       	push   $0xf012fb20
f011f9c7:	e8 a0 15 fe ff       	call   f0100f6c <cprintf>
f011f9cc:	83 c4 10             	add    $0x10,%esp
	{ // 10 KB
		freeFrames = (int)(int)sys_calculate_free_frames();
f011f9cf:	e8 09 e0 fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011f9d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011f9d7:	e8 39 4e fe ff       	call   f0104815 <pf_calculate_free_frames>
f011f9dc:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011f9df:	83 ec 0c             	sub    $0xc,%esp
f011f9e2:	6a 00                	push   $0x0
f011f9e4:	e8 98 90 fe ff       	call   f0108a81 <sbrk>
f011f9e9:	83 c4 10             	add    $0x10,%esp
f011f9ec:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[9] = sbrk(10*kilo);
f011f9ef:	83 ec 0c             	sub    $0xc,%esp
f011f9f2:	68 00 28 00 00       	push   $0x2800
f011f9f7:	e8 85 90 fe ff       	call   f0108a81 <sbrk>
f011f9fc:	83 c4 10             	add    $0x10,%esp
f011f9ff:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		newBrk = (uint32)sbrk(0);
f011fa05:	83 ec 0c             	sub    $0xc,%esp
f011fa08:	6a 00                	push   $0x0
f011fa0a:	e8 72 90 fe ff       	call   f0108a81 <sbrk>
f011fa0f:	83 c4 10             	add    $0x10,%esp
f011fa12:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011fa15:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011fa1c:	e8 f4 4d fe ff       	call   f0104815 <pf_calculate_free_frames>
f011fa21:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011fa24:	74 17                	je     f011fa3d <test_ksbrk+0xa10>
		{
			correct = 0;
f011fa26:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011fa2d:	83 ec 0c             	sub    $0xc,%esp
f011fa30:	68 20 f7 12 f0       	push   $0xf012f720
f011fa35:	e8 32 15 fe ff       	call   f0100f6c <cprintf>
f011fa3a:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)(int)sys_calculate_free_frames()) != 3)
f011fa3d:	e8 9b df fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011fa42:	89 c2                	mov    %eax,%edx
f011fa44:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fa47:	29 d0                	sub    %edx,%eax
f011fa49:	83 f8 03             	cmp    $0x3,%eax
f011fa4c:	74 17                	je     f011fa65 <test_ksbrk+0xa38>
		{
			correct = 0;
f011fa4e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong allocation: pages are not loaded successfully into memory");
f011fa55:	83 ec 0c             	sub    $0xc,%esp
f011fa58:	68 70 fb 12 f0       	push   $0xf012fb70
f011fa5d:	e8 0a 15 fe ff       	call   f0100f6c <cprintf>
f011fa62:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[9] != expectedVAs[9])
f011fa65:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011fa6b:	89 c2                	mov    %eax,%edx
f011fa6d:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f011fa73:	39 c2                	cmp    %eax,%edx
f011fa75:	74 25                	je     f011fa9c <test_ksbrk+0xa6f>
		{
			correct = 0;
f011fa77:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[7], ptr_allocations[7]);
f011fa7e:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011fa84:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011fa8a:	83 ec 04             	sub    $0x4,%esp
f011fa8d:	52                   	push   %edx
f011fa8e:	50                   	push   %eax
f011fa8f:	68 b4 fb 12 f0       	push   $0xf012fbb4
f011fa94:	e8 d3 14 fe ff       	call   f0100f6c <cprintf>
f011fa99:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[9])
f011fa9c:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
f011faa2:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011faa5:	74 21                	je     f011fac8 <test_ksbrk+0xa9b>
		{
			correct = 0;
f011faa7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[7]);
f011faae:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011fab4:	83 ec 04             	sub    $0x4,%esp
f011fab7:	50                   	push   %eax
f011fab8:	ff 75 d0             	pushl  -0x30(%ebp)
f011fabb:	68 e8 fb 12 f0       	push   $0xf012fbe8
f011fac0:	e8 a7 14 fe ff       	call   f0100f6c <cprintf>
f011fac5:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011fac8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011facc:	74 04                	je     f011fad2 <test_ksbrk+0xaa5>
			eval += 10;
f011face:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}

	//cprintf("Test kheap sbrk completed. Evaluation = %d%%\n", eval);
	cprintf("[AUTO_GR@DING_PARTIAL]%d\n", eval);
f011fad2:	83 ec 08             	sub    $0x8,%esp
f011fad5:	ff 75 e4             	pushl  -0x1c(%ebp)
f011fad8:	68 15 fc 12 f0       	push   $0xf012fc15
f011fadd:	e8 8a 14 fe ff       	call   f0100f6c <cprintf>
f011fae2:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011fae5:	83 ec 0c             	sub    $0xc,%esp
f011fae8:	68 2f fc 12 f0       	push   $0xf012fc2f
f011faed:	e8 7a 14 fe ff       	call   f0100f6c <cprintf>
f011faf2:	83 c4 10             	add    $0x10,%esp
	return 0;
f011faf5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fafa:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011fafd:	5b                   	pop    %ebx
f011fafe:	5e                   	pop    %esi
f011faff:	5f                   	pop    %edi
f011fb00:	5d                   	pop    %ebp
f011fb01:	c3                   	ret    

f011fb02 <test_kmalloc_nextfit>:




int test_kmalloc_nextfit()
{
f011fb02:	55                   	push   %ebp
f011fb03:	89 e5                	mov    %esp,%ebp
f011fb05:	81 ec 88 02 00 00    	sub    $0x288,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011fb0b:	83 ec 04             	sub    $0x4,%esp
f011fb0e:	68 c8 fc 12 f0       	push   $0xf012fcc8
f011fb13:	68 76 08 00 00       	push   $0x876
f011fb18:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fb1d:	e8 f8 07 fe ff       	call   f010031a <_panic>

f011fb22 <test_kmalloc_bestfit1>:
	return 1;

}

int test_kmalloc_bestfit1()
{
f011fb22:	55                   	push   %ebp
f011fb23:	89 e5                	mov    %esp,%ebp
f011fb25:	83 ec 58             	sub    $0x58,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011fb28:	83 ec 04             	sub    $0x4,%esp
f011fb2b:	68 c8 fc 12 f0       	push   $0xf012fcc8
f011fb30:	68 1c 09 00 00       	push   $0x91c
f011fb35:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fb3a:	e8 db 07 fe ff       	call   f010031a <_panic>

f011fb3f <test_kmalloc_bestfit2>:
	return 1;

}

int test_kmalloc_bestfit2()
{
f011fb3f:	55                   	push   %ebp
f011fb40:	89 e5                	mov    %esp,%ebp
f011fb42:	83 ec 58             	sub    $0x58,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011fb45:	83 ec 04             	sub    $0x4,%esp
f011fb48:	68 c8 fc 12 f0       	push   $0xf012fcc8
f011fb4d:	68 c8 09 00 00       	push   $0x9c8
f011fb52:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fb57:	e8 be 07 fe ff       	call   f010031a <_panic>

f011fb5c <test_kmalloc_worstfit>:
	return 1;

}

int test_kmalloc_worstfit()
{
f011fb5c:	55                   	push   %ebp
f011fb5d:	89 e5                	mov    %esp,%ebp
f011fb5f:	81 ec 88 02 00 00    	sub    $0x288,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011fb65:	83 ec 04             	sub    $0x4,%esp
f011fb68:	68 c8 fc 12 f0       	push   $0xf012fcc8
f011fb6d:	68 6e 0a 00 00       	push   $0xa6e
f011fb72:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fb77:	e8 9e 07 fe ff       	call   f010031a <_panic>

f011fb7c <test_kfree>:

	return 1;
}

int test_kfree()
{
f011fb7c:	55                   	push   %ebp
f011fb7d:	89 e5                	mov    %esp,%ebp
f011fb7f:	81 ec 08 01 00 00    	sub    $0x108,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011fb85:	83 ec 04             	sub    $0x4,%esp
f011fb88:	68 c8 fc 12 f0       	push   $0xf012fcc8
f011fb8d:	68 14 0b 00 00       	push   $0xb14
f011fb92:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fb97:	e8 7e 07 fe ff       	call   f010031a <_panic>

f011fb9c <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011fb9c:	55                   	push   %ebp
f011fb9d:	89 e5                	mov    %esp,%ebp
f011fb9f:	57                   	push   %edi
f011fba0:	56                   	push   %esi
f011fba1:	53                   	push   %ebx
f011fba2:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011fba8:	a0 dc 0d 18 f0       	mov    0xf0180ddc,%al
f011fbad:	84 c0                	test   %al,%al
f011fbaf:	74 56                	je     f011fc07 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011fbb1:	c6 05 dc 0d 18 f0 00 	movb   $0x0,0xf0180ddc
		initFreeFrames = sys_calculate_free_frames() ;
f011fbb8:	e8 20 de fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011fbbd:	a3 68 72 5c f0       	mov    %eax,0xf05c7268
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011fbc2:	e8 4e 4c fe ff       	call   f0104815 <pf_calculate_free_frames>
f011fbc7:	a3 64 72 5c f0       	mov    %eax,0xf05c7264
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011fbcc:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011fbd2:	bb 25 fe 12 f0       	mov    $0xf012fe25,%ebx
f011fbd7:	ba 11 00 00 00       	mov    $0x11,%edx
f011fbdc:	89 c7                	mov    %eax,%edi
f011fbde:	89 de                	mov    %ebx,%esi
f011fbe0:	89 d1                	mov    %edx,%ecx
f011fbe2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011fbe4:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011fbea:	b9 53 00 00 00       	mov    $0x53,%ecx
f011fbef:	b0 00                	mov    $0x0,%al
f011fbf1:	89 d7                	mov    %edx,%edi
f011fbf3:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011fbf5:	83 ec 0c             	sub    $0xc,%esp
f011fbf8:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011fbfe:	50                   	push   %eax
f011fbff:	e8 d8 22 fe ff       	call   f0101edc <execute_command>
f011fc04:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011fc07:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011fc0e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011fc15:	a1 80 1e 5a f0       	mov    0xf05a1e80,%eax
f011fc1a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011fc1d:	eb 2b                	jmp    f011fc4a <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011fc1f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fc22:	83 c0 20             	add    $0x20,%eax
f011fc25:	83 ec 08             	sub    $0x8,%esp
f011fc28:	68 0d fd 12 f0       	push   $0xf012fd0d
f011fc2d:	50                   	push   %eax
f011fc2e:	e8 e5 28 00 00       	call   f0122518 <strcmp>
f011fc33:	83 c4 10             	add    $0x10,%esp
f011fc36:	85 c0                	test   %eax,%eax
f011fc38:	75 08                	jne    f011fc42 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011fc3a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fc3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011fc40:	eb 2f                	jmp    f011fc71 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011fc42:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f011fc47:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011fc4a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fc4e:	74 08                	je     f011fc58 <test_three_creation_functions+0xbc>
f011fc50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fc53:	8b 40 08             	mov    0x8(%eax),%eax
f011fc56:	eb 05                	jmp    f011fc5d <test_three_creation_functions+0xc1>
f011fc58:	b8 00 00 00 00       	mov    $0x0,%eax
f011fc5d:	a3 88 1e 5a f0       	mov    %eax,0xf05a1e88
f011fc62:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f011fc67:	85 c0                	test   %eax,%eax
f011fc69:	75 b4                	jne    f011fc1f <test_three_creation_functions+0x83>
f011fc6b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fc6f:	75 ae                	jne    f011fc1f <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011fc71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011fc74:	8b 80 40 da 01 00    	mov    0x1da40(%eax),%eax
f011fc7a:	85 c0                	test   %eax,%eax
f011fc7c:	74 17                	je     f011fc95 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011fc7e:	83 ec 04             	sub    $0x4,%esp
f011fc81:	68 18 fd 12 f0       	push   $0xf012fd18
f011fc86:	68 f0 0c 00 00       	push   $0xcf0
f011fc8b:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fc90:	e8 85 06 fe ff       	call   f010031a <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
#else
		int pagesInWS = env_page_ws_get_size(e);
f011fc95:	83 ec 0c             	sub    $0xc,%esp
f011fc98:	ff 75 e4             	pushl  -0x1c(%ebp)
f011fc9b:	e8 93 90 fe ff       	call   f0108d33 <env_page_ws_get_size>
f011fca0:	83 c4 10             	add    $0x10,%esp
f011fca3:	89 45 dc             	mov    %eax,-0x24(%ebp)
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011fca6:	e8 32 dd fe ff       	call   f010d9dd <sys_calculate_free_frames>
f011fcab:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011fcae:	e8 62 4b fe ff       	call   f0104815 <pf_calculate_free_frames>
f011fcb3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011fcb6:	a1 64 72 5c f0       	mov    0xf05c7264,%eax
f011fcbb:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011fcbe:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011fcc1:	74 17                	je     f011fcda <test_three_creation_functions+0x13e>
f011fcc3:	83 ec 04             	sub    $0x4,%esp
f011fcc6:	68 20 f7 12 f0       	push   $0xf012f720
f011fccb:	68 fa 0c 00 00       	push   $0xcfa
f011fcd0:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fcd5:	e8 40 06 fe ff       	call   f010031a <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011fcda:	a1 68 72 5c f0       	mov    0xf05c7268,%eax
f011fcdf:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011fce2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011fce5:	83 c2 15             	add    $0x15,%edx
f011fce8:	39 d0                	cmp    %edx,%eax
f011fcea:	74 17                	je     f011fd03 <test_three_creation_functions+0x167>
f011fcec:	83 ec 04             	sub    $0x4,%esp
f011fcef:	68 88 f7 12 f0       	push   $0xf012f788
f011fcf4:	68 fc 0c 00 00       	push   $0xcfc
f011fcf9:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fcfe:	e8 17 06 fe ff       	call   f010031a <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011fd03:	83 ec 0c             	sub    $0xc,%esp
f011fd06:	68 00 10 00 00       	push   $0x1000
f011fd0b:	e8 7b 8d fe ff       	call   f0108a8b <kmalloc>
f011fd10:	83 c4 10             	add    $0x10,%esp
f011fd13:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011fd16:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011fd19:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011fd1e:	74 17                	je     f011fd37 <test_three_creation_functions+0x19b>
f011fd20:	83 ec 04             	sub    $0x4,%esp
f011fd23:	68 68 fd 12 f0       	push   $0xf012fd68
f011fd28:	68 00 0d 00 00       	push   $0xd00
f011fd2d:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fd32:	e8 e3 05 fe ff       	call   f010031a <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011fd37:	83 ec 0c             	sub    $0xc,%esp
f011fd3a:	68 d8 fd 12 f0       	push   $0xf012fdd8
f011fd3f:	e8 28 12 fe ff       	call   f0100f6c <cprintf>
f011fd44:	83 c4 10             	add    $0x10,%esp

	return 1;
f011fd47:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011fd4c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011fd4f:	5b                   	pop    %ebx
f011fd50:	5e                   	pop    %esi
f011fd51:	5f                   	pop    %edi
f011fd52:	5d                   	pop    %ebp
f011fd53:	c3                   	ret    

f011fd54 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011fd54:	55                   	push   %ebp
f011fd55:	89 e5                	mov    %esp,%ebp
f011fd57:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011fd5a:	83 ec 04             	sub    $0x4,%esp
f011fd5d:	68 89 fe 12 f0       	push   $0xf012fe89
f011fd62:	68 0e 0d 00 00       	push   $0xd0e
f011fd67:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fd6c:	e8 a9 05 fe ff       	call   f010031a <_panic>

f011fd71 <test_kexpand>:

	return 1;

}
int test_kexpand(){
f011fd71:	55                   	push   %ebp
f011fd72:	89 e5                	mov    %esp,%ebp
f011fd74:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011fd77:	83 ec 04             	sub    $0x4,%esp
f011fd7a:	68 89 fe 12 f0       	push   $0xf012fe89
f011fd7f:	68 14 0d 00 00       	push   $0xd14
f011fd84:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fd89:	e8 8c 05 fe ff       	call   f010031a <_panic>

f011fd8e <test_kshrink>:
	return 1;
}

int test_kshrink(){
f011fd8e:	55                   	push   %ebp
f011fd8f:	89 e5                	mov    %esp,%ebp
f011fd91:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011fd94:	83 ec 04             	sub    $0x4,%esp
f011fd97:	68 89 fe 12 f0       	push   $0xf012fe89
f011fd9c:	68 19 0d 00 00       	push   $0xd19
f011fda1:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fda6:	e8 6f 05 fe ff       	call   f010031a <_panic>

f011fdab <test_kfreelast>:
	return 1;
}
int test_kfreelast(){
f011fdab:	55                   	push   %ebp
f011fdac:	89 e5                	mov    %esp,%ebp
f011fdae:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011fdb1:	83 ec 04             	sub    $0x4,%esp
f011fdb4:	68 89 fe 12 f0       	push   $0xf012fe89
f011fdb9:	68 1d 0d 00 00       	push   $0xd1d
f011fdbe:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fdc3:	e8 52 05 fe ff       	call   f010031a <_panic>

f011fdc8 <test_krealloc>:
	return 1;
}

int test_krealloc() {
f011fdc8:	55                   	push   %ebp
f011fdc9:	89 e5                	mov    %esp,%ebp
f011fdcb:	83 ec 08             	sub    $0x8,%esp
	cprintf("==============================================\n");
f011fdce:	83 ec 0c             	sub    $0xc,%esp
f011fdd1:	68 40 ee 12 f0       	push   $0xf012ee40
f011fdd6:	e8 91 11 fe ff       	call   f0100f6c <cprintf>
f011fddb:	83 c4 10             	add    $0x10,%esp
	cprintf(
f011fdde:	83 ec 0c             	sub    $0xc,%esp
f011fde1:	68 70 ee 12 f0       	push   $0xf012ee70
f011fde6:	e8 81 11 fe ff       	call   f0100f6c <cprintf>
f011fdeb:	83 c4 10             	add    $0x10,%esp
			"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
	cprintf("==============================================\n");
f011fdee:	83 ec 0c             	sub    $0xc,%esp
f011fdf1:	68 40 ee 12 f0       	push   $0xf012ee40
f011fdf6:	e8 71 11 fe ff       	call   f0100f6c <cprintf>
f011fdfb:	83 c4 10             	add    $0x10,%esp
	panic("test not available yet");
f011fdfe:	83 ec 04             	sub    $0x4,%esp
f011fe01:	68 89 fe 12 f0       	push   $0xf012fe89
f011fe06:	68 26 0d 00 00       	push   $0xd26
f011fe0b:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fe10:	e8 05 05 fe ff       	call   f010031a <_panic>

f011fe15 <test_krealloc_BF>:
	return 0;
}


int test_krealloc_BF() {
f011fe15:	55                   	push   %ebp
f011fe16:	89 e5                	mov    %esp,%ebp
f011fe18:	83 ec 08             	sub    $0x8,%esp
	cprintf("==============================================\n");
f011fe1b:	83 ec 0c             	sub    $0xc,%esp
f011fe1e:	68 40 ee 12 f0       	push   $0xf012ee40
f011fe23:	e8 44 11 fe ff       	call   f0100f6c <cprintf>
f011fe28:	83 c4 10             	add    $0x10,%esp
	cprintf(
f011fe2b:	83 ec 0c             	sub    $0xc,%esp
f011fe2e:	68 70 ee 12 f0       	push   $0xf012ee70
f011fe33:	e8 34 11 fe ff       	call   f0100f6c <cprintf>
f011fe38:	83 c4 10             	add    $0x10,%esp
			"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
	cprintf("==============================================\n");
f011fe3b:	83 ec 0c             	sub    $0xc,%esp
f011fe3e:	68 40 ee 12 f0       	push   $0xf012ee40
f011fe43:	e8 24 11 fe ff       	call   f0100f6c <cprintf>
f011fe48:	83 c4 10             	add    $0x10,%esp
	panic("test not available yet");
f011fe4b:	83 ec 04             	sub    $0x4,%esp
f011fe4e:	68 89 fe 12 f0       	push   $0xf012fe89
f011fe53:	68 30 0d 00 00       	push   $0xd30
f011fe58:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fe5d:	e8 b8 04 fe ff       	call   f010031a <_panic>

f011fe62 <test_krealloc_FF1>:
	return 0;
}

int test_krealloc_FF1()
{
f011fe62:	55                   	push   %ebp
f011fe63:	89 e5                	mov    %esp,%ebp
f011fe65:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f011fe68:	83 ec 0c             	sub    $0xc,%esp
f011fe6b:	68 a0 fe 12 f0       	push   $0xf012fea0
f011fe70:	e8 f7 10 fe ff       	call   f0100f6c <cprintf>
f011fe75:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [BLOCK ALLOCATOR]******\n") ;
f011fe78:	83 ec 0c             	sub    $0xc,%esp
f011fe7b:	68 d8 fe 12 f0       	push   $0xf012fed8
f011fe80:	e8 e7 10 fe ff       	call   f0100f6c <cprintf>
f011fe85:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f011fe88:	83 ec 0c             	sub    $0xc,%esp
f011fe8b:	68 a0 fe 12 f0       	push   $0xf012fea0
f011fe90:	e8 d7 10 fe ff       	call   f0100f6c <cprintf>
f011fe95:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f011fe98:	83 ec 04             	sub    $0x4,%esp
f011fe9b:	68 89 fe 12 f0       	push   $0xf012fe89
f011fea0:	68 3a 0d 00 00       	push   $0xd3a
f011fea5:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011feaa:	e8 6b 04 fe ff       	call   f010031a <_panic>

f011feaf <test_krealloc_FF2>:
	return 0;

}
int test_krealloc_FF2()
{
f011feaf:	55                   	push   %ebp
f011feb0:	89 e5                	mov    %esp,%ebp
f011feb2:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f011feb5:	83 ec 0c             	sub    $0xc,%esp
f011feb8:	68 a0 fe 12 f0       	push   $0xf012fea0
f011febd:	e8 aa 10 fe ff       	call   f0100f6c <cprintf>
f011fec2:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [PAGE ALLOCATOR]******\n") ;
f011fec5:	83 ec 0c             	sub    $0xc,%esp
f011fec8:	68 24 ff 12 f0       	push   $0xf012ff24
f011fecd:	e8 9a 10 fe ff       	call   f0100f6c <cprintf>
f011fed2:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f011fed5:	83 ec 0c             	sub    $0xc,%esp
f011fed8:	68 a0 fe 12 f0       	push   $0xf012fea0
f011fedd:	e8 8a 10 fe ff       	call   f0100f6c <cprintf>
f011fee2:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f011fee5:	83 ec 04             	sub    $0x4,%esp
f011fee8:	68 89 fe 12 f0       	push   $0xf012fe89
f011feed:	68 44 0d 00 00       	push   $0xd44
f011fef2:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011fef7:	e8 1e 04 fe ff       	call   f010031a <_panic>

f011fefc <test_krealloc_FF3>:
	return 0;
}

int test_krealloc_FF3()
{
f011fefc:	55                   	push   %ebp
f011fefd:	89 e5                	mov    %esp,%ebp
f011feff:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f011ff02:	83 ec 0c             	sub    $0xc,%esp
f011ff05:	68 a0 fe 12 f0       	push   $0xf012fea0
f011ff0a:	e8 5d 10 fe ff       	call   f0100f6c <cprintf>
f011ff0f:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [SWITCH FROM PAGE ALLOCATOR TO DYNAMIC ALLOCATOR AND VICE VERSA]******\n") ;
f011ff12:	83 ec 0c             	sub    $0xc,%esp
f011ff15:	68 6c ff 12 f0       	push   $0xf012ff6c
f011ff1a:	e8 4d 10 fe ff       	call   f0100f6c <cprintf>
f011ff1f:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f011ff22:	83 ec 0c             	sub    $0xc,%esp
f011ff25:	68 a0 fe 12 f0       	push   $0xf012fea0
f011ff2a:	e8 3d 10 fe ff       	call   f0100f6c <cprintf>
f011ff2f:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f011ff32:	83 ec 04             	sub    $0x4,%esp
f011ff35:	68 89 fe 12 f0       	push   $0xf012fe89
f011ff3a:	68 4e 0d 00 00       	push   $0xd4e
f011ff3f:	68 b2 f5 12 f0       	push   $0xf012f5b2
f011ff44:	e8 d1 03 fe ff       	call   f010031a <_panic>

f011ff49 <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011ff49:	55                   	push   %ebp
f011ff4a:	89 e5                	mov    %esp,%ebp
f011ff4c:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011ff4f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ff56:	e9 84 00 00 00       	jmp    f011ffdf <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011ff5b:	83 ec 08             	sub    $0x8,%esp
f011ff5e:	ff 75 f4             	pushl  -0xc(%ebp)
f011ff61:	68 e4 ff 12 f0       	push   $0xf012ffe4
f011ff66:	e8 01 10 fe ff       	call   f0100f6c <cprintf>
f011ff6b:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011ff6e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ff75:	eb 4c                	jmp    f011ffc3 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011ff77:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ff7a:	89 d0                	mov    %edx,%eax
f011ff7c:	c1 e0 02             	shl    $0x2,%eax
f011ff7f:	01 d0                	add    %edx,%eax
f011ff81:	c1 e0 03             	shl    $0x3,%eax
f011ff84:	89 c2                	mov    %eax,%edx
f011ff86:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff89:	01 c2                	add    %eax,%edx
f011ff8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ff8e:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011ff91:	85 c0                	test   %eax,%eax
f011ff93:	74 36                	je     f011ffcb <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011ff95:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ff98:	89 d0                	mov    %edx,%eax
f011ff9a:	c1 e0 02             	shl    $0x2,%eax
f011ff9d:	01 d0                	add    %edx,%eax
f011ff9f:	c1 e0 03             	shl    $0x3,%eax
f011ffa2:	89 c2                	mov    %eax,%edx
f011ffa4:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffa7:	01 c2                	add    %eax,%edx
f011ffa9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ffac:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011ffaf:	83 ec 08             	sub    $0x8,%esp
f011ffb2:	50                   	push   %eax
f011ffb3:	68 ec ff 12 f0       	push   $0xf012ffec
f011ffb8:	e8 af 0f fe ff       	call   f0100f6c <cprintf>
f011ffbd:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011ffc0:	ff 45 f0             	incl   -0x10(%ebp)
f011ffc3:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011ffc7:	7e ae                	jle    f011ff77 <print_order+0x2e>
f011ffc9:	eb 01                	jmp    f011ffcc <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011ffcb:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011ffcc:	83 ec 0c             	sub    $0xc,%esp
f011ffcf:	68 f1 ff 12 f0       	push   $0xf012fff1
f011ffd4:	e8 93 0f fe ff       	call   f0100f6c <cprintf>
f011ffd9:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011ffdc:	ff 45 f4             	incl   -0xc(%ebp)
f011ffdf:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011ffe3:	0f 8e 72 ff ff ff    	jle    f011ff5b <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011ffe9:	90                   	nop
f011ffea:	c9                   	leave  
f011ffeb:	c3                   	ret    

f011ffec <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011ffec:	55                   	push   %ebp
f011ffed:	89 e5                	mov    %esp,%ebp
f011ffef:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011fff2:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011fff9:	83 ec 0c             	sub    $0xc,%esp
f011fffc:	68 00 1e 5a f0       	push   $0xf05a1e00
f0120001:	e8 ef ea fe ff       	call   f010eaf5 <acquire_spinlock>
f0120006:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f0120009:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f0120010:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0120017:	8b 55 0c             	mov    0xc(%ebp),%edx
f012001a:	8b 45 10             	mov    0x10(%ebp),%eax
f012001d:	01 d0                	add    %edx,%eax
f012001f:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0120022:	a1 8c 1e 5a f0       	mov    0xf05a1e8c,%eax
f0120027:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f012002a:	a1 84 1e 5a f0       	mov    0xf05a1e84,%eax
f012002f:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f0120032:	ff 75 e8             	pushl  -0x18(%ebp)
f0120035:	ff 75 0c             	pushl  0xc(%ebp)
f0120038:	ff 75 08             	pushl  0x8(%ebp)
f012003b:	68 f4 ff 12 f0       	push   $0xf012fff4
f0120040:	e8 27 0f fe ff       	call   f0100f6c <cprintf>
f0120045:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0120048:	eb 34                	jmp    f012007e <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f012004a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012004d:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120050:	7d 05                	jge    f0120057 <find_in_range+0x6b>
			{
				i++;
f0120052:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f0120055:	eb 1e                	jmp    f0120075 <find_in_range+0x89>
			}
			if (i >= end)
f0120057:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012005a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f012005d:	7d 29                	jge    f0120088 <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f012005f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120062:	8b 40 10             	mov    0x10(%eax),%eax
f0120065:	3b 45 08             	cmp    0x8(%ebp),%eax
f0120068:	75 08                	jne    f0120072 <find_in_range+0x86>
			{
				ret = i;
f012006a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012006d:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f0120070:	eb 17                	jmp    f0120089 <find_in_range+0x9d>
			}
			i++;
f0120072:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0120075:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120078:	8b 40 0c             	mov    0xc(%eax),%eax
f012007b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f012007e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120081:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0120084:	7c c4                	jl     f012004a <find_in_range+0x5e>
f0120086:	eb 01                	jmp    f0120089 <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f0120088:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f0120089:	83 ec 0c             	sub    $0xc,%esp
f012008c:	68 00 1e 5a f0       	push   $0xf05a1e00
f0120091:	e8 e6 ea fe ff       	call   f010eb7c <release_spinlock>
f0120096:	83 c4 10             	add    $0x10,%esp
	return ret;
f0120099:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f012009c:	c9                   	leave  
f012009d:	c3                   	ret    

f012009e <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f012009e:	55                   	push   %ebp
f012009f:	89 e5                	mov    %esp,%ebp
f01200a1:	57                   	push   %edi
f01200a2:	56                   	push   %esi
f01200a3:	53                   	push   %ebx
f01200a4:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f01200a7:	a0 dd 0d 18 f0       	mov    0xf0180ddd,%al
f01200ac:	84 c0                	test   %al,%al
f01200ae:	0f 84 9b 01 00 00    	je     f012024f <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f01200b4:	c6 05 dd 0d 18 f0 00 	movb   $0x0,0xf0180ddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f01200bb:	8d 45 b8             	lea    -0x48(%ebp),%eax
f01200be:	bb 6c 01 13 f0       	mov    $0xf013016c,%ebx
f01200c3:	ba 05 00 00 00       	mov    $0x5,%edx
f01200c8:	89 c7                	mov    %eax,%edi
f01200ca:	89 de                	mov    %ebx,%esi
f01200cc:	89 d1                	mov    %edx,%ecx
f01200ce:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f01200d0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01200d7:	e9 44 01 00 00       	jmp    f0120220 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f01200dc:	6a 00                	push   $0x0
f01200de:	6a 00                	push   $0x0
f01200e0:	68 f4 01 00 00       	push   $0x1f4
f01200e5:	68 25 00 13 f0       	push   $0xf0130025
f01200ea:	e8 56 99 fe ff       	call   f0109a45 <env_create>
f01200ef:	83 c4 10             	add    $0x10,%esp
f01200f2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f01200f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01200f8:	b9 05 00 00 00       	mov    $0x5,%ecx
f01200fd:	99                   	cltd   
f01200fe:	f7 f9                	idiv   %ecx
f0120100:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f0120103:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120106:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f012010a:	83 ec 08             	sub    $0x8,%esp
f012010d:	50                   	push   %eax
f012010e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0120111:	e8 66 65 fe ff       	call   f010667c <env_set_nice>
f0120116:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f0120119:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f012011d:	75 14                	jne    f0120133 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f012011f:	83 ec 04             	sub    $0x4,%esp
f0120122:	68 2d 00 13 f0       	push   $0xf013002d
f0120127:	6a 53                	push   $0x53
f0120129:	68 46 00 13 f0       	push   $0xf0130046
f012012e:	e8 e7 01 fe ff       	call   f010031a <_panic>
			if (env->page_WS_max_size != 500)
f0120133:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120136:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f012013c:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f0120141:	74 14                	je     f0120157 <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f0120143:	83 ec 04             	sub    $0x4,%esp
f0120146:	68 64 00 13 f0       	push   $0xf0130064
f012014b:	6a 55                	push   $0x55
f012014d:	68 46 00 13 f0       	push   $0xf0130046
f0120152:	e8 c3 01 fe ff       	call   f010031a <_panic>

			switch (nice_values[nice_index])
f0120157:	8b 45 d0             	mov    -0x30(%ebp),%eax
f012015a:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f012015e:	83 c0 0a             	add    $0xa,%eax
f0120161:	83 f8 14             	cmp    $0x14,%eax
f0120164:	0f 87 a5 00 00 00    	ja     f012020f <test_bsd_nice_0+0x171>
f012016a:	8b 04 85 80 01 13 f0 	mov    -0xfecfe80(,%eax,4),%eax
f0120171:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f0120173:	a1 3c 1c 5a f0       	mov    0xf05a1c3c,%eax
f0120178:	8d 50 01             	lea    0x1(%eax),%edx
f012017b:	89 15 3c 1c 5a f0    	mov    %edx,0xf05a1c3c
f0120181:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120184:	8b 52 10             	mov    0x10(%edx),%edx
f0120187:	89 14 85 80 72 5c f0 	mov    %edx,-0xfa38d80(,%eax,4)
				break;
f012018e:	eb 7f                	jmp    f012020f <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f0120190:	a1 40 1c 5a f0       	mov    0xf05a1c40,%eax
f0120195:	8d 50 01             	lea    0x1(%eax),%edx
f0120198:	89 15 40 1c 5a f0    	mov    %edx,0xf05a1c40
f012019e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01201a1:	8b 52 10             	mov    0x10(%edx),%edx
f01201a4:	83 c0 0a             	add    $0xa,%eax
f01201a7:	89 14 85 80 72 5c f0 	mov    %edx,-0xfa38d80(,%eax,4)
				break;
f01201ae:	eb 5f                	jmp    f012020f <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f01201b0:	a1 44 1c 5a f0       	mov    0xf05a1c44,%eax
f01201b5:	8d 50 01             	lea    0x1(%eax),%edx
f01201b8:	89 15 44 1c 5a f0    	mov    %edx,0xf05a1c44
f01201be:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01201c1:	8b 52 10             	mov    0x10(%edx),%edx
f01201c4:	83 c0 14             	add    $0x14,%eax
f01201c7:	89 14 85 80 72 5c f0 	mov    %edx,-0xfa38d80(,%eax,4)
				break;
f01201ce:	eb 3f                	jmp    f012020f <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f01201d0:	a1 48 1c 5a f0       	mov    0xf05a1c48,%eax
f01201d5:	8d 50 01             	lea    0x1(%eax),%edx
f01201d8:	89 15 48 1c 5a f0    	mov    %edx,0xf05a1c48
f01201de:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01201e1:	8b 52 10             	mov    0x10(%edx),%edx
f01201e4:	83 c0 1e             	add    $0x1e,%eax
f01201e7:	89 14 85 80 72 5c f0 	mov    %edx,-0xfa38d80(,%eax,4)
				break;
f01201ee:	eb 1f                	jmp    f012020f <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f01201f0:	a1 4c 1c 5a f0       	mov    0xf05a1c4c,%eax
f01201f5:	8d 50 01             	lea    0x1(%eax),%edx
f01201f8:	89 15 4c 1c 5a f0    	mov    %edx,0xf05a1c4c
f01201fe:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120201:	8b 52 10             	mov    0x10(%edx),%edx
f0120204:	83 c0 28             	add    $0x28,%eax
f0120207:	89 14 85 80 72 5c f0 	mov    %edx,-0xfa38d80(,%eax,4)
				break;
f012020e:	90                   	nop
			}
			sched_new_env(env);
f012020f:	83 ec 0c             	sub    $0xc,%esp
f0120212:	ff 75 d4             	pushl  -0x2c(%ebp)
f0120215:	e8 60 54 fe ff       	call   f010567a <sched_new_env>
f012021a:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f012021d:	ff 45 e4             	incl   -0x1c(%ebp)
f0120220:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f0120224:	0f 8e b2 fe ff ff    	jle    f01200dc <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f012022a:	83 ec 0c             	sub    $0xc,%esp
f012022d:	68 94 00 13 f0       	push   $0xf0130094
f0120232:	e8 35 0d fe ff       	call   f0100f6c <cprintf>
f0120237:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f012023a:	83 ec 0c             	sub    $0xc,%esp
f012023d:	68 e3 00 13 f0       	push   $0xf01300e3
f0120242:	e8 95 1c fe ff       	call   f0101edc <execute_command>
f0120247:	83 c4 10             	add    $0x10,%esp
f012024a:	e9 c0 00 00 00       	jmp    f012030f <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f012024f:	83 ec 0c             	sub    $0xc,%esp
f0120252:	68 ea 00 13 f0       	push   $0xf01300ea
f0120257:	e8 10 0d fe ff       	call   f0100f6c <cprintf>
f012025c:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f012025f:	e8 92 5b fe ff       	call   f0105df6 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f0120264:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f012026b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0120272:	e9 87 00 00 00       	jmp    f01202fe <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f0120277:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f012027e:	eb 52                	jmp    f01202d2 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f0120280:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120283:	8b 14 85 3c 1c 5a f0 	mov    -0xfa5e3c4(,%eax,4),%edx
f012028a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f012028d:	89 c8                	mov    %ecx,%eax
f012028f:	c1 e0 02             	shl    $0x2,%eax
f0120292:	01 c8                	add    %ecx,%eax
f0120294:	01 c0                	add    %eax,%eax
f0120296:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0120299:	01 c8                	add    %ecx,%eax
f012029b:	8b 04 85 80 72 5c f0 	mov    -0xfa38d80(,%eax,4),%eax
f01202a2:	83 ec 04             	sub    $0x4,%esp
f01202a5:	52                   	push   %edx
f01202a6:	ff 75 e0             	pushl  -0x20(%ebp)
f01202a9:	50                   	push   %eax
f01202aa:	e8 3d fd ff ff       	call   f011ffec <find_in_range>
f01202af:	83 c4 10             	add    $0x10,%esp
f01202b2:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f01202b5:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f01202b9:	75 14                	jne    f01202cf <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f01202bb:	83 ec 04             	sub    $0x4,%esp
f01202be:	68 fc 00 13 f0       	push   $0xf01300fc
f01202c3:	6a 7b                	push   $0x7b
f01202c5:	68 46 00 13 f0       	push   $0xf0130046
f01202ca:	e8 4b 00 fe ff       	call   f010031a <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f01202cf:	ff 45 d8             	incl   -0x28(%ebp)
f01202d2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01202d5:	89 d0                	mov    %edx,%eax
f01202d7:	c1 e0 02             	shl    $0x2,%eax
f01202da:	01 d0                	add    %edx,%eax
f01202dc:	01 c0                	add    %eax,%eax
f01202de:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01202e1:	01 d0                	add    %edx,%eax
f01202e3:	8b 04 85 80 72 5c f0 	mov    -0xfa38d80(,%eax,4),%eax
f01202ea:	85 c0                	test   %eax,%eax
f01202ec:	75 92                	jne    f0120280 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f01202ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01202f1:	8b 04 85 3c 1c 5a f0 	mov    -0xfa5e3c4(,%eax,4),%eax
f01202f8:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f01202fb:	ff 45 dc             	incl   -0x24(%ebp)
f01202fe:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f0120302:	0f 8e 6f ff ff ff    	jle    f0120277 <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f0120308:	c6 05 dd 0d 18 f0 00 	movb   $0x0,0xf0180ddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f012030f:	83 ec 0c             	sub    $0xc,%esp
f0120312:	68 30 01 13 f0       	push   $0xf0130130
f0120317:	e8 50 0c fe ff       	call   f0100f6c <cprintf>
f012031c:	83 c4 10             	add    $0x10,%esp
}
f012031f:	90                   	nop
f0120320:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0120323:	5b                   	pop    %ebx
f0120324:	5e                   	pop    %esi
f0120325:	5f                   	pop    %edi
f0120326:	5d                   	pop    %ebp
f0120327:	c3                   	ret    

f0120328 <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f0120328:	55                   	push   %ebp
f0120329:	89 e5                	mov    %esp,%ebp
f012032b:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f012032e:	a0 dd 0d 18 f0       	mov    0xf0180ddd,%al
f0120333:	84 c0                	test   %al,%al
f0120335:	0f 84 50 01 00 00    	je     f012048b <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f012033b:	c6 05 dd 0d 18 f0 00 	movb   $0x0,0xf0180ddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f0120342:	6a 00                	push   $0x0
f0120344:	6a 00                	push   $0x0
f0120346:	68 f4 01 00 00       	push   $0x1f4
f012034b:	68 25 00 13 f0       	push   $0xf0130025
f0120350:	e8 f0 96 fe ff       	call   f0109a45 <env_create>
f0120355:	83 c4 10             	add    $0x10,%esp
f0120358:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f012035b:	6a 00                	push   $0x0
f012035d:	6a 00                	push   $0x0
f012035f:	68 f4 01 00 00       	push   $0x1f4
f0120364:	68 d4 01 13 f0       	push   $0xf01301d4
f0120369:	e8 d7 96 fe ff       	call   f0109a45 <env_create>
f012036e:	83 c4 10             	add    $0x10,%esp
f0120371:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f0120374:	6a 00                	push   $0x0
f0120376:	6a 00                	push   $0x0
f0120378:	68 f4 01 00 00       	push   $0x1f4
f012037d:	68 e1 01 13 f0       	push   $0xf01301e1
f0120382:	e8 be 96 fe ff       	call   f0109a45 <env_create>
f0120387:	83 c4 10             	add    $0x10,%esp
f012038a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f012038d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0120391:	74 0c                	je     f012039f <test_bsd_nice_1+0x77>
f0120393:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0120397:	74 06                	je     f012039f <test_bsd_nice_1+0x77>
f0120399:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012039d:	75 17                	jne    f01203b6 <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f012039f:	83 ec 04             	sub    $0x4,%esp
f01203a2:	68 2d 00 13 f0       	push   $0xf013002d
f01203a7:	68 8e 00 00 00       	push   $0x8e
f01203ac:	68 46 00 13 f0       	push   $0xf0130046
f01203b1:	e8 64 ff fd ff       	call   f010031a <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f01203b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01203b9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01203bf:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01203c4:	75 20                	jne    f01203e6 <test_bsd_nice_1+0xbe>
f01203c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01203c9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01203cf:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01203d4:	75 10                	jne    f01203e6 <test_bsd_nice_1+0xbe>
f01203d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01203d9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01203df:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01203e4:	74 35                	je     f012041b <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f01203e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01203e9:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f01203ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01203f2:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f01203f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01203fb:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0120401:	83 ec 08             	sub    $0x8,%esp
f0120404:	51                   	push   %ecx
f0120405:	52                   	push   %edx
f0120406:	50                   	push   %eax
f0120407:	68 f0 01 13 f0       	push   $0xf01301f0
f012040c:	68 90 00 00 00       	push   $0x90
f0120411:	68 46 00 13 f0       	push   $0xf0130046
f0120416:	e8 ff fe fd ff       	call   f010031a <_panic>
		sched_new_env(fibEnv);
f012041b:	83 ec 0c             	sub    $0xc,%esp
f012041e:	ff 75 ec             	pushl  -0x14(%ebp)
f0120421:	e8 54 52 fe ff       	call   f010567a <sched_new_env>
f0120426:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f0120429:	83 ec 0c             	sub    $0xc,%esp
f012042c:	ff 75 e8             	pushl  -0x18(%ebp)
f012042f:	e8 46 52 fe ff       	call   f010567a <sched_new_env>
f0120434:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f0120437:	83 ec 0c             	sub    $0xc,%esp
f012043a:	ff 75 e4             	pushl  -0x1c(%ebp)
f012043d:	e8 38 52 fe ff       	call   f010567a <sched_new_env>
f0120442:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f0120445:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120448:	8b 40 10             	mov    0x10(%eax),%eax
f012044b:	a3 80 72 5c f0       	mov    %eax,0xf05c7280
		prog_orders[1][0] = fibEnv->env_id;
f0120450:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120453:	8b 40 10             	mov    0x10(%eax),%eax
f0120456:	a3 a8 72 5c f0       	mov    %eax,0xf05c72a8
		prog_orders[2][0] = fibposnEnv->env_id;
f012045b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012045e:	8b 40 10             	mov    0x10(%eax),%eax
f0120461:	a3 d0 72 5c f0       	mov    %eax,0xf05c72d0
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f0120466:	83 ec 0c             	sub    $0xc,%esp
f0120469:	68 94 00 13 f0       	push   $0xf0130094
f012046e:	e8 f9 0a fe ff       	call   f0100f6c <cprintf>
f0120473:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f0120476:	83 ec 0c             	sub    $0xc,%esp
f0120479:	68 e3 00 13 f0       	push   $0xf01300e3
f012047e:	e8 59 1a fe ff       	call   f0101edc <execute_command>
f0120483:	83 c4 10             	add    $0x10,%esp
f0120486:	e9 9e 00 00 00       	jmp    f0120529 <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f012048b:	83 ec 0c             	sub    $0xc,%esp
f012048e:	68 ea 00 13 f0       	push   $0xf01300ea
f0120493:	e8 d4 0a fe ff       	call   f0100f6c <cprintf>
f0120498:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f012049b:	e8 56 59 fe ff       	call   f0105df6 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f01204a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f01204a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f01204ae:	83 ec 0c             	sub    $0xc,%esp
f01204b1:	68 00 1e 5a f0       	push   $0xf05a1e00
f01204b6:	e8 3a e6 fe ff       	call   f010eaf5 <acquire_spinlock>
f01204bb:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f01204be:	a1 8c 1e 5a f0       	mov    0xf05a1e8c,%eax
f01204c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f01204c6:	a1 84 1e 5a f0       	mov    0xf05a1e84,%eax
f01204cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f01204ce:	eb 41                	jmp    f0120511 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f01204d0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01204d3:	89 d0                	mov    %edx,%eax
f01204d5:	c1 e0 02             	shl    $0x2,%eax
f01204d8:	01 d0                	add    %edx,%eax
f01204da:	c1 e0 03             	shl    $0x3,%eax
f01204dd:	05 80 72 5c f0       	add    $0xf05c7280,%eax
f01204e2:	8b 10                	mov    (%eax),%edx
f01204e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01204e7:	8b 40 10             	mov    0x10(%eax),%eax
f01204ea:	39 c2                	cmp    %eax,%edx
f01204ec:	74 17                	je     f0120505 <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f01204ee:	83 ec 04             	sub    $0x4,%esp
f01204f1:	68 fc 00 13 f0       	push   $0xf01300fc
f01204f6:	68 ab 00 00 00       	push   $0xab
f01204fb:	68 46 00 13 f0       	push   $0xf0130046
f0120500:	e8 15 fe fd ff       	call   f010031a <_panic>
				i++;
f0120505:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0120508:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012050b:	8b 40 0c             	mov    0xc(%eax),%eax
f012050e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0120511:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120514:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0120517:	7c b7                	jl     f01204d0 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f0120519:	83 ec 0c             	sub    $0xc,%esp
f012051c:	68 00 1e 5a f0       	push   $0xf05a1e00
f0120521:	e8 56 e6 fe ff       	call   f010eb7c <release_spinlock>
f0120526:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f0120529:	83 ec 0c             	sub    $0xc,%esp
f012052c:	68 5c 02 13 f0       	push   $0xf013025c
f0120531:	e8 36 0a fe ff       	call   f0100f6c <cprintf>
f0120536:	83 c4 10             	add    $0x10,%esp
}
f0120539:	90                   	nop
f012053a:	c9                   	leave  
f012053b:	c3                   	ret    

f012053c <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f012053c:	55                   	push   %ebp
f012053d:	89 e5                	mov    %esp,%ebp
f012053f:	57                   	push   %edi
f0120540:	56                   	push   %esi
f0120541:	53                   	push   %ebx
f0120542:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f0120545:	a0 dd 0d 18 f0       	mov    0xf0180ddd,%al
f012054a:	84 c0                	test   %al,%al
f012054c:	0f 84 ae 01 00 00    	je     f0120700 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f0120552:	83 ec 0c             	sub    $0xc,%esp
f0120555:	6a 01                	push   $0x1
f0120557:	e8 0d 10 00 00       	call   f0121569 <chksch>
f012055c:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f012055f:	c6 05 dd 0d 18 f0 00 	movb   $0x0,0xf0180ddd
		int nice_values[] = {15, 5, 0, -5, -15};
f0120566:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0120569:	bb e0 02 13 f0       	mov    $0xf01302e0,%ebx
f012056e:	ba 05 00 00 00       	mov    $0x5,%edx
f0120573:	89 c7                	mov    %eax,%edi
f0120575:	89 de                	mov    %ebx,%esi
f0120577:	89 d1                	mov    %edx,%ecx
f0120579:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f012057b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0120582:	e9 4a 01 00 00       	jmp    f01206d1 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f0120587:	6a 00                	push   $0x0
f0120589:	6a 00                	push   $0x0
f012058b:	68 10 27 00 00       	push   $0x2710
f0120590:	68 98 02 13 f0       	push   $0xf0130298
f0120595:	e8 ab 94 fe ff       	call   f0109a45 <env_create>
f012059a:	83 c4 10             	add    $0x10,%esp
f012059d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f01205a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01205a3:	b9 05 00 00 00       	mov    $0x5,%ecx
f01205a8:	99                   	cltd   
f01205a9:	f7 f9                	idiv   %ecx
f01205ab:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f01205ae:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01205b1:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f01205b5:	83 ec 08             	sub    $0x8,%esp
f01205b8:	50                   	push   %eax
f01205b9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01205bc:	e8 bb 60 fe ff       	call   f010667c <env_set_nice>
f01205c1:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f01205c4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01205c8:	75 17                	jne    f01205e1 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f01205ca:	83 ec 04             	sub    $0x4,%esp
f01205cd:	68 2d 00 13 f0       	push   $0xf013002d
f01205d2:	68 c1 00 00 00       	push   $0xc1
f01205d7:	68 46 00 13 f0       	push   $0xf0130046
f01205dc:	e8 39 fd fd ff       	call   f010031a <_panic>
			if (env->page_WS_max_size != 10000)
f01205e1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01205e4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01205ea:	3d 10 27 00 00       	cmp    $0x2710,%eax
f01205ef:	74 17                	je     f0120608 <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f01205f1:	83 ec 04             	sub    $0x4,%esp
f01205f4:	68 64 00 13 f0       	push   $0xf0130064
f01205f9:	68 c3 00 00 00       	push   $0xc3
f01205fe:	68 46 00 13 f0       	push   $0xf0130046
f0120603:	e8 12 fd fd ff       	call   f010031a <_panic>

			switch (nice_values[nice_index])
f0120608:	8b 45 d0             	mov    -0x30(%ebp),%eax
f012060b:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f012060f:	83 c0 0f             	add    $0xf,%eax
f0120612:	83 f8 1e             	cmp    $0x1e,%eax
f0120615:	0f 87 a5 00 00 00    	ja     f01206c0 <test_bsd_nice_2+0x184>
f012061b:	8b 04 85 f4 02 13 f0 	mov    -0xfecfd0c(,%eax,4),%eax
f0120622:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f0120624:	a1 3c 1c 5a f0       	mov    0xf05a1c3c,%eax
f0120629:	8d 50 01             	lea    0x1(%eax),%edx
f012062c:	89 15 3c 1c 5a f0    	mov    %edx,0xf05a1c3c
f0120632:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120635:	8b 52 10             	mov    0x10(%edx),%edx
f0120638:	89 14 85 80 72 5c f0 	mov    %edx,-0xfa38d80(,%eax,4)
				break;
f012063f:	eb 7f                	jmp    f01206c0 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f0120641:	a1 40 1c 5a f0       	mov    0xf05a1c40,%eax
f0120646:	8d 50 01             	lea    0x1(%eax),%edx
f0120649:	89 15 40 1c 5a f0    	mov    %edx,0xf05a1c40
f012064f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120652:	8b 52 10             	mov    0x10(%edx),%edx
f0120655:	83 c0 0a             	add    $0xa,%eax
f0120658:	89 14 85 80 72 5c f0 	mov    %edx,-0xfa38d80(,%eax,4)
				break;
f012065f:	eb 5f                	jmp    f01206c0 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f0120661:	a1 44 1c 5a f0       	mov    0xf05a1c44,%eax
f0120666:	8d 50 01             	lea    0x1(%eax),%edx
f0120669:	89 15 44 1c 5a f0    	mov    %edx,0xf05a1c44
f012066f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120672:	8b 52 10             	mov    0x10(%edx),%edx
f0120675:	83 c0 14             	add    $0x14,%eax
f0120678:	89 14 85 80 72 5c f0 	mov    %edx,-0xfa38d80(,%eax,4)
				break;
f012067f:	eb 3f                	jmp    f01206c0 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f0120681:	a1 48 1c 5a f0       	mov    0xf05a1c48,%eax
f0120686:	8d 50 01             	lea    0x1(%eax),%edx
f0120689:	89 15 48 1c 5a f0    	mov    %edx,0xf05a1c48
f012068f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120692:	8b 52 10             	mov    0x10(%edx),%edx
f0120695:	83 c0 1e             	add    $0x1e,%eax
f0120698:	89 14 85 80 72 5c f0 	mov    %edx,-0xfa38d80(,%eax,4)
				break;
f012069f:	eb 1f                	jmp    f01206c0 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f01206a1:	a1 4c 1c 5a f0       	mov    0xf05a1c4c,%eax
f01206a6:	8d 50 01             	lea    0x1(%eax),%edx
f01206a9:	89 15 4c 1c 5a f0    	mov    %edx,0xf05a1c4c
f01206af:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01206b2:	8b 52 10             	mov    0x10(%edx),%edx
f01206b5:	83 c0 28             	add    $0x28,%eax
f01206b8:	89 14 85 80 72 5c f0 	mov    %edx,-0xfa38d80(,%eax,4)
				break;
f01206bf:	90                   	nop
			}
			sched_new_env(env);
f01206c0:	83 ec 0c             	sub    $0xc,%esp
f01206c3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01206c6:	e8 af 4f fe ff       	call   f010567a <sched_new_env>
f01206cb:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f01206ce:	ff 45 e4             	incl   -0x1c(%ebp)
f01206d1:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f01206d5:	0f 8e ac fe ff ff    	jle    f0120587 <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f01206db:	83 ec 0c             	sub    $0xc,%esp
f01206de:	68 94 00 13 f0       	push   $0xf0130094
f01206e3:	e8 84 08 fe ff       	call   f0100f6c <cprintf>
f01206e8:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f01206eb:	83 ec 0c             	sub    $0xc,%esp
f01206ee:	68 e3 00 13 f0       	push   $0xf01300e3
f01206f3:	e8 e4 17 fe ff       	call   f0101edc <execute_command>
f01206f8:	83 c4 10             	add    $0x10,%esp
f01206fb:	e9 d0 00 00 00       	jmp    f01207d0 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f0120700:	83 ec 0c             	sub    $0xc,%esp
f0120703:	6a 00                	push   $0x0
f0120705:	e8 5f 0e 00 00       	call   f0121569 <chksch>
f012070a:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f012070d:	83 ec 0c             	sub    $0xc,%esp
f0120710:	68 ea 00 13 f0       	push   $0xf01300ea
f0120715:	e8 52 08 fe ff       	call   f0100f6c <cprintf>
f012071a:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f012071d:	e8 d4 56 fe ff       	call   f0105df6 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f0120722:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f0120729:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0120730:	e9 8a 00 00 00       	jmp    f01207bf <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f0120735:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f012073c:	eb 55                	jmp    f0120793 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f012073e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120741:	8b 14 85 3c 1c 5a f0 	mov    -0xfa5e3c4(,%eax,4),%edx
f0120748:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f012074b:	89 c8                	mov    %ecx,%eax
f012074d:	c1 e0 02             	shl    $0x2,%eax
f0120750:	01 c8                	add    %ecx,%eax
f0120752:	01 c0                	add    %eax,%eax
f0120754:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0120757:	01 c8                	add    %ecx,%eax
f0120759:	8b 04 85 80 72 5c f0 	mov    -0xfa38d80(,%eax,4),%eax
f0120760:	83 ec 04             	sub    $0x4,%esp
f0120763:	52                   	push   %edx
f0120764:	ff 75 e0             	pushl  -0x20(%ebp)
f0120767:	50                   	push   %eax
f0120768:	e8 7f f8 ff ff       	call   f011ffec <find_in_range>
f012076d:	83 c4 10             	add    $0x10,%esp
f0120770:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f0120773:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f0120777:	75 17                	jne    f0120790 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f0120779:	83 ec 04             	sub    $0x4,%esp
f012077c:	68 fc 00 13 f0       	push   $0xf01300fc
f0120781:	68 ea 00 00 00       	push   $0xea
f0120786:	68 46 00 13 f0       	push   $0xf0130046
f012078b:	e8 8a fb fd ff       	call   f010031a <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f0120790:	ff 45 d8             	incl   -0x28(%ebp)
f0120793:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120796:	89 d0                	mov    %edx,%eax
f0120798:	c1 e0 02             	shl    $0x2,%eax
f012079b:	01 d0                	add    %edx,%eax
f012079d:	01 c0                	add    %eax,%eax
f012079f:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01207a2:	01 d0                	add    %edx,%eax
f01207a4:	8b 04 85 80 72 5c f0 	mov    -0xfa38d80(,%eax,4),%eax
f01207ab:	85 c0                	test   %eax,%eax
f01207ad:	75 8f                	jne    f012073e <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f01207af:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01207b2:	8b 04 85 3c 1c 5a f0 	mov    -0xfa5e3c4(,%eax,4),%eax
f01207b9:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f01207bc:	ff 45 dc             	incl   -0x24(%ebp)
f01207bf:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f01207c3:	0f 8e 6c ff ff ff    	jle    f0120735 <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f01207c9:	c6 05 dd 0d 18 f0 00 	movb   $0x0,0xf0180ddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f01207d0:	83 ec 0c             	sub    $0xc,%esp
f01207d3:	68 a4 02 13 f0       	push   $0xf01302a4
f01207d8:	e8 8f 07 fe ff       	call   f0100f6c <cprintf>
f01207dd:	83 c4 10             	add    $0x10,%esp
}
f01207e0:	90                   	nop
f01207e1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01207e4:	5b                   	pop    %ebx
f01207e5:	5e                   	pop    %esi
f01207e6:	5f                   	pop    %edi
f01207e7:	5d                   	pop    %ebp
f01207e8:	c3                   	ret    

f01207e9 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f01207e9:	55                   	push   %ebp
f01207ea:	89 e5                	mov    %esp,%ebp
f01207ec:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f01207ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f01207f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f01207f5:	8b 45 08             	mov    0x8(%ebp),%eax
f01207f8:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01207fb:	89 10                	mov    %edx,(%eax)
}
f01207fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0120800:	c9                   	leave  
f0120801:	c2 04 00             	ret    $0x4

f0120804 <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f0120804:	55                   	push   %ebp
f0120805:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f0120807:	8b 45 08             	mov    0x8(%ebp),%eax
f012080a:	85 c0                	test   %eax,%eax
f012080c:	78 16                	js     f0120824 <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f012080e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120811:	05 00 20 00 00       	add    $0x2000,%eax
f0120816:	85 c0                	test   %eax,%eax
f0120818:	79 05                	jns    f012081f <fix_round+0x1b>
f012081a:	05 ff 3f 00 00       	add    $0x3fff,%eax
f012081f:	c1 f8 0e             	sar    $0xe,%eax
f0120822:	eb 14                	jmp    f0120838 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f0120824:	8b 45 08             	mov    0x8(%ebp),%eax
f0120827:	2d 00 20 00 00       	sub    $0x2000,%eax
f012082c:	85 c0                	test   %eax,%eax
f012082e:	79 05                	jns    f0120835 <fix_round+0x31>
f0120830:	05 ff 3f 00 00       	add    $0x3fff,%eax
f0120835:	c1 f8 0e             	sar    $0xe,%eax
}
f0120838:	5d                   	pop    %ebp
f0120839:	c3                   	ret    

f012083a <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f012083a:	55                   	push   %ebp
f012083b:	89 e5                	mov    %esp,%ebp
f012083d:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f0120840:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120844:	79 16                	jns    f012085c <fix_scale+0x22>
f0120846:	68 70 03 13 f0       	push   $0xf0130370
f012084b:	68 77 03 13 f0       	push   $0xf0130377
f0120850:	6a 5a                	push   $0x5a
f0120852:	68 8c 03 13 f0       	push   $0xf013038c
f0120857:	e8 be fa fd ff       	call   f010031a <_panic>
  return __mk_fix (x.f * n);
f012085c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012085f:	0f af 45 10          	imul   0x10(%ebp),%eax
f0120863:	89 c2                	mov    %eax,%edx
f0120865:	8b 45 08             	mov    0x8(%ebp),%eax
f0120868:	83 ec 08             	sub    $0x8,%esp
f012086b:	52                   	push   %edx
f012086c:	50                   	push   %eax
f012086d:	e8 77 ff ff ff       	call   f01207e9 <__mk_fix>
f0120872:	83 c4 0c             	add    $0xc,%esp
}
f0120875:	8b 45 08             	mov    0x8(%ebp),%eax
f0120878:	c9                   	leave  
f0120879:	c2 04 00             	ret    $0x4

f012087c <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f012087c:	55                   	push   %ebp
f012087d:	89 e5                	mov    %esp,%ebp
f012087f:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f0120882:	83 ec 08             	sub    $0x8,%esp
f0120885:	68 a0 03 13 f0       	push   $0xf01303a0
f012088a:	68 a0 4b 5a f0       	push   $0xf05a4ba0
f012088f:	e8 30 e2 fe ff       	call   f010eac4 <init_spinlock>
f0120894:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f0120897:	83 ec 0c             	sub    $0xc,%esp
f012089a:	68 a0 4b 5a f0       	push   $0xf05a4ba0
f012089f:	e8 51 e2 fe ff       	call   f010eaf5 <acquire_spinlock>
f01208a4:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f01208a7:	c7 05 88 1d 5a f0 00 	movl   $0x0,0xf05a1d88
f01208ae:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f01208b1:	83 ec 0c             	sub    $0xc,%esp
f01208b4:	68 a0 4b 5a f0       	push   $0xf05a4ba0
f01208b9:	e8 be e2 fe ff       	call   f010eb7c <release_spinlock>
f01208be:	83 c4 10             	add    $0x10,%esp
}
f01208c1:	90                   	nop
f01208c2:	c9                   	leave  
f01208c3:	c3                   	ret    

f01208c4 <inctst>:
void inctst()
{
f01208c4:	55                   	push   %ebp
f01208c5:	89 e5                	mov    %esp,%ebp
f01208c7:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f01208ca:	83 ec 0c             	sub    $0xc,%esp
f01208cd:	68 a0 4b 5a f0       	push   $0xf05a4ba0
f01208d2:	e8 1e e2 fe ff       	call   f010eaf5 <acquire_spinlock>
f01208d7:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f01208da:	a1 88 1d 5a f0       	mov    0xf05a1d88,%eax
f01208df:	40                   	inc    %eax
f01208e0:	a3 88 1d 5a f0       	mov    %eax,0xf05a1d88
	}
	release_spinlock(&tstcntlock);
f01208e5:	83 ec 0c             	sub    $0xc,%esp
f01208e8:	68 a0 4b 5a f0       	push   $0xf05a4ba0
f01208ed:	e8 8a e2 fe ff       	call   f010eb7c <release_spinlock>
f01208f2:	83 c4 10             	add    $0x10,%esp
}
f01208f5:	90                   	nop
f01208f6:	c9                   	leave  
f01208f7:	c3                   	ret    

f01208f8 <gettst>:
uint32 gettst()
{
f01208f8:	55                   	push   %ebp
f01208f9:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f01208fb:	a1 88 1d 5a f0       	mov    0xf05a1d88,%eax
}
f0120900:	5d                   	pop    %ebp
f0120901:	c3                   	ret    

f0120902 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f0120902:	55                   	push   %ebp
f0120903:	89 e5                	mov    %esp,%ebp
f0120905:	83 ec 28             	sub    $0x28,%esp
f0120908:	8b 45 14             	mov    0x14(%ebp),%eax
f012090b:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f012090e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f0120915:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f0120919:	83 f8 65             	cmp    $0x65,%eax
f012091c:	74 5d                	je     f012097b <tst+0x79>
f012091e:	83 f8 65             	cmp    $0x65,%eax
f0120921:	7f 0a                	jg     f012092d <tst+0x2b>
f0120923:	83 f8 62             	cmp    $0x62,%eax
f0120926:	74 73                	je     f012099b <tst+0x99>
f0120928:	e9 91 00 00 00       	jmp    f01209be <tst+0xbc>
f012092d:	83 f8 67             	cmp    $0x67,%eax
f0120930:	74 29                	je     f012095b <tst+0x59>
f0120932:	83 f8 6c             	cmp    $0x6c,%eax
f0120935:	0f 85 83 00 00 00    	jne    f01209be <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f012093b:	8b 45 08             	mov    0x8(%ebp),%eax
f012093e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120941:	73 09                	jae    f012094c <tst+0x4a>
			chk = 1;
f0120943:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f012094a:	eb 68                	jmp    f01209b4 <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f012094c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0120950:	74 62                	je     f01209b4 <tst+0xb2>
			chk = 1;
f0120952:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0120959:	eb 59                	jmp    f01209b4 <tst+0xb2>
	case 'g':
		if (n > v1)
f012095b:	8b 45 08             	mov    0x8(%ebp),%eax
f012095e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120961:	76 09                	jbe    f012096c <tst+0x6a>
			chk = 1;
f0120963:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f012096a:	eb 4b                	jmp    f01209b7 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f012096c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0120970:	74 45                	je     f01209b7 <tst+0xb5>
			chk = 1;
f0120972:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0120979:	eb 3c                	jmp    f01209b7 <tst+0xb5>
	case 'e':
		if (n == v1)
f012097b:	8b 45 08             	mov    0x8(%ebp),%eax
f012097e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120981:	75 09                	jne    f012098c <tst+0x8a>
			chk = 1;
f0120983:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f012098a:	eb 2e                	jmp    f01209ba <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f012098c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0120990:	74 28                	je     f01209ba <tst+0xb8>
			chk = 1;
f0120992:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0120999:	eb 1f                	jmp    f01209ba <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f012099b:	8b 45 08             	mov    0x8(%ebp),%eax
f012099e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01209a1:	72 1a                	jb     f01209bd <tst+0xbb>
f01209a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01209a6:	3b 45 10             	cmp    0x10(%ebp),%eax
f01209a9:	77 12                	ja     f01209bd <tst+0xbb>
			chk = 1;
f01209ab:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f01209b2:	eb 09                	jmp    f01209bd <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f01209b4:	90                   	nop
f01209b5:	eb 07                	jmp    f01209be <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f01209b7:	90                   	nop
f01209b8:	eb 04                	jmp    f01209be <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f01209ba:	90                   	nop
f01209bb:	eb 01                	jmp    f01209be <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f01209bd:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f01209be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01209c2:	75 14                	jne    f01209d8 <tst+0xd6>
f01209c4:	83 ec 04             	sub    $0x4,%esp
f01209c7:	68 ac 03 13 f0       	push   $0xf01303ac
f01209cc:	6a 48                	push   $0x48
f01209ce:	68 bf 03 13 f0       	push   $0xf01303bf
f01209d3:	e8 42 f9 fd ff       	call   f010031a <_panic>

	acquire_spinlock(&tstcntlock);
f01209d8:	83 ec 0c             	sub    $0xc,%esp
f01209db:	68 a0 4b 5a f0       	push   $0xf05a4ba0
f01209e0:	e8 10 e1 fe ff       	call   f010eaf5 <acquire_spinlock>
f01209e5:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f01209e8:	a1 88 1d 5a f0       	mov    0xf05a1d88,%eax
f01209ed:	40                   	inc    %eax
f01209ee:	a3 88 1d 5a f0       	mov    %eax,0xf05a1d88
	}
	release_spinlock(&tstcntlock);
f01209f3:	83 ec 0c             	sub    $0xc,%esp
f01209f6:	68 a0 4b 5a f0       	push   $0xf05a4ba0
f01209fb:	e8 7c e1 fe ff       	call   f010eb7c <release_spinlock>
f0120a00:	83 c4 10             	add    $0x10,%esp

	return;
f0120a03:	90                   	nop
}
f0120a04:	c9                   	leave  
f0120a05:	c3                   	ret    

f0120a06 <chktst>:

void chktst(uint32 n)
{
f0120a06:	55                   	push   %ebp
f0120a07:	89 e5                	mov    %esp,%ebp
f0120a09:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f0120a0c:	83 ec 0c             	sub    $0xc,%esp
f0120a0f:	68 a0 4b 5a f0       	push   $0xf05a4ba0
f0120a14:	e8 dc e0 fe ff       	call   f010eaf5 <acquire_spinlock>
f0120a19:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f0120a1c:	a1 88 1d 5a f0       	mov    0xf05a1d88,%eax
f0120a21:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f0120a24:	83 ec 0c             	sub    $0xc,%esp
f0120a27:	68 a0 4b 5a f0       	push   $0xf05a4ba0
f0120a2c:	e8 4b e1 fe ff       	call   f010eb7c <release_spinlock>
f0120a31:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f0120a34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a37:	3b 45 08             	cmp    0x8(%ebp),%eax
f0120a3a:	75 12                	jne    f0120a4e <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f0120a3c:	83 ec 0c             	sub    $0xc,%esp
f0120a3f:	68 d8 03 13 f0       	push   $0xf01303d8
f0120a44:	e8 23 05 fe ff       	call   f0100f6c <cprintf>
f0120a49:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f0120a4c:	eb 14                	jmp    f0120a62 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f0120a4e:	83 ec 04             	sub    $0x4,%esp
f0120a51:	68 04 04 13 f0       	push   $0xf0130404
f0120a56:	6a 5e                	push   $0x5e
f0120a58:	68 bf 03 13 f0       	push   $0xf01303bf
f0120a5d:	e8 b8 f8 fd ff       	call   f010031a <_panic>
}
f0120a62:	c9                   	leave  
f0120a63:	c3                   	ret    

f0120a64 <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f0120a64:	55                   	push   %ebp
f0120a65:	89 e5                	mov    %esp,%ebp
f0120a67:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f0120a6a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0120a6e:	77 07                	ja     f0120a77 <nearest_pow2_ceil+0x13>
f0120a70:	b8 01 00 00 00       	mov    $0x1,%eax
f0120a75:	eb 20                	jmp    f0120a97 <nearest_pow2_ceil+0x33>
	int power = 2;
f0120a77:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f0120a7e:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f0120a81:	eb 08                	jmp    f0120a8b <nearest_pow2_ceil+0x27>
		power <<= 1;
f0120a83:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120a86:	01 c0                	add    %eax,%eax
f0120a88:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f0120a8b:	d1 6d 08             	shrl   0x8(%ebp)
f0120a8e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120a92:	75 ef                	jne    f0120a83 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f0120a94:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0120a97:	c9                   	leave  
f0120a98:	c3                   	ret    

f0120a99 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f0120a99:	55                   	push   %ebp
f0120a9a:	89 e5                	mov    %esp,%ebp
f0120a9c:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f0120a9f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0120aa3:	77 07                	ja     f0120aac <log2_ceil+0x13>
f0120aa5:	b8 01 00 00 00       	mov    $0x1,%eax
f0120aaa:	eb 1b                	jmp    f0120ac7 <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f0120aac:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f0120ab3:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f0120ab6:	eb 03                	jmp    f0120abb <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f0120ab8:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f0120abb:	d1 6d 08             	shrl   0x8(%ebp)
f0120abe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120ac2:	75 f4                	jne    f0120ab8 <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f0120ac4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0120ac7:	c9                   	leave  
f0120ac8:	c3                   	ret    

f0120ac9 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f0120ac9:	55                   	push   %ebp
f0120aca:	89 e5                	mov    %esp,%ebp
f0120acc:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f0120acf:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f0120ad6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0120add:	eb 12                	jmp    f0120af1 <fixedPt2Str+0x28>
		mulFactor *= 10;
f0120adf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120ae2:	89 d0                	mov    %edx,%eax
f0120ae4:	c1 e0 02             	shl    $0x2,%eax
f0120ae7:	01 d0                	add    %edx,%eax
f0120ae9:	01 c0                	add    %eax,%eax
f0120aeb:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f0120aee:	ff 45 f0             	incl   -0x10(%ebp)
f0120af1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120af4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120af7:	7c e6                	jl     f0120adf <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f0120af9:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0120afc:	83 ec 04             	sub    $0x4,%esp
f0120aff:	ff 75 f4             	pushl  -0xc(%ebp)
f0120b02:	ff 75 08             	pushl  0x8(%ebp)
f0120b05:	50                   	push   %eax
f0120b06:	e8 2f fd ff ff       	call   f012083a <fix_scale>
f0120b0b:	83 c4 0c             	add    $0xc,%esp
f0120b0e:	83 ec 0c             	sub    $0xc,%esp
f0120b11:	ff 75 dc             	pushl  -0x24(%ebp)
f0120b14:	e8 eb fc ff ff       	call   f0120804 <fix_round>
f0120b19:	83 c4 10             	add    $0x10,%esp
f0120b1c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f0120b1f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120b22:	99                   	cltd   
f0120b23:	f7 7d f4             	idivl  -0xc(%ebp)
f0120b26:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f0120b29:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120b2c:	99                   	cltd   
f0120b2d:	f7 7d f4             	idivl  -0xc(%ebp)
f0120b30:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f0120b33:	83 ec 08             	sub    $0x8,%esp
f0120b36:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120b39:	50                   	push   %eax
f0120b3a:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120b3d:	e8 70 1d 00 00       	call   f01228b2 <ltostr>
f0120b42:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f0120b45:	83 ec 08             	sub    $0x8,%esp
f0120b48:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0120b4b:	50                   	push   %eax
f0120b4c:	ff 75 e0             	pushl  -0x20(%ebp)
f0120b4f:	e8 5e 1d 00 00       	call   f01228b2 <ltostr>
f0120b54:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f0120b57:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0120b5a:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0120b5f:	f7 e9                	imul   %ecx
f0120b61:	c1 fa 02             	sar    $0x2,%edx
f0120b64:	89 c8                	mov    %ecx,%eax
f0120b66:	c1 f8 1f             	sar    $0x1f,%eax
f0120b69:	29 c2                	sub    %eax,%edx
f0120b6b:	89 d0                	mov    %edx,%eax
f0120b6d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f0120b70:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f0120b77:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f0120b7e:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f0120b84:	eb 31                	jmp    f0120bb7 <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f0120b86:	83 ec 04             	sub    $0x4,%esp
f0120b89:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0120b8c:	50                   	push   %eax
f0120b8d:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0120b90:	50                   	push   %eax
f0120b91:	68 20 04 13 f0       	push   $0xf0130420
f0120b96:	e8 f0 1d 00 00       	call   f012298b <strcconcat>
f0120b9b:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f0120b9e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0120ba1:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0120ba6:	f7 e9                	imul   %ecx
f0120ba8:	c1 fa 02             	sar    $0x2,%edx
f0120bab:	89 c8                	mov    %ecx,%eax
f0120bad:	c1 f8 1f             	sar    $0x1f,%eax
f0120bb0:	29 c2                	sub    %eax,%edx
f0120bb2:	89 d0                	mov    %edx,%eax
f0120bb4:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f0120bb7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120bba:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0120bbd:	7c c7                	jl     f0120b86 <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f0120bbf:	83 ec 04             	sub    $0x4,%esp
f0120bc2:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0120bc5:	50                   	push   %eax
f0120bc6:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0120bc9:	50                   	push   %eax
f0120bca:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0120bcd:	50                   	push   %eax
f0120bce:	e8 b8 1d 00 00       	call   f012298b <strcconcat>
f0120bd3:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f0120bd6:	83 ec 04             	sub    $0x4,%esp
f0120bd9:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120bdc:	50                   	push   %eax
f0120bdd:	68 22 04 13 f0       	push   $0xf0130422
f0120be2:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120be5:	50                   	push   %eax
f0120be6:	e8 a0 1d 00 00       	call   f012298b <strcconcat>
f0120beb:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f0120bee:	83 ec 04             	sub    $0x4,%esp
f0120bf1:	ff 75 10             	pushl  0x10(%ebp)
f0120bf4:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0120bf7:	50                   	push   %eax
f0120bf8:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120bfb:	50                   	push   %eax
f0120bfc:	e8 8a 1d 00 00       	call   f012298b <strcconcat>
f0120c01:	83 c4 10             	add    $0x10,%esp

}
f0120c04:	90                   	nop
f0120c05:	c9                   	leave  
f0120c06:	c3                   	ret    

f0120c07 <sys_utilities>:

int __firstTimeSleep = 1;
struct Channel __tstchan__ ;
struct spinlock __tstchan_lk__;
void sys_utilities(char* utilityName, int value)
{
f0120c07:	55                   	push   %ebp
f0120c08:	89 e5                	mov    %esp,%ebp
f0120c0a:	81 ec 88 00 00 00    	sub    $0x88,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f0120c10:	83 ec 0c             	sub    $0xc,%esp
f0120c13:	68 24 04 13 f0       	push   $0xf0130424
f0120c18:	e8 ef 17 00 00       	call   f012240c <strlen>
f0120c1d:	83 c4 10             	add    $0x10,%esp
f0120c20:	83 ec 04             	sub    $0x4,%esp
f0120c23:	50                   	push   %eax
f0120c24:	68 24 04 13 f0       	push   $0xf0130424
f0120c29:	ff 75 08             	pushl  0x8(%ebp)
f0120c2c:	e8 1f 19 00 00       	call   f0122550 <strncmp>
f0120c31:	83 c4 10             	add    $0x10,%esp
f0120c34:	85 c0                	test   %eax,%eax
f0120c36:	0f 85 84 00 00 00    	jne    f0120cc0 <sys_utilities+0xb9>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0120c3c:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120c3f:	50                   	push   %eax
f0120c40:	8d 45 80             	lea    -0x80(%ebp),%eax
f0120c43:	50                   	push   %eax
f0120c44:	68 32 04 13 f0       	push   $0xf0130432
f0120c49:	ff 75 08             	pushl  0x8(%ebp)
f0120c4c:	e8 d0 1d 00 00       	call   f0122a21 <strsplit>
f0120c51:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0120c54:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0120c57:	83 ec 04             	sub    $0x4,%esp
f0120c5a:	6a 0a                	push   $0xa
f0120c5c:	6a 00                	push   $0x0
f0120c5e:	50                   	push   %eax
f0120c5f:	e8 08 1b 00 00       	call   f012276c <strtol>
f0120c64:	83 c4 10             	add    $0x10,%esp
f0120c67:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f0120c6a:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		envid2env(envID, &env, 0);
f0120c71:	83 ec 04             	sub    $0x4,%esp
f0120c74:	6a 00                	push   $0x0
f0120c76:	8d 45 c4             	lea    -0x3c(%ebp),%eax
f0120c79:	50                   	push   %eax
f0120c7a:	ff 75 e0             	pushl  -0x20(%ebp)
f0120c7d:	e8 13 9b fe ff       	call   f010a795 <envid2env>
f0120c82:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f0120c85:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120c88:	8b 40 10             	mov    0x10(%eax),%eax
f0120c8b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0120c8e:	74 19                	je     f0120ca9 <sys_utilities+0xa2>
f0120c90:	68 34 04 13 f0       	push   $0xf0130434
f0120c95:	68 77 03 13 f0       	push   $0xf0130377
f0120c9a:	68 a1 00 00 00       	push   $0xa1
f0120c9f:	68 bf 03 13 f0       	push   $0xf01303bf
f0120ca4:	e8 71 f6 fd ff       	call   f010031a <_panic>
		env_set_nice(env, value);
f0120ca9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120cac:	83 ec 08             	sub    $0x8,%esp
f0120caf:	ff 75 0c             	pushl  0xc(%ebp)
f0120cb2:	50                   	push   %eax
f0120cb3:	e8 c4 59 fe ff       	call   f010667c <env_set_nice>
f0120cb8:	83 c4 10             	add    $0x10,%esp
f0120cbb:	e9 00 03 00 00       	jmp    f0120fc0 <sys_utilities+0x3b9>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f0120cc0:	83 ec 0c             	sub    $0xc,%esp
f0120cc3:	68 49 04 13 f0       	push   $0xf0130449
f0120cc8:	e8 3f 17 00 00       	call   f012240c <strlen>
f0120ccd:	83 c4 10             	add    $0x10,%esp
f0120cd0:	83 ec 04             	sub    $0x4,%esp
f0120cd3:	50                   	push   %eax
f0120cd4:	68 49 04 13 f0       	push   $0xf0130449
f0120cd9:	ff 75 08             	pushl  0x8(%ebp)
f0120cdc:	e8 6f 18 00 00       	call   f0122550 <strncmp>
f0120ce1:	83 c4 10             	add    $0x10,%esp
f0120ce4:	85 c0                	test   %eax,%eax
f0120ce6:	0f 85 a0 01 00 00    	jne    f0120e8c <sys_utilities+0x285>
	{
		int* numOfInstances = (int*) value ;
f0120cec:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120cef:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0120cf2:	8d 45 c0             	lea    -0x40(%ebp),%eax
f0120cf5:	50                   	push   %eax
f0120cf6:	8d 45 80             	lea    -0x80(%ebp),%eax
f0120cf9:	50                   	push   %eax
f0120cfa:	68 32 04 13 f0       	push   $0xf0130432
f0120cff:	ff 75 08             	pushl  0x8(%ebp)
f0120d02:	e8 1a 1d 00 00       	call   f0122a21 <strsplit>
f0120d07:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f0120d0a:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0120d0d:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f0120d10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f0120d17:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f0120d1e:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f0120d25:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120d28:	8b 00                	mov    (%eax),%eax
f0120d2a:	85 c0                	test   %eax,%eax
f0120d2c:	79 1c                	jns    f0120d4a <sys_utilities+0x143>
		{
			chkAscending = 0;
f0120d2e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f0120d35:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120d38:	8b 00                	mov    (%eax),%eax
f0120d3a:	f7 d8                	neg    %eax
f0120d3c:	89 c2                	mov    %eax,%edx
f0120d3e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120d41:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f0120d43:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f0120d4a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f0120d51:	83 ec 0c             	sub    $0xc,%esp
f0120d54:	68 00 1e 5a f0       	push   $0xf05a1e00
f0120d59:	e8 97 dd fe ff       	call   f010eaf5 <acquire_spinlock>
f0120d5e:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0120d61:	a1 8c 1e 5a f0       	mov    0xf05a1e8c,%eax
f0120d66:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f0120d69:	a1 84 1e 5a f0       	mov    0xf05a1e84,%eax
f0120d6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0120d71:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120d74:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0120d77:	eb 6c                	jmp    f0120de5 <sys_utilities+0x1de>
			{
				if (strcmp(env->prog_name, progName) != 0)
f0120d79:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d7c:	83 c0 20             	add    $0x20,%eax
f0120d7f:	83 ec 08             	sub    $0x8,%esp
f0120d82:	ff 75 d8             	pushl  -0x28(%ebp)
f0120d85:	50                   	push   %eax
f0120d86:	e8 8d 17 00 00       	call   f0122518 <strcmp>
f0120d8b:	83 c4 10             	add    $0x10,%esp
f0120d8e:	85 c0                	test   %eax,%eax
f0120d90:	75 46                	jne    f0120dd8 <sys_utilities+0x1d1>
					continue;
				(*numOfInstances)-- ;
f0120d92:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120d95:	8b 00                	mov    (%eax),%eax
f0120d97:	8d 50 ff             	lea    -0x1(%eax),%edx
f0120d9a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120d9d:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f0120d9f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120da3:	74 14                	je     f0120db9 <sys_utilities+0x1b2>
				{
					if (prevEnvID > env->env_id)
f0120da5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120da8:	8b 40 10             	mov    0x10(%eax),%eax
f0120dab:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0120dae:	7d 1d                	jge    f0120dcd <sys_utilities+0x1c6>
					{
						success = 0;
f0120db0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f0120db7:	eb 32                	jmp    f0120deb <sys_utilities+0x1e4>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f0120db9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120dbc:	8b 40 10             	mov    0x10(%eax),%eax
f0120dbf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0120dc2:	7e 09                	jle    f0120dcd <sys_utilities+0x1c6>
					{
						success = 0;
f0120dc4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f0120dcb:	eb 1e                	jmp    f0120deb <sys_utilities+0x1e4>
					}
				}
				prevEnvID = env->env_id;
f0120dcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120dd0:	8b 40 10             	mov    0x10(%eax),%eax
f0120dd3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0120dd6:	eb 01                	jmp    f0120dd9 <sys_utilities+0x1d2>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f0120dd8:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0120dd9:	ff 4d e4             	decl   -0x1c(%ebp)
f0120ddc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ddf:	8b 40 0c             	mov    0xc(%eax),%eax
f0120de2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120de5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120de9:	7f 8e                	jg     f0120d79 <sys_utilities+0x172>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f0120deb:	83 ec 0c             	sub    $0xc,%esp
f0120dee:	68 00 1e 5a f0       	push   $0xf05a1e00
f0120df3:	e8 84 dd fe ff       	call   f010eb7c <release_spinlock>
f0120df8:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f0120dfb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120dfe:	8b 00                	mov    (%eax),%eax
f0120e00:	85 c0                	test   %eax,%eax
f0120e02:	75 06                	jne    f0120e0a <sys_utilities+0x203>
f0120e04:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0120e08:	75 41                	jne    f0120e4b <sys_utilities+0x244>
		{
			cprintf("###########################################\n");
f0120e0a:	83 ec 0c             	sub    $0xc,%esp
f0120e0d:	68 5c 04 13 f0       	push   $0xf013045c
f0120e12:	e8 55 01 fe ff       	call   f0100f6c <cprintf>
f0120e17:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f0120e1a:	83 ec 08             	sub    $0x8,%esp
f0120e1d:	ff 75 d8             	pushl  -0x28(%ebp)
f0120e20:	68 8c 04 13 f0       	push   $0xf013048c
f0120e25:	e8 42 01 fe ff       	call   f0100f6c <cprintf>
f0120e2a:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f0120e2d:	83 ec 0c             	sub    $0xc,%esp
f0120e30:	68 5c 04 13 f0       	push   $0xf013045c
f0120e35:	e8 32 01 fe ff       	call   f0100f6c <cprintf>
f0120e3a:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f0120e3d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120e40:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120e46:	e9 75 01 00 00       	jmp    f0120fc0 <sys_utilities+0x3b9>
		}
		else
		{
			cprintf("####################################################\n");
f0120e4b:	83 ec 0c             	sub    $0xc,%esp
f0120e4e:	68 ac 04 13 f0       	push   $0xf01304ac
f0120e53:	e8 14 01 fe ff       	call   f0100f6c <cprintf>
f0120e58:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f0120e5b:	83 ec 08             	sub    $0x8,%esp
f0120e5e:	ff 75 d8             	pushl  -0x28(%ebp)
f0120e61:	68 e4 04 13 f0       	push   $0xf01304e4
f0120e66:	e8 01 01 fe ff       	call   f0100f6c <cprintf>
f0120e6b:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f0120e6e:	83 ec 0c             	sub    $0xc,%esp
f0120e71:	68 ac 04 13 f0       	push   $0xf01304ac
f0120e76:	e8 f1 00 fe ff       	call   f0100f6c <cprintf>
f0120e7b:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f0120e7e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120e81:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f0120e87:	e9 34 01 00 00       	jmp    f0120fc0 <sys_utilities+0x3b9>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f0120e8c:	83 ec 08             	sub    $0x8,%esp
f0120e8f:	68 07 05 13 f0       	push   $0xf0130507
f0120e94:	ff 75 08             	pushl  0x8(%ebp)
f0120e97:	e8 7c 16 00 00       	call   f0122518 <strcmp>
f0120e9c:	83 c4 10             	add    $0x10,%esp
f0120e9f:	85 c0                	test   %eax,%eax
f0120ea1:	75 77                	jne    f0120f1a <sys_utilities+0x313>
	{
		if (__firstTimeSleep)
f0120ea3:	a1 e0 0d 18 f0       	mov    0xf0180de0,%eax
f0120ea8:	85 c0                	test   %eax,%eax
f0120eaa:	74 34                	je     f0120ee0 <sys_utilities+0x2d9>
		{
			__firstTimeSleep = 0;
f0120eac:	c7 05 e0 0d 18 f0 00 	movl   $0x0,0xf0180de0
f0120eb3:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f0120eb6:	83 ec 08             	sub    $0x8,%esp
f0120eb9:	68 11 05 13 f0       	push   $0xf0130511
f0120ebe:	68 60 73 5c f0       	push   $0xf05c7360
f0120ec3:	e8 7f df fe ff       	call   f010ee47 <init_channel>
f0120ec8:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f0120ecb:	83 ec 08             	sub    $0x8,%esp
f0120ece:	68 1e 05 13 f0       	push   $0xf013051e
f0120ed3:	68 c0 73 5c f0       	push   $0xf05c73c0
f0120ed8:	e8 e7 db fe ff       	call   f010eac4 <init_spinlock>
f0120edd:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f0120ee0:	83 ec 0c             	sub    $0xc,%esp
f0120ee3:	68 c0 73 5c f0       	push   $0xf05c73c0
f0120ee8:	e8 08 dc fe ff       	call   f010eaf5 <acquire_spinlock>
f0120eed:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f0120ef0:	83 ec 08             	sub    $0x8,%esp
f0120ef3:	68 c0 73 5c f0       	push   $0xf05c73c0
f0120ef8:	68 60 73 5c f0       	push   $0xf05c7360
f0120efd:	e8 72 df fe ff       	call   f010ee74 <sleep>
f0120f02:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f0120f05:	83 ec 0c             	sub    $0xc,%esp
f0120f08:	68 c0 73 5c f0       	push   $0xf05c73c0
f0120f0d:	e8 6a dc fe ff       	call   f010eb7c <release_spinlock>
f0120f12:	83 c4 10             	add    $0x10,%esp
f0120f15:	e9 a6 00 00 00       	jmp    f0120fc0 <sys_utilities+0x3b9>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f0120f1a:	83 ec 08             	sub    $0x8,%esp
f0120f1d:	68 30 05 13 f0       	push   $0xf0130530
f0120f22:	ff 75 08             	pushl  0x8(%ebp)
f0120f25:	e8 ee 15 00 00       	call   f0122518 <strcmp>
f0120f2a:	83 c4 10             	add    $0x10,%esp
f0120f2d:	85 c0                	test   %eax,%eax
f0120f2f:	75 12                	jne    f0120f43 <sys_utilities+0x33c>
	{
		wakeup_one(&__tstchan__);
f0120f31:	83 ec 0c             	sub    $0xc,%esp
f0120f34:	68 60 73 5c f0       	push   $0xf05c7360
f0120f39:	e8 50 df fe ff       	call   f010ee8e <wakeup_one>
f0120f3e:	83 c4 10             	add    $0x10,%esp
f0120f41:	eb 7d                	jmp    f0120fc0 <sys_utilities+0x3b9>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f0120f43:	83 ec 08             	sub    $0x8,%esp
f0120f46:	68 3e 05 13 f0       	push   $0xf013053e
f0120f4b:	ff 75 08             	pushl  0x8(%ebp)
f0120f4e:	e8 c5 15 00 00       	call   f0122518 <strcmp>
f0120f53:	83 c4 10             	add    $0x10,%esp
f0120f56:	85 c0                	test   %eax,%eax
f0120f58:	75 12                	jne    f0120f6c <sys_utilities+0x365>
	{
		wakeup_all(&__tstchan__);
f0120f5a:	83 ec 0c             	sub    $0xc,%esp
f0120f5d:	68 60 73 5c f0       	push   $0xf05c7360
f0120f62:	e8 41 df fe ff       	call   f010eea8 <wakeup_all>
f0120f67:	83 c4 10             	add    $0x10,%esp
f0120f6a:	eb 54                	jmp    f0120fc0 <sys_utilities+0x3b9>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f0120f6c:	83 ec 08             	sub    $0x8,%esp
f0120f6f:	68 4c 05 13 f0       	push   $0xf013054c
f0120f74:	ff 75 08             	pushl  0x8(%ebp)
f0120f77:	e8 9c 15 00 00       	call   f0122518 <strcmp>
f0120f7c:	83 c4 10             	add    $0x10,%esp
f0120f7f:	85 c0                	test   %eax,%eax
f0120f81:	75 14                	jne    f0120f97 <sys_utilities+0x390>
	{
		int* numOfProcesses = (int*) value ;
f0120f83:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f86:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f0120f89:	a1 6c 73 5c f0       	mov    0xf05c736c,%eax
f0120f8e:	89 c2                	mov    %eax,%edx
f0120f90:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120f93:	89 10                	mov    %edx,(%eax)
f0120f95:	eb 29                	jmp    f0120fc0 <sys_utilities+0x3b9>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f0120f97:	83 ec 08             	sub    $0x8,%esp
f0120f9a:	68 61 05 13 f0       	push   $0xf0130561
f0120f9f:	ff 75 08             	pushl  0x8(%ebp)
f0120fa2:	e8 71 15 00 00       	call   f0122518 <strcmp>
f0120fa7:	83 c4 10             	add    $0x10,%esp
f0120faa:	85 c0                	test   %eax,%eax
f0120fac:	75 12                	jne    f0120fc0 <sys_utilities+0x3b9>
	{
		int* numOfProcesses = (int*) value ;
f0120fae:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fb1:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f0120fb4:	a1 9c 1e 5a f0       	mov    0xf05a1e9c,%eax
f0120fb9:	89 c2                	mov    %eax,%edx
f0120fbb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120fbe:	89 10                	mov    %edx,(%eax)
	}

	if ((int)value < 0)
f0120fc0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120fc4:	79 5b                	jns    f0121021 <sys_utilities+0x41a>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f0120fc6:	83 ec 08             	sub    $0x8,%esp
f0120fc9:	68 77 05 13 f0       	push   $0xf0130577
f0120fce:	ff 75 08             	pushl  0x8(%ebp)
f0120fd1:	e8 42 15 00 00       	call   f0122518 <strcmp>
f0120fd6:	83 c4 10             	add    $0x10,%esp
f0120fd9:	85 c0                	test   %eax,%eax
f0120fdb:	75 44                	jne    f0121021 <sys_utilities+0x41a>
		{
			switch (value)
f0120fdd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fe0:	83 f8 fc             	cmp    $0xfffffffc,%eax
f0120fe3:	74 07                	je     f0120fec <sys_utilities+0x3e5>
f0120fe5:	83 f8 fe             	cmp    $0xfffffffe,%eax
f0120fe8:	74 19                	je     f0121003 <sys_utilities+0x3fc>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f0120fea:	eb 35                	jmp    f0121021 <sys_utilities+0x41a>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f0120fec:	83 ec 0c             	sub    $0xc,%esp
f0120fef:	68 88 05 13 f0       	push   $0xf0130588
f0120ff4:	e8 73 ff fd ff       	call   f0100f6c <cprintf>
f0120ff9:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f0120ffc:	e8 9b d6 fe ff       	call   f010e69c <setPageReplacmentAlgorithmFIFO>
				break;
f0121001:	eb 1e                	jmp    f0121021 <sys_utilities+0x41a>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f0121003:	83 ec 0c             	sub    $0xc,%esp
f0121006:	68 f8 05 13 f0       	push   $0xf01305f8
f012100b:	e8 5c ff fd ff       	call   f0100f6c <cprintf>
f0121010:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f0121013:	83 ec 0c             	sub    $0xc,%esp
f0121016:	6a 02                	push   $0x2
f0121018:	e8 3c d6 fe ff       	call   f010e659 <setPageReplacmentAlgorithmLRU>
f012101d:	83 c4 10             	add    $0x10,%esp
				break;
f0121020:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f0121021:	90                   	nop
f0121022:	c9                   	leave  
f0121023:	c3                   	ret    

f0121024 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f0121024:	55                   	push   %ebp
f0121025:	89 e5                	mov    %esp,%ebp
f0121027:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f012102a:	8b 45 08             	mov    0x8(%ebp),%eax
f012102d:	8b 00                	mov    (%eax),%eax
f012102f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f0121032:	8b 45 08             	mov    0x8(%ebp),%eax
f0121035:	8b 00                	mov    (%eax),%eax
f0121037:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f012103a:	eb 52                	jmp    f012108e <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f012103c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012103f:	8b 00                	mov    (%eax),%eax
f0121041:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f0121044:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121047:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f012104a:	75 12                	jne    f012105e <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f012104c:	83 ec 0c             	sub    $0xc,%esp
f012104f:	68 6c 06 13 f0       	push   $0xf013066c
f0121054:	e8 13 ff fd ff       	call   f0100f6c <cprintf>
f0121059:	83 c4 10             	add    $0x10,%esp
			break;
f012105c:	eb 3f                	jmp    f012109d <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f012105e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121062:	74 38                	je     f012109c <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f0121064:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121067:	8b 00                	mov    (%eax),%eax
f0121069:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f012106c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012106f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0121072:	75 12                	jne    f0121086 <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f0121074:	83 ec 0c             	sub    $0xc,%esp
f0121077:	68 88 06 13 f0       	push   $0xf0130688
f012107c:	e8 eb fe fd ff       	call   f0100f6c <cprintf>
f0121081:	83 c4 10             	add    $0x10,%esp
			break;
f0121084:	eb 17                	jmp    f012109d <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f0121086:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121089:	8b 00                	mov    (%eax),%eax
f012108b:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f012108e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121092:	74 09                	je     f012109d <detect_loop_in_FrameInfo_list+0x79>
f0121094:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121098:	75 a2                	jne    f012103c <detect_loop_in_FrameInfo_list+0x18>
f012109a:	eb 01                	jmp    f012109d <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f012109c:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f012109d:	83 ec 0c             	sub    $0xc,%esp
f01210a0:	68 9f 06 13 f0       	push   $0xf013069f
f01210a5:	e8 c2 fe fd ff       	call   f0100f6c <cprintf>
f01210aa:	83 c4 10             	add    $0x10,%esp
}
f01210ad:	90                   	nop
f01210ae:	c9                   	leave  
f01210af:	c3                   	ret    

f01210b0 <scarce_memory>:

void scarce_memory()
{
f01210b0:	55                   	push   %ebp
f01210b1:	89 e5                	mov    %esp,%ebp
f01210b3:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f01210b6:	a1 80 45 5a f0       	mov    0xf05a4580,%eax
f01210bb:	ba 64 00 00 00       	mov    $0x64,%edx
f01210c0:	29 c2                	sub    %eax,%edx
f01210c2:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f01210c7:	0f af c2             	imul   %edx,%eax
f01210ca:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f01210cf:	f7 e2                	mul    %edx
f01210d1:	89 d0                	mov    %edx,%eax
f01210d3:	c1 e8 05             	shr    $0x5,%eax
f01210d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f01210d9:	a1 80 45 5a f0       	mov    0xf05a4580,%eax
f01210de:	ba 64 00 00 00       	mov    $0x64,%edx
f01210e3:	29 c2                	sub    %eax,%edx
f01210e5:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f01210ea:	89 d1                	mov    %edx,%ecx
f01210ec:	0f af c8             	imul   %eax,%ecx
f01210ef:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01210f4:	f7 e1                	mul    %ecx
f01210f6:	c1 ea 05             	shr    $0x5,%edx
f01210f9:	89 d0                	mov    %edx,%eax
f01210fb:	c1 e0 02             	shl    $0x2,%eax
f01210fe:	01 d0                	add    %edx,%eax
f0121100:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121107:	01 d0                	add    %edx,%eax
f0121109:	c1 e0 02             	shl    $0x2,%eax
f012110c:	29 c1                	sub    %eax,%ecx
f012110e:	89 ca                	mov    %ecx,%edx
f0121110:	85 d2                	test   %edx,%edx
f0121112:	74 03                	je     f0121117 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f0121114:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f0121117:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f012111e:	83 ec 0c             	sub    $0xc,%esp
f0121121:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f0121126:	e8 ca d9 fe ff       	call   f010eaf5 <acquire_spinlock>
f012112b:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f012112e:	a1 cc 1e 5a f0       	mov    0xf05a1ecc,%eax
f0121133:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f0121136:	8b 15 58 46 5a f0    	mov    0xf05a4658,%edx
f012113c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012113f:	29 c2                	sub    %eax,%edx
f0121141:	89 d0                	mov    %edx,%eax
f0121143:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f0121146:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121149:	2b 45 e8             	sub    -0x18(%ebp),%eax
f012114c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f012114f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f0121156:	eb 12                	jmp    f012116a <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f0121158:	83 ec 0c             	sub    $0xc,%esp
f012115b:	8d 45 e0             	lea    -0x20(%ebp),%eax
f012115e:	50                   	push   %eax
f012115f:	e8 41 70 fe ff       	call   f01081a5 <allocate_frame>
f0121164:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f0121167:	ff 45 f0             	incl   -0x10(%ebp)
f012116a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012116d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0121170:	76 e6                	jbe    f0121158 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f0121172:	83 ec 0c             	sub    $0xc,%esp
f0121175:	68 e0 1e 5a f0       	push   $0xf05a1ee0
f012117a:	e8 fd d9 fe ff       	call   f010eb7c <release_spinlock>
f012117f:	83 c4 10             	add    $0x10,%esp

}
f0121182:	90                   	nop
f0121183:	c9                   	leave  
f0121184:	c3                   	ret    

f0121185 <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f0121185:	55                   	push   %ebp
f0121186:	89 e5                	mov    %esp,%ebp
f0121188:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f012118b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f0121192:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f0121199:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f01211a0:	e8 a0 95 fe ff       	call   f010a745 <get_cpu_proc>
f01211a5:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f01211a8:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01211ac:	75 19                	jne    f01211c7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f01211ae:	68 b9 06 13 f0       	push   $0xf01306b9
f01211b3:	68 77 03 13 f0       	push   $0xf0130377
f01211b8:	68 5b 01 00 00       	push   $0x15b
f01211bd:	68 bf 03 13 f0       	push   $0xf01303bf
f01211c2:	e8 53 f1 fd ff       	call   f010031a <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f01211c7:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01211cb:	0f 85 f7 01 00 00    	jne    f01213c8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x243>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f01211d1:	83 ec 0c             	sub    $0xc,%esp
f01211d4:	68 00 1e 5a f0       	push   $0xf05a1e00
f01211d9:	e8 17 d9 fe ff       	call   f010eaf5 <acquire_spinlock>
f01211de:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f01211e1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01211e8:	e9 e9 00 00 00       	jmp    f01212d6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x151>
			{
				struct Env * ptr_ready_env = NULL;
f01211ed:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f01211f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01211f7:	83 c0 09             	add    $0x9,%eax
f01211fa:	c1 e0 04             	shl    $0x4,%eax
f01211fd:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f0121202:	8b 00                	mov    (%eax),%eax
f0121204:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0121207:	e9 81 00 00 00       	jmp    f012128d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x108>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
f012120c:	83 ec 0c             	sub    $0xc,%esp
f012120f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121212:	e8 1c 7b fe ff       	call   f0108d33 <env_page_ws_get_size>
f0121217:	83 c4 10             	add    $0x10,%esp
f012121a:	89 45 cc             	mov    %eax,-0x34(%ebp)
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f012121d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0121220:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f0121226:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121229:	0f af c2             	imul   %edx,%eax
f012122c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0121231:	f7 e2                	mul    %edx
f0121233:	89 d0                	mov    %edx,%eax
f0121235:	c1 e8 05             	shr    $0x5,%eax
f0121238:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f012123b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f012123e:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f0121244:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121247:	89 d1                	mov    %edx,%ecx
f0121249:	0f af c8             	imul   %eax,%ecx
f012124c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0121251:	f7 e1                	mul    %ecx
f0121253:	c1 ea 05             	shr    $0x5,%edx
f0121256:	89 d0                	mov    %edx,%eax
f0121258:	c1 e0 02             	shl    $0x2,%eax
f012125b:	01 d0                	add    %edx,%eax
f012125d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121264:	01 d0                	add    %edx,%eax
f0121266:	c1 e0 02             	shl    $0x2,%eax
f0121269:	29 c1                	sub    %eax,%ecx
f012126b:	89 ca                	mov    %ecx,%edx
f012126d:	85 d2                	test   %edx,%edx
f012126f:	74 03                	je     f0121274 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xef>
						num_of_pages_to_be_removed++;
f0121271:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f0121274:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121277:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f012127a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012127d:	83 c0 09             	add    $0x9,%eax
f0121280:	c1 e0 04             	shl    $0x4,%eax
f0121283:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f0121288:	8b 00                	mov    (%eax),%eax
f012128a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f012128d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121291:	74 08                	je     f012129b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x116>
f0121293:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121296:	8b 40 08             	mov    0x8(%eax),%eax
f0121299:	eb 05                	jmp    f01212a0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11b>
f012129b:	b8 00 00 00 00       	mov    $0x0,%eax
f01212a0:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01212a3:	83 c2 09             	add    $0x9,%edx
f01212a6:	c1 e2 04             	shl    $0x4,%edx
f01212a9:	81 c2 08 1e 5a f0    	add    $0xf05a1e08,%edx
f01212af:	89 02                	mov    %eax,(%edx)
f01212b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01212b4:	83 c0 09             	add    $0x9,%eax
f01212b7:	c1 e0 04             	shl    $0x4,%eax
f01212ba:	05 08 1e 5a f0       	add    $0xf05a1e08,%eax
f01212bf:	8b 00                	mov    (%eax),%eax
f01212c1:	85 c0                	test   %eax,%eax
f01212c3:	0f 85 43 ff ff ff    	jne    f012120c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x87>
f01212c9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01212cd:	0f 85 39 ff ff ff    	jne    f012120c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x87>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f01212d3:	ff 45 e8             	incl   -0x18(%ebp)
f01212d6:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f01212db:	0f b6 c0             	movzbl %al,%eax
f01212de:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01212e1:	0f 8f 06 ff ff ff    	jg     f01211ed <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f01212e7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f01212ee:	a1 80 1e 5a f0       	mov    0xf05a1e80,%eax
f01212f3:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01212f6:	eb 1f                	jmp    f0121317 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x192>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
f01212f8:	83 ec 0c             	sub    $0xc,%esp
f01212fb:	ff 75 dc             	pushl  -0x24(%ebp)
f01212fe:	e8 30 7a fe ff       	call   f0108d33 <env_page_ws_get_size>
f0121303:	83 c4 10             	add    $0x10,%esp
f0121306:	89 45 c8             	mov    %eax,-0x38(%ebp)
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f0121309:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012130c:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f012130f:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f0121314:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0121317:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012131b:	74 08                	je     f0121325 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x1a0>
f012131d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121320:	8b 40 08             	mov    0x8(%eax),%eax
f0121323:	eb 05                	jmp    f012132a <calc_no_pages_tobe_removed_from_ready_exit_queues+0x1a5>
f0121325:	b8 00 00 00 00       	mov    $0x0,%eax
f012132a:	a3 88 1e 5a f0       	mov    %eax,0xf05a1e88
f012132f:	a1 88 1e 5a f0       	mov    0xf05a1e88,%eax
f0121334:	85 c0                	test   %eax,%eax
f0121336:	75 c0                	jne    f01212f8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x173>
f0121338:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012133c:	75 ba                	jne    f01212f8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x173>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f012133e:	83 ec 0c             	sub    $0xc,%esp
f0121341:	68 00 1e 5a f0       	push   $0xf05a1e00
f0121346:	e8 31 d8 fe ff       	call   f010eb7c <release_spinlock>
f012134b:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f012134e:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0121352:	0f 84 de 00 00 00    	je     f0121436 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2b1>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
f0121358:	83 ec 0c             	sub    $0xc,%esp
f012135b:	ff 75 d0             	pushl  -0x30(%ebp)
f012135e:	e8 d0 79 fe ff       	call   f0108d33 <env_page_ws_get_size>
f0121363:	83 c4 10             	add    $0x10,%esp
f0121366:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f0121369:	8b 45 d0             	mov    -0x30(%ebp),%eax
f012136c:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f0121372:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121375:	0f af c2             	imul   %edx,%eax
f0121378:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f012137d:	f7 e2                	mul    %edx
f012137f:	89 d0                	mov    %edx,%eax
f0121381:	c1 e8 05             	shr    $0x5,%eax
f0121384:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0121387:	8b 45 d0             	mov    -0x30(%ebp),%eax
f012138a:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f0121390:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121393:	89 d1                	mov    %edx,%ecx
f0121395:	0f af c8             	imul   %eax,%ecx
f0121398:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f012139d:	f7 e1                	mul    %ecx
f012139f:	c1 ea 05             	shr    $0x5,%edx
f01213a2:	89 d0                	mov    %edx,%eax
f01213a4:	c1 e0 02             	shl    $0x2,%eax
f01213a7:	01 d0                	add    %edx,%eax
f01213a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01213b0:	01 d0                	add    %edx,%eax
f01213b2:	c1 e0 02             	shl    $0x2,%eax
f01213b5:	29 c1                	sub    %eax,%ecx
f01213b7:	89 ca                	mov    %ecx,%edx
f01213b9:	85 d2                	test   %edx,%edx
f01213bb:	74 03                	je     f01213c0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x23b>
				num_of_pages_to_be_removed++;
f01213bd:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f01213c0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01213c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01213c6:	eb 6e                	jmp    f0121436 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2b1>
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
f01213c8:	83 ec 0c             	sub    $0xc,%esp
f01213cb:	ff 75 d0             	pushl  -0x30(%ebp)
f01213ce:	e8 60 79 fe ff       	call   f0108d33 <env_page_ws_get_size>
f01213d3:	83 c4 10             	add    $0x10,%esp
f01213d6:	89 45 c0             	mov    %eax,-0x40(%ebp)
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f01213d9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01213dc:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f01213e2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01213e5:	0f af c2             	imul   %edx,%eax
f01213e8:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f01213ed:	f7 e2                	mul    %edx
f01213ef:	89 d0                	mov    %edx,%eax
f01213f1:	c1 e8 05             	shr    $0x5,%eax
f01213f4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f01213f7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01213fa:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f0121400:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121403:	89 d1                	mov    %edx,%ecx
f0121405:	0f af c8             	imul   %eax,%ecx
f0121408:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f012140d:	f7 e1                	mul    %ecx
f012140f:	c1 ea 05             	shr    $0x5,%edx
f0121412:	89 d0                	mov    %edx,%eax
f0121414:	c1 e0 02             	shl    $0x2,%eax
f0121417:	01 d0                	add    %edx,%eax
f0121419:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121420:	01 d0                	add    %edx,%eax
f0121422:	c1 e0 02             	shl    $0x2,%eax
f0121425:	29 c1                	sub    %eax,%ecx
f0121427:	89 ca                	mov    %ecx,%edx
f0121429:	85 d2                	test   %edx,%edx
f012142b:	74 03                	je     f0121430 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2ab>
			num_of_pages_to_be_removed++;
f012142d:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f0121430:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121433:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f0121436:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0121439:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012143c:	01 c2                	add    %eax,%edx
f012143e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121441:	01 d0                	add    %edx,%eax
}
f0121443:	c9                   	leave  
f0121444:	c3                   	ret    

f0121445 <schenv>:


void schenv()
{
f0121445:	55                   	push   %ebp
f0121446:	89 e5                	mov    %esp,%ebp
f0121448:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f012144b:	c6 05 80 4b 5a f0 00 	movb   $0x0,0xf05a4b80
	__ne = NULL;
f0121452:	c7 05 ac 48 5a f0 00 	movl   $0x0,0xf05a48ac
f0121459:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f012145c:	83 ec 0c             	sub    $0xc,%esp
f012145f:	68 00 1e 5a f0       	push   $0xf05a1e00
f0121464:	e8 8c d6 fe ff       	call   f010eaf5 <acquire_spinlock>
f0121469:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f012146c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121473:	eb 40                	jmp    f01214b5 <schenv+0x70>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f0121475:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121478:	83 c0 09             	add    $0x9,%eax
f012147b:	c1 e0 04             	shl    $0x4,%eax
f012147e:	05 00 1e 5a f0       	add    $0xf05a1e00,%eax
f0121483:	83 ec 0c             	sub    $0xc,%esp
f0121486:	50                   	push   %eax
f0121487:	e8 a9 3a fe ff       	call   f0104f35 <queue_size>
f012148c:	83 c4 10             	add    $0x10,%esp
f012148f:	85 c0                	test   %eax,%eax
f0121491:	74 1f                	je     f01214b2 <schenv+0x6d>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f0121493:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121496:	83 c0 09             	add    $0x9,%eax
f0121499:	c1 e0 04             	shl    $0x4,%eax
f012149c:	05 04 1e 5a f0       	add    $0xf05a1e04,%eax
f01214a1:	8b 00                	mov    (%eax),%eax
f01214a3:	a3 ac 48 5a f0       	mov    %eax,0xf05a48ac
				__nl = i;
f01214a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01214ab:	a2 80 4b 5a f0       	mov    %al,0xf05a4b80
				break;
f01214b0:	eb 10                	jmp    f01214c2 <schenv+0x7d>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f01214b2:	ff 45 f4             	incl   -0xc(%ebp)
f01214b5:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f01214ba:	0f b6 c0             	movzbl %al,%eax
f01214bd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01214c0:	7f b3                	jg     f0121475 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f01214c2:	83 ec 0c             	sub    $0xc,%esp
f01214c5:	68 00 1e 5a f0       	push   $0xf05a1e00
f01214ca:	e8 ad d6 fe ff       	call   f010eb7c <release_spinlock>
f01214cf:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f01214d2:	e8 6e 92 fe ff       	call   f010a745 <get_cpu_proc>
f01214d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f01214da:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01214de:	0f 84 82 00 00 00    	je     f0121566 <schenv+0x121>
	{
		if (__ne != NULL)
f01214e4:	a1 ac 48 5a f0       	mov    0xf05a48ac,%eax
f01214e9:	85 c0                	test   %eax,%eax
f01214eb:	74 49                	je     f0121536 <schenv+0xf1>
		{
			if ((__pl + 1) < __nl)
f01214ed:	a0 f1 1d 5a f0       	mov    0xf05a1df1,%al
f01214f2:	0f b6 c0             	movzbl %al,%eax
f01214f5:	8d 50 01             	lea    0x1(%eax),%edx
f01214f8:	a0 80 4b 5a f0       	mov    0xf05a4b80,%al
f01214fd:	0f b6 c0             	movzbl %al,%eax
f0121500:	39 c2                	cmp    %eax,%edx
f0121502:	7d 62                	jge    f0121566 <schenv+0x121>
			{
				__ne = cur_env;
f0121504:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121507:	a3 ac 48 5a f0       	mov    %eax,0xf05a48ac
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f012150c:	a0 f1 1d 5a f0       	mov    0xf05a1df1,%al
f0121511:	0f b6 c0             	movzbl %al,%eax
f0121514:	8a 15 00 4b 5a f0    	mov    0xf05a4b00,%dl
f012151a:	0f b6 d2             	movzbl %dl,%edx
f012151d:	4a                   	dec    %edx
f012151e:	39 d0                	cmp    %edx,%eax
f0121520:	7d 08                	jge    f012152a <schenv+0xe5>
f0121522:	a0 f1 1d 5a f0       	mov    0xf05a1df1,%al
f0121527:	40                   	inc    %eax
f0121528:	eb 05                	jmp    f012152f <schenv+0xea>
f012152a:	a0 f1 1d 5a f0       	mov    0xf05a1df1,%al
f012152f:	a2 80 4b 5a f0       	mov    %al,0xf05a4b80
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f0121534:	eb 30                	jmp    f0121566 <schenv+0x121>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f0121536:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121539:	a3 ac 48 5a f0       	mov    %eax,0xf05a48ac
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f012153e:	a0 f1 1d 5a f0       	mov    0xf05a1df1,%al
f0121543:	0f b6 c0             	movzbl %al,%eax
f0121546:	8a 15 00 4b 5a f0    	mov    0xf05a4b00,%dl
f012154c:	0f b6 d2             	movzbl %dl,%edx
f012154f:	4a                   	dec    %edx
f0121550:	39 d0                	cmp    %edx,%eax
f0121552:	7d 08                	jge    f012155c <schenv+0x117>
f0121554:	a0 f1 1d 5a f0       	mov    0xf05a1df1,%al
f0121559:	40                   	inc    %eax
f012155a:	eb 05                	jmp    f0121561 <schenv+0x11c>
f012155c:	a0 f1 1d 5a f0       	mov    0xf05a1df1,%al
f0121561:	a2 80 4b 5a f0       	mov    %al,0xf05a4b80
		}
	}
}
f0121566:	90                   	nop
f0121567:	c9                   	leave  
f0121568:	c3                   	ret    

f0121569 <chksch>:

void chksch(uint8 onoff)
{
f0121569:	55                   	push   %ebp
f012156a:	89 e5                	mov    %esp,%ebp
f012156c:	83 ec 18             	sub    $0x18,%esp
f012156f:	8b 45 08             	mov    0x8(%ebp),%eax
f0121572:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f0121575:	e8 8e 51 fe ff       	call   f0106708 <isSchedMethodBSD>
f012157a:	85 c0                	test   %eax,%eax
f012157c:	74 48                	je     f01215c6 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f012157e:	e8 33 51 fe ff       	call   f01066b6 <get_load_average>
f0121583:	a3 1c 4b 5a f0       	mov    %eax,0xf05a4b1c
f0121588:	a1 1c 4b 5a f0       	mov    0xf05a4b1c,%eax
f012158d:	a3 5c 46 5a f0       	mov    %eax,0xf05a465c
		acquire_spinlock(&ProcessQueues.qlock);
f0121592:	83 ec 0c             	sub    $0xc,%esp
f0121595:	68 00 1e 5a f0       	push   $0xf05a1e00
f012159a:	e8 56 d5 fe ff       	call   f010eaf5 <acquire_spinlock>
f012159f:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f01215a2:	a1 8c 1e 5a f0       	mov    0xf05a1e8c,%eax
f01215a7:	a3 60 1f 5a f0       	mov    %eax,0xf05a1f60
		}
		release_spinlock(&ProcessQueues.qlock);
f01215ac:	83 ec 0c             	sub    $0xc,%esp
f01215af:	68 00 1e 5a f0       	push   $0xf05a1e00
f01215b4:	e8 c3 d5 fe ff       	call   f010eb7c <release_spinlock>
f01215b9:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f01215bc:	c7 05 bc 48 5a f0 01 	movl   $0x1,0xf05a48bc
f01215c3:	00 00 00 
	}
	__chkstatus = onoff;
f01215c6:	8a 45 f4             	mov    -0xc(%ebp),%al
f01215c9:	a2 a8 48 5a f0       	mov    %al,0xf05a48a8
}
f01215ce:	90                   	nop
f01215cf:	c9                   	leave  
f01215d0:	c3                   	ret    

f01215d1 <chk1>:
void chk1()
{
f01215d1:	55                   	push   %ebp
f01215d2:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f01215d4:	90                   	nop
f01215d5:	5d                   	pop    %ebp
f01215d6:	c3                   	ret    

f01215d7 <chk2>:
void chk2(struct Env* __se)
{
f01215d7:	55                   	push   %ebp
f01215d8:	89 e5                	mov    %esp,%ebp
f01215da:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f01215dd:	a0 a8 48 5a f0       	mov    0xf05a48a8,%al
f01215e2:	84 c0                	test   %al,%al
f01215e4:	0f 84 59 03 00 00    	je     f0121943 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f01215ea:	e8 19 51 fe ff       	call   f0106708 <isSchedMethodBSD>
f01215ef:	85 c0                	test   %eax,%eax
f01215f1:	0f 84 4d 03 00 00    	je     f0121944 <chk2+0x36d>
	{
		__nla = get_load_average();
f01215f7:	e8 ba 50 fe ff       	call   f01066b6 <get_load_average>
f01215fc:	a3 84 45 5a f0       	mov    %eax,0xf05a4584
		acquire_spinlock(&ProcessQueues.qlock);
f0121601:	83 ec 0c             	sub    $0xc,%esp
f0121604:	68 00 1e 5a f0       	push   $0xf05a1e00
f0121609:	e8 e7 d4 fe ff       	call   f010eaf5 <acquire_spinlock>
f012160e:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0121611:	a1 8c 1e 5a f0       	mov    0xf05a1e8c,%eax
f0121616:	a3 b0 48 5a f0       	mov    %eax,0xf05a48b0
		}
		release_spinlock(&ProcessQueues.qlock);
f012161b:	83 ec 0c             	sub    $0xc,%esp
f012161e:	68 00 1e 5a f0       	push   $0xf05a1e00
f0121623:	e8 54 d5 fe ff       	call   f010eb7c <release_spinlock>
f0121628:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f012162b:	a1 bc 48 5a f0       	mov    0xf05a48bc,%eax
f0121630:	85 c0                	test   %eax,%eax
f0121632:	74 72                	je     f01216a6 <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f0121634:	83 ec 0c             	sub    $0xc,%esp
f0121637:	68 00 1e 5a f0       	push   $0xf05a1e00
f012163c:	e8 b4 d4 fe ff       	call   f010eaf5 <acquire_spinlock>
f0121641:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f0121644:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121648:	0f 95 c0             	setne  %al
f012164b:	0f b6 c0             	movzbl %al,%eax
f012164e:	a3 74 4a 5a f0       	mov    %eax,0xf05a4a74
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f0121653:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f0121658:	0f b6 c0             	movzbl %al,%eax
f012165b:	48                   	dec    %eax
f012165c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012165f:	eb 20                	jmp    f0121681 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f0121661:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121664:	83 c0 09             	add    $0x9,%eax
f0121667:	c1 e0 04             	shl    $0x4,%eax
f012166a:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f012166f:	8b 00                	mov    (%eax),%eax
f0121671:	8b 15 74 4a 5a f0    	mov    0xf05a4a74,%edx
f0121677:	01 d0                	add    %edx,%eax
f0121679:	a3 74 4a 5a f0       	mov    %eax,0xf05a4a74
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f012167e:	ff 4d f4             	decl   -0xc(%ebp)
f0121681:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121685:	79 da                	jns    f0121661 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f0121687:	c7 05 bc 48 5a f0 00 	movl   $0x0,0xf05a48bc
f012168e:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f0121691:	83 ec 0c             	sub    $0xc,%esp
f0121694:	68 00 1e 5a f0       	push   $0xf05a1e00
f0121699:	e8 de d4 fe ff       	call   f010eb7c <release_spinlock>
f012169e:	83 c4 10             	add    $0x10,%esp
f01216a1:	e9 91 02 00 00       	jmp    f0121937 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f01216a6:	8b 15 60 1f 5a f0    	mov    0xf05a1f60,%edx
f01216ac:	a1 b0 48 5a f0       	mov    0xf05a48b0,%eax
f01216b1:	39 c2                	cmp    %eax,%edx
f01216b3:	74 63                	je     f0121718 <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f01216b5:	83 ec 0c             	sub    $0xc,%esp
f01216b8:	68 00 1e 5a f0       	push   $0xf05a1e00
f01216bd:	e8 33 d4 fe ff       	call   f010eaf5 <acquire_spinlock>
f01216c2:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f01216c5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01216c9:	0f 95 c0             	setne  %al
f01216cc:	0f b6 c0             	movzbl %al,%eax
f01216cf:	a3 74 4a 5a f0       	mov    %eax,0xf05a4a74
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f01216d4:	a0 00 4b 5a f0       	mov    0xf05a4b00,%al
f01216d9:	0f b6 c0             	movzbl %al,%eax
f01216dc:	48                   	dec    %eax
f01216dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01216e0:	eb 20                	jmp    f0121702 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f01216e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216e5:	83 c0 09             	add    $0x9,%eax
f01216e8:	c1 e0 04             	shl    $0x4,%eax
f01216eb:	05 0c 1e 5a f0       	add    $0xf05a1e0c,%eax
f01216f0:	8b 00                	mov    (%eax),%eax
f01216f2:	8b 15 74 4a 5a f0    	mov    0xf05a4a74,%edx
f01216f8:	01 d0                	add    %edx,%eax
f01216fa:	a3 74 4a 5a f0       	mov    %eax,0xf05a4a74
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f01216ff:	ff 4d f0             	decl   -0x10(%ebp)
f0121702:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121706:	79 da                	jns    f01216e2 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f0121708:	83 ec 0c             	sub    $0xc,%esp
f012170b:	68 00 1e 5a f0       	push   $0xf05a1e00
f0121710:	e8 67 d4 fe ff       	call   f010eb7c <release_spinlock>
f0121715:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f0121718:	e8 32 4f fe ff       	call   f010664f <timer_ticks>
f012171d:	6a 00                	push   $0x0
f012171f:	68 e8 03 00 00       	push   $0x3e8
f0121724:	52                   	push   %edx
f0121725:	50                   	push   %eax
f0121726:	e8 7d 2c 00 00       	call   f01243a8 <__moddi3>
f012172b:	83 c4 10             	add    $0x10,%esp
f012172e:	09 d0                	or     %edx,%eax
f0121730:	85 c0                	test   %eax,%eax
f0121732:	75 32                	jne    f0121766 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f0121734:	8b 15 5c 46 5a f0    	mov    0xf05a465c,%edx
f012173a:	a1 84 45 5a f0       	mov    0xf05a4584,%eax
f012173f:	39 c2                	cmp    %eax,%edx
f0121741:	75 19                	jne    f012175c <chk2+0x185>
f0121743:	68 c9 06 13 f0       	push   $0xf01306c9
f0121748:	68 77 03 13 f0       	push   $0xf0130377
f012174d:	68 17 02 00 00       	push   $0x217
f0121752:	68 bf 03 13 f0       	push   $0xf01303bf
f0121757:	e8 4e ec fd ff       	call   f01003aa <_panic_all>
				__histla = __nla;
f012175c:	a1 84 45 5a f0       	mov    0xf05a4584,%eax
f0121761:	a3 5c 46 5a f0       	mov    %eax,0xf05a465c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f0121766:	e8 e4 4e fe ff       	call   f010664f <timer_ticks>
f012176b:	6a 00                	push   $0x0
f012176d:	6a 64                	push   $0x64
f012176f:	52                   	push   %edx
f0121770:	50                   	push   %eax
f0121771:	e8 32 2c 00 00       	call   f01243a8 <__moddi3>
f0121776:	83 c4 10             	add    $0x10,%esp
f0121779:	09 d0                	or     %edx,%eax
f012177b:	85 c0                	test   %eax,%eax
f012177d:	0f 85 b4 01 00 00    	jne    f0121937 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f0121783:	8b 0d 1c 4b 5a f0    	mov    0xf05a4b1c,%ecx
f0121789:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f012178e:	f7 e9                	imul   %ecx
f0121790:	c1 fa 05             	sar    $0x5,%edx
f0121793:	89 c8                	mov    %ecx,%eax
f0121795:	c1 f8 1f             	sar    $0x1f,%eax
f0121798:	29 c2                	sub    %eax,%edx
f012179a:	89 d0                	mov    %edx,%eax
f012179c:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f012179f:	8b 0d 1c 4b 5a f0    	mov    0xf05a4b1c,%ecx
f01217a5:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01217aa:	f7 e9                	imul   %ecx
f01217ac:	c1 fa 05             	sar    $0x5,%edx
f01217af:	89 c8                	mov    %ecx,%eax
f01217b1:	c1 f8 1f             	sar    $0x1f,%eax
f01217b4:	29 c2                	sub    %eax,%edx
f01217b6:	89 d0                	mov    %edx,%eax
f01217b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01217bb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01217be:	89 d0                	mov    %edx,%eax
f01217c0:	c1 e0 02             	shl    $0x2,%eax
f01217c3:	01 d0                	add    %edx,%eax
f01217c5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01217cc:	01 d0                	add    %edx,%eax
f01217ce:	c1 e0 02             	shl    $0x2,%eax
f01217d1:	29 c1                	sub    %eax,%ecx
f01217d3:	89 c8                	mov    %ecx,%eax
f01217d5:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f01217d8:	8b 0d 84 45 5a f0    	mov    0xf05a4584,%ecx
f01217de:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01217e3:	f7 e9                	imul   %ecx
f01217e5:	c1 fa 05             	sar    $0x5,%edx
f01217e8:	89 c8                	mov    %ecx,%eax
f01217ea:	c1 f8 1f             	sar    $0x1f,%eax
f01217ed:	29 c2                	sub    %eax,%edx
f01217ef:	89 d0                	mov    %edx,%eax
f01217f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f01217f4:	8b 0d 84 45 5a f0    	mov    0xf05a4584,%ecx
f01217fa:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01217ff:	f7 e9                	imul   %ecx
f0121801:	c1 fa 05             	sar    $0x5,%edx
f0121804:	89 c8                	mov    %ecx,%eax
f0121806:	c1 f8 1f             	sar    $0x1f,%eax
f0121809:	29 c2                	sub    %eax,%edx
f012180b:	89 d0                	mov    %edx,%eax
f012180d:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0121810:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121813:	89 d0                	mov    %edx,%eax
f0121815:	c1 e0 02             	shl    $0x2,%eax
f0121818:	01 d0                	add    %edx,%eax
f012181a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121821:	01 d0                	add    %edx,%eax
f0121823:	c1 e0 02             	shl    $0x2,%eax
f0121826:	29 c1                	sub    %eax,%ecx
f0121828:	89 c8                	mov    %ecx,%eax
f012182a:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f012182d:	8b 15 b0 48 5a f0    	mov    0xf05a48b0,%edx
f0121833:	a1 60 1f 5a f0       	mov    0xf05a1f60,%eax
f0121838:	39 c2                	cmp    %eax,%edx
f012183a:	0f 85 ed 00 00 00    	jne    f012192d <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f0121840:	a1 74 4a 5a f0       	mov    0xf05a4a74,%eax
f0121845:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121848:	7e 5b                	jle    f01218a5 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f012184a:	a1 74 4a 5a f0       	mov    0xf05a4a74,%eax
f012184f:	83 ec 08             	sub    $0x8,%esp
f0121852:	ff 75 e0             	pushl  -0x20(%ebp)
f0121855:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121858:	ff 75 e8             	pushl  -0x18(%ebp)
f012185b:	ff 75 ec             	pushl  -0x14(%ebp)
f012185e:	50                   	push   %eax
f012185f:	68 dc 06 13 f0       	push   $0xf01306dc
f0121864:	e8 03 f7 fd ff       	call   f0100f6c <cprintf>
f0121869:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f012186c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012186f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121872:	0f 8f b5 00 00 00    	jg     f012192d <chk2+0x356>
f0121878:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012187b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f012187e:	75 0c                	jne    f012188c <chk2+0x2b5>
f0121880:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121883:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121886:	0f 8d a1 00 00 00    	jge    f012192d <chk2+0x356>
f012188c:	68 24 07 13 f0       	push   $0xf0130724
f0121891:	68 77 03 13 f0       	push   $0xf0130377
f0121896:	68 2c 02 00 00       	push   $0x22c
f012189b:	68 bf 03 13 f0       	push   $0xf01303bf
f01218a0:	e8 05 eb fd ff       	call   f01003aa <_panic_all>
					}
					else if (__nproc < plaint)
f01218a5:	a1 74 4a 5a f0       	mov    0xf05a4a74,%eax
f01218aa:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01218ad:	7d 53                	jge    f0121902 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f01218af:	a1 74 4a 5a f0       	mov    0xf05a4a74,%eax
f01218b4:	83 ec 08             	sub    $0x8,%esp
f01218b7:	ff 75 e0             	pushl  -0x20(%ebp)
f01218ba:	ff 75 e4             	pushl  -0x1c(%ebp)
f01218bd:	ff 75 e8             	pushl  -0x18(%ebp)
f01218c0:	ff 75 ec             	pushl  -0x14(%ebp)
f01218c3:	50                   	push   %eax
f01218c4:	68 64 07 13 f0       	push   $0xf0130764
f01218c9:	e8 9e f6 fd ff       	call   f0100f6c <cprintf>
f01218ce:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f01218d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01218d4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01218d7:	7c 54                	jl     f012192d <chk2+0x356>
f01218d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01218dc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01218df:	75 08                	jne    f01218e9 <chk2+0x312>
f01218e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01218e4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01218e7:	7e 44                	jle    f012192d <chk2+0x356>
f01218e9:	68 ac 07 13 f0       	push   $0xf01307ac
f01218ee:	68 77 03 13 f0       	push   $0xf0130377
f01218f3:	68 32 02 00 00       	push   $0x232
f01218f8:	68 bf 03 13 f0       	push   $0xf01303bf
f01218fd:	e8 a8 ea fd ff       	call   f01003aa <_panic_all>
					}
					else if (__nproc == plaint)
f0121902:	a1 74 4a 5a f0       	mov    0xf05a4a74,%eax
f0121907:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f012190a:	75 21                	jne    f012192d <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f012190c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012190f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121912:	74 19                	je     f012192d <chk2+0x356>
f0121914:	68 ec 07 13 f0       	push   $0xf01307ec
f0121919:	68 77 03 13 f0       	push   $0xf0130377
f012191e:	68 36 02 00 00       	push   $0x236
f0121923:	68 bf 03 13 f0       	push   $0xf01303bf
f0121928:	e8 7d ea fd ff       	call   f01003aa <_panic_all>
					}
				}
				__pla = __nla;
f012192d:	a1 84 45 5a f0       	mov    0xf05a4584,%eax
f0121932:	a3 1c 4b 5a f0       	mov    %eax,0xf05a4b1c
			}
		}
		__pnexit = __nnexit;
f0121937:	a1 b0 48 5a f0       	mov    0xf05a48b0,%eax
f012193c:	a3 60 1f 5a f0       	mov    %eax,0xf05a1f60
f0121941:	eb 01                	jmp    f0121944 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f0121943:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f0121944:	c9                   	leave  
f0121945:	c3                   	ret    

f0121946 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f0121946:	55                   	push   %ebp
f0121947:	89 e5                	mov    %esp,%ebp
f0121949:	83 ec 18             	sub    $0x18,%esp
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#else
	{
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
f012194c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121953:	eb 40                	jmp    f0121995 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f0121955:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121958:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f012195e:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0121963:	83 ec 08             	sub    $0x8,%esp
f0121966:	52                   	push   %edx
f0121967:	50                   	push   %eax
f0121968:	e8 a6 01 00 00       	call   f0121b13 <check_va2pa>
f012196d:	83 c4 10             	add    $0x10,%esp
f0121970:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0121973:	74 19                	je     f012198e <check_boot_pgdir+0x48>
f0121975:	68 00 08 13 f0       	push   $0xf0130800
f012197a:	68 77 03 13 f0       	push   $0xf0130377
f012197f:	68 82 02 00 00       	push   $0x282
f0121984:	68 bf 03 13 f0       	push   $0xf01303bf
f0121989:	e8 8c e9 fd ff       	call   f010031a <_panic>
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#else
	{
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
f012198e:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0121995:	81 7d f4 00 00 00 10 	cmpl   $0x10000000,-0xc(%ebp)
f012199c:	75 b7                	jne    f0121955 <check_boot_pgdir+0xf>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f012199e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01219a5:	e9 81 00 00 00       	jmp    f0121a2b <check_boot_pgdir+0xe5>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f01219aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01219ad:	25 ff 7f 00 00       	and    $0x7fff,%eax
f01219b2:	85 c0                	test   %eax,%eax
f01219b4:	74 6d                	je     f0121a23 <check_boot_pgdir+0xdd>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f01219b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01219b9:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f01219bf:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f01219c4:	83 ec 08             	sub    $0x8,%esp
f01219c7:	52                   	push   %edx
f01219c8:	50                   	push   %eax
f01219c9:	e8 45 01 00 00       	call   f0121b13 <check_va2pa>
f01219ce:	83 c4 10             	add    $0x10,%esp
f01219d1:	c7 45 f0 00 80 17 f0 	movl   $0xf0178000,-0x10(%ebp)
f01219d8:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f01219df:	77 17                	ja     f01219f8 <check_boot_pgdir+0xb2>
f01219e1:	ff 75 f0             	pushl  -0x10(%ebp)
f01219e4:	68 38 08 13 f0       	push   $0xf0130838
f01219e9:	68 8b 02 00 00       	push   $0x28b
f01219ee:	68 bf 03 13 f0       	push   $0xf01303bf
f01219f3:	e8 22 e9 fd ff       	call   f010031a <_panic>
f01219f8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01219fb:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f0121a01:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121a04:	01 ca                	add    %ecx,%edx
f0121a06:	39 d0                	cmp    %edx,%eax
f0121a08:	74 1a                	je     f0121a24 <check_boot_pgdir+0xde>
f0121a0a:	68 6c 08 13 f0       	push   $0xf013086c
f0121a0f:	68 77 03 13 f0       	push   $0xf0130377
f0121a14:	68 8b 02 00 00       	push   $0x28b
f0121a19:	68 bf 03 13 f0       	push   $0xf01303bf
f0121a1e:	e8 f7 e8 fd ff       	call   f010031a <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f0121a23:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f0121a24:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0121a2b:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f0121a32:	0f 86 72 ff ff ff    	jbe    f01219aa <check_boot_pgdir+0x64>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f0121a38:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121a3f:	e9 af 00 00 00       	jmp    f0121af3 <check_boot_pgdir+0x1ad>
		switch (i) {
f0121a44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121a47:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f0121a4c:	74 11                	je     f0121a5f <check_boot_pgdir+0x119>
f0121a4e:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f0121a53:	72 36                	jb     f0121a8b <check_boot_pgdir+0x145>
f0121a55:	2d bd 03 00 00       	sub    $0x3bd,%eax
f0121a5a:	83 f8 02             	cmp    $0x2,%eax
f0121a5d:	77 2c                	ja     f0121a8b <check_boot_pgdir+0x145>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f0121a5f:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0121a64:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121a67:	c1 e2 02             	shl    $0x2,%edx
f0121a6a:	01 d0                	add    %edx,%eax
f0121a6c:	8b 00                	mov    (%eax),%eax
f0121a6e:	85 c0                	test   %eax,%eax
f0121a70:	75 7a                	jne    f0121aec <check_boot_pgdir+0x1a6>
f0121a72:	68 f2 08 13 f0       	push   $0xf01308f2
f0121a77:	68 77 03 13 f0       	push   $0xf0130377
f0121a7c:	68 96 02 00 00       	push   $0x296
f0121a81:	68 bf 03 13 f0       	push   $0xf01303bf
f0121a86:	e8 8f e8 fd ff       	call   f010031a <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f0121a8b:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f0121a92:	76 2c                	jbe    f0121ac0 <check_boot_pgdir+0x17a>
				assert(ptr_page_directory[i]);
f0121a94:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0121a99:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121a9c:	c1 e2 02             	shl    $0x2,%edx
f0121a9f:	01 d0                	add    %edx,%eax
f0121aa1:	8b 00                	mov    (%eax),%eax
f0121aa3:	85 c0                	test   %eax,%eax
f0121aa5:	75 48                	jne    f0121aef <check_boot_pgdir+0x1a9>
f0121aa7:	68 f2 08 13 f0       	push   $0xf01308f2
f0121aac:	68 77 03 13 f0       	push   $0xf0130377
f0121ab1:	68 9a 02 00 00       	push   $0x29a
f0121ab6:	68 bf 03 13 f0       	push   $0xf01303bf
f0121abb:	e8 5a e8 fd ff       	call   f010031a <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f0121ac0:	a1 7c 4a 5a f0       	mov    0xf05a4a7c,%eax
f0121ac5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121ac8:	c1 e2 02             	shl    $0x2,%edx
f0121acb:	01 d0                	add    %edx,%eax
f0121acd:	8b 00                	mov    (%eax),%eax
f0121acf:	85 c0                	test   %eax,%eax
f0121ad1:	74 1c                	je     f0121aef <check_boot_pgdir+0x1a9>
f0121ad3:	68 08 09 13 f0       	push   $0xf0130908
f0121ad8:	68 77 03 13 f0       	push   $0xf0130377
f0121add:	68 9c 02 00 00       	push   $0x29c
f0121ae2:	68 bf 03 13 f0       	push   $0xf01303bf
f0121ae7:	e8 2e e8 fd ff       	call   f010031a <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f0121aec:	90                   	nop
f0121aed:	eb 01                	jmp    f0121af0 <check_boot_pgdir+0x1aa>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f0121aef:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f0121af0:	ff 45 f4             	incl   -0xc(%ebp)
f0121af3:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0121afa:	0f 86 44 ff ff ff    	jbe    f0121a44 <check_boot_pgdir+0xfe>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f0121b00:	83 ec 0c             	sub    $0xc,%esp
f0121b03:	68 24 09 13 f0       	push   $0xf0130924
f0121b08:	e8 5f f4 fd ff       	call   f0100f6c <cprintf>
f0121b0d:	83 c4 10             	add    $0x10,%esp
}
f0121b10:	90                   	nop
f0121b11:	c9                   	leave  
f0121b12:	c3                   	ret    

f0121b13 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f0121b13:	55                   	push   %ebp
f0121b14:	89 e5                	mov    %esp,%ebp
f0121b16:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f0121b19:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121b1c:	c1 e8 16             	shr    $0x16,%eax
f0121b1f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121b26:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b29:	01 d0                	add    %edx,%eax
f0121b2b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f0121b2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121b31:	8b 00                	mov    (%eax),%eax
f0121b33:	83 e0 01             	and    $0x1,%eax
f0121b36:	85 c0                	test   %eax,%eax
f0121b38:	75 0a                	jne    f0121b44 <check_va2pa+0x31>
		return ~0;
f0121b3a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0121b3f:	e9 87 00 00 00       	jmp    f0121bcb <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f0121b44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121b47:	8b 00                	mov    (%eax),%eax
f0121b49:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0121b4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121b51:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121b54:	c1 e8 0c             	shr    $0xc,%eax
f0121b57:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0121b5a:	a1 58 46 5a f0       	mov    0xf05a4658,%eax
f0121b5f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0121b62:	72 17                	jb     f0121b7b <check_va2pa+0x68>
f0121b64:	ff 75 f0             	pushl  -0x10(%ebp)
f0121b67:	68 48 09 13 f0       	push   $0xf0130948
f0121b6c:	68 b2 02 00 00       	push   $0x2b2
f0121b71:	68 bf 03 13 f0       	push   $0xf01303bf
f0121b76:	e8 9f e7 fd ff       	call   f010031a <_panic>
f0121b7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121b7e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0121b83:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f0121b86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121b89:	c1 e8 0c             	shr    $0xc,%eax
f0121b8c:	25 ff 03 00 00       	and    $0x3ff,%eax
f0121b91:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121b98:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121b9b:	01 d0                	add    %edx,%eax
f0121b9d:	8b 00                	mov    (%eax),%eax
f0121b9f:	83 e0 01             	and    $0x1,%eax
f0121ba2:	85 c0                	test   %eax,%eax
f0121ba4:	75 07                	jne    f0121bad <check_va2pa+0x9a>
		return ~0;
f0121ba6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0121bab:	eb 1e                	jmp    f0121bcb <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f0121bad:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121bb0:	c1 e8 0c             	shr    $0xc,%eax
f0121bb3:	25 ff 03 00 00       	and    $0x3ff,%eax
f0121bb8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121bbf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121bc2:	01 d0                	add    %edx,%eax
f0121bc4:	8b 00                	mov    (%eax),%eax
f0121bc6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0121bcb:	c9                   	leave  
f0121bcc:	c3                   	ret    

f0121bcd <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f0121bcd:	55                   	push   %ebp
f0121bce:	89 e5                	mov    %esp,%ebp
f0121bd0:	53                   	push   %ebx
f0121bd1:	83 ec 14             	sub    $0x14,%esp
f0121bd4:	8b 45 10             	mov    0x10(%ebp),%eax
f0121bd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121bda:	8b 45 14             	mov    0x14(%ebp),%eax
f0121bdd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f0121be0:	8b 45 18             	mov    0x18(%ebp),%eax
f0121be3:	ba 00 00 00 00       	mov    $0x0,%edx
f0121be8:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f0121beb:	77 55                	ja     f0121c42 <printnum+0x75>
f0121bed:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f0121bf0:	72 05                	jb     f0121bf7 <printnum+0x2a>
f0121bf2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0121bf5:	77 4b                	ja     f0121c42 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f0121bf7:	8b 45 1c             	mov    0x1c(%ebp),%eax
f0121bfa:	8d 58 ff             	lea    -0x1(%eax),%ebx
f0121bfd:	8b 45 18             	mov    0x18(%ebp),%eax
f0121c00:	ba 00 00 00 00       	mov    $0x0,%edx
f0121c05:	52                   	push   %edx
f0121c06:	50                   	push   %eax
f0121c07:	ff 75 f4             	pushl  -0xc(%ebp)
f0121c0a:	ff 75 f0             	pushl  -0x10(%ebp)
f0121c0d:	e8 2e 29 00 00       	call   f0124540 <__udivdi3>
f0121c12:	83 c4 10             	add    $0x10,%esp
f0121c15:	83 ec 04             	sub    $0x4,%esp
f0121c18:	ff 75 20             	pushl  0x20(%ebp)
f0121c1b:	53                   	push   %ebx
f0121c1c:	ff 75 18             	pushl  0x18(%ebp)
f0121c1f:	52                   	push   %edx
f0121c20:	50                   	push   %eax
f0121c21:	ff 75 0c             	pushl  0xc(%ebp)
f0121c24:	ff 75 08             	pushl  0x8(%ebp)
f0121c27:	e8 a1 ff ff ff       	call   f0121bcd <printnum>
f0121c2c:	83 c4 20             	add    $0x20,%esp
f0121c2f:	eb 1a                	jmp    f0121c4b <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f0121c31:	83 ec 08             	sub    $0x8,%esp
f0121c34:	ff 75 0c             	pushl  0xc(%ebp)
f0121c37:	ff 75 20             	pushl  0x20(%ebp)
f0121c3a:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c3d:	ff d0                	call   *%eax
f0121c3f:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f0121c42:	ff 4d 1c             	decl   0x1c(%ebp)
f0121c45:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f0121c49:	7f e6                	jg     f0121c31 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f0121c4b:	8b 4d 18             	mov    0x18(%ebp),%ecx
f0121c4e:	bb 00 00 00 00       	mov    $0x0,%ebx
f0121c53:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121c56:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121c59:	53                   	push   %ebx
f0121c5a:	51                   	push   %ecx
f0121c5b:	52                   	push   %edx
f0121c5c:	50                   	push   %eax
f0121c5d:	e8 ee 29 00 00       	call   f0124650 <__umoddi3>
f0121c62:	83 c4 10             	add    $0x10,%esp
f0121c65:	05 94 0b 13 f0       	add    $0xf0130b94,%eax
f0121c6a:	8a 00                	mov    (%eax),%al
f0121c6c:	0f be c0             	movsbl %al,%eax
f0121c6f:	83 ec 08             	sub    $0x8,%esp
f0121c72:	ff 75 0c             	pushl  0xc(%ebp)
f0121c75:	50                   	push   %eax
f0121c76:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c79:	ff d0                	call   *%eax
f0121c7b:	83 c4 10             	add    $0x10,%esp
}
f0121c7e:	90                   	nop
f0121c7f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0121c82:	c9                   	leave  
f0121c83:	c3                   	ret    

f0121c84 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f0121c84:	55                   	push   %ebp
f0121c85:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f0121c87:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f0121c8b:	7e 1c                	jle    f0121ca9 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f0121c8d:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c90:	8b 00                	mov    (%eax),%eax
f0121c92:	8d 50 08             	lea    0x8(%eax),%edx
f0121c95:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c98:	89 10                	mov    %edx,(%eax)
f0121c9a:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c9d:	8b 00                	mov    (%eax),%eax
f0121c9f:	83 e8 08             	sub    $0x8,%eax
f0121ca2:	8b 50 04             	mov    0x4(%eax),%edx
f0121ca5:	8b 00                	mov    (%eax),%eax
f0121ca7:	eb 40                	jmp    f0121ce9 <getuint+0x65>
	else if (lflag)
f0121ca9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121cad:	74 1e                	je     f0121ccd <getuint+0x49>
		return va_arg(*ap, unsigned long);
f0121caf:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cb2:	8b 00                	mov    (%eax),%eax
f0121cb4:	8d 50 04             	lea    0x4(%eax),%edx
f0121cb7:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cba:	89 10                	mov    %edx,(%eax)
f0121cbc:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cbf:	8b 00                	mov    (%eax),%eax
f0121cc1:	83 e8 04             	sub    $0x4,%eax
f0121cc4:	8b 00                	mov    (%eax),%eax
f0121cc6:	ba 00 00 00 00       	mov    $0x0,%edx
f0121ccb:	eb 1c                	jmp    f0121ce9 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f0121ccd:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cd0:	8b 00                	mov    (%eax),%eax
f0121cd2:	8d 50 04             	lea    0x4(%eax),%edx
f0121cd5:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cd8:	89 10                	mov    %edx,(%eax)
f0121cda:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cdd:	8b 00                	mov    (%eax),%eax
f0121cdf:	83 e8 04             	sub    $0x4,%eax
f0121ce2:	8b 00                	mov    (%eax),%eax
f0121ce4:	ba 00 00 00 00       	mov    $0x0,%edx
}
f0121ce9:	5d                   	pop    %ebp
f0121cea:	c3                   	ret    

f0121ceb <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f0121ceb:	55                   	push   %ebp
f0121cec:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f0121cee:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f0121cf2:	7e 1c                	jle    f0121d10 <getint+0x25>
		return va_arg(*ap, long long);
f0121cf4:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cf7:	8b 00                	mov    (%eax),%eax
f0121cf9:	8d 50 08             	lea    0x8(%eax),%edx
f0121cfc:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cff:	89 10                	mov    %edx,(%eax)
f0121d01:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d04:	8b 00                	mov    (%eax),%eax
f0121d06:	83 e8 08             	sub    $0x8,%eax
f0121d09:	8b 50 04             	mov    0x4(%eax),%edx
f0121d0c:	8b 00                	mov    (%eax),%eax
f0121d0e:	eb 38                	jmp    f0121d48 <getint+0x5d>
	else if (lflag)
f0121d10:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121d14:	74 1a                	je     f0121d30 <getint+0x45>
		return va_arg(*ap, long);
f0121d16:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d19:	8b 00                	mov    (%eax),%eax
f0121d1b:	8d 50 04             	lea    0x4(%eax),%edx
f0121d1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d21:	89 10                	mov    %edx,(%eax)
f0121d23:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d26:	8b 00                	mov    (%eax),%eax
f0121d28:	83 e8 04             	sub    $0x4,%eax
f0121d2b:	8b 00                	mov    (%eax),%eax
f0121d2d:	99                   	cltd   
f0121d2e:	eb 18                	jmp    f0121d48 <getint+0x5d>
	else
		return va_arg(*ap, int);
f0121d30:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d33:	8b 00                	mov    (%eax),%eax
f0121d35:	8d 50 04             	lea    0x4(%eax),%edx
f0121d38:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d3b:	89 10                	mov    %edx,(%eax)
f0121d3d:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d40:	8b 00                	mov    (%eax),%eax
f0121d42:	83 e8 04             	sub    $0x4,%eax
f0121d45:	8b 00                	mov    (%eax),%eax
f0121d47:	99                   	cltd   
}
f0121d48:	5d                   	pop    %ebp
f0121d49:	c3                   	ret    

f0121d4a <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f0121d4a:	55                   	push   %ebp
f0121d4b:	89 e5                	mov    %esp,%ebp
f0121d4d:	56                   	push   %esi
f0121d4e:	53                   	push   %ebx
f0121d4f:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f0121d52:	eb 17                	jmp    f0121d6b <vprintfmt+0x21>
			if (ch == '\0')
f0121d54:	85 db                	test   %ebx,%ebx
f0121d56:	0f 84 c1 03 00 00    	je     f012211d <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f0121d5c:	83 ec 08             	sub    $0x8,%esp
f0121d5f:	ff 75 0c             	pushl  0xc(%ebp)
f0121d62:	53                   	push   %ebx
f0121d63:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d66:	ff d0                	call   *%eax
f0121d68:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f0121d6b:	8b 45 10             	mov    0x10(%ebp),%eax
f0121d6e:	8d 50 01             	lea    0x1(%eax),%edx
f0121d71:	89 55 10             	mov    %edx,0x10(%ebp)
f0121d74:	8a 00                	mov    (%eax),%al
f0121d76:	0f b6 d8             	movzbl %al,%ebx
f0121d79:	83 fb 25             	cmp    $0x25,%ebx
f0121d7c:	75 d6                	jne    f0121d54 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f0121d7e:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f0121d82:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f0121d89:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f0121d90:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f0121d97:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f0121d9e:	8b 45 10             	mov    0x10(%ebp),%eax
f0121da1:	8d 50 01             	lea    0x1(%eax),%edx
f0121da4:	89 55 10             	mov    %edx,0x10(%ebp)
f0121da7:	8a 00                	mov    (%eax),%al
f0121da9:	0f b6 d8             	movzbl %al,%ebx
f0121dac:	8d 43 dd             	lea    -0x23(%ebx),%eax
f0121daf:	83 f8 5b             	cmp    $0x5b,%eax
f0121db2:	0f 87 3d 03 00 00    	ja     f01220f5 <vprintfmt+0x3ab>
f0121db8:	8b 04 85 b8 0b 13 f0 	mov    -0xfecf448(,%eax,4),%eax
f0121dbf:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f0121dc1:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f0121dc5:	eb d7                	jmp    f0121d9e <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f0121dc7:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f0121dcb:	eb d1                	jmp    f0121d9e <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f0121dcd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f0121dd4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121dd7:	89 d0                	mov    %edx,%eax
f0121dd9:	c1 e0 02             	shl    $0x2,%eax
f0121ddc:	01 d0                	add    %edx,%eax
f0121dde:	01 c0                	add    %eax,%eax
f0121de0:	01 d8                	add    %ebx,%eax
f0121de2:	83 e8 30             	sub    $0x30,%eax
f0121de5:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f0121de8:	8b 45 10             	mov    0x10(%ebp),%eax
f0121deb:	8a 00                	mov    (%eax),%al
f0121ded:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f0121df0:	83 fb 2f             	cmp    $0x2f,%ebx
f0121df3:	7e 3e                	jle    f0121e33 <vprintfmt+0xe9>
f0121df5:	83 fb 39             	cmp    $0x39,%ebx
f0121df8:	7f 39                	jg     f0121e33 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f0121dfa:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f0121dfd:	eb d5                	jmp    f0121dd4 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f0121dff:	8b 45 14             	mov    0x14(%ebp),%eax
f0121e02:	83 c0 04             	add    $0x4,%eax
f0121e05:	89 45 14             	mov    %eax,0x14(%ebp)
f0121e08:	8b 45 14             	mov    0x14(%ebp),%eax
f0121e0b:	83 e8 04             	sub    $0x4,%eax
f0121e0e:	8b 00                	mov    (%eax),%eax
f0121e10:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f0121e13:	eb 1f                	jmp    f0121e34 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f0121e15:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121e19:	79 83                	jns    f0121d9e <vprintfmt+0x54>
				width = 0;
f0121e1b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f0121e22:	e9 77 ff ff ff       	jmp    f0121d9e <vprintfmt+0x54>

		case '#':
			altflag = 1;
f0121e27:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f0121e2e:	e9 6b ff ff ff       	jmp    f0121d9e <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f0121e33:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f0121e34:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121e38:	0f 89 60 ff ff ff    	jns    f0121d9e <vprintfmt+0x54>
				width = precision, precision = -1;
f0121e3e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121e41:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0121e44:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f0121e4b:	e9 4e ff ff ff       	jmp    f0121d9e <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f0121e50:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f0121e53:	e9 46 ff ff ff       	jmp    f0121d9e <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f0121e58:	8b 45 14             	mov    0x14(%ebp),%eax
f0121e5b:	83 c0 04             	add    $0x4,%eax
f0121e5e:	89 45 14             	mov    %eax,0x14(%ebp)
f0121e61:	8b 45 14             	mov    0x14(%ebp),%eax
f0121e64:	83 e8 04             	sub    $0x4,%eax
f0121e67:	8b 00                	mov    (%eax),%eax
f0121e69:	83 ec 08             	sub    $0x8,%esp
f0121e6c:	ff 75 0c             	pushl  0xc(%ebp)
f0121e6f:	50                   	push   %eax
f0121e70:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e73:	ff d0                	call   *%eax
f0121e75:	83 c4 10             	add    $0x10,%esp
			break;
f0121e78:	e9 9b 02 00 00       	jmp    f0122118 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f0121e7d:	8b 45 14             	mov    0x14(%ebp),%eax
f0121e80:	83 c0 04             	add    $0x4,%eax
f0121e83:	89 45 14             	mov    %eax,0x14(%ebp)
f0121e86:	8b 45 14             	mov    0x14(%ebp),%eax
f0121e89:	83 e8 04             	sub    $0x4,%eax
f0121e8c:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f0121e8e:	85 db                	test   %ebx,%ebx
f0121e90:	79 02                	jns    f0121e94 <vprintfmt+0x14a>
				err = -err;
f0121e92:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f0121e94:	83 fb 64             	cmp    $0x64,%ebx
f0121e97:	7f 0b                	jg     f0121ea4 <vprintfmt+0x15a>
f0121e99:	8b 34 9d 00 0a 13 f0 	mov    -0xfecf600(,%ebx,4),%esi
f0121ea0:	85 f6                	test   %esi,%esi
f0121ea2:	75 19                	jne    f0121ebd <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f0121ea4:	53                   	push   %ebx
f0121ea5:	68 a5 0b 13 f0       	push   $0xf0130ba5
f0121eaa:	ff 75 0c             	pushl  0xc(%ebp)
f0121ead:	ff 75 08             	pushl  0x8(%ebp)
f0121eb0:	e8 70 02 00 00       	call   f0122125 <printfmt>
f0121eb5:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f0121eb8:	e9 5b 02 00 00       	jmp    f0122118 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f0121ebd:	56                   	push   %esi
f0121ebe:	68 ae 0b 13 f0       	push   $0xf0130bae
f0121ec3:	ff 75 0c             	pushl  0xc(%ebp)
f0121ec6:	ff 75 08             	pushl  0x8(%ebp)
f0121ec9:	e8 57 02 00 00       	call   f0122125 <printfmt>
f0121ece:	83 c4 10             	add    $0x10,%esp
			break;
f0121ed1:	e9 42 02 00 00       	jmp    f0122118 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f0121ed6:	8b 45 14             	mov    0x14(%ebp),%eax
f0121ed9:	83 c0 04             	add    $0x4,%eax
f0121edc:	89 45 14             	mov    %eax,0x14(%ebp)
f0121edf:	8b 45 14             	mov    0x14(%ebp),%eax
f0121ee2:	83 e8 04             	sub    $0x4,%eax
f0121ee5:	8b 30                	mov    (%eax),%esi
f0121ee7:	85 f6                	test   %esi,%esi
f0121ee9:	75 05                	jne    f0121ef0 <vprintfmt+0x1a6>
				p = "(null)";
f0121eeb:	be b1 0b 13 f0       	mov    $0xf0130bb1,%esi
			if (width > 0 && padc != '-')
f0121ef0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121ef4:	7e 6d                	jle    f0121f63 <vprintfmt+0x219>
f0121ef6:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f0121efa:	74 67                	je     f0121f63 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f0121efc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121eff:	83 ec 08             	sub    $0x8,%esp
f0121f02:	50                   	push   %eax
f0121f03:	56                   	push   %esi
f0121f04:	e8 26 05 00 00       	call   f012242f <strnlen>
f0121f09:	83 c4 10             	add    $0x10,%esp
f0121f0c:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f0121f0f:	eb 16                	jmp    f0121f27 <vprintfmt+0x1dd>
					putch(padc, putdat);
f0121f11:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f0121f15:	83 ec 08             	sub    $0x8,%esp
f0121f18:	ff 75 0c             	pushl  0xc(%ebp)
f0121f1b:	50                   	push   %eax
f0121f1c:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f1f:	ff d0                	call   *%eax
f0121f21:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f0121f24:	ff 4d e4             	decl   -0x1c(%ebp)
f0121f27:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121f2b:	7f e4                	jg     f0121f11 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f0121f2d:	eb 34                	jmp    f0121f63 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f0121f2f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121f33:	74 1c                	je     f0121f51 <vprintfmt+0x207>
f0121f35:	83 fb 1f             	cmp    $0x1f,%ebx
f0121f38:	7e 05                	jle    f0121f3f <vprintfmt+0x1f5>
f0121f3a:	83 fb 7e             	cmp    $0x7e,%ebx
f0121f3d:	7e 12                	jle    f0121f51 <vprintfmt+0x207>
					putch('?', putdat);
f0121f3f:	83 ec 08             	sub    $0x8,%esp
f0121f42:	ff 75 0c             	pushl  0xc(%ebp)
f0121f45:	6a 3f                	push   $0x3f
f0121f47:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f4a:	ff d0                	call   *%eax
f0121f4c:	83 c4 10             	add    $0x10,%esp
f0121f4f:	eb 0f                	jmp    f0121f60 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f0121f51:	83 ec 08             	sub    $0x8,%esp
f0121f54:	ff 75 0c             	pushl  0xc(%ebp)
f0121f57:	53                   	push   %ebx
f0121f58:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f5b:	ff d0                	call   *%eax
f0121f5d:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f0121f60:	ff 4d e4             	decl   -0x1c(%ebp)
f0121f63:	89 f0                	mov    %esi,%eax
f0121f65:	8d 70 01             	lea    0x1(%eax),%esi
f0121f68:	8a 00                	mov    (%eax),%al
f0121f6a:	0f be d8             	movsbl %al,%ebx
f0121f6d:	85 db                	test   %ebx,%ebx
f0121f6f:	74 24                	je     f0121f95 <vprintfmt+0x24b>
f0121f71:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0121f75:	78 b8                	js     f0121f2f <vprintfmt+0x1e5>
f0121f77:	ff 4d e0             	decl   -0x20(%ebp)
f0121f7a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0121f7e:	79 af                	jns    f0121f2f <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f0121f80:	eb 13                	jmp    f0121f95 <vprintfmt+0x24b>
				putch(' ', putdat);
f0121f82:	83 ec 08             	sub    $0x8,%esp
f0121f85:	ff 75 0c             	pushl  0xc(%ebp)
f0121f88:	6a 20                	push   $0x20
f0121f8a:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f8d:	ff d0                	call   *%eax
f0121f8f:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f0121f92:	ff 4d e4             	decl   -0x1c(%ebp)
f0121f95:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121f99:	7f e7                	jg     f0121f82 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f0121f9b:	e9 78 01 00 00       	jmp    f0122118 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f0121fa0:	83 ec 08             	sub    $0x8,%esp
f0121fa3:	ff 75 e8             	pushl  -0x18(%ebp)
f0121fa6:	8d 45 14             	lea    0x14(%ebp),%eax
f0121fa9:	50                   	push   %eax
f0121faa:	e8 3c fd ff ff       	call   f0121ceb <getint>
f0121faf:	83 c4 10             	add    $0x10,%esp
f0121fb2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121fb5:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f0121fb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121fbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121fbe:	85 d2                	test   %edx,%edx
f0121fc0:	79 23                	jns    f0121fe5 <vprintfmt+0x29b>
				putch('-', putdat);
f0121fc2:	83 ec 08             	sub    $0x8,%esp
f0121fc5:	ff 75 0c             	pushl  0xc(%ebp)
f0121fc8:	6a 2d                	push   $0x2d
f0121fca:	8b 45 08             	mov    0x8(%ebp),%eax
f0121fcd:	ff d0                	call   *%eax
f0121fcf:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f0121fd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121fd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121fd8:	f7 d8                	neg    %eax
f0121fda:	83 d2 00             	adc    $0x0,%edx
f0121fdd:	f7 da                	neg    %edx
f0121fdf:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121fe2:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f0121fe5:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f0121fec:	e9 bc 00 00 00       	jmp    f01220ad <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f0121ff1:	83 ec 08             	sub    $0x8,%esp
f0121ff4:	ff 75 e8             	pushl  -0x18(%ebp)
f0121ff7:	8d 45 14             	lea    0x14(%ebp),%eax
f0121ffa:	50                   	push   %eax
f0121ffb:	e8 84 fc ff ff       	call   f0121c84 <getuint>
f0122000:	83 c4 10             	add    $0x10,%esp
f0122003:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0122006:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f0122009:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f0122010:	e9 98 00 00 00       	jmp    f01220ad <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f0122015:	83 ec 08             	sub    $0x8,%esp
f0122018:	ff 75 0c             	pushl  0xc(%ebp)
f012201b:	6a 58                	push   $0x58
f012201d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122020:	ff d0                	call   *%eax
f0122022:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f0122025:	83 ec 08             	sub    $0x8,%esp
f0122028:	ff 75 0c             	pushl  0xc(%ebp)
f012202b:	6a 58                	push   $0x58
f012202d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122030:	ff d0                	call   *%eax
f0122032:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f0122035:	83 ec 08             	sub    $0x8,%esp
f0122038:	ff 75 0c             	pushl  0xc(%ebp)
f012203b:	6a 58                	push   $0x58
f012203d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122040:	ff d0                	call   *%eax
f0122042:	83 c4 10             	add    $0x10,%esp
			break;
f0122045:	e9 ce 00 00 00       	jmp    f0122118 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f012204a:	83 ec 08             	sub    $0x8,%esp
f012204d:	ff 75 0c             	pushl  0xc(%ebp)
f0122050:	6a 30                	push   $0x30
f0122052:	8b 45 08             	mov    0x8(%ebp),%eax
f0122055:	ff d0                	call   *%eax
f0122057:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f012205a:	83 ec 08             	sub    $0x8,%esp
f012205d:	ff 75 0c             	pushl  0xc(%ebp)
f0122060:	6a 78                	push   $0x78
f0122062:	8b 45 08             	mov    0x8(%ebp),%eax
f0122065:	ff d0                	call   *%eax
f0122067:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f012206a:	8b 45 14             	mov    0x14(%ebp),%eax
f012206d:	83 c0 04             	add    $0x4,%eax
f0122070:	89 45 14             	mov    %eax,0x14(%ebp)
f0122073:	8b 45 14             	mov    0x14(%ebp),%eax
f0122076:	83 e8 04             	sub    $0x4,%eax
f0122079:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f012207b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f012207e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f0122085:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f012208c:	eb 1f                	jmp    f01220ad <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f012208e:	83 ec 08             	sub    $0x8,%esp
f0122091:	ff 75 e8             	pushl  -0x18(%ebp)
f0122094:	8d 45 14             	lea    0x14(%ebp),%eax
f0122097:	50                   	push   %eax
f0122098:	e8 e7 fb ff ff       	call   f0121c84 <getuint>
f012209d:	83 c4 10             	add    $0x10,%esp
f01220a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01220a3:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f01220a6:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f01220ad:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f01220b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01220b4:	83 ec 04             	sub    $0x4,%esp
f01220b7:	52                   	push   %edx
f01220b8:	ff 75 e4             	pushl  -0x1c(%ebp)
f01220bb:	50                   	push   %eax
f01220bc:	ff 75 f4             	pushl  -0xc(%ebp)
f01220bf:	ff 75 f0             	pushl  -0x10(%ebp)
f01220c2:	ff 75 0c             	pushl  0xc(%ebp)
f01220c5:	ff 75 08             	pushl  0x8(%ebp)
f01220c8:	e8 00 fb ff ff       	call   f0121bcd <printnum>
f01220cd:	83 c4 20             	add    $0x20,%esp
			break;
f01220d0:	eb 46                	jmp    f0122118 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f01220d2:	83 ec 08             	sub    $0x8,%esp
f01220d5:	ff 75 0c             	pushl  0xc(%ebp)
f01220d8:	53                   	push   %ebx
f01220d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01220dc:	ff d0                	call   *%eax
f01220de:	83 c4 10             	add    $0x10,%esp
			break;
f01220e1:	eb 35                	jmp    f0122118 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f01220e3:	c6 05 f0 1d 5a f0 00 	movb   $0x0,0xf05a1df0
			break;
f01220ea:	eb 2c                	jmp    f0122118 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f01220ec:	c6 05 f0 1d 5a f0 01 	movb   $0x1,0xf05a1df0
			break;
f01220f3:	eb 23                	jmp    f0122118 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f01220f5:	83 ec 08             	sub    $0x8,%esp
f01220f8:	ff 75 0c             	pushl  0xc(%ebp)
f01220fb:	6a 25                	push   $0x25
f01220fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0122100:	ff d0                	call   *%eax
f0122102:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f0122105:	ff 4d 10             	decl   0x10(%ebp)
f0122108:	eb 03                	jmp    f012210d <vprintfmt+0x3c3>
f012210a:	ff 4d 10             	decl   0x10(%ebp)
f012210d:	8b 45 10             	mov    0x10(%ebp),%eax
f0122110:	48                   	dec    %eax
f0122111:	8a 00                	mov    (%eax),%al
f0122113:	3c 25                	cmp    $0x25,%al
f0122115:	75 f3                	jne    f012210a <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f0122117:	90                   	nop
		}
	}
f0122118:	e9 35 fc ff ff       	jmp    f0121d52 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f012211d:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f012211e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0122121:	5b                   	pop    %ebx
f0122122:	5e                   	pop    %esi
f0122123:	5d                   	pop    %ebp
f0122124:	c3                   	ret    

f0122125 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f0122125:	55                   	push   %ebp
f0122126:	89 e5                	mov    %esp,%ebp
f0122128:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f012212b:	8d 45 10             	lea    0x10(%ebp),%eax
f012212e:	83 c0 04             	add    $0x4,%eax
f0122131:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f0122134:	8b 45 10             	mov    0x10(%ebp),%eax
f0122137:	ff 75 f4             	pushl  -0xc(%ebp)
f012213a:	50                   	push   %eax
f012213b:	ff 75 0c             	pushl  0xc(%ebp)
f012213e:	ff 75 08             	pushl  0x8(%ebp)
f0122141:	e8 04 fc ff ff       	call   f0121d4a <vprintfmt>
f0122146:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f0122149:	90                   	nop
f012214a:	c9                   	leave  
f012214b:	c3                   	ret    

f012214c <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f012214c:	55                   	push   %ebp
f012214d:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f012214f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122152:	8b 40 08             	mov    0x8(%eax),%eax
f0122155:	8d 50 01             	lea    0x1(%eax),%edx
f0122158:	8b 45 0c             	mov    0xc(%ebp),%eax
f012215b:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f012215e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122161:	8b 10                	mov    (%eax),%edx
f0122163:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122166:	8b 40 04             	mov    0x4(%eax),%eax
f0122169:	39 c2                	cmp    %eax,%edx
f012216b:	73 12                	jae    f012217f <sprintputch+0x33>
		*b->buf++ = ch;
f012216d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122170:	8b 00                	mov    (%eax),%eax
f0122172:	8d 48 01             	lea    0x1(%eax),%ecx
f0122175:	8b 55 0c             	mov    0xc(%ebp),%edx
f0122178:	89 0a                	mov    %ecx,(%edx)
f012217a:	8b 55 08             	mov    0x8(%ebp),%edx
f012217d:	88 10                	mov    %dl,(%eax)
}
f012217f:	90                   	nop
f0122180:	5d                   	pop    %ebp
f0122181:	c3                   	ret    

f0122182 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f0122182:	55                   	push   %ebp
f0122183:	89 e5                	mov    %esp,%ebp
f0122185:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f0122188:	8b 45 08             	mov    0x8(%ebp),%eax
f012218b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f012218e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122191:	8d 50 ff             	lea    -0x1(%eax),%edx
f0122194:	8b 45 08             	mov    0x8(%ebp),%eax
f0122197:	01 d0                	add    %edx,%eax
f0122199:	89 45 f0             	mov    %eax,-0x10(%ebp)
f012219c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f01221a3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01221a7:	74 06                	je     f01221af <vsnprintf+0x2d>
f01221a9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01221ad:	7f 07                	jg     f01221b6 <vsnprintf+0x34>
		return -E_INVAL;
f01221af:	b8 03 00 00 00       	mov    $0x3,%eax
f01221b4:	eb 20                	jmp    f01221d6 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f01221b6:	ff 75 14             	pushl  0x14(%ebp)
f01221b9:	ff 75 10             	pushl  0x10(%ebp)
f01221bc:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01221bf:	50                   	push   %eax
f01221c0:	68 4c 21 12 f0       	push   $0xf012214c
f01221c5:	e8 80 fb ff ff       	call   f0121d4a <vprintfmt>
f01221ca:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f01221cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01221d0:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f01221d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01221d6:	c9                   	leave  
f01221d7:	c3                   	ret    

f01221d8 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f01221d8:	55                   	push   %ebp
f01221d9:	89 e5                	mov    %esp,%ebp
f01221db:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f01221de:	8d 45 10             	lea    0x10(%ebp),%eax
f01221e1:	83 c0 04             	add    $0x4,%eax
f01221e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f01221e7:	8b 45 10             	mov    0x10(%ebp),%eax
f01221ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01221ed:	50                   	push   %eax
f01221ee:	ff 75 0c             	pushl  0xc(%ebp)
f01221f1:	ff 75 08             	pushl  0x8(%ebp)
f01221f4:	e8 89 ff ff ff       	call   f0122182 <vsnprintf>
f01221f9:	83 c4 10             	add    $0x10,%esp
f01221fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f01221ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0122202:	c9                   	leave  
f0122203:	c3                   	ret    

f0122204 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f0122204:	55                   	push   %ebp
f0122205:	89 e5                	mov    %esp,%ebp
f0122207:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f012220a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012220e:	74 13                	je     f0122223 <readline+0x1f>
		cprintf("%s", prompt);
f0122210:	83 ec 08             	sub    $0x8,%esp
f0122213:	ff 75 08             	pushl  0x8(%ebp)
f0122216:	68 28 0d 13 f0       	push   $0xf0130d28
f012221b:	e8 4c ed fd ff       	call   f0100f6c <cprintf>
f0122220:	83 c4 10             	add    $0x10,%esp

	i = 0;
f0122223:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f012222a:	83 ec 0c             	sub    $0xc,%esp
f012222d:	6a 00                	push   $0x0
f012222f:	e8 45 ec fd ff       	call   f0100e79 <iscons>
f0122234:	83 c4 10             	add    $0x10,%esp
f0122237:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f012223a:	e8 21 ec fd ff       	call   f0100e60 <getchar>
f012223f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f0122242:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0122246:	79 22                	jns    f012226a <readline+0x66>
			if (c != -E_EOF)
f0122248:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f012224c:	0f 84 ad 00 00 00    	je     f01222ff <readline+0xfb>
				cprintf("read error: %e\n", c);
f0122252:	83 ec 08             	sub    $0x8,%esp
f0122255:	ff 75 ec             	pushl  -0x14(%ebp)
f0122258:	68 2b 0d 13 f0       	push   $0xf0130d2b
f012225d:	e8 0a ed fd ff       	call   f0100f6c <cprintf>
f0122262:	83 c4 10             	add    $0x10,%esp
			break;
f0122265:	e9 95 00 00 00       	jmp    f01222ff <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f012226a:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f012226e:	7e 34                	jle    f01222a4 <readline+0xa0>
f0122270:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f0122277:	7f 2b                	jg     f01222a4 <readline+0xa0>
			if (echoing)
f0122279:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012227d:	74 0e                	je     f012228d <readline+0x89>
				cputchar(c);
f012227f:	83 ec 0c             	sub    $0xc,%esp
f0122282:	ff 75 ec             	pushl  -0x14(%ebp)
f0122285:	e8 bf eb fd ff       	call   f0100e49 <cputchar>
f012228a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f012228d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122290:	8d 50 01             	lea    0x1(%eax),%edx
f0122293:	89 55 f4             	mov    %edx,-0xc(%ebp)
f0122296:	89 c2                	mov    %eax,%edx
f0122298:	8b 45 0c             	mov    0xc(%ebp),%eax
f012229b:	01 d0                	add    %edx,%eax
f012229d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01222a0:	88 10                	mov    %dl,(%eax)
f01222a2:	eb 56                	jmp    f01222fa <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f01222a4:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f01222a8:	75 1f                	jne    f01222c9 <readline+0xc5>
f01222aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01222ae:	7e 19                	jle    f01222c9 <readline+0xc5>
			if (echoing)
f01222b0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01222b4:	74 0e                	je     f01222c4 <readline+0xc0>
				cputchar(c);
f01222b6:	83 ec 0c             	sub    $0xc,%esp
f01222b9:	ff 75 ec             	pushl  -0x14(%ebp)
f01222bc:	e8 88 eb fd ff       	call   f0100e49 <cputchar>
f01222c1:	83 c4 10             	add    $0x10,%esp

			i--;
f01222c4:	ff 4d f4             	decl   -0xc(%ebp)
f01222c7:	eb 31                	jmp    f01222fa <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f01222c9:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f01222cd:	74 0a                	je     f01222d9 <readline+0xd5>
f01222cf:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f01222d3:	0f 85 61 ff ff ff    	jne    f012223a <readline+0x36>
			if (echoing)
f01222d9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01222dd:	74 0e                	je     f01222ed <readline+0xe9>
				cputchar(c);
f01222df:	83 ec 0c             	sub    $0xc,%esp
f01222e2:	ff 75 ec             	pushl  -0x14(%ebp)
f01222e5:	e8 5f eb fd ff       	call   f0100e49 <cputchar>
f01222ea:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f01222ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01222f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01222f3:	01 d0                	add    %edx,%eax
f01222f5:	c6 00 00             	movb   $0x0,(%eax)
			break;
f01222f8:	eb 06                	jmp    f0122300 <readline+0xfc>
		}
	}
f01222fa:	e9 3b ff ff ff       	jmp    f012223a <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f01222ff:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f0122300:	90                   	nop
f0122301:	c9                   	leave  
f0122302:	c3                   	ret    

f0122303 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f0122303:	55                   	push   %ebp
f0122304:	89 e5                	mov    %esp,%ebp
f0122306:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f0122309:	e8 57 b5 fe ff       	call   f010d865 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f012230e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122312:	74 13                	je     f0122327 <atomic_readline+0x24>
			cprintf("%s", prompt);
f0122314:	83 ec 08             	sub    $0x8,%esp
f0122317:	ff 75 08             	pushl  0x8(%ebp)
f012231a:	68 28 0d 13 f0       	push   $0xf0130d28
f012231f:	e8 48 ec fd ff       	call   f0100f6c <cprintf>
f0122324:	83 c4 10             	add    $0x10,%esp

		i = 0;
f0122327:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f012232e:	83 ec 0c             	sub    $0xc,%esp
f0122331:	6a 00                	push   $0x0
f0122333:	e8 41 eb fd ff       	call   f0100e79 <iscons>
f0122338:	83 c4 10             	add    $0x10,%esp
f012233b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f012233e:	e8 1d eb fd ff       	call   f0100e60 <getchar>
f0122343:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f0122346:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012234a:	79 22                	jns    f012236e <atomic_readline+0x6b>
				if (c != -E_EOF)
f012234c:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f0122350:	0f 84 ad 00 00 00    	je     f0122403 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f0122356:	83 ec 08             	sub    $0x8,%esp
f0122359:	ff 75 ec             	pushl  -0x14(%ebp)
f012235c:	68 2b 0d 13 f0       	push   $0xf0130d2b
f0122361:	e8 06 ec fd ff       	call   f0100f6c <cprintf>
f0122366:	83 c4 10             	add    $0x10,%esp
				break;
f0122369:	e9 95 00 00 00       	jmp    f0122403 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f012236e:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f0122372:	7e 34                	jle    f01223a8 <atomic_readline+0xa5>
f0122374:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f012237b:	7f 2b                	jg     f01223a8 <atomic_readline+0xa5>
				if (echoing)
f012237d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0122381:	74 0e                	je     f0122391 <atomic_readline+0x8e>
					cputchar(c);
f0122383:	83 ec 0c             	sub    $0xc,%esp
f0122386:	ff 75 ec             	pushl  -0x14(%ebp)
f0122389:	e8 bb ea fd ff       	call   f0100e49 <cputchar>
f012238e:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f0122391:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122394:	8d 50 01             	lea    0x1(%eax),%edx
f0122397:	89 55 f4             	mov    %edx,-0xc(%ebp)
f012239a:	89 c2                	mov    %eax,%edx
f012239c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012239f:	01 d0                	add    %edx,%eax
f01223a1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01223a4:	88 10                	mov    %dl,(%eax)
f01223a6:	eb 56                	jmp    f01223fe <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f01223a8:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f01223ac:	75 1f                	jne    f01223cd <atomic_readline+0xca>
f01223ae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01223b2:	7e 19                	jle    f01223cd <atomic_readline+0xca>
				if (echoing)
f01223b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01223b8:	74 0e                	je     f01223c8 <atomic_readline+0xc5>
					cputchar(c);
f01223ba:	83 ec 0c             	sub    $0xc,%esp
f01223bd:	ff 75 ec             	pushl  -0x14(%ebp)
f01223c0:	e8 84 ea fd ff       	call   f0100e49 <cputchar>
f01223c5:	83 c4 10             	add    $0x10,%esp
				i--;
f01223c8:	ff 4d f4             	decl   -0xc(%ebp)
f01223cb:	eb 31                	jmp    f01223fe <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f01223cd:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f01223d1:	74 0a                	je     f01223dd <atomic_readline+0xda>
f01223d3:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f01223d7:	0f 85 61 ff ff ff    	jne    f012233e <atomic_readline+0x3b>
				if (echoing)
f01223dd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01223e1:	74 0e                	je     f01223f1 <atomic_readline+0xee>
					cputchar(c);
f01223e3:	83 ec 0c             	sub    $0xc,%esp
f01223e6:	ff 75 ec             	pushl  -0x14(%ebp)
f01223e9:	e8 5b ea fd ff       	call   f0100e49 <cputchar>
f01223ee:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f01223f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01223f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01223f7:	01 d0                	add    %edx,%eax
f01223f9:	c6 00 00             	movb   $0x0,(%eax)
				break;
f01223fc:	eb 06                	jmp    f0122404 <atomic_readline+0x101>
			}
		}
f01223fe:	e9 3b ff ff ff       	jmp    f012233e <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f0122403:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f0122404:	e8 6a b4 fe ff       	call   f010d873 <sys_unlock_cons>
}
f0122409:	90                   	nop
f012240a:	c9                   	leave  
f012240b:	c3                   	ret    

f012240c <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f012240c:	55                   	push   %ebp
f012240d:	89 e5                	mov    %esp,%ebp
f012240f:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f0122412:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0122419:	eb 06                	jmp    f0122421 <strlen+0x15>
		n++;
f012241b:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f012241e:	ff 45 08             	incl   0x8(%ebp)
f0122421:	8b 45 08             	mov    0x8(%ebp),%eax
f0122424:	8a 00                	mov    (%eax),%al
f0122426:	84 c0                	test   %al,%al
f0122428:	75 f1                	jne    f012241b <strlen+0xf>
		n++;
	return n;
f012242a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f012242d:	c9                   	leave  
f012242e:	c3                   	ret    

f012242f <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f012242f:	55                   	push   %ebp
f0122430:	89 e5                	mov    %esp,%ebp
f0122432:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f0122435:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f012243c:	eb 09                	jmp    f0122447 <strnlen+0x18>
		n++;
f012243e:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f0122441:	ff 45 08             	incl   0x8(%ebp)
f0122444:	ff 4d 0c             	decl   0xc(%ebp)
f0122447:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012244b:	74 09                	je     f0122456 <strnlen+0x27>
f012244d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122450:	8a 00                	mov    (%eax),%al
f0122452:	84 c0                	test   %al,%al
f0122454:	75 e8                	jne    f012243e <strnlen+0xf>
		n++;
	return n;
f0122456:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0122459:	c9                   	leave  
f012245a:	c3                   	ret    

f012245b <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f012245b:	55                   	push   %ebp
f012245c:	89 e5                	mov    %esp,%ebp
f012245e:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f0122461:	8b 45 08             	mov    0x8(%ebp),%eax
f0122464:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f0122467:	90                   	nop
f0122468:	8b 45 08             	mov    0x8(%ebp),%eax
f012246b:	8d 50 01             	lea    0x1(%eax),%edx
f012246e:	89 55 08             	mov    %edx,0x8(%ebp)
f0122471:	8b 55 0c             	mov    0xc(%ebp),%edx
f0122474:	8d 4a 01             	lea    0x1(%edx),%ecx
f0122477:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f012247a:	8a 12                	mov    (%edx),%dl
f012247c:	88 10                	mov    %dl,(%eax)
f012247e:	8a 00                	mov    (%eax),%al
f0122480:	84 c0                	test   %al,%al
f0122482:	75 e4                	jne    f0122468 <strcpy+0xd>
		/* do nothing */;
	return ret;
f0122484:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0122487:	c9                   	leave  
f0122488:	c3                   	ret    

f0122489 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f0122489:	55                   	push   %ebp
f012248a:	89 e5                	mov    %esp,%ebp
f012248c:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f012248f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122492:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f0122495:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f012249c:	eb 1f                	jmp    f01224bd <strncpy+0x34>
		*dst++ = *src;
f012249e:	8b 45 08             	mov    0x8(%ebp),%eax
f01224a1:	8d 50 01             	lea    0x1(%eax),%edx
f01224a4:	89 55 08             	mov    %edx,0x8(%ebp)
f01224a7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01224aa:	8a 12                	mov    (%edx),%dl
f01224ac:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f01224ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01224b1:	8a 00                	mov    (%eax),%al
f01224b3:	84 c0                	test   %al,%al
f01224b5:	74 03                	je     f01224ba <strncpy+0x31>
			src++;
f01224b7:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f01224ba:	ff 45 fc             	incl   -0x4(%ebp)
f01224bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01224c0:	3b 45 10             	cmp    0x10(%ebp),%eax
f01224c3:	72 d9                	jb     f012249e <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f01224c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f01224c8:	c9                   	leave  
f01224c9:	c3                   	ret    

f01224ca <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f01224ca:	55                   	push   %ebp
f01224cb:	89 e5                	mov    %esp,%ebp
f01224cd:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f01224d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01224d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f01224d6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01224da:	74 30                	je     f012250c <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f01224dc:	eb 16                	jmp    f01224f4 <strlcpy+0x2a>
			*dst++ = *src++;
f01224de:	8b 45 08             	mov    0x8(%ebp),%eax
f01224e1:	8d 50 01             	lea    0x1(%eax),%edx
f01224e4:	89 55 08             	mov    %edx,0x8(%ebp)
f01224e7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01224ea:	8d 4a 01             	lea    0x1(%edx),%ecx
f01224ed:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f01224f0:	8a 12                	mov    (%edx),%dl
f01224f2:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f01224f4:	ff 4d 10             	decl   0x10(%ebp)
f01224f7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01224fb:	74 09                	je     f0122506 <strlcpy+0x3c>
f01224fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122500:	8a 00                	mov    (%eax),%al
f0122502:	84 c0                	test   %al,%al
f0122504:	75 d8                	jne    f01224de <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f0122506:	8b 45 08             	mov    0x8(%ebp),%eax
f0122509:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f012250c:	8b 55 08             	mov    0x8(%ebp),%edx
f012250f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122512:	29 c2                	sub    %eax,%edx
f0122514:	89 d0                	mov    %edx,%eax
}
f0122516:	c9                   	leave  
f0122517:	c3                   	ret    

f0122518 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f0122518:	55                   	push   %ebp
f0122519:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f012251b:	eb 06                	jmp    f0122523 <strcmp+0xb>
		p++, q++;
f012251d:	ff 45 08             	incl   0x8(%ebp)
f0122520:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f0122523:	8b 45 08             	mov    0x8(%ebp),%eax
f0122526:	8a 00                	mov    (%eax),%al
f0122528:	84 c0                	test   %al,%al
f012252a:	74 0e                	je     f012253a <strcmp+0x22>
f012252c:	8b 45 08             	mov    0x8(%ebp),%eax
f012252f:	8a 10                	mov    (%eax),%dl
f0122531:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122534:	8a 00                	mov    (%eax),%al
f0122536:	38 c2                	cmp    %al,%dl
f0122538:	74 e3                	je     f012251d <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f012253a:	8b 45 08             	mov    0x8(%ebp),%eax
f012253d:	8a 00                	mov    (%eax),%al
f012253f:	0f b6 d0             	movzbl %al,%edx
f0122542:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122545:	8a 00                	mov    (%eax),%al
f0122547:	0f b6 c0             	movzbl %al,%eax
f012254a:	29 c2                	sub    %eax,%edx
f012254c:	89 d0                	mov    %edx,%eax
}
f012254e:	5d                   	pop    %ebp
f012254f:	c3                   	ret    

f0122550 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f0122550:	55                   	push   %ebp
f0122551:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f0122553:	eb 09                	jmp    f012255e <strncmp+0xe>
		n--, p++, q++;
f0122555:	ff 4d 10             	decl   0x10(%ebp)
f0122558:	ff 45 08             	incl   0x8(%ebp)
f012255b:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f012255e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122562:	74 17                	je     f012257b <strncmp+0x2b>
f0122564:	8b 45 08             	mov    0x8(%ebp),%eax
f0122567:	8a 00                	mov    (%eax),%al
f0122569:	84 c0                	test   %al,%al
f012256b:	74 0e                	je     f012257b <strncmp+0x2b>
f012256d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122570:	8a 10                	mov    (%eax),%dl
f0122572:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122575:	8a 00                	mov    (%eax),%al
f0122577:	38 c2                	cmp    %al,%dl
f0122579:	74 da                	je     f0122555 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f012257b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012257f:	75 07                	jne    f0122588 <strncmp+0x38>
		return 0;
f0122581:	b8 00 00 00 00       	mov    $0x0,%eax
f0122586:	eb 14                	jmp    f012259c <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f0122588:	8b 45 08             	mov    0x8(%ebp),%eax
f012258b:	8a 00                	mov    (%eax),%al
f012258d:	0f b6 d0             	movzbl %al,%edx
f0122590:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122593:	8a 00                	mov    (%eax),%al
f0122595:	0f b6 c0             	movzbl %al,%eax
f0122598:	29 c2                	sub    %eax,%edx
f012259a:	89 d0                	mov    %edx,%eax
}
f012259c:	5d                   	pop    %ebp
f012259d:	c3                   	ret    

f012259e <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f012259e:	55                   	push   %ebp
f012259f:	89 e5                	mov    %esp,%ebp
f01225a1:	83 ec 04             	sub    $0x4,%esp
f01225a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01225a7:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f01225aa:	eb 12                	jmp    f01225be <strchr+0x20>
		if (*s == c)
f01225ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01225af:	8a 00                	mov    (%eax),%al
f01225b1:	3a 45 fc             	cmp    -0x4(%ebp),%al
f01225b4:	75 05                	jne    f01225bb <strchr+0x1d>
			return (char *) s;
f01225b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01225b9:	eb 11                	jmp    f01225cc <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f01225bb:	ff 45 08             	incl   0x8(%ebp)
f01225be:	8b 45 08             	mov    0x8(%ebp),%eax
f01225c1:	8a 00                	mov    (%eax),%al
f01225c3:	84 c0                	test   %al,%al
f01225c5:	75 e5                	jne    f01225ac <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f01225c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01225cc:	c9                   	leave  
f01225cd:	c3                   	ret    

f01225ce <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f01225ce:	55                   	push   %ebp
f01225cf:	89 e5                	mov    %esp,%ebp
f01225d1:	83 ec 04             	sub    $0x4,%esp
f01225d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01225d7:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f01225da:	eb 0d                	jmp    f01225e9 <strfind+0x1b>
		if (*s == c)
f01225dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01225df:	8a 00                	mov    (%eax),%al
f01225e1:	3a 45 fc             	cmp    -0x4(%ebp),%al
f01225e4:	74 0e                	je     f01225f4 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f01225e6:	ff 45 08             	incl   0x8(%ebp)
f01225e9:	8b 45 08             	mov    0x8(%ebp),%eax
f01225ec:	8a 00                	mov    (%eax),%al
f01225ee:	84 c0                	test   %al,%al
f01225f0:	75 ea                	jne    f01225dc <strfind+0xe>
f01225f2:	eb 01                	jmp    f01225f5 <strfind+0x27>
		if (*s == c)
			break;
f01225f4:	90                   	nop
	return (char *) s;
f01225f5:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01225f8:	c9                   	leave  
f01225f9:	c3                   	ret    

f01225fa <memset>:


void *
memset(void *v, int c, uint32 n)
{
f01225fa:	55                   	push   %ebp
f01225fb:	89 e5                	mov    %esp,%ebp
f01225fd:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f0122600:	8b 45 08             	mov    0x8(%ebp),%eax
f0122603:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f0122606:	8b 45 10             	mov    0x10(%ebp),%eax
f0122609:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f012260c:	eb 0e                	jmp    f012261c <memset+0x22>
		*p++ = c;
f012260e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122611:	8d 50 01             	lea    0x1(%eax),%edx
f0122614:	89 55 fc             	mov    %edx,-0x4(%ebp)
f0122617:	8b 55 0c             	mov    0xc(%ebp),%edx
f012261a:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f012261c:	ff 4d f8             	decl   -0x8(%ebp)
f012261f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f0122623:	79 e9                	jns    f012260e <memset+0x14>
		*p++ = c;

	return v;
f0122625:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0122628:	c9                   	leave  
f0122629:	c3                   	ret    

f012262a <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f012262a:	55                   	push   %ebp
f012262b:	89 e5                	mov    %esp,%ebp
f012262d:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f0122630:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122633:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f0122636:	8b 45 08             	mov    0x8(%ebp),%eax
f0122639:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f012263c:	eb 16                	jmp    f0122654 <memcpy+0x2a>
		*d++ = *s++;
f012263e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0122641:	8d 50 01             	lea    0x1(%eax),%edx
f0122644:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0122647:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012264a:	8d 4a 01             	lea    0x1(%edx),%ecx
f012264d:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f0122650:	8a 12                	mov    (%edx),%dl
f0122652:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f0122654:	8b 45 10             	mov    0x10(%ebp),%eax
f0122657:	8d 50 ff             	lea    -0x1(%eax),%edx
f012265a:	89 55 10             	mov    %edx,0x10(%ebp)
f012265d:	85 c0                	test   %eax,%eax
f012265f:	75 dd                	jne    f012263e <memcpy+0x14>
		*d++ = *s++;

	return dst;
f0122661:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0122664:	c9                   	leave  
f0122665:	c3                   	ret    

f0122666 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f0122666:	55                   	push   %ebp
f0122667:	89 e5                	mov    %esp,%ebp
f0122669:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f012266c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012266f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f0122672:	8b 45 08             	mov    0x8(%ebp),%eax
f0122675:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f0122678:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012267b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f012267e:	73 50                	jae    f01226d0 <memmove+0x6a>
f0122680:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0122683:	8b 45 10             	mov    0x10(%ebp),%eax
f0122686:	01 d0                	add    %edx,%eax
f0122688:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f012268b:	76 43                	jbe    f01226d0 <memmove+0x6a>
		s += n;
f012268d:	8b 45 10             	mov    0x10(%ebp),%eax
f0122690:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f0122693:	8b 45 10             	mov    0x10(%ebp),%eax
f0122696:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f0122699:	eb 10                	jmp    f01226ab <memmove+0x45>
			*--d = *--s;
f012269b:	ff 4d f8             	decl   -0x8(%ebp)
f012269e:	ff 4d fc             	decl   -0x4(%ebp)
f01226a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01226a4:	8a 10                	mov    (%eax),%dl
f01226a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01226a9:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f01226ab:	8b 45 10             	mov    0x10(%ebp),%eax
f01226ae:	8d 50 ff             	lea    -0x1(%eax),%edx
f01226b1:	89 55 10             	mov    %edx,0x10(%ebp)
f01226b4:	85 c0                	test   %eax,%eax
f01226b6:	75 e3                	jne    f012269b <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f01226b8:	eb 23                	jmp    f01226dd <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f01226ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01226bd:	8d 50 01             	lea    0x1(%eax),%edx
f01226c0:	89 55 f8             	mov    %edx,-0x8(%ebp)
f01226c3:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01226c6:	8d 4a 01             	lea    0x1(%edx),%ecx
f01226c9:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f01226cc:	8a 12                	mov    (%edx),%dl
f01226ce:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f01226d0:	8b 45 10             	mov    0x10(%ebp),%eax
f01226d3:	8d 50 ff             	lea    -0x1(%eax),%edx
f01226d6:	89 55 10             	mov    %edx,0x10(%ebp)
f01226d9:	85 c0                	test   %eax,%eax
f01226db:	75 dd                	jne    f01226ba <memmove+0x54>
			*d++ = *s++;

	return dst;
f01226dd:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01226e0:	c9                   	leave  
f01226e1:	c3                   	ret    

f01226e2 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f01226e2:	55                   	push   %ebp
f01226e3:	89 e5                	mov    %esp,%ebp
f01226e5:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f01226e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01226eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f01226ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f01226f1:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f01226f4:	eb 2a                	jmp    f0122720 <memcmp+0x3e>
		if (*s1 != *s2)
f01226f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01226f9:	8a 10                	mov    (%eax),%dl
f01226fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01226fe:	8a 00                	mov    (%eax),%al
f0122700:	38 c2                	cmp    %al,%dl
f0122702:	74 16                	je     f012271a <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f0122704:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122707:	8a 00                	mov    (%eax),%al
f0122709:	0f b6 d0             	movzbl %al,%edx
f012270c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012270f:	8a 00                	mov    (%eax),%al
f0122711:	0f b6 c0             	movzbl %al,%eax
f0122714:	29 c2                	sub    %eax,%edx
f0122716:	89 d0                	mov    %edx,%eax
f0122718:	eb 18                	jmp    f0122732 <memcmp+0x50>
		s1++, s2++;
f012271a:	ff 45 fc             	incl   -0x4(%ebp)
f012271d:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f0122720:	8b 45 10             	mov    0x10(%ebp),%eax
f0122723:	8d 50 ff             	lea    -0x1(%eax),%edx
f0122726:	89 55 10             	mov    %edx,0x10(%ebp)
f0122729:	85 c0                	test   %eax,%eax
f012272b:	75 c9                	jne    f01226f6 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f012272d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0122732:	c9                   	leave  
f0122733:	c3                   	ret    

f0122734 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f0122734:	55                   	push   %ebp
f0122735:	89 e5                	mov    %esp,%ebp
f0122737:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f012273a:	8b 55 08             	mov    0x8(%ebp),%edx
f012273d:	8b 45 10             	mov    0x10(%ebp),%eax
f0122740:	01 d0                	add    %edx,%eax
f0122742:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f0122745:	eb 15                	jmp    f012275c <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f0122747:	8b 45 08             	mov    0x8(%ebp),%eax
f012274a:	8a 00                	mov    (%eax),%al
f012274c:	0f b6 d0             	movzbl %al,%edx
f012274f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122752:	0f b6 c0             	movzbl %al,%eax
f0122755:	39 c2                	cmp    %eax,%edx
f0122757:	74 0d                	je     f0122766 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f0122759:	ff 45 08             	incl   0x8(%ebp)
f012275c:	8b 45 08             	mov    0x8(%ebp),%eax
f012275f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f0122762:	72 e3                	jb     f0122747 <memfind+0x13>
f0122764:	eb 01                	jmp    f0122767 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f0122766:	90                   	nop
	return (void *) s;
f0122767:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012276a:	c9                   	leave  
f012276b:	c3                   	ret    

f012276c <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f012276c:	55                   	push   %ebp
f012276d:	89 e5                	mov    %esp,%ebp
f012276f:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f0122772:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f0122779:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f0122780:	eb 03                	jmp    f0122785 <strtol+0x19>
		s++;
f0122782:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f0122785:	8b 45 08             	mov    0x8(%ebp),%eax
f0122788:	8a 00                	mov    (%eax),%al
f012278a:	3c 20                	cmp    $0x20,%al
f012278c:	74 f4                	je     f0122782 <strtol+0x16>
f012278e:	8b 45 08             	mov    0x8(%ebp),%eax
f0122791:	8a 00                	mov    (%eax),%al
f0122793:	3c 09                	cmp    $0x9,%al
f0122795:	74 eb                	je     f0122782 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f0122797:	8b 45 08             	mov    0x8(%ebp),%eax
f012279a:	8a 00                	mov    (%eax),%al
f012279c:	3c 2b                	cmp    $0x2b,%al
f012279e:	75 05                	jne    f01227a5 <strtol+0x39>
		s++;
f01227a0:	ff 45 08             	incl   0x8(%ebp)
f01227a3:	eb 13                	jmp    f01227b8 <strtol+0x4c>
	else if (*s == '-')
f01227a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01227a8:	8a 00                	mov    (%eax),%al
f01227aa:	3c 2d                	cmp    $0x2d,%al
f01227ac:	75 0a                	jne    f01227b8 <strtol+0x4c>
		s++, neg = 1;
f01227ae:	ff 45 08             	incl   0x8(%ebp)
f01227b1:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f01227b8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01227bc:	74 06                	je     f01227c4 <strtol+0x58>
f01227be:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f01227c2:	75 20                	jne    f01227e4 <strtol+0x78>
f01227c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01227c7:	8a 00                	mov    (%eax),%al
f01227c9:	3c 30                	cmp    $0x30,%al
f01227cb:	75 17                	jne    f01227e4 <strtol+0x78>
f01227cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01227d0:	40                   	inc    %eax
f01227d1:	8a 00                	mov    (%eax),%al
f01227d3:	3c 78                	cmp    $0x78,%al
f01227d5:	75 0d                	jne    f01227e4 <strtol+0x78>
		s += 2, base = 16;
f01227d7:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f01227db:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f01227e2:	eb 28                	jmp    f012280c <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f01227e4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01227e8:	75 15                	jne    f01227ff <strtol+0x93>
f01227ea:	8b 45 08             	mov    0x8(%ebp),%eax
f01227ed:	8a 00                	mov    (%eax),%al
f01227ef:	3c 30                	cmp    $0x30,%al
f01227f1:	75 0c                	jne    f01227ff <strtol+0x93>
		s++, base = 8;
f01227f3:	ff 45 08             	incl   0x8(%ebp)
f01227f6:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f01227fd:	eb 0d                	jmp    f012280c <strtol+0xa0>
	else if (base == 0)
f01227ff:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122803:	75 07                	jne    f012280c <strtol+0xa0>
		base = 10;
f0122805:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f012280c:	8b 45 08             	mov    0x8(%ebp),%eax
f012280f:	8a 00                	mov    (%eax),%al
f0122811:	3c 2f                	cmp    $0x2f,%al
f0122813:	7e 19                	jle    f012282e <strtol+0xc2>
f0122815:	8b 45 08             	mov    0x8(%ebp),%eax
f0122818:	8a 00                	mov    (%eax),%al
f012281a:	3c 39                	cmp    $0x39,%al
f012281c:	7f 10                	jg     f012282e <strtol+0xc2>
			dig = *s - '0';
f012281e:	8b 45 08             	mov    0x8(%ebp),%eax
f0122821:	8a 00                	mov    (%eax),%al
f0122823:	0f be c0             	movsbl %al,%eax
f0122826:	83 e8 30             	sub    $0x30,%eax
f0122829:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012282c:	eb 42                	jmp    f0122870 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f012282e:	8b 45 08             	mov    0x8(%ebp),%eax
f0122831:	8a 00                	mov    (%eax),%al
f0122833:	3c 60                	cmp    $0x60,%al
f0122835:	7e 19                	jle    f0122850 <strtol+0xe4>
f0122837:	8b 45 08             	mov    0x8(%ebp),%eax
f012283a:	8a 00                	mov    (%eax),%al
f012283c:	3c 7a                	cmp    $0x7a,%al
f012283e:	7f 10                	jg     f0122850 <strtol+0xe4>
			dig = *s - 'a' + 10;
f0122840:	8b 45 08             	mov    0x8(%ebp),%eax
f0122843:	8a 00                	mov    (%eax),%al
f0122845:	0f be c0             	movsbl %al,%eax
f0122848:	83 e8 57             	sub    $0x57,%eax
f012284b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012284e:	eb 20                	jmp    f0122870 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f0122850:	8b 45 08             	mov    0x8(%ebp),%eax
f0122853:	8a 00                	mov    (%eax),%al
f0122855:	3c 40                	cmp    $0x40,%al
f0122857:	7e 39                	jle    f0122892 <strtol+0x126>
f0122859:	8b 45 08             	mov    0x8(%ebp),%eax
f012285c:	8a 00                	mov    (%eax),%al
f012285e:	3c 5a                	cmp    $0x5a,%al
f0122860:	7f 30                	jg     f0122892 <strtol+0x126>
			dig = *s - 'A' + 10;
f0122862:	8b 45 08             	mov    0x8(%ebp),%eax
f0122865:	8a 00                	mov    (%eax),%al
f0122867:	0f be c0             	movsbl %al,%eax
f012286a:	83 e8 37             	sub    $0x37,%eax
f012286d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f0122870:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122873:	3b 45 10             	cmp    0x10(%ebp),%eax
f0122876:	7d 19                	jge    f0122891 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f0122878:	ff 45 08             	incl   0x8(%ebp)
f012287b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012287e:	0f af 45 10          	imul   0x10(%ebp),%eax
f0122882:	89 c2                	mov    %eax,%edx
f0122884:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122887:	01 d0                	add    %edx,%eax
f0122889:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f012288c:	e9 7b ff ff ff       	jmp    f012280c <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f0122891:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f0122892:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0122896:	74 08                	je     f01228a0 <strtol+0x134>
		*endptr = (char *) s;
f0122898:	8b 45 0c             	mov    0xc(%ebp),%eax
f012289b:	8b 55 08             	mov    0x8(%ebp),%edx
f012289e:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f01228a0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01228a4:	74 07                	je     f01228ad <strtol+0x141>
f01228a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01228a9:	f7 d8                	neg    %eax
f01228ab:	eb 03                	jmp    f01228b0 <strtol+0x144>
f01228ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f01228b0:	c9                   	leave  
f01228b1:	c3                   	ret    

f01228b2 <ltostr>:

void
ltostr(long value, char *str)
{
f01228b2:	55                   	push   %ebp
f01228b3:	89 e5                	mov    %esp,%ebp
f01228b5:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f01228b8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f01228bf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f01228c6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01228ca:	79 13                	jns    f01228df <ltostr+0x2d>
	{
		neg = 1;
f01228cc:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f01228d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01228d6:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f01228d9:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f01228dc:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f01228df:	8b 45 08             	mov    0x8(%ebp),%eax
f01228e2:	b9 0a 00 00 00       	mov    $0xa,%ecx
f01228e7:	99                   	cltd   
f01228e8:	f7 f9                	idiv   %ecx
f01228ea:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f01228ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01228f0:	8d 50 01             	lea    0x1(%eax),%edx
f01228f3:	89 55 f8             	mov    %edx,-0x8(%ebp)
f01228f6:	89 c2                	mov    %eax,%edx
f01228f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01228fb:	01 d0                	add    %edx,%eax
f01228fd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122900:	83 c2 30             	add    $0x30,%edx
f0122903:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f0122905:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0122908:	b8 67 66 66 66       	mov    $0x66666667,%eax
f012290d:	f7 e9                	imul   %ecx
f012290f:	c1 fa 02             	sar    $0x2,%edx
f0122912:	89 c8                	mov    %ecx,%eax
f0122914:	c1 f8 1f             	sar    $0x1f,%eax
f0122917:	29 c2                	sub    %eax,%edx
f0122919:	89 d0                	mov    %edx,%eax
f012291b:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f012291e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122922:	75 bb                	jne    f01228df <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f0122924:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f012292b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012292e:	48                   	dec    %eax
f012292f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f0122932:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0122936:	74 3d                	je     f0122975 <ltostr+0xc3>
		start = 1 ;
f0122938:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f012293f:	eb 34                	jmp    f0122975 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f0122941:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122944:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122947:	01 d0                	add    %edx,%eax
f0122949:	8a 00                	mov    (%eax),%al
f012294b:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f012294e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122951:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122954:	01 c2                	add    %eax,%edx
f0122956:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0122959:	8b 45 0c             	mov    0xc(%ebp),%eax
f012295c:	01 c8                	add    %ecx,%eax
f012295e:	8a 00                	mov    (%eax),%al
f0122960:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f0122962:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0122965:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122968:	01 c2                	add    %eax,%edx
f012296a:	8a 45 eb             	mov    -0x15(%ebp),%al
f012296d:	88 02                	mov    %al,(%edx)
		start++ ;
f012296f:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f0122972:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f0122975:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122978:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f012297b:	7c c4                	jl     f0122941 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f012297d:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0122980:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122983:	01 d0                	add    %edx,%eax
f0122985:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f0122988:	90                   	nop
f0122989:	c9                   	leave  
f012298a:	c3                   	ret    

f012298b <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f012298b:	55                   	push   %ebp
f012298c:	89 e5                	mov    %esp,%ebp
f012298e:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f0122991:	ff 75 08             	pushl  0x8(%ebp)
f0122994:	e8 73 fa ff ff       	call   f012240c <strlen>
f0122999:	83 c4 04             	add    $0x4,%esp
f012299c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f012299f:	ff 75 0c             	pushl  0xc(%ebp)
f01229a2:	e8 65 fa ff ff       	call   f012240c <strlen>
f01229a7:	83 c4 04             	add    $0x4,%esp
f01229aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f01229ad:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f01229b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01229bb:	eb 17                	jmp    f01229d4 <strcconcat+0x49>
		final[s] = str1[s] ;
f01229bd:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01229c0:	8b 45 10             	mov    0x10(%ebp),%eax
f01229c3:	01 c2                	add    %eax,%edx
f01229c5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f01229c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01229cb:	01 c8                	add    %ecx,%eax
f01229cd:	8a 00                	mov    (%eax),%al
f01229cf:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f01229d1:	ff 45 fc             	incl   -0x4(%ebp)
f01229d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01229d7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01229da:	7c e1                	jl     f01229bd <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f01229dc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f01229e3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f01229ea:	eb 1f                	jmp    f0122a0b <strcconcat+0x80>
		final[s++] = str2[i] ;
f01229ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01229ef:	8d 50 01             	lea    0x1(%eax),%edx
f01229f2:	89 55 fc             	mov    %edx,-0x4(%ebp)
f01229f5:	89 c2                	mov    %eax,%edx
f01229f7:	8b 45 10             	mov    0x10(%ebp),%eax
f01229fa:	01 c2                	add    %eax,%edx
f01229fc:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f01229ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122a02:	01 c8                	add    %ecx,%eax
f0122a04:	8a 00                	mov    (%eax),%al
f0122a06:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f0122a08:	ff 45 f8             	incl   -0x8(%ebp)
f0122a0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0122a0e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0122a11:	7c d9                	jl     f01229ec <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f0122a13:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0122a16:	8b 45 10             	mov    0x10(%ebp),%eax
f0122a19:	01 d0                	add    %edx,%eax
f0122a1b:	c6 00 00             	movb   $0x0,(%eax)
}
f0122a1e:	90                   	nop
f0122a1f:	c9                   	leave  
f0122a20:	c3                   	ret    

f0122a21 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f0122a21:	55                   	push   %ebp
f0122a22:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f0122a24:	8b 45 14             	mov    0x14(%ebp),%eax
f0122a27:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f0122a2d:	8b 45 14             	mov    0x14(%ebp),%eax
f0122a30:	8b 00                	mov    (%eax),%eax
f0122a32:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0122a39:	8b 45 10             	mov    0x10(%ebp),%eax
f0122a3c:	01 d0                	add    %edx,%eax
f0122a3e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0122a44:	eb 0c                	jmp    f0122a52 <strsplit+0x31>
			*string++ = 0;
f0122a46:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a49:	8d 50 01             	lea    0x1(%eax),%edx
f0122a4c:	89 55 08             	mov    %edx,0x8(%ebp)
f0122a4f:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0122a52:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a55:	8a 00                	mov    (%eax),%al
f0122a57:	84 c0                	test   %al,%al
f0122a59:	74 18                	je     f0122a73 <strsplit+0x52>
f0122a5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a5e:	8a 00                	mov    (%eax),%al
f0122a60:	0f be c0             	movsbl %al,%eax
f0122a63:	50                   	push   %eax
f0122a64:	ff 75 0c             	pushl  0xc(%ebp)
f0122a67:	e8 32 fb ff ff       	call   f012259e <strchr>
f0122a6c:	83 c4 08             	add    $0x8,%esp
f0122a6f:	85 c0                	test   %eax,%eax
f0122a71:	75 d3                	jne    f0122a46 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f0122a73:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a76:	8a 00                	mov    (%eax),%al
f0122a78:	84 c0                	test   %al,%al
f0122a7a:	74 5a                	je     f0122ad6 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f0122a7c:	8b 45 14             	mov    0x14(%ebp),%eax
f0122a7f:	8b 00                	mov    (%eax),%eax
f0122a81:	83 f8 0f             	cmp    $0xf,%eax
f0122a84:	75 07                	jne    f0122a8d <strsplit+0x6c>
		{
			return 0;
f0122a86:	b8 00 00 00 00       	mov    $0x0,%eax
f0122a8b:	eb 66                	jmp    f0122af3 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f0122a8d:	8b 45 14             	mov    0x14(%ebp),%eax
f0122a90:	8b 00                	mov    (%eax),%eax
f0122a92:	8d 48 01             	lea    0x1(%eax),%ecx
f0122a95:	8b 55 14             	mov    0x14(%ebp),%edx
f0122a98:	89 0a                	mov    %ecx,(%edx)
f0122a9a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0122aa1:	8b 45 10             	mov    0x10(%ebp),%eax
f0122aa4:	01 c2                	add    %eax,%edx
f0122aa6:	8b 45 08             	mov    0x8(%ebp),%eax
f0122aa9:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f0122aab:	eb 03                	jmp    f0122ab0 <strsplit+0x8f>
			string++;
f0122aad:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f0122ab0:	8b 45 08             	mov    0x8(%ebp),%eax
f0122ab3:	8a 00                	mov    (%eax),%al
f0122ab5:	84 c0                	test   %al,%al
f0122ab7:	74 8b                	je     f0122a44 <strsplit+0x23>
f0122ab9:	8b 45 08             	mov    0x8(%ebp),%eax
f0122abc:	8a 00                	mov    (%eax),%al
f0122abe:	0f be c0             	movsbl %al,%eax
f0122ac1:	50                   	push   %eax
f0122ac2:	ff 75 0c             	pushl  0xc(%ebp)
f0122ac5:	e8 d4 fa ff ff       	call   f012259e <strchr>
f0122aca:	83 c4 08             	add    $0x8,%esp
f0122acd:	85 c0                	test   %eax,%eax
f0122acf:	74 dc                	je     f0122aad <strsplit+0x8c>
			string++;
	}
f0122ad1:	e9 6e ff ff ff       	jmp    f0122a44 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f0122ad6:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f0122ad7:	8b 45 14             	mov    0x14(%ebp),%eax
f0122ada:	8b 00                	mov    (%eax),%eax
f0122adc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0122ae3:	8b 45 10             	mov    0x10(%ebp),%eax
f0122ae6:	01 d0                	add    %edx,%eax
f0122ae8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f0122aee:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0122af3:	c9                   	leave  
f0122af4:	c3                   	ret    

f0122af5 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f0122af5:	55                   	push   %ebp
f0122af6:	89 e5                	mov    %esp,%ebp
f0122af8:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f0122afb:	83 ec 04             	sub    $0x4,%esp
f0122afe:	68 3c 0d 13 f0       	push   $0xf0130d3c
f0122b03:	68 3f 01 00 00       	push   $0x13f
f0122b08:	68 5e 0d 13 f0       	push   $0xf0130d5e
f0122b0d:	e8 08 d8 fd ff       	call   f010031a <_panic>

f0122b12 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f0122b12:	55                   	push   %ebp
f0122b13:	89 e5                	mov    %esp,%ebp
f0122b15:	83 ec 18             	sub    $0x18,%esp
f0122b18:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0122b1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0122b22:	89 c2                	mov    %eax,%edx
f0122b24:	ec                   	in     (%dx),%al
f0122b25:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0122b28:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0122b2b:	0f b6 c0             	movzbl %al,%eax
f0122b2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122b31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122b34:	25 c0 00 00 00       	and    $0xc0,%eax
f0122b39:	83 f8 40             	cmp    $0x40,%eax
f0122b3c:	75 10                	jne    f0122b4e <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f0122b3e:	83 ec 0c             	sub    $0xc,%esp
f0122b41:	68 a0 1d 5a f0       	push   $0xf05a1da0
f0122b46:	e8 43 c3 fe ff       	call   f010ee8e <wakeup_one>
f0122b4b:	83 c4 10             	add    $0x10,%esp
	}

}
f0122b4e:	90                   	nop
f0122b4f:	c9                   	leave  
f0122b50:	c3                   	ret    

f0122b51 <ide_init>:

void ide_init()
{
f0122b51:	55                   	push   %ebp
f0122b52:	89 e5                	mov    %esp,%ebp
f0122b54:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f0122b57:	83 ec 08             	sub    $0x8,%esp
f0122b5a:	68 12 2b 12 f0       	push   $0xf0122b12
f0122b5f:	6a 0e                	push   $0xe
f0122b61:	e8 07 a8 fe ff       	call   f010d36d <irq_install_handler>
f0122b66:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f0122b69:	83 ec 08             	sub    $0x8,%esp
f0122b6c:	68 6c 0d 13 f0       	push   $0xf0130d6c
f0122b71:	68 a0 1d 5a f0       	push   $0xf05a1da0
f0122b76:	e8 cc c2 fe ff       	call   f010ee47 <init_channel>
f0122b7b:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f0122b7e:	83 ec 08             	sub    $0x8,%esp
f0122b81:	68 79 0d 13 f0       	push   $0xf0130d79
f0122b86:	68 e0 48 5a f0       	push   $0xf05a48e0
f0122b8b:	e8 34 bf fe ff       	call   f010eac4 <init_spinlock>
f0122b90:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f0122b93:	90                   	nop
f0122b94:	c9                   	leave  
f0122b95:	c3                   	ret    

f0122b96 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f0122b96:	55                   	push   %ebp
f0122b97:	89 e5                	mov    %esp,%ebp
f0122b99:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0122b9c:	90                   	nop
f0122b9d:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0122ba4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0122ba7:	89 c2                	mov    %eax,%edx
f0122ba9:	ec                   	in     (%dx),%al
f0122baa:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0122bad:	8a 45 ef             	mov    -0x11(%ebp),%al
f0122bb0:	0f b6 c0             	movzbl %al,%eax
f0122bb3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122bb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122bb9:	25 c0 00 00 00       	and    $0xc0,%eax
f0122bbe:	83 f8 40             	cmp    $0x40,%eax
f0122bc1:	75 da                	jne    f0122b9d <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f0122bc3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122bc7:	74 24                	je     f0122bed <ide_wait_ready+0x57>
f0122bc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122bcc:	83 e0 21             	and    $0x21,%eax
f0122bcf:	85 c0                	test   %eax,%eax
f0122bd1:	74 1a                	je     f0122bed <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f0122bd3:	83 ec 0c             	sub    $0xc,%esp
f0122bd6:	ff 75 f4             	pushl  -0xc(%ebp)
f0122bd9:	ff 75 f4             	pushl  -0xc(%ebp)
f0122bdc:	68 8c 0d 13 f0       	push   $0xf0130d8c
f0122be1:	6a 5d                	push   $0x5d
f0122be3:	68 af 0d 13 f0       	push   $0xf0130daf
f0122be8:	e8 2d d7 fd ff       	call   f010031a <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f0122bed:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0122bf2:	c9                   	leave  
f0122bf3:	c3                   	ret    

f0122bf4 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f0122bf4:	55                   	push   %ebp
f0122bf5:	89 e5                	mov    %esp,%ebp
f0122bf7:	57                   	push   %edi
f0122bf8:	53                   	push   %ebx
f0122bf9:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f0122bfc:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0122c03:	76 16                	jbe    f0122c1b <ide_read+0x27>
f0122c05:	68 ba 0d 13 f0       	push   $0xf0130dba
f0122c0a:	68 c7 0d 13 f0       	push   $0xf0130dc7
f0122c0f:	6a 68                	push   $0x68
f0122c11:	68 af 0d 13 f0       	push   $0xf0130daf
f0122c16:	e8 ff d6 fd ff       	call   f010031a <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f0122c1b:	83 ec 0c             	sub    $0xc,%esp
f0122c1e:	6a 00                	push   $0x0
f0122c20:	e8 71 ff ff ff       	call   f0122b96 <ide_wait_ready>
f0122c25:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f0122c28:	8b 45 10             	mov    0x10(%ebp),%eax
f0122c2b:	0f b6 c0             	movzbl %al,%eax
f0122c2e:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0122c35:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0122c38:	8a 45 d2             	mov    -0x2e(%ebp),%al
f0122c3b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0122c3e:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0122c3f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c42:	0f b6 c0             	movzbl %al,%eax
f0122c45:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0122c4c:	88 45 d3             	mov    %al,-0x2d(%ebp)
f0122c4f:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0122c52:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122c55:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0122c56:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c59:	c1 e8 08             	shr    $0x8,%eax
f0122c5c:	0f b6 c0             	movzbl %al,%eax
f0122c5f:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0122c66:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0122c69:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0122c6c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0122c6f:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0122c70:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c73:	c1 e8 10             	shr    $0x10,%eax
f0122c76:	0f b6 c0             	movzbl %al,%eax
f0122c79:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0122c80:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0122c83:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0122c86:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122c89:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0122c8a:	a1 50 1c 5a f0       	mov    0xf05a1c50,%eax
f0122c8f:	83 e0 01             	and    $0x1,%eax
f0122c92:	c1 e0 04             	shl    $0x4,%eax
f0122c95:	88 c2                	mov    %al,%dl
f0122c97:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c9a:	c1 e8 18             	shr    $0x18,%eax
f0122c9d:	83 e0 0f             	and    $0xf,%eax
f0122ca0:	09 d0                	or     %edx,%eax
f0122ca2:	83 c8 e0             	or     $0xffffffe0,%eax
f0122ca5:	0f b6 c0             	movzbl %al,%eax
f0122ca8:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0122caf:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0122cb2:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0122cb5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0122cb8:	ee                   	out    %al,(%dx)
f0122cb9:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0122cc0:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f0122cc4:	8a 45 d7             	mov    -0x29(%ebp),%al
f0122cc7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0122cca:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0122ccb:	eb 55                	jmp    f0122d22 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f0122ccd:	83 ec 0c             	sub    $0xc,%esp
f0122cd0:	6a 01                	push   $0x1
f0122cd2:	e8 bf fe ff ff       	call   f0122b96 <ide_wait_ready>
f0122cd7:	83 c4 10             	add    $0x10,%esp
f0122cda:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0122cdd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0122ce1:	79 05                	jns    f0122ce8 <ide_read+0xf4>
			return r;
f0122ce3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0122ce6:	eb 45                	jmp    f0122d2d <ide_read+0x139>
f0122ce8:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0122cef:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122cf2:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0122cf5:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f0122cfc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122cff:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0122d02:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0122d05:	89 cb                	mov    %ecx,%ebx
f0122d07:	89 df                	mov    %ebx,%edi
f0122d09:	89 c1                	mov    %eax,%ecx
f0122d0b:	fc                   	cld    
f0122d0c:	f2 6d                	repnz insl (%dx),%es:(%edi)
f0122d0e:	89 c8                	mov    %ecx,%eax
f0122d10:	89 fb                	mov    %edi,%ebx
f0122d12:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0122d15:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0122d18:	ff 4d 10             	decl   0x10(%ebp)
f0122d1b:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0122d22:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122d26:	75 a5                	jne    f0122ccd <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f0122d28:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0122d2d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0122d30:	5b                   	pop    %ebx
f0122d31:	5f                   	pop    %edi
f0122d32:	5d                   	pop    %ebp
f0122d33:	c3                   	ret    

f0122d34 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f0122d34:	55                   	push   %ebp
f0122d35:	89 e5                	mov    %esp,%ebp
f0122d37:	56                   	push   %esi
f0122d38:	53                   	push   %ebx
f0122d39:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f0122d3c:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0122d43:	76 19                	jbe    f0122d5e <ide_write+0x2a>
f0122d45:	68 ba 0d 13 f0       	push   $0xf0130dba
f0122d4a:	68 c7 0d 13 f0       	push   $0xf0130dc7
f0122d4f:	68 82 00 00 00       	push   $0x82
f0122d54:	68 af 0d 13 f0       	push   $0xf0130daf
f0122d59:	e8 bc d5 fd ff       	call   f010031a <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f0122d5e:	83 ec 0c             	sub    $0xc,%esp
f0122d61:	6a 00                	push   $0x0
f0122d63:	e8 2e fe ff ff       	call   f0122b96 <ide_wait_ready>
f0122d68:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f0122d6b:	8b 45 10             	mov    0x10(%ebp),%eax
f0122d6e:	0f b6 c0             	movzbl %al,%eax
f0122d71:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0122d78:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0122d7b:	8a 45 d2             	mov    -0x2e(%ebp),%al
f0122d7e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0122d81:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0122d82:	8b 45 08             	mov    0x8(%ebp),%eax
f0122d85:	0f b6 c0             	movzbl %al,%eax
f0122d88:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0122d8f:	88 45 d3             	mov    %al,-0x2d(%ebp)
f0122d92:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0122d95:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122d98:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0122d99:	8b 45 08             	mov    0x8(%ebp),%eax
f0122d9c:	c1 e8 08             	shr    $0x8,%eax
f0122d9f:	0f b6 c0             	movzbl %al,%eax
f0122da2:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0122da9:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0122dac:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0122daf:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0122db2:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0122db3:	8b 45 08             	mov    0x8(%ebp),%eax
f0122db6:	c1 e8 10             	shr    $0x10,%eax
f0122db9:	0f b6 c0             	movzbl %al,%eax
f0122dbc:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0122dc3:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0122dc6:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0122dc9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122dcc:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0122dcd:	a1 50 1c 5a f0       	mov    0xf05a1c50,%eax
f0122dd2:	83 e0 01             	and    $0x1,%eax
f0122dd5:	c1 e0 04             	shl    $0x4,%eax
f0122dd8:	88 c2                	mov    %al,%dl
f0122dda:	8b 45 08             	mov    0x8(%ebp),%eax
f0122ddd:	c1 e8 18             	shr    $0x18,%eax
f0122de0:	83 e0 0f             	and    $0xf,%eax
f0122de3:	09 d0                	or     %edx,%eax
f0122de5:	83 c8 e0             	or     $0xffffffe0,%eax
f0122de8:	0f b6 c0             	movzbl %al,%eax
f0122deb:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0122df2:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0122df5:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0122df8:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0122dfb:	ee                   	out    %al,(%dx)
f0122dfc:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0122e03:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f0122e07:	8a 45 d7             	mov    -0x29(%ebp),%al
f0122e0a:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0122e0d:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0122e0e:	eb 55                	jmp    f0122e65 <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f0122e10:	83 ec 0c             	sub    $0xc,%esp
f0122e13:	6a 01                	push   $0x1
f0122e15:	e8 7c fd ff ff       	call   f0122b96 <ide_wait_ready>
f0122e1a:	83 c4 10             	add    $0x10,%esp
f0122e1d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0122e20:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0122e24:	79 05                	jns    f0122e2b <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f0122e26:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0122e29:	eb 45                	jmp    f0122e70 <ide_write+0x13c>
f0122e2b:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0122e32:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122e35:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0122e38:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f0122e3f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122e42:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0122e45:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0122e48:	89 cb                	mov    %ecx,%ebx
f0122e4a:	89 de                	mov    %ebx,%esi
f0122e4c:	89 c1                	mov    %eax,%ecx
f0122e4e:	fc                   	cld    
f0122e4f:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f0122e51:	89 c8                	mov    %ecx,%eax
f0122e53:	89 f3                	mov    %esi,%ebx
f0122e55:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0122e58:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0122e5b:	ff 4d 10             	decl   0x10(%ebp)
f0122e5e:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0122e65:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122e69:	75 a5                	jne    f0122e10 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f0122e6b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0122e70:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0122e73:	5b                   	pop    %ebx
f0122e74:	5e                   	pop    %esi
f0122e75:	5d                   	pop    %ebp
f0122e76:	c3                   	ret    

f0122e77 <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f0122e77:	55                   	push   %ebp
f0122e78:	89 e5                	mov    %esp,%ebp
f0122e7a:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0122e7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e80:	83 e8 04             	sub    $0x4,%eax
f0122e83:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f0122e86:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122e89:	8b 00                	mov    (%eax),%eax
f0122e8b:	83 e0 fe             	and    $0xfffffffe,%eax
}
f0122e8e:	c9                   	leave  
f0122e8f:	c3                   	ret    

f0122e90 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f0122e90:	55                   	push   %ebp
f0122e91:	89 e5                	mov    %esp,%ebp
f0122e93:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0122e96:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e99:	83 e8 04             	sub    $0x4,%eax
f0122e9c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f0122e9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122ea2:	8b 00                	mov    (%eax),%eax
f0122ea4:	83 e0 01             	and    $0x1,%eax
f0122ea7:	85 c0                	test   %eax,%eax
f0122ea9:	0f 94 c0             	sete   %al
}
f0122eac:	c9                   	leave  
f0122ead:	c3                   	ret    

f0122eae <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f0122eae:	55                   	push   %ebp
f0122eaf:	89 e5                	mov    %esp,%ebp
f0122eb1:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f0122eb4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f0122ebb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122ebe:	83 f8 02             	cmp    $0x2,%eax
f0122ec1:	74 2b                	je     f0122eee <alloc_block+0x40>
f0122ec3:	83 f8 02             	cmp    $0x2,%eax
f0122ec6:	7f 07                	jg     f0122ecf <alloc_block+0x21>
f0122ec8:	83 f8 01             	cmp    $0x1,%eax
f0122ecb:	74 0e                	je     f0122edb <alloc_block+0x2d>
f0122ecd:	eb 58                	jmp    f0122f27 <alloc_block+0x79>
f0122ecf:	83 f8 03             	cmp    $0x3,%eax
f0122ed2:	74 2d                	je     f0122f01 <alloc_block+0x53>
f0122ed4:	83 f8 04             	cmp    $0x4,%eax
f0122ed7:	74 3b                	je     f0122f14 <alloc_block+0x66>
f0122ed9:	eb 4c                	jmp    f0122f27 <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f0122edb:	83 ec 0c             	sub    $0xc,%esp
f0122ede:	ff 75 08             	pushl  0x8(%ebp)
f0122ee1:	e8 05 03 00 00       	call   f01231eb <alloc_block_FF>
f0122ee6:	83 c4 10             	add    $0x10,%esp
f0122ee9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0122eec:	eb 4a                	jmp    f0122f38 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f0122eee:	83 ec 0c             	sub    $0xc,%esp
f0122ef1:	ff 75 08             	pushl  0x8(%ebp)
f0122ef4:	e8 91 14 00 00       	call   f012438a <alloc_block_NF>
f0122ef9:	83 c4 10             	add    $0x10,%esp
f0122efc:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0122eff:	eb 37                	jmp    f0122f38 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f0122f01:	83 ec 0c             	sub    $0xc,%esp
f0122f04:	ff 75 08             	pushl  0x8(%ebp)
f0122f07:	e8 23 07 00 00       	call   f012362f <alloc_block_BF>
f0122f0c:	83 c4 10             	add    $0x10,%esp
f0122f0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0122f12:	eb 24                	jmp    f0122f38 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f0122f14:	83 ec 0c             	sub    $0xc,%esp
f0122f17:	ff 75 08             	pushl  0x8(%ebp)
f0122f1a:	e8 4e 14 00 00       	call   f012436d <alloc_block_WF>
f0122f1f:	83 c4 10             	add    $0x10,%esp
f0122f22:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0122f25:	eb 11                	jmp    f0122f38 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f0122f27:	83 ec 0c             	sub    $0xc,%esp
f0122f2a:	68 dc 0d 13 f0       	push   $0xf0130ddc
f0122f2f:	e8 38 e0 fd ff       	call   f0100f6c <cprintf>
f0122f34:	83 c4 10             	add    $0x10,%esp
		break;
f0122f37:	90                   	nop
	}
	return va;
f0122f38:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0122f3b:	c9                   	leave  
f0122f3c:	c3                   	ret    

f0122f3d <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f0122f3d:	55                   	push   %ebp
f0122f3e:	89 e5                	mov    %esp,%ebp
f0122f40:	53                   	push   %ebx
f0122f41:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f0122f44:	83 ec 0c             	sub    $0xc,%esp
f0122f47:	68 fc 0d 13 f0       	push   $0xf0130dfc
f0122f4c:	e8 1b e0 fd ff       	call   f0100f6c <cprintf>
f0122f51:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f0122f54:	83 ec 0c             	sub    $0xc,%esp
f0122f57:	68 27 0e 13 f0       	push   $0xf0130e27
f0122f5c:	e8 0b e0 fd ff       	call   f0100f6c <cprintf>
f0122f61:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f0122f64:	8b 45 08             	mov    0x8(%ebp),%eax
f0122f67:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122f6a:	eb 37                	jmp    f0122fa3 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0122f6c:	83 ec 0c             	sub    $0xc,%esp
f0122f6f:	ff 75 f4             	pushl  -0xc(%ebp)
f0122f72:	e8 19 ff ff ff       	call   f0122e90 <is_free_block>
f0122f77:	83 c4 10             	add    $0x10,%esp
f0122f7a:	0f be d8             	movsbl %al,%ebx
f0122f7d:	83 ec 0c             	sub    $0xc,%esp
f0122f80:	ff 75 f4             	pushl  -0xc(%ebp)
f0122f83:	e8 ef fe ff ff       	call   f0122e77 <get_block_size>
f0122f88:	83 c4 10             	add    $0x10,%esp
f0122f8b:	83 ec 04             	sub    $0x4,%esp
f0122f8e:	53                   	push   %ebx
f0122f8f:	50                   	push   %eax
f0122f90:	68 3f 0e 13 f0       	push   $0xf0130e3f
f0122f95:	e8 d2 df fd ff       	call   f0100f6c <cprintf>
f0122f9a:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f0122f9d:	8b 45 10             	mov    0x10(%ebp),%eax
f0122fa0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122fa3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122fa7:	74 07                	je     f0122fb0 <print_blocks_list+0x73>
f0122fa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122fac:	8b 00                	mov    (%eax),%eax
f0122fae:	eb 05                	jmp    f0122fb5 <print_blocks_list+0x78>
f0122fb0:	b8 00 00 00 00       	mov    $0x0,%eax
f0122fb5:	89 45 10             	mov    %eax,0x10(%ebp)
f0122fb8:	8b 45 10             	mov    0x10(%ebp),%eax
f0122fbb:	85 c0                	test   %eax,%eax
f0122fbd:	75 ad                	jne    f0122f6c <print_blocks_list+0x2f>
f0122fbf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122fc3:	75 a7                	jne    f0122f6c <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f0122fc5:	83 ec 0c             	sub    $0xc,%esp
f0122fc8:	68 fc 0d 13 f0       	push   $0xf0130dfc
f0122fcd:	e8 9a df fd ff       	call   f0100f6c <cprintf>
f0122fd2:	83 c4 10             	add    $0x10,%esp

}
f0122fd5:	90                   	nop
f0122fd6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0122fd9:	c9                   	leave  
f0122fda:	c3                   	ret    

f0122fdb <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f0122fdb:	55                   	push   %ebp
f0122fdc:	89 e5                	mov    %esp,%ebp
f0122fde:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f0122fe1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122fe4:	83 e0 01             	and    $0x1,%eax
f0122fe7:	85 c0                	test   %eax,%eax
f0122fe9:	74 03                	je     f0122fee <initialize_dynamic_allocator+0x13>
f0122feb:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f0122fee:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0122ff2:	0f 84 bb 01 00 00    	je     f01231b3 <initialize_dynamic_allocator+0x1d8>
                return ;
            is_initialized = 1;
f0122ff8:	c7 05 54 1c 5a f0 01 	movl   $0x1,0xf05a1c54
f0122fff:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f0123002:	8b 55 08             	mov    0x8(%ebp),%edx
f0123005:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123008:	01 d0                	add    %edx,%eax
f012300a:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f012300f:	0f 87 a1 01 00 00    	ja     f01231b6 <initialize_dynamic_allocator+0x1db>
        return;
    if(daStart < KERNEL_HEAP_START)
f0123015:	81 7d 08 ff ff ff f5 	cmpl   $0xf5ffffff,0x8(%ebp)
f012301c:	0f 86 97 01 00 00    	jbe    f01231b9 <initialize_dynamic_allocator+0x1de>
        return;

     struct BlockElement * element = NULL;
f0123022:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f0123029:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f012302e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0123031:	e9 87 00 00 00       	jmp    f01230bd <initialize_dynamic_allocator+0xe2>
     {
        LIST_REMOVE(&freeBlocksList,element);
f0123036:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012303a:	75 14                	jne    f0123050 <initialize_dynamic_allocator+0x75>
f012303c:	83 ec 04             	sub    $0x4,%esp
f012303f:	68 57 0e 13 f0       	push   $0xf0130e57
f0123044:	6a 79                	push   $0x79
f0123046:	68 75 0e 13 f0       	push   $0xf0130e75
f012304b:	e8 ca d2 fd ff       	call   f010031a <_panic>
f0123050:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123053:	8b 00                	mov    (%eax),%eax
f0123055:	85 c0                	test   %eax,%eax
f0123057:	74 10                	je     f0123069 <initialize_dynamic_allocator+0x8e>
f0123059:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012305c:	8b 00                	mov    (%eax),%eax
f012305e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123061:	8b 52 04             	mov    0x4(%edx),%edx
f0123064:	89 50 04             	mov    %edx,0x4(%eax)
f0123067:	eb 0b                	jmp    f0123074 <initialize_dynamic_allocator+0x99>
f0123069:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012306c:	8b 40 04             	mov    0x4(%eax),%eax
f012306f:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0123074:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123077:	8b 40 04             	mov    0x4(%eax),%eax
f012307a:	85 c0                	test   %eax,%eax
f012307c:	74 0f                	je     f012308d <initialize_dynamic_allocator+0xb2>
f012307e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123081:	8b 40 04             	mov    0x4(%eax),%eax
f0123084:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123087:	8b 12                	mov    (%edx),%edx
f0123089:	89 10                	mov    %edx,(%eax)
f012308b:	eb 0a                	jmp    f0123097 <initialize_dynamic_allocator+0xbc>
f012308d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123090:	8b 00                	mov    (%eax),%eax
f0123092:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0123097:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012309a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01230a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01230a3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01230aa:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f01230af:	48                   	dec    %eax
f01230b0:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
        return;
    if(daStart < KERNEL_HEAP_START)
        return;

     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f01230b5:	a1 58 1f 5a f0       	mov    0xf05a1f58,%eax
f01230ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01230bd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01230c1:	74 07                	je     f01230ca <initialize_dynamic_allocator+0xef>
f01230c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01230c6:	8b 00                	mov    (%eax),%eax
f01230c8:	eb 05                	jmp    f01230cf <initialize_dynamic_allocator+0xf4>
f01230ca:	b8 00 00 00 00       	mov    $0x0,%eax
f01230cf:	a3 58 1f 5a f0       	mov    %eax,0xf05a1f58
f01230d4:	a1 58 1f 5a f0       	mov    0xf05a1f58,%eax
f01230d9:	85 c0                	test   %eax,%eax
f01230db:	0f 85 55 ff ff ff    	jne    f0123036 <initialize_dynamic_allocator+0x5b>
f01230e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01230e5:	0f 85 4b ff ff ff    	jne    f0123036 <initialize_dynamic_allocator+0x5b>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f01230eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01230ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f01230f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01230f4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    struct Block_Start_End* end_block = (struct Block_Start_End*) (daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End));
f01230fa:	8b 55 08             	mov    0x8(%ebp),%edx
f01230fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123100:	01 d0                	add    %edx,%eax
f0123102:	83 e8 04             	sub    $0x4,%eax
f0123105:	89 45 ec             	mov    %eax,-0x14(%ebp)
    end_block->info = 1;
f0123108:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012310b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f0123111:	8b 45 08             	mov    0x8(%ebp),%eax
f0123114:	83 c0 08             	add    $0x8,%eax
f0123117:	89 45 e8             	mov    %eax,-0x18(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f012311a:	8b 45 08             	mov    0x8(%ebp),%eax
f012311d:	83 c0 04             	add    $0x4,%eax
f0123120:	8b 55 0c             	mov    0xc(%ebp),%edx
f0123123:	83 ea 08             	sub    $0x8,%edx
f0123126:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0123128:	8b 55 0c             	mov    0xc(%ebp),%edx
f012312b:	8b 45 08             	mov    0x8(%ebp),%eax
f012312e:	01 d0                	add    %edx,%eax
f0123130:	83 e8 08             	sub    $0x8,%eax
f0123133:	8b 55 0c             	mov    0xc(%ebp),%edx
f0123136:	83 ea 08             	sub    $0x8,%edx
f0123139:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f012313b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012313e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f0123144:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0123147:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f012314e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0123152:	75 17                	jne    f012316b <initialize_dynamic_allocator+0x190>
f0123154:	83 ec 04             	sub    $0x4,%esp
f0123157:	68 90 0e 13 f0       	push   $0xf0130e90
f012315c:	68 91 00 00 00       	push   $0x91
f0123161:	68 75 0e 13 f0       	push   $0xf0130e75
f0123166:	e8 af d1 fd ff       	call   f010031a <_panic>
f012316b:	8b 15 50 1f 5a f0    	mov    0xf05a1f50,%edx
f0123171:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0123174:	89 10                	mov    %edx,(%eax)
f0123176:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0123179:	8b 00                	mov    (%eax),%eax
f012317b:	85 c0                	test   %eax,%eax
f012317d:	74 0d                	je     f012318c <initialize_dynamic_allocator+0x1b1>
f012317f:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f0123184:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0123187:	89 50 04             	mov    %edx,0x4(%eax)
f012318a:	eb 08                	jmp    f0123194 <initialize_dynamic_allocator+0x1b9>
f012318c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012318f:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0123194:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0123197:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f012319c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012319f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01231a6:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f01231ab:	40                   	inc    %eax
f01231ac:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
f01231b1:	eb 07                	jmp    f01231ba <initialize_dynamic_allocator+0x1df>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f01231b3:	90                   	nop
f01231b4:	eb 04                	jmp    f01231ba <initialize_dynamic_allocator+0x1df>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f01231b6:	90                   	nop
f01231b7:	eb 01                	jmp    f01231ba <initialize_dynamic_allocator+0x1df>
    if(daStart < KERNEL_HEAP_START)
        return;
f01231b9:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f01231ba:	c9                   	leave  
f01231bb:	c3                   	ret    

f01231bc <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f01231bc:	55                   	push   %ebp
f01231bd:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f01231bf:	8b 45 10             	mov    0x10(%ebp),%eax
f01231c2:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f01231c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01231c8:	8d 50 fc             	lea    -0x4(%eax),%edx
f01231cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01231ce:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f01231d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01231d3:	83 e8 04             	sub    $0x4,%eax
f01231d6:	8b 00                	mov    (%eax),%eax
f01231d8:	83 e0 fe             	and    $0xfffffffe,%eax
f01231db:	8d 50 f8             	lea    -0x8(%eax),%edx
f01231de:	8b 45 08             	mov    0x8(%ebp),%eax
f01231e1:	01 c2                	add    %eax,%edx
f01231e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01231e6:	89 02                	mov    %eax,(%edx)
}
f01231e8:	90                   	nop
f01231e9:	5d                   	pop    %ebp
f01231ea:	c3                   	ret    

f01231eb <alloc_block_FF>:

//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *alloc_block_FF(uint32 size)
{
f01231eb:	55                   	push   %ebp
f01231ec:	89 e5                	mov    %esp,%ebp
f01231ee:	83 ec 48             	sub    $0x48,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f01231f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01231f4:	83 e0 01             	and    $0x1,%eax
f01231f7:	85 c0                	test   %eax,%eax
f01231f9:	74 03                	je     f01231fe <alloc_block_FF+0x13>
f01231fb:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f01231fe:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0123202:	77 07                	ja     f012320b <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0123204:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f012320b:	a1 54 1c 5a f0       	mov    0xf05a1c54,%eax
f0123210:	85 c0                	test   %eax,%eax
f0123212:	75 73                	jne    f0123287 <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0123214:	8b 45 08             	mov    0x8(%ebp),%eax
f0123217:	83 c0 10             	add    $0x10,%eax
f012321a:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f012321d:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f0123224:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123227:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012322a:	01 d0                	add    %edx,%eax
f012322c:	48                   	dec    %eax
f012322d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0123230:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0123233:	ba 00 00 00 00       	mov    $0x0,%edx
f0123238:	f7 75 ec             	divl   -0x14(%ebp)
f012323b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012323e:	29 d0                	sub    %edx,%eax
f0123240:	c1 e8 0c             	shr    $0xc,%eax
f0123243:	83 ec 0c             	sub    $0xc,%esp
f0123246:	50                   	push   %eax
f0123247:	e8 35 58 fe ff       	call   f0108a81 <sbrk>
f012324c:	83 c4 10             	add    $0x10,%esp
f012324f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0123252:	83 ec 0c             	sub    $0xc,%esp
f0123255:	6a 00                	push   $0x0
f0123257:	e8 25 58 fe ff       	call   f0108a81 <sbrk>
f012325c:	83 c4 10             	add    $0x10,%esp
f012325f:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0123262:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123265:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0123268:	83 ec 08             	sub    $0x8,%esp
f012326b:	50                   	push   %eax
f012326c:	ff 75 e4             	pushl  -0x1c(%ebp)
f012326f:	e8 67 fd ff ff       	call   f0122fdb <initialize_dynamic_allocator>
f0123274:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0123277:	83 ec 0c             	sub    $0xc,%esp
f012327a:	68 b3 0e 13 f0       	push   $0xf0130eb3
f012327f:	e8 e8 dc fd ff       	call   f0100f6c <cprintf>
f0123284:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f0123287:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012328b:	75 0a                	jne    f0123297 <alloc_block_FF+0xac>
	        return NULL;
f012328d:	b8 00 00 00 00       	mov    $0x0,%eax
f0123292:	e9 96 03 00 00       	jmp    f012362d <alloc_block_FF+0x442>
	    }
	    struct BlockElement *blk = NULL;
f0123297:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f012329e:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f01232a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01232a6:	e9 f3 02 00 00       	jmp    f012359e <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f01232ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01232ae:	89 45 cc             	mov    %eax,-0x34(%ebp)
	        uint32 blk_size = get_block_size(va);
f01232b1:	83 ec 0c             	sub    $0xc,%esp
f01232b4:	ff 75 cc             	pushl  -0x34(%ebp)
f01232b7:	e8 bb fb ff ff       	call   f0122e77 <get_block_size>
f01232bc:	83 c4 10             	add    $0x10,%esp
f01232bf:	89 45 c8             	mov    %eax,-0x38(%ebp)
	        if (blk_size >= size + 2 * sizeof(uint32)) {
f01232c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01232c5:	83 c0 08             	add    $0x8,%eax
f01232c8:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01232cb:	0f 87 c5 02 00 00    	ja     f0123596 <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f01232d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01232d4:	83 c0 18             	add    $0x18,%eax
f01232d7:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01232da:	0f 87 19 02 00 00    	ja     f01234f9 <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f01232e0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01232e3:	2b 45 08             	sub    0x8(%ebp),%eax
f01232e6:	83 e8 08             	sub    $0x8,%eax
f01232e9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32)); // casting to char because its 1 byte size
f01232ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01232ef:	8d 50 08             	lea    0x8(%eax),%edx
f01232f2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01232f5:	01 d0                	add    %edx,%eax
f01232f7:	89 45 c0             	mov    %eax,-0x40(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f01232fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01232fd:	83 c0 08             	add    $0x8,%eax
f0123300:	83 ec 04             	sub    $0x4,%esp
f0123303:	6a 01                	push   $0x1
f0123305:	50                   	push   %eax
f0123306:	ff 75 cc             	pushl  -0x34(%ebp)
f0123309:	e8 ae fe ff ff       	call   f01231bc <set_block_data>
f012330e:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f0123311:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123314:	8b 40 04             	mov    0x4(%eax),%eax
f0123317:	85 c0                	test   %eax,%eax
f0123319:	75 68                	jne    f0123383 <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f012331b:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f012331f:	75 17                	jne    f0123338 <alloc_block_FF+0x14d>
f0123321:	83 ec 04             	sub    $0x4,%esp
f0123324:	68 90 0e 13 f0       	push   $0xf0130e90
f0123329:	68 d2 00 00 00       	push   $0xd2
f012332e:	68 75 0e 13 f0       	push   $0xf0130e75
f0123333:	e8 e2 cf fd ff       	call   f010031a <_panic>
f0123338:	8b 15 50 1f 5a f0    	mov    0xf05a1f50,%edx
f012333e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0123341:	89 10                	mov    %edx,(%eax)
f0123343:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0123346:	8b 00                	mov    (%eax),%eax
f0123348:	85 c0                	test   %eax,%eax
f012334a:	74 0d                	je     f0123359 <alloc_block_FF+0x16e>
f012334c:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f0123351:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0123354:	89 50 04             	mov    %edx,0x4(%eax)
f0123357:	eb 08                	jmp    f0123361 <alloc_block_FF+0x176>
f0123359:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012335c:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0123361:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0123364:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0123369:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012336c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123373:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123378:	40                   	inc    %eax
f0123379:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
f012337e:	e9 dc 00 00 00       	jmp    f012345f <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f0123383:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123386:	8b 00                	mov    (%eax),%eax
f0123388:	85 c0                	test   %eax,%eax
f012338a:	75 65                	jne    f01233f1 <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f012338c:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0123390:	75 17                	jne    f01233a9 <alloc_block_FF+0x1be>
f0123392:	83 ec 04             	sub    $0x4,%esp
f0123395:	68 c4 0e 13 f0       	push   $0xf0130ec4
f012339a:	68 d6 00 00 00       	push   $0xd6
f012339f:	68 75 0e 13 f0       	push   $0xf0130e75
f01233a4:	e8 71 cf fd ff       	call   f010031a <_panic>
f01233a9:	8b 15 54 1f 5a f0    	mov    0xf05a1f54,%edx
f01233af:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01233b2:	89 50 04             	mov    %edx,0x4(%eax)
f01233b5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01233b8:	8b 40 04             	mov    0x4(%eax),%eax
f01233bb:	85 c0                	test   %eax,%eax
f01233bd:	74 0c                	je     f01233cb <alloc_block_FF+0x1e0>
f01233bf:	a1 54 1f 5a f0       	mov    0xf05a1f54,%eax
f01233c4:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01233c7:	89 10                	mov    %edx,(%eax)
f01233c9:	eb 08                	jmp    f01233d3 <alloc_block_FF+0x1e8>
f01233cb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01233ce:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f01233d3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01233d6:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f01233db:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01233de:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01233e4:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f01233e9:	40                   	inc    %eax
f01233ea:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
f01233ef:	eb 6e                	jmp    f012345f <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f01233f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01233f5:	74 06                	je     f01233fd <alloc_block_FF+0x212>
f01233f7:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f01233fb:	75 17                	jne    f0123414 <alloc_block_FF+0x229>
f01233fd:	83 ec 04             	sub    $0x4,%esp
f0123400:	68 e8 0e 13 f0       	push   $0xf0130ee8
f0123405:	68 da 00 00 00       	push   $0xda
f012340a:	68 75 0e 13 f0       	push   $0xf0130e75
f012340f:	e8 06 cf fd ff       	call   f010031a <_panic>
f0123414:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123417:	8b 10                	mov    (%eax),%edx
f0123419:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012341c:	89 10                	mov    %edx,(%eax)
f012341e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0123421:	8b 00                	mov    (%eax),%eax
f0123423:	85 c0                	test   %eax,%eax
f0123425:	74 0b                	je     f0123432 <alloc_block_FF+0x247>
f0123427:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012342a:	8b 00                	mov    (%eax),%eax
f012342c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f012342f:	89 50 04             	mov    %edx,0x4(%eax)
f0123432:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123435:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0123438:	89 10                	mov    %edx,(%eax)
f012343a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012343d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123440:	89 50 04             	mov    %edx,0x4(%eax)
f0123443:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0123446:	8b 00                	mov    (%eax),%eax
f0123448:	85 c0                	test   %eax,%eax
f012344a:	75 08                	jne    f0123454 <alloc_block_FF+0x269>
f012344c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012344f:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0123454:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123459:	40                   	inc    %eax
f012345a:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
				}
				LIST_REMOVE(&freeBlocksList, blk);
f012345f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123463:	75 17                	jne    f012347c <alloc_block_FF+0x291>
f0123465:	83 ec 04             	sub    $0x4,%esp
f0123468:	68 57 0e 13 f0       	push   $0xf0130e57
f012346d:	68 dc 00 00 00       	push   $0xdc
f0123472:	68 75 0e 13 f0       	push   $0xf0130e75
f0123477:	e8 9e ce fd ff       	call   f010031a <_panic>
f012347c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012347f:	8b 00                	mov    (%eax),%eax
f0123481:	85 c0                	test   %eax,%eax
f0123483:	74 10                	je     f0123495 <alloc_block_FF+0x2aa>
f0123485:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123488:	8b 00                	mov    (%eax),%eax
f012348a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012348d:	8b 52 04             	mov    0x4(%edx),%edx
f0123490:	89 50 04             	mov    %edx,0x4(%eax)
f0123493:	eb 0b                	jmp    f01234a0 <alloc_block_FF+0x2b5>
f0123495:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123498:	8b 40 04             	mov    0x4(%eax),%eax
f012349b:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f01234a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01234a3:	8b 40 04             	mov    0x4(%eax),%eax
f01234a6:	85 c0                	test   %eax,%eax
f01234a8:	74 0f                	je     f01234b9 <alloc_block_FF+0x2ce>
f01234aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01234ad:	8b 40 04             	mov    0x4(%eax),%eax
f01234b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01234b3:	8b 12                	mov    (%edx),%edx
f01234b5:	89 10                	mov    %edx,(%eax)
f01234b7:	eb 0a                	jmp    f01234c3 <alloc_block_FF+0x2d8>
f01234b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01234bc:	8b 00                	mov    (%eax),%eax
f01234be:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f01234c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01234c6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01234cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01234cf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01234d6:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f01234db:	48                   	dec    %eax
f01234dc:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
				set_block_data(new_block_va, remaining_size, 0);
f01234e1:	83 ec 04             	sub    $0x4,%esp
f01234e4:	6a 00                	push   $0x0
f01234e6:	ff 75 c4             	pushl  -0x3c(%ebp)
f01234e9:	ff 75 c0             	pushl  -0x40(%ebp)
f01234ec:	e8 cb fc ff ff       	call   f01231bc <set_block_data>
f01234f1:	83 c4 10             	add    $0x10,%esp
f01234f4:	e9 95 00 00 00       	jmp    f012358e <alloc_block_FF+0x3a3>
	            }
	            else
	            {
	            	set_block_data(va, blk_size, 1);
f01234f9:	83 ec 04             	sub    $0x4,%esp
f01234fc:	6a 01                	push   $0x1
f01234fe:	ff 75 c8             	pushl  -0x38(%ebp)
f0123501:	ff 75 cc             	pushl  -0x34(%ebp)
f0123504:	e8 b3 fc ff ff       	call   f01231bc <set_block_data>
f0123509:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f012350c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123510:	75 17                	jne    f0123529 <alloc_block_FF+0x33e>
f0123512:	83 ec 04             	sub    $0x4,%esp
f0123515:	68 57 0e 13 f0       	push   $0xf0130e57
f012351a:	68 e2 00 00 00       	push   $0xe2
f012351f:	68 75 0e 13 f0       	push   $0xf0130e75
f0123524:	e8 f1 cd fd ff       	call   f010031a <_panic>
f0123529:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012352c:	8b 00                	mov    (%eax),%eax
f012352e:	85 c0                	test   %eax,%eax
f0123530:	74 10                	je     f0123542 <alloc_block_FF+0x357>
f0123532:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123535:	8b 00                	mov    (%eax),%eax
f0123537:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012353a:	8b 52 04             	mov    0x4(%edx),%edx
f012353d:	89 50 04             	mov    %edx,0x4(%eax)
f0123540:	eb 0b                	jmp    f012354d <alloc_block_FF+0x362>
f0123542:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123545:	8b 40 04             	mov    0x4(%eax),%eax
f0123548:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f012354d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123550:	8b 40 04             	mov    0x4(%eax),%eax
f0123553:	85 c0                	test   %eax,%eax
f0123555:	74 0f                	je     f0123566 <alloc_block_FF+0x37b>
f0123557:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012355a:	8b 40 04             	mov    0x4(%eax),%eax
f012355d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123560:	8b 12                	mov    (%edx),%edx
f0123562:	89 10                	mov    %edx,(%eax)
f0123564:	eb 0a                	jmp    f0123570 <alloc_block_FF+0x385>
f0123566:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123569:	8b 00                	mov    (%eax),%eax
f012356b:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0123570:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123573:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123579:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012357c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123583:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123588:	48                   	dec    %eax
f0123589:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
	            }
	            return va;
f012358e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0123591:	e9 97 00 00 00       	jmp    f012362d <alloc_block_FF+0x442>

	 if (size == 0) {
	        return NULL;
	    }
	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f0123596:	a1 58 1f 5a f0       	mov    0xf05a1f58,%eax
f012359b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012359e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01235a2:	74 07                	je     f01235ab <alloc_block_FF+0x3c0>
f01235a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01235a7:	8b 00                	mov    (%eax),%eax
f01235a9:	eb 05                	jmp    f01235b0 <alloc_block_FF+0x3c5>
f01235ab:	b8 00 00 00 00       	mov    $0x0,%eax
f01235b0:	a3 58 1f 5a f0       	mov    %eax,0xf05a1f58
f01235b5:	a1 58 1f 5a f0       	mov    0xf05a1f58,%eax
f01235ba:	85 c0                	test   %eax,%eax
f01235bc:	0f 85 e9 fc ff ff    	jne    f01232ab <alloc_block_FF+0xc0>
f01235c2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01235c6:	0f 85 df fc ff ff    	jne    f01232ab <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f01235cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01235cf:	83 c0 08             	add    $0x8,%eax
f01235d2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f01235d5:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01235dc:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01235df:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01235e2:	01 d0                	add    %edx,%eax
f01235e4:	48                   	dec    %eax
f01235e5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01235e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01235eb:	ba 00 00 00 00       	mov    $0x0,%edx
f01235f0:	f7 75 d8             	divl   -0x28(%ebp)
f01235f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01235f6:	29 d0                	sub    %edx,%eax
f01235f8:	c1 e8 0c             	shr    $0xc,%eax
f01235fb:	83 ec 0c             	sub    $0xc,%esp
f01235fe:	50                   	push   %eax
f01235ff:	e8 7d 54 fe ff       	call   f0108a81 <sbrk>
f0123604:	83 c4 10             	add    $0x10,%esp
f0123607:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f012360a:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f012360e:	75 07                	jne    f0123617 <alloc_block_FF+0x42c>
			return NULL; // Allocation failed
f0123610:	b8 00 00 00 00       	mov    $0x0,%eax
f0123615:	eb 16                	jmp    f012362d <alloc_block_FF+0x442>
		}
		set_block_data(new_mem, required_size, 1);
f0123617:	83 ec 04             	sub    $0x4,%esp
f012361a:	6a 01                	push   $0x1
f012361c:	ff 75 dc             	pushl  -0x24(%ebp)
f012361f:	ff 75 d0             	pushl  -0x30(%ebp)
f0123622:	e8 95 fb ff ff       	call   f01231bc <set_block_data>
f0123627:	83 c4 10             	add    $0x10,%esp
		return new_mem;
f012362a:	8b 45 d0             	mov    -0x30(%ebp),%eax
}
f012362d:	c9                   	leave  
f012362e:	c3                   	ret    

f012362f <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f012362f:	55                   	push   %ebp
f0123630:	89 e5                	mov    %esp,%ebp
f0123632:	57                   	push   %edi
f0123633:	56                   	push   %esi
f0123634:	53                   	push   %ebx
f0123635:	83 ec 5c             	sub    $0x5c,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0123638:	8b 45 08             	mov    0x8(%ebp),%eax
f012363b:	83 e0 01             	and    $0x1,%eax
f012363e:	85 c0                	test   %eax,%eax
f0123640:	74 03                	je     f0123645 <alloc_block_BF+0x16>
f0123642:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0123645:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0123649:	77 07                	ja     f0123652 <alloc_block_BF+0x23>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f012364b:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0123652:	a1 54 1c 5a f0       	mov    0xf05a1c54,%eax
f0123657:	85 c0                	test   %eax,%eax
f0123659:	75 73                	jne    f01236ce <alloc_block_BF+0x9f>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f012365b:	8b 45 08             	mov    0x8(%ebp),%eax
f012365e:	83 c0 10             	add    $0x10,%eax
f0123661:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0123664:	c7 45 d0 00 10 00 00 	movl   $0x1000,-0x30(%ebp)
f012366b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012366e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0123671:	01 d0                	add    %edx,%eax
f0123673:	48                   	dec    %eax
f0123674:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0123677:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012367a:	ba 00 00 00 00       	mov    $0x0,%edx
f012367f:	f7 75 d0             	divl   -0x30(%ebp)
f0123682:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0123685:	29 d0                	sub    %edx,%eax
f0123687:	c1 e8 0c             	shr    $0xc,%eax
f012368a:	83 ec 0c             	sub    $0xc,%esp
f012368d:	50                   	push   %eax
f012368e:	e8 ee 53 fe ff       	call   f0108a81 <sbrk>
f0123693:	83 c4 10             	add    $0x10,%esp
f0123696:	89 45 c8             	mov    %eax,-0x38(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0123699:	83 ec 0c             	sub    $0xc,%esp
f012369c:	6a 00                	push   $0x0
f012369e:	e8 de 53 fe ff       	call   f0108a81 <sbrk>
f01236a3:	83 c4 10             	add    $0x10,%esp
f01236a6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f01236a9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01236ac:	2b 45 c8             	sub    -0x38(%ebp),%eax
f01236af:	83 ec 08             	sub    $0x8,%esp
f01236b2:	50                   	push   %eax
f01236b3:	ff 75 c8             	pushl  -0x38(%ebp)
f01236b6:	e8 20 f9 ff ff       	call   f0122fdb <initialize_dynamic_allocator>
f01236bb:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f01236be:	83 ec 0c             	sub    $0xc,%esp
f01236c1:	68 b3 0e 13 f0       	push   $0xf0130eb3
f01236c6:	e8 a1 d8 fd ff       	call   f0100f6c <cprintf>
f01236cb:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f01236ce:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	void *best_va=NULL;
f01236d5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f01236dc:	c7 45 dc f8 ef ff ff 	movl   $0xffffeff8,-0x24(%ebp)
	bool internal = 0;
f01236e3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f01236ea:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f01236ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01236f2:	e9 b5 01 00 00       	jmp    f01238ac <alloc_block_BF+0x27d>
		void *va = (void *)blk;
f01236f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01236fa:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f01236fd:	83 ec 0c             	sub    $0xc,%esp
f0123700:	ff 75 a8             	pushl  -0x58(%ebp)
f0123703:	e8 6f f7 ff ff       	call   f0122e77 <get_block_size>
f0123708:	83 c4 10             	add    $0x10,%esp
f012370b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f012370e:	8b 45 08             	mov    0x8(%ebp),%eax
f0123711:	83 c0 08             	add    $0x8,%eax
f0123714:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0123717:	0f 87 87 01 00 00    	ja     f01238a4 <alloc_block_BF+0x275>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f012371d:	8b 45 08             	mov    0x8(%ebp),%eax
f0123720:	83 c0 18             	add    $0x18,%eax
f0123723:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0123726:	77 1d                	ja     f0123745 <alloc_block_BF+0x116>
			{
				if (best_blk_size > blk_size)
f0123728:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012372b:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f012372e:	0f 86 70 01 00 00    	jbe    f01238a4 <alloc_block_BF+0x275>
				{
					best_va = va;
f0123734:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0123737:	89 45 e0             	mov    %eax,-0x20(%ebp)
					best_blk_size = blk_size;
f012373a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f012373d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0123740:	e9 5f 01 00 00       	jmp    f01238a4 <alloc_block_BF+0x275>
				}
			}
			else
			{
				cprintf("288\n");
f0123745:	83 ec 0c             	sub    $0xc,%esp
f0123748:	68 1c 0f 13 f0       	push   $0xf0130f1c
f012374d:	e8 1a d8 fd ff       	call   f0100f6c <cprintf>
f0123752:	83 c4 10             	add    $0x10,%esp
				cprintf("Size : %d\n",size);
f0123755:	83 ec 08             	sub    $0x8,%esp
f0123758:	ff 75 08             	pushl  0x8(%ebp)
f012375b:	68 21 0f 13 f0       	push   $0xf0130f21
f0123760:	e8 07 d8 fd ff       	call   f0100f6c <cprintf>
f0123765:	83 c4 10             	add    $0x10,%esp
				cprintf("Best Size : %d\n",blk_size);
f0123768:	83 ec 08             	sub    $0x8,%esp
f012376b:	ff 75 a4             	pushl  -0x5c(%ebp)
f012376e:	68 2c 0f 13 f0       	push   $0xf0130f2c
f0123773:	e8 f4 d7 fd ff       	call   f0100f6c <cprintf>
f0123778:	83 c4 10             	add    $0x10,%esp
				print_blocks_list(freeBlocksList);
f012377b:	83 ec 10             	sub    $0x10,%esp
f012377e:	89 e0                	mov    %esp,%eax
f0123780:	89 c2                	mov    %eax,%edx
f0123782:	bb 50 1f 5a f0       	mov    $0xf05a1f50,%ebx
f0123787:	b8 04 00 00 00       	mov    $0x4,%eax
f012378c:	89 d7                	mov    %edx,%edi
f012378e:	89 de                	mov    %ebx,%esi
f0123790:	89 c1                	mov    %eax,%ecx
f0123792:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0123794:	e8 a4 f7 ff ff       	call   f0122f3d <print_blocks_list>
f0123799:	83 c4 10             	add    $0x10,%esp
				if (blk_size == size + 2 * sizeof(uint32)){
f012379c:	8b 45 08             	mov    0x8(%ebp),%eax
f012379f:	83 c0 08             	add    $0x8,%eax
f01237a2:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01237a5:	0f 85 ce 00 00 00    	jne    f0123879 <alloc_block_BF+0x24a>
					cprintf("291\n");
f01237ab:	83 ec 0c             	sub    $0xc,%esp
f01237ae:	68 3c 0f 13 f0       	push   $0xf0130f3c
f01237b3:	e8 b4 d7 fd ff       	call   f0100f6c <cprintf>
f01237b8:	83 c4 10             	add    $0x10,%esp
					set_block_data(va, blk_size, 1);
f01237bb:	83 ec 04             	sub    $0x4,%esp
f01237be:	6a 01                	push   $0x1
f01237c0:	ff 75 a4             	pushl  -0x5c(%ebp)
f01237c3:	ff 75 a8             	pushl  -0x58(%ebp)
f01237c6:	e8 f1 f9 ff ff       	call   f01231bc <set_block_data>
f01237cb:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f01237ce:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01237d2:	75 17                	jne    f01237eb <alloc_block_BF+0x1bc>
f01237d4:	83 ec 04             	sub    $0x4,%esp
f01237d7:	68 57 0e 13 f0       	push   $0xf0130e57
f01237dc:	68 25 01 00 00       	push   $0x125
f01237e1:	68 75 0e 13 f0       	push   $0xf0130e75
f01237e6:	e8 2f cb fd ff       	call   f010031a <_panic>
f01237eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01237ee:	8b 00                	mov    (%eax),%eax
f01237f0:	85 c0                	test   %eax,%eax
f01237f2:	74 10                	je     f0123804 <alloc_block_BF+0x1d5>
f01237f4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01237f7:	8b 00                	mov    (%eax),%eax
f01237f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01237fc:	8b 52 04             	mov    0x4(%edx),%edx
f01237ff:	89 50 04             	mov    %edx,0x4(%eax)
f0123802:	eb 0b                	jmp    f012380f <alloc_block_BF+0x1e0>
f0123804:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123807:	8b 40 04             	mov    0x4(%eax),%eax
f012380a:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f012380f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123812:	8b 40 04             	mov    0x4(%eax),%eax
f0123815:	85 c0                	test   %eax,%eax
f0123817:	74 0f                	je     f0123828 <alloc_block_BF+0x1f9>
f0123819:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012381c:	8b 40 04             	mov    0x4(%eax),%eax
f012381f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0123822:	8b 12                	mov    (%edx),%edx
f0123824:	89 10                	mov    %edx,(%eax)
f0123826:	eb 0a                	jmp    f0123832 <alloc_block_BF+0x203>
f0123828:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012382b:	8b 00                	mov    (%eax),%eax
f012382d:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0123832:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123835:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012383b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012383e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123845:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f012384a:	48                   	dec    %eax
f012384b:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
					print_blocks_list(freeBlocksList);
f0123850:	83 ec 10             	sub    $0x10,%esp
f0123853:	89 e0                	mov    %esp,%eax
f0123855:	89 c2                	mov    %eax,%edx
f0123857:	bb 50 1f 5a f0       	mov    $0xf05a1f50,%ebx
f012385c:	b8 04 00 00 00       	mov    $0x4,%eax
f0123861:	89 d7                	mov    %edx,%edi
f0123863:	89 de                	mov    %ebx,%esi
f0123865:	89 c1                	mov    %eax,%ecx
f0123867:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0123869:	e8 cf f6 ff ff       	call   f0122f3d <print_blocks_list>
f012386e:	83 c4 10             	add    $0x10,%esp
					return va;
f0123871:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0123874:	e9 d7 03 00 00       	jmp    f0123c50 <alloc_block_BF+0x621>
				}
				else //if (blk_size> size + 2 * sizeof(uint32))
				{
					if (best_blk_size > blk_size)
f0123879:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012387c:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f012387f:	76 23                	jbe    f01238a4 <alloc_block_BF+0x275>
					{
						cprintf("299\n");
f0123881:	83 ec 0c             	sub    $0xc,%esp
f0123884:	68 41 0f 13 f0       	push   $0xf0130f41
f0123889:	e8 de d6 fd ff       	call   f0100f6c <cprintf>
f012388e:	83 c4 10             	add    $0x10,%esp
						internal = 1;
f0123891:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
						best_va = va;
f0123898:	8b 45 a8             	mov    -0x58(%ebp),%eax
f012389b:	89 45 e0             	mov    %eax,-0x20(%ebp)
						best_blk_size = blk_size;
f012389e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01238a1:	89 45 dc             	mov    %eax,-0x24(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f01238a4:	a1 58 1f 5a f0       	mov    0xf05a1f58,%eax
f01238a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01238ac:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01238b0:	74 07                	je     f01238b9 <alloc_block_BF+0x28a>
f01238b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01238b5:	8b 00                	mov    (%eax),%eax
f01238b7:	eb 05                	jmp    f01238be <alloc_block_BF+0x28f>
f01238b9:	b8 00 00 00 00       	mov    $0x0,%eax
f01238be:	a3 58 1f 5a f0       	mov    %eax,0xf05a1f58
f01238c3:	a1 58 1f 5a f0       	mov    0xf05a1f58,%eax
f01238c8:	85 c0                	test   %eax,%eax
f01238ca:	0f 85 27 fe ff ff    	jne    f01236f7 <alloc_block_BF+0xc8>
f01238d0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01238d4:	0f 85 1d fe ff ff    	jne    f01236f7 <alloc_block_BF+0xc8>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f01238da:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01238de:	0f 84 26 02 00 00    	je     f0123b0a <alloc_block_BF+0x4db>
f01238e4:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01238e8:	0f 85 1c 02 00 00    	jne    f0123b0a <alloc_block_BF+0x4db>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f01238ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01238f1:	2b 45 08             	sub    0x8(%ebp),%eax
f01238f4:	83 e8 08             	sub    $0x8,%eax
f01238f7:	89 45 c0             	mov    %eax,-0x40(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f01238fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01238fd:	8d 50 08             	lea    0x8(%eax),%edx
f0123900:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123903:	01 d0                	add    %edx,%eax
f0123905:	89 45 bc             	mov    %eax,-0x44(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f0123908:	8b 45 08             	mov    0x8(%ebp),%eax
f012390b:	83 c0 08             	add    $0x8,%eax
f012390e:	83 ec 04             	sub    $0x4,%esp
f0123911:	6a 01                	push   $0x1
f0123913:	50                   	push   %eax
f0123914:	ff 75 e0             	pushl  -0x20(%ebp)
f0123917:	e8 a0 f8 ff ff       	call   f01231bc <set_block_data>
f012391c:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f012391f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123922:	8b 40 04             	mov    0x4(%eax),%eax
f0123925:	85 c0                	test   %eax,%eax
f0123927:	75 68                	jne    f0123991 <alloc_block_BF+0x362>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0123929:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f012392d:	75 17                	jne    f0123946 <alloc_block_BF+0x317>
f012392f:	83 ec 04             	sub    $0x4,%esp
f0123932:	68 90 0e 13 f0       	push   $0xf0130e90
f0123937:	68 40 01 00 00       	push   $0x140
f012393c:	68 75 0e 13 f0       	push   $0xf0130e75
f0123941:	e8 d4 c9 fd ff       	call   f010031a <_panic>
f0123946:	8b 15 50 1f 5a f0    	mov    0xf05a1f50,%edx
f012394c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f012394f:	89 10                	mov    %edx,(%eax)
f0123951:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0123954:	8b 00                	mov    (%eax),%eax
f0123956:	85 c0                	test   %eax,%eax
f0123958:	74 0d                	je     f0123967 <alloc_block_BF+0x338>
f012395a:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f012395f:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0123962:	89 50 04             	mov    %edx,0x4(%eax)
f0123965:	eb 08                	jmp    f012396f <alloc_block_BF+0x340>
f0123967:	8b 45 bc             	mov    -0x44(%ebp),%eax
f012396a:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f012396f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0123972:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0123977:	8b 45 bc             	mov    -0x44(%ebp),%eax
f012397a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123981:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123986:	40                   	inc    %eax
f0123987:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
f012398c:	e9 dc 00 00 00       	jmp    f0123a6d <alloc_block_BF+0x43e>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f0123991:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123994:	8b 00                	mov    (%eax),%eax
f0123996:	85 c0                	test   %eax,%eax
f0123998:	75 65                	jne    f01239ff <alloc_block_BF+0x3d0>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f012399a:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f012399e:	75 17                	jne    f01239b7 <alloc_block_BF+0x388>
f01239a0:	83 ec 04             	sub    $0x4,%esp
f01239a3:	68 c4 0e 13 f0       	push   $0xf0130ec4
f01239a8:	68 45 01 00 00       	push   $0x145
f01239ad:	68 75 0e 13 f0       	push   $0xf0130e75
f01239b2:	e8 63 c9 fd ff       	call   f010031a <_panic>
f01239b7:	8b 15 54 1f 5a f0    	mov    0xf05a1f54,%edx
f01239bd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01239c0:	89 50 04             	mov    %edx,0x4(%eax)
f01239c3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01239c6:	8b 40 04             	mov    0x4(%eax),%eax
f01239c9:	85 c0                	test   %eax,%eax
f01239cb:	74 0c                	je     f01239d9 <alloc_block_BF+0x3aa>
f01239cd:	a1 54 1f 5a f0       	mov    0xf05a1f54,%eax
f01239d2:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01239d5:	89 10                	mov    %edx,(%eax)
f01239d7:	eb 08                	jmp    f01239e1 <alloc_block_BF+0x3b2>
f01239d9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01239dc:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f01239e1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01239e4:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f01239e9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01239ec:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01239f2:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f01239f7:	40                   	inc    %eax
f01239f8:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
f01239fd:	eb 6e                	jmp    f0123a6d <alloc_block_BF+0x43e>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f01239ff:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0123a03:	74 06                	je     f0123a0b <alloc_block_BF+0x3dc>
f0123a05:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f0123a09:	75 17                	jne    f0123a22 <alloc_block_BF+0x3f3>
f0123a0b:	83 ec 04             	sub    $0x4,%esp
f0123a0e:	68 e8 0e 13 f0       	push   $0xf0130ee8
f0123a13:	68 4a 01 00 00       	push   $0x14a
f0123a18:	68 75 0e 13 f0       	push   $0xf0130e75
f0123a1d:	e8 f8 c8 fd ff       	call   f010031a <_panic>
f0123a22:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123a25:	8b 10                	mov    (%eax),%edx
f0123a27:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0123a2a:	89 10                	mov    %edx,(%eax)
f0123a2c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0123a2f:	8b 00                	mov    (%eax),%eax
f0123a31:	85 c0                	test   %eax,%eax
f0123a33:	74 0b                	je     f0123a40 <alloc_block_BF+0x411>
f0123a35:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123a38:	8b 00                	mov    (%eax),%eax
f0123a3a:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0123a3d:	89 50 04             	mov    %edx,0x4(%eax)
f0123a40:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123a43:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0123a46:	89 10                	mov    %edx,(%eax)
f0123a48:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0123a4b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0123a4e:	89 50 04             	mov    %edx,0x4(%eax)
f0123a51:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0123a54:	8b 00                	mov    (%eax),%eax
f0123a56:	85 c0                	test   %eax,%eax
f0123a58:	75 08                	jne    f0123a62 <alloc_block_BF+0x433>
f0123a5a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0123a5d:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0123a62:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123a67:	40                   	inc    %eax
f0123a68:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f0123a6d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0123a71:	75 17                	jne    f0123a8a <alloc_block_BF+0x45b>
f0123a73:	83 ec 04             	sub    $0x4,%esp
f0123a76:	68 57 0e 13 f0       	push   $0xf0130e57
f0123a7b:	68 4c 01 00 00       	push   $0x14c
f0123a80:	68 75 0e 13 f0       	push   $0xf0130e75
f0123a85:	e8 90 c8 fd ff       	call   f010031a <_panic>
f0123a8a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123a8d:	8b 00                	mov    (%eax),%eax
f0123a8f:	85 c0                	test   %eax,%eax
f0123a91:	74 10                	je     f0123aa3 <alloc_block_BF+0x474>
f0123a93:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123a96:	8b 00                	mov    (%eax),%eax
f0123a98:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0123a9b:	8b 52 04             	mov    0x4(%edx),%edx
f0123a9e:	89 50 04             	mov    %edx,0x4(%eax)
f0123aa1:	eb 0b                	jmp    f0123aae <alloc_block_BF+0x47f>
f0123aa3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123aa6:	8b 40 04             	mov    0x4(%eax),%eax
f0123aa9:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0123aae:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123ab1:	8b 40 04             	mov    0x4(%eax),%eax
f0123ab4:	85 c0                	test   %eax,%eax
f0123ab6:	74 0f                	je     f0123ac7 <alloc_block_BF+0x498>
f0123ab8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123abb:	8b 40 04             	mov    0x4(%eax),%eax
f0123abe:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0123ac1:	8b 12                	mov    (%edx),%edx
f0123ac3:	89 10                	mov    %edx,(%eax)
f0123ac5:	eb 0a                	jmp    f0123ad1 <alloc_block_BF+0x4a2>
f0123ac7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123aca:	8b 00                	mov    (%eax),%eax
f0123acc:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0123ad1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123ad4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123ada:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123add:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123ae4:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123ae9:	48                   	dec    %eax
f0123aea:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
			set_block_data(new_block_va, remaining_size, 0);
f0123aef:	83 ec 04             	sub    $0x4,%esp
f0123af2:	6a 00                	push   $0x0
f0123af4:	ff 75 c0             	pushl  -0x40(%ebp)
f0123af7:	ff 75 bc             	pushl  -0x44(%ebp)
f0123afa:	e8 bd f6 ff ff       	call   f01231bc <set_block_data>
f0123aff:	83 c4 10             	add    $0x10,%esp
			return best_va;
f0123b02:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123b05:	e9 46 01 00 00       	jmp    f0123c50 <alloc_block_BF+0x621>
	}
	else if(internal == 1)
f0123b0a:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0123b0e:	0f 85 cb 00 00 00    	jne    f0123bdf <alloc_block_BF+0x5b0>
	{

		cprintf("291\n");
f0123b14:	83 ec 0c             	sub    $0xc,%esp
f0123b17:	68 3c 0f 13 f0       	push   $0xf0130f3c
f0123b1c:	e8 4b d4 fd ff       	call   f0100f6c <cprintf>
f0123b21:	83 c4 10             	add    $0x10,%esp
		set_block_data(best_va, best_blk_size, 1);
f0123b24:	83 ec 04             	sub    $0x4,%esp
f0123b27:	6a 01                	push   $0x1
f0123b29:	ff 75 dc             	pushl  -0x24(%ebp)
f0123b2c:	ff 75 e0             	pushl  -0x20(%ebp)
f0123b2f:	e8 88 f6 ff ff       	call   f01231bc <set_block_data>
f0123b34:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f0123b37:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0123b3b:	75 17                	jne    f0123b54 <alloc_block_BF+0x525>
f0123b3d:	83 ec 04             	sub    $0x4,%esp
f0123b40:	68 57 0e 13 f0       	push   $0xf0130e57
f0123b45:	68 55 01 00 00       	push   $0x155
f0123b4a:	68 75 0e 13 f0       	push   $0xf0130e75
f0123b4f:	e8 c6 c7 fd ff       	call   f010031a <_panic>
f0123b54:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123b57:	8b 00                	mov    (%eax),%eax
f0123b59:	85 c0                	test   %eax,%eax
f0123b5b:	74 10                	je     f0123b6d <alloc_block_BF+0x53e>
f0123b5d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123b60:	8b 00                	mov    (%eax),%eax
f0123b62:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0123b65:	8b 52 04             	mov    0x4(%edx),%edx
f0123b68:	89 50 04             	mov    %edx,0x4(%eax)
f0123b6b:	eb 0b                	jmp    f0123b78 <alloc_block_BF+0x549>
f0123b6d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123b70:	8b 40 04             	mov    0x4(%eax),%eax
f0123b73:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0123b78:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123b7b:	8b 40 04             	mov    0x4(%eax),%eax
f0123b7e:	85 c0                	test   %eax,%eax
f0123b80:	74 0f                	je     f0123b91 <alloc_block_BF+0x562>
f0123b82:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123b85:	8b 40 04             	mov    0x4(%eax),%eax
f0123b88:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0123b8b:	8b 12                	mov    (%edx),%edx
f0123b8d:	89 10                	mov    %edx,(%eax)
f0123b8f:	eb 0a                	jmp    f0123b9b <alloc_block_BF+0x56c>
f0123b91:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123b94:	8b 00                	mov    (%eax),%eax
f0123b96:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0123b9b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123b9e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123ba4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123ba7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123bae:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123bb3:	48                   	dec    %eax
f0123bb4:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
		print_blocks_list(freeBlocksList);
f0123bb9:	83 ec 10             	sub    $0x10,%esp
f0123bbc:	89 e0                	mov    %esp,%eax
f0123bbe:	89 c2                	mov    %eax,%edx
f0123bc0:	bb 50 1f 5a f0       	mov    $0xf05a1f50,%ebx
f0123bc5:	b8 04 00 00 00       	mov    $0x4,%eax
f0123bca:	89 d7                	mov    %edx,%edi
f0123bcc:	89 de                	mov    %ebx,%esi
f0123bce:	89 c1                	mov    %eax,%ecx
f0123bd0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0123bd2:	e8 66 f3 ff ff       	call   f0122f3d <print_blocks_list>
f0123bd7:	83 c4 10             	add    $0x10,%esp
		return best_va;
f0123bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123bdd:	eb 71                	jmp    f0123c50 <alloc_block_BF+0x621>

	}
	cprintf("sbrk\n");
f0123bdf:	83 ec 0c             	sub    $0xc,%esp
f0123be2:	68 46 0f 13 f0       	push   $0xf0130f46
f0123be7:	e8 80 d3 fd ff       	call   f0100f6c <cprintf>
f0123bec:	83 c4 10             	add    $0x10,%esp
	uint32 required_size = size + 2 * sizeof(uint32);
f0123bef:	8b 45 08             	mov    0x8(%ebp),%eax
f0123bf2:	83 c0 08             	add    $0x8,%eax
f0123bf5:	89 45 b8             	mov    %eax,-0x48(%ebp)
	void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0123bf8:	c7 45 b4 00 10 00 00 	movl   $0x1000,-0x4c(%ebp)
f0123bff:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0123c02:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0123c05:	01 d0                	add    %edx,%eax
f0123c07:	48                   	dec    %eax
f0123c08:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0123c0b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0123c0e:	ba 00 00 00 00       	mov    $0x0,%edx
f0123c13:	f7 75 b4             	divl   -0x4c(%ebp)
f0123c16:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0123c19:	29 d0                	sub    %edx,%eax
f0123c1b:	c1 e8 0c             	shr    $0xc,%eax
f0123c1e:	83 ec 0c             	sub    $0xc,%esp
f0123c21:	50                   	push   %eax
f0123c22:	e8 5a 4e fe ff       	call   f0108a81 <sbrk>
f0123c27:	83 c4 10             	add    $0x10,%esp
f0123c2a:	89 45 ac             	mov    %eax,-0x54(%ebp)
	if (new_mem == (void *)-1) {
f0123c2d:	83 7d ac ff          	cmpl   $0xffffffff,-0x54(%ebp)
f0123c31:	75 07                	jne    f0123c3a <alloc_block_BF+0x60b>
		return NULL; // Allocation failed
f0123c33:	b8 00 00 00 00       	mov    $0x0,%eax
f0123c38:	eb 16                	jmp    f0123c50 <alloc_block_BF+0x621>
	}
	set_block_data(new_mem, required_size, 1);
f0123c3a:	83 ec 04             	sub    $0x4,%esp
f0123c3d:	6a 01                	push   $0x1
f0123c3f:	ff 75 b8             	pushl  -0x48(%ebp)
f0123c42:	ff 75 ac             	pushl  -0x54(%ebp)
f0123c45:	e8 72 f5 ff ff       	call   f01231bc <set_block_data>
f0123c4a:	83 c4 10             	add    $0x10,%esp
	return new_mem;
f0123c4d:	8b 45 ac             	mov    -0x54(%ebp),%eax
}
f0123c50:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0123c53:	5b                   	pop    %ebx
f0123c54:	5e                   	pop    %esi
f0123c55:	5f                   	pop    %edi
f0123c56:	5d                   	pop    %ebp
f0123c57:	c3                   	ret    

f0123c58 <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f0123c58:	55                   	push   %ebp
f0123c59:	89 e5                	mov    %esp,%ebp
f0123c5b:	53                   	push   %ebx
f0123c5c:	83 ec 24             	sub    $0x24,%esp
//	cprintf("273\n");
	bool prev_is_free = 0, next_is_free = 0;
f0123c5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0123c66:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f0123c6d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123c71:	74 1e                	je     f0123c91 <merging+0x39>
f0123c73:	ff 75 08             	pushl  0x8(%ebp)
f0123c76:	e8 fc f1 ff ff       	call   f0122e77 <get_block_size>
f0123c7b:	83 c4 04             	add    $0x4,%esp
f0123c7e:	89 c2                	mov    %eax,%edx
f0123c80:	8b 45 08             	mov    0x8(%ebp),%eax
f0123c83:	01 d0                	add    %edx,%eax
f0123c85:	3b 45 10             	cmp    0x10(%ebp),%eax
f0123c88:	75 07                	jne    f0123c91 <merging+0x39>
//		cprintf("276\n");
		prev_is_free = 1;
f0123c8a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f0123c91:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0123c95:	74 1e                	je     f0123cb5 <merging+0x5d>
f0123c97:	ff 75 10             	pushl  0x10(%ebp)
f0123c9a:	e8 d8 f1 ff ff       	call   f0122e77 <get_block_size>
f0123c9f:	83 c4 04             	add    $0x4,%esp
f0123ca2:	89 c2                	mov    %eax,%edx
f0123ca4:	8b 45 10             	mov    0x10(%ebp),%eax
f0123ca7:	01 d0                	add    %edx,%eax
f0123ca9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0123cac:	75 07                	jne    f0123cb5 <merging+0x5d>
		next_is_free = 1;
f0123cae:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}


	if(prev_is_free && next_is_free)
f0123cb5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123cb9:	0f 84 cc 00 00 00    	je     f0123d8b <merging+0x133>
f0123cbf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0123cc3:	0f 84 c2 00 00 00    	je     f0123d8b <merging+0x133>
	{
//		cprintf("284\n");
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f0123cc9:	ff 75 08             	pushl  0x8(%ebp)
f0123ccc:	e8 a6 f1 ff ff       	call   f0122e77 <get_block_size>
f0123cd1:	83 c4 04             	add    $0x4,%esp
f0123cd4:	89 c3                	mov    %eax,%ebx
f0123cd6:	ff 75 10             	pushl  0x10(%ebp)
f0123cd9:	e8 99 f1 ff ff       	call   f0122e77 <get_block_size>
f0123cde:	83 c4 04             	add    $0x4,%esp
f0123ce1:	01 c3                	add    %eax,%ebx
f0123ce3:	ff 75 0c             	pushl  0xc(%ebp)
f0123ce6:	e8 8c f1 ff ff       	call   f0122e77 <get_block_size>
f0123ceb:	83 c4 04             	add    $0x4,%esp
f0123cee:	01 d8                	add    %ebx,%eax
f0123cf0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0123cf3:	6a 00                	push   $0x0
f0123cf5:	ff 75 ec             	pushl  -0x14(%ebp)
f0123cf8:	ff 75 08             	pushl  0x8(%ebp)
f0123cfb:	e8 bc f4 ff ff       	call   f01231bc <set_block_data>
f0123d00:	83 c4 0c             	add    $0xc,%esp


		LIST_REMOVE(&freeBlocksList, next_block);
f0123d03:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0123d07:	75 17                	jne    f0123d20 <merging+0xc8>
f0123d09:	83 ec 04             	sub    $0x4,%esp
f0123d0c:	68 57 0e 13 f0       	push   $0xf0130e57
f0123d11:	68 7c 01 00 00       	push   $0x17c
f0123d16:	68 75 0e 13 f0       	push   $0xf0130e75
f0123d1b:	e8 fa c5 fd ff       	call   f010031a <_panic>
f0123d20:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123d23:	8b 00                	mov    (%eax),%eax
f0123d25:	85 c0                	test   %eax,%eax
f0123d27:	74 10                	je     f0123d39 <merging+0xe1>
f0123d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123d2c:	8b 00                	mov    (%eax),%eax
f0123d2e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0123d31:	8b 52 04             	mov    0x4(%edx),%edx
f0123d34:	89 50 04             	mov    %edx,0x4(%eax)
f0123d37:	eb 0b                	jmp    f0123d44 <merging+0xec>
f0123d39:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123d3c:	8b 40 04             	mov    0x4(%eax),%eax
f0123d3f:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0123d44:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123d47:	8b 40 04             	mov    0x4(%eax),%eax
f0123d4a:	85 c0                	test   %eax,%eax
f0123d4c:	74 0f                	je     f0123d5d <merging+0x105>
f0123d4e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123d51:	8b 40 04             	mov    0x4(%eax),%eax
f0123d54:	8b 55 0c             	mov    0xc(%ebp),%edx
f0123d57:	8b 12                	mov    (%edx),%edx
f0123d59:	89 10                	mov    %edx,(%eax)
f0123d5b:	eb 0a                	jmp    f0123d67 <merging+0x10f>
f0123d5d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123d60:	8b 00                	mov    (%eax),%eax
f0123d62:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0123d67:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123d6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123d73:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123d7a:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123d7f:	48                   	dec    %eax
f0123d80:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
		next_is_free = 1;
	}


	if(prev_is_free && next_is_free)
	{
f0123d85:	90                   	nop
		else {
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0123d86:	e9 ea 02 00 00       	jmp    f0124075 <merging+0x41d>
		set_block_data(prev_block, new_block_size, 0);


		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f0123d8b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123d8f:	74 3b                	je     f0123dcc <merging+0x174>
	{
//		cprintf("299\n");
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f0123d91:	83 ec 0c             	sub    $0xc,%esp
f0123d94:	ff 75 08             	pushl  0x8(%ebp)
f0123d97:	e8 db f0 ff ff       	call   f0122e77 <get_block_size>
f0123d9c:	83 c4 10             	add    $0x10,%esp
f0123d9f:	89 c3                	mov    %eax,%ebx
f0123da1:	83 ec 0c             	sub    $0xc,%esp
f0123da4:	ff 75 10             	pushl  0x10(%ebp)
f0123da7:	e8 cb f0 ff ff       	call   f0122e77 <get_block_size>
f0123dac:	83 c4 10             	add    $0x10,%esp
f0123daf:	01 d8                	add    %ebx,%eax
f0123db1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0123db4:	83 ec 04             	sub    $0x4,%esp
f0123db7:	6a 00                	push   $0x0
f0123db9:	ff 75 e8             	pushl  -0x18(%ebp)
f0123dbc:	ff 75 08             	pushl  0x8(%ebp)
f0123dbf:	e8 f8 f3 ff ff       	call   f01231bc <set_block_data>
f0123dc4:	83 c4 10             	add    $0x10,%esp
		else {
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0123dc7:	e9 a9 02 00 00       	jmp    f0124075 <merging+0x41d>
//		cprintf("299\n");
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f0123dcc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0123dd0:	0f 84 2d 01 00 00    	je     f0123f03 <merging+0x2ab>
	{
//		cprintf("306\n");
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f0123dd6:	83 ec 0c             	sub    $0xc,%esp
f0123dd9:	ff 75 10             	pushl  0x10(%ebp)
f0123ddc:	e8 96 f0 ff ff       	call   f0122e77 <get_block_size>
f0123de1:	83 c4 10             	add    $0x10,%esp
f0123de4:	89 c3                	mov    %eax,%ebx
f0123de6:	83 ec 0c             	sub    $0xc,%esp
f0123de9:	ff 75 0c             	pushl  0xc(%ebp)
f0123dec:	e8 86 f0 ff ff       	call   f0122e77 <get_block_size>
f0123df1:	83 c4 10             	add    $0x10,%esp
f0123df4:	01 d8                	add    %ebx,%eax
f0123df6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f0123df9:	83 ec 04             	sub    $0x4,%esp
f0123dfc:	6a 00                	push   $0x0
f0123dfe:	ff 75 e4             	pushl  -0x1c(%ebp)
f0123e01:	ff 75 10             	pushl  0x10(%ebp)
f0123e04:	e8 b3 f3 ff ff       	call   f01231bc <set_block_data>
f0123e09:	83 c4 10             	add    $0x10,%esp


		struct BlockElement *va_block = (struct BlockElement *)va;
f0123e0c:	8b 45 10             	mov    0x10(%ebp),%eax
f0123e0f:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f0123e12:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0123e16:	74 06                	je     f0123e1e <merging+0x1c6>
f0123e18:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0123e1c:	75 17                	jne    f0123e35 <merging+0x1dd>
f0123e1e:	83 ec 04             	sub    $0x4,%esp
f0123e21:	68 4c 0f 13 f0       	push   $0xf0130f4c
f0123e26:	68 8f 01 00 00       	push   $0x18f
f0123e2b:	68 75 0e 13 f0       	push   $0xf0130e75
f0123e30:	e8 e5 c4 fd ff       	call   f010031a <_panic>
f0123e35:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123e38:	8b 50 04             	mov    0x4(%eax),%edx
f0123e3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123e3e:	89 50 04             	mov    %edx,0x4(%eax)
f0123e41:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123e44:	8b 55 0c             	mov    0xc(%ebp),%edx
f0123e47:	89 10                	mov    %edx,(%eax)
f0123e49:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123e4c:	8b 40 04             	mov    0x4(%eax),%eax
f0123e4f:	85 c0                	test   %eax,%eax
f0123e51:	74 0d                	je     f0123e60 <merging+0x208>
f0123e53:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123e56:	8b 40 04             	mov    0x4(%eax),%eax
f0123e59:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0123e5c:	89 10                	mov    %edx,(%eax)
f0123e5e:	eb 08                	jmp    f0123e68 <merging+0x210>
f0123e60:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123e63:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0123e68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123e6b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0123e6e:	89 50 04             	mov    %edx,0x4(%eax)
f0123e71:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123e76:	40                   	inc    %eax
f0123e77:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
		LIST_REMOVE(&freeBlocksList, next_block);
f0123e7c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0123e80:	75 17                	jne    f0123e99 <merging+0x241>
f0123e82:	83 ec 04             	sub    $0x4,%esp
f0123e85:	68 57 0e 13 f0       	push   $0xf0130e57
f0123e8a:	68 90 01 00 00       	push   $0x190
f0123e8f:	68 75 0e 13 f0       	push   $0xf0130e75
f0123e94:	e8 81 c4 fd ff       	call   f010031a <_panic>
f0123e99:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123e9c:	8b 00                	mov    (%eax),%eax
f0123e9e:	85 c0                	test   %eax,%eax
f0123ea0:	74 10                	je     f0123eb2 <merging+0x25a>
f0123ea2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123ea5:	8b 00                	mov    (%eax),%eax
f0123ea7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0123eaa:	8b 52 04             	mov    0x4(%edx),%edx
f0123ead:	89 50 04             	mov    %edx,0x4(%eax)
f0123eb0:	eb 0b                	jmp    f0123ebd <merging+0x265>
f0123eb2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123eb5:	8b 40 04             	mov    0x4(%eax),%eax
f0123eb8:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0123ebd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123ec0:	8b 40 04             	mov    0x4(%eax),%eax
f0123ec3:	85 c0                	test   %eax,%eax
f0123ec5:	74 0f                	je     f0123ed6 <merging+0x27e>
f0123ec7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123eca:	8b 40 04             	mov    0x4(%eax),%eax
f0123ecd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0123ed0:	8b 12                	mov    (%edx),%edx
f0123ed2:	89 10                	mov    %edx,(%eax)
f0123ed4:	eb 0a                	jmp    f0123ee0 <merging+0x288>
f0123ed6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123ed9:	8b 00                	mov    (%eax),%eax
f0123edb:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0123ee0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123ee3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123ee9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123eec:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123ef3:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123ef8:	48                   	dec    %eax
f0123ef9:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
		else {
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0123efe:	e9 72 01 00 00       	jmp    f0124075 <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f0123f03:	8b 45 10             	mov    0x10(%ebp),%eax
f0123f06:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f0123f09:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123f0d:	74 79                	je     f0123f88 <merging+0x330>
f0123f0f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0123f13:	74 73                	je     f0123f88 <merging+0x330>
f0123f15:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123f19:	74 06                	je     f0123f21 <merging+0x2c9>
f0123f1b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0123f1f:	75 17                	jne    f0123f38 <merging+0x2e0>
f0123f21:	83 ec 04             	sub    $0x4,%esp
f0123f24:	68 e8 0e 13 f0       	push   $0xf0130ee8
f0123f29:	68 96 01 00 00       	push   $0x196
f0123f2e:	68 75 0e 13 f0       	push   $0xf0130e75
f0123f33:	e8 e2 c3 fd ff       	call   f010031a <_panic>
f0123f38:	8b 45 08             	mov    0x8(%ebp),%eax
f0123f3b:	8b 10                	mov    (%eax),%edx
f0123f3d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123f40:	89 10                	mov    %edx,(%eax)
f0123f42:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123f45:	8b 00                	mov    (%eax),%eax
f0123f47:	85 c0                	test   %eax,%eax
f0123f49:	74 0b                	je     f0123f56 <merging+0x2fe>
f0123f4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0123f4e:	8b 00                	mov    (%eax),%eax
f0123f50:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123f53:	89 50 04             	mov    %edx,0x4(%eax)
f0123f56:	8b 45 08             	mov    0x8(%ebp),%eax
f0123f59:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123f5c:	89 10                	mov    %edx,(%eax)
f0123f5e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123f61:	8b 55 08             	mov    0x8(%ebp),%edx
f0123f64:	89 50 04             	mov    %edx,0x4(%eax)
f0123f67:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123f6a:	8b 00                	mov    (%eax),%eax
f0123f6c:	85 c0                	test   %eax,%eax
f0123f6e:	75 08                	jne    f0123f78 <merging+0x320>
f0123f70:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123f73:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0123f78:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123f7d:	40                   	inc    %eax
f0123f7e:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
f0123f83:	e9 ce 00 00 00       	jmp    f0124056 <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f0123f88:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123f8c:	74 65                	je     f0123ff3 <merging+0x39b>
f0123f8e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0123f92:	75 17                	jne    f0123fab <merging+0x353>
f0123f94:	83 ec 04             	sub    $0x4,%esp
f0123f97:	68 c4 0e 13 f0       	push   $0xf0130ec4
f0123f9c:	68 97 01 00 00       	push   $0x197
f0123fa1:	68 75 0e 13 f0       	push   $0xf0130e75
f0123fa6:	e8 6f c3 fd ff       	call   f010031a <_panic>
f0123fab:	8b 15 54 1f 5a f0    	mov    0xf05a1f54,%edx
f0123fb1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123fb4:	89 50 04             	mov    %edx,0x4(%eax)
f0123fb7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123fba:	8b 40 04             	mov    0x4(%eax),%eax
f0123fbd:	85 c0                	test   %eax,%eax
f0123fbf:	74 0c                	je     f0123fcd <merging+0x375>
f0123fc1:	a1 54 1f 5a f0       	mov    0xf05a1f54,%eax
f0123fc6:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123fc9:	89 10                	mov    %edx,(%eax)
f0123fcb:	eb 08                	jmp    f0123fd5 <merging+0x37d>
f0123fcd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123fd0:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0123fd5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123fd8:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0123fdd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0123fe0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123fe6:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0123feb:	40                   	inc    %eax
f0123fec:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
f0123ff1:	eb 63                	jmp    f0124056 <merging+0x3fe>
		else {
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f0123ff3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0123ff7:	75 17                	jne    f0124010 <merging+0x3b8>
f0123ff9:	83 ec 04             	sub    $0x4,%esp
f0123ffc:	68 90 0e 13 f0       	push   $0xf0130e90
f0124001:	68 99 01 00 00       	push   $0x199
f0124006:	68 75 0e 13 f0       	push   $0xf0130e75
f012400b:	e8 0a c3 fd ff       	call   f010031a <_panic>
f0124010:	8b 15 50 1f 5a f0    	mov    0xf05a1f50,%edx
f0124016:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0124019:	89 10                	mov    %edx,(%eax)
f012401b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012401e:	8b 00                	mov    (%eax),%eax
f0124020:	85 c0                	test   %eax,%eax
f0124022:	74 0d                	je     f0124031 <merging+0x3d9>
f0124024:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f0124029:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012402c:	89 50 04             	mov    %edx,0x4(%eax)
f012402f:	eb 08                	jmp    f0124039 <merging+0x3e1>
f0124031:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0124034:	a3 54 1f 5a f0       	mov    %eax,0xf05a1f54
f0124039:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012403c:	a3 50 1f 5a f0       	mov    %eax,0xf05a1f50
f0124041:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0124044:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012404b:	a1 5c 1f 5a f0       	mov    0xf05a1f5c,%eax
f0124050:	40                   	inc    %eax
f0124051:	a3 5c 1f 5a f0       	mov    %eax,0xf05a1f5c
		}
		set_block_data(va, get_block_size(va), 0);
f0124056:	83 ec 0c             	sub    $0xc,%esp
f0124059:	ff 75 10             	pushl  0x10(%ebp)
f012405c:	e8 16 ee ff ff       	call   f0122e77 <get_block_size>
f0124061:	83 c4 10             	add    $0x10,%esp
f0124064:	83 ec 04             	sub    $0x4,%esp
f0124067:	6a 00                	push   $0x0
f0124069:	50                   	push   %eax
f012406a:	ff 75 10             	pushl  0x10(%ebp)
f012406d:	e8 4a f1 ff ff       	call   f01231bc <set_block_data>
f0124072:	83 c4 10             	add    $0x10,%esp
	}
}
f0124075:	90                   	nop
f0124076:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0124079:	c9                   	leave  
f012407a:	c3                   	ret    

f012407b <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f012407b:	55                   	push   %ebp
f012407c:	89 e5                	mov    %esp,%ebp
f012407e:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f0124081:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f0124086:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f0124089:	a1 54 1f 5a f0       	mov    0xf05a1f54,%eax
f012408e:	3b 45 08             	cmp    0x8(%ebp),%eax
f0124091:	73 1b                	jae    f01240ae <free_block+0x33>
//		cprintf("363\n");
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f0124093:	a1 54 1f 5a f0       	mov    0xf05a1f54,%eax
f0124098:	83 ec 04             	sub    $0x4,%esp
f012409b:	ff 75 08             	pushl  0x8(%ebp)
f012409e:	6a 00                	push   $0x0
f01240a0:	50                   	push   %eax
f01240a1:	e8 b2 fb ff ff       	call   f0123c58 <merging>
f01240a6:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01240a9:	e9 8b 00 00 00       	jmp    f0124139 <free_block+0xbe>

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
//		cprintf("363\n");
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f01240ae:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f01240b3:	3b 45 08             	cmp    0x8(%ebp),%eax
f01240b6:	76 18                	jbe    f01240d0 <free_block+0x55>
//		cprintf("367\n");
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f01240b8:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f01240bd:	83 ec 04             	sub    $0x4,%esp
f01240c0:	ff 75 08             	pushl  0x8(%ebp)
f01240c3:	50                   	push   %eax
f01240c4:	6a 00                	push   $0x0
f01240c6:	e8 8d fb ff ff       	call   f0123c58 <merging>
f01240cb:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01240ce:	eb 69                	jmp    f0124139 <free_block+0xbe>
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
//		cprintf("367\n");
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f01240d0:	a1 50 1f 5a f0       	mov    0xf05a1f50,%eax
f01240d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01240d8:	eb 39                	jmp    f0124113 <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f01240da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01240dd:	3b 45 08             	cmp    0x8(%ebp),%eax
f01240e0:	73 29                	jae    f012410b <free_block+0x90>
f01240e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01240e5:	8b 00                	mov    (%eax),%eax
f01240e7:	3b 45 08             	cmp    0x8(%ebp),%eax
f01240ea:	76 1f                	jbe    f012410b <free_block+0x90>
//			cprintf("376\n");
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f01240ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01240ef:	8b 00                	mov    (%eax),%eax
f01240f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f01240f4:	83 ec 04             	sub    $0x4,%esp
f01240f7:	ff 75 08             	pushl  0x8(%ebp)
f01240fa:	ff 75 f0             	pushl  -0x10(%ebp)
f01240fd:	ff 75 f4             	pushl  -0xc(%ebp)
f0124100:	e8 53 fb ff ff       	call   f0123c58 <merging>
f0124105:	83 c4 10             	add    $0x10,%esp
			break;
f0124108:	90                   	nop
		}
	}
}
f0124109:	eb 2e                	jmp    f0124139 <free_block+0xbe>
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
//		cprintf("367\n");
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f012410b:	a1 58 1f 5a f0       	mov    0xf05a1f58,%eax
f0124110:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0124113:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0124117:	74 07                	je     f0124120 <free_block+0xa5>
f0124119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012411c:	8b 00                	mov    (%eax),%eax
f012411e:	eb 05                	jmp    f0124125 <free_block+0xaa>
f0124120:	b8 00 00 00 00       	mov    $0x0,%eax
f0124125:	a3 58 1f 5a f0       	mov    %eax,0xf05a1f58
f012412a:	a1 58 1f 5a f0       	mov    0xf05a1f58,%eax
f012412f:	85 c0                	test   %eax,%eax
f0124131:	75 a7                	jne    f01240da <free_block+0x5f>
f0124133:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0124137:	75 a1                	jne    f01240da <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0124139:	90                   	nop
f012413a:	c9                   	leave  
f012413b:	c3                   	ret    

f012413c <realloc_block_FF>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *realloc_block_FF(void* va, uint32 new_size)
{
f012413c:	55                   	push   %ebp
f012413d:	89 e5                	mov    %esp,%ebp
f012413f:	83 ec 48             	sub    $0x48,%esp


	/*any address or size saved in header or footer are in single Bytes*/


	if(va == NULL)
f0124142:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0124146:	75 23                	jne    f012416b <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f0124148:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012414c:	74 13                	je     f0124161 <realloc_block_FF+0x25>
f012414e:	83 ec 0c             	sub    $0xc,%esp
f0124151:	ff 75 0c             	pushl  0xc(%ebp)
f0124154:	e8 92 f0 ff ff       	call   f01231eb <alloc_block_FF>
f0124159:	83 c4 10             	add    $0x10,%esp
f012415c:	e9 0a 02 00 00       	jmp    f012436b <realloc_block_FF+0x22f>
		return NULL;
f0124161:	b8 00 00 00 00       	mov    $0x0,%eax
f0124166:	e9 00 02 00 00       	jmp    f012436b <realloc_block_FF+0x22f>
	}

	if(new_size == 0)
f012416b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012416f:	75 18                	jne    f0124189 <realloc_block_FF+0x4d>
	{
		free_block(va);
f0124171:	83 ec 0c             	sub    $0xc,%esp
f0124174:	ff 75 08             	pushl  0x8(%ebp)
f0124177:	e8 ff fe ff ff       	call   f012407b <free_block>
f012417c:	83 c4 10             	add    $0x10,%esp
		return NULL;
f012417f:	b8 00 00 00 00       	mov    $0x0,%eax
f0124184:	e9 e2 01 00 00       	jmp    f012436b <realloc_block_FF+0x22f>
	}


	new_size = ROUNDUP(new_size, 8);
f0124189:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
f0124190:	8b 55 0c             	mov    0xc(%ebp),%edx
f0124193:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0124196:	01 d0                	add    %edx,%eax
f0124198:	48                   	dec    %eax
f0124199:	89 45 f0             	mov    %eax,-0x10(%ebp)
f012419c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012419f:	ba 00 00 00 00       	mov    $0x0,%edx
f01241a4:	f7 75 f4             	divl   -0xc(%ebp)
f01241a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01241aa:	29 d0                	sub    %edx,%eax
f01241ac:	89 45 0c             	mov    %eax,0xc(%ebp)
	//uint32 new_new_size = new_size + new_size%2);
	new_size += (new_size%2);
f01241af:	8b 45 0c             	mov    0xc(%ebp),%eax
f01241b2:	83 e0 01             	and    $0x1,%eax
f01241b5:	01 45 0c             	add    %eax,0xc(%ebp)
	uint32 newBloc_size = new_size + 8;
f01241b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01241bb:	83 c0 08             	add    $0x8,%eax
f01241be:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//cur Block data
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f01241c1:	83 ec 0c             	sub    $0xc,%esp
f01241c4:	ff 75 08             	pushl  0x8(%ebp)
f01241c7:	e8 ab ec ff ff       	call   f0122e77 <get_block_size>
f01241cc:	83 c4 10             	add    $0x10,%esp
f01241cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f01241d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01241d5:	83 e8 08             	sub    $0x8,%eax
f01241d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	//next Block data
	void *next_cur_va = (void *)(va + curBLOCK_size);
f01241db:	8b 55 08             	mov    0x8(%ebp),%edx
f01241de:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01241e1:	01 d0                	add    %edx,%eax
f01241e3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_cur_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f01241e6:	83 ec 0c             	sub    $0xc,%esp
f01241e9:	ff 75 e0             	pushl  -0x20(%ebp)
f01241ec:	e8 86 ec ff ff       	call   f0122e77 <get_block_size>
f01241f1:	83 c4 10             	add    $0x10,%esp
f01241f4:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f01241f7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01241fa:	83 e8 08             	sub    $0x8,%eax
f01241fd:	89 45 d8             	mov    %eax,-0x28(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size) return va;
f0124200:	8b 45 0c             	mov    0xc(%ebp),%eax
f0124203:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0124206:	75 08                	jne    f0124210 <realloc_block_FF+0xd4>
f0124208:	8b 45 08             	mov    0x8(%ebp),%eax
f012420b:	e9 5b 01 00 00       	jmp    f012436b <realloc_block_FF+0x22f>


	if(new_size < cur_size)
f0124210:	8b 45 0c             	mov    0xc(%ebp),%eax
f0124213:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0124216:	0f 83 a2 00 00 00    	jae    f01242be <realloc_block_FF+0x182>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f012421c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012421f:	2b 45 0c             	sub    0xc(%ebp),%eax
f0124222:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if(is_free_block(next_cur_va))
f0124225:	83 ec 0c             	sub    $0xc,%esp
f0124228:	ff 75 e0             	pushl  -0x20(%ebp)
f012422b:	e8 60 ec ff ff       	call   f0122e90 <is_free_block>
f0124230:	83 c4 10             	add    $0x10,%esp
f0124233:	84 c0                	test   %al,%al
f0124235:	74 48                	je     f012427f <realloc_block_FF+0x143>
		{
			uint32 next_new_size = next_cur_size + remaining_size;
f0124237:	8b 55 d8             	mov    -0x28(%ebp),%edx
f012423a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012423d:	01 d0                	add    %edx,%eax
f012423f:	89 45 d0             	mov    %eax,-0x30(%ebp)
			set_block_data(va, newBloc_size, 1);
f0124242:	83 ec 04             	sub    $0x4,%esp
f0124245:	6a 01                	push   $0x1
f0124247:	ff 75 ec             	pushl  -0x14(%ebp)
f012424a:	ff 75 08             	pushl  0x8(%ebp)
f012424d:	e8 6a ef ff ff       	call   f01231bc <set_block_data>
f0124252:	83 c4 10             	add    $0x10,%esp

			void *next_new_va = (void *)(FOOTER(va) + 2);
f0124255:	8b 45 08             	mov    0x8(%ebp),%eax
f0124258:	83 e8 04             	sub    $0x4,%eax
f012425b:	8b 00                	mov    (%eax),%eax
f012425d:	83 e0 fe             	and    $0xfffffffe,%eax
f0124260:	89 c2                	mov    %eax,%edx
f0124262:	8b 45 08             	mov    0x8(%ebp),%eax
f0124265:	01 d0                	add    %edx,%eax
f0124267:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(next_new_va, next_new_size, 0);
f012426a:	83 ec 04             	sub    $0x4,%esp
f012426d:	6a 00                	push   $0x0
f012426f:	ff 75 d0             	pushl  -0x30(%ebp)
f0124272:	ff 75 cc             	pushl  -0x34(%ebp)
f0124275:	e8 42 ef ff ff       	call   f01231bc <set_block_data>
f012427a:	83 c4 10             	add    $0x10,%esp
f012427d:	eb 37                	jmp    f01242b6 <realloc_block_FF+0x17a>

			//still needed edit freeBlocklist
		}
		else
		{
			if(remaining_size>=16)
f012427f:	83 7d d4 0f          	cmpl   $0xf,-0x2c(%ebp)
f0124283:	76 31                	jbe    f01242b6 <realloc_block_FF+0x17a>
			{
				uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
f0124285:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0124288:	83 e8 08             	sub    $0x8,%eax
f012428b:	89 45 c8             	mov    %eax,-0x38(%ebp)
				set_block_data(va, newBloc_size, 1);
f012428e:	83 ec 04             	sub    $0x4,%esp
f0124291:	6a 01                	push   $0x1
f0124293:	ff 75 ec             	pushl  -0x14(%ebp)
f0124296:	ff 75 08             	pushl  0x8(%ebp)
f0124299:	e8 1e ef ff ff       	call   f01231bc <set_block_data>
f012429e:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f01242a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01242a4:	83 e8 04             	sub    $0x4,%eax
f01242a7:	8b 00                	mov    (%eax),%eax
f01242a9:	83 e0 fe             	and    $0xfffffffe,%eax
f01242ac:	89 c2                	mov    %eax,%edx
f01242ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01242b1:	01 d0                	add    %edx,%eax
f01242b3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				//insert new block to free_block_list
				//set_block_data(next_new_va, next_new_size, 0);
			}
		}
		return va;
f01242b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01242b9:	e9 ad 00 00 00       	jmp    f012436b <realloc_block_FF+0x22f>
	}

	else
	{
		if(is_free_block(next_cur_va))
f01242be:	83 ec 0c             	sub    $0xc,%esp
f01242c1:	ff 75 e0             	pushl  -0x20(%ebp)
f01242c4:	e8 c7 eb ff ff       	call   f0122e90 <is_free_block>
f01242c9:	83 c4 10             	add    $0x10,%esp
f01242cc:	84 c0                	test   %al,%al
f01242ce:	74 7f                	je     f012434f <realloc_block_FF+0x213>
		{
			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f01242d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01242d3:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f01242d6:	89 45 c0             	mov    %eax,-0x40(%ebp)
			if(needed_size>nextBLOCK_size) goto new_alloc;
f01242d9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01242dc:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01242df:	77 6d                	ja     f012434e <realloc_block_FF+0x212>
			uint32 remaining_size = nextBLOCK_size - needed_size;
f01242e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01242e4:	2b 45 c0             	sub    -0x40(%ebp),%eax
f01242e7:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16)
f01242ea:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f01242ee:	77 1e                	ja     f012430e <realloc_block_FF+0x1d2>
			{
				//remove from free_block_list, then
				set_block_data(va, cur_size + nextBLOCK_size+8, 1);
f01242f0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01242f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01242f6:	01 d0                	add    %edx,%eax
f01242f8:	83 c0 08             	add    $0x8,%eax
f01242fb:	83 ec 04             	sub    $0x4,%esp
f01242fe:	6a 01                	push   $0x1
f0124300:	50                   	push   %eax
f0124301:	ff 75 08             	pushl  0x8(%ebp)
f0124304:	e8 b3 ee ff ff       	call   f01231bc <set_block_data>
f0124309:	83 c4 10             	add    $0x10,%esp
f012430c:	eb 3b                	jmp    f0124349 <realloc_block_FF+0x20d>
			}
			else
			{
				set_block_data(va, newBloc_size, 1);
f012430e:	83 ec 04             	sub    $0x4,%esp
f0124311:	6a 01                	push   $0x1
f0124313:	ff 75 ec             	pushl  -0x14(%ebp)
f0124316:	ff 75 08             	pushl  0x8(%ebp)
f0124319:	e8 9e ee ff ff       	call   f01231bc <set_block_data>
f012431e:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0124321:	8b 45 08             	mov    0x8(%ebp),%eax
f0124324:	83 e8 04             	sub    $0x4,%eax
f0124327:	8b 00                	mov    (%eax),%eax
f0124329:	83 e0 fe             	and    $0xfffffffe,%eax
f012432c:	89 c2                	mov    %eax,%edx
f012432e:	8b 45 08             	mov    0x8(%ebp),%eax
f0124331:	01 d0                	add    %edx,%eax
f0124333:	89 45 b8             	mov    %eax,-0x48(%ebp)
				//update free_block_list
				set_block_data(next_new_va, remaining_size, 0);
f0124336:	83 ec 04             	sub    $0x4,%esp
f0124339:	6a 00                	push   $0x0
f012433b:	ff 75 bc             	pushl  -0x44(%ebp)
f012433e:	ff 75 b8             	pushl  -0x48(%ebp)
f0124341:	e8 76 ee ff ff       	call   f01231bc <set_block_data>
f0124346:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f0124349:	8b 45 08             	mov    0x8(%ebp),%eax
f012434c:	eb 1d                	jmp    f012436b <realloc_block_FF+0x22f>
	else
	{
		if(is_free_block(next_cur_va))
		{
			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
			if(needed_size>nextBLOCK_size) goto new_alloc;
f012434e:	90                   	nop
			return va;
		}
		//else goto new_alloc;
	}
	new_alloc:
	free_block(va); //set it free
f012434f:	83 ec 0c             	sub    $0xc,%esp
f0124352:	ff 75 08             	pushl  0x8(%ebp)
f0124355:	e8 21 fd ff ff       	call   f012407b <free_block>
f012435a:	83 c4 10             	add    $0x10,%esp
	return alloc_block_FF(new_size); //new allocation
f012435d:	83 ec 0c             	sub    $0xc,%esp
f0124360:	ff 75 0c             	pushl  0xc(%ebp)
f0124363:	e8 83 ee ff ff       	call   f01231eb <alloc_block_FF>
f0124368:	83 c4 10             	add    $0x10,%esp
}
f012436b:	c9                   	leave  
f012436c:	c3                   	ret    

f012436d <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f012436d:	55                   	push   %ebp
f012436e:	89 e5                	mov    %esp,%ebp
f0124370:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0124373:	83 ec 04             	sub    $0x4,%esp
f0124376:	68 84 0f 13 f0       	push   $0xf0130f84
f012437b:	68 28 02 00 00       	push   $0x228
f0124380:	68 75 0e 13 f0       	push   $0xf0130e75
f0124385:	e8 90 bf fd ff       	call   f010031a <_panic>

f012438a <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f012438a:	55                   	push   %ebp
f012438b:	89 e5                	mov    %esp,%ebp
f012438d:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0124390:	83 ec 04             	sub    $0x4,%esp
f0124393:	68 ac 0f 13 f0       	push   $0xf0130fac
f0124398:	68 31 02 00 00       	push   $0x231
f012439d:	68 75 0e 13 f0       	push   $0xf0130e75
f01243a2:	e8 73 bf fd ff       	call   f010031a <_panic>
f01243a7:	90                   	nop

f01243a8 <__moddi3>:
f01243a8:	55                   	push   %ebp
f01243a9:	57                   	push   %edi
f01243aa:	56                   	push   %esi
f01243ab:	53                   	push   %ebx
f01243ac:	83 ec 2c             	sub    $0x2c,%esp
f01243af:	8b 74 24 40          	mov    0x40(%esp),%esi
f01243b3:	8b 7c 24 44          	mov    0x44(%esp),%edi
f01243b7:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f01243bb:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f01243bf:	89 d8                	mov    %ebx,%eax
f01243c1:	85 ff                	test   %edi,%edi
f01243c3:	0f 88 d3 00 00 00    	js     f012449c <__moddi3+0xf4>
f01243c9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f01243d0:	00 
f01243d1:	85 c0                	test   %eax,%eax
f01243d3:	0f 88 ab 00 00 00    	js     f0124484 <__moddi3+0xdc>
f01243d9:	89 0c 24             	mov    %ecx,(%esp)
f01243dc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f01243e0:	89 74 24 10          	mov    %esi,0x10(%esp)
f01243e4:	89 fb                	mov    %edi,%ebx
f01243e6:	8b 14 24             	mov    (%esp),%edx
f01243e9:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f01243ed:	89 d0                	mov    %edx,%eax
f01243ef:	89 54 24 18          	mov    %edx,0x18(%esp)
f01243f3:	89 ca                	mov    %ecx,%edx
f01243f5:	8b 0c 24             	mov    (%esp),%ecx
f01243f8:	89 34 24             	mov    %esi,(%esp)
f01243fb:	89 7c 24 14          	mov    %edi,0x14(%esp)
f01243ff:	85 d2                	test   %edx,%edx
f0124401:	75 15                	jne    f0124418 <__moddi3+0x70>
f0124403:	89 c7                	mov    %eax,%edi
f0124405:	39 d8                	cmp    %ebx,%eax
f0124407:	76 5b                	jbe    f0124464 <__moddi3+0xbc>
f0124409:	89 f0                	mov    %esi,%eax
f012440b:	89 da                	mov    %ebx,%edx
f012440d:	f7 f7                	div    %edi
f012440f:	89 d3                	mov    %edx,%ebx
f0124411:	89 d8                	mov    %ebx,%eax
f0124413:	31 d2                	xor    %edx,%edx
f0124415:	eb 09                	jmp    f0124420 <__moddi3+0x78>
f0124417:	90                   	nop
f0124418:	39 fa                	cmp    %edi,%edx
f012441a:	76 1c                	jbe    f0124438 <__moddi3+0x90>
f012441c:	89 f0                	mov    %esi,%eax
f012441e:	89 fa                	mov    %edi,%edx
f0124420:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0124424:	85 c9                	test   %ecx,%ecx
f0124426:	74 07                	je     f012442f <__moddi3+0x87>
f0124428:	f7 d8                	neg    %eax
f012442a:	83 d2 00             	adc    $0x0,%edx
f012442d:	f7 da                	neg    %edx
f012442f:	83 c4 2c             	add    $0x2c,%esp
f0124432:	5b                   	pop    %ebx
f0124433:	5e                   	pop    %esi
f0124434:	5f                   	pop    %edi
f0124435:	5d                   	pop    %ebp
f0124436:	c3                   	ret    
f0124437:	90                   	nop
f0124438:	0f bd c2             	bsr    %edx,%eax
f012443b:	83 f0 1f             	xor    $0x1f,%eax
f012443e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0124442:	75 6c                	jne    f01244b0 <__moddi3+0x108>
f0124444:	39 fa                	cmp    %edi,%edx
f0124446:	72 05                	jb     f012444d <__moddi3+0xa5>
f0124448:	3b 0c 24             	cmp    (%esp),%ecx
f012444b:	77 0e                	ja     f012445b <__moddi3+0xb3>
f012444d:	8b 34 24             	mov    (%esp),%esi
f0124450:	29 ce                	sub    %ecx,%esi
f0124452:	19 d3                	sbb    %edx,%ebx
f0124454:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0124458:	89 34 24             	mov    %esi,(%esp)
f012445b:	8b 04 24             	mov    (%esp),%eax
f012445e:	8b 54 24 14          	mov    0x14(%esp),%edx
f0124462:	eb bc                	jmp    f0124420 <__moddi3+0x78>
f0124464:	85 c9                	test   %ecx,%ecx
f0124466:	75 0b                	jne    f0124473 <__moddi3+0xcb>
f0124468:	b8 01 00 00 00       	mov    $0x1,%eax
f012446d:	31 d2                	xor    %edx,%edx
f012446f:	f7 f1                	div    %ecx
f0124471:	89 c1                	mov    %eax,%ecx
f0124473:	89 d8                	mov    %ebx,%eax
f0124475:	31 d2                	xor    %edx,%edx
f0124477:	f7 f1                	div    %ecx
f0124479:	8b 04 24             	mov    (%esp),%eax
f012447c:	f7 f1                	div    %ecx
f012447e:	89 d3                	mov    %edx,%ebx
f0124480:	eb 8f                	jmp    f0124411 <__moddi3+0x69>
f0124482:	66 90                	xchg   %ax,%ax
f0124484:	89 c8                	mov    %ecx,%eax
f0124486:	89 da                	mov    %ebx,%edx
f0124488:	f7 d8                	neg    %eax
f012448a:	83 d2 00             	adc    $0x0,%edx
f012448d:	f7 da                	neg    %edx
f012448f:	89 04 24             	mov    %eax,(%esp)
f0124492:	89 54 24 04          	mov    %edx,0x4(%esp)
f0124496:	e9 45 ff ff ff       	jmp    f01243e0 <__moddi3+0x38>
f012449b:	90                   	nop
f012449c:	f7 de                	neg    %esi
f012449e:	83 d7 00             	adc    $0x0,%edi
f01244a1:	f7 df                	neg    %edi
f01244a3:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f01244aa:	ff 
f01244ab:	e9 21 ff ff ff       	jmp    f01243d1 <__moddi3+0x29>
f01244b0:	b8 20 00 00 00       	mov    $0x20,%eax
f01244b5:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f01244b9:	29 f8                	sub    %edi,%eax
f01244bb:	89 c6                	mov    %eax,%esi
f01244bd:	89 44 24 14          	mov    %eax,0x14(%esp)
f01244c1:	89 f9                	mov    %edi,%ecx
f01244c3:	d3 e2                	shl    %cl,%edx
f01244c5:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f01244c9:	89 e8                	mov    %ebp,%eax
f01244cb:	89 f1                	mov    %esi,%ecx
f01244cd:	d3 e8                	shr    %cl,%eax
f01244cf:	09 d0                	or     %edx,%eax
f01244d1:	89 04 24             	mov    %eax,(%esp)
f01244d4:	89 ea                	mov    %ebp,%edx
f01244d6:	89 f9                	mov    %edi,%ecx
f01244d8:	d3 e2                	shl    %cl,%edx
f01244da:	89 d7                	mov    %edx,%edi
f01244dc:	89 da                	mov    %ebx,%edx
f01244de:	d3 e2                	shl    %cl,%edx
f01244e0:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f01244e4:	d3 e5                	shl    %cl,%ebp
f01244e6:	8b 44 24 10          	mov    0x10(%esp),%eax
f01244ea:	89 f1                	mov    %esi,%ecx
f01244ec:	d3 e8                	shr    %cl,%eax
f01244ee:	09 d0                	or     %edx,%eax
f01244f0:	d3 eb                	shr    %cl,%ebx
f01244f2:	89 da                	mov    %ebx,%edx
f01244f4:	f7 34 24             	divl   (%esp)
f01244f7:	89 d3                	mov    %edx,%ebx
f01244f9:	f7 e7                	mul    %edi
f01244fb:	89 c6                	mov    %eax,%esi
f01244fd:	89 d1                	mov    %edx,%ecx
f01244ff:	39 d3                	cmp    %edx,%ebx
f0124501:	72 29                	jb     f012452c <__moddi3+0x184>
f0124503:	74 33                	je     f0124538 <__moddi3+0x190>
f0124505:	89 e8                	mov    %ebp,%eax
f0124507:	29 f0                	sub    %esi,%eax
f0124509:	19 cb                	sbb    %ecx,%ebx
f012450b:	89 de                	mov    %ebx,%esi
f012450d:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0124511:	d3 e6                	shl    %cl,%esi
f0124513:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0124517:	89 f9                	mov    %edi,%ecx
f0124519:	d3 e8                	shr    %cl,%eax
f012451b:	09 c6                	or     %eax,%esi
f012451d:	89 f0                	mov    %esi,%eax
f012451f:	89 f9                	mov    %edi,%ecx
f0124521:	d3 eb                	shr    %cl,%ebx
f0124523:	89 da                	mov    %ebx,%edx
f0124525:	e9 f6 fe ff ff       	jmp    f0124420 <__moddi3+0x78>
f012452a:	66 90                	xchg   %ax,%ax
f012452c:	29 f8                	sub    %edi,%eax
f012452e:	1b 14 24             	sbb    (%esp),%edx
f0124531:	89 d1                	mov    %edx,%ecx
f0124533:	89 c6                	mov    %eax,%esi
f0124535:	eb ce                	jmp    f0124505 <__moddi3+0x15d>
f0124537:	90                   	nop
f0124538:	39 c5                	cmp    %eax,%ebp
f012453a:	72 f0                	jb     f012452c <__moddi3+0x184>
f012453c:	89 d9                	mov    %ebx,%ecx
f012453e:	eb c5                	jmp    f0124505 <__moddi3+0x15d>

f0124540 <__udivdi3>:
f0124540:	55                   	push   %ebp
f0124541:	57                   	push   %edi
f0124542:	56                   	push   %esi
f0124543:	53                   	push   %ebx
f0124544:	83 ec 1c             	sub    $0x1c,%esp
f0124547:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f012454b:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f012454f:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0124553:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f0124557:	89 ca                	mov    %ecx,%edx
f0124559:	89 f8                	mov    %edi,%eax
f012455b:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f012455f:	85 f6                	test   %esi,%esi
f0124561:	75 2d                	jne    f0124590 <__udivdi3+0x50>
f0124563:	39 cf                	cmp    %ecx,%edi
f0124565:	77 65                	ja     f01245cc <__udivdi3+0x8c>
f0124567:	89 fd                	mov    %edi,%ebp
f0124569:	85 ff                	test   %edi,%edi
f012456b:	75 0b                	jne    f0124578 <__udivdi3+0x38>
f012456d:	b8 01 00 00 00       	mov    $0x1,%eax
f0124572:	31 d2                	xor    %edx,%edx
f0124574:	f7 f7                	div    %edi
f0124576:	89 c5                	mov    %eax,%ebp
f0124578:	31 d2                	xor    %edx,%edx
f012457a:	89 c8                	mov    %ecx,%eax
f012457c:	f7 f5                	div    %ebp
f012457e:	89 c1                	mov    %eax,%ecx
f0124580:	89 d8                	mov    %ebx,%eax
f0124582:	f7 f5                	div    %ebp
f0124584:	89 cf                	mov    %ecx,%edi
f0124586:	89 fa                	mov    %edi,%edx
f0124588:	83 c4 1c             	add    $0x1c,%esp
f012458b:	5b                   	pop    %ebx
f012458c:	5e                   	pop    %esi
f012458d:	5f                   	pop    %edi
f012458e:	5d                   	pop    %ebp
f012458f:	c3                   	ret    
f0124590:	39 ce                	cmp    %ecx,%esi
f0124592:	77 28                	ja     f01245bc <__udivdi3+0x7c>
f0124594:	0f bd fe             	bsr    %esi,%edi
f0124597:	83 f7 1f             	xor    $0x1f,%edi
f012459a:	75 40                	jne    f01245dc <__udivdi3+0x9c>
f012459c:	39 ce                	cmp    %ecx,%esi
f012459e:	72 0a                	jb     f01245aa <__udivdi3+0x6a>
f01245a0:	3b 44 24 08          	cmp    0x8(%esp),%eax
f01245a4:	0f 87 9e 00 00 00    	ja     f0124648 <__udivdi3+0x108>
f01245aa:	b8 01 00 00 00       	mov    $0x1,%eax
f01245af:	89 fa                	mov    %edi,%edx
f01245b1:	83 c4 1c             	add    $0x1c,%esp
f01245b4:	5b                   	pop    %ebx
f01245b5:	5e                   	pop    %esi
f01245b6:	5f                   	pop    %edi
f01245b7:	5d                   	pop    %ebp
f01245b8:	c3                   	ret    
f01245b9:	8d 76 00             	lea    0x0(%esi),%esi
f01245bc:	31 ff                	xor    %edi,%edi
f01245be:	31 c0                	xor    %eax,%eax
f01245c0:	89 fa                	mov    %edi,%edx
f01245c2:	83 c4 1c             	add    $0x1c,%esp
f01245c5:	5b                   	pop    %ebx
f01245c6:	5e                   	pop    %esi
f01245c7:	5f                   	pop    %edi
f01245c8:	5d                   	pop    %ebp
f01245c9:	c3                   	ret    
f01245ca:	66 90                	xchg   %ax,%ax
f01245cc:	89 d8                	mov    %ebx,%eax
f01245ce:	f7 f7                	div    %edi
f01245d0:	31 ff                	xor    %edi,%edi
f01245d2:	89 fa                	mov    %edi,%edx
f01245d4:	83 c4 1c             	add    $0x1c,%esp
f01245d7:	5b                   	pop    %ebx
f01245d8:	5e                   	pop    %esi
f01245d9:	5f                   	pop    %edi
f01245da:	5d                   	pop    %ebp
f01245db:	c3                   	ret    
f01245dc:	bd 20 00 00 00       	mov    $0x20,%ebp
f01245e1:	89 eb                	mov    %ebp,%ebx
f01245e3:	29 fb                	sub    %edi,%ebx
f01245e5:	89 f9                	mov    %edi,%ecx
f01245e7:	d3 e6                	shl    %cl,%esi
f01245e9:	89 c5                	mov    %eax,%ebp
f01245eb:	88 d9                	mov    %bl,%cl
f01245ed:	d3 ed                	shr    %cl,%ebp
f01245ef:	89 e9                	mov    %ebp,%ecx
f01245f1:	09 f1                	or     %esi,%ecx
f01245f3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f01245f7:	89 f9                	mov    %edi,%ecx
f01245f9:	d3 e0                	shl    %cl,%eax
f01245fb:	89 c5                	mov    %eax,%ebp
f01245fd:	89 d6                	mov    %edx,%esi
f01245ff:	88 d9                	mov    %bl,%cl
f0124601:	d3 ee                	shr    %cl,%esi
f0124603:	89 f9                	mov    %edi,%ecx
f0124605:	d3 e2                	shl    %cl,%edx
f0124607:	8b 44 24 08          	mov    0x8(%esp),%eax
f012460b:	88 d9                	mov    %bl,%cl
f012460d:	d3 e8                	shr    %cl,%eax
f012460f:	09 c2                	or     %eax,%edx
f0124611:	89 d0                	mov    %edx,%eax
f0124613:	89 f2                	mov    %esi,%edx
f0124615:	f7 74 24 0c          	divl   0xc(%esp)
f0124619:	89 d6                	mov    %edx,%esi
f012461b:	89 c3                	mov    %eax,%ebx
f012461d:	f7 e5                	mul    %ebp
f012461f:	39 d6                	cmp    %edx,%esi
f0124621:	72 19                	jb     f012463c <__udivdi3+0xfc>
f0124623:	74 0b                	je     f0124630 <__udivdi3+0xf0>
f0124625:	89 d8                	mov    %ebx,%eax
f0124627:	31 ff                	xor    %edi,%edi
f0124629:	e9 58 ff ff ff       	jmp    f0124586 <__udivdi3+0x46>
f012462e:	66 90                	xchg   %ax,%ax
f0124630:	8b 54 24 08          	mov    0x8(%esp),%edx
f0124634:	89 f9                	mov    %edi,%ecx
f0124636:	d3 e2                	shl    %cl,%edx
f0124638:	39 c2                	cmp    %eax,%edx
f012463a:	73 e9                	jae    f0124625 <__udivdi3+0xe5>
f012463c:	8d 43 ff             	lea    -0x1(%ebx),%eax
f012463f:	31 ff                	xor    %edi,%edi
f0124641:	e9 40 ff ff ff       	jmp    f0124586 <__udivdi3+0x46>
f0124646:	66 90                	xchg   %ax,%ax
f0124648:	31 c0                	xor    %eax,%eax
f012464a:	e9 37 ff ff ff       	jmp    f0124586 <__udivdi3+0x46>
f012464f:	90                   	nop

f0124650 <__umoddi3>:
f0124650:	55                   	push   %ebp
f0124651:	57                   	push   %edi
f0124652:	56                   	push   %esi
f0124653:	53                   	push   %ebx
f0124654:	83 ec 1c             	sub    $0x1c,%esp
f0124657:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f012465b:	8b 74 24 34          	mov    0x34(%esp),%esi
f012465f:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0124663:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f0124667:	89 44 24 0c          	mov    %eax,0xc(%esp)
f012466b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f012466f:	89 f3                	mov    %esi,%ebx
f0124671:	89 fa                	mov    %edi,%edx
f0124673:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0124677:	89 34 24             	mov    %esi,(%esp)
f012467a:	85 c0                	test   %eax,%eax
f012467c:	75 1a                	jne    f0124698 <__umoddi3+0x48>
f012467e:	39 f7                	cmp    %esi,%edi
f0124680:	0f 86 a2 00 00 00    	jbe    f0124728 <__umoddi3+0xd8>
f0124686:	89 c8                	mov    %ecx,%eax
f0124688:	89 f2                	mov    %esi,%edx
f012468a:	f7 f7                	div    %edi
f012468c:	89 d0                	mov    %edx,%eax
f012468e:	31 d2                	xor    %edx,%edx
f0124690:	83 c4 1c             	add    $0x1c,%esp
f0124693:	5b                   	pop    %ebx
f0124694:	5e                   	pop    %esi
f0124695:	5f                   	pop    %edi
f0124696:	5d                   	pop    %ebp
f0124697:	c3                   	ret    
f0124698:	39 f0                	cmp    %esi,%eax
f012469a:	0f 87 ac 00 00 00    	ja     f012474c <__umoddi3+0xfc>
f01246a0:	0f bd e8             	bsr    %eax,%ebp
f01246a3:	83 f5 1f             	xor    $0x1f,%ebp
f01246a6:	0f 84 ac 00 00 00    	je     f0124758 <__umoddi3+0x108>
f01246ac:	bf 20 00 00 00       	mov    $0x20,%edi
f01246b1:	29 ef                	sub    %ebp,%edi
f01246b3:	89 fe                	mov    %edi,%esi
f01246b5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f01246b9:	89 e9                	mov    %ebp,%ecx
f01246bb:	d3 e0                	shl    %cl,%eax
f01246bd:	89 d7                	mov    %edx,%edi
f01246bf:	89 f1                	mov    %esi,%ecx
f01246c1:	d3 ef                	shr    %cl,%edi
f01246c3:	09 c7                	or     %eax,%edi
f01246c5:	89 e9                	mov    %ebp,%ecx
f01246c7:	d3 e2                	shl    %cl,%edx
f01246c9:	89 14 24             	mov    %edx,(%esp)
f01246cc:	89 d8                	mov    %ebx,%eax
f01246ce:	d3 e0                	shl    %cl,%eax
f01246d0:	89 c2                	mov    %eax,%edx
f01246d2:	8b 44 24 08          	mov    0x8(%esp),%eax
f01246d6:	d3 e0                	shl    %cl,%eax
f01246d8:	89 44 24 04          	mov    %eax,0x4(%esp)
f01246dc:	8b 44 24 08          	mov    0x8(%esp),%eax
f01246e0:	89 f1                	mov    %esi,%ecx
f01246e2:	d3 e8                	shr    %cl,%eax
f01246e4:	09 d0                	or     %edx,%eax
f01246e6:	d3 eb                	shr    %cl,%ebx
f01246e8:	89 da                	mov    %ebx,%edx
f01246ea:	f7 f7                	div    %edi
f01246ec:	89 d3                	mov    %edx,%ebx
f01246ee:	f7 24 24             	mull   (%esp)
f01246f1:	89 c6                	mov    %eax,%esi
f01246f3:	89 d1                	mov    %edx,%ecx
f01246f5:	39 d3                	cmp    %edx,%ebx
f01246f7:	0f 82 87 00 00 00    	jb     f0124784 <__umoddi3+0x134>
f01246fd:	0f 84 91 00 00 00    	je     f0124794 <__umoddi3+0x144>
f0124703:	8b 54 24 04          	mov    0x4(%esp),%edx
f0124707:	29 f2                	sub    %esi,%edx
f0124709:	19 cb                	sbb    %ecx,%ebx
f012470b:	89 d8                	mov    %ebx,%eax
f012470d:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0124711:	d3 e0                	shl    %cl,%eax
f0124713:	89 e9                	mov    %ebp,%ecx
f0124715:	d3 ea                	shr    %cl,%edx
f0124717:	09 d0                	or     %edx,%eax
f0124719:	89 e9                	mov    %ebp,%ecx
f012471b:	d3 eb                	shr    %cl,%ebx
f012471d:	89 da                	mov    %ebx,%edx
f012471f:	83 c4 1c             	add    $0x1c,%esp
f0124722:	5b                   	pop    %ebx
f0124723:	5e                   	pop    %esi
f0124724:	5f                   	pop    %edi
f0124725:	5d                   	pop    %ebp
f0124726:	c3                   	ret    
f0124727:	90                   	nop
f0124728:	89 fd                	mov    %edi,%ebp
f012472a:	85 ff                	test   %edi,%edi
f012472c:	75 0b                	jne    f0124739 <__umoddi3+0xe9>
f012472e:	b8 01 00 00 00       	mov    $0x1,%eax
f0124733:	31 d2                	xor    %edx,%edx
f0124735:	f7 f7                	div    %edi
f0124737:	89 c5                	mov    %eax,%ebp
f0124739:	89 f0                	mov    %esi,%eax
f012473b:	31 d2                	xor    %edx,%edx
f012473d:	f7 f5                	div    %ebp
f012473f:	89 c8                	mov    %ecx,%eax
f0124741:	f7 f5                	div    %ebp
f0124743:	89 d0                	mov    %edx,%eax
f0124745:	e9 44 ff ff ff       	jmp    f012468e <__umoddi3+0x3e>
f012474a:	66 90                	xchg   %ax,%ax
f012474c:	89 c8                	mov    %ecx,%eax
f012474e:	89 f2                	mov    %esi,%edx
f0124750:	83 c4 1c             	add    $0x1c,%esp
f0124753:	5b                   	pop    %ebx
f0124754:	5e                   	pop    %esi
f0124755:	5f                   	pop    %edi
f0124756:	5d                   	pop    %ebp
f0124757:	c3                   	ret    
f0124758:	3b 04 24             	cmp    (%esp),%eax
f012475b:	72 06                	jb     f0124763 <__umoddi3+0x113>
f012475d:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0124761:	77 0f                	ja     f0124772 <__umoddi3+0x122>
f0124763:	89 f2                	mov    %esi,%edx
f0124765:	29 f9                	sub    %edi,%ecx
f0124767:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f012476b:	89 14 24             	mov    %edx,(%esp)
f012476e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0124772:	8b 44 24 04          	mov    0x4(%esp),%eax
f0124776:	8b 14 24             	mov    (%esp),%edx
f0124779:	83 c4 1c             	add    $0x1c,%esp
f012477c:	5b                   	pop    %ebx
f012477d:	5e                   	pop    %esi
f012477e:	5f                   	pop    %edi
f012477f:	5d                   	pop    %ebp
f0124780:	c3                   	ret    
f0124781:	8d 76 00             	lea    0x0(%esi),%esi
f0124784:	2b 04 24             	sub    (%esp),%eax
f0124787:	19 fa                	sbb    %edi,%edx
f0124789:	89 d1                	mov    %edx,%ecx
f012478b:	89 c6                	mov    %eax,%esi
f012478d:	e9 71 ff ff ff       	jmp    f0124703 <__umoddi3+0xb3>
f0124792:	66 90                	xchg   %ax,%ax
f0124794:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0124798:	72 ea                	jb     f0124784 <__umoddi3+0x134>
f012479a:	89 d9                	mov    %ebx,%ecx
f012479c:	e9 62 ff ff ff       	jmp    f0124703 <__umoddi3+0xb3>
